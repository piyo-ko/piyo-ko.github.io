<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<link rel="stylesheet" href="sicp.css" type="text/css">
	<base target="_top">
	<title>Structure and Interpretation of Computer Programs: SICPç§è¨³</title>
</head>

<body>

<div class="idx-bar">
<nav>
<a href="https://twitter.com/share" class="twitter-share-button" data-lang="ja">ãƒ„ã‚¤ãƒ¼ãƒˆ</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
<span class="status">æ¨æ•²å¾…ã¡</span>
[
<a href="00_cover.html">å…ˆé ­ã¸</a> |
<a href="13_chap2.html">å‰ã¸</a> |
<a href="15_sec2_2.html">æ¬¡ã¸</a> | 
<a href="04_toc.html#%_toc_start">ç›®æ¬¡</a> |
<a href="38_index.html#%_index_start">ç´¢å¼•</a>
] [<a href="99_about.html">ã“ã®å¯¾è¨³ç‰ˆã«ã¤ã„ã¦</a> | <a href="../index.html">ãƒ›ãƒ¼ãƒ </a>]
[
Â§<a href="#%_sec_2.1">2.1</a>
Â§<a href="#%_sec_2.1.1">2.1.1</a>
ğŸ“š<a href="#%_sec_Temp_132">&hellip;</a>
ğŸ“š<a href="#%_sec_Temp_134">&hellip;</a>
ğŸ“<a href="#%_thm_2.1">2.1</a>
Â§<a href="#%_sec_2.1.2">2.1.2</a>
ğŸ¨<a href="#%_fig_2.1">2.1</a>
ğŸ“<a href="#%_thm_2.2">2.2</a>
ğŸ“<a href="#%_thm_2.3">2.3</a>
Â§<a href="#%_sec_2.1.3">2.1.3</a>
ğŸ“<a href="#%_thm_2.4">2.4</a>
ğŸ“<a href="#%_thm_2.5">2.5</a>
ğŸ“<a href="#%_thm_2.6">2.6</a>
Â§<a href="#%_sec_2.1.4">2.1.4</a>
ğŸ“<a href="#%_thm_2.7">2.7</a>
ğŸ“<a href="#%_thm_2.8">2.8</a>
ğŸ“<a href="#%_thm_2.9">2.9</a>
ğŸ“<a href="#%_thm_2.10">2.10</a>
ğŸ“<a href="#%_thm_2.11">2.11</a>
ğŸ“<a href="#%_thm_2.12">2.12</a>
ğŸ“<a href="#%_thm_2.13">2.13</a>
ğŸ“<a href="#%_thm_2.14">2.14</a>
ğŸ“<a href="#%_thm_2.15">2.15</a>
ğŸ“<a href="#%_thm_2.16">2.16</a>
<a href="#footnotes">è„šæ³¨</a>
]
</nav>
</div>

<div class="main-txt">



<a name="%_sec_2.1"></a>
<h2 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_2.1">2.1  Introduction to Data Abstraction</a></h2>
<h2 class="trans" lang="ja">2.1 ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–åºè«–</h2>

<p class="orig" lang="en">
In section <a href="10_sec1_1.html#%_sec_1.1.8">1.1.8</a>, we noted
that a procedure used as an element in creating a more complex
procedure could be regarded not only as a collection of particular
operations but also as a procedural abstraction.  That is, the details
of how the procedure was implemented could be suppressed, and the
particular procedure itself could be replaced by any other procedure
with the same overall behavior.  In other words, we could make an
abstraction that would separate the way the procedure would be used
from the details of how the procedure would be implemented in terms of
more primitive procedures.  The analogous notion for compound data is
called <a name="%_idx_1280"></a><em>data abstraction</em>.  Data abstraction is a methodology that
enables us to isolate how a compound data object is used from the
details of how it is constructed from more primitive data objects.
</p>

<p class="trans" lang="ja">
ã‚ˆã‚Šè¤‡é›‘ãªæ‰‹ç¶šãã‚’ä½œæˆã™ã‚‹éš›ã®è¦ç´ ã¨ã—ã¦ä½¿ã‚ã‚Œã‚‹æ‰‹ç¶šãã¯ã€ç‰¹å®šã®æ¼”ç®—ã®é›†ã¾ã‚Šã¨è¦‹ãªã—å¾—ã‚‹ã ã‘ã§ãªãã€æ‰‹ç¶šãçš„æŠ½è±¡åŒ–ã¨ã‚‚è¦‹ãªã—å¾—ã‚‹ã®ã ã€ã¨ã„ã†ã“ã¨ã‚’ã€<a href="10_sec1_1.html#%_sec_1.1.8">1.1.8</a>ç¯€ã§è¿°ã¹ãŸã€‚
ã¤ã¾ã‚Šã€æ‰‹ç¶šããŒã©ã®ã‚ˆã†ã«å®Ÿè£…ã•ã‚Œã¦ã„ãŸã®ã‹ã€ã¨ã„ã†è©³ç´°ã¯éš ã•ã‚Œå¾—ã‚‹ã—ã€ç‰¹å®šã®æ‰‹ç¶šãè‡ªä½“ãŒã€ã¾ã£ãŸãåŒã˜æŒ¯ã‚‹èˆã„ã‚’ã™ã‚‹ä»»æ„ã®ä»–ã®æ‰‹ç¶šãã«ç½®ãæ›ãˆã‚‰ã‚Œå¾—ã‚‹ã€‚
æ›è¨€ã™ã‚Œã°ã€æ‰‹ç¶šããŒä½¿ã‚ã‚Œã‚‹ã ã‚ã†æ–¹æ³•ã‚’ã€æ‰‹ç¶šããŒã‚ˆã‚ŠåŸå§‹çš„ãªæ‰‹ç¶šãã‚’ç”¨ã„ã¦ã©ã®ã‚ˆã†ã«å®Ÿè£…ã•ã‚Œã‚‹ã ã‚ã†ã‹ã¨ã„ã†è©³ç´°ã‹ã‚‰ã€åˆ†é›¢ã™ã‚‹ã§ã‚ã‚ã†æŠ½è±¡æ¦‚å¿µã‚’ã€ç§ãŸã¡ã¯ä½œã‚Œã‚‹ã ã‚ã†ã€‚
è¤‡åˆçš„ãƒ‡ãƒ¼ã‚¿ã«ã¤ã„ã¦ã®é¡ä¼¼ã®æ¦‚å¿µã¯ã€<em>ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–</em>ã¨å‘¼ã°ã‚Œã‚‹ã€‚
ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ã¨ã¯ã€è¤‡åˆçš„ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä½¿ã‚ã‚Œæ–¹ã‚’ã€è¤‡åˆçš„ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚ˆã‚ŠåŸå§‹çš„ãªãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ã©ã®ã‚ˆã†ã«æ§‹ç¯‰ã•ã‚Œã¦ã„ã‚‹ã®ã‹ã€ã¨ã„ã†è©³ç´°ã‹ã‚‰ã€åˆ‡ã‚Šé›¢ã™ã“ã¨ã‚’å¯èƒ½ã«ã—ã¦ãã‚Œã‚‹æ–¹æ³•è«–ãªã®ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
The basic idea of data abstraction is to structure the programs that
are to use compound data objects so that they operate on <a name="%_idx_1282"></a><a name="%_idx_1284"></a>``abstract
data.'' That is, our programs should use data in such a way as to make
no assumptions about the data that are not strictly necessary for
performing the task at hand.  At the same time, a <a name="%_idx_1286"></a><a name="%_idx_1288"></a>``concrete'' data
representation is defined independent of the programs that use
the data.  The interface between these two parts of our system will be
a set of procedures, called <a name="%_idx_1290"></a><em>selectors</em> and <a name="%_idx_1292"></a><em>constructors</em>,
that implement the abstract data in terms of the concrete
representation.  To illustrate this technique, we will consider how to
design a set of procedures for manipulating rational numbers.
</p>

<p class="trans" lang="ja">
ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ã®åŸºæœ¬çš„ãªè€ƒãˆã¯ã€è¤‡åˆçš„ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½¿ã†ã“ã¨ã«ãªã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ã€ã€ŒæŠ½è±¡ãƒ‡ãƒ¼ã‚¿ã€ä¸Šã§å‹•ä½œã™ã‚‹ã‚ˆã†ã«ã€æ§‹ç¯‰ã™ã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚
ã¤ã¾ã‚Šã€ãƒ‡ãƒ¼ã‚¿ã«ã¤ã„ã¦ã¯ã€ç›®ä¸‹ã®èª²é¡Œã‚’å®Ÿè¡Œã™ã‚‹ãŸã‚ã«çµ¶å¯¾ã«å¿…è¦ã ã¨ã„ã†ã‚ã‘ã§ã¯ãªã„æƒ³å®šã‚’ã—ãªã„ã€ã¨ã„ã†ã‚ˆã†ãªæ–¹æ³•ã§ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ã†ã¹ãã§ã‚ã‚‹ã€‚
åŒæ™‚ã«ã€ã€Œå…·ä½“çš„ãªã€ãƒ‡ãƒ¼ã‚¿è¡¨ç¾ã¯ã€ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ã†ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¨ã¯ã©ãã‚Šã¤ã«å®šç¾©ã•ã‚Œã‚‹ã€‚
ç§ãŸã¡ã®ã‚·ã‚¹ãƒ†ãƒ ã«ãŠã‘ã‚‹ã“ã‚Œã‚‰äºŒã¤ã®éƒ¨åˆ†ã®é–“ã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ã‚¤ã‚¹ã¯ã€å…·ä½“çš„ãªè¡¨ç¾ã‚’ç”¨ã„ã¦æŠ½è±¡çš„ãªãƒ‡ãƒ¼ã‚¿ã‚’å®Ÿè£…ã™ã‚‹æ‰‹ç¶šãâ€”â€”<em>ã‚»ãƒ¬ã‚¯ã‚¿</em>ãŠã‚ˆã³<em>ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿</em>ã¨å‘¼ã°ã‚Œã‚‹ã‚‚ã®â€”â€”ã®é›†åˆã¨ãªã‚‹ã ã‚ã†ã€‚
ã“ã®æŠ€æ³•ã‚’èª¬æ˜ã™ã‚‹ãŸã‚ã«ã€ç§ãŸã¡ã¯ã€æœ‰ç†æ•°ã‚’æ“ä½œã™ã‚‹ãŸã‚ã®æ‰‹ç¶šãã®é›†åˆã‚’è¨­è¨ˆã™ã‚‹æ–¹æ³•ã‚’è€ƒãˆã‚‹ã“ã¨ã«ã—ã‚ˆã†ã€‚
</p>

<a name="%_sec_2.1.1"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_2.1.1">2.1.1  Example: Arithmetic Operations for Rational Numbers</a></h3>
<h3 class="trans" lang="ja">2.1.1  ä¾‹: æœ‰ç†æ•°ã«å¯¾ã™ã‚‹ç®—è¡“æ¼”ç®—</h3>

<p class="orig" lang="en">
<a name="%_idx_1294"></a><a name="%_idx_1296"></a><a name="%_idx_1298"></a>Suppose we want to do arithmetic with rational numbers.  We want to be
able to add, subtract, multiply, and divide them and to test whether
two rational numbers are equal.
</p>

<p class="trans" lang="ja">
ç§ãŸã¡ã¯æœ‰ç†æ•°ã‚’ä½¿ã£ã¦ç®—è¡“ãŒã—ãŸã„ã®ã ã€ã¨æƒ³å®šã—ã‚ˆã†ã€‚
ç§ãŸã¡ã¯ã€æœ‰ç†æ•°ã‚’è¶³ã—ãŸã‚Šã€å¼•ã„ãŸã‚Šã€æ›ã‘ãŸã‚Šã€å‰²ã£ãŸã‚Šã§ãã‚‹ã‚ˆã†ã§ã‚ã‚ŠãŸã„ã—ã€äºŒã¤ã®æœ‰ç†æ•°ãŒç­‰ã—ã„ã‹ã©ã†ã‹ã‚’èª¿ã¹ã‚‰ã‚Œã‚‹ã‚ˆã†ã§ã‚ã‚ŠãŸã„ã€‚
</p>

<p class="orig" lang="en">
Let us begin by assuming that we already have a way of constructing a
rational number from a numerator and a denominator.  We also assume
that, given a rational number, we have a way of extracting (or
selecting) its numerator and its denominator.  Let us further assume
that the constructor and selectors are available as procedures:
</p>

<p class="trans" lang="ja">
åˆ†å­ã¨åˆ†æ¯ã‹ã‚‰æœ‰ç†æ•°ã‚’æ§‹ç¯‰ã™ã‚‹æ–¹æ³•ãŒæ—¢ã«ã‚ã‚‹ã€ã¨æƒ³å®šã™ã‚‹ã“ã¨ã‹ã‚‰å§‹ã‚ã‚ˆã†ã€‚
ã¾ãŸã€ã‚ã‚‹æœ‰ç†æ•°ãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãã«ã€ãã®åˆ†å­ã¨åˆ†æ¯ã‚’æŠ½å‡º (ã¾ãŸã¯é¸æŠ) ã™ã‚‹æ–¹æ³•ã‚‚ã‚ã‚‹ã®ã ã€ã¨æƒ³å®šã—ã‚ˆã†ã€‚
ã•ã‚‰ã«ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¨ã‚»ãƒ¬ã‚¯ã‚¿ãŒã€æ¬¡ã®ã‚ˆã†ãªæ‰‹ç¶šãã¨ã—ã¦åˆ©ç”¨å¯èƒ½ã ã€ã¨æƒ³å®šã—ã‚ˆã†ã€‚
</p>

<ul class="orig" lang="en">
<a name="%_idx_1300"></a>
<li><tt>(make-rat &lt;<em>n</em>&gt; &lt;<em>d</em>&gt;)</tt> returns the
rational number whose  numerator is the integer <tt>&lt;<em>n</em>&gt;</tt>
and whose denominator is the integer <tt>&lt;<em>d</em>&gt;</tt>. </li>

<a name="%_idx_1302"></a>
<li><tt>(numer &lt;<em>x</em>&gt;)</tt> returns the numerator of the rational 
number <tt>&lt;<em>x</em>&gt;</tt>.</li>

<a name="%_idx_1304"></a>
<li><tt>(denom &lt;<em>x</em>&gt;)</tt> returns the denominator of the 
rational number <tt>&lt;<em>x</em>&gt;</tt>.</li>
</ul>

<ul class="trans" lang="ja">
<li><tt>(make-rat &lt;<em class="en">n</em>&gt; &lt;<em class="en">d</em>&gt;)</tt> ã¯ã€åˆ†å­ãŒ <tt>&lt;<em class="en">n</em>&gt;</tt> ã¨ã„ã†æ•´æ•°ã§ã‚ã‚Šåˆ†æ¯ãŒ <tt>&lt;<em class="en">d</em>&gt;</tt> ã¨ã„ã†æ•´æ•°ã§ã‚ã‚‹ã‚ˆã†ãªæœ‰ç†æ•°ã‚’è¿”ã™ã€‚</li>
<li><tt>(numer &lt;<em class="en">x</em>&gt;)</tt> ã¯ã€<tt>&lt;<em class="en">x</em>&gt;</tt> ã¨ã„ã†æœ‰ç†æ•°ã®åˆ†å­ã‚’è¿”ã™ã€‚</li>
<li><tt>(denom &lt;<em class="en">x</em>&gt;)</tt> ã¯ã€<tt>&lt;<em class="en">x</em>&gt;</tt> ã¨ã„ã†æœ‰ç†æ•°ã®åˆ†æ¯ã‚’è¿”ã™ã€‚</li>
</ul>

<p class="orig" lang="en">
We are using here a powerful strategy of synthesis: <a name="%_idx_1306"></a><em>wishful thinking</em>.
We haven't yet said how a rational number is represented, or how the
procedures <tt>numer</tt>, <tt>denom</tt>, and <tt>make-rat</tt> should be
implemented.  Even so, if we did have these three procedures, we could
then add, subtract, multiply, divide, and test equality by using the
following relations:
</p>

<p class="trans" lang="ja">
ç§ãŸã¡ã¯ã“ã“ã§ã€åˆæˆã«é–¢ã™ã‚‹å¼·åŠ›ãªæˆ¦ç•¥â€”â€”ã¤ã¾ã‚Šã€<em>å¸Œæœ›çš„è¦³æ¸¬</em>â€”â€”ã‚’ä½¿ã£ã¦ã„ã‚‹ã€‚
ç§ãŸã¡ã¯ã¾ã ã€æœ‰ç†æ•°ãŒã©ã†è¡¨ç¾ã•ã‚Œã‚‹ã®ã‹ã€ã«ã¤ã„ã¦ã‚‚è¿°ã¹ã¦ã„ãªã„ã—ã€<tt>numer</tt> ã¨ <tt>denom</tt> ã¨ <tt>make-rat</tt> ã¨ã„ã†æ‰‹ç¶šããŒã©ã†å®Ÿè£…ã•ã‚Œã‚‹ã¹ãã‹ã€ã«ã¤ã„ã¦ã‚‚è¿°ã¹ã¦ã„ãªã„ã€‚
ãŸã¨ãˆãã†ã§ã‚ã£ã¦ã‚‚ã€ã‚‚ã—ã“ã‚Œã‚‰ä¸‰ã¤ã®æ‰‹ç¶šããŒã‚ã‚Œã°ã€ä»¥ä¸‹ã®é–¢ä¿‚ã‚’ä½¿ã£ã¦ã€è¶³ã—ç®—ã€å¼•ãç®—ã€æ›ã‘ç®—ã€å‰²ã‚Šç®—ãŒã§ãã‚‹ã ã‚ã†ã—ã€ç­‰ã—ã„ã‹ã©ã†ã‹èª¿ã¹ã‚‹ã“ã¨ã‚‚ã§ãã‚‹ã ã‚ã†ã€‚
</p>

<figure>
<img src="ch2-Z-G-1.gif" border="0"><br>
<img src="ch2-Z-G-2.gif" border="0"><br>
<img src="ch2-Z-G-3.gif" border="0"><br>
<img src="ch2-Z-G-4.gif" border="0"><br>
<img src="ch2-Z-G-5.gif" border="0">
</figure>

<p class="orig" lang="en">
We can express these rules as procedures:</p>

<p class="trans" lang="ja">
ç§ãŸã¡ã¯ã“ã‚Œã‚‰ã®è¦å‰‡ã‚’æ‰‹ç¶šãã¨ã—ã¦è¡¨ç¾ã§ãã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_1308"></a>(define (add-rat x y)
  (make-rat (+ (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))
<a name="%_idx_1310"></a>(define (sub-rat x y)
  (make-rat (- (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))
<a name="%_idx_1312"></a>(define (mul-rat x y)
  (make-rat (* (numer x) (numer y))
            (* (denom x) (denom y))))
<a name="%_idx_1314"></a>(define (div-rat x y)
  (make-rat (* (numer x) (denom y))
            (* (denom x) (numer y))))
<a name="%_idx_1316"></a>(define (equal-rat? x y)
  (= (* (numer x) (denom y))
     (* (numer y) (denom x))))
</p>

<p class="orig" lang="en">
Now we have the operations on rational numbers defined in terms of the
selector and constructor procedures
<tt>numer</tt>, <tt>denom</tt>, and <tt>make-rat</tt>.
But we haven't yet defined these.
What we need is some way to glue together a numerator and a
denominator to form a rational
number.</p>

<p class="trans" lang="ja">
<tt>numer</tt> ã¨ <tt>denom</tt> ã¨ <tt>make-rat</tt> ã¨ã„ã†ã€ã‚»ãƒ¬ã‚¯ã‚¿ãŠã‚ˆã³ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§ã‚ã‚‹è«¸æ‰‹ç¶šãã‚’ä½¿ã£ã¦å®šç¾©ã•ã‚ŒãŸã€æœ‰ç†æ•°ä¸Šã®æ¼”ç®—ã‚’ã€ä»Šã‚„ç§ãŸã¡ã¯æ‰‹ã«ã—ã¦ã„ã‚‹ã€‚
ã—ã‹ã—ã€ç§ãŸã¡ã¯ã¾ã ã“ã‚Œã‚‰ã‚’å®šç¾©ã—ã¦ã„ãªã„ã€‚
ç§ãŸã¡ã«å¿…è¦ãªã‚‚ã®ã¯ã€åˆ†å­ã¨åˆ†æ¯ã‚’ãã£ã¤ã‘ã¦æœ‰ç†æ•°ã‚’ä½œã‚Šå‡ºã™ãŸã‚ã®ã€ä½•ã‚‰ã‹ã®æ–¹æ³•ã§ã‚ã‚‹ã€‚
</p>

<a name="%_sec_Temp_132"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_132">Pairs</a></h4>
<h4 class="trans" lang="ja">å¯¾</h4>

<p class="orig" lang="en">
To enable us to implement the concrete level of our data
abstraction, our language provides a compound structure called a <a name="%_idx_1318"></a><em>pair</em>, which can be constructed with the primitive procedure <a name="%_idx_1320"></a><a name="%_idx_1322"></a><tt>cons</tt>.  This procedure takes two arguments and returns a compound data
object that contains the two arguments as parts.  Given a pair, we can
extract the parts using the primitive procedures <a name="%_idx_1324"></a><a name="%_idx_1326"></a><tt>car</tt> and <a name="%_idx_1328"></a><a name="%_idx_1330"></a><tt>cdr</tt>.<a name="call_footnote_Temp_133" href="#footnote_Temp_133"><sup><small>2</small></sup></a> Thus, we can use <tt>cons</tt>, <tt>car</tt>, and <tt>cdr</tt> as follows:</p>

<p class="trans" lang="ja">
ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ã«ãŠã‘ã‚‹å…·ä½“çš„ãªãƒ¬ãƒ™ãƒ«ã‚’å®Ÿè£…ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã«ã€ç§ãŸã¡ã®è¨€èªã¯ã€<em><ruby><rb>å¯¾</rb><rp> (</rp><rt>ãƒšã‚¢</rt><rp>)</rp></em> ã¨å‘¼ã°ã‚Œã‚‹è¤‡åˆçš„æ§‹é€ ä½“â€”â€”<tt>cons</tt> ã¨ã„ã†åŸå§‹çš„æ‰‹ç¶šãã‚’ä½¿ã£ã¦æ§‹ç¯‰ã§ãã‚‹â€”â€”ã‚’ä¾›çµ¦ã—ã¦ã„ã‚‹ã€‚
ã“ã®æ‰‹ç¶šãã¯ã€äºŒã¤ã®å¼•æ•°ã‚’ã¨ã‚Šã€ãã®äºŒã¤ã®å¼•æ•°ã‚’éƒ¨å“ã¨ã—ã¦å«ã‚€ã‚ˆã†ãªè¤‡åˆçš„ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã™ã€‚
å¯¾ã‚’ä¸ãˆã‚‰ã‚ŒãŸã¨ãã«ã¯ã€<tt>car</tt> ã¨ <tt>cdr</tt> ã¨ã„ã†åŸå§‹çš„æ‰‹ç¶šãã‚’ä½¿ã£ã¦ã€ãã‚Œã‚‰ã®éƒ¨å“ã‚’æŠ½å‡ºã§ãã‚‹<a href="#footnote_Temp_133"><sup><small>2</small></sup></a>ã€‚
ã‚ˆã£ã¦ã€ç§ãŸã¡ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã« <tt>cons</tt> ã¨ <tt>car</tt> ã¨ <tt>cdr</tt> ã‚’ä½¿ã†ã“ã¨ãŒã§ãã‚‹ã€‚
</p>

<p class="lisp">(define x (cons 1 2))

(car x)
<i>1</i>

(cdr x)
<i>2</i>
</p>

<p class="orig" lang="en">
Notice that a pair is a data object that can be given a name and
manipulated, just like a primitive data object.  Moreover, <tt>cons</tt>
can be used to form pairs whose elements are pairs, and so on:</p>

<p class="trans" lang="ja">
åŸå§‹çš„ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã¡ã‚‡ã†ã©åŒã˜ã‚ˆã†ã«ã€å¯¾ãŒã€åå‰ã‚’ä¸ãˆã‚‹ã“ã¨ã‚‚æ“ä½œã™ã‚‹ã“ã¨ã‚‚ã§ãã‚‹ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãªã®ã ã€ã¨ã„ã†ã“ã¨ã«æ³¨æ„ã—ã¦ã»ã—ã„ã€‚
ã•ã‚‰ã«ã€<tt>cons</tt> ã¯ã€è¦ç´ ãŒå¯¾ã§ã‚ã‚‹ã‚ˆã†ãªå¯¾ãªã©ã‚’ä½œã‚Šå‡ºã™ãŸã‚ã«ã‚‚ã€ä½¿ã‚ã‚Œå¾—ã‚‹ã€‚
</p>

<p class="lisp">(define x (cons 1 2))

(define y (cons 3 4))

(define z (cons x y))

(car (car z))
<i>1</i>

(car (cdr z))
<i>3</i>
</p>

<p class="orig" lang="en">
In section <a href="15_sec2_2.html#%_sec_2.2">2.2</a> we will see how this ability to
combine pairs means that pairs can be used as general-purpose building
blocks to create all sorts of complex data structures.  The single
compound-data primitive <em>pair</em>, implemented by the procedures <tt>cons</tt>, <tt>car</tt>, and <tt>cdr</tt>, is the only glue we need.  Data
objects constructed from pairs are called <a name="%_idx_1342"></a><a name="%_idx_1344"></a><em>list-structured</em> data.</p>

<p class="trans" lang="ja">
å¯¾åŒå£«ã‚’çµåˆã™ã‚‹ãŸã‚ã®ã“ã®èƒ½åŠ›ãŒã€ã©ã†ã„ã†ã‚ã‘ã§ã€ã‚ã‚‰ã‚†ã‚‹ç¨®é¡ã®è¤‡é›‘ãªãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’ä½œæˆã™ã‚‹ãŸã‚ã®æ±ç”¨çš„ãªåŸºæœ¬çš„æ§‹æˆè¦ç´ ã¨ã—ã¦å¯¾ãŒä½¿ãˆã‚‹ã¨ã„ã†ã“ã¨ã‚’æ„å‘³ã™ã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’ã€<a href="15_sec2_2.html#%_sec_2.2">2.2</a>ç¯€ã§è¦‹ã‚‹ã“ã¨ã«ã—ã‚ˆã†ã€‚
ãŸã£ãŸä¸€ã¤ã®è¤‡åˆçš„ãƒ‡ãƒ¼ã‚¿ã®ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã§ã‚ã‚‹<em>å¯¾</em>â€”â€”<tt>cons</tt> ã¨ <tt>car</tt> ã¨ <tt>cdr</tt> ã¨ã„ã†æ‰‹ç¶šãã«ã‚ˆã£ã¦å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹â€”â€”ãŒã€ç§ãŸã¡ã«å¿…è¦ãªå”¯ä¸€ã®æ¥ç€å‰¤ã§ã‚ã‚‹ã€‚
å¯¾ã‹ã‚‰æ§‹ç¯‰ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€<em>ãƒªã‚¹ãƒˆæ§‹é€ </em>ãƒ‡ãƒ¼ã‚¿ã¨å‘¼ã°ã‚Œã‚‹ã€‚
</p>

<a name="%_sec_Temp_134"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_134">Representing rational numbers</a></h4>
<h4 class="trans" lang="ja">æœ‰ç†æ•°ã‚’è¡¨ç¾ã™ã‚‹</h4>

<p class="orig" lang="en">
<a name="%_idx_1346"></a>Pairs offer a natural way to complete the rational-number system.
Simply represent a rational number as a pair of two integers: a
numerator and a denominator.  Then <tt>make-rat</tt>, <tt>numer</tt>, and
<tt>denom</tt> are readily implemented as follows:<a name="call_footnote_Temp_135" href="#footnote_Temp_135"><sup><small>3</small></sup></a></p>

<p class="trans" lang="ja">
å¯¾ã¯ã€æœ‰ç†æ•°ã‚·ã‚¹ãƒ†ãƒ ã‚’å®Œæˆã•ã›ã‚‹ãŸã‚ã®è‡ªç„¶ãªæ–¹æ³•ã‚’ä¸ãˆã¦ãã‚Œã‚‹ã€‚
å˜ç´”ã«ã€æœ‰ç†æ•°ã‚’ã€äºŒã¤ã®æ•´æ•°â€”â€”ã¤ã¾ã‚Šåˆ†å­ã¨åˆ†æ¯â€”â€”ã®å¯¾ã¨ã—ã¦è¡¨ç¾ã›ã‚ˆã€‚
ã™ã‚‹ã¨ã€<tt>make-rat</tt> ã¨ <tt>numer</tt> ã¨ <tt>denom</tt> ã¯ã€ã™ãã«ä»¥ä¸‹ã®ã¨ãŠã‚Šå®Ÿè£…ã•ã‚Œã‚‹<a href="#footnote_Temp_135"><sup><small>3</small></sup></a>ã€‚
</p>

<p class="lisp"><a name="%_idx_1348"></a>(define (make-rat n d) (cons n d))

<a name="%_idx_1350"></a>(define (numer x) (car x))

<a name="%_idx_1352"></a>(define (denom x) (cdr x))
</p>

<p class="orig" lang="en">
Also, in order to display the results of our computations,
we can <a name="%_idx_1354"></a>print rational numbers by printing the numerator, a
slash, and the denominator:<a name="call_footnote_Temp_136" href="#footnote_Temp_136"><sup><small>4</small></sup></a></p>

<p class="trans" lang="ja">
ã¾ãŸã€è¨ˆç®—ã®çµæœã‚’è¡¨ç¤ºã™ã‚‹ãŸã‚ã«ã€åˆ†å­ã¨ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã¨åˆ†æ¯ã‚’å°å­—ã™ã‚‹ã“ã¨ã§æœ‰ç†æ•°ã‚’å°å­—ã™ã‚‹ã“ã¨ãŒã§ãã‚‹<a href="#footnote_Temp_136"><sup><small>4</small></sup></a>ã€‚
</p>

<p class="lisp"><a name="%_idx_1370"></a>(define (print-rat x)
  (newline)
  (display (numer x))
  (display &quot;/&quot;)
  (display (denom x)))
</p>

<p class="orig" lang="en">
Now we can try our rational-number procedures:
</p>

<p class="trans" lang="ja">
ã•ã¦ã€ã“ã‚Œã§ç§ãŸã¡ã¯æœ‰ç†æ•°ã«ã¤ã„ã¦ã®æ‰‹ç¶šãã‚’è©¦ã™ã“ã¨ãŒã§ãã‚‹ã€‚
</p>

<p class="lisp">(define one-half (make-rat 1 2))

(print-rat one-half)
<i>1/2</i>

(define one-third (make-rat 1 3))
(print-rat (add-rat one-half one-third))
<i>5/6</i>

(print-rat (mul-rat one-half one-third))
<i>1/6</i>

(print-rat (add-rat one-third one-third))
<i>6/9</i>
</p>

<p class="orig" lang="en">
<a name="%_idx_1372"></a><a name="%_idx_1374"></a>As the final example shows, our rational-number implementation does
not reduce rational numbers to lowest terms.  We can remedy this by
changing <tt>make-rat</tt>. If we have a <a name="%_idx_1376"></a><tt>gcd</tt> procedure like the one
in section <a href="11_sec1_2.html#%_sec_1.2.5">1.2.5</a> that produces the greatest common divisor of two
integers, we can use <tt>gcd</tt> to reduce the numerator and the
denominator to lowest terms before constructing the pair:
</p>

<p class="trans" lang="ja">
æœ€å¾Œã®ä¾‹ãŒç¤ºã™ã¨ãŠã‚Šã€ç§ãŸã¡ã®æœ‰ç†æ•°ã®å®Ÿè£…ã¯ã€æœ‰ç†æ•°ã‚’ç´„åˆ†ã—ãªã„ã€‚
<tt>make-rat</tt> ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ã§ã€ã“ã®ç‚¹ã‚’æ”¹å–„ã§ãã‚‹ã€‚
ã‚‚ã—ã€äºŒã¤ã®æ•´æ•°ã®æœ€å¤§å…¬ç´„æ•°ã‚’ä½œã‚Šå‡ºã™ã€<a href="11_sec1_2.html#%_sec_1.2.5">1.2.5</a>ç¯€ã®ã‚‚ã®ã¨ä¼¼ãŸã‚ˆã†ãªã€<tt>gcd</tt> ã¨ã„ã†æ‰‹ç¶šããŒã‚ã‚Œã°ã€å¯¾ã‚’æ§‹ç¯‰ã™ã‚‹å‰ã«ã€<tt>gcd</tt> ã‚’ä½¿ã£ã¦åˆ†å­ã¨åˆ†æ¯ã‚’ç´„åˆ†ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_1378"></a>(define (make-rat n d)
  (let ((g (gcd n d)))
    (cons (/ n g) (/ d g))))
</p>

<p class="orig" lang="en">
Now we have
</p>

<p class="trans" lang="ja">
ã™ã‚‹ã¨ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚‹ã€‚
</p>

<p class="lisp">(print-rat (add-rat one-third one-third))
<i>2/3</i>
</p>

<p class="orig" lang="en">
as desired.  This modification was accomplished by changing the
constructor <tt>make-rat</tt> without changing any of the procedures
(such as <tt>add-rat</tt> and <tt>mul-rat</tt>)
that implement the actual operations.
</p>

<p class="trans" lang="ja">
ã“ã‚Œã¯æ‰€æœ›ã®ã¨ãŠã‚Šã§ã‚ã‚‹ã€‚
ã“ã®ä¿®æ­£ã¯ã€å®Ÿéš›ã®æ¼”ç®—ã‚’å®Ÿè£…ã™ã‚‹æ‰‹ç¶šã (ãŸã¨ãˆã° <tt>add-rat</tt> ã‚„ <tt>mul-rat</tt> ãªã©) ã®ã„ãšã‚Œã‚’ã‚‚å¤‰æ›´ã›ãšã«ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãŸã‚‹ <tt>make-rat</tt> ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€é”æˆã•ã‚ŒãŸã€‚
</p>

<p class="orig" lang="en"><a name="%_thm_2.1"></a>
<b>Exercise 2.1.</b>  Define a better version of <tt>make-rat</tt> that
handles both positive and negative arguments.  <tt>Make-rat</tt> should
normalize the sign so that if the rational number is positive, both
the numerator and denominator are positive, and if the rational number
is negative, only the numerator is negative.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.1.</b> æ­£ã¨è² ã®ä¸¡æ–¹ã®å¼•æ•°ã‚’ã†ã¾ãæ‰±ã†ã‚ˆã†ãªã€<tt>make-rat</tt> ã®æ”¹å–„ç‰ˆã‚’å®šç¾©ã›ã‚ˆã€‚
<tt>make-rat</tt> ã¯ã€ã‚‚ã—æœ‰ç†æ•°ãŒæ­£ãªã‚‰åˆ†å­ã¨åˆ†æ¯ã®ä¸¡æ–¹ãŒæ­£ã¨ãªã‚‹ã‚ˆã†ã«ã€ãã—ã¦ã€ã‚‚ã—æœ‰ç†æ•°ãŒè² ãªã‚‰åˆ†å­ã®ã¿ãŒè² ã¨ãªã‚‹ã‚ˆã†ã«ã€ç¬¦å·ã‚’æ­£è¦åŒ–ã™ã¹ãã§ã‚ã‚‹ã€‚
</p>

<p class="exercise">
(define (make-rat n d) 
  (cond
    ((and (&gt;= n 0) (&gt; d 0)) (cons n d))
    ((and (&gt;= n 0) (&lt; d 0)) (cons (- n) d))
    ((and (&lt; n 0) (&gt; d 0)) (cons n d))
    ((and (&lt; n 0) (&lt; d 0)) (cons (- n) (- d)))
    (else (display "*** error ***"))))

<span class="ex_comment">
</span></p>

<a name="%_sec_2.1.2"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_2.1.2">2.1.2  Abstraction Barriers</a></h3>
<h3 class="trans" lang="ja">2.1.2 æŠ½è±¡åŒ–ã®é˜²å£</h3>

<p class="orig" lang="en">
<a name="%_idx_1380"></a>Before continuing with more examples of compound data and data
abstraction, let us consider some of the issues raised by the
rational-number example.  We defined the rational-number operations in
terms of a constructor <tt>make-rat</tt> and selectors <tt>numer</tt> and
<tt>denom</tt>.  In general, the underlying idea of data abstraction is
to identify for each type of data object a basic set of operations in
terms of which all manipulations of data objects of that type will be
expressed, and then to use only those operations in manipulating the
data.
</p>

<p class="trans" lang="ja">
è¤‡åˆçš„ãƒ‡ãƒ¼ã‚¿ã¨ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ã«ã¤ã„ã¦ã®æ›´ãªã‚‹ä¾‹ã‚’ç¶šã‘ã‚‹å‰ã«ã€æœ‰ç†æ•°ã®ä¾‹ã§æŒã¡ä¸ŠãŒã£ãŸå•é¡Œã®ã„ãã¤ã‹ã«ã¤ã„ã¦è€ƒãˆã¦ã¿ã‚ˆã†ã€‚
ç§ãŸã¡ã¯ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§ã‚ã‚‹ <tt>make-rat</tt> ã¨ã€ã‚»ãƒ¬ã‚¯ã‚¿ã§ã‚ã‚‹ <tt>numer</tt> ãŠã‚ˆã³ <tt>denom</tt> ã‚’ç”¨ã„ã¦ã€æœ‰ç†æ•°ã®æ¼”ç®—ã‚’å®šç¾©ã—ãŸã€‚
ä¸€èˆ¬ã«ã€ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ã®æ ¹åº•ã«ã‚ã‚‹æ¦‚å¿µã¨ã¯ã€å„å‹ã®ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¤ã„ã¦ã€ãã®å‹ã®ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¤ã„ã¦ã®ã©ã®æ“ä½œã‚’è¡¨ç¾ã™ã‚‹ã®ã«ã‚‚ä½¿ã‚ã‚Œã‚‹ã§ã‚ã‚ã†ã‚ˆã†ãªåŸºæœ¬çš„ãªæ¼”ç®—ã®é›†åˆã‚’ç‰¹å®šã™ã‚‹ã“ã¨ã€ãã—ã¦ã€ãƒ‡ãƒ¼ã‚¿ã‚’æ“ä½œã™ã‚‹éš›ã«ã¯ã€ãã‚Œã‚‰ã®æ¼”ç®—ã®ã¿ã‚’ä½¿ã†ã“ã¨ã€ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
We can envision the structure of the rational-number system as
shown in figure <a href="#%_fig_2.1">2.1</a>.  The
horizontal lines represent <em>abstraction barriers</em> that isolate
different ``levels'' of the system.  At each level, the barrier
separates the programs (above) that use the data abstraction from the
programs (below) that implement the data abstraction.  Programs that
use rational numbers manipulate them solely in terms of the procedures
supplied ``for public use'' by the rational-number package: <tt>add-rat</tt>, <tt>sub-rat</tt>, <tt>mul-rat</tt>, <tt>div-rat</tt>, and <tt>equal-rat?</tt>. These, in turn, are implemented solely in terms of the
<a name="%_idx_1382"></a><a name="%_idx_1384"></a>constructor and selectors <tt>make-rat</tt>, <tt>numer</tt>, and <tt>denom</tt>, which themselves are implemented in terms of pairs.  The
details of how pairs are implemented are irrelevant to the rest of the
rational-number package so long as pairs can be manipulated by the use
of <tt>cons</tt>, <tt>car</tt>, and <tt>cdr</tt>.  In effect, procedures at
each level are the interfaces that define the abstraction barriers and
connect the different levels.
</p>

<p class="trans" lang="ja">
ç§ãŸã¡ã¯ã€æœ‰ç†æ•°ã‚·ã‚¹ãƒ†ãƒ ã®æ§‹é€ ã‚’å›³<a href="#%_fig_2.1">2.1</a>ã®ã‚ˆã†ã«æ€ã„æãã“ã¨ãŒã§ãã‚‹ã€‚
æ¨ªç·šã¯ã€ã‚·ã‚¹ãƒ†ãƒ ã®ç•°ãªã‚‹ã€Œãƒ¬ãƒ™ãƒ«ã€é–“ã‚’éš”é›¢ã™ã‚‹ã€<em>æŠ½è±¡åŒ–ã®é˜²å£</em>ã‚’è¡¨ã™ã€‚
å„ãƒ¬ãƒ™ãƒ«ã§ã€é˜²å£ã¯ã€ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ã‚’åˆ©ç”¨ã™ã‚‹ (ä¸Šå´ã®) ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ã€ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ (ä¸‹å´ã®) ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‹ã‚‰åˆ†é›¢ã™ã‚‹ã€‚
æœ‰ç†æ•°ã‚’ä½¿ã†ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€æœ‰ç†æ•°ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã«ã‚ˆã‚Šã€Œä¸€èˆ¬åˆ©ç”¨ã®ãŸã‚ã«ã€æä¾›ã•ã‚ŒãŸæ‰‹ç¶šãâ€”â€”<tt>add-rat</tt> ã¨ <tt>sub-rat</tt> ã¨ <tt>mul-rat</tt> ã¨ <tt>div-rat</tt> ã¨ <tt>equal-rat?</tt>â€”â€”ã®ã¿ã‚’ä½¿ã£ã¦ã€æœ‰ç†æ•°ã‚’æ“ä½œã™ã‚‹ã€‚
ãã—ã¦ä»Šåº¦ã¯ã€ã“ã‚Œã‚‰ã®æ‰‹ç¶šããŒã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¨ã‚»ãƒ¬ã‚¯ã‚¿ãŸã‚‹ <tt>make-rat</tt> ã¨ <tt>numer</tt> ã¨ <tt>denom</tt> ã®ã¿ã‚’ç”¨ã„ã¦å®Ÿè£…ã•ã‚Œã¦ãŠã‚Šã€ã•ã‚‰ã«ä»Šåº¦ã¯ã€ã“ã‚Œã‚‰ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¨ã‚»ãƒ¬ã‚¯ã‚¿è‡ªä½“ãŒå¯¾ã‚’ä½¿ã£ã¦å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ã€‚
å¯¾ãŒã©ã†å®Ÿè£…ã•ã‚Œã‚‹ã‹ã¨ã„ã†è©³ç´°ã¯ã€<tt>cons</tt> ã¨ <tt>car</tt> ã¨ <tt>cdr</tt> ã‚’ç”¨ã„ã‚‹ã“ã¨ã«ã‚ˆã‚Šå¯¾ã‚’æ“ä½œã§ãã‚‹é™ã‚Šã¯ã€æœ‰ç†æ•°ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®æ®‹ã‚Šã®éƒ¨åˆ†ã«ã¯ç„¡é–¢ä¿‚ã§ã‚ã‚‹ã€‚
å®Ÿéš›ã€å„ãƒ¬ãƒ™ãƒ«ã®æ‰‹ç¶šãã¯ã€æŠ½è±¡åŒ–ã®é˜²å£ã‚’å®šç¾©ã™ã‚‹ã¨ã¨ã‚‚ã«ç•°ãªã‚‹ãƒ¬ãƒ™ãƒ«é–“ã‚’ã¤ãªãã€ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ã‚¤ã‚¹ãªã®ã§ã‚ã‚‹ã€‚
</p>

<a name="%_fig_2.1"></a>
<figure>
<img src="ch2-Z-G-6.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 2.1:</b>  Data-abstraction barriers in the rational-number package.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³2.1:</b> æœ‰ç†æ•°ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã«ãŠã‘ã‚‹ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ã®é˜²å£</figcaption>
</figure>

<p class="orig" lang="en">
This simple idea has many advantages.  One advantage is that it makes
programs much easier to maintain and to modify.  Any complex data
structure can be represented in a variety of ways with the primitive
data structures provided by a programming language.  Of course, the
choice of representation influences the programs that operate on it;
thus, if the representation were to be changed at some later time, all
such programs might have to be modified accordingly.  This task could
be time-consuming and expensive in the case of large programs unless
the dependence on the representation were to be confined by design to
a very few program modules.
</p>

<p class="trans" lang="ja">
ã“ã®ç°¡æ½”ãªè€ƒãˆæ–¹ã«ã¯å¤šãã®åˆ©ç‚¹ãŒã‚ã‚‹ã€‚
åˆ©ç‚¹ã®ä¸€ã¤ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ã‚ˆã‚Šä¿å®ˆã—ã‚„ã™ãã€ã‹ã¤ã€å¤‰æ›´ã—ã‚„ã™ãã™ã‚‹ã€ã¨ã„ã†ç‚¹ã ã€‚
ã©ã®è¤‡é›‘ãªãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚‚ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã«ã‚ˆã‚Šæä¾›ã•ã‚Œã‚‹åŸå§‹çš„ãªãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’ä½¿ã£ãŸæ§˜ã€…ãªæ–¹æ³•ã§è¡¨ç¾ã§ãã‚‹ã€‚
ã‚‚ã¡ã‚ã‚“ã€è¡¨ç¾ã®é¸æŠã¯ã€ãã®è¡¨ç¾ã®ä¸Šã§å‹•ä½œã™ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«å½±éŸ¿ã™ã‚‹ã€‚ã‚ˆã£ã¦ã€ã‚‚ã—ã€ã„ã¤ã‹å¾Œã®æ™‚ç‚¹ã§è¡¨ç¾ã‚’å¤‰ãˆã‚‹ã“ã¨ã«ãªã£ãŸã‚‰ã€ãã‚Œã«å¿œã˜ã¦ã€ã™ã¹ã¦ã®ãã®ã‚ˆã†ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’å¤‰æ›´ã—ãªãã¦ã¯ãªã‚‰ãªã‹ã‚‚ã—ã‚Œãªã„ã€‚
ã“ã®ä½œæ¥­ã¯ã€è¡¨ç¾ã¸ã®ä¾å­˜ãŒè¨­è¨ˆã«ã‚ˆã‚Šã”ãå°‘æ•°ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã ã‘ã«åˆ¶é™ã•ã‚Œã‚‹ã“ã¨ã«ãªã£ã¦ã„ãŸã®ã§ã‚‚ãªã„é™ã‚Šã€å¤§è¦æ¨¡ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®å ´åˆã«ãŠã„ã¦ã€æ™‚é–“ã‚’é£Ÿã†ã ã‚ã†ã—ã€é«˜ãã¤ãã ã‚ã†ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_1386"></a><a name="%_idx_1388"></a>For example, an alternate way to address the problem of reducing rational
numbers to lowest terms is to perform the reduction whenever we
access the parts of a rational number, rather than when we construct
it.  This leads to different constructor and selector procedures:
</p>

<p class="trans" lang="ja">
ãŸã¨ãˆã°ã€æœ‰ç†æ•°ã‚’ç´„åˆ†ã™ã‚‹å•é¡Œã«å¯¾å‡¦ã™ã‚‹ãŸã‚ã®ä»£ã‚ã‚Šã®æ–¹æ³•ã¯ã€æœ‰ç†æ•°ã‚’æ§‹ç¯‰ã™ã‚‹ã¨ãã§ã¯ãªãã‚€ã—ã‚ã€æœ‰ç†æ•°ã®éƒ¨åˆ†ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãŸã³ã«ã€ç´„åˆ†ã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚
ã“ã‚Œã¯ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¨ã‚»ãƒ¬ã‚¯ã‚¿ã®åˆ¥ã®æ‰‹ç¶šãã«ã¤ãªãŒã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_1390"></a>(define (make-rat n d)
  (cons n d))
<a name="%_idx_1392"></a>(define (numer x)
  (let ((g (gcd (car x) (cdr x))))
    (/ (car x) g)))
<a name="%_idx_1394"></a>(define (denom x)
  (let ((g (gcd (car x) (cdr x))))
    (/ (cdr x) g)))
</p>

<p class="orig" lang="en">
The difference between this implementation and the previous one lies
in when we compute the <tt>gcd</tt>.
If in our typical use of rational numbers we access the
numerators and denominators of the same rational numbers many
times, it would be preferable
to compute the <tt>gcd</tt> when the rational numbers are constructed.
If not, we may be better off waiting until access
time to compute the <tt>gcd</tt>.  In any case, when
we change from one representation to the other, the procedures <tt>add-rat</tt>, <tt>sub-rat</tt>, and so on do not have to be modified at all.
</p>

<p class="trans" lang="ja">
ã“ã®å®Ÿè£…ã¨å‰ã®å®Ÿè£…ã®é•ã„ã¯ã€ã„ã¤ <tt>gcd</tt> ã‚’è¨ˆç®—ã™ã‚‹ã®ã‹ã¨ã„ã†ç‚¹ã«ã‚ã‚‹ã€‚
ã‚‚ã—ã€ç§ãŸã¡ã«ã¨ã£ã¦ã®æœ‰ç†æ•°ã®å…¸å‹çš„ãªåˆ©ç”¨ã«ãŠã„ã¦ã€åŒã˜æœ‰ç†æ•°ã®åˆ†å­ã¨åˆ†æ¯ã«ä½•åº¦ã‚‚ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãªã‚‰ã°ã€æœ‰ç†æ•°ãŒæ§‹ç¯‰ã•ã‚ŒãŸã¨ãã« <tt>gcd</tt> ã‚’è¨ˆç®—ã™ã‚‹ã®ãŒå¥½ã¾ã—ã„ã ã‚ã†ã€‚
ã‚‚ã—ã€ãã†ã§ãªã‘ã‚Œã°ã€ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã¨ãã¾ã§å¾…ã£ã¦ã‹ã‚‰ <tt>gcd</tt> ã‚’è¨ˆç®—ã™ã‚‹æ–¹ãŒã‚ˆã„ã‹ã‚‚ã—ã‚Œãªã„ã€‚
ã„ãšã‚Œã«ã›ã‚ˆã€ä¸€æ–¹ã®è¡¨ç¾ã‹ã‚‰ä»–æ–¹ã®è¡¨ç¾ã¸ã¨ç§»è¡Œã™ã‚‹å ´åˆã«ã€<tt>add-rat</tt> ã‚„ <tt>sub-rat</tt> ãªã©ã®æ‰‹ç¶šãã‚’å¤‰æ›´ã™ã‚‹å¿…è¦ã¯ã¾ã£ãŸããªã„ã€‚
</p>

<p class="orig" lang="en">
Constraining the dependence on the representation to a few interface
procedures helps us design programs as well as modify them,
because it allows us to maintain the flexibility to consider alternate
implementations.  To continue with our simple example, suppose we are
designing a rational-number package and we can't decide initially
whether to perform the <tt>gcd</tt> at construction time or at selection
time.  The data-abstraction methodology gives us a way to defer that
decision without losing the ability to make progress on the rest of
the system.
</p>

<p class="trans" lang="ja">
è¡¨ç¾ã¸ã®ä¾å­˜ã‚’å°‘æ•°ã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ã‚¤ã‚¹æ‰‹ç¶šãã ã‘ã«åˆ¶ç´„ã™ã‚‹ã“ã¨ã¯ã€ç§ãŸã¡ãŒãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’è¨­è¨ˆã—ãŸã‚Šå¤‰æ›´ã—ãŸã‚Šã™ã‚‹ã®ã«å½¹ç«‹ã¤ã€‚ã¨ã„ã†ã®ã‚‚ã€ãã®åˆ¶ç´„ã«ã‚ˆã‚Šã€ä»£ã‚ã‚Šã®å®Ÿè£…ã‚’è€ƒæ…®ã™ã‚‹æŸ”è»Ÿæ€§ã‚’ç¶­æŒã§ãã‚‹ã‹ã‚‰ã ã€‚
ç§ãŸã¡ã®ç°¡å˜ãªä¾‹ã‚’ç¶šã‘ã‚‹ãŸã‚ã€ç§ãŸã¡ãŒæœ‰ç†æ•°ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’è¨­è¨ˆã—ã¦ã„ã‚‹ã¨ã“ã‚ã ã¨ã—ã€ã‹ã¤ã€<tt>gcd</tt> ã‚’æ§‹ç¯‰ã®éš›ã«å®Ÿè¡Œã™ã¹ãã‹é¸æŠã®éš›ã«å®Ÿè¡Œã™ã¹ãã‹ã‚’ã€ç§ãŸã¡ã¯æœ€åˆã«æ±ºå®šã§ããªã„ã‚‚ã®ã¨ã—ã‚ˆã†ã€‚
ã‚·ã‚¹ãƒ†ãƒ ã®æ®‹ã‚Šã®éƒ¨åˆ†ã§é€²æ—ã™ã‚‹èƒ½åŠ›ã‚’å¤±ã‚ãªã„ã¾ã¾ã§ã€ãã®æ±ºå®šã‚’å»¶æœŸã™ã‚‹ã‚„ã‚Šæ–¹ã‚’ã€ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ã®æ–¹æ³•è«–ã¯ä¸ãˆã¦ãã‚Œã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="%_thm_2.2"></a>
<b>Exercise 2.2.</b>  Consider the problem of representing 
<a name="%_idx_1396"></a>line segments in a plane.  Each segment is
represented as a pair of points: a starting point and an ending point.
Define a constructor <a name="%_idx_1398"></a><tt>make-segment</tt> and selectors <a name="%_idx_1400"></a><tt>start-segment</tt>
and <a name="%_idx_1402"></a><tt>end-segment</tt> that define the representation of segments in
terms of points.  Furthermore, a point <a name="%_idx_1404"></a>can be represented as a pair
of numbers: the <em>x</em> coordinate and the <em>y</em> coordinate.  Accordingly,
specify a constructor <a name="%_idx_1406"></a><tt>make-point</tt> and selectors <tt>x-point</tt> and
<tt>y-point</tt> that define this representation.  Finally, using your
selectors and constructors, define a procedure <a name="%_idx_1408"></a><tt>midpoint-segment</tt>
that takes a line segment as argument and returns its midpoint (the
point whose coordinates are the average of the coordinates of the
endpoints).
To try your procedures, you'll need a way to print points:
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.2.</b> å¹³é¢ä¸Šã®ç·šåˆ†ã‚’è¡¨ç¾ã™ã‚‹å•é¡Œã‚’è€ƒãˆã‚ˆã†ã€‚
å„ç·šåˆ†ã¯ã€ç‚¹ã®å¯¾â€”â€”ã¤ã¾ã‚Šã€å§‹ç‚¹ã¨çµ‚ç‚¹ã®å¯¾â€”â€”ã¨ã—ã¦è¡¨ç¾ã•ã‚Œã‚‹ã€‚
ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§ã‚ã‚‹ <tt>make-segment</tt> ã¨ã€ã‚»ãƒ¬ã‚¯ã‚¿ã§ã‚ã‚‹ <tt>start-segment</tt> ãŠã‚ˆã³ <tt>end-segment</tt>â€”â€”ã“ã‚Œã‚‰ã¯ç‚¹ã‚’ä½¿ã£ã¦ç·šåˆ†ã®è¡¨ç¾ã‚’å®šç¾©ã™ã‚‹ã‚‚ã®ã§ã‚ã‚‹â€”â€”ã‚’å®šç¾©ã›ã‚ˆã€‚
ã•ã‚‰ã«ã€ç‚¹ã¯ã€æ•°ã®å¯¾â€”â€”ã¤ã¾ã‚Šã€<em class="en">x</em> åº§æ¨™ã¨ <em class="en">y</em> åº§æ¨™ã®å¯¾â€”â€”ã¨ã—ã¦è¡¨ç¾ã§ãã‚‹ã€‚
ã“ã‚Œã«ã—ãŸãŒã£ã¦ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§ã‚ã‚‹ <tt>make-point</tt> ã¨ã€ã‚»ãƒ¬ã‚¯ã‚¿ã§ã‚ã‚‹ <tt>x-point</tt> ãŠã‚ˆã³ <tt>y-point</tt>â€”â€”ã“ã‚Œã‚‰ã¯ã“ã®è¡¨ç¾ã‚’å®šç¾©ã™ã‚‹ã‚‚ã®ã§ã‚ã‚‹â€”â€”ã‚’è¦å®šã›ã‚ˆã€‚
æœ€å¾Œã«ã€ç·šåˆ†ã‚’å¼•æ•°ã¨ã—ã¦å–ã£ã¦ãã®ä¸­ç‚¹ (ãã®åº§æ¨™ãŒã€ä¸¡ç«¯ç‚¹ã®åº§æ¨™ã®å¹³å‡ã§ã‚ã‚‹ã‚ˆã†ãªç‚¹) ã‚’è¿”ã™ã‚ˆã†ãªã€<tt>midpoint-segment</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’ã€å›ã®ä½œã£ãŸã‚»ãƒ¬ã‚¯ã‚¿ã¨ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’ç”¨ã„ã¦å®šç¾©ã›ã‚ˆã€‚
å›ã®æ‰‹ç¶šãã‚’è©¦ã™ãŸã‚ã«ã€ç‚¹ã‚’å°å­—ã™ã‚‹æ–¹æ³•ãŒå¿…è¦ã ã‚ã†ã€‚
</p>

<p class="lisp"><a name="%_idx_1410"></a>(define (print-point p)
  (newline)
  (display &quot;(&quot;)
  (display (x-point p))
  (display &quot;,&quot;)
  (display (y-point p))
  (display &quot;)&quot;))
</p>

<p class="exercise">(define (make-segment start-point end-point) (cons start-point end-point))
(define (start-segment segment) (car segment))
(define (end-segment segment) (cdr segment))

(define (make-point x y) (cons x y))
(define (x-point point) (car point))
(define (y-point point) (cdr point))

(define (midpoint-segment segment)
  (let ((s (start-segment segment))
        (e (end-segment segment)))
       (make-point
          (/ (+ (x-point s) (x-point e)) 2)
          (/ (+ (y-point s) (y-point e)) 2))))

<span class="ex_comment"></span></p>

<p class="orig" lang="en"><a name="%_thm_2.3"></a>
<b>Exercise 2.3.</b>  <a name="%_idx_1412"></a>Implement a representation for rectangles in a plane.
(Hint: You may want to make use of exercise <a href="#%_thm_2.2">2.2</a>.)
In terms of
your constructors and selectors, create procedures that compute the
perimeter and the area of a given rectangle.  Now implement a
different representation for rectangles.  Can you design your system
with suitable abstraction barriers, so that the same perimeter and
area procedures will work using either representation?
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.3.</b> å¹³é¢ä¸Šã®ä¸‰è§’å½¢ã®è¡¨ç¾ã‚’å®Ÿè£…ã›ã‚ˆã€‚
(ãƒ’ãƒ³ãƒˆ: å›ã¯ç·´ç¿’å•é¡Œ<a href="#%_thm_2.2">2.2</a>ã‚’åˆ©ç”¨ã—ãŸã„ã‹ã‚‚ã­ã€‚)
å›ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¨ã‚»ãƒ¬ã‚¯ã‚¿ã‚’ä½¿ã£ã¦ã€ä¸ãˆã‚‰ã‚ŒãŸä¸‰è§’å½¢ã®å‘¨é•·ã¨é¢ç©ã‚’è¨ˆç®—ã™ã‚‹æ‰‹ç¶šãã‚’ä½œæˆã›ã‚ˆã€‚
ã•ã¦ã“ã“ã§ä¸‰è§’å½¢ã®åˆ¥ã®è¡¨ç¾ã‚’å®Ÿè£…ã›ã‚ˆã€‚
å›ã¯ã€æŠ½è±¡åŒ–ã®é©åˆ‡ãªé˜²å£ã‚’ã¨ã‚‚ãªã£ãŸã‚·ã‚¹ãƒ†ãƒ ã‚’è¨­è¨ˆã§ãã‚‹ã‹ãª? â€”â€”è¨­è¨ˆã§ãã‚Œã°ãã®çµæœã€ã©ã¡ã‚‰ã®è¡¨ç¾ã‚’ä½¿ã£ã¦ã‚‚ã€å‘¨é•·ã¨é¢ç©ã®åŒã˜æ‰‹ç¶šããŒã†ã¾ãå‹•ãã ã‚ã†ã€‚
</p>

<p class="exercise"><span class="ex_comment">é¢ç©ã¯ãƒ˜ãƒ­ãƒ³ã®å…¬å¼ã§æ±‚ã‚ã‚ˆã†ã‹â€¦â€¦
</span></p>

<a name="%_sec_2.1.3"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_2.1.3">2.1.3  What Is Meant by Data?</a></h3>
<h3 class="trans" lang="ja">2.1.3 ãƒ‡ãƒ¼ã‚¿ã¨ã¯ã©ã†ã„ã†æ„å‘³ãªã®ã‹?</h3>

<p class="orig" lang="en">
<a name="%_idx_1414"></a>
We began the rational-number implementation in
section <a href="#%_sec_2.1.1">2.1.1</a> by implementing the rational-number
operations <tt>add-rat</tt>, <tt>sub-rat</tt>, and so on in terms of three
unspecified procedures: <tt>make-rat</tt>, <tt>numer</tt>, and <tt>denom</tt>.
At that point, we could think of the operations as being defined in
terms of data objects -- numerators, denominators, and rational
numbers -- whose behavior was specified by the latter three procedures.
</p>

<p class="trans" lang="ja">
ç§ãŸã¡ã¯<a href="#%_sec_2.1.1">2.1.1</a>ç¯€ã§ã€æœ‰ç†æ•°æ¼”ç®—ã§ã‚ã‚‹ <tt>add-rat</tt> ã‚„ <tt>sub-rat</tt>ãªã©ã‚’ã€æ˜ç´°ãŒç‰¹å®šã•ã‚Œã¦ã„ãªã„ä¸‰ã¤ã®æ‰‹ç¶šãâ€”â€”ã¤ã¾ã‚Šã€<tt>make-rat</tt> ã¨ <tt>numer</tt> ã¨ <tt>denom</tt>â€”â€”ã‚’ç”¨ã„ã¦å®Ÿè£…ã™ã‚‹ã“ã¨ã‹ã‚‰ã€æœ‰ç†æ•°ã®å®Ÿè£…ã‚’å§‹ã‚ãŸã€‚
ãã®æ™‚ç‚¹ã§ã€ç§ãŸã¡ã¯ã€æ¼”ç®—ã‚’ã€å¾Œè€…ã®ä¸‰ã¤ã®æ‰‹ç¶šãã«ã‚ˆã‚ŠæŒ¯ã‚‹èˆã„ãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆâ€”â€”åˆ†å­ã¨åˆ†æ¯ã¨æœ‰ç†æ•°â€”â€”ã®è¦³ç‚¹ã‹ã‚‰å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‚‚ã®ã¨è¦‹ãªã™ã“ã¨ãŒã§ããŸã ã‚ã†ã€‚
</p>

<p class="orig" lang="en">
But exactly what is meant by <em>data</em>?  It is not enough to say
``whatever is implemented by the given selectors and constructors.''
Clearly, not every arbitrary set of three procedures can serve as an
appropriate basis for the rational-number implementation.  We need to
guarantee that, <a name="%_idx_1416"></a><a name="%_idx_1418"></a><a name="%_idx_1420"></a>if we construct a rational number <tt>x</tt> from a pair
of integers <tt>n</tt> and <tt>d</tt>, then extracting the <tt>numer</tt> and the
<tt>denom</tt> of <tt>x</tt> and dividing them should yield the same result
as dividing <tt>n</tt> by <tt>d</tt>.  In other words, <tt>make-rat</tt>,
<tt>numer</tt>, and <tt>denom</tt> must satisfy the condition that, for any
integer <tt>n</tt> and any non-zero integer <tt>d</tt>, if <tt>x</tt> is
(<tt>make-rat n d</tt>), then
</p>

<p class="trans" lang="ja">
ã—ã‹ã—ã€<em>ãƒ‡ãƒ¼ã‚¿</em>ã¨ã¯å³å¯†ã«ã¯ä½•ã‚’æ„å‘³ã™ã‚‹ã®ã ã‚ã†ã‹?
ã€Œä¸ãˆã‚‰ã‚ŒãŸã‚»ãƒ¬ã‚¯ã‚¿ã¨ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«ã‚ˆã‚Šå®Ÿè£…ã•ã‚Œã‚‹ã‚‚ã®ãªã‚‰ä½•ã§ã‚‚ã€ã¨è¨€ã†ã ã‘ã§ã¯ä¸ååˆ†ã ã€‚
æ˜ã‚‰ã‹ã«ã€ã‚ã‚‰ã‚†ã‚‹ä»»æ„ã®ä¸‰ã¤ã®æ‰‹ç¶šãã®é›†åˆãŒã€æœ‰ç†æ•°ã®å®Ÿè£…ã®é©åˆ‡ãªåŸºç¤ã¨ã—ã¦ç”¨ã‚’ãªã—å¾—ã‚‹ã€ã¨ã„ã†ã‚ã‘ã§ã¯ãªã„ã€‚
<tt>n</tt> ã¨ <tt>d</tt> ã¨ã„ã†æ•´æ•°ã®å¯¾ã‹ã‚‰ <tt>x</tt> ã¨ã„ã†æœ‰ç†æ•°ã‚’æ§‹ç¯‰ã—ã¦ã„ã‚‹å ´åˆã€<tt>x</tt> ã® <tt>numer</tt> ã¨ <tt>denom</tt> ã‚’æŠ½å‡ºã—ã¦ã€æŠ½å‡ºã—ãŸãã‚Œã‚‰ã®ã‚‚ã®ã§å‰²ã‚Šç®—ã‚’ã™ã‚‹ã“ã¨ã¯ã€<tt>n</tt> ã‚’ <tt>d</tt> ã§å‰²ã‚‹ã“ã¨ã¨ã€åŒã˜çµæœã«ãªã‚‹ã¹ãã§ã‚ã‚‹ã€‚
æ›è¨€ã™ã‚Œã°ã€<tt>make-rat</tt> ã¨ <tt>numer</tt> ã¨ <tt>denom</tt> ã¯ã€æ¬¡ã®æ¡ä»¶ã‚’æº€ãŸã•ã­ã°ãªã‚‰ãªã„â€”â€”ä»»æ„ã®æ•´æ•° <tt>n</tt> ã¨ä»»æ„ã®éé›¶ã®æ•´æ•° <tt>d</tt> ã«å¯¾ã—ã¦ã€ã‚‚ã— <tt>x</tt> ãŒ (<tt>make-rat n d</tt>) ãªã‚‰ã°ã€ä»¥ä¸‹ã®ã¨ãŠã‚Šã§ã‚ã‚‹ã€‚
</p>

<figure>
<img src="ch2-Z-G-7.gif" border="0">
</figure>

<p class="orig" lang="en">
In fact, this is the only condition <tt>make-rat</tt>, <tt>numer</tt>, and
<tt>denom</tt> must fulfill in order to form a suitable basis for a
rational-number representation.  In general, we can think of data as
defined by some collection of selectors and constructors, together
with specified conditions that these procedures must fulfill in order
to be a valid representation.<a name="call_footnote_Temp_140" href="#footnote_Temp_140"><sup><small>5</small></sup></a>
</p>

<p class="trans" lang="ja">
å®Ÿéš›ã€ã“ã‚Œã¯ã€<tt>make-rat</tt> ã¨ <tt>numer</tt> ã¨ <tt>denom</tt> ãŒã€æœ‰ç†æ•°ã®è¡¨ç¾ã®é©åˆ‡ãªåŸºç¤ã¨ãªã‚‹ãŸã‚ã«æº€ãŸã•ã­ã°ãªã‚‰ãªã„ã€å”¯ä¸€ã®æ¡ä»¶ã§ã‚ã‚‹ã€‚
ä¸€èˆ¬ã«ã¯ã€ç§ãŸã¡ã¯ã€ãƒ‡ãƒ¼ã‚¿ã‚’ã€ã‚»ãƒ¬ã‚¯ã‚¿ã¨ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®ä½•ã‚‰ã‹ã®é›†ã¾ã‚Šã¨ã€ã“ã‚Œã‚‰ã®æ‰‹ç¶šããŒå¦¥å½“ãªè¡¨ç¾ã§ã‚ã‚‹ãŸã‚ã«æº€ãŸã•ã­ã°ãªã‚‰ãªã„æ¡ä»¶ã¨ã«ã‚ˆã£ã¦ã€å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‚‚ã®ã ã€ã¨è¦‹ãªã™ã“ã¨ãŒã§ãã‚‹<a href="#footnote_Temp_140"><sup><small>5</small></sup></a>ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_1446"></a><a name="%_idx_1448"></a>This point of view can serve to define not only ``high-level'' data
objects, such as rational numbers, but lower-level objects as well.
<a name="%_idx_1450"></a>Consider the notion of a pair, which we used in order to define our
rational numbers.  We never actually said what a pair was, only that
the language supplied procedures <tt>cons</tt>, <tt>car</tt>, and <tt>cdr</tt>
for operating on pairs.  But the only thing we need to know about
these three operations <a name="%_idx_1452"></a><a name="%_idx_1454"></a><a name="%_idx_1456"></a><a name="%_idx_1458"></a>is that if we glue two objects together using
<tt>cons</tt> we can retrieve the objects using <tt>car</tt> and <tt>cdr</tt>.
That is, the operations satisfy the condition that, for any objects
<tt>x</tt> and <tt>y</tt>, if <tt>z</tt> is <tt>(cons x y)</tt> then <tt>(car z)</tt>
is <tt>x</tt> and <tt>(cdr z)</tt> is <tt>y</tt>.  Indeed, we mentioned that
these three procedures are included as primitives in our language.
However, any triple of procedures that satisfies the above condition
can be used as the basis for implementing pairs.  This point is
illustrated strikingly by the fact that we could implement <tt>cons</tt>,
<tt>car</tt>, and <tt>cdr</tt> without using any data structures at all but
only using procedures.  Here are the definitions:
</p>

<p class="trans" lang="ja">
ã“ã®è¦³ç‚¹ã¯ã€ã€Œé«˜ã„ãƒ¬ãƒ™ãƒ«ã®ã€ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆâ€”â€”æœ‰ç†æ•°ãªã©â€”â€”ã‚’å®šç¾©ã™ã‚‹ã®ã«å½¹ç«‹ã¤ã ã‘ã§ãªãã€ä½ã„æ–¹ã®ãƒ¬ãƒ™ãƒ«ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å®šç¾©ã™ã‚‹ã®ã«ã‚‚å½¹ç«‹ã¤ã€‚
å¯¾â€”â€”ç§ãŸã¡ãŒã€æœ‰ç†æ•°ã‚’å®šç¾©ã™ã‚‹ãŸã‚ã«ç”¨ã„ãŸã‚‚ã®ã§ã‚ã‚‹â€”â€”ã®æ¦‚å¿µã‚’è€ƒãˆã‚ˆã†ã€‚
ç§ãŸã¡ã¯ã€å¯¾ãŒä½•ã§ã‚ã‚‹ã‹ã€ã¨å®Ÿéš›ã«è¨€ã£ãŸã“ã¨ã¯æ±ºã—ã¦ãªãã€ãŸã ã€å¯¾ã«é–¢ã™ã‚‹æ¼”ç®—ã‚’è¡Œã†ãŸã‚ã«ã€<tt>cons</tt> ã¨ <tt>car</tt> ã¨ <tt>cdr</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’ã€è¨€èªãŒæä¾›ã—ã¦ã„ã‚‹ã€ã¨è¨€ã£ãŸã ã‘ã ã€‚
ã—ã‹ã—ã€ã“ã‚Œã‚‰ä¸‰ã¤ã®æ¼”ç®—ã«ã¤ã„ã¦ç§ãŸã¡ãŒçŸ¥ã‚‹å¿…è¦ãŒã‚ã‚‹å”¯ä¸€ã®ã“ã¨ã¯ã€ã‚‚ã— <tt>cons</tt> ã‚’ç”¨ã„ã¦äºŒã¤ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ãã£ã¤ã‘ãŸã‚‰ã€<tt>car</tt> ã¨ <tt>cdr</tt> ã‚’ä½¿ã£ã¦ãã‚Œã‚‰ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å–ã‚Šæˆ»ã›ã‚‹ã€ã¨ã„ã†ã“ã¨ãªã®ã ã€‚
ã¤ã¾ã‚Šã€ã“ã‚Œã‚‰ã®æ¼”ç®—ã¯ã€ä»»æ„ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <tt>x</tt> ã¨ <tt>y</tt> ã«å¯¾ã—ã¦ã€ã‚‚ã— <tt>z</tt> ãŒ <tt>(cons x y)</tt> ãªã‚‰ã°ã€<tt>(car z)</tt> ã¯ <tt>x</tt> ã§ã‚ã‚Š <tt>(cdr z)</tt> ã¯ <tt>y</tt> ã§ã‚ã‚‹ã€ã¨ã„ã†æ¡ä»¶ã‚’æº€ãŸã™ã€‚
å®Ÿéš›ã€ã“ã‚Œã‚‰ä¸‰ã¤ã®æ‰‹ç¶šããŒãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã¨ã—ã¦è¨€èªã«å«ã¾ã‚Œã¦ã„ã‚‹ã€ã¨ç§ãŸã¡ã¯è¿°ã¹ãŸã€‚
ã—ã‹ã—ã€ä¸Šè¨˜ã®æ¡ä»¶ã‚’æº€ãŸã™ã‚ˆã†ãªä»»æ„ã®ä¸‰ã¤çµ„ã®æ‰‹ç¶šãã‚’ã€å¯¾ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã®åŸºç¤ã¨ã—ã¦ä½¿ã†ã“ã¨ãŒã§ãã‚‹ã€‚
ã“ã®ç‚¹ã¯ã€<tt>cons</tt> ã¨ <tt>car</tt> ã¨ <tt>cdr</tt> ã‚’ã€ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’ã¾ã£ãŸãä½¿ã‚ãšã«ã€ãŸã æ‰‹ç¶šãã®ã¿ã‚’ç”¨ã„ã¦å®Ÿè£…ã—å¾—ãŸã ã‚ã†ã€ã¨ã„ã†äº‹å®Ÿã«ã‚ˆã£ã¦ã€é¡•è‘—ã«èª¬æ˜ã•ã‚Œã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_1460"></a>(define (cons x y)
  (define (dispatch m)
    (cond ((= m 0) x)
          ((= m 1) y)
          (else (error &quot;Argument not 0 or 1 -- CONS&quot; m))))
  dispatch)

<a name="%_idx_1462"></a>(define (car z) (z 0))

<a name="%_idx_1464"></a>(define (cdr z) (z 1))
</p>

<p class="orig" lang="en">
This use of procedures corresponds to nothing like our intuitive
notion of what data should be.  Nevertheless, all we need to do to
show that this is a valid way to represent pairs is to verify that
these procedures satisfy the condition given above.
</p>

<p class="trans" lang="ja">
ã“ã®ã‚ˆã†ãªæ‰‹ç¶šãã®ä½¿ã„æ–¹ã¯ã€ãƒ‡ãƒ¼ã‚¿ãŒä½•ã§ã‚ã‚‹ã¹ãã‹ã¨ã„ã†ã€ç§ãŸã¡ã®ç›´è¦³çš„æ¦‚å¿µã®ã‚ˆã†ãªã‚‚ã®ã«ã¯ã€åˆè‡´ã—ãªã„ã€‚
ãã‚Œã«ã‚‚ã‹ã‹ã‚ã‚‰ãšã€ã“ã‚ŒãŒå¯¾ã‚’è¡¨ç¾ã™ã‚‹ãŸã‚ã®å¦¥å½“ãªæ–¹æ³•ã ã€ã¨ç¤ºã™ãŸã‚ã«ç§ãŸã¡ãŒã—ãªãã¦ã¯ãªã‚‰ãªã„ã“ã¨ã¯ã€ãŸã ã€ã“ã‚Œã‚‰ã®æ‰‹ç¶šããŒä¸Šè¨˜ã®æ¡ä»¶ã‚’æº€ãŸã™ã“ã¨ã‚’è¨¼æ˜ã™ã‚‹ã“ã¨ã®ã¿ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
The subtle point to notice is that the value returned by <tt>(cons x
y)</tt> is a procedure -- namely the internally defined procedure <tt>dispatch</tt>, which takes one argument and returns either <tt>x</tt> or <tt>y</tt> depending on whether the argument is 0 or 1.  Correspondingly, <tt>(car z)</tt> is defined to apply <tt>z</tt> to 0.  Hence, if <tt>z</tt> is the
procedure formed by <tt>(cons x y)</tt>, then <tt>z</tt> applied to 0 will
yield <tt>x</tt>. Thus, we have shown that <tt>(car (cons x y))</tt> yields
<tt>x</tt>, as desired.  Similarly, <tt>(cdr (cons x y))</tt> applies the
procedure returned by <tt>(cons x y)</tt> to 1, which returns <tt>y</tt>.
Therefore, this procedural implementation of pairs is a valid
implementation, and if we access pairs using only <tt>cons</tt>, <tt>car</tt>, and <tt>cdr</tt> we cannot distinguish this implementation from one
that uses ``real'' data structures.
</p>

<p class="trans" lang="ja">
æ³¨ç›®ã™ã¹ãå·§å¦™ãªç‚¹ã¯ã€<tt>(cons x y)</tt> ã«ã‚ˆã‚Šè¿”ã•ã‚Œã‚‹å€¤ãŒã€æ‰‹ç¶šãâ€”â€”ã¤ã¾ã‚Šã€å†…éƒ¨ã§å®šç¾©ã•ã‚ŒãŸ <tt>dispatch</tt> ã¨ã„ã†æ‰‹ç¶šãã§ã‚ã‚Šã€ã“ã‚Œã¯ã€ä¸€ã¤ã®å¼•æ•°ã‚’å–ã‚Šã€ãã®å¼•æ•°ãŒ0ã‹1ã‹ã«å¿œã˜ã¦ <tt>x</tt> ã‹ <tt>y</tt> ã‚’è¿”ã™â€”â€”ã§ã‚ã‚‹ã€ã¨ã„ã†ç‚¹ã ã€‚
ãã‚Œã«å¯¾å¿œã—ã¦ã€<tt>(car z)</tt> ã¯ã€<tt>z</tt> ã‚’0ã«é©ç”¨ã™ã‚‹ã“ã¨ã€ã¨å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã€‚
ã—ãŸãŒã£ã¦ã€ã‚‚ã— <tt>z</tt> ãŒ <tt>(cons x y)</tt> ã«ã‚ˆã‚Šä½œã‚Šå‡ºã•ã‚ŒãŸæ‰‹ç¶šããªã‚‰ã°ã€0ã«é©ç”¨ã•ã‚ŒãŸ <tt>z</tt> ã¯ã€<tt>x</tt> ã‚’ç”Ÿã˜ã‚‹ã ã‚ã†ã€‚
ã“ã®ã‚ˆã†ã«ã€ç§ãŸã¡ã¯ã€<tt>(car (cons x y))</tt> ãŒæ‰€æœ›ã®ã¨ãŠã‚Šã« <tt>x</tt> ã‚’ç”Ÿã˜ã‚‹ã“ã¨ã‚’ç¤ºã—ãŸã€‚
åŒæ§˜ã«ã€<tt>(cdr (cons x y))</tt> ã¯ã€<tt>(cons x y)</tt> ã«ã‚ˆã‚Šè¿”ã•ã‚ŒãŸæ‰‹ç¶šãã‚’1ã«é©ç”¨ã—ã€ãã‚Œã«ã‚ˆã‚Š <tt>y</tt> ã‚’è¿”ã™ã€‚
ã—ãŸãŒã£ã¦ã€å¯¾ã«ã¤ã„ã¦ã®ã€ã“ã®æ‰‹ç¶šãçš„å®Ÿè£…ã¯ã€å¦¥å½“ãªå®Ÿè£…ã§ã‚ã‚Šã€ã‚‚ã—ç§ãŸã¡ãŒ <tt>cons</tt> ã¨ <tt>car</tt> ã¨ <tt>cdr</tt> ã®ã¿ã‚’ä½¿ã£ã¦å¯¾ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãªã‚‰ã€ç§ãŸã¡ã¯ã€ã“ã®å®Ÿè£…ã¨ã€ã€Œç¾å®Ÿã®ã€ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’ä½¿ã†å®Ÿè£…ã‚’åŒºåˆ¥ã§ããªã„ã€‚
</p>

<p class="orig" lang="en">
The point of exhibiting the procedural representation of pairs is not
that our language works this way (Scheme, and Lisp systems in general,
implement pairs directly, for efficiency reasons) but that it could
work this way.  The procedural representation, although obscure, is a
perfectly adequate way to represent pairs, since it fulfills the only
conditions that pairs need to fulfill.  This example also demonstrates
that the ability to manipulate procedures as objects automatically
provides the ability to represent compound data.  This may seem a
curiosity now, but procedural representations of data will play a
central role in our programming repertoire.  This style of programming
is often called <a name="%_idx_1466"></a><em>message passing</em>, and we will be using it as a
basic tool in chapter 3 when we address the issues of modeling and
simulation.
</p>

<p class="trans" lang="ja">
å¯¾ã®æ‰‹ç¶šãçš„è¡¨ç¾ã‚’æç¤ºã—ã¦ã¿ã›ã‚‹ã“ã¨ã®è¦ç‚¹ã¯ã€ç§ãŸã¡ã®è¨€èªãŒã“ã†ã„ã†æ–¹æ³•ã§ã†ã¾ãå‹•ãã€ã¨ã„ã†ç‚¹ã§ã¯ãªã (Schemeã¯â€”â€”ãã—ã¦Lispã‚·ã‚¹ãƒ†ãƒ ã¯ä¸€èˆ¬ã«â€”â€”åŠ¹ç‡é¢ã®ç†ç”±ã‹ã‚‰ã€å¯¾ã‚’ç›´æ¥çš„ã«å®Ÿè£…ã™ã‚‹ã®ã )ã€ç§ãŸã¡ã®è¨€èªãŒã“ã†ã„ã†æ–¹æ³•ã§ã†ã¾ãå‹•ãã“ã¨ã‚‚å¯èƒ½ã ã€ã¨ã„ã†ç‚¹ã§ã‚ã‚‹ã€‚
æ‰‹ç¶šãçš„è¡¨ç¾ã¯ã€é›£è§£ã ã¨ã¯ã„ãˆã€å¯¾ã‚’è¡¨ç¾ã™ã‚‹ãŸã‚ã®å®Œå…¨ã«é©åˆ‡ãªæ–¹æ³•ã§ã‚ã‚‹ã€‚ã¨ã„ã†ã®ã‚‚ã€ã“ã®è¡¨ç¾ã¯ã€å¯¾ãŒæº€ãŸã™å¿…è¦ã®ã‚ã‚‹å”¯ä¸€ã®æ¡ä»¶ã‚’æº€ãŸã™ã‹ã‚‰ã§ã‚ã‚‹ã€‚
ã“ã®ä¾‹ã¯ã€æ‰‹ç¶šãã‚’ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦æ“ä½œã™ã‚‹èƒ½åŠ›ãŒã€è¤‡åˆçš„ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ç¾ã™ã‚‹èƒ½åŠ›ã‚’è‡ªå‹•çš„ã«ä¸ãˆã¦ãã‚Œã‚‹ã€ã¨ã„ã†ã“ã¨ã‚‚å®Ÿè¨¼ã—ã¦ã„ã‚‹ã€‚
ã“ã®ã“ã¨ã¯ã€ä»Šã¯ã€ãŸã èˆˆå‘³ã‚’å¼•ãã‚‚ã®ã”ã¨ã«æ€ãˆã‚‹ã ã‘ã ã‚ã†ãŒã€ãƒ‡ãƒ¼ã‚¿ã®æ‰‹ç¶šãçš„è¡¨ç¾ã¯ã€ç§ãŸã¡ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°æŠ€è¡“ã®ãƒ¬ãƒ‘ãƒ¼ãƒˆãƒªãƒ¼ã«ãŠã„ã¦ã€ä¸­å¿ƒçš„å½¹å‰²ã‚’æœãŸã™ã“ã¨ã«ãªã‚‹ã ã‚ã†ã€‚
ã“ã®ã‚ˆã†ãªãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®æµå„€ã¯ã€ã—ã°ã—ã°<em>ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ‘ãƒƒã‚·ãƒ³ã‚°</em>ã¨å‘¼ã°ã‚Œã€ã“ã‚Œã‚’ç§ãŸã¡ã¯3ç« ã§ã€ãƒ¢ãƒ‡ãƒªãƒ³ã‚°ã¨ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®å•é¡Œã«å¯¾å‡¦ã™ã‚‹ã¨ãã«ã€åŸºæœ¬çš„ãªé“å…·ã¨ã—ã¦ä½¿ã£ã¦ã„ã‚‹ã“ã¨ã ã‚ã†ã€‚
</p>

<p class="orig" lang="en"><a name="%_thm_2.4"></a>
<b>Exercise 2.4.</b>  Here is an alternative procedural representation of pairs.  For this
representation, verify that <tt>(car (cons x y))</tt> yields <tt>x</tt> for
any objects <tt>x</tt> and <tt>y</tt>.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.4.</b> ã“ã“ã«ã€å¯¾ã®æ‰‹ç¶šãçš„è¡¨ç¾ã®ã€åˆ¥ã®é¸æŠè‚¢ãŒã‚ã‚‹ã€‚
ã“ã®è¡¨ç¾ã«ã¤ã„ã¦ã€ä»»æ„ã® <tt>x</tt> ã¨ <tt>y</tt> ã¨ã„ã†ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦ <tt>(car (cons x y))</tt> ãŒ <tt>x</tt> ã‚’ç”Ÿã˜ã‚‹ã€ã¨ã„ã†ã“ã¨ã‚’è¨¼æ˜ã›ã‚ˆã€‚
</p>

<p class="lisp"><a name="%_idx_1468"></a>(define (cons x y)
  (lambda (m) (m x y)))

<a name="%_idx_1470"></a>(define (car z)
  (z (lambda (p q) p)))
</p>

<p class="exercise">(car (cons x y))
<span class="ex_comment">ã‚’å±•é–‹ã™ã‚‹ã¨ã€consã®å®šç¾©ã‚ˆã‚Šã€</span>
(car (lambda (m) (m x y)))
<span class="ex_comment">ã¨ãªã‚Šã€carã®å®šç¾©ã‚ˆã‚Šã€</span>
((lambda (m) (m x y)) (lambda (p q) p))
<span class="ex_comment">ã¨å±•é–‹ã§ãã¦ã€ã“ã“ã§é–¢æ•°é©ç”¨ã«ã‚ˆã‚Šã€</span>
((lambda (p q) p) x y)
<span class="ex_comment">ã¨ãªã£ã¦ã€ã“ã“ã§ã¾ãŸé–¢æ•°é©ç”¨ã‚’è¡Œã£ã¦ã€æœ€çµ‚çš„ã«</span>
x
<span class="ex_comment">ã‚’å¾—ã‚‹ã€‚</span>
</p>

<p class="orig" lang="en">
<a name="%_idx_1472"></a>What is the corresponding definition of <tt>cdr</tt>? (Hint: To verify
that this works, make use of the substitution model of
section <a href="10_sec1_1.html#%_sec_1.1.5">1.1.5</a>.)
</p>

<p class="trans" lang="ja">
ã“ã‚Œã«å¯¾å¿œã™ã‚‹ã€<tt>cdr</tt> ã®è¡¨ç¾ã¯ã€ã©ã‚“ãªã‚‚ã®ã ã‚ã†ã‹?
(ãƒ’ãƒ³ãƒˆ: ã“ã‚ŒãŒã†ã¾ãå‹•ãã“ã¨ã‚’è¨¼æ˜ã™ã‚‹ã«ã¯ã€<a href="10_sec1_1.html#%_sec_1.1.5">1.1.5</a>ç¯€ã®ä»£å…¥ãƒ¢ãƒ‡ãƒ«ã‚’åˆ©ç”¨ã›ã‚ˆã€‚)
</p>

<p class="exercise"><span class="ex_comment">; cdrã®å®šç¾©</span>
(define (cdr z)
  (z (lambda (p q) q)))

<span class="ex_comment">ã“ã®å®šç¾©ãŒæ­£ã—ã„ã“ã¨ã‚’ç¤ºã™ã€‚ã¾ãšã€</span>
(cdr (cons x y))
<span class="ex_comment">ã‚’å±•é–‹ã™ã‚‹ã¨ã€consã®å®šç¾©ã‚ˆã‚Šã€</span>
(cdr (lambda (m) (m x y)))
<span class="ex_comment">ã¨ãªã‚Šã€cdrã®å®šç¾©ã‚ˆã‚Šã€</span>
((lambda (m) (m x y)) (lambda (p q) q))
<span class="ex_comment">ã¨å±•é–‹ã§ãã¦ã€ã“ã“ã§é–¢æ•°é©ç”¨ã«ã‚ˆã‚Šã€</span>
((lambda (p q) q) x y)
<span class="ex_comment">ã¨ãªã£ã¦ã€ã“ã“ã§ã¾ãŸé–¢æ•°é©ç”¨ã‚’è¡Œã£ã¦ã€æœ€çµ‚çš„ã«</span>
y
<span class="ex_comment">ã‚’å¾—ã‚‹ã€‚</span></p>

<p class="orig" lang="en"><a name="%_thm_2.5"></a>
<b>Exercise 2.5.</b>  Show that we can represent pairs of nonnegative integers using only
numbers and arithmetic operations if we represent the pair <em>a</em> and <em>b</em>
as the integer that is the product 2<sup><em>a</em></sup> 3<sup><em>b</em></sup>.  Give the corresponding
definitions of the procedures <tt>cons</tt>, <tt>car</tt>, and <tt>cdr</tt>.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.5.</b> ã‚‚ã—ã€<em class="en">a</em> ã¨ <em class="en">b</em> ã®å¯¾ã‚’ã€2<sup><em class="en">a</em></sup> 3<sup><em class="en">b</em></sup> ã¨ã„ã†ç©ã«ç­‰ã—ã„æ•´æ•°ã¨ã—ã¦è¡¨ã™ãªã‚‰ã€æ•°ã¨ç®—è¡“æ¼”ç®—ã®ã¿ã‚’ä½¿ã£ã¦éè² æ•´æ•°ã®å¯¾ã‚’è¡¨ã›ã‚‹ã€ã¨ã„ã†ã“ã¨ã‚’ç¤ºã›ã€‚
ã“ã‚Œã«å¯¾å¿œã™ã‚‹ã€<tt>cons</tt> ã¨ <tt>car</tt> ã¨ <tt>cdr</tt> ã®æ‰‹ç¶šãã®å®šç¾©ã‚’æç¤ºã›ã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment">ã‚²ãƒ¼ãƒ‡ãƒ«æ•°ã§ã™ã­ã€‚2ã¨3ã¯ç´ æ•°ã ã‹ã‚‰ã€ç´ å› æ•°åˆ†è§£ã®ä¸€æ„æ€§ã‚ˆã‚Šã€
<span class="math"><em class="en">n</em> = 2<sup><em class="en">a</em></sup> 3<sup><em class="en">b</em></sup></span>
ãŒæˆç«‹ã™ã‚‹ã‚ˆã†ãª <em class="en">a</em> ã¨ <em class="en">b</em> ã¯ã€<em class="en">n</em> ã«å¯¾ã—ã¦ä¸€æ„ã«å®šã¾ã‚‹ã€‚ã ã‹ã‚‰ã€<em class="en">n</em> ã¨ã„ã†æ•°ã§ã€<em class="en">a</em> ã¨ <em class="en">b</em> ã®å¯¾ã‚’è¡¨ã›ã‚‹ã€‚</span>
(define (cons a b)
  (define (cons-iter i j result)
    (if (= i 0)
      (if (= j 0)
        result
        (cons-iter i (- j 1) (* 3 result)))
      (cons-iter (- i 1) j (* 2 result))))
  (cons-iter a b 1))

(define (car n)
  (define (car-iter i count)
    (if (= (remainder i 2) 0) (car-iter (/ i 2) (+ count 1)) count))
  (car-iter n 0))

(define (cdr n)
  (define (cdr-iter i count)
    (if (= (remainder i 3) 0) (cdr-iter (/ i 3) (+ count 1)) count))
  (cdr-iter n 0))

<span class="ex_comment">; å®Ÿè¡Œä¾‹</span>
gosh&gt; (cons 1 1)
6
gosh&gt; (cons 0 0)
1
gosh&gt; (cons 0 1)
3
gosh&gt; (cons 1 0)
2
gosh&gt; (cons 4 3)
432
gosh&gt; (car 6)
1
gosh&gt; (cdr 6)
1
gosh&gt; (car 1)
0
gosh&gt; (cdr 1)
0
gosh&gt; (car 3)
0
gosh&gt; (cdr 3)
1
gosh&gt; (car 2)
1
gosh&gt; (cdr 2)
0
gosh&gt; (car 432)
4
gosh&gt; (cdr 432)
3
</p>

<p class="orig" lang="en"><a name="%_thm_2.6"></a>
<b>Exercise 2.6.</b>  In case representing pairs as procedures wasn't mind-boggling enough,
consider that, in a language that can manipulate procedures, we can
get by without numbers (at least insofar as nonnegative integers are
concerned) by implementing 0 and the operation of adding 1 as
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.6.</b> å¯¾ã‚’æ‰‹ç¶šãã¨ã—ã¦è¡¨ã™ã“ã¨ãŒã€ååˆ†ã«é©šå˜†ã™ã¹ãã“ã¨ã§ã¯ãªã‹ã£ãŸã€ã¨ã„ã†å ´åˆã€æ¬¡ã®ã“ã¨ã‚’è€ƒãˆã¦ã¿ã‚ˆâ€”â€”æ‰‹ç¶šãã‚’æ“ä½œã§ãã‚‹è¨€èªã§ã¯ã€0ã¨ã€1ã‚’è¶³ã™æ¼”ç®—ã¨ã‚’ã€ä»¥ä¸‹ã®ã‚ˆã†ã«å®Ÿè£…ã™ã‚‹ã“ã¨ã§ã€(å°‘ãªãã¨ã‚‚éè² æ•´æ•°ã«é–¢ã™ã‚‹é™ã‚Šã¯) æ•°ãŒãªãã¦ã‚‚ã€ãªã‚“ã¨ã‹ã‚„ã£ã¦ã‚†ã‘ã‚‹ã€‚
</p>

<p class="lisp">(define zero (lambda (f) (lambda (x) x)))

(define (add-1 n)
  (lambda (f) (lambda (x) (f ((n f) x)))))
</p>

<p class="orig" lang="en">
This representation is known as <a name="%_idx_1474"></a><em>Church numerals</em>, after its
inventor, <a name="%_idx_1476"></a>Alonzo Church, the logician who invented the <img src="book-Z-G-D-6.gif" border="0">
calculus.
</p>

<p class="trans" lang="ja">
ã“ã®è¡¨ç¾ã¯ã€ãã®è€ƒæ¡ˆè€…ã§ã‚ã‚‹ã‚¢ãƒ­ãƒ³ã‚¾ãƒ»ãƒãƒ£ãƒ¼ãƒâ€”â€”&lambda;è¨ˆç®—ã‚’è€ƒæ¡ˆã—ãŸè«–ç†å­¦è€…â€”â€”ã«ã¡ãªã‚“ã§ã€<em>ãƒãƒ£ãƒ¼ãƒæ•°</em>ã¨ã—ã¦çŸ¥ã‚‰ã‚Œã¦ã„ã‚‹ã€‚
</p>

<p class="orig" lang="en">
Define <tt>one</tt> and <tt>two</tt> directly (not in terms of <tt>zero</tt>
and <tt>add-1</tt>).  (Hint: Use substitution to evaluate <tt>(add-1 zero)</tt>).
Give a direct definition of the addition procedure <tt>+</tt> (not in
terms of repeated application of <tt>add-1</tt>).
</p>

<p class="trans" lang="ja">
<tt>one</tt> ã¨ <tt>two</tt> ã‚’ç›´æ¥çš„ã« (<tt>zero</tt> ã¨ <tt>add-1</tt> ã‚’ä½¿ã‚ãšã«) å®šç¾©ã›ã‚ˆã€‚
(ãƒ’ãƒ³ãƒˆ: ä»£å…¥ã‚’ä½¿ã£ã¦ <tt>(add-1 zero)</tt> ã‚’è©•ä¾¡ã—ã¦ã¿ã‚ˆã€‚)
åŠ ç®—æ‰‹ç¶šãã§ã‚ã‚‹ <tt>+</tt> ã®ã€ç›´æ¥çš„ãªå®šç¾© (<tt>add-1</tt> ã®ç¹°ã‚Šè¿”ã—é©ç”¨ã‚’ä½¿ã‚ãªã„ã‚‚ã®) ã‚’æç¤ºã›ã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment">; ãƒ’ãƒ³ãƒˆã«ã—ãŸãŒã£ã¦ä»£å…¥ã—ã¦ã¿ã‚‹ã€‚</span>
(add-1 zero)
(lambda (f) (lambda (x) (f ( (    zero                    f) x) ) ) )
(lambda (f) (lambda (x) (f ( ((lambda (f) (lambda (x) x)) f) x) ) ) )
(lambda (f) (lambda (x) (f (    (lambda (x) x)               x) ) ) )
(lambda (f) (lambda (x) (f (              x                   ) ) ) )

<span class="ex_comment">; ã¨ã„ã†ã‚ã‘ã§</span>
(define one (lambda (f) (lambda (x) (f (x)))))


</p>

<a name="%_sec_2.1.4"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_2.1.4">2.1.4  Extended Exercise: Interval Arithmetic</a></h3>
<h3 class="trans" lang="ja">2.1.4 ç™ºå±•çš„ç·´ç¿’å•é¡Œ: åŒºé–“ç®—è¡“</h3>

<p class="orig" lang="en">
<a name="%_idx_1478"></a><a name="%_idx_1480"></a>
Alyssa P. Hacker is designing a system to help people solve
engineering problems.  One feature she wants to provide in her system
is the ability to manipulate inexact quantities (such as measured
parameters of physical devices) with known precision, so that when
computations are done with such approximate quantities the results
will be numbers of known precision.
</p>

<p class="trans" lang="ja">
ã‚¢ãƒªãƒƒã‚µãƒ»Pãƒ»ãƒãƒƒã‚«ã¯ã€äººã€…ãŒå·¥å­¦çš„å•é¡Œã‚’è§£ãã®ã‚’æ‰‹åŠ©ã‘ã™ã‚‹ã‚·ã‚¹ãƒ†ãƒ ã‚’è¨­è¨ˆã—ã¦ã„ã‚‹ã¨ã“ã‚ã ã€‚
å½¼å¥³ãŒè‡ªåˆ†ã®ã‚·ã‚¹ãƒ†ãƒ ã§æä¾›ã—ãŸã„ç‰¹å¾´ã®ä¸€ã¤ã¯ã€æ—¢çŸ¥ã®ç²¾åº¦ã®ã€å³å¯†ã§ãªã„é‡ (ãŸã¨ãˆã°ã€ç‰©ç†çš„ãªå™¨å…·ã§æ¸¬å®šã•ã‚ŒãŸãƒ‘ãƒ©ãƒ¡ã‚¿ãªã©) ã‚’æ“ä½œã™ã‚‹èƒ½åŠ›ã ã€‚ãã‚Œã«ã‚ˆã‚Šã€ãã†ã„ã†è¿‘ä¼¼çš„ãªé‡ã‚’ä½¿ã£ã¦è¨ˆç®—ãŒè¡Œã‚ã‚Œã‚‹ã¨ãã«ã¯ã€ãã®çµæœã¯ã€æ—¢çŸ¥ã®ç²¾åº¦ã®æ•°ã¨ãªã‚‹ã ã‚ã†ã€‚
</p>

<p class="orig" lang="en">
Electrical engineers will be using Alyssa's system to compute
electrical quantities.  It is sometimes necessary for them to compute
the value of a parallel equivalent resistance <em>R</em><sub><em>p</em></sub> of two
resistors <em>R</em><sub>1</sub> and <em>R</em><sub>2</sub> using the formula
<a name="%_idx_1482"></a>
</p>

<p class="trans" lang="ja">
é›»æ°—ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã¯ã€é›»æ°—çš„ãªé‡ã‚’è¨ˆç®—ã™ã‚‹ã®ã«ã‚¢ãƒªãƒƒã‚µã®ã‚·ã‚¹ãƒ†ãƒ ã‚’ä½¿ã†ã ã‚ã†ã€‚
ã¨ãã¨ã—ã¦é›»æ°—ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã«ã¯ã€ä»¥ä¸‹ã®å…¬å¼ã‚’ç”¨ã„ã¦ã€äºŒã¤ã®æŠµæŠ—å™¨ <em class="en">R</em><sub>1</sub> ã¨ <em class="en">R</em><sub>2</sub> ã®ä¸¦åˆ—æ¥ç¶šã«ç­‰ä¾¡ãªæŠµæŠ— <em class="en">R<sub>p</sub></em> ã‚’è¨ˆç®—ã™ã‚‹ã“ã¨ãŒå¿…è¦ã§ã‚ã‚‹ã€‚
</p>

<figure><img src="ch2-Z-G-8.gif" border="0"></figure>

<p class="orig" lang="en">
Resistance values are usually known only up to some <a name="%_idx_1484"></a>tolerance
guaranteed by the manufacturer of the resistor.  For example, if you
buy a resistor labeled ``6.8 ohms with 10% tolerance'' you can only
be sure that the resistor has a resistance between 6.8 - 0.68 = 6.12 and
6.8 + 0.68 = 7.48 ohms.  Thus, if you have a 6.8-ohm 10% resistor in
parallel with a 4.7-ohm 5% resistor, the resistance of the
combination can range from about 2.58 ohms (if the two resistors are
at the lower bounds) to about 2.97 ohms (if the two resistors are at
the upper bounds).
</p>

<p class="trans" lang="ja">
æŠµæŠ—å€¤ã¯æ™®é€šã€æŠµæŠ—å™¨ã®è£½é€ è€…ã«ã‚ˆã‚Šä¿è¨¼ã•ã‚ŒãŸã€ã‚ã‚‹è¨±å®¹èª¤å·®ç¯„å›²ã¾ã§ã§ã ã‘ã€åˆ†ã‹ã‚‹ã€‚
ãŸã¨ãˆã°ã€ã‚‚ã—ã€Œ6.8ã‚ªãƒ¼ãƒ ã§10%ã®è¨±å®¹èª¤å·®ç¯„å›²ã€ã¨è¡¨ç¤ºã•ã‚ŒãŸæŠµæŠ—å™¨ã‚’è²·ã†ãªã‚‰ã°ã€ãã®æŠµæŠ—å™¨ã®æŠµæŠ—å€¤ãŒ
6.8 &minus; 0.68 = 6.12 ã‚ªãƒ¼ãƒ ã‹ã‚‰
6.8 + 0.68 = 7.48 ã‚ªãƒ¼ãƒ ã¾ã§ã ã€ã¨ã„ã†ã“ã¨ã ã‘ã‚’ç¢ºä¿¡ã§ãã‚‹ã‚ã‘ã ã€‚
ã‚ˆã£ã¦ã€ã‚‚ã—ã€6.8ã‚ªãƒ¼ãƒ ã§10%ã®è¨±å®¹èª¤å·®ç¯„å›²ã®æŠµæŠ—å™¨ã‚’ã€4.7ã‚ªãƒ¼ãƒ ã§5%ã®è¨±å®¹èª¤å·®ç¯„å›²ã®æŠµæŠ—å™¨ã¨ä¸¦åˆ—ã«ã¤ãªã„ã ã‚‰ã€åˆæˆæŠµæŠ—ã¯ã€ç´„2.58ã‚ªãƒ¼ãƒ  (äºŒã¤ã®æŠµæŠ—å™¨ãŒä¸‹é™å€¤ã§ã‚ã‚‹å ´åˆ) ã‹ã‚‰ç´„2.97ã‚ªãƒ¼ãƒ  (äºŒã¤ã®æŠµæŠ—å™¨ãŒä¸Šé™å€¤ã§ã‚ã‚‹å ´åˆ) ã¾ã§ã®ç¯„å›²ã«åŠã³å¾—ã‚‹ã€‚
</p>

<p class="orig" lang="en">
Alyssa's idea is to implement ``interval arithmetic'' as a set of
arithmetic operations for combining ``intervals'' (objects
that represent the range of possible values of an inexact quantity).
The result of adding, subtracting, multiplying, or dividing two
intervals is itself an interval, representing the range of the
result.
</p>

<p class="trans" lang="ja">
ã‚¢ãƒªãƒƒã‚µã®è€ƒãˆã¯ã€ã€ŒåŒºé–“ã€(å³å¯†ã§ãªã„é‡ã®ã€å¯èƒ½ãªå€¤ã®ç¯„å›²ã‚’è¡¨ã™ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ) åŒå£«ã‚’åˆæˆã™ã‚‹ç®—è¡“æ¼”ç®—ã®ä¸€æƒã„ã¨ã—ã¦ã€ã€ŒåŒºé–“ç®—è¡“ã€ã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚
äºŒã¤ã®åŒºé–“ã‚’è¶³ã—ãŸã‚Šã€å¼•ã„ãŸã‚Šã€æ›ã‘ãŸã‚Šã€å‰²ã£ãŸã‚Šã—ãŸçµæœã¯ã€ãã‚Œè‡ªä½“ãŒåŒºé–“ã§ã‚ã‚Šã€ãã®çµæœã®ç¯„å›²ã‚’è¡¨ã™ã€‚
</p>

<p class="orig" lang="en">
Alyssa postulates the existence of an abstract object called an
``interval'' that has two endpoints: a lower bound and an upper bound.
She also presumes that, given the endpoints of an interval, she can
construct the interval using the data constructor <a name="%_idx_1486"></a><tt>make-interval</tt>.
Alyssa first writes a procedure for adding two intervals.  She
reasons that the minimum value the sum could be is the sum of the two
lower bounds and the maximum value it could be is the sum of the two
upper bounds:
</p>

<p class="trans" lang="ja">
ã‚¢ãƒªãƒƒã‚µã¯ã€äºŒã¤ã®ç«¯ç‚¹â€”â€”ä¸‹é™ã¨ä¸Šé™â€”â€”ã‚’æœ‰ã—ã€ŒåŒºé–“ã€ã¨å‘¼ã°ã‚Œã‚‹æŠ½è±¡çš„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å­˜åœ¨ã‚’ä»®å®šã—ã¦ã„ã‚‹ã€‚
å½¼å¥³ã¯ã€åŒºé–“ã®ä¸¡ç«¯ç‚¹ãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãã€<tt>make-interval</tt> ã¨ã„ã†ãƒ‡ãƒ¼ã‚¿ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’ä½¿ã£ã¦ã€ãã®åŒºé–“ã‚’æ§‹ç¯‰ã§ãã‚‹ã€ã¨ã‚‚æƒ³å®šã—ã¦ã„ã‚‹ã€‚
ã‚¢ãƒªãƒƒã‚µã¯ã¾ãšäºŒã¤ã®åŒºé–“ã‚’è¶³ã™ãŸã‚ã®æ‰‹ç¶šãã‚’æ›¸ãã€‚
å½¼å¥³ã¯ã€å’Œã®æœ€å°å€¤ã¯äºŒã¤ã®ä¸‹é™åŒå£«ã®å’Œã ã‚ã†ã—ã€å’Œã®æœ€å¤§å€¤ã¯äºŒã¤ã®ä¸Šé™ã®å’Œã ã‚ã†ã€ã¨æ¨è«–ã™ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_1488"></a>(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                 (+ (upper-bound x) (upper-bound y))))
</p>

<p class="orig" lang="en">
Alyssa also works out the product of two intervals by finding the
minimum and the maximum of the products of the bounds and using them
as the bounds of the resulting interval.  (<tt>Min</tt> and <tt>max</tt> are
<a name="%_idx_1490"></a><a name="%_idx_1492"></a><a name="%_idx_1494"></a><a name="%_idx_1496"></a>primitives that find the minimum or maximum of any number of
arguments.)
</p>

<p class="trans" lang="ja">
å¢ƒç•Œå€¤åŒå£«ã®ç©ã®ã†ã¡ã®æœ€å°å€¤ã¨æœ€å¤§å€¤ã‚’è¦‹ã¤ã‘ã€ãã‚Œã‚‰ã‚’ã€çµæœã¨ã—ã¦ç”Ÿã˜ã‚‹åŒºé–“ã®å¢ƒç•Œå€¤ã¨ã—ã¦ä½¿ã†ã“ã¨ã§ã€ã‚¢ãƒªãƒƒã‚µã¯ã€äºŒã¤ã®åŒºé–“ã®ç©ã‚‚åˆ†ã‹ã‚‹ã€‚
(<tt>min</tt> ã¨ <tt>max</tt> ã¯ã€ä»»æ„ã®å€‹æ•°ã®å¼•æ•°ã®ã†ã¡ã®æœ€å°å€¤ã¨æœ€å¤§å€¤ã‚’æ±‚ã‚ã‚‹ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã§ã‚ã‚‹ã€‚)
</p>

<p class="lisp"><a name="%_idx_1498"></a>(define (mul-interval x y)
  (let ((p1 (* (lower-bound x) (lower-bound y)))
        (p2 (* (lower-bound x) (upper-bound y)))
        (p3 (* (upper-bound x) (lower-bound y)))
        (p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
                   (max p1 p2 p3 p4))))
</p>

<p class="orig" lang="en">
To divide two intervals, Alyssa multiplies the first by the reciprocal of
the second.  Note that the bounds of the reciprocal interval are
the reciprocal of the upper bound and the reciprocal of the lower bound, in
that order.
</p>

<p class="trans" lang="ja">
äºŒã¤ã®åŒºé–“ã®å‰²ã‚Šç®—ã‚’ã™ã‚‹ãŸã‚ã«ã€ã‚¢ãƒªãƒƒã‚µã¯ã€ä¸€ã¤ç›®ã«äºŒã¤ç›®ã®é€†æ•°ã‚’æ›ã‘ã‚‹ã€‚
é€†æ•°ã®åŒºé–“ã®å¢ƒç•Œå€¤ã¯ã€ä¸Šé™ã®é€†æ•°ã¨ä¸‹é™ã®é€†æ•°ã§ã‚ã‚Šã€ã“ã®æ›¸ã„ãŸé †ã§ä¸‹é™ã€ä¸Šé™ã§ã‚ã‚‹ã€‚
<!--å…ƒã®åŒºé–“ã®ä¸‹é™ãŒè² ã§ä¸Šé™ãŒæ­£ã®ã¨ãã€ãªã‚“ã‹ã†ã¾ãã„ã‹ãªã„æ°—ãŒã™ã‚‹ãŒâ€¦â€¦-->
</p>

<p class="lisp"><a name="%_idx_1500"></a>(define (div-interval x y)
  (mul-interval x 
                (make-interval (/ 1.0 (upper-bound y))
                               (/ 1.0 (lower-bound y)))))
</p>

<p class="orig" lang="en"><a name="%_thm_2.7"></a>
<b>Exercise 2.7.</b>  Alyssa's program is incomplete because she has not specified the
implementation of the interval abstraction.  Here is a definition of
the interval constructor:
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œs2.7.</b> ã‚¢ãƒªãƒƒã‚µã¯ã€åŒºé–“ã®æŠ½è±¡æ¦‚å¿µã®å®Ÿè£…ã«ã¤ã„ã¦æ˜ç´°ã‚’ã¾ã æŒ‡å®šã—ã¦ã„ãªã„ã®ã§ã€å½¼å¥³ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ä¸å®Œå…¨ã§ã‚ã‚‹ã€‚
ã“ã“ã«åŒºé–“ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®å®šç¾©ãŒã‚ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_1502"></a>(define (make-interval a b) (cons a b))
</p>

<p class="orig" lang="en">
Define selectors <a name="%_idx_1504"></a><tt>upper-bound</tt> and <a name="%_idx_1506"></a><tt>lower-bound</tt> to complete
the implementation.
</p>

<p class="trans" lang="ja">
å®Ÿè£…ã‚’å®Œæˆã•ã›ã‚‹ãŸã‚ã€<tt>upper-bound</tt> ã¨ <tt>lower-bound</tt> ã¨ã„ã†ã‚»ãƒ¬ã‚¯ã‚¿ã‚’å®šç¾©ã›ã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_2.8"></a>
<b>Exercise 2.8.</b>  Using reasoning analogous to Alyssa's, describe how the difference
of two intervals may be computed.  Define a corresponding subtraction
procedure, called <a name="%_idx_1508"></a><tt>sub-interval</tt>.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.8.</b> ã‚¢ãƒªãƒƒã‚µã®æ¨è«–ã¨ä¼¼ãŸã‚ˆã†ãªæ¨è«–ã‚’ä½¿ã£ã¦ã€äºŒã¤ã®åŒºé–“ã®å·®ãŒã©ã®ã‚ˆã†ã«è¨ˆç®—ã•ã‚Œå¾—ã‚‹ã‹ã‚’èª¬æ˜ã›ã‚ˆã€‚
å¯¾å¿œã™ã‚‹æ¸›ç®—æ‰‹ç¶šãâ€”â€”<tt>sub-interval</tt> ã¨å‘¼ã°ã‚Œã‚‹â€”â€”ã‚’å®šç¾©ã›ã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_2.9"></a>
<b>Exercise 2.9.</b>  <a name="%_idx_1510"></a>The <em>width</em> of an interval is half of the difference between its
upper and lower bounds.  The width is a measure of the uncertainty of
the number specified by the interval.  For some arithmetic operations
the width of the result of combining two intervals is a function only
of the widths of the argument intervals, whereas for others the width
of the combination is not a function of the widths of the argument
intervals.  Show that the width of the sum (or difference) of two
intervals is a function only of the widths of the intervals being
added (or subtracted).  Give examples to show that this is not true
for multiplication or division.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.9.</b> åŒºé–“ã®<em>å¹…</em>ã¨ã¯ã€åŒºé–“ã®ä¸Šé™ã¨ä¸‹é™ã®å·®ã®åŠåˆ†ã§ã‚ã‚‹ã€‚
å¹…ã¯ã€åŒºé–“ã«ã‚ˆã‚Šç‰¹å®šã•ã‚Œã‚‹æ•°ã®ä¸ç¢ºå®Ÿæ€§ã®å°ºåº¦ã§ã‚ã‚‹ã€‚
ã‚ã‚‹ç¨®ã®ç®—è¡“æ¼”ç®—ã§ã¯ã€äºŒã¤ã®åŒºé–“ã‚’çµåˆã—ãŸçµæœã®å¹…ã¯ã€å¼•æ•°ãŸã‚‹ä¸¡åŒºé–“ã®å¹…ã®ã¿ã®é–¢æ•°ã ãŒã€ä»–ã®ç®—è¡“æ¼”ç®—ã§ã¯ã€çµåˆã—ãŸã‚‚ã®ã®å¹…ã¯ã€å¼•æ•°ãŸã‚‹ä¸¡åŒºé–“ã®å¹…ã®é–¢æ•°ã§ã¯ãªã„ã€‚
äºŒã¤ã®ã®åŒºé–“ã®å’Œ (ã¾ãŸã¯å·®) ã®å¹…ãŒã€è¶³ã—ç®— (ã¾ãŸã¯å¼•ãç®—) ã•ã‚Œã‚‹ä¸¡åŒºé–“ã®å¹…ã®ã¿ã®é–¢æ•°ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã›ã€‚
ã“ã®ã“ã¨ãŒæ›ã‘ç®—ã‚„å‰²ã‚Šç®—ã«ã¯å½“ã¦ã¯ã¾ã‚‰ãªã„ã“ã¨ã‚’ç¤ºã™ä¾‹ã‚’æç¤ºã›ã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_2.10"></a>
<b>Exercise 2.10.</b>  <a name="%_idx_1512"></a>Ben Bitdiddle, an expert systems programmer, looks over Alyssa's
shoulder and comments that it is not clear what it means to
divide by an interval that spans zero.  Modify Alyssa's code to
check for this condition and to signal an error if it occurs.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.10.</b> ç†Ÿç·´ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ã‚°ãƒ©ãƒã§ã‚ã‚‹ãƒ™ãƒ³ãƒ»ãƒ“ãƒƒãƒˆãƒ‡ã‚£ãƒ‰ãƒ«ã¯ã€ã‚¢ãƒªãƒƒã‚µã‚’æ³¨æ„æ·±ãè¦‹å®ˆã‚Šã€ã‚¼ãƒ­ã‚’ã¾ãŸãåŒºé–“ã«ã‚ˆã‚Šå‰²ã‚‹ã“ã¨ã®æ„å‘³ãŒæ˜ã‚‰ã‹ã§ãªã„ã€ã¨è«–è©•ã™ã‚‹ã€‚
ã‚¢ãƒªãƒƒã‚µã®ã‚³ãƒ¼ãƒ‰ã‚’ã€ã“ã®æ¡ä»¶ã‚’èª¿ã¹ã¦ã€ã‚‚ã—ã“ã‚ŒãŒç”Ÿã˜ãŸã‚‰ã‚¨ãƒ©ãƒ¼ã‚’çŸ¥ã‚‰ã›ã‚‹ã‚ˆã†ã«ã€ä¿®æ­£ã›ã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_2.11"></a>
<b>Exercise 2.11.</b>  <a name="%_idx_1514"></a>In passing, Ben also cryptically comments: ``By testing the signs of
the endpoints of the intervals, it is possible to break <tt>mul-interval</tt> into nine cases, only one of which requires more than
two multiplications.''  Rewrite this procedure using Ben's
suggestion.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.11.</b> ãƒ™ãƒ³ã¯ã¤ã„ã§ã«ã€ã€ŒåŒºé–“ã®ä¸¡ç«¯ç‚¹ã®ç¬¦å·ã‚’ãƒ†ã‚¹ãƒˆã™ã‚‹ã“ã¨ã§ã€<tt>mul-interval</tt> ã‚’ä¹ã¤ã®å ´åˆã«åˆ†ã‘ã‚‹ã“ã¨ãŒå¯èƒ½ã§ã€ãã®ã†ã¡ã®ä¸€ã¤ã®ã¿ãŒä¹—ç®—ã‚’äºŒå›ã‚ˆã‚Šå¤šãå¿…è¦ã¨ã™ã‚‹ã‚“ã ã‚ˆã€ã¨è¬ã‚ã„ãŸè«–è©•ã‚’ã™ã‚‹ã€‚
ãƒ™ãƒ³ã®ç¤ºå”†ã‚’åˆ©ç”¨ã—ã¦ã€ã“ã®æ‰‹ç¶šãã‚’æ›¸ãç›´ã›ã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
After debugging her program, Alyssa shows it to a potential user,
who complains that her program solves the wrong problem.  He
wants a program that can deal with numbers represented as a center
value and an additive tolerance; for example, he wants to work with
intervals such as 3.5&plusmn; 0.15 rather than [3.35, 3.65].  Alyssa 
returns to her desk and fixes this problem by supplying an alternate
constructor and alternate selectors:
</p>

<p class="trans" lang="ja">
è‡ªåˆ†ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ãƒ‡ãƒãƒƒã‚°ã—ãŸå¾Œã€ã‚¢ãƒªãƒƒã‚µã¯ãã‚Œã‚’æ½œåœ¨çš„ãƒ¦ãƒ¼ã‚¶ã«è¦‹ã›ãŸã®ã ãŒã€ãã®äººã¯ã‚¢ãƒªãƒƒã‚µã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒé–“é•ã£ãŸå•é¡Œã‚’è§£ã„ã¦ã„ã‚‹ã¨æ–‡å¥ã‚’è¨€ã£ãŸã€‚
å½¼ã¯ã€ä¸­å¿ƒå€¤ã¨åŠ æ³•çš„ãªè¨±å®¹èª¤å·®ã¨ã—ã¦è¡¨ã•ã‚ŒãŸæ•°ã‚’æ‰±ãˆã‚‹ã‚ˆã†ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒæ¬²ã—ã„ã®ã ã€‚å½¼ã¯ã€ãŸã¨ãˆã°ã€[3.35, 3.65] ã‚ˆã‚Šã‚€ã—ã‚ <span class="math">3.5&plusmn; 0.15</span> ã®ã‚ˆã†ãªåŒºé–“ã‚’ä½¿ã£ã¦ä½œæ¥­ã‚’ã—ãŸãŒã£ã¦ã„ã‚‹ã€‚
ã‚¢ãƒªãƒƒã‚µã¯è‡ªåˆ†ã®æœºã«æˆ»ã‚Šã€ä»£ã‚ã‚Šã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¨ä»£ã‚ã‚Šã®ã‚»ãƒ¬ã‚¯ã‚¿ã‚’æä¾›ã™ã‚‹ã“ã¨ã§ã€ã“ã®å•é¡Œã‚’ç›´ã™ã€‚
</p>

<p class="lisp"><a name="%_idx_1516"></a>(define (make-center-width c w)
  (make-interval (- c w) (+ c w)))
<a name="%_idx_1518"></a>(define (center i)
  (/ (+ (lower-bound i) (upper-bound i)) 2))
<a name="%_idx_1520"></a>(define (width i)
  (/ (- (upper-bound i) (lower-bound i)) 2))
</p>

<p class="orig" lang="en">
Unfortunately, most of Alyssa's users are engineers.  Real engineering
situations usually involve measurements with only a small uncertainty,
measured as the ratio of the width of the interval to the midpoint of
the interval.  Engineers usually specify percentage tolerances on the
parameters of devices, as in the resistor specifications given
earlier.
</p>

<p class="trans" lang="ja">
ã‚ã„ã«ãã€ã‚¢ãƒªãƒƒã‚µã«ã¨ã£ã¦ã®ãƒ¦ãƒ¼ã‚¶ã®ã»ã¨ã‚“ã©ã¯ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã§ã‚ã‚‹ã€‚
ç¾å®Ÿã®å·¥å­¦ã®çŠ¶æ³ã¯ã€æ™®é€šã€å°ã•ãªä¸ç¢ºå®Ÿæ€§â€”â€”åŒºé–“ã®ä¸­ç‚¹ã«å¯¾ã™ã‚‹ã€åŒºé–“ã®å¹…ã®å‰²åˆã¨ã—ã¦æ¸¬ã‚‰ã‚Œã‚‹â€”â€”ã—ã‹ãªã„ã‚ˆã†ãªæ¸¬å®šå€¤ã«é–¢é€£ã—ã¦ã„ã‚‹ã€‚
æ™®é€šã€ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã¯ã€æ©Ÿå™¨ã®ãƒ‘ãƒ©ãƒ¡ã‚¿ã«é–¢ã—ã¦ã€ãƒ‘ãƒ¼ã‚»ãƒ³ãƒ†ãƒ¼ã‚¸ã§ç¤ºã—ãŸè¨±å®¹èª¤å·®ã‚’æŒ‡å®šã™ã‚‹â€”â€”å‰ã«ç¤ºã—ãŸã€æŠµæŠ—å™¨ã®ä»•æ§˜ã®ã‚ˆã†ã«ã€‚
</p>

<p class="orig" lang="en"><a name="%_thm_2.12"></a>
<b>Exercise 2.12.</b>  Define a constructor <a name="%_idx_1522"></a><tt>make-center-percent</tt> that takes a center and
a percentage tolerance and produces the desired interval.  You must
also define a selector <tt>percent</tt> that produces the
percentage tolerance for a given interval.  The <tt>center</tt> selector
is the same as the one shown above.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.12.</b> ä¸­å¿ƒç‚¹ã¨ã€ãƒ‘ãƒ¼ã‚»ãƒ³ãƒ†ãƒ¼ã‚¸ã§ç¤ºã—ãŸè¨±å®¹èª¤å·®ã¨ã‚’å—ã‘å–ã‚Šã€æ‰€æœ›ã®åŒºé–“ã‚’ä½œã‚Šå‡ºã™ã‚ˆã†ãªã€<tt>make-center-percent</tt> ã¨ã„ã†ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’å®šç¾©ã›ã‚ˆã€‚
ä¸ãˆã‚‰ã‚ŒãŸåŒºé–“ã«ã¤ã„ã¦ã®ã€ãƒ‘ãƒ¼ã‚»ãƒ³ãƒ†ãƒ¼ã‚¸ã§ç¤ºã—ãŸè¨±å®¹èª¤å·®ã‚’ä½œã‚Šå‡ºã™ã‚ˆã†ãªã€<tt>percent</tt> ã¨ã„ã†ã‚»ãƒ¬ã‚¯ã‚¿ã‚‚å®šç¾©ã›ã­ã°ãªã‚‰ãªã„ã€‚
<tt>center</tt> ã¨ã„ã†ã‚»ãƒ¬ã‚¯ã‚¿ã¯ã€ä¸Šè¨˜ã®ã‚‚ã®ã¨åŒã˜ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="%_thm_2.13"></a>
<b>Exercise 2.13.</b>  Show that under the assumption of small percentage tolerances there is
a simple formula for the approximate percentage tolerance of the
product of two intervals in terms of the tolerances of the factors.
You may simplify the problem by assuming that all numbers are
positive.
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.13.</b> ãƒ‘ãƒ¼ã‚»ãƒ³ãƒ†ãƒ¼ã‚¸ã§ç¤ºã—ãŸè¨±å®¹èª¤å·®ãŒå°ã•ã„ã¨ã„ã†ä»®å®šã®ä¸‹ã§ã¯ã€äºŒã¤ã®åŒºé–“ã®ç©ã®ã€ãƒ‘ãƒ¼ã‚»ãƒ³ãƒ†ãƒ¼ã‚¸ã§ç¤ºã—ãŸè¿‘ä¼¼çš„ãªè¨±å®¹èª¤å·®ã‚’ã€ä¸¡å› æ•°ã®è¨±å®¹èª¤å·®ã‚’ä½¿ã£ã¦è¡¨ã™ã‚ˆã†ãªã€ç°¡å˜ãªå…¬å¼ãŒã‚ã‚‹ã€‚
ã™ã¹ã¦ã®æ•°ãŒæ­£ã ã¨ä»®å®šã™ã‚‹ã“ã¨ã§ã€å•é¡Œã‚’ç°¡å˜åŒ–ã—ã¦ã‚‚ã‚ˆã„ã€‚
</p>

<p class="orig" lang="en">After considerable work, Alyssa P. Hacker delivers her finished
system.  Several years later, after she has forgotten all about it, she
gets a frenzied call from an irate user,  Lem E. Tweakit.
It seems that Lem has
noticed that the formula for parallel resistors can be written in two
<a name="%_idx_1524"></a>algebraically equivalent ways:
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="trans" lang="ja">
ã‹ãªã‚Šã®ä½œæ¥­ã®å¾Œã€ã‚¢ãƒªãƒƒã‚µãƒ»Pãƒ»ãƒãƒƒã‚«ã¯ã€ä»•ä¸Šã’ãŸã‚·ã‚¹ãƒ†ãƒ ã‚’æä¾›ã™ã‚‹ã€‚
æ•°å¹´å¾Œã€ãã‚Œã«ã¤ã„ã¦ã®ã™ã¹ã¦ã‚’å¿˜ã‚ŒãŸå¾Œã«ãªã£ã¦ã‹ã‚‰ã€ã‚¢ãƒªãƒƒã‚µã¯ã€ãƒ¬ãƒ ãƒ»Eãƒ»ãƒ„ã‚¤ãƒ¼ã‚­ãƒƒãƒˆã¨ã„ã†æ¿€æ€’ã—ãŸãƒ¦ãƒ¼ã‚¶ã‹ã‚‰ã€åŠç‹‚ä¹±ã®é›»è©±ã‚’å—ã‘ãŸã€‚
ã©ã†ã‚„ã‚‰ã€ãƒ¬ãƒ ã¯ã€ä¸¦åˆ—æ¥ç¶šã®æŠµæŠ—å™¨ã®å…¬å¼ãŒã€ä»£æ•°çš„ã«ç­‰ä¾¡ãªäºŒã¤ã®æ–¹æ³•ã§æ›¸ã‘ã‚‹ã“ã¨ã«æ°—ã¥ã„ãŸã‚‰ã—ã„ã€‚
</p>

<figure>
<img src="ch2-Z-G-9.gif" border="0"><br>
and<br>
<img src="ch2-Z-G-10.gif" border="0">
</figure>

<p class="orig" lang="en">
He has written the following two programs, each of which computes the
parallel-resistors formula differently:
</p>

<p class="trans" lang="ja">
å½¼ã¯ä»¥ä¸‹ã®äºŒã¤ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ã„ãŸâ€”â€”ã“ã‚Œã‚‰ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®å„ã€…ã¯ã€ä¸¦åˆ—æ¥ç¶šã®æŠµæŠ—å™¨ã®å…¬å¼ã‚’ã€é•ã†ã‚„ã‚Šæ–¹ã§è¨ˆç®—ã™ã‚‹ã€‚
</p>

<p class="lisp">(define (par1 r1 r2)
  (div-interval (mul-interval r1 r2)
                (add-interval r1 r2)))
(define (par2 r1 r2)
  (let ((one (make-interval 1 1))) 
    (div-interval one
                  (add-interval (div-interval one r1)
                                (div-interval one r2)))))
</p>

<p class="orig" lang="en">
Lem complains that Alyssa's program gives different answers for
the two ways of computing. This is a serious complaint.
</p>

<p class="trans" lang="ja">
äºŒã¤ã®è¨ˆç®—æ–¹æ³•ã«å¯¾ã—ã¦ã€ã‚¢ãƒªãƒƒã‚µã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ç•°ãªã‚‹ç­”ãˆã‚’å‡ºã™ã€ã¨ãƒ¬ãƒ ã¯è‹¦æƒ…ã‚’è¨€ã†ã€‚
ã“ã‚Œã¯æ·±åˆ»ãªè‹¦æƒ…ã ã€‚
</p>

<p class="orig" lang="en"><a name="%_thm_2.14"></a>
<b>Exercise 2.14.</b>  Demonstrate that Lem is right. Investigate the behavior of the
system on a variety of arithmetic expressions. Make some intervals <em>A</em> and <em>B</em>,
and use them in computing the expressions <em>A</em>/<em>A</em> and <em>A</em>/<em>B</em>.  You will
get the most insight by using intervals whose width is a small
percentage of the center value. Examine the results of the computation
in center-percent form (see exercise <a href="#%_thm_2.12">2.12</a>).
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.14.</b> ãƒ¬ãƒ ãŒæ­£ã—ã„ã“ã¨ã‚’è¨¼æ˜ã›ã‚ˆã€‚
æ§˜ã€…ãªç®—è¡“å¼ã«é–¢ã—ã¦ã€ã‚·ã‚¹ãƒ†ãƒ ã®æŒ¯ã‚‹èˆã„ã‚’èª¿æŸ»ã›ã‚ˆã€‚
ä½•ã‚‰ã‹ã®åŒºé–“ <em class="en">A</em> ã¨ <em class="en">B</em> ã‚’ä½œã‚Šã€
<span class="math"><em class="en">A</em>/<em class="en">A</em></span> 
ã¨ 
<span class="math"><em class="en">A</em>/<em class="en">B</em></span> 
ã¨ã„ã†å¼ã‚’è¨ˆç®—ã™ã‚‹ã®ã«ã€ãã‚Œã‚‰ <em class="en">A</em> ã¨ <em class="en">B</em> ã‚’ä½¿ãˆã€‚
å¹…ãŒä¸­å¿ƒå€¤ã«å¯¾ã—ã¦å°ã•ãªãƒ‘ãƒ¼ã‚»ãƒ³ãƒ†ãƒ¼ã‚¸ã§ã‚ã‚‹ã‚ˆã†ãªåŒºé–“ã‚’ä½¿ã†ã“ã¨ã§ã€å›ã¯å¤§æŠµã®æ´å¯Ÿã‚’å¾—ã‚‹ã ã‚ã†ã€‚
ä¸­å¿ƒå€¤ã¨ãƒ‘ãƒ¼ã‚»ãƒ³ãƒ†ãƒ¼ã‚¸ã®å½¢å¼ã§ã®è¨ˆç®—ã®çµæœã‚’åŸå‘³ã›ã‚ˆ (ç·´ç¿’å•é¡Œ<a href="#%_thm_2.12">2.12</a>ã‚’å‚ç…§)ã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_2.15"></a>
<b>Exercise 2.15.</b>  Eva Lu Ator, another user, has also noticed the different intervals
computed by different but algebraically equivalent expressions. She
says that a formula to compute with intervals using Alyssa's system
will produce tighter error bounds if it can be written in such a form
that no variable that represents an uncertain number is repeated.
Thus, she says, <tt>par2</tt> is a ``better'' program for parallel
resistances than <tt>par1</tt>.  Is she right?  Why?
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.15.</b> ã‚‚ã†ä¸€äººã®ãƒ¦ãƒ¼ã‚¶ã§ã‚ã‚‹ã‚¨ãƒ´ã‚¡ãƒ»ãƒªãƒ¥ãƒ»ã‚¨ã‚¤ã‚¿ã‚‚ã€ç•°ãªã£ã¦ã¯ã„ã‚‹ãŒä»£æ•°çš„ã«ã¯ç­‰ä¾¡ãªå¼ã«ã‚ˆã‚Šè¨ˆç®—ã•ã‚ŒãŸã€ç•°ãªã‚‹åŒºé–“ã«æ°—ãŒã¤ã„ãŸã€‚
ã‚¢ãƒªãƒƒã‚µã®ã‚·ã‚¹ãƒ†ãƒ ã‚’ä½¿ã£ã¦åŒºé–“ã‚’ç”¨ã„ãŸè¨ˆç®—ã‚’ã™ã‚‹ãŸã‚ã®å…¬å¼ã¯ã€ã‚‚ã—ã€ä¸ç¢ºã‹ãªæ•°ã‚’è¡¨ã™å¤‰æ•°ãŒä¸€ã¤ã‚‚ç¹°ã‚Šè¿”ã•ã‚Œãªã„ã‚ˆã†ãªå½¢å¼ã§æ›¸ã‹ã‚Œå¾—ã‚‹ãªã‚‰ã°ã€ã‚ˆã‚Šãã¤ã„ã€é–“é•ã£ãŸå¢ƒç•Œã‚’ä½œã‚Šå‡ºã—ã¦ã—ã¾ã†ã ã‚ã†ã€ã¨å½¼å¥³ã¯è¨€ã†ã€‚
ã‚ˆã£ã¦ã€<tt>par1</tt> ã‚ˆã‚Šã‚‚ <tt>par2</tt> ã®æ–¹ãŒã€ä¸¦åˆ—ã®æŠµæŠ—ã«ã¤ã„ã¦ã®ã€Œã¾ã—ãªã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã‚ã‚‹ã€ã¨å½¼å¥³ã¯è¨€ã†ã€‚
å½¼å¥³ã¯æ­£ã—ã„ã‹?
ãã‚Œã¯ãªãœ?
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_2.16"></a>
<b>Exercise 2.16.</b>  Explain, in general, why equivalent algebraic expressions may lead to
different answers.  Can you devise an interval-arithmetic package that
does not have this shortcoming, or is this task impossible?  (Warning:
This problem is very difficult.)
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.16.</b> ç­‰ä¾¡ãªä»£æ•°å¼ãŒã€ãªãœç•°ãªã‚‹ç­”ãˆã‚’å‡ºã—ã¦ã—ã¾ã†ã“ã¨ãŒã‚ã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã«ã¤ã„ã¦ã€ä¸€èˆ¬çš„ã«èª¬æ˜ã›ã‚ˆã€‚
ã“ã®æ¬ ç‚¹ã®ãªã„åŒºé–“ç®—è¡“ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’ã€å›ã¯è€ƒæ¡ˆã§ãã‚‹ã‹ãª? ã‚ã‚‹ã„ã¯ã€ã“ã®èª²é¡Œã¯ä¸å¯èƒ½ãªã‚‚ã®ã ã‚ã†ã‹?
(è­¦å‘Š: ã“ã®å•é¡Œã¯ã¨ã¦ã‚‚é›£ã—ã„ã‚ˆã€‚)
</p>

<p class="exercise"><span class="ex_comment">
</span></p>



<a name="footnotes"></a>
<hr>

<p class="orig" lang="en"><a name="footnote_Temp_133" href="#call_footnote_Temp_133"><sup><small>2</small></sup></a> The name <a name="%_idx_1332"></a><tt>cons</tt> stands for ``construct.''  The
names <a name="%_idx_1334"></a><tt>car</tt> and <a name="%_idx_1336"></a><tt>cdr</tt> derive from the original implementation of
Lisp on the <a name="%_idx_1338"></a><a name="%_idx_1340"></a>IBM 704.  That machine had an addressing scheme that
allowed one to reference the ``address'' and ``decrement'' parts of a
memory location.  <tt>Car</tt> stands for ``Contents of Address part of
Register'' and <tt>cdr</tt> (pronounced ``could-er'') stands for
``Contents of Decrement part of Register.''
</p>

<p class="trans" lang="ja">
<tt>cons</tt> ã¨ã„ã†åå‰ã¯ã€&ldquo;construct&rdquo; ã‚’æ„å‘³ã™ã‚‹ã€‚
<tt>car</tt> ã¨ <tt>cdr</tt> ã¨ã„ã†åå‰ã¯ã€IBM 704ä¸Šã®Lispã®æœ€åˆã®å®Ÿè£…ã«ç”±æ¥ã™ã‚‹ã€‚
ãã®ãƒã‚·ãƒ³ã¯ã€ãƒ¡ãƒ¢ãƒªã®å ´æ‰€ã®ã€ã€Œã‚¢ãƒ‰ãƒ¬ã‚¹ã€éƒ¨ã¨ã€Œãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã€éƒ¨ã¨ã‚’å‚ç…§ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ã‚ˆã†ãªã€ã‚¢ãƒ‰ãƒ¬ãƒƒã‚·ãƒ³ã‚°æ‰‹æ³•ã‚’ã¨ã£ã¦ã„ãŸã€‚
<tt>car</tt> ã¯ã€&ldquo;Contents of Address part of Register&rdquo; (ãƒ¬ã‚¸ã‚¹ã‚¿ã®ã‚¢ãƒ‰ãƒ¬ã‚¹éƒ¨ã®å†…å®¹) ã‚’æ„å‘³ã—ã€<tt>cdr</tt> (ã€Œã‚¯ãƒƒãƒ€ã€ã¨ç™ºéŸ³ã™ã‚‹) ã¯ã€&ldquo;Contents of Decrement part of Register&rdquo; (ãƒ¬ã‚¸ã‚¹ã‚¿ã®ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆéƒ¨ã®å†…å®¹) ã‚’æ„å‘³ã™ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_135" href="#call_footnote_Temp_135"><sup><small>3</small></sup></a> Another way to define the selectors and constructor is
</p>

<p class="trans" lang="ja">
ã‚»ãƒ¬ã‚¯ã‚¿ã¨ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’å®šç¾©ã™ã‚‹åˆ¥ã®æ–¹æ³•ã¯ã€ä»¥ä¸‹ã®ã¨ãŠã‚Šã§ã‚ã‚‹ã€‚
</p>

<p class="lisp">(define make-rat cons)
(define numer car)
(define denom cdr)
</p>

<p class="orig" lang="en">
The first definition associates the name <tt>make-rat</tt>
with the value of the expression <tt>cons</tt>, which is the primitive
procedure that constructs pairs.  Thus <tt>make-rat</tt> and <tt>cons</tt>
are names for the same primitive constructor.
</p>

<p class="trans" lang="ja">
ä¸€ã¤ç›®ã®å®šç¾©ã¯ã€<tt>make-rat</tt> ã¨ã„ã†åå‰ã‚’ã€<tt>cons</tt> ã¨ã„ã†å¼â€”â€”ã“ã‚Œã¯å¯¾ã‚’æ§‹ç¯‰ã™ã‚‹ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ãªæ‰‹ç¶šãã§ã‚ã‚‹â€”â€”ã®å€¤ã«é–¢é€£ã¥ã‘ã¦ã„ã‚‹ã€‚
ã‚ˆã£ã¦ã€ <tt>make-rat</tt> ã¨ <tt>cons</tt> ã¯ã€åŒã˜ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ãªã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«å¯¾ã™ã‚‹åå‰ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
Defining selectors and constructors in this way is efficient:
Instead of <tt>make-rat</tt> <em>calling</em> <tt>cons</tt>, <tt>make-rat</tt>
<em>is</em> <tt>cons</tt>, so there is only one procedure called, not two,
when <tt>make-rat</tt> is called.  On the other hand, doing this defeats debugging
aids that trace procedure calls or put breakpoints on procedure calls:
You may want to watch <tt>make-rat</tt> being called, but you certainly
don't want to watch every call to <tt>cons</tt>.
</p>

<p class="trans" lang="ja">
ã‚»ãƒ¬ã‚¯ã‚¿ã¨ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’ã“ã®ã‚ˆã†ã«å®šç¾©ã™ã‚‹ã®ã¯åŠ¹ç‡çš„ã ã€‚
<tt>make-rat</tt> ãŒ <tt>cons</tt> ã‚’<em>å‘¼ã³å‡ºã™</em>ã®ã§ã¯ãªãã€<tt>make-rat</tt> ã¯ <tt>cons</tt> <em>ã§ã‚ã‚‹</em>ã‹ã‚‰ã€<tt>make-rat</tt> ãŒå‘¼ã³å‡ºã•ã‚ŒãŸã¨ãã«ã¯ã€äºŒã¤ã§ã¯ãªãã€ä¸€ã¤ã®æ‰‹ç¶šãã ã‘ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ã€‚
ä»–æ–¹ã€ã“ã†ã™ã‚‹ã“ã¨ã¯ã€æ‰‹ç¶šãå‘¼ã³å‡ºã—ã‚’ãƒˆãƒ¬ãƒ¼ã‚¹ã—ãŸã‚Šã‚ã‚‹ã„ã¯æ‰‹ç¶šãå‘¼ã³å‡ºã—ã«ãƒ–ãƒ¬ã‚¤ã‚¯ãƒã‚¤ãƒ³ãƒˆã‚’è¨­å®šã—ãŸã‚Šã™ã‚‹ãƒ‡ãƒãƒƒã‚°è£œåŠ©å™¨ã«ã¨ã£ã¦ã€æ‰‹ã«è² ãˆãªã„ã‚‚ã®ã§ã‚ã‚‹ã€‚
å›ã¯ã€<tt>make-rat</tt> ãŒå‘¼ã°ã‚Œã¦ã„ã‚‹ã¨ã“ã‚ã‚’è¦‹ãŸã„ã‹ã‚‚ã—ã‚Œãªã„ãŒã€<tt>cons</tt> ã«å¯¾ã™ã‚‹ã™ã¹ã¦ã®å‘¼ã³å‡ºã—ã‚’è¦‹ãŸã„ã¨ã¯ã€ãã£ã¨æ€ã‚ãªã„ã ã‚ã†ã€‚
</p>

<p class="orig" lang="en">
We have chosen not to use this style of definition in this book.
</p>

<p class="trans" lang="ja">
ç§ãŸã¡ã¯ã€ã“ã®æ§˜å¼ã®å®šç¾©ã‚’æœ¬æ›¸ã§ã¯ä½¿ã‚ãªã„ã“ã¨ã«ã—ãŸã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_136" href="#call_footnote_Temp_136"><sup><small>4</small></sup></a> <a name="%_idx_1356"></a><a name="%_idx_1358"></a><a name="%_idx_1360"></a><a name="%_idx_1362"></a><a name="%_idx_1364"></a><tt>Display</tt> is
the Scheme primitive for printing data.  The Scheme primitive
<tt>newline</tt> starts a new line for printing.
<a name="%_idx_1366"></a><a name="%_idx_1368"></a>Neither of these procedures returns a useful value, so in the uses of
<tt>print-rat</tt> below, we show only what <tt>print-rat</tt> prints,
not what the interpreter prints as the value returned by <tt>print-rat</tt>.
</p>

<p class="trans" lang="ja">
<tt>display</tt> ã¯ã€ãƒ‡ãƒ¼ã‚¿ã‚’å°å­—ã™ã‚‹ãŸã‚ã®Schemeã®ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã§ã‚ã‚‹ã€‚
Schemeã®ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã§ã‚ã‚‹ <tt>newline</tt> ã¯ã€å°å­—ç”¨ã®æ–°ãŸãªè¡Œã‚’é–‹å§‹ã™ã‚‹ã€‚
ã“ã‚Œã‚‰ã®æ‰‹ç¶šãã®ã„ãšã‚Œã‚‚ã€æœ‰ç”¨ãªå€¤ã‚’è¿”ã•ãªã„ã®ã§ã€ä»¥ä¸‹ã®ã‚ˆã†ãª <tt>print-rat</tt> ã®ä½¿ç”¨ã«ãŠã„ã¦ã€ç§ãŸã¡ã¯ã€<tt>print-rat</tt> ãŒå°å­—ã™ã‚‹ã‚‚ã®ã®ã¿ã‚’è¡¨ç¤ºã—ã€<tt>print-rat</tt> ã«ã‚ˆã‚Šè¿”ã•ã‚Œã‚‹å€¤ã¨ã—ã¦ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒå°å­—ã™ã‚‹ã‚‚ã®ã¯è¡¨ç¤ºã—ãªã„ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_140" href="#call_footnote_Temp_140"><sup><small>5</small></sup></a> Surprisingly, this idea is very
difficult to formulate rigorously. There are two approaches to giving
such a formulation.  One, pioneered by <a name="%_idx_1422"></a>C. A. R. Hoare (1972), is known
as the method of <a name="%_idx_1424"></a><a name="%_idx_1426"></a><em>abstract models</em>.  It formalizes the
``procedures plus conditions'' specification as outlined in the
rational-number example above.  Note that the condition on the
rational-number representation was stated in terms of facts about
integers (equality and division).  In general, abstract models define
new kinds of data objects in terms of previously defined types of data
objects.  Assertions about data objects can therefore be checked by
reducing them to assertions about previously defined data objects.
Another approach, introduced by <a name="%_idx_1428"></a>Zilles at MIT, by <a name="%_idx_1430"></a>Goguen, <a name="%_idx_1432"></a>Thatcher,
<a name="%_idx_1434"></a>Wagner, and <a name="%_idx_1436"></a>Wright at IBM (see Thatcher, Wagner, and Wright 1978), and by <a name="%_idx_1438"></a>Guttag at Toronto (see Guttag 1977),
is called <a name="%_idx_1440"></a><a name="%_idx_1442"></a><em>algebraic specification</em>.  It regards the ``procedures''
as elements of an abstract algebraic system whose behavior is
specified by axioms that correspond to our ``conditions,'' and uses
the techniques of abstract algebra to check assertions about data
objects.  Both methods are surveyed in the paper by <a name="%_idx_1444"></a>Liskov and Zilles
(1975).
</p>

<p class="trans" lang="ja">
é©šãã¹ãã“ã¨ã«ã€ã“ã®è€ƒãˆã¯ã€å³å¯†ã«å®šå¼åŒ–ã™ã‚‹ã®ãŒã¨ã¦ã‚‚é›£ã—ã„ã€‚
ãã†ã„ã†å®šå¼åŒ–ã‚’ä¸ãˆã‚‹ãŸã‚ã®æ‰‹æ³•ã¯äºŒã¤ã‚ã‚‹ã€‚
ä¸€ã¤ã¯â€”â€”C. A. R. ãƒ›ã‚¢ãƒ¬ (1972) ã«ã‚ˆã‚Šåˆ‡ã‚Šé–‹ã‹ã‚ŒãŸã‚‚ã®ã ãŒâ€”â€”<em>æŠ½è±¡ãƒ¢ãƒ‡ãƒ«</em>ã®æ–¹æ³•ã¨ã—ã¦çŸ¥ã‚‰ã‚Œã‚‹ã€‚
ãã‚Œã¯ã€ä¸Šè¨˜ã®æœ‰ç†æ•°ã®ä¾‹ã§æ¦‚è¦³ã—ãŸã‚ˆã†ã«ã€ã€Œæ‰‹ç¶šããŠã‚ˆã³æ¡ä»¶ã€ã®æŒ‡å®šã‚’å®šå¼åŒ–ã™ã‚‹ã€‚
æœ‰ç†æ•°ã®è¡¨ç¾ã«é–¢ã™ã‚‹æ¡ä»¶ã¯ã€æ•´æ•°ã«ã¤ã„ã¦ã®äº‹å®Ÿ (ç­‰ä¾¡æ€§ã¨é™¤ç®—) ã®è¦³ç‚¹ã‹ã‚‰è¨˜è¿°ã•ã‚Œã¦ã„ãŸã€ã¨ã„ã†ã“ã¨ã«æ³¨æ„ã›ã‚ˆã€‚
ä¸€èˆ¬çš„ã«ã€æŠ½è±¡ãƒ¢ãƒ‡ãƒ«ã¯ã€ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¤ã„ã¦ã®ã€ä»¥å‰ã«å®šç¾©ã•ã‚ŒãŸå‹ã®è¦³ç‚¹ã‹ã‚‰ã€æ–°ãŸãªç¨®é¡ã®ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å®šç¾©ã™ã‚‹ã€‚
ã‚†ãˆã«ã€ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¤ã„ã¦ã®è¨€æ˜ã¯ã€ãã‚Œã‚‰ã‚’ã€ä»¥å‰ã«å®šç¾©ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¤ã„ã¦ã®è¨€æ˜ã¸ã¨é‚„å…ƒã™ã‚‹ã“ã¨ã§ã€ãƒã‚§ãƒƒã‚¯ã§ãã‚‹ã€‚
ã‚‚ã†ä¸€ã¤ã®æ‰‹æ³•ã¯â€”â€”MITã®ãƒ„ã‚£ãƒ¬ã‚¹ã¨ã€IBMã®ã€ã‚´ãƒ¼ã‚²ãƒ³ã€ã‚µãƒƒãƒãƒ£ãƒ¼ã€ãƒ¯ãƒ¼ã‚°ãƒŠãƒ¼ã€ãŠã‚ˆã³ãƒ©ã‚¤ãƒˆã¨ (Thatcher, Wagner, and Wright 1978 ã‚’å‚ç…§)ã€ãƒˆãƒ­ãƒ³ãƒˆã®ã‚°ãƒƒã‚¿ãƒ¼ã‚¯ (Guttag 1977 ã‚’å‚ç…§) ã«ã‚ˆã£ã¦å°å…¥ã•ã‚ŒãŸã‚‚ã®ã ãŒâ€”â€”<em>ä»£æ•°çš„æŒ‡å®š</em>ã¨å‘¼ã°ã‚Œã‚‹ã€‚
ãã‚Œã¯ã€ã€Œæ‰‹ç¶šãã€ã‚’ã€ç§ãŸã¡ã®è¨€ã†ã€Œæ¡ä»¶ã€ã«å¯¾å¿œã™ã‚‹å…¬ç†ã«ã‚ˆã£ã¦æŒ¯ã‚‹èˆã„ãŒæŒ‡å®šã•ã‚Œã‚‹ã‚ˆã†ãªæŠ½è±¡çš„ä»£æ•°ç³»ã®ä¸€è¦ç´ ã ã¨è¦‹ãªã—ã€æŠ½è±¡çš„ä»£æ•°ã®æŠ€æ³•ã‚’ä½¿ã£ã¦ã€ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¤ã„ã¦ã®è¨€æ˜ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ã€‚
ã©ã¡ã‚‰ã®æ–¹æ³•ã‚‚ã€ãƒªã‚¹ã‚³ãƒ•ã¨ãƒ„ãƒƒãƒ¬ã‚¹ã®è«–æ–‡ (1975) ã§èª¿æŸ»ã•ã‚Œã¦ã„ã‚‹ã€‚
</p>

</div>

</body>
</html>
