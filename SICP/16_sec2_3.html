<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<link rel="stylesheet" href="sicp.css" type="text/css">
	<base target="_top">
	<title>Structure and Interpretation of Computer Programs: SICPç§è¨³</title>
</head>

<body>

<div class="idx-bar">
<nav>
<a href="https://twitter.com/share" class="twitter-share-button" data-lang="ja">ãƒ„ã‚¤ãƒ¼ãƒˆ</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
<span class="status">æ¨æ•²å¾…ã¡</span>
[
<a href="00_cover.html">å…ˆé ­ã¸</a> |
<a href="15_sec2_2.html">å‰ã¸</a> |
<a href="17_sec2_4.html">æ¬¡ã¸</a> | 
<a href="04_toc.html#%_toc_start">ç›®æ¬¡</a> |
<a href="38_index.html#%_index_start">ç´¢å¼•</a>
] [<a href="99_about.html">ã“ã®å¯¾è¨³ç‰ˆã«ã¤ã„ã¦</a> | <a href="../index.html">ãƒ›ãƒ¼ãƒ </a>]
[
Â§<a href="#%_sec_2.3">2.3</a>
Â§<a href="#%_sec_2.3.1">2.3.1</a>
ğŸ“<a href="#%_thm_2.53">2.53</a>
ğŸ“<a href="#%_thm_2.54">2.54</a>
ğŸ“<a href="#%_thm_2.55">2.55</a>
Â§<a href="#%_sec_2.3.2">2.3.2</a>
ğŸ“š<a href="#%_sec_Temp_235">&hellip;</a>
ğŸ“š<a href="#%_sec_Temp_236">&hellip;</a>
ğŸ“<a href="#%_thm_2.56">2.56</a>
ğŸ“<a href="#%_thm_2.57">2.57</a>
ğŸ“<a href="#%_thm_2.58">2.58</a>
Â§<a href="#%_sec_2.3.3">2.3.3</a>
ğŸ“š<a href="#%_sec_Temp_241">&hellip;</a>
ğŸ“<a href="#%_thm_2.59">2.59</a>
ğŸ“<a href="#%_thm_2.60">2.60</a>
ğŸ“š<a href="#%_sec_Temp_244">&hellip;</a>
ğŸ“<a href="#%_thm_2.61">2.61</a>
ğŸ“<a href="#%_thm_2.62">2.62</a>
ğŸ“š<a href="#%_sec_Temp_247">&hellip;</a>
ğŸ¨<a href="#%_fig_2.16">2.16</a>
ğŸ¨<a href="#%_fig_2.17">2.17</a>
ğŸ“<a href="#%_thm_2.63">2.63</a>
ğŸ“<a href="#%_thm_2.64">2.64</a>
ğŸ“<a href="#%_thm_2.65">2.65</a>
ğŸ“š<a href="#%_sec_Temp_255">&hellip;</a>
ğŸ“<a href="#%_thm_2.66">2.66</a>
Â§<a href="#%_sec_2.3.4">2.3.4</a>
ğŸ¨<a href="#%_fig_2.18">2.18</a>
ğŸ“š<a href="#%_sec_Temp_257">&hellip;</a>
ğŸ“š<a href="#%_sec_Temp_259">&hellip;</a>
ğŸ“š<a href="#%_sec_Temp_260">&hellip;</a>
ğŸ“š<a href="#%_sec_Temp_261">&hellip;</a>
ğŸ“<a href="#%_thm_2.67">2.67</a>
ğŸ“<a href="#%_thm_2.68">2.68</a>
ğŸ“<a href="#%_thm_2.69">2.69</a>
ğŸ“<a href="#%_thm_2.70">2.70</a>
ğŸ“<a href="#%_thm_2.71">2.71</a>
ğŸ“<a href="#%_thm_2.72">2.72</a>
<a href="#footnotes">è„šæ³¨</a>
]
</nav>

</div>

<div class="main-txt">

<a name="%_sec_2.3"></a>
<h2 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_2.3">2.3  Symbolic Data</a></h2>
<h2 class="trans" lang="ja">2.3 è¨˜å·çš„ãƒ‡ãƒ¼ã‚¿</h2>

<p class="orig" lang="en">
<a name="%_idx_1984"></a>
<a name="%_idx_1986"></a>All the compound data objects we have used so far were constructed
ultimately from numbers.  In this section we extend the representational
capability of our language by introducing the ability to work with
arbitrary symbols as data.</p>

<p class="trans" lang="ja">
ã“ã‚Œã¾ã§ã«ç§ãŸã¡ãŒä½¿ã£ã¦ããŸã™ã¹ã¦ã®è¤‡åˆçš„ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ç©¶æ¥µçš„ã«ã¯æ•°ã‹ã‚‰æ§‹ç¯‰ã•ã‚Œã¦ã„ãŸã€‚
æœ¬ç¯€ã§ã¯ã€ãƒ‡ãƒ¼ã‚¿ã¨ã—ã¦ä»»æ„ã®è¨˜å·ã‚’ä½¿ã£ã¦ä½œæ¥­ã™ã‚‹èƒ½åŠ›ã‚’å°å…¥ã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€ç§ãŸã¡ã®è¨€èªã®è¡¨ç¾èƒ½åŠ›ã‚’æ‹¡å¼µã™ã‚‹ã€‚
</p>

<a name="%_sec_2.3.1"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_2.3.1">2.3.1  Quotation</a></h3>
<h3 class="trans" lang="ja">2.3.1 å¼•ç”¨</h3>

<p class="orig" lang="en">
<a name="%_idx_1988"></a>
If we can form compound data using symbols, we can have lists such as
</p>

<p class="trans" lang="ja">ã‚‚ã—è¨˜å·ã‚’ä½¿ã£ã¦è¤‡åˆçš„ãƒ‡ãƒ¼ã‚¿ã‚’å½¢æˆã§ããŸã‚‰ã€ä»¥ä¸‹ã®ã‚ˆã†ãªãƒªã‚¹ãƒˆãŒã‚ã‚Šå¾—ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_1990"></a>(a b c d)
(23 45 17)
((Norah 12) (Molly 9) (Anna 7) (Lauren 6) (Charlotte 4))
</p>

<p class="orig" lang="en">
Lists containing symbols can look just like the expressions of our
language:
</p>

<p class="trans" lang="ja">
è¨˜å·ã‚’å«ã‚€ãƒªã‚¹ãƒˆã¯ã€å˜ã«ã€ç§ãŸã¡ã®è¨€èªã®å¼ã®ã‚ˆã†ã«è¦‹ãˆã‚‹ã“ã¨ãŒã‚ã‚Šå¾—ã‚‹ã€‚
</p>

<p class="lisp">(* (+ 23 45) (+ x 9))

(define (fact n) (if (= n 1) 1 (* n (fact (- n 1)))))
</p>

<p class="orig" lang="en">
In order to manipulate symbols we need a new element in our language:
the ability to <em>quote</em> a data object.  Suppose we want to
construct the list <tt>(a b)</tt>.  We can't accomplish this with <tt>(list a b)</tt>, because this expression constructs
a list of the <em>values</em> of <tt>a</tt> and <tt>b</tt> rather than
the symbols themselves.  This issue is well known in the context of
<a name="%_idx_1992"></a><a name="%_idx_1994"></a>natural languages, where words and sentences may be regarded either as
semantic entities or as character strings (syntactic entities).  The
common practice in natural languages is to use quotation marks to
indicate that a word or a sentence is to be treated literally as a
string of characters.  For instance, the first letter of ``John'' is
clearly ``J.''  If we tell somebody ``say your name aloud,'' we expect
to hear that person's name.  However, if we tell somebody ``say `your
name' aloud,'' we expect to hear the words ``your name.''  Note that
we are forced to nest quotation marks to describe what somebody else
might say.<a name="call_footnote_Temp_227" href="#footnote_Temp_227"><sup><small>32</small></sup></a>
</p>

<p class="trans" lang="ja">
è¨˜å·ã‚’æ“ä½œã™ã‚‹ãŸã‚ã«ã¯ã€ç§ãŸã¡ã®è¨€èªã«æ–°ãŸãªè¦ç´ ãŒè¦ã‚‹â€”â€”ã¤ã¾ã‚Šã€ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’<em>å¼•ç”¨</em>ã™ã‚‹èƒ½åŠ›ãŒè¦ã‚‹ã€‚
<tt>(a b)</tt> ã¨ã„ã†ãƒªã‚¹ãƒˆã‚’æ§‹ç¯‰ã—ãŸã„ã®ã ã¨ã—ã‚ˆã†ã€‚
ã“ã‚Œã‚’ã€<tt>(list a b)</tt> ã‚’ä½¿ã£ã¦é”æˆã™ã‚‹ã“ã¨ã¯ã€ã§ããªã„â€”â€”ãªãœãªã‚‰ã€ã“ã®å¼ã¯ã€<tt>a</tt> ã¨ <tt>b</tt> ã®è¨˜å·è‡ªä½“ã¨ã„ã†ã‚ˆã‚Šã‚‚ã‚€ã—ã‚ã€ãã®<em>å€¤</em> ã®ãƒªã‚¹ãƒˆã‚’æ§‹ç¯‰ã™ã‚‹ã‹ã‚‰ã§ã‚ã‚‹ã€‚
ã“ã®è«–ç‚¹ã¯ã€è‡ªç„¶è¨€èªã®æ–‡è„ˆã§ã‚ˆãçŸ¥ã‚‰ã‚Œã¦ã„ã‚‹â€”â€”è‡ªç„¶è¨€èªã®æ–‡è„ˆã§ã¯ã€å˜èªã‚„æ–‡ã¯ã€æ„å‘³çš„ãªå®Ÿä½“ã ã¨è¦‹ãªã•ã‚Œã‚‹ã‹ã€ã‚ã‚‹ã„ã¯ã€æ–‡å­—åˆ— (çµ±èªçš„ãªå®Ÿä½“) ã ã¨è¦‹ãªã•ã‚Œã‚‹ã‹ã®ã€ã„ãšã‚Œã‹ã§ã‚ã‚‹ã€‚
è‡ªç„¶è¨€èªã§ã®æ™®é€šã®ç¿’æ…£ã¯ã€å˜èªã¾ãŸã¯æ–‡ãŒã€æ›¸ã„ã¦ã‚ã‚‹ã¨ãŠã‚Šã«æ–‡å­—åˆ—ã¨ã—ã¦æ‰±ã‚ã‚Œã‚‹ã¹ãã ã€ã¨ã„ã†ã“ã¨ã‚’ç¤ºã™ãŸã‚ã«ã€å¼•ç”¨ç¬¦ã‚’ä½¿ã†ã“ã¨ã§ã‚ã‚‹ã€‚
ãŸã¨ãˆã°ã€ã€ŒJohnã€ã®æœ€åˆã®æ–‡å­—ã¯æ˜ã‚‰ã‹ã«ã€ŒJã€ã ã€‚
èª°ã‹ã«ã€Œã‚ãªãŸã®åå‰ã‚’å£°ã«å‡ºã—ã¦è¨€ã£ã¦ã€ã¨è¨€ã†ã¨ãã€ç§ãŸã¡ã¯ã€ãã®äººç‰©ã®åå‰ã‚’èãã“ã¨ã‚’äºˆæœŸã—ã¦ã„ã‚‹ã€‚
ã—ã‹ã—ã€ã€Œã€ã‚ãªãŸã®åå‰ã€ã‚’å£°ã«å‡ºã—ã¦è¨€ã£ã¦ã€ã¨è¨€ã†ã¨ãã€ç§ãŸã¡ã¯ã€ã€Œã‚ãªãŸã®åå‰ã€ã¨ã„ã†è¨€è‘‰ã‚’èãã“ã¨ã‚’äºˆæœŸã—ã¦ã„ã‚‹ã€‚
èª°ã‹ã»ã‹ã®äººãŒè¨€ã†ã‹ã‚‚ã—ã‚Œãªã„ã“ã¨ã‚’è¨˜è¿°ã™ã‚‹ãŸã‚ã«ã¯ã€å¼•ç”¨ç¬¦ã‚’å…¥ã‚Œå­ã«ã›ã–ã‚‹ã‚’å¾—ãªã„ã€ã¨ã„ã†ã“ã¨ã«æ³¨æ„ã—ã¦ã»ã—ã„<a href="#footnote_Temp_227"><sup><small>32</small></sup></a>ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_1998"></a>We can follow this same practice to identify lists and symbols that are
to be treated as data objects rather than as expressions to be
evaluated.  However, our format for quoting differs from that of
natural languages in that we place a quotation mark (traditionally,
the single <a name="%_idx_2000"></a>quote symbol <tt>'</tt>) only at the beginning of the object
to be quoted.  We can get away with this in Scheme syntax because we
rely on blanks and parentheses to delimit objects.  Thus, the meaning
of the single quote character is to quote the next object.<a name="call_footnote_Temp_228" href="#footnote_Temp_228"><sup><small>33</small></sup></a></p>

<p class="trans" lang="ja">
è©•ä¾¡ã™ã¹ãå¼ã¨ã—ã¦ã€ã¨ã„ã†ã‚ˆã‚Šã‚‚ã€ã‚€ã—ã‚ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦æ‰±ã‚ã‚Œã‚‹ã¹ãã€ãƒªã‚¹ãƒˆã‚„è¨˜å·ã‚’è­˜åˆ¥ã™ã‚‹ãŸã‚ã«ã€ã“ã®åŒã˜ç¿’æ…£ã«å¾“ã†ã“ã¨ãŒå¯èƒ½ã ã€‚
ã—ã‹ã—ã€å¼•ç”¨ã®ãŸã‚ã®ç§ãŸã¡ã®å½¢å¼ã¯ã€å¼•ç”¨ã™ã¹ãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æœ€åˆã«ã ã‘å¼•ç”¨ç¬¦ (ä¼çµ±çš„ã«ã¯ã€<tt>'</tt> ã¨ã„ã†ã€ä¸€é‡å¼•ç”¨è¨˜å·) ã‚’ç½®ãã€ã¨ã„ã†ç‚¹ã«ãŠã„ã¦ã€è‡ªç„¶è¨€èªã§ã®å½¢å¼ã¨ã¯ç•°ãªã‚‹ã€‚
ã“ã®ã“ã¨ã‚’Schemeã®æ–‡æ³•ã§ã‚„ã£ã¦ã®ã‘ã‚‹ã“ã¨ãŒã§ãã‚‹â€”â€”ãªãœãªã‚‰ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆåŒå£«ã‚’åŒºåˆ‡ã‚‹ã®ã«ç©ºç™½ã¨æ‹¬å¼§ã«é ¼ã£ã¦ã„ã‚‹ã‹ã‚‰ã§ã‚ã‚‹ã€‚
ã‚ˆã£ã¦ã€ä¸€é‡å¼•ç”¨ç¬¦æ–‡å­—ã®æ„å‘³ã¯ã€æ¬¡ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å¼•ç”¨ã™ã‚‹ã€ã¨ã„ã†ã“ã¨ã§ã‚ã‚‹<a href="#footnote_Temp_228"><sup><small>33</small></sup></a>ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_2010"></a>Now we can distinguish between symbols and their values:
</p>

<p class="trans" lang="ja">
ã•ã¦ä»Šã‚„ç§ãŸã¡ã¯ã€è¨˜å·ã¨ãã®å€¤ã¨ã‚’åŒºåˆ¥ã§ãã‚‹ã€‚
</p>

<p class="lisp">(define a 1)

(define b 2)

(list a b)
<i>(1 2)</i>

(list 'a 'b)
<i>(a b)</i>

(list 'a b)
<i>(a 2)</i>
</p>

<p class="orig" lang="en">
<a name="%_idx_2012"></a>Quotation also allows us to type in compound objects, using the
conventional printed representation for lists:<a name="call_footnote_Temp_229" href="#footnote_Temp_229"><sup><small>34</small></sup></a>
</p>

<p class="trans" lang="ja">
å¼•ç”¨ã®ãŠã‹ã’ã§ã€è¤‡åˆçš„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å½¢ã§â€”â€”ãƒªã‚¹ãƒˆã®ã€å¾“æ¥ã©ãŠã‚Šã®å°å­—ã•ã‚ŒãŸè¡¨ç¾ã‚’ä½¿ã£ã¦â€”â€”ã‚¿ã‚¤ãƒ—ã™ã‚‹ã“ã¨ãŒã€å¯èƒ½ã«ãªã‚‹<a href="#footnote_Temp_229"><sup><small>34</small></sup></a>ã€‚
</p>

<p class="lisp">(car '(a b c))
<i>a</i>

(cdr '(a b c))
<i>(b c)</i>
</p>

<p class="orig" lang="en">
<a name="%_idx_2018"></a><a name="%_idx_2020"></a>In keeping with this, we can obtain the empty list by evaluating <tt>'()</tt>, and thus dispense with the variable <tt>nil</tt>.</p>

<p class="trans" lang="ja">
ã“ã®ç·šã«æ²¿ã†ã¨ã€ç§ãŸã¡ã¯ã€<tt>'()</tt> ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ã§ç©ºãƒªã‚¹ãƒˆã‚’å¾—ã‚‹ã“ã¨ãŒã§ãã€ã‚†ãˆã«ã€<tt>nil</tt> ã¨ã„ã†å¤‰æ•°ãªã—ã§æ¸ˆã¾ã™ã“ã¨ãŒã§ãã‚‹ã€‚
</p>

<p class="orig" lang="en">
One additional primitive used in manipulating symbols is <a name="%_idx_2022"></a><a name="%_idx_2024"></a><a name="%_idx_2026"></a><a name="%_idx_2028"></a><tt>eq?</tt>,
which takes two symbols as arguments and tests whether they are the
same.<a name="call_footnote_Temp_230" href="#footnote_Temp_230"><sup><small>35</small></sup></a> Using <tt>eq?</tt>,
we can implement a useful procedure called <tt>memq</tt>.  This takes two
arguments, a symbol and a list.  If the symbol is not contained in the
list (i.e., is not <tt>eq?</tt> to any item in the list), then <tt>memq</tt> returns false.  Otherwise, it returns the sublist of
the list beginning with the first occurrence of the symbol:
</p>

<p class="trans" lang="ja">
è¨˜å·ã‚’æ“ä½œã™ã‚‹ã¨ãã«ä½¿ã‚ã‚Œã‚‹è¿½åŠ çš„ãªãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã®ä¸€ã¤ã¯ã€<tt>eq?</tt> ã§ã‚ã‚Šã€ã“ã‚Œã¯ã€å¼•æ•°ã¨ã—ã¦äºŒã¤ã®è¨˜å·ã‚’å–ã‚Šã€ãã‚Œã‚‰ãŒåŒã˜ã‹ã©ã†ã‹ã‚’æ¤œæŸ»ã™ã‚‹<a href="#footnote_Temp_230"><sup><small>35</small></sup></a>ã€‚
<tt>eq?</tt> ã‚’ä½¿ã†ã¨ã€<tt>memq</tt> ã¨å‘¼ã°ã‚Œã‚‹æœ‰ç”¨ãªæ‰‹ç¶šãã‚’å®Ÿè£…ã§ãã‚‹ã€‚
ã“ã‚Œã¯ã€äºŒã¤ã®å¼•æ•°â€”â€”ã™ãªã‚ã¡ã€è¨˜å·ã¨ãƒªã‚¹ãƒˆâ€”â€”ã‚’ã¨ã‚‹ã€‚
ã‚‚ã—ã€ãã®è¨˜å·ãŒãã®ãƒªã‚¹ãƒˆã«å«ã¾ã‚Œã¦ã„ãªã‘ã‚Œã° (ã¤ã¾ã‚Šã€ãã®è¨˜å·ãŒã€ãã®ãƒªã‚¹ãƒˆå†…ã®ã©ã®é …ç›®ã«å¯¾ã—ã¦ã‚‚ <tt>eq?</tt> ã§ãªã‘ã‚Œã°)ã€<tt>memq</tt> ã¯å½ã‚’è¿”ã™ã€‚
ãã‚Œä»¥å¤–ã®å ´åˆã€<tt>memq</tt> ã¯ã€ãã®è¨˜å·ã®æœ€åˆã®å‡ºç¾ã‹ã‚‰å§‹ã¾ã‚‹ã€ãã®ãƒªã‚¹ãƒˆã®éƒ¨åˆ†ãƒªã‚¹ãƒˆã‚’ã€è¿”ã™ã€‚
</p>

<p class="lisp"><a name="%_idx_2030"></a>(define (memq item x)
  (cond ((null? x) false)
        ((eq? item (car x)) x)
        (else (memq item (cdr x)))))
</p>

<p class="orig" lang="en">
For example, the value of
</p>

<p class="trans" lang="ja">
ãŸã¨ãˆã°ã€ä»¥ä¸‹ã®ã‚‚ã®ã®å€¤ã¯ã€
</p>

<p class="lisp">(memq 'apple '(pear banana prune))
</p>

<p class="orig" lang="en">
is false, whereas the value of
</p>

<p class="trans" lang="ja">
å½ã§ã‚ã‚‹ã®ã«å¯¾ã—ã€ä»¥ä¸‹ã®ã‚‚ã®ã®å€¤ã¯ã€
</p>

<p class="lisp">(memq 'apple '(x (apple sauce) y apple pear))
</p>

<p class="orig" lang="en">
is <tt>(apple pear)</tt>.
</p>

<p class="trans" lang="ja">
<tt>(apple pear)</tt> ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
<a name="%_thm_2.53"></a>
<b>Exercise 2.53.</b>  What would the interpreter print in response to evaluating each of the
following expressions?
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.53.</b> ä»¥ä¸‹ã®å¼ã®å„ã€…ã‚’è©•ä¾¡ã™ã‚‹ã®ã«å¿œã˜ã¦ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã¯ã€ä½•ã‚’å°å­—ã™ã‚‹ã ã‚ã†ã‹?
</p>

<p class="lisp">(list 'a 'b 'c)

(list (list 'george))
(cdr '((x1 x2) (y1 y2)))

(cadr '((x1 x2) (y1 y2)))
(pair? (car '(a short list)))
(memq 'red '((red shoes) (blue socks)))

(memq 'red '(red shoes blue socks))
</p>

<p class="exercise">&gt; (list 'a 'b 'c)
<i>(a b c)</i>
&gt; (list (list 'george))
<i>((george))</i>
&gt; (cdr '((x1 x2) (y1 y2)))
<i>((y1 y2))</i>
&gt; (cadr '((x1 x2) (y1 y2)))
<i>(y1 y2)</i>
&gt; (pair? (car '(a short list)))
<i>#f</i>
&gt; (memq 'red '((red shoes) (blue socks)))
<i>#f</i>
&gt; (memq 'red '(red shoes blue socks))
<i>(red shoes blue socks)</i>
</p>

<p class="orig" lang="en">
<a name="%_thm_2.54"></a>
<b>Exercise 2.54.</b>  Two lists are said to be <a name="%_idx_2032"></a><a name="%_idx_2034"></a><a name="%_idx_2036"></a><tt>equal?</tt> if they contain equal elements
arranged in the same order.  For example,
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.54.</b> äºŒã¤ã®ãƒªã‚¹ãƒˆã¯ã€åŒã˜é †åºã§ä¸¦ã‚“ã ç­‰ã—ã„è¦ç´ ã‚’å«ã‚“ã§ã„ã‚‹å ´åˆã«ã€<tt>equal?</tt> ã§ã‚ã‚‹ã¨è¨€ã‚ã‚Œã‚‹ã€‚
</p>

<p class="lisp">(equal? '(this is a list) '(this is a list))
</p>

<p class="orig" lang="en">
is true, but
</p>

<p class="trans" lang="ja">
ã¯çœŸã ãŒã€
</p>

<p class="lisp">(equal? '(this is a list) '(this (is a) list))
</p>

<p class="orig" lang="en">
is false.  To be more precise, we can define <tt>equal?</tt>
recursively in terms of the basic <tt>eq?</tt> equality of symbols by
saying that <tt>a</tt> and <tt>b</tt> are <tt>equal?</tt> if they are both
symbols and the symbols are <tt>eq?</tt>, or if they are both lists such
that <tt>(car a)</tt> is <tt>equal?</tt> to <tt>(car b)</tt> and <tt>(cdr
a)</tt> is <tt>equal?</tt> to <tt>(cdr b)</tt>.  Using this idea, implement
<tt>equal?</tt> as a procedure.<a name="call_footnote_Temp_233" href="#footnote_Temp_233"><sup><small>36</small></sup></a>
</p>

<p class="trans" lang="ja">
ã¯å½ã§ã‚ã‚‹ã€‚
ã‚ˆã‚Šæ­£ç¢ºã«ã¯ã€è¨˜å·ã«ã¤ã„ã¦ã®åŸºæœ¬çš„ãª <tt>eq?</tt> ç­‰ä¾¡æ€§ã‚’ä½¿ã£ã¦ã€å†å¸°çš„ã« <tt>equal?</tt> ã‚’å®šç¾©ã§ãã‚‹â€”â€”<tt>a</tt> ã¨ <tt>b</tt> ã¯ã€ã¨ã‚‚ã«è¨˜å·ã§ã‚ã‚Šã€ã‹ã¤ã€ãã®è¨˜å·åŒå£«ãŒ <tt>eq?</tt> ã§ã‚ã‚‹å ´åˆã‹ã€ã‚‚ã—ãã¯ã€<tt>(car a)</tt> ãŒ <tt>(car b)</tt> ã«å¯¾ã—ã¦ <tt>equal?</tt> ã§ã‚ã‚Šã€ã‹ã¤ã€<tt>(cdr a)</tt> ãŒ <tt>(cdr b)</tt> ã«å¯¾ã—ã¦ <tt>equal?</tt> ã§ã‚ã‚‹ã‚ˆã†ãªãƒªã‚¹ãƒˆåŒå£«ã§ã‚ã‚‹å ´åˆã«ã€<tt>equal?</tt> ã§ã‚ã‚‹ã€ã¨è¨€ã†ã“ã¨ã«ã‚ˆã£ã¦ã€‚
ã“ã®è€ƒãˆã‚’ä½¿ã£ã¦ã€<tt>equal?</tt> ã‚’æ‰‹ç¶šãã¨ã—ã¦å®Ÿè£…ã›ã‚ˆ<a href="#footnote_Temp_233"><sup><small>36</small></sup></a>ã€‚
</p>

<p class="exercise">(define (equal? a b)
  (cond ((and (symbol? a) (symbol? b) (eq? a b)) #t)
        ((and (null? a) (null? b)) #t)
        ((and (list? a) (not (null? a)) (list? b) (not (null? b)))
         (and (equal? (car a) (car b)) (equal? (cdr a) (cdr b))))
        (else #f)))
</p>

<p class="exercise"><span class="ex_comment">; å®Ÿè¡Œä¾‹</span>
gosh&gt; (equal? 1 1)
#f
gosh&gt; (equal? 'a 'a)
#t
gosh&gt; (equal? 'a 'b)
#f
gosh&gt; (equal? 'a '(x y z))
#f
gosh&gt; (equal? '(a b) 'z)
#f
gosh&gt; (equal? '(a b c) '(a b c))
#t
gosh&gt; (equal? '(a (b) (c d)) '(a (b) (c d)))
#t
gosh&gt; (equal? '(a (b) (c d)) '(a (bb) (c d)))
#f
gosh&gt; (equal? '() '())
#t
gosh&gt; (equal? '() '(x y))
#f
gosh&gt; (equal? '(x y) '()) 
#f
</p>

<p class="orig" lang="en">
<a name="%_thm_2.55"></a>
<b>Exercise 2.55.</b>  Eva Lu Ator types to the interpreter the expression</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.55.</b> ã‚¨ãƒ´ã‚¡ãƒ»ãƒªãƒ¥ãƒ»ã‚¨ã‚¤ã‚¿ã¯ã€ä»¥ä¸‹ã®å¼ã‚’ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«å¯¾ã—ã¦æ‰“ã¡è¾¼ã‚€ã€‚
</p>

<p class="lisp">(car ''abracadabra)
</p>

<p class="orig" lang="en">
To her surprise, the interpreter prints back <tt>quote</tt>.  Explain.
</p>

<p class="trans" lang="ja">
å½¼å¥³ãŒé©šã„ãŸã“ã¨ã«ã¯ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã¯ã€<tt>quote</tt> ã¨å°å­—ã—ã¦è¿”ã—ãŸã€‚
èª¬æ˜ã›ã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment">è¦‹ã¥ã‚‰ã„ã‘ã‚Œã©ã€ã“ã‚Œã¯ã€ŒäºŒé‡å¼•ç”¨ç¬¦ãŒä¸€ã¤ã€ã§ã¯ãªãã¦ã€Œä¸€é‡å¼•ç”¨ç¬¦ãŒäºŒã¤ã€ã§ã‚ã‚‹ã€‚
ã¤ã¾ã‚Šã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«ã€</span>
(car (quote (quote abracadabra)))
<span class="ex_comment">ã¨æ‰“ã¡è¾¼ã¾ã‚ŒãŸã®ã¨åŒã˜ã§ã‚ã‚‹ã€‚</span>
(quote (quote abracadabra))
<span class="ex_comment">ã¯ã€</span>
(quote abracadabra)
<span class="ex_comment">ã¨ã„ã†ãƒªã‚¹ãƒˆãã®ã‚‚ã®ãªã®ã§ã€ã“ã®ãƒªã‚¹ãƒˆã® <tt>car</tt> ã‚’ã¨ã£ãŸã‚‰ã€</span>
quote
<span class="ex_comment">ã¨ã„ã†è¨˜å·ãŒå¾—ã‚‰ã‚ŒãŸã€ã¨ã„ã†ã‚ã‘ã ã€‚</span>
</p>

<a name="%_sec_2.3.2"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_2.3.2">2.3.2  Example: Symbolic Differentiation</a></h3>
<h3 class="trans" lang="ja">2.3.2 ä¾‹: è¨˜å·å¾®åˆ†</h3>

<p class="orig" lang="en">
<a name="%_idx_2042"></a><a name="%_idx_2044"></a><a name="%_idx_2046"></a>
As an illustration of symbol manipulation and a further illustration
of data abstraction, consider the design of a procedure that performs
symbolic differentiation of algebraic expressions.  We would like the
procedure to take as arguments an algebraic expression and a variable
and to return the derivative of the expression with respect to the
variable.  For example, if the arguments to the procedure are <em>a</em><em>x</em><sup>2</sup>
 + <em>b</em><em>x</em>  + <em>c</em> and <em>x</em>, the procedure should return 2<em>a</em><em>x</em> + <em>b</em>.  Symbolic
differentiation is of special historical significance in Lisp.  It was
one of the motivating examples behind the development of a computer
language for symbol manipulation.  Furthermore, it marked the
beginning of the line of research that led to the development of
powerful systems for symbolic mathematical work, which are currently
being used by a growing number of applied mathematicians and
physicists.</p>

<p class="trans" lang="ja">
è¨˜å·æ“ä½œã¨ã®ä¾‹ç¤ºã¨ã—ã¦ã€ãã—ã¦ã€ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ã®ã•ã‚‰ãªã‚‹ä¾‹ç¤ºã¨ã—ã¦ã€ä»£æ•°å¼ã®è¨˜å·å¾®åˆ†ã‚’å®Ÿè¡Œã™ã‚‹æ‰‹ç¶šãã®è¨­è¨ˆã‚’è€ƒãˆã‚ˆã†ã€‚
ãã®æ‰‹ç¶šããŒã€å¼•æ•°ã¨ã—ã¦ä»£æ•°å¼ã¨å¤‰æ•°ã¨ã‚’å–ã‚Šã€ãã®ä»£æ•°å¼ã®ã€ãã®å¤‰æ•°ã«é–¢ã™ã‚‹å°é–¢æ•°ã‚’è¿”ã™ã‚ˆã†ã«ã—ãŸã„ã€‚
ãŸã¨ãˆã°ã€ãã®æ‰‹ç¶šãã«å¯¾ã™ã‚‹å¼•æ•°ãŒã€
<span class="math"><em class="en">ax</em><sup>2</sup> + <em class="en">bx</em>  + <em class="en">c</em></span>
ã¨ <em class="en">x</em> ãªã‚‰ã°ã€ãã®æ‰‹ç¶šãã¯ã€
<span class="math">2<em class="en">ax</em> + <em class="en">b</em></span>
ã‚’è¿”ã™ã¹ãã§ã‚ã‚‹ã€‚
è¨˜å·å¾®åˆ†ã«ã¯ã€Lispã§ã¯ç‰¹åˆ¥ãªæ­´å²çš„é‡è¦æ€§ãŒã‚ã‚‹ã€‚
è¨˜å·å¾®åˆ†ã¯ã€è¨˜å·æ“ä½œã®ãŸã‚ã®ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿è¨€èªã®é–‹ç™ºã®èƒŒå¾Œã«ã‚ã‚‹ã€æ„æ¬²ã‚’ã‹ããŸã¦ã‚‹ä¾‹ã®ã†ã¡ã®ã€ä¸€ã¤ã§ã‚ã£ãŸã€‚
ã•ã‚‰ã«ã€è¨˜å·å¾®åˆ†ã¯ã€è¨˜å·çš„ãªæ•°å­¦çš„ä½œæ¥­ã®ãŸã‚ã®å¼·åŠ›ãªã‚·ã‚¹ãƒ†ãƒ â€”â€”ç¾åœ¨ã§ã¯ã€ã¾ã™ã¾ã™å¤šãã®å¿œç”¨æ•°å­¦è€…ã¨å¿œç”¨ç‰©ç†è€…ã«ã‚ˆã‚Šä½¿ã‚ã‚Œã¦ã„ã‚‹â€”â€”ã®é–‹ç™ºã¸ã¨ã¤ãªãŒã‚‹ã‚ˆã†ãªã€ç ”ç©¶ã®é“ç­‹ã®å§‹ã¾ã‚Šã‚’ã€ã—ã‚‹ã—ãŸã®ã ã€‚
</p>

<p class="orig" lang="en">
In developing the symbolic-differentiation program, we will follow the
same strategy of data abstraction that we followed in developing the
rational-number system of section <a href="14_sec2_1.html#%_sec_2.1.1">2.1.1</a>.  That is, we will first
define a differentiation algorithm that operates on abstract
objects such as ``sums,'' ``products,'' and ``variables'' without
worrying about how these are to be represented.  Only afterward will
we address the representation problem.</p>

<p class="trans" lang="ja">
è¨˜å·å¾®åˆ†ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®é–‹ç™ºã«éš›ã—ã¦ã€ç§ãŸã¡ã¯ã€<a href="14_sec2_1.html#%_sec_2.1.1">2.1.1</a>ç¯€ã®æœ‰ç†æ•°ã‚·ã‚¹ãƒ†ãƒ ã®é–‹ç™ºã®éš›ã«å¾“ã£ãŸã®ã¨åŒã˜ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ã®æˆ¦ç•¥ã«å¾“ãŠã†ã€‚
ã¤ã¾ã‚Šã€ã€Œå’Œã€ã‚„ã€Œç©ã€ã‚„ã€Œå¤‰æ•°ã€ã¨ã„ã£ãŸæŠ½è±¡çš„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«é–¢ã—ã¦å‹•ä½œã™ã‚‹å¾®åˆ†ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’ã€ã“ã‚Œã‚‰ã®æŠ½è±¡çš„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã©ã®ã‚ˆã†ã«è¡¨ç¾ã•ã‚Œã‚‹ã¹ããªã®ã‹ã«ã¤ã„ã¦å¿ƒé…ã™ã‚‹ã“ã¨ãªãã€ã¾ãšå®šç¾©ã—ã‚ˆã†ã€‚
ãã®å¾Œã«ãªã£ã¦ã¯ã˜ã‚ã¦ã€è¡¨ç¾ã®å•é¡Œã«å–ã‚Šçµ„ã‚‚ã†ã€‚
</p>

<a name="%_sec_Temp_235"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_235">The differentiation program with abstract data</a></h4>
<h4 class="trans" lang="ja">æŠ½è±¡ãƒ‡ãƒ¼ã‚¿ã‚’ç”¨ã„ãŸå¾®åˆ†ãƒ—ãƒ­ã‚°ãƒ©ãƒ </h4>

<p class="orig" lang="en">
<a name="%_idx_2048"></a>
In order to keep things simple, we will consider a very simple
symbolic-differentiation program that handles expressions that are
built up using only the operations of addition and multiplication with
two arguments.  Differentiation of any such expression can be carried
out by applying the following reduction rules:</p>

<p class="trans" lang="ja">
ç‰©äº‹ã‚’ç°¡æ½”ã«ä¿ã¤ãŸã‚ã«ã€äºŒå¼•æ•°ã®åŠ ç®—ãŠã‚ˆã³ä¹—ç®—ã¨ã„ã†æ¼”ç®—ã®ã¿ã‚’ä½¿ã£ã¦æ§‹ç¯‰ã•ã‚ŒãŸå¼ã‚’æ‰±ã†ã‚ˆã†ãªã€ã¨ã¦ã‚‚ç°¡å˜ãªè¨˜å·å¾®åˆ†ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’è€ƒãˆã‚‹ã“ã¨ã«ã—ã‚ˆã†ã€‚
ãã†ã„ã†å¼ã®å¾®åˆ†ã¯ã€ä»¥ä¸‹ã®é‚„å…ƒè¦å‰‡ã‚’é©ç”¨ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€å®Ÿè¡Œã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
</p>

<figure>
<img src="ch2-Z-G-45.gif" border="0"><br>
<img src="ch2-Z-G-46.gif" border="0"><br>
<img src="ch2-Z-G-47.gif" border="0"><br>
<img src="ch2-Z-G-48.gif" border="0">
</figure>

<p class="orig" lang="en">
Observe that the latter two rules are recursive in nature.  That is,
to obtain the derivative of a sum we first find the derivatives of the
terms and add them.  Each of the terms may in turn be an
expression that needs to be decomposed.  Decomposing into smaller and
smaller pieces will eventually produce pieces that are either
constants or variables, whose derivatives will be either 0 or 1.</p>

<p class="trans" lang="ja">
å¾Œã‚ã®äºŒã¤ã®è¦å‰‡ãŒæœ¬è³ªçš„ã«å†å¸°çš„ã§ã‚ã‚‹ã“ã¨ã«æ°—ã¥ã„ã¦ã»ã—ã„ã€‚
ã¤ã¾ã‚Šã€å’Œã®å°é–¢æ•°ã‚’å¾—ã‚‹ãŸã‚ã«ã¯ã€ã¾ãšã€å„é …ã®å°é–¢æ•°ã‚’æ±‚ã‚ã¦ã‹ã‚‰ã€ãã‚Œã‚‰ã‚’è¶³ã™ã€‚
é …ã®ãã‚Œãã‚ŒãŒã€ä»Šåº¦ã¯ã€åˆ†è§£ã•ã‚Œã‚‹å¿…è¦ã®ã‚ã‚‹å¼ã§ã‚ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚
ã©ã‚“ã©ã‚“å°ã•ãªå˜ä½ã¸ã¨åˆ†è§£ã—ã¦ã‚†ãã“ã¨ã§ã€æœ€çµ‚çš„ã«ã¯ã€å®šæ•°ã¾ãŸã¯å¤‰æ•°ã§ã‚ã‚‹ã‚ˆã†ãªå˜ä½â€”â€”ãã®å°é–¢æ•°ã¯ã€0ã‹1ã§ã‚ã‚‹â€”â€”ãŒä½œã‚Šå‡ºã•ã‚Œã‚‹ã ã‚ã†ã€‚
</p>

<p class="orig" lang="en">
To embody these rules in a procedure we indulge in a little <a name="%_idx_2050"></a>wishful
thinking, as we did in designing the rational-number implementation.
If we had a means for representing algebraic expressions, we should be
able to tell whether an expression is a sum, a product, a constant, or
a variable.  We should be able to extract the parts of an expression.
For a sum, for example we want to be able to extract the addend
(first term) and the augend (second term).  We should also be able to
construct expressions from parts.  Let us assume that we already have
procedures to implement the following selectors, constructors, and
predicates:</p>

<p class="trans" lang="ja">
ã“ã‚Œã‚‰ã®è¦å‰‡ã‚’æ‰‹ç¶šãã®ä¸­ã«å…·ä½“åŒ–ã™ã‚‹ãŸã‚ã«ã€ç§ãŸã¡ã¯ã€ã¡ã‚‡ã£ã¨ã—ãŸå¸Œæœ›çš„è¦³æ¸¬ã‚’è¨±ãã†â€”â€”æœ‰ç†æ•°ã®å®Ÿè£…ã‚’è¨­è¨ˆã™ã‚‹éš›ã«ãã®ã‚ˆã†ã«ã—ãŸã®ã¨åŒæ§˜ã«ã€‚
ã‚‚ã—ã€ä»£æ•°å¼ã‚’è¡¨ç¾ã™ã‚‹æ‰‹æ®µãŒã‚ã£ãŸãªã‚‰ã€å¼ãŒå’Œãªã®ã‹ã€ç©ãªã®ã‹ã€å®šæ•°ãªã®ã‹ã€ãã‚Œã¨ã‚‚å¤‰æ•°ãªã®ã‹ã‚’ã€æ•™ãˆã‚‹ã“ã¨ãŒã§ãã‚‹ã¹ãã ã€‚
å¼ã®å„éƒ¨åˆ†ã‚‚æŠœãå‡ºã™ã“ã¨ãŒã§ãã‚‹ã¹ãã ã€‚
ãŸã¨ãˆã°ã€å’Œã«ã¤ã„ã¦ã¯ã€è¢«åŠ æ•° (ç¬¬ä¸€é …) ã¨åŠ æ•° (ç¬¬äºŒé …) ã‚’æŠœãå‡ºã›ã‚‹ã‚ˆã†ã§ã‚ã‚ŠãŸã„ã€‚
ã¾ãŸã€éƒ¨åˆ†ã‹ã‚‰å¼ã‚’æ§‹ç¯‰ã§ãã‚‹ã¹ãã§ã‚ã‚‹ã€‚
ä»¥ä¸‹ã®ã‚»ãƒ¬ã‚¯ã‚¿ã¨ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¨è¿°èªã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã®æ‰‹ç¶šããŒã€æ—¢ã«ã‚ã‚‹ã®ã ã€ã¨æƒ³å®šã—ã‚ˆã†ã€‚
</p>

<div  class="orig" lang="en">
<table class="expl">
<tr><td valign=top ><tt>(variable? e)</tt> </td><td valign=top >Is <tt>e</tt> a variable?</td></tr>
<tr><td valign=top ><tt>(same-variable? v1 v2)</tt> </td><td valign=top >Are <tt>v1</tt> and <tt>v2</tt> the same variable?</td></tr>
<tr><td valign=top ><tt>(sum? e)</tt> </td><td valign=top >Is <tt>e</tt> a sum?</td></tr>
<tr><td valign=top ><tt>(addend e)</tt> </td><td valign=top >Addend of the sum <tt>e</tt>.</td></tr>
<tr><td valign=top ><tt>(augend e)</tt> </td><td valign=top >Augend of the sum <tt>e</tt>.</td></tr>
<tr><td valign=top ><tt>(make-sum a1 a2)</tt> </td><td valign=top >Construct the sum of <tt>a1</tt> and <tt>a2</tt>.</td></tr>
<tr><td valign=top ><tt>(product? e)</tt> </td><td valign=top >Is <tt>e</tt> a product?</td></tr>
<tr><td valign=top ><tt>(multiplier e)</tt> </td><td valign=top >Multiplier of the product <tt>e</tt>.</td></tr>
<tr><td valign=top ><tt>(multiplicand e)</tt> </td><td valign=top >Multiplicand of the product <tt>e</tt>.</td></tr>
<tr><td valign=top ><tt>(make-product m1 m2)</tt> </td><td valign=top >Construct the product of <tt>m1</tt> and <tt>m2</tt>.</td></tr>
</table>
</div>
<br>
<div class="trans" lang="ja">
<table class="expl">
<tr><td valign=top ><tt>(variable? e)</tt> </td><td valign=top ><tt>e</tt> ã¯å¤‰æ•°ã‹?</td></tr>
<tr><td valign=top ><tt>(same-variable? v1 v2)</tt> </td><td valign=top ><tt>v1</tt> ã¨ <tt>v2</tt> ã¯åŒã˜å¤‰æ•°ã‹?</td></tr>
<tr><td valign=top ><tt>(sum? e)</tt> </td><td valign=top ><tt>e</tt> ã¯å’Œã‹?</td></tr>
<tr><td valign=top ><tt>(addend e)</tt> </td><td valign=top >å’Œ <tt>e</tt> ã®è¢«åŠ æ•°</td></tr>
<tr><td valign=top ><tt>(augend e)</tt> </td><td valign=top >å’Œ <tt>e</tt> ã®åŠ æ•°</td></tr>
<tr><td valign=top ><tt>(make-sum a1 a2)</tt> </td><td valign=top ><tt>a1</tt> ã¨ <tt>a2</tt> ã®å’Œã‚’æ§‹ç¯‰ã™ã‚‹</td></tr>
<tr><td valign=top ><tt>(product? e)</tt> </td><td valign=top ><tt>e</tt> ã¯ç©ã‹?</td></tr>
<tr><td valign=top ><tt>(multiplier e)</tt> </td><td valign=top >ç© <tt>e</tt> ã®ä¹—æ•°</td></tr>
<tr><td valign=top ><tt>(multiplicand e)</tt> </td><td valign=top >ç© <tt>e</tt> ã®è¢«ä¹—æ•°</td></tr>
<tr><td valign=top ><tt>(make-product m1 m2)</tt> </td><td valign=top ><tt>m1</tt> ã¨ <tt>m2</tt> ã®ç©ã‚’æ§‹ç¯‰ã™ã‚‹</td></tr>
</table>
</div>

<p class="orig" lang="en">
Using these, and the primitive predicate <tt>number?</tt>,
<a name="%_idx_2052"></a><a name="%_idx_2054"></a>which identifies numbers, we can express the differentiation rules as the
following procedure:
</p>

<p class="trans" lang="ja">
ã“ã‚Œã‚‰ã¨ã€åŸå§‹çš„è¿°èªã® <tt>number?</tt>â€”â€”æ•°ã‚’ç¢ºèªã™ã‚‹â€”â€”ã¨ã‚’ä½¿ã£ã¦ã€ä»¥ä¸‹ã®æ‰‹ç¶šãã®ã‚ˆã†ã«å¾®åˆ†è¦å‰‡ã‚’è¡¨ã›ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_2056"></a>(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
           (make-product (multiplier exp)
                         (deriv (multiplicand exp) var))
           (make-product (deriv (multiplier exp) var)
                         (multiplicand exp))))
        (else
         (error &quot;unknown expression type -- DERIV&quot; exp))))
</p>

<p class="orig" lang="en">
This <tt>deriv</tt> procedure incorporates the complete differentiation algorithm.
Since it is expressed in terms of abstract data, it will work no
matter how we choose to represent algebraic expressions, as long as we
design a proper set of selectors and constructors.  This is the issue
we must address next.</p>

<p class="trans" lang="ja">
ã“ã® <tt>deriv</tt> ã¨ã„ã†æ‰‹ç¶šãã¯ã€å®Œå…¨ãªå¾®åˆ†ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’å–ã‚Šå…¥ã‚Œã¦ã„ã‚‹ã€‚
ã“ã‚Œã¯ã€æŠ½è±¡ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ã£ã¦è¡¨ç¾ã•ã‚Œã¦ã„ã‚‹ã®ã§ã€ç§ãŸã¡ãŒã‚»ãƒ¬ã‚¯ã‚¿ã¨ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®é©åˆ‡ãªä¸€å¼ã‚’è¨­è¨ˆã™ã‚‹é™ã‚Šã¯ã€ä»£æ•°å¼ã‚’ã©ã†è¡¨ç¾ã™ã‚‹ã“ã¨ã‚’é¸ã¼ã†ã¨ã‚‚ã€ã“ã‚Œã¯ã†ã¾ãå‹•ãã ã‚ã†ã€‚
ã“ã®ã“ã¨ãŒã€ç§ãŸã¡ãŒæ¬¡ã«å–ã‚Šçµ„ã¾ãªãã¦ã¯ãªã‚‰ãªã„å•é¡Œã§ã‚ã‚‹ã€‚
</p>

<a name="%_sec_Temp_236"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_236">Representing algebraic expressions</a></h4>
<h4 class="trans" lang="ja">ä»£æ•°å¼ã‚’è¡¨ç¾ã™ã‚‹</h4>

<p class="orig" lang="en">
<a name="%_idx_2058"></a>
We can imagine many ways to use list structure to represent algebraic
expressions.  For example, we could use lists of symbols that mirror
the usual algebraic notation, representing <em>a</em><em>x</em> + <em>b</em> as the list <tt>(a
* x + b)</tt>.  However, one especially straightforward choice is to use
the same parenthesized prefix notation that Lisp uses for
combinations; that is, to represent <em>a</em><em>x</em> + <em>b</em> as <tt>(+ (* a x) b)</tt>.
Then our data representation for the differentiation problem is as
follows:</p>

<p class="trans" lang="ja">
ä»£æ•°å¼ã‚’è¡¨ç¾ã™ã‚‹ãŸã‚ã«ãƒªã‚¹ãƒˆæ§‹é€ ã‚’ä½¿ã†ã‚ˆã†ãªã€å¤šãã®æ–¹æ³•ã‚’æƒ³åƒã™ã‚‹ã“ã¨ãŒå¯èƒ½ã ã€‚
ãŸã¨ãˆã°ã€æ™®é€šã®ä»£æ•°çš„è¡¨è¨˜æ³•ã‚’åæ˜ ã—ãŸã€è¨˜å·ã®ãƒªã‚¹ãƒˆã‚’ä½¿ã†ã“ã¨ã‚‚ã§ãã‚‹ã ã‚ã†â€”â€”ã¤ã¾ã‚Šã€
<span class="math"><em class="en">ax</em> + <em class="en">b</em></span>
ã‚’
<tt>(a * x + b)</tt>
ã¨ã„ã†ãƒªã‚¹ãƒˆã¨ã—ã¦è¡¨ç¾ã™ã‚‹ã‚ã‘ã ã€‚
ã—ã‹ã—ã€ç‰¹ã«åˆ†ã‹ã‚Šã‚„ã™ã„ä¸€ã¤ã®é¸æŠè‚¢ã¯ã€LispãŒã‚³ãƒ³ãƒ“ãƒãƒ¼ã‚·ãƒ§ãƒ³ã«ã¤ã„ã¦ä½¿ã£ã¦ã„ã‚‹ã®ã¨åŒã˜ã€æ‹¬å¼§ã§æ‹¬ã‚‰ã‚ŒãŸå‰ç½®è¨˜æ³•ã‚’ã€ä½¿ã†ã“ã¨ã§ã‚ã‚‹ã€‚
ã¤ã¾ã‚Šã€
<span class="math"><em class="en">ax</em> + <em class="en">b</em></span>
ã‚’
<tt>(+ (* a x) b)</tt>
ã¨è¡¨ç¾ã™ã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚
ã™ã‚‹ã¨ã€å¾®åˆ†ã®å•é¡Œã®ãŸã‚ã®ç§ãŸã¡ã®ãƒ‡ãƒ¼ã‚¿è¡¨ç¾ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚‹ã€‚
</p>

<ul class="orig" lang="en">
<li>The variables are symbols.  They are identified by the primitive predicate
<a name="%_idx_2060"></a><a name="%_idx_2062"></a><tt>symbol?</tt>:</li>
</ul>

<ul class="trans" lang="ja">
<li>å¤‰æ•°ã¯è¨˜å·ã§ã‚ã‚‹ã€‚
å¤‰æ•°ã¯ã€<tt>symbol?</tt> ã¨ã„ã†åŸå§‹çš„è¿°èªã«ã‚ˆã‚Šè­˜åˆ¥ã•ã‚Œã‚‹ã€‚</li>
</ul>

<p class="lisp"><a name="%_idx_2064"></a>(define (variable? x) (symbol? x))
</p>

<ul class="orig" lang="en">
<li>Two variables are the same if the symbols representing them are
<tt>eq?</tt>:</li>
</ul>

<ul class="trans" lang="ja">
<li>äºŒã¤ã®å¤‰æ•°ã¯ã€ãã‚Œã‚‰ã‚’è¡¨ç¾ã™ã‚‹è¨˜å·åŒå£«ãŒ <tt>eq?</tt> ã§ã‚ã‚‹ã¨ãã«ã€åŒä¸€ã§ã‚ã‚‹ã€‚</li>
</ul>

<p class="lisp"><a name="%_idx_2066"></a>(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))
</p>

<ul class="orig" lang="en">
<li>Sums and products are constructed as lists:</li>
</ul>

<ul class="trans" lang="ja">
<li>å’Œã¨ç©ã¯ã€ãƒªã‚¹ãƒˆã¨ã—ã¦æ§‹ç¯‰ã•ã‚Œã‚‹ã€‚</li>
</ul>

<p class="lisp"><a name="%_idx_2068"></a>(define (make-sum a1 a2) (list '+ a1 a2))

<a name="%_idx_2070"></a>(define (make-product m1 m2) (list '* m1 m2))
</p>

<ul class="orig" lang="en">
<li>A sum is a list whose first element is the symbol <tt>+</tt>:</li>
</ul>

<ul class="trans" lang="ja">
<li>å’Œã¯ã€ãã®æœ€åˆã®è¦ç´ ãŒ <tt>+</tt> ã¨ã„ã†è¨˜å·ã§ã‚ã‚‹ã‚ˆã†ãªã€ãƒªã‚¹ãƒˆã§ã‚ã‚‹ã€‚</li>
</ul>

<p class="lisp"><a name="%_idx_2072"></a>(define (sum? x)
  (and (pair? x) (eq? (car x) '+)))
</p>

<ul class="orig" lang="en">
<li>The addend is the second item of the sum list:</li>
</ul>

<ul class="trans" lang="ja">
<li>è¢«åŠ æ•°ã¯ã€å’Œã®ãƒªã‚¹ãƒˆã®2ç•ªç›®ã®é …ç›®ã§ã‚ã‚‹ã€‚</li>
</ul>

<p class="lisp"><a name="%_idx_2074"></a>(define (addend s) (cadr s))
</p>

<ul class="orig" lang="en">
<li>The augend is the third item of the sum list:</li>
</ul>

<ul class="trans" lang="ja">
<li>åŠ æ•°ã¯ã€å’Œã®ãƒªã‚¹ãƒˆã®3ç•ªç›®ã®é …ç›®ã§ã‚ã‚‹ã€‚</li>
</ul>

<p class="lisp"><a name="%_idx_2076"></a>(define (augend s) (caddr s))
</p>

<ul class="orig" lang="en">
<li>A product is a list whose first element is the symbol <tt>*</tt>:</li>
</ul>

<ul class="trans" lang="ja">
<li>ç©ã¯ã€ãã®æœ€åˆã®è¦ç´ ãŒ <tt>*</tt> ã¨ã„ã†è¨˜å·ã§ã‚ã‚‹ã‚ˆã†ãªã€ãƒªã‚¹ãƒˆã§ã‚ã‚‹ã€‚</li>
</ul>

<p class="lisp"><a name="%_idx_2078"></a>(define (product? x)
  (and (pair? x) (eq? (car x) '*)))
</p>

<ul class="orig" lang="en">
<li>The multiplier is the second item of the product list:</li>
</ul>

<ul class="trans" lang="ja">
<li>ä¹—æ•°ã¯ã€ç©ã®ãƒªã‚¹ãƒˆã®2ç•ªç›®ã®é …ç›®ã§ã‚ã‚‹ã€‚</li>
</ul>

<p class="lisp"><a name="%_idx_2080"></a>(define (multiplier p) (cadr p))
</p>

<ul class="orig" lang="en">
<li>The multiplicand is the third item of the product list:</li>
</ul>

<ul class="trans" lang="ja">
<li>è¢«ä¹—æ•°ã¯ã€ç©ã®ãƒªã‚¹ãƒˆã®3ç•ªç›®ã®é …ç›®ã§ã‚ã‚‹ã€‚</li>
</ul>

<p class="lisp"><a name="%_idx_2082"></a>(define (multiplicand p) (caddr p))
</p>

<p class="orig" lang="en">
Thus, we need only combine these with the algorithm as embodied by
<tt>deriv</tt> in order to have a working symbolic-differentiation
program.  Let us look at some examples of its behavior:
</p>

<p class="trans" lang="ja">
ã—ãŸãŒã£ã¦ã€å©ãå°ã¨ãªã‚‹è¨˜å·å¾®åˆ†ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’å¾—ã‚‹ãŸã‚ã«ã¯ã€ã“ã‚Œã‚‰ã‚’ã€<tt>deriv</tt> ã«ã‚ˆã‚Šå…·ä½“åŒ–ã•ã‚ŒãŸã¨ãŠã‚Šã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¨çµ„ã¿åˆã‚ã›ã‚‹ã ã‘ã§ã‚ˆã„ã€‚
</p>

<p class="lisp">(deriv '(+ x 3) 'x)
<i>(+ 1 0)</i>
(deriv '(* x y) 'x)
<i>(+ (* x 0) (* 1 y))</i>
(deriv '(* (* x y) (+ x 3)) 'x)
<i>(+ (* (* x y) (+ 1 0))
   (* (+ (* x 0) (* 1 y))
      (+  x 3)))</i>
</p>

<p class="orig" lang="en">
The program produces answers that are correct; however, they are
unsimplified.  It is true that</p>

<p class="trans" lang="ja">
ã“ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€æ­£ã—ã„ç­”ãˆã‚’å‡ºã™ã€‚
ã—ã‹ã—ã€ãã‚Œã‚‰ã®ç­”ãˆã¯ã€ç°¡ç•¥åŒ–ã•ã‚Œã¦ã„ãªã„ã€‚
ä»¥ä¸‹ã®ã“ã¨ã¯çœŸã§ã‚ã‚‹
</p>

<figure><img src="ch2-Z-G-49.gif" border="0"></figure>

<p class="orig" lang="en">
but we would like the program to know that <em>x</em> &middot;  0  =  0, 1 &middot;  <em>y</em>  = 
<em>y</em>, and 0 + <em>y</em> = <em>y</em>.  The answer for the second example should have been
simply <tt>y</tt>.  As the third example shows, this becomes a serious
issue when the expressions are complex.</p>

<p class="trans" lang="ja">
ãŒã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ã¯ã€
<span class="math"><em class="en">x</em> &middot;  0  =  0</span>
ã§ã‚ã‚Šã€
<span class="math">1 &middot;  <em class="en">y</em>  = <em class="en">y</em></span>
ã§ã‚ã‚Šã€
<span class="math">0 + <em class="en">y</em> = <em class="en">y</em></span>
ã§ã‚ã‚‹ã€ã¨ã„ã†ã“ã¨ã‚’çŸ¥ã£ã¦ã„ã¦ã»ã—ã„ã®ã ã€‚
2ç•ªç›®ã®ä¾‹ã®ç­”ãˆã¯ã€ç°¡æ½”ã«ã€<tt>y</tt> ã¨ãªã‚‹ã¹ãã ã£ãŸã€‚
3ç•ªç›®ã®ä¾‹ãŒç¤ºã™ã¨ãŠã‚Šã€ã“ã‚Œã¯ã€å¼ãŒè¤‡é›‘ãªå ´åˆã«ã¯æ·±åˆ»ãªå•é¡Œã¨ãªã‚‹ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_2084"></a><a name="%_idx_2086"></a>Our difficulty is much like the one we encountered with the
rational-number implementation: we haven't reduced answers to simplest
form.  To accomplish the rational-number reduction, we needed to
change only the constructors and the selectors of the implementation.
We can adopt a similar strategy here.  We won't change <tt>deriv</tt> at
all.  Instead, we will change <tt>make-sum</tt> so that if both summands
are numbers, <tt>make-sum</tt> will add them and return their sum.  Also,
if one of the summands is 0, then <tt>make-sum</tt> will return the other
summand.
</p>

<p class="trans" lang="ja">
ç§ãŸã¡ã«ã¨ã£ã¦ã®å›°é›£ã¯ã€æœ‰ç†æ•°ã®å®Ÿè£…ã®ã¨ãã«ç›´é¢ã—ãŸã®ã¨ã»ã¨ã‚“ã©åŒã˜ã‚‚ã®ã â€”â€”ç§ãŸã¡ã¯ã¾ã ã€ã‚‚ã£ã¨ã‚‚ç°¡æ½”ãªå½¢å¼ã¸ã¨ç­”ãˆã‚’é‚„å…ƒã—ã¦ã„ãªã„ã€‚
æœ‰ç†æ•°ã®ç´„åˆ†ã‚’é”æˆã™ã‚‹ãŸã‚ã«ã¯ã€å®Ÿè£…ã®ã†ã¡ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¨ã‚»ãƒ¬ã‚¯ã‚¿ã®ã¿ã‚’å¤‰æ›´ã™ã‚‹å¿…è¦ãŒã‚ã£ãŸã€‚
ã“ã“ã§ä¼¼ãŸã‚ˆã†ãªæˆ¦ç•¥ã‚’æ¡ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
<tt>deriv</tt> ã¯ã€ã¾ã£ãŸãå¤‰æ›´ã—ãŸããªã„ã€‚
ä»£ã‚ã‚Šã«ã€è¶³ã•ã‚Œã‚‹ã‚‚ã®ãŒäºŒã¤ã¨ã‚‚æ•°ãªã‚‰ã°ã€<tt>make-sum</tt> ãŒãã‚Œã‚‰ã‚’è¶³ã—ã¦ãã®å’Œã‚’è¿”ã™ã‚ˆã†ã«ã€<tt>make-sum</tt> ã‚’å¤‰æ›´ã—ã‚ˆã†ã€‚
ã¾ãŸã€è¶³ã•ã‚Œã‚‹ã‚‚ã®ã®ã†ã¡ã®ä¸€æ–¹ãŒ0ãªã‚‰ã°ã€<tt>make-sum</tt> ã¯ã€ä»–æ–¹ã‚’è¿”ã™ã ã‚ã†ã€‚
</p>

<p class="lisp"><a name="%_idx_2088"></a>(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2)) (+ a1 a2))
        (else (list '+ a1 a2))))
</p>

<p class="orig" lang="en">
This uses the procedure <tt>=number?</tt>, which checks whether an
expression is equal to a given number:
</p>

<p class="trans" lang="ja">
ã“ã‚Œã¯ã€<tt>=number?</tt> ã¨ã„ã†è¿°èªâ€”â€”å¼ãŒã€ä¸ãˆã‚‰ã‚ŒãŸæ•°ã¨ç­‰ã—ã„ã‹ã©ã†ã‹ã‚’æ¤œæŸ»ã™ã‚‹â€”â€”ã‚’ä½¿ã£ã¦ã„ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_2090"></a>(define (=number? exp num)
  (and (number? exp) (= exp num)))
</p>

<p class="orig" lang="en">
Similarly, we will change <tt>make-product</tt> to build in the rules that 0
times anything is 0 and 1 times anything is the thing itself:
</p>

<p class="trans" lang="ja">
åŒæ§˜ã«ã€ä½•ã§ã‚‚ãã®0å€ã¯0ã§ã‚ã‚Šã€ã‹ã¤ã€ä½•ã§ã‚‚1å€ã¯ãã®ã‚‚ã®è‡ªèº«ã§ã‚ã‚‹ã€ã¨ã„ã†è¦å‰‡ã‚’ç¹”ã‚Šè¾¼ã‚€ã‚ˆã†ã«ã€<tt>make-product</tt> ã‚’å¤‰æ›´ã—ã‚ˆã†ã€‚
</p>

<p class="lisp"><a name="%_idx_2092"></a>(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        (else (list '* m1 m2))))
</p>

<p class="orig" lang="en">
Here is how this version works on our three examples:
</p>

<p class="trans" lang="ja">
ç§ãŸã¡ã®ä¸‰ã¤ã®ä¾‹ã«é–¢ã—ã¦ã€ã“ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒã©ã†å‹•ãã‹ã‚’ã€ã“ã“ã«ç¤ºã™ã€‚
</p>

<p class="lisp">(deriv '(+ x 3) 'x)
<i>1</i>
(deriv '(* x y) 'x)
<i>y</i>
(deriv '(* (* x y) (+ x 3)) 'x)
<i>(+ (* x y) (* y (+ x 3)))</i>
</p>

<p class="orig" lang="en">
Although this is quite an improvement, the third example shows that
there is still a long way to go before we get a program that puts
expressions into a form that we might agree is ``simplest.''  The
problem of algebraic simplification is complex because, among other
reasons, a form that may be simplest for one purpose may not be for
another.
</p>

<p class="trans" lang="ja">
ã“ã‚Œã¯å¤§å¤‰ãªæ”¹å–„ã ã‘ã‚Œã©ã‚‚ã€å¼ã‚’ã€ç§ãŸã¡ãŒã€Œã‚‚ã£ã¨ã‚‚ç°¡æ½”ã ã­ã€ã¨åŒæ„ã™ã‚‹ã§ã‚ã‚ã†ã‚ˆã†ãªå½¢å¼ã«ã—ã¦ãã‚Œã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’å¾—ã‚‹ã¾ã§ã«ã¯ã€ã¾ã ã¾ã é•·ã„é“ã®ã‚ŠãŒã‚ã‚‹ã€ã¨ã„ã†ã“ã¨ã‚’ã€3ç•ªç›®ã®ä¾‹ã¯ç¤ºã—ã¦ã„ã‚‹ã€‚
ä»£æ•°çš„ãªç°¡æ½”åŒ–ã®å•é¡Œã¯ã€è¤‡é›‘ã§ã‚ã‚‹ã€‚ãªãœãªã‚‰â€”â€”ä»–ã®ç†ç”±ã‚‚ã‚ã‚‹ãŒã€ãã®ä¸­ã§ã‚‚ã¨ã‚Šã‚ã‘â€”â€”ã‚ã‚‹ä¸€ã¤ã®ç›®çš„ã«ã¨ã£ã¦ã‚‚ã£ã¨ã‚‚ç°¡æ½”ã‹ã‚‚ã—ã‚Œãªã„å½¢å¼ã¯ã€ä»–ã®ç›®çš„ã«ã¨ã£ã¦ã¯ãã†ã§ãªã„ã‹ã‚‚ã—ã‚Œãªã„ã‹ã‚‰ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="%_thm_2.56"></a>
<b>Exercise 2.56.</b>  <a name="%_idx_2094"></a>Show how to extend the basic differentiator to handle more kinds of
expressions.  For instance, implement the differentiation rule</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.56.</b> åŸºæœ¬çš„ãªå¾®åˆ†æ¼”ç®—å­ã‚’ã€ã‚ˆã‚Šå¤šãã®ç¨®é¡ã®å¼ã‚’æ‰±ã†ã‚ˆã†ã«æ‹¡å¼µã™ã‚‹æ–¹æ³•ã‚’ç¤ºã›ã€‚
ãŸã¨ãˆã°ã€ä»¥ä¸‹ã®å¾®åˆ†è¦å‰‡ã‚’å®Ÿè£…ã›ã‚ˆ
</p>

<figure><img src="ch2-Z-G-50.gif" border="0"></figure>

<p class="orig" lang="en">
by adding a new clause to the <tt>deriv</tt> program
and defining
appropriate procedures <tt>exponentiation?</tt>, <tt>base</tt>, <tt>exponent</tt>,
and <tt>make-exponentiation</tt>.  (You may use the symbol <tt>**</tt> to denote
exponentiation.)
Build in the rules that anything raised to the power 0 is 1 and
anything raised to the power 1 is the thing itself.
</p>

<p class="trans" lang="ja">
â€”â€”<tt>deriv</tt> ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«æ–°ãŸãªç¯€ã‚’è¿½åŠ ã—ã€ã‹ã¤ã€<tt>exponentiation?</tt> ã¨ <tt>base</tt> ã¨ <tt>exponent</tt> ã¨ <tt>make-exponentiation</tt> ã¨ã„ã†é©å®œã®æ‰‹ç¶šãã‚’å®šç¾©ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€‚
(ç´¯ä¹—ã‚’è¡¨ã™ã®ã« <tt>**</tt> ã¨ã„ã†è¨˜å·ã‚’ä½¿ã£ã¦ã‚‚ã‚ˆã„ã‚ˆã€‚)
0ä¹—ã•ã‚ŒãŸã‚‚ã®ã¯ä½•ã§ã‚‚1ã§ã‚ã‚Šã€ã‹ã¤ã€1ä¹—ã•ã‚ŒãŸã‚‚ã®ã¯ä½•ã§ã‚‚ãã‚Œè‡ªèº«ã§ã‚ã‚‹ã€ã¨ã„ã†è¦å‰‡ã‚’ç¹”ã‚Šè¾¼ã‚€ã‚ˆã†ã«ã­ã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_2.57"></a>
<b>Exercise 2.57.</b>  Extend the differentiation program to handle sums and products of
arbitrary numbers of (two or more) terms.
Then the last example above could be expressed as</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.57.</b> å¾®åˆ†ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ã€(2ä»¥ä¸Šã®) ä»»æ„ã®å€‹æ•°ã®é …ã®å’Œã¨ç©ã‚’æ‰±ã†ã‚ˆã†ã«ã€æ‹¡å¼µã›ã‚ˆã€‚
ã™ã‚‹ã¨ã€ä¸Šè¨˜ã®æœ€å¾Œã®ä¾‹ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã«è¡¨ç¾ã§ãã‚‹ã ã‚ã†ã€‚
</p>

<p class="lisp">(deriv '(* x y (+ x 3)) 'x)
</p>

<p class="orig" lang="en">
Try to do this by changing only the
representation for sums and products, without changing the <tt>deriv</tt> procedure at all.  For example, the <tt>addend</tt> of a sum would
be the first term, and the <tt>augend</tt> would be the sum of the rest
of the terms.
</p>

<p class="trans" lang="ja">
<tt>deriv</tt> ã®æ‰‹ç¶šãã‚’ã¾ã£ãŸãå¤‰ãˆãšã«ã€å’Œã¨ç©ã®è¡¨ç¾ã®ã¿ã‚’å¤‰ãˆã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€ã“ã®ã‚ˆã†ãªæ‹¡å¼µã‚’è¡Œã£ã¦ã¿ã‚ˆã€‚
ãŸã¨ãˆã°ã€å’Œã® <tt>addend</tt> ã¯ã€æœ€åˆã®é …ã ã‚ã†ã—ã€<tt>augend</tt> ã¯æ®‹ã‚Šã®é …ã®å’Œã ã‚ã†ã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_2.58"></a>
<b>Exercise 2.58.</b>  <a name="%_idx_2096"></a><a name="%_idx_2098"></a>Suppose we want to modify the differentiation program so that it works
with ordinary mathematical notation, in which <tt>+</tt> and <tt>*</tt> are
infix rather than prefix operators.  Since the differentiation program
is defined in terms of abstract data, we can modify it to work with
different representations of expressions solely by changing the
predicates, selectors, and constructors that define the representation
of the algebraic expressions on which the differentiator is to
operate.</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.58.</b> å¾®åˆ†ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ã€æ™®é€šã®æ•°å­¦çš„è¡¨è¨˜â€”â€”ãã“ã§ã¯ <tt>+</tt> ã‚„ <tt>*</tt> ãŒã€å‰ç½®æ¼”ç®—å­ã§ã¯ãªãä¸­ç½®æ¼”ç®—å­ã§ã‚ã‚‹â€”â€”ã«å¯¾ã—ã¦å‹•ãã‚ˆã†ã«ã€ä¿®æ­£ã—ãŸã„ã®ã ã¨ã—ã‚ˆã†ã€‚
å¾®åˆ†ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯æŠ½è±¡ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ã£ã¦å®šç¾©ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€ç§ãŸã¡ã¯ã€ãŸã ã€å¾®åˆ†æ¼”ç®—å­ãŒå‹•ä½œã™ã‚‹å¯¾è±¡ã§ã‚ã‚‹ä»£æ•°å¼ã®è¡¨ç¾ã‚’å®šç¾©ã—ã¦ã„ã‚‹è¿°èªãƒ»ã‚»ãƒ¬ã‚¯ã‚¿ãƒ»ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’å¤‰æ›´ã™ã‚‹ã ã‘ã§ã€å¾®åˆ†ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ã€å¼ã®åˆ¥è¡¨ç¾ã«å¯¾ã—ã¦å‹•ãã‚ˆã†ã«ã€ä¿®æ­£ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
</p>

<ol start="1" class="orig" lang="en" style="list-style-type: lower-alpha">
<li>
Show how to do this in order to differentiate algebraic
expressions presented in infix form, such as <tt>(x + (3 * (x + (y + 2))))</tt>.
To simplify the task, assume that <tt>+</tt> and <tt>*</tt> always
take two arguments and that expressions are fully parenthesized.
</li>
</ol>

<ol start="1" class="trans" lang="ja" style="list-style-type: lower-alpha">
<li>
ãŸã¨ãˆã° <tt>(x + (3 * (x + (y + 2))))</tt> ã®ã‚ˆã†ã«ä¸­ç½®å½¢å¼ã§æç¤ºã•ã‚ŒãŸä»£æ•°å¼ã‚’å¾®åˆ†ã™ã‚‹ãŸã‚ã«ã€ä»¥ä¸Šã®ã‚ˆã†ãªä¿®æ­£ã‚’è¡Œã†æ–¹æ³•ã‚’ç¤ºã›ã€‚
èª²é¡Œã‚’ç°¡æ½”åŒ–ã™ã‚‹ãŸã‚ã«ã€<tt>+</tt> ã¨ <tt>*</tt> ãŒå¸¸ã«äºŒã¤ã®å¼•æ•°ã‚’ã¨ã‚‹ã‚‚ã®ã¨ã—ã€ã‹ã¤ã€å¼ã¯æ¼ã‚Œãªãæ‹¬å¼§ã§æ‹¬ã‚‰ã‚Œã¦ã„ã‚‹ã‚‚ã®ã¨ã›ã‚ˆã€‚
</li>
</ol>

<p class="exercise"><span class="ex_comment">
</span></p>

<ol start="2" class="orig" lang="en" style="list-style-type: lower-alpha">
<li>
The problem becomes substantially harder if we allow standard
algebraic notation, such as <tt>(x + 3 * (x + y + 2))</tt>, which drops
unnecessary parentheses and assumes that multiplication is done before
addition.  Can you design appropriate predicates, selectors, and
constructors for this notation such that our derivative program still
works?
</li>
</ol>


<ol start="2" class="trans" lang="ja" style="list-style-type: lower-alpha">
<li>
ãŸã¨ãˆã° <tt>(x + 3 * (x + y + 2))</tt> ã®ã‚ˆã†ãªã€æ¨™æº–çš„ãªä»£æ•°çš„è¡¨è¨˜â€”â€”ä¸å¿…è¦ãªæ‹¬å¼§ã¯ä½¿ã‚ãšã€åŠ ç®—ã®å‰ã«ä¹—ç®—ãŒå®Ÿè¡Œã•ã‚Œã‚‹ã“ã¨ã‚’å‰æã¨ã™ã‚‹â€”â€”ã‚’è¨±ã™ã“ã¨ã«ã—ãŸã‚‰ã€å•é¡Œã¯ç›¸å½“ã«é›£ã—ããªã‚‹ã€‚
ãã‚Œã§ã‚‚ãªãŠç§ãŸã¡ã®å¾®åˆ†ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒå‹•ãã‚ˆã†ã«ã€å›ã¯ã€ã“ã®è¡¨è¨˜ã®ãŸã‚ã®é©åˆ‡ãªè¿°èªãƒ»ã‚»ãƒ¬ã‚¯ã‚¿ãƒ»ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’è¨­è¨ˆã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã‹ãª?
</li>
</ol>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_2.3.3"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_2.3.3">2.3.3  Example: Representing Sets</a></h3>
<h3 class="trans" lang="ja">2.3.3 ä¾‹: é›†åˆã‚’è¡¨ç¾ã™ã‚‹</h3>

<p class="orig" lang="en">
<a name="%_idx_2100"></a>
In the previous examples we built representations for two kinds of
compound data objects: rational numbers and algebraic expressions.  In
one of these examples we had the choice of simplifying (reducing) the
expressions at either construction time or selection time, but other
than that the choice of a representation for these structures in terms
of lists was straightforward. When we turn to the representation of
sets, the choice of a representation is not so obvious.  Indeed, there
are a number of possible representations, and they differ
significantly from one another in several ways.</p>

<p class="trans" lang="ja">
ä»Šã¾ã§ã®ä¾‹ã§ã€ç§ãŸã¡ã¯ã€2ç¨®é¡ã®è¤‡åˆãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆâ€”â€”ã¤ã¾ã‚Šã€æœ‰ç†æ•°ã¨ä»£æ•°å¼â€”â€”ã®è¡¨ç¾ã‚’æ§‹ç¯‰ã—ãŸã€‚
ã“ã‚Œã‚‰ã®ä¾‹ã®ã†ã¡ã®ä¸€ã¤ã§ã¯ã€æ§‹ç¯‰æ™‚ã¨é¸æŠæ™‚ã®ã©ã¡ã‚‰ã«ãŠã„ã¦å¼ã‚’ç°¡æ½”åŒ–ã™ã‚‹ (é‚„å…ƒã™ã‚‹) ã®ã‹ã€ã¨ã„ã†é¸æŠã®ä½™åœ°ãŒã‚ã£ãŸãŒã€ãƒªã‚¹ãƒˆã‚’ç”¨ã„ãŸã“ã‚Œã‚‰ã®æ§‹é€ ä½“ã®ãŸã‚ã®è¡¨ç¾ã«ã¤ã„ã¦ã®é¸æŠè‚¢ã¯ã€å˜ç´”æ˜å¿«ã ã£ãŸã€‚
é›†åˆã®è¡¨ç¾ã«ç›®ã‚’å‘ã‘ã‚‹ã¨ãã€è¡¨ç¾ã«ã¤ã„ã¦ã®é¸æŠè‚¢ã¯ã€ãã‚Œã»ã©è‡ªæ˜ãªã‚‚ã®ã§ã¯ãªã„ã€‚
å®Ÿéš›ã€å¯èƒ½ãªè¡¨ç¾ãŒã„ãã¤ã‚‚ã‚ã‚‹ã—ã€ãã‚Œã‚‰ã¯è‰²ã€…ãªé¢ã§äº’ã„ã«è‘—ã—ãç•°ãªã£ã¦ã„ã‚‹ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_2102"></a>Informally, a set is simply a collection of distinct objects.  To give
a more precise definition we can employ the method of data
abstraction.  That is, we define ``set'' by specifying the operations
that are to be used on sets.  These are <tt>union-set</tt>,
<tt>intersection-set</tt>, <tt>element-of-set?</tt>, and <tt>adjoin-set</tt>.
<a name="%_idx_2104"></a><tt>Element-of-set?</tt> is a predicate that determines whether a given
element is a member of a set.  <a name="%_idx_2106"></a><tt>Adjoin-set</tt> takes an object and a
set as arguments and returns a set that contains the elements of the
original set and also the adjoined element.  <a name="%_idx_2108"></a><tt>Union-set</tt> computes
the union of two sets, which is the set containing each element that
appears in either argument.  <a name="%_idx_2110"></a><tt>Intersection-set</tt> computes the
intersection of two sets, which is the set containing only elements
that appear in both arguments.  From the viewpoint of data abstraction, we
are free to design any representation that implements these operations
in a way consistent with the interpretations given above.<a name="call_footnote_Temp_240" href="#footnote_Temp_240"><sup><small>37</small></sup></a>
</p>

<p class="trans" lang="ja">
ãã ã‘ãŸè¨€ã„æ–¹ã‚’ã™ã‚‹ã¨ã€é›†åˆã¨ã¯ã€ç•°ãªã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é›†ã¾ã‚Šã§ã‚ã‚‹ã€‚
ã‚ˆã‚Šæ­£ç¢ºãªå®šç¾©ã‚’ä¸ãˆã‚‹ãŸã‚ã«ã¯ã€ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ã®æ–¹æ³•ã‚’ä½¿ã†ã“ã¨ãŒã§ãã‚‹ã€‚
ã¤ã¾ã‚Šã€é›†åˆä¸Šã§ä½¿ã‚ã‚Œã‚‹ã¹ãæ¼”ç®—å­ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€ã€Œé›†åˆã€ã‚’å®šç¾©ã™ã‚‹ã®ã ã€‚
ã“ã‚Œã‚‰ã®æ¼”ç®—å­ã¨ã¯ã€<tt>union-set</tt> ã¨ <tt>intersection-set</tt> ã¨ <tt>element-of-set?</tt> ã¨ <tt>adjoin-set</tt> ã§ã‚ã‚‹ã€‚
<tt>element-of-set?</tt> ã¯ã€ä¸ãˆã‚‰ã‚ŒãŸè¦ç´ ãŒé›†åˆã®æ§‹æˆè¦ç´ ã‹ã©ã†ã‹ã‚’åˆ¤å®šã™ã‚‹è¿°èªã§ã‚ã‚‹ã€‚
<tt>adjoin-set</tt> ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨é›†åˆã‚’å¼•æ•°ã¨ã—ã¦ã¨ã‚Šã€å…ƒã®é›†åˆã®è¦ç´ ã¨ã€è¿½åŠ ã•ã‚ŒãŸè¦ç´ ã¨ã‚’å«ã‚€ã‚ˆã†ãªã€é›†åˆã‚’è¿”ã™ã€‚
<tt>union-set</tt> ã¯ã€äºŒã¤ã®é›†åˆã®å’Œé›†åˆâ€”â€”ã„ãšã‚Œã‹ã®å¼•æ•°ã®ä¸­ã«ç¾ã‚Œã‚‹å„è¦ç´ ã‚’å«ã‚€é›†åˆã®ã“ã¨ã â€”â€”ã‚’è¨ˆç®—ã™ã‚‹ã€‚
<tt>intersection-set</tt> ã¯ã€äºŒã¤ã®é›†åˆã®ç©é›†åˆâ€”â€”ä¸¡æ–¹ã®å¼•æ•°ã®ä¸­ã«ç¾ã‚Œã‚‹è¦ç´ ã®ã¿ã‚’å«ã‚€é›†åˆã®ã“ã¨ã â€”â€”ã‚’è¨ˆç®—ã™ã‚‹ã€‚
ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ã®è¦³ç‚¹ã‹ã‚‰ã¯ã€ä»¥ä¸Šã®ã‚ˆã†ã«ä¸ãˆã‚‰ã‚ŒãŸè§£é‡ˆã¨æ•´åˆæ€§ãŒã¨ã‚ŒãŸæ–¹æ³•ã§ã“ã‚Œã‚‰ã®æ¼”ç®—å­ã‚’å®Ÿè£…ã™ã‚‹ã‚ˆã†ãªã€ã©ã‚“ãªè¡¨ç¾ã§ã‚‚ã€è‡ªç”±ã«è¨­è¨ˆã§ãã‚‹<a href="#footnote_Temp_240"><sup><small>37</small></sup></a>ã€‚
</p>

<a name="%_sec_Temp_241"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_241">Sets as unordered lists</a></h4>
<h4 class="trans" lang="ja">é †åºä»˜ã‘ã•ã‚Œã¦ã„ãªã„ãƒªã‚¹ãƒˆã¨ã—ã¦ã®é›†åˆ</h4>

<p class="orig" lang="en">
<a name="%_idx_2112"></a><a name="%_idx_2114"></a>
One way to represent a set is as a list of its elements in which no
element appears more than once.  The empty set is represented by the
empty list.  In this representation, <tt>element-of-set?</tt> is similar
to the procedure <tt>memq</tt> of section <a href="#%_sec_2.3.1">2.3.1</a>.  It uses <tt>equal?</tt>
instead of <tt>eq?</tt> so that the set elements need not be symbols:
</p>

<p class="trans" lang="ja">
é›†åˆã‚’è¡¨ç¾ã™ã‚‹ä¸€ã¤ã®æ–¹æ³•ã¯ã€ãã®é›†åˆã®è¦ç´ ã®ãƒªã‚¹ãƒˆã§ã‚ã£ã¦ã€ãã®ä¸­ã«1å›ã‚ˆã‚Šå¤šãç¾ã‚Œã‚‹è¦ç´ ãŒãªã„ã‚ˆã†ãªã‚‚ã®ã¨ã—ã¦ã€è¡¨ç¾ã™ã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚
ç©ºé›†åˆã¯ã€ç©ºãƒªã‚¹ãƒˆã«ã‚ˆã‚Šè¡¨ç¾ã•ã‚Œã‚‹ã€‚
ã“ã®è¡¨ç¾ã§ã¯ã€<tt>element-of-set?</tt> ã¯ã€<a href="#%_sec_2.3.1">2.3.1</a>ç¯€ã® <tt>memq</tt> ã¨ã„ã†æ‰‹ç¶šãã«ä¼¼ã¦ã„ã‚‹ã€‚
<tt>element-of-set?</tt> ã¯ã€é›†åˆã®è¦ç´ ãŒè¨˜å·ã§ãªãã¦ã‚‚æ§‹ã‚ãªã„ã‚ˆã†ã«ã€<tt>eq?</tt> ã®ä»£ã‚ã‚Šã« <tt>equal?</tt> ã‚’ä½¿ã†ã€‚
</p>

<p class="lisp"><a name="%_idx_2116"></a>(define (element-of-set? x set)
  (cond ((null? set) false)
        ((equal? x (car set)) true)
        (else (element-of-set? x (cdr set)))))
</p>

<p class="orig" lang="en">
Using this, we can write <tt>adjoin-set</tt>.  If the object to be adjoined
is already in the set, we just return the set.  Otherwise, we use
<tt>cons</tt> to add the object to the list that represents the set:
</p>

<p class="trans" lang="ja">
ã“ã‚Œã‚’ä½¿ã£ã¦ã€<tt>adjoin-set</tt> ã‚’æ›¸ã‘ã‚‹ã€‚
ã‚‚ã—ã€è¿½åŠ ã•ã‚Œã‚‹ã¹ãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒæ—¢ã«ãã®é›†åˆã®ä¸­ã«ã‚ã‚Œã°ã€ãã®é›†åˆã‚’è¿”ã™ã ã‘ã ã€‚
ãã‚Œä»¥å¤–ã®å ´åˆã€<tt>cons</tt> ã‚’ä½¿ã£ã¦ã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã€ãã®é›†åˆã‚’è¡¨ç¾ã™ã‚‹ãƒªã‚¹ãƒˆã«ã€è¿½åŠ ã™ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_2118"></a>(define (adjoin-set x set)
  (if (element-of-set? x set)
      set
      (cons x set)))
</p>

<p class="orig" lang="en">
For <tt>intersection-set</tt> we can use a recursive strategy.  If we
know how to form the intersection of <tt>set2</tt> and the <tt>cdr</tt>
of <tt>set1</tt>, we only need to decide whether to include
the <tt>car</tt> of <tt>set1</tt> in this.  But this depends on whether <tt>(car
set1)</tt> is also in <tt>set2</tt>.  Here is the resulting procedure:
</p>

<p class="trans" lang="ja">
<tt>intersection-set</tt> ã«ã¤ã„ã¦ã¯ã€å†å¸°çš„ãªæˆ¦ç•¥ãŒä½¿ãˆã‚‹ã€‚
ã‚‚ã—ã€<tt>set2</tt> ã¨ã€<tt>set1</tt> ã® <tt>cdr</tt> ã¨ã®ç©é›†åˆã‚’å½¢æˆã™ã‚‹æ–¹æ³•ãŒåˆ†ã‹ã£ã¦ã„ã‚‹ãªã‚‰ã€<tt>set1</tt> ã® <tt>car</tt> ã‚’ã“ã®ç©é›†åˆã®ä¸­ã«å«ã‚ã‚‹ã¹ãã‹ã©ã†ã‹ã‚’æ±ºã‚ã‚‹ã ã‘ã§ã‚ˆã„ã€‚
ã—ã‹ã—ã“ã‚Œã¯ã€<tt>(car set1)</tt> ã‚‚ <tt>set2</tt> ã®ä¸­ã«ã‚ã‚‹ã®ã‹ã©ã†ã‹ã€ã¨ã„ã†ã“ã¨ã«ä¾å­˜ã™ã‚‹ã€‚
ãã®çµæœã§ãã‚‹æ‰‹ç¶šãã‚’ã€ã“ã“ã«ç¤ºã™ã€‚
</p>

<p class="lisp"><a name="%_idx_2120"></a>(define (intersection-set set1 set2)
  (cond ((or (null? set1) (null? set2)) '())
        ((element-of-set? (car set1) set2)        
         (cons (car set1)
               (intersection-set (cdr set1) set2)))
        (else (intersection-set (cdr set1) set2))))
</p>

<p class="orig" lang="en">
In designing a representation, one of the issues we should be
concerned with is efficiency.  Consider the number of steps required by our set
operations.  Since they all use <tt>element-of-set?</tt>, the speed
of this operation has a major impact on the efficiency of the set
implementation as a whole.  Now, in order to check whether an object
is a member of a set, <tt>element-of-set?</tt> may have to scan the
entire set. (In the worst case, the object turns out not to be in the
set.)  Hence, if the set has <em>n</em> elements, <tt>element-of-set?</tt>
might take up to <em>n</em> steps.  Thus, the number of steps
required grows as <img src="book-Z-G-D-3.gif" border="0">(<em>n</em>).
The number of steps required by <tt>adjoin-set</tt>, which uses this operation,
also grows as <img src="book-Z-G-D-3.gif" border="0">(<em>n</em>).  For <tt>intersection-set</tt>, which does an <tt>element-of-set?</tt> check for each element of <tt>set1</tt>, the number of steps
required grows as the product of the sizes of the sets involved, or
<img src="book-Z-G-D-3.gif" border="0">(<em>n</em><sup>2</sup>) for two sets of size <em>n</em>.  The same will be true of <tt>union-set</tt>.</p>

<p class="trans" lang="ja">
è¡¨ç¾ã‚’è¨­è¨ˆã™ã‚‹ã«ã‚ãŸã£ã¦ã€é–¢å¿ƒã‚’å¯„ã›ã‚‹ã¹ãè«–ç‚¹ã®ä¸€ã¤ã¯ã€åŠ¹ç‡ã§ã‚ã‚‹ã€‚
ç§ãŸã¡ã®é›†åˆæ¼”ç®—ãŒå¿…è¦ã¨ã™ã‚‹ã‚¹ãƒ†ãƒƒãƒ—æ•°ã‚’è€ƒãˆã‚ˆã€‚
ã“ã‚Œã‚‰ã®é›†åˆæ¼”ç®—ã¯ã©ã‚Œã‚‚ <tt>element-of-set?</tt> ã‚’åˆ©ç”¨ã™ã‚‹ãŸã‚ã€å…¨ä½“ã¨ã—ã¦ã¯ã€ã“ã®æ¼”ç®—ã®é€Ÿã•ãŒã€é›†åˆã®å®Ÿè£…ã®åŠ¹ç‡ã«å¯¾ã—ã¦ä¸»è¦ãªå½±éŸ¿ã‚’ä¸ãˆã‚‹ã€‚
ã•ã¦ã€ã‚ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚ã‚‹é›†åˆã®æ§‹æˆè¦ç´ ã‹ã©ã†ã‹ã‚’æ¤œæŸ»ã™ã‚‹ãŸã‚ã«ã¯ã€<tt>element-of-set?</tt> ã¯ã€é›†åˆå…¨ä½“ã‚’èµ°æŸ»ã—ãªãã¦ã¯ãªã‚‰ãªã„ã“ã¨ãŒã‚ã‚‹ã€‚
(æœ€æ‚ªã®å ´åˆã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒãã®é›†åˆã®ä¸­ã«ãªã„ã¨åˆ¤æ˜ã™ã‚‹ã€‚)
ã‚ˆã£ã¦ã€ã‚‚ã—é›†åˆãŒ <em class="en">n</em> å€‹ã®è¦ç´ ã‚’æŒã¤ãªã‚‰ã°ã€<tt>element-of-set?</tt> ã¯ã€<em class="en">n</em> ã‚¹ãƒ†ãƒƒãƒ—ã¾ã§ã‹ã‹ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚
ã—ãŸãŒã£ã¦ã€å¿…è¦ãªã‚¹ãƒ†ãƒƒãƒ—æ•°ã¯ã€&Theta;(<em class="en">n</em>) ã§å¢—å¤§ã™ã‚‹ã€‚
<tt>adjoin-set</tt> â€”â€”ã“ã® <tt>element-of-set?</tt> ã¨ã„ã†æ¼”ç®—ã‚’ä½¿ã†â€”â€”ã§å¿…è¦ãªã‚¹ãƒ†ãƒƒãƒ—æ•°ã‚‚ã€&Theta;(<em class="en">n</em>) ã§å¢—å¤§ã™ã‚‹ã€‚
<tt>intersection-set</tt> â€”â€”<tt>element-of-set?</tt> ã®æ¤œæŸ»ã‚’ <tt>set1</tt> ã®å„è¦ç´ ã«å¯¾ã—ã¦è¡Œã†â€”â€”ã«ã¤ã„ã¦ã¯ã€å¿…è¦ãªã‚¹ãƒ†ãƒƒãƒ—æ•°ã¯ã€å½“è©²ä¸¡é›†åˆã®å¤§ãã•åŒå£«ã®ç©ã«å¿œã˜ã¦â€”â€”ã¤ã¾ã‚Šã€å¤§ãã•ãŒ <em class="en">n</em> ã®äºŒã¤ã®é›†åˆã«å¯¾ã—ã¦ã¯ &Theta;(<em class="en">n</em><sup>2</sup>) ã§â€”â€”å¢—å¤§ã™ã‚‹ã€‚
</p>

<p class="orig" lang="en">
<a name="%_thm_2.59"></a>
<b>Exercise 2.59.</b>  Implement the <a name="%_idx_2122"></a><tt>union-set</tt> operation for the unordered-list
representation of sets.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.59.</b> é›†åˆã®ã€é †åºãªã—ãƒªã‚¹ãƒˆè¡¨ç¾ã®ãŸã‚ã®ã€<tt>union-set</tt> æ¼”ç®—ã‚’å®Ÿè£…ã›ã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_2.60"></a>
<b>Exercise 2.60.</b>  We specified that a set would be represented as a list with no
duplicates.  Now suppose we allow duplicates.  For instance,
the set {1,2,3} could be represented as the list <tt>(2 3 2 1 3 2
2)</tt>.  Design procedures <tt>element-of-set?</tt>, <tt>adjoin-set</tt>, <tt>union-set</tt>, and <tt>intersection-set</tt> that operate on this
representation.  How does the efficiency of each compare with the
corresponding procedure for the non-duplicate representation?  Are
there applications for which you would use this representation in
preference to the non-duplicate one?
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.60.</b> ç§ãŸã¡ã¯ã€é›†åˆã¯è¤‡è£½ã®ãªã„ãƒªã‚¹ãƒˆã¨ã—ã¦è¡¨ç¾ã•ã‚Œã‚‹ã ã‚ã†ã€ã¨æŒ‡å®šã—ãŸã€‚
ã“ã“ã§ã€è¤‡è£½ã‚’è¨±ã™ã‚‚ã®ã¨æƒ³å®šã›ã‚ˆã€‚
ãŸã¨ãˆã°ã€
<span class="math">{1, 2, 3}</span>
ã¨ã„ã†é›†åˆã¯ã€
<tt>(2 3 2 1 3 2 2)</tt>
ã¨ã„ã†ãƒªã‚¹ãƒˆã¨ã—ã¦è¡¨ç¾ã•ã‚Œå¾—ã‚‹ã€‚
ã“ã®è¡¨ç¾ã®ä¸Šã§å‹•ä½œã™ã‚‹ã‚ˆã†ãªã€<tt>element-of-set?</tt> ã¨ <tt>adjoin-set</tt> ã¨ <tt>union-set</tt> ã¨ <tt>intersection-set</tt> ã®æ‰‹ç¶šãã‚’ã€è¨­è¨ˆã›ã‚ˆã€‚
å„ã€…ã®æ‰‹ç¶šãã®åŠ¹ç‡ã¯ã€è¤‡è£½ãªã—ã®è¡¨ç¾ã«ãŠã‘ã‚‹ã€ãã‚Œã«ç›¸å½“ã™ã‚‹æ‰‹ç¶šãã¨æ¯”ã¹ã¦ã€ã©ã†ã ã‚ã†ã‹?
è¤‡è£½ãªã—ã®ã‚‚ã®ã‚ˆã‚Šã‚‚å„ªå…ˆã—ã¦ã€ã“ã®è¡¨ç¾ã‚’ä½¿ã†ã ã‚ã†ãªã€ã¨ã„ã†ã‚ˆã†ãªå¿œç”¨ãŒã€ã‚ã‚‹ã ã‚ã†ã‹?
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_Temp_244"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_244">Sets as ordered lists</a></h4>
<h4 class="trans" lang="ja">é †åºä»˜ã‘ãƒªã‚¹ãƒˆã¨ã—ã¦ã®é›†åˆ</h4>

<p class="orig" lang="en">
<a name="%_idx_2124"></a><a name="%_idx_2126"></a>
One way to speed up our set operations is to change the representation
so that the set elements are listed in increasing order.  To do this,
we need some way to compare two objects so that we can say which is
bigger.  For example, we could compare symbols lexicographically, or
we could agree on some method for assigning a unique number to an
object and then compare the elements by comparing the corresponding
numbers.  To keep our discussion simple, we will consider only the
case where the set elements are numbers, so that we can compare
elements using <tt>&gt;</tt> and <tt>&lt;</tt>.  We will represent a set of
numbers by listing its elements in increasing order.  Whereas our
first representation above allowed us to represent the set
{1,3,6,10} by listing the elements in any order, our new
representation allows only the list <tt>(1 3 6 10)</tt>.</p>

<p class="trans" lang="ja">
ç§ãŸã¡ã®é›†åˆæ¼”ç®—ã‚’é«˜é€ŸåŒ–ã™ã‚‹ãŸã‚ã®ä¸€ã¤ã®æ–¹æ³•ã¯ã€é›†åˆã®è¦ç´ ãŒæ˜‡é †ã«ãƒªã‚¹ãƒˆã•ã‚Œã‚‹ã‚ˆã†ã«ã€è¡¨ç¾ã‚’å¤‰ãˆã‚‹ã“ã¨ã ã€‚
ã“ã‚Œã‚’è¡Œã†ãŸã‚ã«ã¯ã€ç§ãŸã¡ã«ã¯ã€äºŒã¤ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã†ã¡ã®ã©ã¡ã‚‰ãŒå¤§ãã„ã®ã‹ã‚’è¨€ãˆã‚‹ã‚ˆã†ã«ã€ãã‚Œã‚‰ã‚’æ¯”ã¹ã‚‹ãŸã‚ã®ä½•ã‚‰ã‹ã®æ–¹æ³•ãŒå¿…è¦ã ã€‚
ãŸã¨ãˆã°ã€è¨˜å·åŒå£«ã‚’è¾æ›¸é †ã§æ¯”ã¹ã‚‹ã“ã¨ãŒã§ãã‚‹ã ã‚ã†ã—ã€ã‚ã‚‹ã„ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦ä¸€æ„ãªæ•°ã‚’å‰²ã‚Šã‚ã¦ã‚‹ãŸã‚ã®ä½•ã‚‰ã‹ã®æ–¹æ³•ã«åŒæ„ã—ã¦ã€è¦ç´ åŒå£«ã‚’ã€å¯¾å¿œã™ã‚‹æ•°åŒå£«ã‚’æ¯”è¼ƒã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€æ¯”è¼ƒã™ã‚‹ã“ã¨ã‚‚ã§ãã‚‹ã ã‚ã†ã€‚
è­°è«–ã‚’ç°¡æ½”ã«ä¿ã£ã¦ãŠããŸã‚ã«ã€é›†åˆã®è¦ç´ ãŒæ•°ã§ã‚ã‚‹ã‚ˆã†ãªå ´åˆã®ã¿ã‚’è€ƒãˆã‚‹ã“ã¨ã«ã—ã‚ˆã†â€”â€”ãã†ã™ã‚Œã°ã€<tt>&gt;</tt> ã¨ <tt>&lt;</tt> ã‚’ç”¨ã„ã¦ã€è¦ç´ åŒå£«ã‚’æ¯”è¼ƒã§ãã‚‹ã€‚
æ•°ã®é›†åˆã‚’ã€ãã®è¦ç´ ã‚’æ˜‡é †ã§ãƒªã‚¹ãƒˆåŒ–ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€è¡¨ç¾ã™ã‚‹ã“ã¨ã«ã—ã‚ˆã†ã€‚
<span class="math">{1,3,6,10}</span>
ã¨ã„ã†é›†åˆã‚’ã€ã©ã®ã‚ˆã†ãªé †åºã§è¦ç´ ã‚’ãƒªã‚¹ãƒˆåŒ–ã™ã‚‹ã“ã¨ã§è¡¨ç¾ã—ã¦ã‚‚ã€ä¸Šè¨˜ã®æœ€åˆã®è¡¨ç¾ã§ã¯è¨±ã•ã‚ŒãŸã‚ã‘ã ãŒã€ç§ãŸã¡ã®æ–°ãŸãªè¡¨ç¾ã§ã¯ã€<tt>(1 3 6 10)</tt> ã¨ã„ã†ãƒªã‚¹ãƒˆã®ã¿ãŒè¨±ã•ã‚Œã‚‹ã€‚
</p>

<p class="orig" lang="en">
One advantage of ordering shows up in <tt>element-of-set?</tt>: In
checking for the presence of an item, we no longer have to scan the
entire set.  If we reach a set element that is larger than the item we
are looking for, then we know that the item is not in the set:
</p>

<p class="trans" lang="ja">
é †åºã¥ã‘ã®åˆ©ç‚¹ã®ä¸€ã¤ã¯ã€<tt>element-of-set?</tt> ã«ãŠã„ã¦ç¾ã‚Œã‚‹ã€‚
ã‚ã‚‹é …ç›®ãŒå­˜åœ¨ã™ã‚‹ã‹ã‚’èª¿ã¹ã‚‹éš›ã«ã€é›†åˆå…¨ä½“ã‚’èµ°æŸ»ã™ã‚‹å¿…è¦ã¯ã€ã‚‚ã¯ã‚„ã€ãªã„ã®ã ã€‚
ã‚‚ã—ã€æ¢ã—ã¦ã„ã‚‹é …ç›®ã‚ˆã‚Šã‚‚å¤§ããªé›†åˆè¦ç´ ã«ãŸã©ã‚Šç€ã„ãŸã‚‰ã€ãã®é …ç›®ãŒãã®é›†åˆã®ä¸­ã«ã¯ãªã„ã“ã¨ãŒåˆ†ã‹ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_2128"></a>(define (element-of-set? x set)
  (cond ((null? set) false)
        ((= x (car set)) true)
        ((&lt; x (car set)) false)
        (else (element-of-set? x (cdr set)))))
</p>

<p class="orig" lang="en">
How many steps does this save?  In the worst case, the item we are
looking for may be the largest one in the set, so the number of steps
is the same as for the unordered representation.  On the other hand,
if we search for items of many different sizes we can expect that
sometimes we will be able to stop searching at a point near the
beginning of the list and that other times we will still need to
examine most of the list.  On the average we should expect to have to
examine about half of the items in the set.  Thus, the average
number of steps required will be about <em>n</em>/2.
This is still <img src="book-Z-G-D-3.gif" border="0">(<em>n</em>) growth, but
it does save us, on the average, a factor of 2 in number of steps over the
previous implementation.</p>

<p class="trans" lang="ja">
ã“ã‚Œã«ã‚ˆã£ã¦ã€ã©ã‚Œãã‚‰ã„å¤šãã®ã‚¹ãƒ†ãƒƒãƒ—ã‚’ç¯€ç´„ã§ãã‚‹ã ã‚ã†?
æœ€æ‚ªã®å ´åˆã§ã¯ã€æ¢ã—ã¦ã„ã‚‹é …ç›®ãŒã€ãã®é›†åˆã®ä¸­ã§æœ€å¤§ã®ã‚‚ã®ã‹ã‚‚ã—ã‚Œãšã€ã™ã‚‹ã¨ã€ã‚¹ãƒ†ãƒƒãƒ–æ•°ã¯ã€é †åºã¥ã‘ã—ã¦ã„ãªã„è¡¨ç¾ã®ã¨ãã¨åŒã˜ã§ã‚ã‚‹ã€‚
ä»–æ–¹ã€ã‚‚ã—å¤šãã®ç•°ãªã‚‹å¤§ãã•ã®é …ç›®ã‚’æ¢ã™ãªã‚‰ã€ç§ãŸã¡ã¯ã€ã¨ãã«ã¯ãƒªã‚¹ãƒˆã®å§‹ã‚ã®è¿‘ãã®å ´æ‰€ã§æ¢ç´¢ã‚’æ­¢ã‚ã‚‹ã“ã¨ãŒã§ãã‚‹ã ã‚ã†ã€ã¨äºˆæƒ³ã§ãã‚‹ã—ã€ã»ã‹ã®å ´åˆã«ã¯ã‚„ã¯ã‚Šãƒªã‚¹ãƒˆã®ã»ã¨ã‚“ã©ã‚’æ¤œæŸ»ã›ã­ã°ãªã‚‰ãªã„ã ã‚ã†ã€ã¨ã‚‚äºˆæƒ³ã§ãã‚‹ã€‚
å¹³å‡ã¨ã—ã¦ã¯ã€é›†åˆå†…ã®ç´„åŠåˆ†ã®é …ç›®ã‚’æ¤œæŸ»ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€ã¨äºˆæƒ³ã™ã¹ãã§ã‚ã‚‹ã€‚
ã‚ˆã£ã¦ã€å¹³å‡å¿…è¦ã‚¹ãƒ†ãƒƒãƒ—æ•°ã¯ã€ãŠã‚ˆãã€<em class="en">n</em>/2 ã«ãªã‚‹ã ã‚ã†ã€‚
ã“ã‚Œã¯ã€ä¾ç„¶ã¨ã—ã¦ &Theta;(<em class="en">n</em>) ã®å¢—å¤§ã§ã¯ã‚ã‚‹ãŒã€å¹³å‡çš„ã«ã¯ã€ä»¥å‰ã®å®Ÿè£…ã«å¯¾ã—ã¦ã‚¹ãƒ†ãƒƒãƒ—æ•°ã®2åˆ†ã®1ã‚’çœã„ã¦ãã‚Œã‚‹ã®ã ã€‚
</p>

<p class="orig" lang="en">
We obtain a more impressive speedup with <tt>intersection-set</tt>.  In
the unordered representation this operation required
<img src="book-Z-G-D-3.gif" border="0">(<em>n</em><sup>2</sup>) steps, because we performed a complete scan of <tt>set2</tt> for
each element of <tt>set1</tt>.  But with the ordered representation, we
can use a more clever method.  Begin by comparing the initial
elements, <tt>x1</tt> and <tt>x2</tt>, of the two sets.  If <tt>x1</tt>
equals <tt>x2</tt>, then that gives an element of the intersection, and
the rest of the intersection is the intersection of the <tt>cdr</tt>s of
the two sets.  Suppose, however, that <tt>x1</tt> is less than <tt>x2</tt>.
Since <tt>x2</tt> is the smallest element in <tt>set2</tt>, we can
immediately conclude that <tt>x1</tt> cannot appear anywhere in <tt>set2</tt> and hence is not in the intersection.  Hence, the intersection
is equal to the intersection of <tt>set2</tt> with the <tt>cdr</tt> of <tt>set1</tt>.  Similarly, if <tt>x2</tt> is less than <tt>x1</tt>, then the
intersection is given by the intersection of <tt>set1</tt> with the <tt>cdr</tt> of <tt>set2</tt>.  Here is the procedure:
</p>

<p class="trans" lang="ja">
<tt>intersection-set</tt> ã«ã¤ã„ã¦ã¯ã€ã‚ˆã‚Šå°è±¡æ·±ã„é«˜é€ŸåŒ–ãŒé”æˆã•ã‚Œã‚‹ã€‚
é †åºã¥ã‘ã•ã‚Œã¦ã„ãªã„è¡¨ç¾ã§ã¯ã€ã“ã®æ¼”ç®—ã¯ &Theta;(<em class="en">n</em><sup>2</sup>) å›ã®ã‚¹ãƒ†ãƒƒãƒ—ã‚’è¦ã—ãŸã€‚ãªãœãªã‚‰ã€<tt>set1</tt> ã®å„è¦ç´ ã«å¯¾ã—ã¦ <tt>set2</tt> ã®å®Œå…¨ãªèµ°æŸ»ã‚’å®Ÿè¡Œã—ãŸã‹ã‚‰ã§ã‚ã‚‹ã€‚
ã—ã‹ã—ã€é †åºã¥ã‘ã•ã‚ŒãŸè¡¨ç¾ã§ã¯ã€ã‚ˆã‚Šè³¢ã„æ–¹æ³•ãŒä½¿ãˆã‚‹ã€‚
äºŒã¤ã®é›†åˆã®æœ€åˆã®è¦ç´ åŒå£«â€”â€”<tt>x1</tt> ã¨ <tt>x2</tt>â€”â€”ã‚’æ¯”ã¹ã‚‹ã“ã¨ã‹ã‚‰ã€å§‹ã‚ã‚ˆã†ã€‚
ã‚‚ã—ã€<tt>x1</tt> ãŒ <tt>x2</tt> ã«ç­‰ã—ã‘ã‚Œã°ã€ãã‚ŒãŒç©é›†åˆã®è¦ç´ ã‚’ä¸ãˆã¦ãŠã‚Šã€ã“ã®ç©é›†åˆã®æ®‹ã‚Šã¯ã€äºŒã¤ã®é›†åˆã® <tt>cdr</tt> åŒå£«ã®ç©é›†åˆã§ã‚ã‚‹ã€‚
ãã®ä¸€æ–¹ã§ã€<tt>x1</tt> ãŒ <tt>x2</tt> ã‚ˆã‚Šå°ã•ã„ã€ã¨ä»®å®šã—ã¦ã¿ã‚ˆã†ã€‚
<tt>x2</tt> ã¯ <tt>set2</tt> ã®ã†ã¡ã§æœ€å°ã®è¦ç´ ãªã®ã§ã€ç§ãŸã¡ã¯ç›´ã¡ã«ã€<tt>x1</tt> ã¯<tt>set2</tt> ã®ã©ã“ã«ã‚‚ç¾ã‚Œã‚‹ã¯ãšãŒãªãã€ã—ãŸãŒã£ã¦ã€ç©é›†åˆã«å«ã¾ã‚Œãªã„ã€ã¨çµè«–ã¥ã‘ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
ã‚ˆã£ã¦ã€ãã®ç©é›†åˆã¯ã€<tt>set2</tt> ã¨ã€<tt>set1</tt> ã® <tt>cdr</tt> ã¨ã®ç©é›†åˆã«ç­‰ã—ã„ã€‚
åŒæ§˜ã«ã€ã‚‚ã—ã€<tt>x2</tt> ãŒ <tt>x1</tt> ã‚ˆã‚Šå°ã•ã‘ã‚Œã°ã€ãã®ç©é›†åˆã¯ã€<tt>set1</tt> ã¨ã€<tt>set2</tt> ã® <tt>cdr</tt> ã¨ã®ç©é›†åˆã«ã‚ˆã‚Šä¸ãˆã‚‰ã‚Œã‚‹ã€‚
ã“ã“ã«æ‰‹ç¶šãã‚’ç¤ºã™ã€‚
</p>

<p class="lisp"><a name="%_idx_2130"></a>(define (intersection-set set1 set2)
  (if (or (null? set1) (null? set2))
      '()    
      (let ((x1 (car set1)) (x2 (car set2)))
        (cond ((= x1 x2)
               (cons x1
                     (intersection-set (cdr set1)
                                       (cdr set2))))
              ((&lt; x1 x2)
               (intersection-set (cdr set1) set2))
              ((&lt; x2 x1)
               (intersection-set set1 (cdr set2)))))))
</p>

<p class="orig" lang="en">
To estimate the number of steps required by this process, observe that at each
step we reduce the intersection problem to computing intersections of
smaller sets -- removing the first element from <tt>set1</tt> or <tt>set2</tt> or both.  Thus, the number of steps required is at most the sum
of the sizes of <tt>set1</tt> and <tt>set2</tt>, rather than the product of
the sizes as with the unordered representation.  This is <img src="book-Z-G-D-3.gif" border="0">(<em>n</em>) growth
rather than <img src="book-Z-G-D-3.gif" border="0">(<em>n</em><sup>2</sup>) -- a considerable speedup, even for sets of
moderate size.</p>

<p class="trans" lang="ja">
ã“ã®ãƒ—ãƒ­ã‚»ã‚¹ãŒå¿…è¦ã¨ã™ã‚‹ã‚¹ãƒ†ãƒƒãƒ—ã®æ•°ã‚’è¦‹ç©ã‚‚ã‚‹ãŸã‚ã«æ°—ã¥ã„ã¦ã»ã—ã„ã®ã¯ã€ç©é›†åˆã®å•é¡Œã‚’ã€å„ã‚¹ãƒ†ãƒƒãƒ—ã§ã€ã‚ˆã‚Šå°ã•ãªé›†åˆåŒå£«ã®ç©é›†åˆã‚’æ±‚ã‚ã‚‹ã“ã¨ã¸ã¨é‚„å…ƒã—ã¦ã„ã‚‹â€”â€”<tt>set1</tt> ã‚‚ã—ãã¯ <tt>set2</tt> ã¾ãŸã¯ãã®åŒæ–¹ã‹ã‚‰ã€æœ€åˆã®è¦ç´ ã‚’å–ã‚Šé™¤ã„ã¦ã„ã‚‹â€”â€”ã¨ã„ã†ã“ã¨ã§ã‚ã‚‹ã€‚
ã‚ˆã£ã¦ã€å¿…è¦ãªã‚¹ãƒ†ãƒƒãƒ—ã®æ•°ã¯ã€ã›ã„ãœã„å¤šãã¦ã‚‚ <tt>set1</tt> ã¨ <tt>size2</tt> ã®å¤§ãã•åŒå£«ã®å’Œã§ã‚ã‚‹â€”â€”é †åºã¥ã‘ã‚‰ã‚Œã¦ã„ãªã„è¡¨ç¾ã®ã¨ãã®ã‚ˆã†ãªã€å¤§ãã•åŒå£«ã®ç©ã§ã¯ãªãã€‚
ã“ã‚Œã¯ã€&Theta;(<em class="en">n</em><sup>2</sup>) ã§ã¯ãªã &Theta;(<em class="en">n</em>) ã®å¢—å¤§ã§ã‚ã‚‹â€”â€”ã¤ã¾ã‚Šã€ã»ã©ã»ã©ã®å¤§ãã•ã®é›†åˆã«å¯¾ã—ã¦ã§ã•ãˆã€ã‹ãªã‚Šã®é«˜é€ŸåŒ–ã ã€‚
</p>

<p class="orig" lang="en">
<a name="%_thm_2.61"></a>
<b>Exercise 2.61.</b>  Give an implementation of <a name="%_idx_2132"></a><tt>adjoin-set</tt> using the ordered
representation.  By analogy with <tt>element-of-set?</tt> show how to
take advantage of the ordering to produce a procedure that requires on
the average about half as many steps as with the unordered
representation.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.61.</b> é †åºã¥ã‘ã•ã‚ŒãŸè¡¨ç¾ã‚’ä½¿ã£ã¦ã€<tt>adjoin-set</tt> ã®å®Ÿè£…ã‚’ç¤ºã›ã€‚
é †åºã¥ã‘ã‚‰ã‚Œã¦ã„ãªã„è¡¨ç¾ã®ã¨ãã®ç´„åŠåˆ†ã®ã‚¹ãƒ†ãƒƒãƒ—ã—ã‹å¹³å‡çš„ã«ã¯å¿…è¦ã¨ã—ãªã„ã‚ˆã†ãªæ‰‹ç¶šãã‚’ä½œã‚Šå‡ºã™ãŸã‚ã«ã€ã©ã®ã‚ˆã†ã«é †åºã¥ã‘ã‚’åˆ©ç”¨ã™ã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’ã€<tt>element-of-set?</tt> ã¨ã®é¡ä¼¼ã«ã‚ˆã‚Šç¤ºã›ã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_2.62"></a>
<b>Exercise 2.62.</b>  Give a <img src="book-Z-G-D-3.gif" border="0">(<em>n</em>) implementation of <a name="%_idx_2134"></a><tt>union-set</tt> for sets
represented as ordered lists.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.62.</b> é †åºã¥ã‘ã‚‰ã‚ŒãŸãƒªã‚¹ãƒˆã¨ã—ã¦è¡¨ç¾ã•ã‚ŒãŸé›†åˆã«å¯¾ã™ã‚‹ã€<tt>union-set</tt> ã® &Theta;(<em class="en">n</em>) ã®å®Ÿè£…ã‚’ä¸ãˆã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_Temp_247"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_247">Sets as binary trees</a></h4>
<h4 class="trans" lang="ja">äºŒåˆ†æœ¨ã¨ã—ã¦ã®é›†åˆ</h4>

<p class="orig" lang="en">
<a name="%_idx_2136"></a><a name="%_idx_2138"></a><a name="%_idx_2140"></a><a name="%_idx_2142"></a><a name="%_idx_2144"></a><a name="%_idx_2146"></a>
We can do better than the ordered-list representation by arranging the
set elements in the form of a tree.  Each node of the tree holds one
element of the set, called the ``entry'' at that node, and a link to
each of two other (possibly empty) nodes.  The ``left'' link points to
elements smaller than the one at the node, and the ``right'' link to
elements greater than the one at the node.
Figure <a href="#%_fig_2.16">2.16</a> shows some trees that represent the set
{1,3,5,7,9,11}.  The same set may be represented by a tree in a
number of different ways.  The only thing we require for a valid
representation is that all elements in the left subtree be smaller
than the node entry and that all elements in the right subtree be
larger.</p>

<p class="trans" lang="ja">
é›†åˆè¦ç´ ã‚’æœ¨ã®å½¢ã«é…ç½®ã™ã‚‹ã“ã¨ã§ã€é †åºã¥ã‘ãƒªã‚¹ãƒˆè¡¨ç¾ã®ã¨ãã‚ˆã‚Šã‚‚ã€ã†ã¾ãã‚„ã‚Œã‚‹ã€‚
æœ¨ã®å„ãƒãƒ¼ãƒ‰ã¯ã€é›†åˆã®ä¸€ã¤ã®è¦ç´ â€”â€”ãã®ãƒãƒ¼ãƒ‰ã«ãŠã‘ã‚‹ã€Œã‚¨ãƒ³ãƒˆãƒªã€ã¨å‘¼ã°ã‚Œã‚‹â€”â€”ã¨ã€ä»–ã®äºŒã¤ã® (ç©ºã®å¯èƒ½æ€§ã‚‚ã‚ã‚‹) ãƒãƒ¼ãƒ‰ã®å„ã€…ã¸ã®ãƒªãƒ³ã‚¯ã¨ã‚’ã€ä¿æŒã™ã‚‹ã€‚
ã€Œå·¦ã€ã®ãƒªãƒ³ã‚¯ã¯ã€ãã®ãƒãƒ¼ãƒ‰ã®è¦ç´ ã‚ˆã‚Šå°ã•ã„è¦ç´ ã‚’æŒ‡ã—ã€ã€Œå³ã€ã®ãƒªãƒ³ã‚¯ã¯ã€ãã®ãƒãƒ¼ãƒ‰ã®è¦ç´ ã‚ˆã‚Šå¤§ãã„è¦ç´ ã‚’æŒ‡ã™ã€‚
å›³<a href="#%_fig_2.16">2.16</a>ã¯ã€
<span class="math">{1, 3, 5, 7, 9, 11}</span>
ã¨ã„ã†é›†åˆã‚’è¡¨ç¾ã™ã‚‹ã€ã„ãã¤ã‹ã®æœ¨ã‚’ç¤ºã—ã¦ã„ã‚‹ã€‚
åŒã˜é›†åˆãŒã€ã„ãã¤ã‚‚ã®ç•°ãªã‚‹ã‚„ã‚Šæ–¹ã®æœ¨ã«ã‚ˆã£ã¦ã€è¡¨ç¾ã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã€‚
æœ‰åŠ¹ãªè¡¨ç¾ã«å¯¾ã—ã¦æ±‚ã‚ã‚‹ã“ã¨ã¯ã€ãŸã ã€å·¦ã®éƒ¨åˆ†æœ¨ã®ä¸­ã®ã™ã¹ã¦ã®è¦ç´ ãŒå½“è©²ãƒãƒ¼ãƒ‰ã®ã‚¨ãƒ³ãƒˆãƒªã‚ˆã‚Šå°ã•ã„ã“ã¨ã¨ã€å³ã®éƒ¨åˆ†æœ¨ã®ä¸­ã®ã™ã¹ã¦ã®è¦ç´ ãŒå½“è©²ãƒãƒ¼ãƒ‰ã®ã‚¨ãƒ³ãƒˆãƒªã‚ˆã‚Šå¤§ãã„ã“ã¨ã ã‘ãªã®ã ã€‚
</p>

<figure>
<a name="%_fig_2.16"></a>
<img src="ch2-Z-G-51.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 2.16:</b>  Various binary trees that represent the set { 1,3,5,7,9,11 }.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³2.16:</b> {1, 3, 5, 7, 9, 11} ã¨ã„ã†é›†åˆã‚’è¡¨ç¾ã™ã‚‹æ§˜ã€…ãªäºŒåˆ†æœ¨</figcaption>
</figure>

<p class="orig" lang="en">
The advantage of the tree representation is this: Suppose we want to
check whether a number <em>x</em> is contained in a set.  We begin by
comparing <em>x</em> with the entry in the top node.  If <em>x</em> is less than
this, we know that we need only search the left subtree; if <em>x</em> is
greater, we need only search the right subtree.  Now, if the tree is
``balanced,'' each of these subtrees will be about half the size of
the original.  Thus, in one step we have reduced the problem of
searching a tree of size <em>n</em> to searching a tree of size <em>n</em>/2.  Since
the size of the tree is halved at each step, we should expect that the
number of steps needed to search a tree of size <em>n</em> grows as <img src="book-Z-G-D-3.gif" border="0">(<tt>log</tt>
<em>n</em>).<a name="call_footnote_Temp_248" href="#footnote_Temp_248"><sup><small>38</small></sup></a> For large sets, this will
be a significant speedup over the previous representations.</p>

<p class="trans" lang="ja">
æœ¨ã®è¡¨ç¾ã®åˆ©ç‚¹ã¯ä»¥ä¸‹ã®ã¨ãŠã‚Šã ã€‚
<em class="en">x</em> ã¨ã„ã†æ•°ãŒã€ã‚ã‚‹é›†åˆã®ä¸­ã«å«ã¾ã‚Œã‚‹ã‹ã©ã†ã‹ã‚’æ¤œæŸ»ã—ãŸã„ã®ã ã¨ã—ã‚ˆã†ã€‚
<em class="en">x</em> ã‚’ä¸€ç•ªä¸Šã®ãƒãƒ¼ãƒ‰ã®ã‚¨ãƒ³ãƒˆãƒªã¨æ¯”ã¹ã‚‹ã“ã¨ã‹ã‚‰å§‹ã‚ã‚‹ã€‚
ã‚‚ã—ã€<em class="en">x</em> ãŒã“ã‚Œã‚ˆã‚Šå°ã•ã‘ã‚Œã°ã€å·¦ã®éƒ¨åˆ†æœ¨ã‚’æ¢ã™ã ã‘ã§ã‚ˆã„ã€ã¨åˆ†ã‹ã‚‹ã€‚
ã‚‚ã—ã€<em class="en">x</em> ãŒã“ã‚Œã‚ˆã‚Šå¤§ãã‘ã‚Œã°ã€å³ã®éƒ¨åˆ†æœ¨ã‚’æ¢ã™ã ã‘ã§ã‚ˆã„ã€‚
ã•ã¦ã€ã‚‚ã—æœ¨ãŒã€Œå‡è¡¡ãŒã¨ã‚Œã¦ã„ã‚‹ã€ãªã‚‰ã€ã“ã‚Œã‚‰ã®éƒ¨åˆ†æœ¨ã®å„ã€…ã¯ã€å…ƒã®æœ¨ã®ç´„åŠåˆ†ã®å¤§ãã•ã§ã‚ã‚ã†ã€‚
ã“ã†ã—ã¦ã€å¤§ãã•ãŒ <em class="en">n</em> ã®æœ¨ã‚’æ¢ç´¢ã™ã‚‹ã¨ã„ã†å•é¡Œã‚’ã€å¤§ãã•ãŒ <em class="en">n</em>/2 ã®æœ¨ã‚’æ¢ç´¢ã™ã‚‹ã¨ã„ã†å•é¡Œã¸ã¨ã€ä¸€ã¤ã®ã‚¹ãƒ†ãƒƒãƒ—ã§é‚„å…ƒã—ãŸã‚ã‘ã ã€‚
å„ã‚¹ãƒ†ãƒƒãƒ—ã§æœ¨ã®å¤§ãã•ãŒåŠåˆ†ã«ãªã‚‹ãŸã‚ã€ç§ãŸã¡ã¯ã€å¤§ãã•ãŒ <em class="en">n</em> ã®æœ¨ã‚’æ¢ç´¢ã™ã‚‹ã®ã«å¿…è¦ãªã‚¹ãƒ†ãƒƒãƒ—ã®æ•°ã¯ &Theta;(<tt>log</tt><em class="en">n</em>) ã§å¢—å¤§ã™ã‚‹ã€ã¨äºˆæƒ³ã™ã‚‹ã¯ãšã <a href="#footnote_Temp_248"><sup><small>38</small></sup></a>ã€‚
ã“ã®ã“ã¨ã¯ã€å¤§ããªé›†åˆã«å¯¾ã—ã¦ã¯ã€ä»¥å‰ã®è¡¨ç¾ã¨æ¯”ã¹ã¦é¡•è‘—ãªé«˜é€ŸåŒ–ã¨ãªã‚‹ã ã‚ã†ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_2150"></a>We can represent trees by using lists.  Each node will be a list of
three items: the entry at the node, the left subtree, and the right
subtree.  A left or a right subtree of the empty list will indicate
that there is no subtree connected there.  We can describe this
representation by the following procedures:<a name="call_footnote_Temp_249" href="#footnote_Temp_249"><sup><small>39</small></sup></a>
</p>

<p class="trans" lang="ja">
ç§ãŸã¡ã¯ã€ãƒªã‚¹ãƒˆã‚’ä½¿ã£ã¦æœ¨ã‚’è¡¨ç¾ã§ãã‚‹ã€‚
å„ãƒãƒ¼ãƒ‰ã¯ã€ä¸‰ã¤ã®é …ç›®â€”â€”ã¤ã¾ã‚Šã€ãã®ãƒãƒ¼ãƒ‰ã®ã‚¨ãƒ³ãƒˆãƒªã¨ã€å·¦ã®éƒ¨åˆ†æœ¨ã¨ã€å³ã®éƒ¨åˆ†æœ¨â€”â€”ã®ãƒªã‚¹ãƒˆã ã‚ã†ã€‚
ç©ºãƒªã‚¹ãƒˆã§ã‚ã‚‹ã‚ˆã†ãªã€å·¦ã¾ãŸã¯å³ã®éƒ¨åˆ†æœ¨ã¯ã€ãã“ã«ã¤ãªãŒã£ãŸéƒ¨åˆ†æœ¨ãŒãªã„ã€ã¨ã„ã†ã“ã¨ã‚’ç¤ºã™ã ã‚ã†ã€‚
ä»¥ä¸‹ã®æ‰‹ç¶šãã«ã‚ˆã‚Šã€ã“ã®è¡¨ç¾ã‚’è¨˜è¿°ã§ãã‚‹<a href="#footnote_Temp_249"><sup><small>39</small></sup></a>ã€‚
</p>

<p class="lisp"><a name="%_idx_2152"></a>(define (entry tree) (car tree))
<a name="%_idx_2154"></a>(define (left-branch tree) (cadr tree))
<a name="%_idx_2156"></a>(define (right-branch tree) (caddr tree))
<a name="%_idx_2158"></a>(define (make-tree entry left right)
  (list entry left right))
</p>

<p class="orig" lang="en">
Now we can write the <tt>element-of-set?</tt> procedure using the strategy
described above:
</p>

<p class="trans" lang="ja">
ã•ã¦ä»Šã‚„ã€ä¸Šè¨˜ã®æˆ¦ç•¥ã‚’ä½¿ã£ã¦ã€<tt>element-of-set?</tt> ã®æ‰‹ç¶šãã‚’æ›¸ãã“ã¨ãŒå¯èƒ½ã ã€‚
</p>

<p class="lisp"><a name="%_idx_2160"></a>(define (element-of-set? x set)
  (cond ((null? set) false)
        ((= x (entry set)) true)
        ((&lt; x (entry set))
         (element-of-set? x (left-branch set)))
        ((&gt; x (entry set))
         (element-of-set? x (right-branch set)))))
</p></p>

<p class="orig" lang="en">
Adjoining an item to a set is implemented similarly and also requires
<img src="book-Z-G-D-3.gif" border="0">(<tt>log</tt> <em>n</em>) steps.  To adjoin an item <tt>x</tt>, we compare <tt>x</tt> with
the node entry to determine whether <tt>x</tt> should be added to the
right or to the left branch, and having adjoined <tt>x</tt> to the
appropriate branch we piece this newly constructed branch together
with the original entry and the other branch.  If <tt>x</tt> is equal to
the entry, we just return the node.  If we are asked to adjoin
<tt>x</tt> to an empty tree, we generate a tree that has <tt>x</tt> as the
entry and empty right and left branches.  Here is the procedure:
</p>

<p class="trans" lang="ja">
é›†åˆã¸ã®é …ç›®ã®è¿½åŠ ã‚‚ã€åŒæ§˜ã«å®Ÿè£…ã•ã‚Œã€ã“ã‚Œã‚‚ &Theta;(<tt>log</tt> <em class="en">n</em>) ã®ã‚¹ãƒ†ãƒƒãƒ—ã‚’è¦ã™ã‚‹ã€‚
<tt>x</tt> ã¨ã„ã†é …ç›®ã‚’è¿½åŠ ã™ã‚‹ãŸã‚ã«ã€ç§ãŸã¡ã¯ã€<tt>x</tt> ã‚’ãƒãƒ¼ãƒ‰ã®ã‚¨ãƒ³ãƒˆãƒªã¨æ¯”ã¹ã¦ã€<tt>x</tt> ã‚’å³ã®åˆ†å²ã¸è¿½åŠ ã™ã¹ãã‹ã€ãã‚Œã¨ã‚‚å·¦ã®åˆ†å²ã¸è¿½åŠ ã™ã¹ãã‹ã‚’åˆ¤å®šã—ã€ãã—ã¦ã€<tt>x</tt> ã‚’é©åˆ‡ãªåˆ†å²ã¸ã¨è¿½åŠ ã—ãŸã‚‰ã€ã“ã®æ–°ãŸã«æ§‹æˆã•ã‚ŒãŸåˆ†å²ã‚’ã€å…ƒã®ã‚¨ãƒ³ãƒˆãƒªãŠã‚ˆã³ä»–æ–¹ã®åˆ†å²ã¨ã€ã¾ã¨ã‚ã‚‹ã€‚
ã‚‚ã—ã€<tt>x</tt> ãŒå½“è©²ã‚¨ãƒ³ãƒˆãƒªã¨ç­‰ã—ã‘ã‚Œã°ã€ãŸã ãã®ãƒãƒ¼ãƒ‰ã‚’è¿”ã™ã ã‘ã ã€‚
ã‚‚ã—ã€<tt>x</tt> ã‚’ç©ºã®æœ¨ã«è¿½åŠ ã™ã‚‹ã‚ˆã†ã«æ±‚ã‚ã‚‰ã‚ŒãŸã‚‰ã€<tt>x</tt> ã‚’ã‚¨ãƒ³ãƒˆãƒªã¨ã—ã¦æœ‰ã—ã€ã‹ã¤ã€ç©ºã®å·¦å³ã®åˆ†å²ã‚’æœ‰ã™ã‚‹ã‚ˆã†ãªæœ¨ã‚’ã€ç”Ÿæˆã™ã‚‹ã€‚
ã“ã“ã«æ‰‹ç¶šãã‚’ç¤ºã™ã€‚
</p>

<p class="lisp"><a name="%_idx_2162"></a>(define (adjoin-set x set)
  (cond ((null? set) (make-tree x '() '()))
        ((= x (entry set)) set)
        ((&lt; x (entry set))
         (make-tree (entry set) 
                    (adjoin-set x (left-branch set))
                    (right-branch set)))
        ((&gt; x (entry set))
         (make-tree (entry set)
                    (left-branch set)
                    (adjoin-set x (right-branch set))))))
</p>

<p class="orig" lang="en">
The above claim that searching the tree can be performed in a logarithmic
number of steps
rests on the assumption that the tree is <a name="%_idx_2164"></a><a name="%_idx_2166"></a>``balanced,'' i.e., that the
left and the right subtree of every tree have approximately the same
number of elements, so that each subtree contains about half the
elements of its parent.  But how can we be certain that the trees we
construct will be balanced?  Even if we start with a balanced tree,
adding elements with <tt>adjoin-set</tt> may produce an unbalanced
result.  Since the position of a newly adjoined element depends on how
the element compares with the items already in the set, we can expect
that if we add elements ``randomly'' the tree will tend to be balanced
on the average.  But this is not a guarantee.  For example, if we
start with an empty set and adjoin the numbers 1 through 7 in sequence
we end up with the highly unbalanced tree shown in
figure <a href="#%_fig_2.17">2.17</a>.  In this tree all the left subtrees
are empty, so it has no advantage over a simple ordered list.  One
way to solve this problem is to define an operation that transforms an
arbitrary tree into a balanced tree with the same elements.  Then we
can perform this transformation after every few <tt>adjoin-set</tt>
operations to keep our set in balance.  There are also other ways to
solve this problem, most of which involve designing new data
structures for which searching and insertion both can be done in
<img src="book-Z-G-D-3.gif" border="0">(<tt>log</tt> <em>n</em>) steps.<a name="call_footnote_Temp_250" href="#footnote_Temp_250"><sup><small>40</small></sup></a></p>

<p class="trans" lang="ja">
æœ¨ã®æ¢ç´¢ãŒå¯¾æ•°çš„ãªã‚¹ãƒ†ãƒƒãƒ—æ•°ã§å®Ÿè¡Œå¯èƒ½ã ã€ã¨ã„ã†ä¸Šè¨˜ã®ä¸»å¼µã¯ã€æœ¨ãŒã€Œå‡è¡¡ã—ã¦ã„ã‚‹ã€â€”â€”ã¤ã¾ã‚Šã€ã©ã®æœ¨ã®å·¦ã¨å³ã®éƒ¨åˆ†æœ¨ã‚‚ã€ãŠãŠã‚ˆãã¯åŒã˜æ•°ã®è¦ç´ ã‚’æœ‰ã—ã¦ãŠã‚Šã€ã‚ˆã£ã¦ã€å„éƒ¨åˆ†æœ¨ã¯è‡ªèº«ã®è¦ªã®ç´„åŠåˆ†ã®è¦ç´ ã‚’å«ã‚€â€”â€”ã¨ã„ã†ä»®èª¬ã«é ¼ã£ã¦ã„ã‚‹ã€‚
ã—ã‹ã—ã€ç§ãŸã¡ãŒæ§‹ç¯‰ã™ã‚‹æœ¨ã¯å‡è¡¡ã—ã¦ã„ã‚‹ã ã‚ã†ã€ã¨ã„ã†ã“ã¨ã‚’ã€ã©ã†ã—ãŸã‚‰ç¢ºã‹ãªã“ã¨ã«ã§ãã‚‹ã®ã‹?
ãŸã¨ãˆå‡è¡¡ã®ã¨ã‚ŒãŸæœ¨ã‹ã‚‰å§‹ã‚ã‚‹ã¨ã—ã¦ã‚‚ã€<tt>adjoin-set</tt> ã‚’ä½¿ã£ã¦è¦ç´ ã‚’è¶³ã—ã¦ã„ãã¨ã€ä¸å‡è¡¡ãªçµæœãŒç”Ÿã¿å‡ºã•ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚
æ–°ãŸã«è¿½åŠ ã•ã‚Œã‚‹è¦ç´ ã®ä½ç½®ã¯ã€ãã®è¦ç´ ãŒæ—¢ã«é›†åˆå†…ã«ã‚ã‚‹é …ç›®ã¨ã©ã®ã‚ˆã†ã«æ¯”ã¹ã‚‰ã‚Œã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã«ã‹ã‹ã£ã¦ã„ã‚‹ã®ã§ã€ç§ãŸã¡ã¯ã€ã‚‚ã—è¦ç´ ã‚’ã€Œãƒ©ãƒ³ãƒ€ãƒ ã«ã€æœ¨ã«è¿½åŠ ã—ã¦ã„ã£ãŸã‚‰ã€å¹³å‡çš„ã«ã¯æœ¨ãŒå‡è¡¡ã™ã‚‹å‚¾å‘ãŒã‚ã‚‹ã ã‚ã†ã€ã¨äºˆæƒ³ã§ãã‚‹ã€‚
ã—ã‹ã—ã“ã‚Œã¯ã€ä¿è¨¼ã•ã‚ŒãŸã“ã¨ã§ã¯ãªã„ã€‚
ãŸã¨ãˆã°ã€ã‚‚ã—ç©ºé›†åˆã‹ã‚‰å§‹ã‚ã¦ã€1ã‹ã‚‰7ã¨ã„ã†æ•°ã‚’é †ã«è¿½åŠ ã—ãŸã‚‰ã€æœ€çµ‚çš„ã«ã¯ã€å›³<a href="#%_fig_2.17">2.17</a>ã«ç¤ºã—ãŸã€ã¨ã¦ã‚‚ä¸å‡è¡¡ãªæœ¨ã«è‡³ã‚‹ã€‚
ã“ã®æœ¨ã§ã¯ã€ã™ã¹ã¦ã®å·¦éƒ¨åˆ†æœ¨ã¯ç©ºã§ã‚ã‚Šã€ã‚†ãˆã«ã€å˜ç´”ãªé †åºã¥ã‘ãƒªã‚¹ãƒˆã«å¯¾ã™ã‚‹ä½•ã®åˆ©ç‚¹ã‚‚ãªã„ã€‚
ã“ã®å•é¡Œã‚’è§£æ±ºã™ã‚‹ä¸€ã¤ã®æ–¹æ³•ã¯ã€ä»»æ„ã®æœ¨ã‚’åŒã˜è¦ç´ ã‚’æŒã£ãŸå‡è¡¡ã®ã¨ã‚ŒãŸæœ¨ã¸ã¨å¤‰å½¢ã™ã‚‹æ¼”ç®—ã‚’ã€å®šç¾©ã™ã‚‹ã“ã¨ã ã€‚
ã™ã‚‹ã¨ã€å‡è¡¡ã®ã¨ã‚ŒãŸçŠ¶æ…‹ã«é›†åˆã‚’ä¿ã¤ãŸã‚ã«ã€ç§ãŸã¡ã¯ã€æ•°å›ã® <tt>adjoin-set</tt> æ¼”ç®—ãŒæ¸ˆã‚€ãŸã³ã«ã€ã“ã®å¤‰å½¢ã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
ã“ã®å•é¡Œã‚’è§£æ±ºã™ã‚‹åˆ¥ã®æ–¹æ³•ã‚‚ã‚ã‚‹ãŒã€ãã‚Œã‚‰ã®æ–¹æ³•ã®ã»ã¨ã‚“ã©ã¯ã€æ¢ç´¢ã¨æŒ¿å…¥ãŒã©ã¡ã‚‰ã‚‚ &Theta;(<tt>log</tt> <em class="en">n</em>) ã®ã‚¹ãƒ†ãƒƒãƒ—ã§è¡Œãˆã‚‹ã‚ˆã†ãªæ–°ã—ã„ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’è¨­è¨ˆã™ã‚‹ã“ã¨ã‚’ã€ä¼´ã£ã¦ã„ã‚‹<a href="#footnote_Temp_250"><sup><small>40</small></sup></a>ã€‚
</p>

<figure>
<a name="%_fig_2.17"></a>
<img src="ch2-Z-G-52.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 2.17:</b>  Unbalanced tree produced by adjoining 1 through 7 in sequence.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³2.17:</b> 1ã‹ã‚‰7ã¾ã§ã‚’é †ã«è¿½åŠ ã™ã‚‹ã“ã¨ã§ä½œã‚Šå‡ºã•ã‚ŒãŸã€ä¸å‡è¡¡ãªæœ¨</figcaption>
</figure>

<p class="orig" lang="en">
<a name="%_thm_2.63"></a>
<b>Exercise 2.63.</b>  Each of the following two procedures converts a <a name="%_idx_2182"></a><a name="%_idx_2184"></a>binary tree to a list.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.63.</b> ä»¥ä¸‹ã®äºŒã¤ã®æ‰‹ç¶šãã®ãã‚Œãã‚Œã¯ã€äºŒåˆ†æœ¨ã‚’ãƒªã‚¹ãƒˆã«å¤‰æ›ã™ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_2186"></a>(define (tree-&gt;list-1 tree)
  (if (null? tree)
      '()
      (append (tree-&gt;list-1 (left-branch tree))
              (cons (entry tree)
                    (tree-&gt;list-1 (right-branch tree))))))
(define (tree-&gt;list-2 tree)
  (define (copy-to-list tree result-list)
    (if (null? tree)
        result-list
        (copy-to-list (left-branch tree)
                      (cons (entry tree)
                            (copy-to-list (right-branch tree)
                                          result-list)))))
  (copy-to-list tree '()))
</p>

<ol class="orig" lang="en">
<li>Do the two procedures produce the same result for every tree?  If
not, how do the results differ?  What lists do the two procedures
produce for the trees in figure <a href="#%_fig_2.16">2.16</a>?</li>
<li>Do the two procedures have the same order of growth in the number
of steps required to convert a balanced tree with <em>n</em> elements to a list?
If not, which one grows more slowly?</li>
</ol>

<ol class="trans" lang="ja">
<li>ã©ã®æœ¨ã«å¯¾ã—ã¦ã‚‚ã€äºŒã¤ã®æ‰‹ç¶šãã¯åŒã˜çµæœã‚’ç”Ÿã¿å‡ºã™ã ã‚ã†ã‹?
ã‚‚ã—ãã†ã§ãªã„ãªã‚‰ã€çµæœã¯ã©ã®ã‚ˆã†ã«ç•°ãªã‚‹ã‹?
å›³<a href="#%_fig_2.16">2.16</a>ã®æœ¨ã«å¯¾ã—ã¦ã€äºŒã¤ã®æ‰‹ç¶šãã¯ã€ã©ã†ã„ã†ãƒªã‚¹ãƒˆã‚’ä½œã‚Šå‡ºã™ã‹?</li>
<li><em class="en">n</em> å€‹ã®è¦ç´ ã‚’æŒã£ãŸå‡è¡¡æœ¨ã‚’ãƒªã‚¹ãƒˆã«å¤‰æ›ã™ã‚‹ã®ã«å¿…è¦ãªã‚¹ãƒ†ãƒƒãƒ—æ•°ã®å¢—å¤§ã®ã‚ªãƒ¼ãƒ€ã¯ã€äºŒã¤ã®æ‰‹ç¶šãã§åŒã˜ã ã‚ã†ã‹?</li>
</ol>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_2.64"></a>
<b>Exercise 2.64.</b>  <a name="%_idx_2188"></a><a name="%_idx_2190"></a>The following procedure <tt>list-&gt;tree</tt> converts an ordered list to a
balanced binary tree.  The helper procedure <tt>partial-tree</tt> takes
as arguments an integer <em>n</em> and list of at least <em>n</em> elements and
constructs a balanced tree containing the first <em>n</em> elements of the
list.  The result returned by <tt>partial-tree</tt> is a pair (formed
with <tt>cons</tt>) whose <tt>car</tt> is the constructed tree and whose
<tt>cdr</tt> is the list of elements not included in the tree.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.64.</b> ä»¥ä¸‹ã® <tt>list-&gt;tree</tt> ã¨ã„ã†æ‰‹ç¶šãã¯ã€é †åºã¥ã‘ã•ã‚ŒãŸãƒªã‚¹ãƒˆã‚’å‡è¡¡äºŒåˆ†æœ¨ã«å¤‰æ›ã™ã‚‹ã€‚
<tt>partial-tree</tt> ã¨ã„ã†ãƒ˜ãƒ«ãƒ‘æ‰‹ç¶šãã¯ã€å¼•æ•°ã¨ã—ã¦ã€<em class="en">n</em> ã¨ã„ã†æ•´æ•°ã¨ã€å°‘ãªãã¨ã‚‚ <em class="en">n</em> å€‹ã®è¦ç´ ã‹ã‚‰ãªã‚‹ãƒªã‚¹ãƒˆã¨ã‚’ã¨ã‚Šã€ãã®ãƒªã‚¹ãƒˆã®æœ€åˆã® <em class="en">n</em> å€‹ã®ãƒªã‚¹ãƒˆã‚’å«ã‚€å‡è¡¡æœ¨ã‚’æ§‹ç¯‰ã™ã‚‹ã€‚
<tt>partial-tree</tt> ãŒè¿”ã™çµæœã¯ã€(<tt>cons</tt> ã«ã‚ˆã‚Šå½¢æˆã•ã‚Œã‚‹) å¯¾ã§ã‚ã£ã¦ã€ãã® <tt>car</tt> ãŒæ§‹ç¯‰æ¸ˆã¿ã®æœ¨ã§ã‚ã‚Šã€ã‹ã¤ã€ãã® <tt>cdr</tt> ãŒãã®æœ¨ã«å«ã¾ã‚Œã¦ã„ãªã„è¦ç´ ã®ãƒªã‚¹ãƒˆã§ã‚ã‚‹ã‚ˆã†ãªã‚‚ã®ã€ã§ã‚ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_2192"></a>(define (list-&gt;tree elements)
  (car (partial-tree elements (length elements))))

(define (partial-tree elts n)
  (if (= n 0)
      (cons '() elts)
      (let ((left-size (quotient (- n 1) 2)))
        (let ((left-result (partial-tree elts left-size)))
          (let ((left-tree (car left-result))
                (non-left-elts (cdr left-result))
                (right-size (- n (+ left-size 1))))
            (let ((this-entry (car non-left-elts))
                  (right-result (partial-tree (cdr non-left-elts)
                                              right-size)))
              (let ((right-tree (car right-result))
                    (remaining-elts (cdr right-result)))
                (cons (make-tree this-entry left-tree right-tree)
                      remaining-elts))))))))
</p>

<ol class="orig" lang="en">
<li>Write a short paragraph explaining as clearly as you can how <tt>partial-tree</tt> works.  Draw the tree produced by <tt>list-&gt;tree</tt> for
the list <tt>(1 3 5 7 9 11)</tt>.</li>
<li>What is the order of growth in the number of steps required by <tt>list-&gt;tree</tt> to convert a list of <em>n</em> elements?</li>
</ol>

<ol class="trans" lang="ja">
<li><tt>partial-tree</tt> ãŒã©ã†å‹•ãã®ã‹ã‚’ã§ãã‚‹ã ã‘æ˜ç¢ºã«èª¬æ˜ã™ã‚‹ã€çŸ­ã„ãƒ‘ãƒ©ã‚°ãƒ©ãƒ•ã‚’æ›¸ã‘ã€‚
<tt>(1 3 5 7 9 11)</tt> ã¨ã„ã†ãƒªã‚¹ãƒˆã«å¯¾ã—ã¦ <tt>list-&gt;tree</tt> ã«ã‚ˆã‚Šä½œã‚Šå‡ºã•ã‚Œã‚‹æœ¨ã‚’æã‘ã€‚</li>
<li><em class="en">n</em> å€‹ã®è¦ç´ ã®ãƒªã‚¹ãƒˆã‚’å¤‰æ›ã™ã‚‹ã®ã« <tt>list-&gt;tree</tt> ãŒå¿…è¦ã¨ã™ã‚‹ã‚¹ãƒ†ãƒƒãƒ—ã®æ•°ã®å¢—å¤§ã®ã‚ªãƒ¼ãƒ€ã¯ã€ã„ã‹ã»ã©ã‹?</li>
</ol>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_2.65"></a>
<b>Exercise 2.65.</b>  <a name="%_idx_2194"></a><a name="%_idx_2196"></a>Use the results of exercises <a href="#%_thm_2.63">2.63</a> and
 <a href="#%_thm_2.64">2.64</a> to give <img src="book-Z-G-D-3.gif" border="0">(<em>n</em>) implementations of <tt>union-set</tt> and <tt>intersection-set</tt> for sets implemented as
(balanced) binary trees.<a name="call_footnote_Temp_254" href="#footnote_Temp_254"><sup><small>41</small></sup></a>
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.65.</b> ç·´ç¿’å•é¡Œ<a href="#%_thm_2.63">2.63</a>ã¨<a href="#%_thm_2.64">2.64</a>ã®çµæœã‚’ä½¿ã£ã¦ã€
(å‡è¡¡) äºŒåˆ†æœ¨ã¨ã—ã¦å®Ÿè£…ã•ã‚ŒãŸé›†åˆã«å¯¾ã™ã‚‹ã€<tt>union-set</tt> ã¨ <tt>intersection-set</tt> ã®ã€&Theta;(<em class="en">n</em>) ã®å®Ÿè£…ã‚’ç¤ºã›ã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_Temp_255"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_255">Sets and information retrieval</a></h4>
<h4 class="trans" lang="ja">é›†åˆã¨æƒ…å ±æ¤œç´¢</h4>

<p class="orig" lang="en">
<a name="%_idx_2200"></a>
We have examined options for using lists to represent sets and have
seen how the choice of representation for a data object can have a
large impact on the performance of the programs that use the data.
Another reason for concentrating on sets is that the techniques
discussed here appear again and again in applications involving
information retrieval.</p>

<p class="trans" lang="ja">
ç§ãŸã¡ã¯ã€é›†åˆã‚’è¡¨ç¾ã™ã‚‹ã®ã«ãƒªã‚¹ãƒˆã‚’ç”¨ã„ã‚‹é¸æŠè‚¢ã‚’ã„ãã¤ã‹åŸå‘³ã—ã¦ããŸã€‚ãã—ã¦ã€ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®è¡¨ç¾ã«ã¤ã„ã¦ã®é¸æŠãŒã€ãã®ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ã†ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®æ€§èƒ½ã«å¯¾ã—ã¦ã€ã©ã‚Œã»ã©å¤§ããªå½±éŸ¿ã‚’ä¸ãˆå¾—ã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’è¦‹ã¦ããŸã€‚
é›†åˆã«ç²¾ç¥ã‚’é›†ä¸­ã•ã›ã¦ã„ã‚‹ã‚‚ã†ä¸€ã¤ã®ç†ç”±ã¯ã€ã“ã“ã§è­°è«–ã—ã¦ã„ã‚‹æŠ€æ³•ãŒã€æƒ…å ±æ¤œç´¢ã‚’ä¼´ã†ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ä¸­ã§ã€ä½•åº¦ã‚‚ä½•åº¦ã‚‚ç¾ã‚Œã‚‹ã‹ã‚‰ã ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_2202"></a>Consider a data base containing a large number of individual records,
<a name="%_idx_2204"></a>such as the personnel files for a company or the transactions in an
accounting system.  A typical data-management system spends a large
amount of time accessing or modifying the data in the records and
therefore requires an efficient method for accessing records.  This is
done by identifying a part of each record to serve as an identifying
<a name="%_idx_2206"></a><em>key</em>.  A key can be anything that uniquely identifies the
record.  For a personnel file, it might be an employee's ID number.
For an accounting system, it might be a transaction number.  Whatever
the key is, when we define the record as a data structure we should
include a <a name="%_idx_2208"></a><tt>key</tt> selector procedure that retrieves the key
associated with a given record.</p>

<p class="trans" lang="ja">
ãŸã¨ãˆã°ã€ä¼šç¤¾ã®å€‹äººè¨˜éŒ²ã‚„ã€å£åº§ã‚·ã‚¹ãƒ†ãƒ ã§ã®å–å¼•ãªã©ã®ã€å¤šæ•°ã®å€‹åˆ¥ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’å«ã‚€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’è€ƒãˆã¦ã¿ã‚ˆã†ã€‚
å…¸å‹çš„ãªãƒ‡ãƒ¼ã‚¿ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã¯ã€ãƒ¬ã‚³ãƒ¼ãƒ‰å†…ã®ãƒ‡ãƒ¼ã‚¿ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ãŸã‚Šä¿®æ­£ã‚’åŠ ãˆãŸã‚Šã™ã‚‹ã®ã«ã€å¤šãã®æ™‚é–“ã‚’è²»ã‚„ã—ã¦ãŠã‚Šã€ã‚†ãˆã«ã€ãƒ¬ã‚³ãƒ¼ãƒ‰ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãŸã‚ã®åŠ¹ç‡çš„ãªæ‰‹æ³•ã‚’å¿…è¦ã¨ã—ã¦ã„ã‚‹ã€‚
ã“ã‚Œã¯ã€è­˜åˆ¥<em>ã‚­ãƒ¼</em>ã¨ã—ã¦ã¯ãŸã‚‰ãã‚ˆã†ã«å„ãƒ¬ã‚³ãƒ¼ãƒ‰ã®ä¸€éƒ¨ã‚’è­˜åˆ¥ã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€ãªã•ã‚Œã‚‹ã€‚
ã‚­ãƒ¼ã¯ã€ãã®ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’ä¸€æ„ã«è­˜åˆ¥ã™ã‚‹ã‚‚ã®ãªã‚‰ä½•ã§ã‚‚ã‚ˆã„ã€‚
å€‹äººè¨˜éŒ²ãªã‚‰ã€ã‚­ãƒ¼ã¯ã€å¾“æ¥­å“¡ã®IDç•ªå·ã‹ã‚‚ã—ãªã„ã€‚
å£åº§ã‚·ã‚¹ãƒ†ãƒ ãªã‚‰ã€ã‚­ãƒ¼ã¯ã€å–å¼•ç•ªå·ã‹ã‚‚ã—ãªã„ã€‚
ã‚­ãƒ¼ãŒä½•ã§ã‚ã‚ã†ãŒã€ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã¨ã—ã¦å®šç¾©ã™ã‚‹éš›ã«ã¯ã€ç§ãŸã¡ã¯ã€ä¸ãˆã‚‰ã‚ŒãŸãƒ¬ã‚³ãƒ¼ãƒ‰ã«å¯¾å¿œã¥ã‘ã‚‰ã‚ŒãŸã‚­ãƒ¼ã‚’å–ã‚Šå‡ºã™ã‚ˆã†ãªã€<tt>key</tt> ã¨ã„ã†ã‚»ãƒ¬ã‚¯ã‚¿æ‰‹ç¶šãã‚’å«ã‚ã‚‹ã¹ãã ã€‚
</p>

<p class="orig" lang="en">
Now we represent the data base as a set of records. To locate the
record with a given key we use a procedure <tt>lookup</tt>, which takes
as arguments a key and a data base and which returns the record that
has that key, or false if there is no such record.  <tt>Lookup</tt>
is implemented in almost the same way as <tt>element-of-set?</tt>.  For
example, if the set of records is implemented as an unordered list, we
could use
</p>

<p class="trans" lang="ja">
ã•ã¦ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’ãƒ¬ã‚³ãƒ¼ãƒ‰ã®é›†åˆã¨ã—ã¦è¡¨ç¾ã™ã‚‹ã€‚
ä¸ãˆã‚‰ã‚ŒãŸã‚­ãƒ¼ã‚’æŒã¤ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’çªãã¨ã‚ã‚‹ãŸã‚ã«ã¯ã€<tt>lookup</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’ä½¿ã†ãŒã€ã“ã‚Œã¯ã€å¼•æ•°ã¨ã—ã¦ã‚­ãƒ¼ã¨ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã¨ã‚’å–ã‚Šã€ãã®ã‚­ãƒ¼ã‚’æŒã¤ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’è¿”ã™ã‹ã€ã‚ã‚‹ã„ã¯ã€ãã†ã„ã†ãƒ¬ã‚³ãƒ¼ãƒ‰ãŒãªã„ã¨ãã¯å½ã‚’è¿”ã™ã€‚
<tt>lookup</tt> ã¯ã€<tt>element-of-set?</tt> ã¨ã»ã¨ã‚“ã©åŒã˜æ–¹æ³•ã§å®Ÿè£…ã•ã‚Œã‚‹ã€‚
ãŸã¨ãˆã°ã€ã‚‚ã—ãƒ¬ã‚³ãƒ¼ãƒ‰ã®é›†åˆãŒã€é †åºã¥ã‘ã•ã‚Œã¦ã„ãªã„ãƒªã‚¹ãƒˆã¨ã—ã¦å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ãªã‚‰ã°ã€ä»¥ä¸‹ã®ã‚‚ã®ã‚’ä½¿ãˆã‚‹ã ã‚ã†ã€‚
</p>

<p class="lisp"><a name="%_idx_2210"></a>(define (lookup given-key set-of-records)
  (cond ((null? set-of-records) false)
        ((equal? given-key (key (car set-of-records)))
         (car set-of-records))
        (else (lookup given-key (cdr set-of-records)))))
</p>

<p class="orig" lang="en">
Of course, there are better ways to represent large sets than as
unordered lists.  Information-retrieval systems in which records have
to be ``randomly accessed'' are typically implemented by a tree-based
method, such as the binary-tree representation discussed previously.
In designing such a system the methodology of data abstraction
can be a great help.  The designer can create an initial
implementation using a simple, straightforward representation such as
unordered lists.  This will be unsuitable for the eventual system, but
it can be useful in providing a ``quick and dirty'' data base with
which to test the rest of the system.  Later on, the data
representation can be modified to be more sophisticated.  If the data
base is accessed in terms of abstract selectors and constructors, this
change in representation will not require any changes to the rest of
the system.</p>

<p class="trans" lang="ja">
ã‚‚ã¡ã‚ã‚“ã€å¤§ããªé›†åˆã‚’ã€é †åºã¥ã‘ã•ã‚Œã¦ã„ãªã„ãƒªã‚¹ãƒˆã¨ã—ã¦è¡¨ç¾ã™ã‚‹ã‚ˆã‚Šã‚‚ã€ã‚ˆã‚Šè‰¯ã„è¡¨ç¾æ–¹æ³•ã¯ã‚ã‚‹ã€‚
ãƒ¬ã‚³ãƒ¼ãƒ‰ãŒã€Œãƒ©ãƒ³ãƒ€ãƒ ã«ã‚¢ã‚¯ã‚»ã‚¹ã•ã‚Œã€ãªãã¦ã¯ãªã‚‰ãªã„æƒ…å ±æ¤œç´¢ã‚·ã‚¹ãƒ†ãƒ ã¯ã€å…¸å‹çš„ã«ã¯ã€æœ¨ã«åŸºã¥ãæ–¹æ³•â€”â€”å‰ã«è­°è«–ã—ãŸã€äºŒåˆ†æœ¨è¡¨ç¾ãªã©â€”â€”ã«ã‚ˆã‚Šã€å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ã€‚
ãã†ã„ã†ã‚·ã‚¹ãƒ†ãƒ ã‚’è¨­è¨ˆã™ã‚‹éš›ã«ã¯ã€ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ã®æ–¹æ³•è«–ãŒã€å¤§ããªåŠ©ã‘ã¨ãªã‚Šå¾—ã‚‹ã€‚
è¨­è¨ˆè€…ã¯ã€é †åºã¥ã‘ã•ã‚Œã¦ã„ãªã„ãƒªã‚¹ãƒˆãªã©ã®ã€ç°¡å˜ã§ã‚ã‹ã‚Šã‚„ã™ã„è¡¨ç¾ã‚’ä½¿ã£ãŸã€æœ€åˆã®å®Ÿè£…ã‚’ä½œæˆã§ãã‚‹ã€‚
ã“ã‚Œã¯ã€æœ€çµ‚çš„ãªã‚·ã‚¹ãƒ†ãƒ ã«ã¯é©ã—ã¦ã„ãªã„ã ã‚ã†ãŒã€ã‚·ã‚¹ãƒ†ãƒ ã®æ®‹ã‚Šã‚’æ¤œæŸ»ã™ã‚‹éš›ã«ä½¿ã†ã€Œã‚„ã£ã¤ã‘ã®ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’æä¾›ã™ã‚‹ã®ã«ã¯ã€å½¹ç«‹ã¡å¾—ã‚‹ã®ã ã€‚
å¾Œã§ã€ãƒ‡ãƒ¼ã‚¿è¡¨ç¾ã¯ã€ã‚ˆã‚Šæ´—ç·´ã•ã‚ŒãŸå½¢ã¸ã¨ä¿®æ­£ã•ã‚Œå¾—ã‚‹ã€‚
ã‚‚ã—ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãŒã€æŠ½è±¡çš„ãªã‚»ãƒ¬ã‚¯ã‚¿ã¨ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’ä½¿ã£ã¦ã‚¢ã‚¯ã‚»ã‚¹ã•ã‚Œã‚‹ãªã‚‰ã€è¡¨ç¾ã«ã¤ã„ã¦ã®ã“ã®å¤‰æ›´ã®ã›ã„ã§ã€ã‚·ã‚¹ãƒ†ãƒ ã®æ®‹ã‚Šã«å¯¾ã™ã‚‹ä½•ã‚‰ã‹ã®å¤‰æ›´ãŒå¿…è¦ã¨ãªã‚‹ã“ã¨ã¯ã€ãªã„ã ã‚ã†ã€‚
</p>

<p class="orig" lang="en">
<a name="%_thm_2.66"></a>
<b>Exercise 2.66.</b>  Implement the <tt>lookup</tt> procedure for the case
where the set of records is structured as a binary tree, ordered by
the numerical values of the keys.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.66.</b> ã‚­ãƒ¼ã®æ•°å€¤ã«ã‚ˆã‚Šé †åºã¥ã‘ã‚‰ã‚ŒãŸäºŒåˆ†æœ¨ã¨ã—ã¦ãƒ¬ã‚³ãƒ¼ãƒ‰ã®é›†åˆãŒæ§‹é€ åŒ–ã•ã‚Œã¦ã„ã‚‹å ´åˆã«ãŠã‘ã‚‹ã€<tt>lookup</tt> ã®æ‰‹ç¶šãã‚’å®Ÿè£…ã›ã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_2.3.4"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_2.3.4">2.3.4  Example: Huffman Encoding Trees</a></h3>
<h3 class="trans" lang="ja">2.3.4 ä¾‹: ãƒãƒ•ãƒãƒ³ç¬¦å·åŒ–æœ¨</h3>

<p class="orig" lang="en">
<a name="%_idx_2212"></a>
This section provides practice in the use of list structure and data
abstraction to manipulate sets and trees.  The application is to
methods for representing data as sequences of ones and zeros (bits).
For example, the <a name="%_idx_2214"></a><a name="%_idx_2216"></a>ASCII standard code used to represent text in
computers encodes each <a name="%_idx_2218"></a>character as a sequence of seven bits.  Using
seven bits allows us to distinguish 2<sup>7</sup>, or 128, possible different
characters.  In general, if we want to distinguish <em>n</em> different
symbols, we will need to use <tt>log</tt><sub>2</sub> <em>n</em> bits per symbol.  If all our
messages are made up of the eight symbols A, B, C, D, E, F, G, and H,
we can choose a code with three bits per character, for example</p>

<p class="trans" lang="ja">
æœ¬ç¯€ã§ã¯ã€é›†åˆã¨æœ¨ã‚’æ“ä½œã™ã‚‹ãŸã‚ã®ãƒªã‚¹ãƒˆæ§‹é€ ã¨ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ã®ä½¿ç”¨ã«ãŠã‘ã‚‹å®Ÿè·µã‚’ç¤ºã™ã€‚
é©ç”¨å…ˆã¯ã€1ã¨0 (ã¤ã¾ã‚Šãƒ“ãƒƒãƒˆ) ã®åˆ—ã¨ã—ã¦ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ç¾ã™ã‚‹ãŸã‚ã®æ–¹æ³•ã§ã‚ã‚‹ã€‚
ãŸã¨ãˆã°ã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã§ãƒ†ã‚­ã‚¹ãƒˆã‚’è¡¨ç¾ã™ã‚‹ã®ã«ä½¿ã‚ã‚Œã¦ã„ã‚‹ASCIIæ¨™æº–ç¬¦å·ã¯ã€å„æ–‡å­—ã‚’7ãƒ“ãƒƒãƒˆã®åˆ—ã¨ã—ã¦ç¬¦å·åŒ–ã—ã¦ã„ã‚‹ã€‚
7ãƒ“ãƒƒãƒˆã‚’ä½¿ã†ã“ã¨ã§ã€2<sup>7</sup>å€‹ã€ã¤ã¾ã‚Š128å€‹ã®ã€å¯èƒ½ãªç•°ãªã‚‹æ–‡å­—ã‚’åŒºåˆ¥ã§ãã‚‹ã€‚
ä¸€èˆ¬çš„ã«ã¯ã€<em class="en">n</em>å€‹ã®ç•°ãªã‚‹ã‚·ãƒ³ãƒœãƒ«ã‚’åŒºåˆ¥ã—ãŸã„ãªã‚‰ã€ä¸€ã¤ã®ã‚·ãƒ³ãƒœãƒ«ã‚ãŸã‚Š
<span class="math"><tt>log</tt><sub>2</sub> <em class="en">n</em></span>
ãƒ“ãƒƒãƒˆã‚’ä½¿ã†å¿…è¦ãŒã‚ã‚‹ã ã‚ã†ã€‚
ã‚‚ã—ã€ã™ã¹ã¦ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒã€Aã€Bã€Cã€Dã€Eã€Fã€Gã€H ã¨ã„ã†8å€‹ã®ã‚·ãƒ³ãƒœãƒ«ã‹ã‚‰æˆã‚Šç«‹ã£ã¦ã„ã‚‹ã®ãªã‚‰ã€ä¸€æ–‡å­—ã‚ãŸã‚Š3ãƒ“ãƒƒãƒˆã®ç¬¦å·ã‚’é¸ã¶ã“ã¨ãŒã§ãã‚‹ã€‚ãŸã¨ãˆã°ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ã€‚
</p>

<figure>
<table class="common"><tr><td valign=top >A 000 </td><td valign=top >C 010 </td><td valign=top >E 100 </td><td valign=top >G 110</td></tr>
<tr><td valign=top >B 001 </td><td valign=top >D 011 </td><td valign=top >F 101 </td><td valign=top >H 111
</td></tr></table>
</figure>

<p class="orig" lang="en">
With this code, the message
</p>

<p class="trans" lang="ja">
ã“ã®ç¬¦å·ã‚’ä½¿ã†ã¨ã€ä»¥ä¸‹ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ã€
</p>

<p class="lisp">BACADAEAFABBAAAGAH</p>

<p class="orig" lang="en">
is encoded as the string of 54 bits</p>

<p class="trans" lang="ja">
æ¬¡ã®ã‚ˆã†ãª54ãƒ“ãƒƒãƒˆã®åˆ—ã¨ã—ã¦ã€ç¬¦å·åŒ–ã•ã‚Œã‚‹ã€‚
</p>

<p class="lisp">001000010000011000100000101000001001000000000110000111</p>


<p class="orig" lang="en">
Codes such as ASCII and the A-through-H code above are known as <a name="%_idx_2220"></a><a name="%_idx_2222"></a><em>fixed-length</em> codes, because they represent each symbol in the message
with the same number of bits.  It is sometimes advantageous to use
<a name="%_idx_2224"></a><a name="%_idx_2226"></a><em>variable-length</em> codes, in which different symbols may be
represented by different numbers of bits.  For example, <a name="%_idx_2228"></a><a name="%_idx_2230"></a>Morse code
does not use the same number of dots and dashes for each letter of the
alphabet.  In particular, E, the most frequent letter, is represented
by a single dot.  In general, if our messages are such that some
symbols appear very frequently and some very rarely, we can encode
data more efficiently (i.e., using fewer bits per message) if we
assign shorter codes to the frequent symbols.  Consider the following
alternative code for the letters A through H:
</p>

<p class="trans" lang="ja">
ASCIIã‚„ä¸Šè¨˜ã®Aã€œHç¬¦å·ãªã©ã®ç¬¦å·ã¯ã€<em>å›ºå®šé•·</em>ç¬¦å·ã¨ã—ã¦çŸ¥ã‚‰ã‚Œã‚‹ã€‚ã¨ã„ã†ã®ã‚‚ã€ãã‚Œã‚‰ã®ç¬¦å·ã¯ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å†…ã®å„ã‚·ãƒ³ãƒœãƒ«ã‚’åŒæ•°ã®ãƒ“ãƒƒãƒˆã§è¡¨ç¾ã™ã‚‹ã‹ã‚‰ã ã€‚
ã¨ãã«ã¯ã€<em>å¯å¤‰é•·</em>ç¬¦å·â€”â€”ç•°ãªã‚‹ã‚·ãƒ³ãƒœãƒ«ãŒã€ç•°ãªã‚‹å€‹æ•°ã®ãƒ“ãƒƒãƒˆã§è¡¨ç¾ã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹â€”â€”ã‚’ä½¿ã†ã®ãŒæœ‰åˆ©ã§ã‚ã‚‹ã€‚
ãŸã¨ãˆã°ã€ãƒ¢ãƒ¼ãƒ«ã‚¹ç¬¦å·ã¯ã€ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã®å„æ–‡å­—ã«å¯¾ã—ã¦ã€åŒã˜å€‹æ•°ã®ç‚¹ã¨ç·šã‚’ä½¿ã£ã¦ã¯ã„ãªã„ã€‚
ç‰¹ã«ã€Eâ€”â€”æœ€é »å‡ºã®æ–‡å­—â€”â€”ã¯ã€ä¸€ã¤ã®ç‚¹ã«ã‚ˆã‚Šè¡¨ç¾ã•ã‚Œã‚‹ã€‚
ä¸€èˆ¬çš„ã«ã¯ã€ã‚ã‚‹ä¸€éƒ¨ã®ã‚·ãƒ³ãƒœãƒ«ã¯ã¨ã¦ã‚‚é »ç¹ã«å‡ºç¾ã™ã‚‹ä¸€æ–¹ã§ã€ã‚ã‚‹ä¸€éƒ¨ã®ã‚·ãƒ³ãƒœãƒ«ã¯ã¨ã¦ã‚‚ç¨€ã«ã—ã‹å‡ºç¾ã—ãªã„ã‚ˆã†ã«ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒã§ãã¦ã„ã‚‹å ´åˆã€ã‚ˆã‚ŠçŸ­ã„ç¬¦å·ã‚’é »å‡ºã™ã‚‹ã‚·ãƒ³ãƒœãƒ«ã«å‰²ã‚Šå½“ã¦ã‚Œã°ã€ã‚ˆã‚ŠåŠ¹ç‡ã‚ˆã (ã¤ã¾ã‚Šã€ä¸€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚ãŸã‚Šã€ã‚ˆã‚Šå°‘ãªã„ãƒ“ãƒƒãƒˆã ã‘ã‚’ä½¿ã£ã¦) ãƒ‡ãƒ¼ã‚¿ã‚’ç¬¦å·åŒ–ã§ãã‚‹ã€‚
Aã‹ã‚‰Hã¾ã§ã®æ–‡å­—ã«å¯¾ã™ã‚‹ã€ä»¥ä¸‹ã®ä»£æ›¿ç¬¦å·ã‚’è€ƒãˆã‚ˆã†ã€‚
</p>

<figure>
<table class="common"><tr><td valign=top >A 0 </td><td valign=top >C 1010 </td><td valign=top >E 1100 </td><td valign=top >G 1110</td></tr>
<tr><td valign=top >B 100 </td><td valign=top >D 1011 </td><td valign=top >F 1101 </td><td valign=top >H 1111
</td></tr></table>
</figure>

<p class="orig" lang="en">
With this code, the same message as above is encoded as the string</p>

<p class="trans" lang="ja">
ã“ã®ç¬¦å·ã‚’ä½¿ã†ã¨ã€ä¸Šè¨˜ã¨åŒã˜ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ã€ä»¥ä¸‹ã®åˆ—ã®ã‚ˆã†ã«ç¬¦å·åŒ–ã•ã‚Œã‚‹ã€‚
</p>

<p class="lisp">100010100101101100011010100100000111001111</p>

<p class="orig" lang="en">
This string contains 42 bits, so it saves more than 20% in space in
comparison with the fixed-length code shown above.</p>

<p class="trans" lang="ja">
ã“ã®åˆ—ã¯42ãƒ“ãƒƒãƒˆã‚’å«ã¿ã€ã‚ˆã£ã¦ã€ä¸Šè¨˜ã®å›ºå®šé•·ç¬¦å·ã¨æ¯”ã¹ã‚‹ã¨ã€ç©ºé–“ã‚’20%ä»¥ä¸Šã‚‚ç¯€ç´„ã§ãã‚‹ã€‚
</p>

<p class="orig" lang="en">
One of the difficulties of using a variable-length code is knowing
when you have reached the end of a symbol in reading a sequence of
zeros and ones.  Morse code solves this problem by using a special
<a name="%_idx_2232"></a><em>separator code</em> (in this case, a pause) after the sequence of
dots and dashes for each letter.  Another solution is to design the
code in such a way that no complete code for any symbol is the
beginning (or <em>prefix</em>) of the code for another symbol.  Such a
code is called a <a name="%_idx_2234"></a><a name="%_idx_2236"></a><em>prefix code</em>.  In the example above, A is
encoded by 0 and B is encoded by 100, so no other symbol can have a
code that begins with 0 or with 100.</p>

<p class="trans" lang="ja">
å¯å¤‰é•·ç¬¦å·ã‚’ä½¿ã†ã“ã¨ã®é›£ã—ã•ã®ä¸€ã¤ã¯ã€0ã¨1ã®ä¸¦ã³ã‚’èª­ã‚“ã§ã„ãä¸­ã§ã€ã„ã¤ã‚·ãƒ³ãƒœãƒ«ã®çµ‚ã‚ã‚Šã«é”ã—ãŸã®ã‹ã‚’çŸ¥ã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚ãƒ¢ãƒ¼ãƒ«ã‚¹ç¬¦å·ã§ã¯ã€å„æ–‡å­—ã®ç‚¹ã¨ç·šã®ä¸¦ã³ã®å¾Œã§ç©ºé–“çš„ãª<em>ã‚»ãƒ‘ãƒ¬ãƒ¼ã‚¿</em> (ã“ã“ã§ã¯<ruby><rb>å°ä¼‘æ­¢</rb><rp> (</rp><rt>ãƒãƒ¼ã‚º</rt><rp>) </rp></ruby>) ã‚’ä½¿ã†ã“ã¨ã«ã‚ˆã‚Šã€ã“ã®å•é¡Œã‚’è§£æ±ºã—ã¦ã„ã‚‹ã€‚
åˆ¥ã®è§£æ±ºæ³•ã¯ã€ã©ã®ã‚·ãƒ³ãƒœãƒ«ã«ã¤ã„ã¦ã®ç¬¦å·å…¨ä½“ã‚‚ã€åˆ¥ã®ã‚·ãƒ³ãƒœãƒ«ã®ç¬¦å·ã®å§‹ã¾ã‚Šã®éƒ¨åˆ† (ã¤ã¾ã‚Š<em>ãƒ—ãƒ¬ãƒ•ã‚£ã‚¯ã‚¹</em>) ã§ã¯ãªã„ã‚ˆã†ãªã‚„ã‚Šæ–¹ã§ã€ç¬¦å·ã‚’è¨­è¨ˆã™ã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚
ãã®ã‚ˆã†ãªç¬¦å·ã¯ã€<em>ãƒ—ãƒ¬ãƒ•ã‚£ã‚¯ã‚¹ç¬¦å·</em>ã¨å‘¼ã°ã‚Œã‚‹ã€‚
ä¸Šè¨˜ã®ä¾‹ã§ã¯ã€AãŒ0ã«ç¬¦å·åŒ–ã•ã‚Œã€BãŒ100ã«ç¬¦å·åŒ–ã•ã‚Œã¦ã„ã‚‹ã‹ã‚‰ã€ä»–ã®ã©ã®ã‚·ãƒ³ãƒœãƒ«ã‚‚ã€0ã¾ãŸã¯100ã‹ã‚‰å§‹ã¾ã‚‹ç¬¦å·ã«ã¯ãªã‚Œãªã„ã€‚
</p>

<p class="orig" lang="en">
In general, we can attain significant savings if we use
variable-length prefix codes that take advantage of the relative
frequencies of the symbols in the messages to be encoded.  One
particular scheme for doing this is called the Huffman encoding
method, after its discoverer, <a name="%_idx_2238"></a>David Huffman.  A Huffman code can be
represented as a <a name="%_idx_2240"></a><a name="%_idx_2242"></a>binary tree whose leaves are the symbols that are
encoded.  At each non-leaf node of the tree there is a set containing
all the symbols in the leaves that lie below the node.  In addition,
each symbol at a leaf is assigned a weight (which is its
relative frequency), and each non-leaf
node contains a weight that is the sum of all the weights of the
leaves lying below it.  The weights are not used in the encoding or
the decoding process.  We will see below how they are used to help
construct the tree.</p>

<p class="trans" lang="ja">
ä¸€èˆ¬ã«ã¯ã€ç¬¦å·åŒ–ã™ã¹ããƒ¡ãƒƒã‚»ãƒ¼ã‚¸å†…ã§ã®å„ã‚·ãƒ³ãƒœãƒ«ã®ç›¸å¯¾é »åº¦ã‚’åˆ©ç”¨ã™ã‚‹ã‚ˆã†ãªå¯å¤‰é•·ãƒ—ãƒ¬ãƒ•ã‚£ã‚¯ã‚¹ç¬¦å·ã‚’ä½¿ã†ã¨ãã«ã€é¡•è‘—ãªç¯€ç´„ã‚’é”æˆã§ãã‚‹ã€‚
ã“ã†ã™ã‚‹ãŸã‚ã®ä¸€ã¤ã®æ ¼åˆ¥ãªä½“ç³»ã¯ã€ãƒãƒ•ãƒãƒ³ç¬¦å·åŒ–æ³•ã¨å‘¼ã°ã‚Œã‚‹â€”â€”ãã®ç™ºè¦‹è€…ãŸã‚‹ãƒ‡ã‚¤ãƒ´ã‚£ãƒƒãƒ‰ãƒ»ãƒãƒ•ãƒãƒ³ã«ã¡ãªã‚“ã§ã€‚
ãƒãƒ•ãƒãƒ³ç¬¦å·ã¯ã€è‘‰ãŒã€ç¬¦å·åŒ–ã•ã‚Œã‚‹ã‚·ãƒ³ãƒœãƒ«ã§ã‚ã‚‹ã‚ˆã†ãªäºŒåˆ†æœ¨ã¨ã—ã¦ã€è¡¨ç¾ã§ãã‚‹ã€‚
æœ¨ã®ã†ã¡è‘‰ã§ã¯ãªã„å„ãƒãƒ¼ãƒ‰ã«ã¯ã€ãã®ãƒãƒ¼ãƒ‰ã®é…ä¸‹ã«ã‚ã‚‹è‘‰ã«ã‚ã‚‹å…¨ã¦ã®ã‚·ãƒ³ãƒœãƒ«ã‚’å«ã‚€ã‚ˆã†ãªé›†åˆãŒã‚ã‚‹ã€‚
ã•ã‚‰ã«ã€è‘‰ã«ã‚ã‚‹å„ã‚·ãƒ³ãƒœãƒ«ã«ã¯ã€é‡ã¿ (ãã®ã‚·ãƒ³ãƒœãƒ«ã®ç›¸å¯¾é »åº¦)  ãŒå‰²ã‚Šå½“ã¦ã‚‰ã‚Œã¦ãŠã‚Šã€è‘‰ã§ã¯ãªã„å„ãƒãƒ¼ãƒ‰ã¯ã€ãã®é…ä¸‹ã«ã‚ã‚‹å…¨ã¦ã®è‘‰ã®é‡ã¿ã®å’Œã§ã‚ã‚‹ã‚ˆã†ãªé‡ã¿ã‚’å«ã‚€ã€‚
é‡ã¿ã¯ã€ç¬¦å·åŒ–ãƒ—ãƒ­ã‚»ã‚¹ã§ã‚‚å¾©å·ãƒ—ãƒ­ã‚»ã‚¹ã§ã‚‚ä½¿ã‚ã‚Œãªã„ã€‚
æœ¨ã‚’æ§‹ç¯‰ã™ã‚‹åŠ©ã‘ã¨ã™ã‚‹ãŸã‚ã«ã€ã©ã®ã‚ˆã†ã«é‡ã¿ãŒä½¿ã‚ã‚Œã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’ã€ã“ã‚Œã‹ã‚‰è¦‹ã‚ˆã†ã€‚
</p>

<figure>
<a name="%_fig_2.18"></a>
<img src="ch2-Z-G-53.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 2.18:</b>  A Huffman encoding tree.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³2.18:</b>  ãƒãƒ•ãƒãƒ³ç¬¦å·åŒ–ã®æœ¨</figcaption>
</figure>

<p class="orig" lang="en">
Figure <a href="#%_fig_2.18">2.18</a> shows the Huffman tree for the A-through-H 
code given above.  The weights at the leaves
indicate that the tree was designed for messages in which A appears
with relative frequency 8, B with relative frequency 3, and the
other letters each with relative frequency 1.</p>

<p class="trans" lang="ja">
å›³<a href="#%_fig_2.18">2.18</a>ã¯ã€ä¸Šè¨˜ã®Aã€œHç¬¦å·ç”¨ã®ãƒãƒ•ãƒãƒ³æœ¨ã‚’ã‚’ç¤ºã—ã¦ã„ã‚‹ã€‚
è‘‰ã®é‡ã¿ãŒç¤ºã—ã¦ã„ã‚‹ã®ã¯ã€ã“ã®æœ¨ã¯ã€8ã¨ã„ã†ç›¸å¯¾é »åº¦ã§AãŒç¾ã‚Œã€3ã¨ã„ã†ç›¸å¯¾é »åº¦ã§BãŒç¾ã‚Œã€æ®‹ã‚Šã®æ–‡å­—ãŒãã‚Œãã‚Œ1ã¨ã„ã†ç›¸å¯¾é »åº¦ã§ç¾ã‚Œã‚‹ã‚ˆã†ãªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç”¨ã«è¨­è¨ˆã•ã‚ŒãŸã€ã¨ã„ã†ã“ã¨ã ã€‚
</p>

<p class="orig" lang="en">
Given a Huffman tree, we can find the encoding of any symbol by
starting at the root and moving down until we reach the leaf that
holds the symbol.  Each time we move down a left branch we add a 0 to
the code, and each time we move down a right branch we add a 1.  (We
decide which branch to follow by testing to see which branch either is
the leaf node for the symbol or contains the symbol in its set.)  For
example, starting from the root of the tree in
figure <a href="#%_fig_2.18">2.18</a>, we arrive at the leaf for D by following a
right branch, then a left branch, then a right branch, then a right
branch; hence, the code for D is 1011.</p>

<p class="trans" lang="ja">
ãƒãƒ•ãƒãƒ³æœ¨ãŒä¸ãˆã‚‰ã‚Œã‚‹ã¨ã€ç§ãŸã¡ã¯ã€ã©ã®ã‚·ãƒ³ãƒœãƒ«ã®ç¬¦å·åŒ–ã®ä»•æ–¹ã§ã‚ã£ã¦ã‚‚ã€æ ¹ã‹ã‚‰å§‹ã‚ã¦ã€å½“è©²ã‚·ãƒ³ãƒœãƒ«ã‚’ä¿æŒã™ã‚‹è‘‰ã«åˆ°ã‚‹ã¾ã§é™ã‚Šã¦ã‚†ãã“ã¨ã«ã‚ˆã£ã¦ã€ãã®ä»•æ–¹ãŒã‚ã‹ã‚‹ã®ã§ã‚ã‚‹ã€‚
å·¦ã®åˆ†å²ã‚’é™ã‚Šã‚‹ãŸã³ã«ã€0ã‚’ç¬¦å·ã«åŠ ãˆã€å³ã®åˆ†å²ã‚’é™ã‚Šã‚‹ãŸã³ã«ã€1ã‚’åŠ ãˆã‚‹ã€‚
(å½“è©²ã‚·ãƒ³ãƒœãƒ«ã®è‘‰ãƒãƒ¼ãƒ‰ã§ã‚ã‚‹ã‹ã€ã¾ãŸã¯ã€ãã®é›†åˆå†…ã«å½“è©²ã‚·ãƒ³ãƒœãƒ«ã‚’å«ã‚“ã§ã„ã‚‹ã®ã¯ã€ã©ã¡ã‚‰ã®åˆ†å²ãªã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’èª¿ã¹ã‚‹ã“ã¨ã§ã€ã©ã¡ã‚‰ã®åˆ†å²ã‚’ãŸã©ã‚‹ã¹ããªã®ã‹ã‚’æ±ºã‚ã‚‹ã€‚)
ãŸã¨ãˆã°ã€å›³<a href="#%_fig_2.18">2.18</a>ã®æ ¹ã‹ã‚‰å§‹ã‚ã¦ã€å³ã®åˆ†å²ã€ãã‚Œã‹ã‚‰å·¦ã®åˆ†å²ã€ãã‚Œã‹ã‚‰å³ã®åˆ†å²ã€ãã‚Œã‹ã‚‰å³ã®åˆ†å²ã€ã¨ãŸã©ã‚‹ã“ã¨ã§ã€Dã®è‘‰ã«ãŸã©ã‚Šã¤ãã€‚ã‚ˆã£ã¦ã€Dã®ç¬¦å·ã¯1011ã ã€‚
</p>

<p class="orig" lang="en">
To decode a bit sequence using a Huffman tree, we begin at the root
and use the successive zeros and ones of the bit sequence to determine
whether to move down the left or the right branch.  Each time we come
to a leaf, we have generated a new symbol in the message, at which
point we start over from the root of the tree to find the next symbol.
For example, suppose we are given the tree above and the sequence
10001010.  Starting at the root, we move down the right branch, (since
the first bit of the string is 1), then down the left branch (since
the second bit is 0), then down the left branch (since the third bit
is also 0).  This brings us to the leaf for B, so the first symbol of
the decoded message is B.  Now we start again at the root, and we make
a left move because the next bit in the string is 0.  This brings us
to the leaf for A.  Then we start again at the root with the rest of
the string 1010, so we move right, left, right, left and reach C.
Thus, the entire message is BAC.</p>

<p class="trans" lang="ja">
ãƒãƒ•ãƒãƒ³æœ¨ã‚’ä½¿ã£ã¦ãƒ“ãƒƒãƒˆåˆ—ã‚’å¾©å·ã™ã‚‹ã«ã¯ã€æ ¹ã‹ã‚‰å§‹ã‚ã€ãã—ã¦ã€ãã®ãƒ“ãƒƒãƒˆåˆ—ã®ã€æ¬¡ã«ç¶šã0ã¨1ã¨ã‚’ä½¿ã£ã¦ã€å·¦ã®åˆ†å²ã‚’é™ã‚Šã‚‹ã¹ãã‹ã€ãã‚Œã¨ã‚‚å³ã®åˆ†å²ã‚’é™ã‚Šã‚‹ã¹ãã‹ã‚’ã€åˆ¤å®šã™ã‚‹ã€‚
è‘‰ã«é”ã™ã‚‹ãŸã³ã«ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å†…ã®æ–°ãŸãªã‚·ãƒ³ãƒœãƒ«ã‚’ç”Ÿæˆã—ãŸã“ã¨ã«ãªã‚Šã€ãã®æ™‚ç‚¹ã§ã€æ¬¡ã®ã‚·ãƒ³ãƒœãƒ«ã‚’è¦‹ã¤ã‘ã‚‹ãŸã‚ã«ã€æœ¨ã®æ ¹ã‹ã‚‰ã‚„ã‚Šç›´ã™ã€‚
ãŸã¨ãˆã°ã€ä¸Šè¨˜ã®æœ¨ã¨ã€10001010ã¨ã„ã†åˆ—ãŒä¸ãˆã‚‰ã‚ŒãŸã¨ã—ã‚ˆã†ã€‚
æ ¹ã‹ã‚‰å§‹ã‚ã¦ã€å³ã®åˆ†å²ã‚’é™ã‚Š (ã“ã®åˆ—ã®1ç•ªç›®ã®ãƒ“ãƒƒãƒˆãŒ1ã ã‹ã‚‰)ã€ãã‚Œã‹ã‚‰å·¦ã®åˆ†å²ã‚’é™ã‚Š (2ç•ªç›®ã®ãƒ“ãƒƒãƒˆãŒ0ã ã‹ã‚‰)ã€ãã‚Œã‹ã‚‰å·¦ã®åˆ†å²ã‚’é™ã‚Šã‚‹ (3ç•ªç›®ã®ãƒ“ãƒƒãƒˆãŒ0ã ã‹ã‚‰)ã€‚
ã“ã‚Œã«ã‚ˆã£ã¦Bã®è‘‰ã«åˆ°ã‚‹ã®ã§ã€å¾©å·ã•ã‚ŒãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®1ç•ªç›®ã®ã‚·ãƒ³ãƒœãƒ«ã¯ã€Bã§ã‚ã‚‹ã€‚
ã•ã¦ã€å†ã³æ ¹ã‹ã‚‰å§‹ã‚ã¦ã€åˆ—ã®æ¬¡ã®ãƒ“ãƒƒãƒˆãŒ0ãªã®ã§å·¦ã¸ç§»å‹•ã™ã‚‹ã€‚
ã“ã‚Œã«ã‚ˆã£ã¦Aã®è‘‰ã«åˆ°ã‚‹ã€‚
æ¬¡ã«ã€æ®‹ã‚Šã®1010ã¨ã„ã†åˆ—ã«ã¤ã„ã¦å†ã³æ ¹ã‹ã‚‰å§‹ã‚ã¦ã€ãã—ã¦ã€å³ã€å·¦ã€å³ã€å·¦ã€ã¨ç§»å‹•ã—ã¦ã€Cã«åˆ°ç€ã™ã‚‹ã€‚
ã“ã®ã¨ãŠã‚Šãªã®ã§ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å…¨ä½“ã¯BACã§ã‚ã‚‹ã€‚
</p>

<a name="%_sec_Temp_257"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_257">Generating Huffman trees</a></h4>
<h4 class="trans" lang="ja">ãƒãƒ•ãƒãƒ³æœ¨ã‚’ç”Ÿæˆã™ã‚‹</h4>

<p class="orig" lang="en">
Given an ``alphabet'' of symbols and their relative frequencies, how
do we construct the ``best'' code?  (In other words, which tree will
encode messages with the fewest bits?)  Huffman gave an algorithm for
doing this and showed that the resulting code is indeed the best
variable-length code for messages where the relative frequency of the
symbols matches the frequencies with which the code was constructed.
<a name="%_idx_2244"></a><a name="%_idx_2246"></a>We will not prove this optimality of Huffman codes here, but we will
show how Huffman trees are constructed.<a name="call_footnote_Temp_258" href="#footnote_Temp_258"><sup><small>42</small></sup></a></p>

<p class="trans" lang="ja">
ã‚·ãƒ³ãƒœãƒ«ã®ã€Œã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã€ã¨ã€ãã‚Œã‚‰ã‚·ãƒ³ãƒœãƒ«ã®ç›¸å¯¾é »åº¦ã¨ãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãã€ã©ã®ã‚ˆã†ã«ã€Œæœ€è‰¯ã€ã®ç¬¦å·ã‚’æ§‹ç¯‰ã™ã‚‹ã‹?
(æ›è¨€ã™ã‚Œã°ã€ã©ã®æœ¨ãŒã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æœ€å°‘ãƒ“ãƒƒãƒˆã§ç¬¦å·åŒ–ã™ã‚‹ã®ã‹?)
ãƒãƒ•ãƒãƒ³ã¯ã€ã“ã‚Œã‚’è¡Œã†ãŸã‚ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’ç¤ºã™ã¨ã¨ã‚‚ã«ã€ã‚·ãƒ³ãƒœãƒ«ã®ç›¸å¯¾é »åº¦ãŒã€ç¬¦å·ãŒæ§‹ç¯‰ã•ã‚Œã‚‹ã®ã«ä½¿ã‚ã‚ŒãŸé »åº¦ã¨ä¸€è‡´ã™ã‚‹ã‚ˆã†ãªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«å¯¾ã—ã¦ã¯ã€çµæœã¨ã—ã¦ç”Ÿã˜ã‚‹ç¬¦å·ãŒã€å®Ÿéš›ã«æœ€è‰¯ã®å¯å¤‰é•·ç¬¦å·ã§ã‚ã‚‹ã€ã¨ç¤ºã—ãŸã€‚
ã“ã“ã§ã¯ã€ãƒãƒ•ãƒãƒ³ç¬¦å·ã®ã“ã®æœ€é©æ€§ã‚’è¨¼æ˜ã—ãªã„ã“ã¨ã«ã™ã‚‹ãŒã€ãƒãƒ•ãƒãƒ³æœ¨ãŒã©ã®ã‚ˆã†ã«æ§‹ç¯‰ã•ã‚Œã‚‹ã®ã‹ã€ã«ã¤ã„ã¦ã¯ç¤ºãã†<a href="#footnote_Temp_258"><sup><small>42</small></sup></a>ã€‚
</p>

<p class="orig" lang="en">
The algorithm for generating a Huffman tree is very simple. The idea
is to arrange the tree so that the symbols with the lowest frequency
appear farthest away from the root. Begin with the set of leaf nodes,
containing symbols and their frequencies, as determined by the initial data
from which the code is to be constructed. Now find two leaves with
the lowest weights and merge them to produce a node that has these
two nodes as its left and right branches. The weight of the new node
is the sum of the two weights. Remove the two leaves from the
original set and replace them by this new node. Now continue this
process. At each step, merge two nodes with the smallest weights,
removing them from the set and replacing them with a node that has
these two as its left and right branches. The process stops when
there is only one node left, which is the root of the entire tree.
Here is how the Huffman tree of figure <a href="#%_fig_2.18">2.18</a> was generated:</p>

<p class="trans" lang="ja">
ãƒãƒ•ãƒãƒ³æœ¨ã‚’ç”Ÿæˆã™ã‚‹ãŸã‚ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯ã€ã¨ã¦ã‚‚ç°¡æ½”ã ã€‚
ãã®è€ƒãˆæ–¹ã¨ã¯ã€æœ€ä½é »åº¦ã®ã‚·ãƒ³ãƒœãƒ«ãŒã€æ ¹ã‹ã‚‰æœ€ã‚‚é ãé›¢ã‚ŒãŸã¨ã“ã‚ã«ç¾ã‚Œã‚‹ã‚ˆã†ã«ã€æœ¨ã‚’æ•´ãˆã‚‹ã€ã¨ã„ã†ã“ã¨ã§ã‚ã‚‹ã€‚
ç¬¦å·ã‚’æ§‹ç¯‰ã™ã‚‹å…ƒã«ãªã‚‹ã¹ãåˆæœŸãƒ‡ãƒ¼ã‚¿ã«ã‚ˆã‚Šæ±ºå®šã•ã‚Œã‚‹ã¨ãŠã‚Šã®ã€è‘‰ãƒãƒ¼ãƒ‰â€”â€”ã‚·ãƒ³ãƒœãƒ«ã¨ãã®é »åº¦ã‚’å«ã‚€â€”â€”ã®é›†åˆã‹ã‚‰ã€å§‹ã‚ã‚ˆã†ã€‚
ã•ã¦ã€æœ€å°ã®é‡ã¿ã®äºŒã¤ã®è‘‰ã‚’è¦‹ã¤ã‘ã€ã“ã‚Œã‚‰ã‚’ä½µåˆã—ã¦ã€ã“ã‚Œã‚‰äºŒã¤ã®ãƒãƒ¼ãƒ‰ã‚’è‡ªåˆ†ã®å·¦å³ã®åˆ†å²ã¨ã—ã¦æœ‰ã™ã‚‹ã‚ˆã†ãªãƒãƒ¼ãƒ‰ã‚’ä½œã‚Šå‡ºãã†ã€‚
æ–°ã—ã„ãƒãƒ¼ãƒ‰ã®é‡ã¿ã¯ã€äºŒã¤ã®é‡ã¿ã®å’Œã§ã‚ã‚‹ã€‚
å…ƒã®é›†åˆã‹ã‚‰ã€ã“ã‚Œã‚‰äºŒã¤ã®è‘‰ã‚’å–ã‚Šé™¤ãã€ã“ã‚Œã‚‰ã‚’ã€æ–°ã—ã„ãƒãƒ¼ãƒ‰ã§ç½®ãæ›ãˆã‚ˆã†ã€‚
ãã—ã¦ã“ã®ãƒ—ãƒ­ã‚»ã‚¹ã‚’ç¶šã‘ã‚‹ã€‚
å„ã‚¹ãƒ†ãƒƒãƒ—ã§ã€æœ€å°ã®é‡ã¿ã®äºŒã¤ã®ãƒãƒ¼ãƒ‰ã‚’ä½µåˆã›ã‚ˆâ€”â€”ãã—ã¦ã€ã“ã‚Œã‚‰ã‚’é›†åˆã‹ã‚‰å–ã‚Šé™¤ãã¨ã¨ã‚‚ã«ã€ã“ã‚Œã‚‰äºŒã¤ã‚’è‡ªåˆ†ã®å·¦å³ã®åˆ†å²ã¨ã—ã¦æœ‰ã™ã‚‹ãƒãƒ¼ãƒ‰ã§ã€ã“ã‚Œã‚‰ã‚’ç½®ãæ›ãˆã‚‹ã®ã ã€‚
ã“ã®ãƒ—ãƒ­ã‚»ã‚¹ã¯ã€ãŸã£ãŸä¸€ã¤ã®ãƒãƒ¼ãƒ‰ã ã‘ãŒæ®‹ã£ãŸã¨ãã«åœæ­¢ã—ã€ãã®ãŸã£ãŸä¸€ã¤ã®ãƒãƒ¼ãƒ‰ã¯æœ¨å…¨ä½“ã®æ ¹ã§ã‚ã‚‹ã€‚
å›³<a href="#%_fig_2.18">2.18</a>ã®ãƒãƒ•ãƒãƒ³æœ¨ãŒã©ã®ã‚ˆã†ã«ç”Ÿæˆã•ã‚ŒãŸã®ã‹ã‚’ã€ã“ã“ã«ç¤ºã™ã€‚
</p>

<figure>
<table class="common">
<tr><td valign=top >Initial leaves </td><td valign=top><tt>{(A 8)  (B 3)  (C 1) (D 1)  (E 1)  (F 1)  (G 1)  (H 1)}</tt></td></tr>
<tr><td valign=top >Merge </td><td valign=top><tt>{(A 8)  (B 3)  ({C D} 2)  (E 1)  (F 1)  (G 1)  (H 1)}</tt></td></tr>
<tr><td valign=top >Merge </td><td valign=top><tt>{(A 8)  (B 3)  ({C D} 2) ({E F} 2)  (G 1)  (H 1)}</tt></td></tr>
<tr><td valign=top >Merge </td><td valign=top><tt>{(A 8)  (B 3)  ({C D} 2) ({E F} 2)   ({G H} 2)}</tt></td></tr>
<tr><td valign=top >Merge </td><td valign=top><tt>{(A 8)   (B 3)  ({C D} 2)  ({E F G H} 4)}</tt></td></tr>
<tr><td valign=top >Merge </td><td valign=top><tt>{(A 8)  ({B C D} 5)  ({E F G H} 4)}</tt></td></tr>
<tr><td valign=top >Merge </td><td valign=top><tt>{(A 8)  ({B C D E F G H} 9)}</tt></td></tr>
<tr><td valign=top >Final merge </td><td valign=top><tt>{({A B C D E F G H} 17)}</tt></td></tr>
</table>
</figure>

<p class="orig" lang="en">
The algorithm does not always specify a unique tree, because there may
not be unique smallest-weight nodes at each step.  Also, the choice of
the order in which the two nodes are merged (i.e., which will be the
right branch and which will be the left branch) is arbitrary.</p>

<p class="trans" lang="ja">
ã“ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯ã€ã„ã¤ã§ã‚‚ä¸€æ„ãªæœ¨ã‚’ç‰¹å®šã™ã‚‹ã‚ã‘ã§ã¯ãªã„ã€‚ã¨ã„ã†ã®ã‚‚ã€å„ã‚¹ãƒ†ãƒƒãƒ—ã§ã€ä¸€æ„ãªæœ€å°é‡ã¿ã®ãƒãƒ¼ãƒ‰ãŒã‚ã‚‹ã¨ã¯é™ã‚‰ãªã„ã‹ã‚‰ã ã€‚
ã•ã‚‰ã«ã€äºŒã¤ã®ãƒãƒ¼ãƒ‰ã‚’ä½µåˆã™ã‚‹é †åºã®é¸æŠ (ã¤ã¾ã‚Šã€ã©ã¡ã‚‰ãŒå³ã®åˆ†å²ã«ãªã‚Šã€ã©ã¡ã‚‰ãŒå·¦ã®åˆ†å²ã«ãªã‚‹ã‹) ã‚‚ä»»æ„ãªã®ã ã€‚
</p>

<a name="%_sec_Temp_259"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_259">Representing Huffman trees</a></h4>
<h4 class="trans" lang="ja">ãƒãƒ•ãƒãƒ³æœ¨ã‚’è¡¨ç¾ã™ã‚‹</h4>

<p class="orig" lang="en">
In the exercises below we will work with a system that uses
Huffman trees to encode and decode messages and generates Huffman
trees according to the algorithm outlined above.  We will begin by
discussing how trees are represented.</p>

<p class="trans" lang="ja">
ä»¥ä¸‹ã®ç·´ç¿’å•é¡Œã§ã¯ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ç¬¦å·åŒ–ã—ãŸã‚Šå¾©å·ã—ãŸã‚Šã™ã‚‹ã®ã«ãƒãƒ•ãƒãƒ³æœ¨ã‚’ä½¿ã„ã€ã‹ã¤ã€ä¸Šè¨˜ã§æ¦‚èª¬ã—ãŸã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã«ã—ãŸãŒã£ã¦ãƒãƒ•ãƒãƒ³æœ¨ã‚’ç”Ÿæˆã™ã‚‹ã‚ˆã†ãªã‚·ã‚¹ãƒ†ãƒ ã‚’ç”¨ã„ã¦ã€ä½œæ¥­ã‚’è¡Œã†ã“ã¨ã«ã™ã‚‹ã€‚
æœ¨ãŒã©ã®ã‚ˆã†ã«è¡¨ç¾ã•ã‚Œã‚‹ã®ã‹ã‚’è­°è«–ã™ã‚‹ã“ã¨ã‹ã‚‰å§‹ã‚ã‚ˆã†ã€‚
</p>

<p class="orig" lang="en">
Leaves of the tree are represented by a list consisting of the
symbol <tt>leaf</tt>, the symbol at the leaf, and the weight:
</p>

<p class="trans" lang="ja">
æœ¨ã®è‘‰ã¯ã€<tt>leaf</tt> ã¨ã„ã†ã‚·ãƒ³ãƒœãƒ«ã¨ã€ãã®è‘‰ã®ã‚·ãƒ³ãƒœãƒ«ã¨ã€é‡ã¿ã¨ã‹ã‚‰ãªã‚‹ãƒªã‚¹ãƒˆã«ã‚ˆã‚Šã€è¡¨ç¾ã•ã‚Œã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_2250"></a>(define (make-leaf symbol weight)
  (list 'leaf symbol weight))
<a name="%_idx_2252"></a>(define (leaf? object)
  (eq? (car object) 'leaf))
<a name="%_idx_2254"></a>(define (symbol-leaf x) (cadr x))
<a name="%_idx_2256"></a>(define (weight-leaf x) (caddr x))
</p>

<p class="orig" lang="en">
A general tree will be a list of a left branch, a right branch, a set
of symbols, and a weight.  The set of symbols will be simply a list of
the symbols, rather than some more sophisticated set representation.
When we make a tree by merging two nodes, we obtain the weight of the
tree as the sum of the weights of the nodes, and the set of symbols as
the union of the sets of symbols for the nodes.  Since our symbol sets are
represented as lists, we can form the union by using the <tt>append</tt>
procedure we defined in section <a href="15_sec2_2.html#%_sec_2.2.1">2.2.1</a>:
</p>

<p class="trans" lang="ja">
ä¸€èˆ¬çš„ãªæœ¨ã¯ã€å·¦ã®åˆ†å²ã¨ã€å³ã®åˆ†å²ã¨ã€ã‚·ãƒ³ãƒœãƒ«ã®é›†åˆã¨ã€é‡ã¿ã¨ã‹ã‚‰ãªã‚‹ãƒªã‚¹ãƒˆã«ãªã‚‹ã ã‚ã†ã€‚
ã‚·ãƒ³ãƒœãƒ«ã®é›†åˆã¯ã€å˜ç´”ã«ã€ã‚·ãƒ³ãƒœãƒ«ã®ãƒªã‚¹ãƒˆã«ãªã‚‹ã ã‚ã†â€”â€”ã‚ˆã‚Šæ´—ç·´ã•ã‚ŒãŸä½•ã‚‰ã‹ã®è¡¨ç¾ã§ã¯ãªãã€‚
äºŒã¤ã®ãƒãƒ¼ãƒ‰ã‚’ä½µåˆã™ã‚‹ã“ã¨ã§æœ¨ã‚’ä½œã‚‹ã¨ãã€ãã‚Œã‚‰ã®ãƒãƒ¼ãƒ‰ã®é‡ã¿ã®å’Œã¨ã—ã¦ã®ã€æœ¨ã®é‡ã¿ã‚’å¾—ã‚‹ã¨ã¨ã‚‚ã«ã€ãã‚Œã‚‰ã®ãƒãƒ¼ãƒ‰ã®ã‚·ãƒ³ãƒœãƒ«ã®é›†åˆåŒå£«ã®å’Œé›†åˆã¨ã—ã¦ã®ã€ã‚·ãƒ³ãƒœãƒ«ã®é›†åˆã‚’å¾—ã‚‹ã€‚
ã‚·ãƒ³ãƒœãƒ«é›†åˆãŒãƒªã‚¹ãƒˆã§è¡¨ç¾ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€å’Œé›†åˆã¯ã€<a href="15_sec2_2.html#%_sec_2.2.1">2.2.1</a>ç¯€ã§å®šç¾©ã—ãŸ <tt>append</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’ä½¿ã£ã¦å½¢æˆã§ãã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_2258"></a>(define (make-code-tree left right)
  (list left
        right
        (append (symbols left) (symbols right))
        (+ (weight left) (weight right))))
</p>

<p class="orig" lang="en">
If we make a tree in this way, we have the following selectors:
</p>

<p class="trans" lang="ja">
ã‚‚ã—ã“ã®ã‚„ã‚Šæ–¹ã§æœ¨ã‚’ä½œã‚‹ãªã‚‰ã€ä»¥ä¸‹ã®ã‚»ãƒ¬ã‚¯ã‚¿ãŒã‚ã‚‹ã“ã¨ã«ãªã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_2260"></a>(define (left-branch tree) (car tree))

<a name="%_idx_2262"></a>(define (right-branch tree) (cadr tree))
<a name="%_idx_2264"></a>(define (symbols tree)
  (if (leaf? tree)
      (list (symbol-leaf tree))
      (caddr tree)))
<a name="%_idx_2266"></a>(define (weight tree)
  (if (leaf? tree)
      (weight-leaf tree)
      (cadddr tree)))
</p>

<p class="orig" lang="en">
The procedures <tt>symbols</tt> and <tt>weight</tt> must do something
slightly different depending on whether they are called with a leaf or
a general tree.  These are simple examples of <a name="%_idx_2268"></a><a name="%_idx_2270"></a><em>generic
procedures</em> (procedures that can handle more than one kind of data),
which we will have much more to say about in
sections <a href="17_sec2_4.html#%_sec_2.4">2.4</a> and <a href="18_sec2_5.html#%_sec_2.5">2.5</a>.</p>

<p class="trans" lang="ja">
<tt>symbols</tt> ã¨  <tt>weight</tt> ã¨ã„ã†æ‰‹ç¶šãã¯ã€è‘‰ã«ã¤ã„ã¦å‘¼ã°ã‚ŒãŸã®ã‹ã€ãã‚Œã¨ã‚‚ä¸€èˆ¬çš„ãªæœ¨ã«ã¤ã„ã¦å‘¼ã°ã‚ŒãŸã®ã‹ã«ã‚ˆã£ã¦ã€å°‘ã—ç•°ãªã‚‹ä½•ã‹ã‚’è¡Œã‚ãªãã¦ã¯ãªã‚‰ãªã„ã€‚
ã“ã‚Œã‚‰ã¯ã€<em>ç·æ‹¬çš„ãªæ‰‹ç¶šã</em> (1ç¨®é¡ã‚ˆã‚Šå¤šã„ç¨®é¡ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–ã‚Šæ‰±ãˆã‚‹æ‰‹ç¶šã) â€”â€”ã“ã‚Œã«ã¤ã„ã¦ã¯ã€<a href="17_sec2_4.html#%_sec_2.4">2.4</a>ç¯€ã¨<a href="18_sec2_5.html#%_sec_2.5">2.5</a>ç¯€ã§ã€è¨€ã†ã¹ãã“ã¨ãŒã‚‚ã£ã¨ãšã£ã¨å¤šãå‡ºã¦ãã‚‹ã ã‚ã†â€”â€”ã®å˜ç´”ãªä¾‹ã§ã‚ã‚‹ã€‚
</p>

<a name="%_sec_Temp_260"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_260">The decoding procedure</a></h4>
<h4 class="trans" lang="ja">å¾©å·æ‰‹ç¶šã</h4>

<p class="orig" lang="en">
The following procedure implements the decoding algorithm.
It takes as arguments a list of zeros and ones, together with
a Huffman tree.
</p>

<p class="trans" lang="ja">
ä»¥ä¸‹ã®æ‰‹ç¶šãã¯ã€å¾©å·ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ã€‚
ã“ã‚Œã¯ã€0ã¨1ã®é€£ãªã‚Šã‚’ã€ãƒãƒ•ãƒãƒ³æœ¨ã¨ã¨ã‚‚ã«ã€å¼•æ•°ã¨ã—ã¦ã¨ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_2272"></a>(define (decode bits tree)
  (define (decode-1 bits current-branch)
    (if (null? bits)
        '()
        (let ((next-branch
               (choose-branch (car bits) current-branch)))
          (if (leaf? next-branch)
              (cons (symbol-leaf next-branch)
                    (decode-1 (cdr bits) tree))
              (decode-1 (cdr bits) next-branch)))))
  (decode-1 bits tree))
(define (choose-branch bit branch)
  (cond ((= bit 0) (left-branch branch))
        ((= bit 1) (right-branch branch))
        (else (error &quot;bad bit -- CHOOSE-BRANCH&quot; bit))))
</p>

<p class="orig" lang="en">
The procedure <tt>decode-1</tt> takes two arguments: the list of remaining bits
and the current position in the tree.  It keeps moving
``down'' the tree, choosing a left or a right branch according to
whether the next bit in the list is a zero or a one.  (This is done
with the procedure <tt>choose-branch</tt>.)  When it reaches a leaf, it
returns the symbol at that leaf as the next symbol in the message by
<tt>cons</tt>ing it onto the result of decoding
the rest of the message, starting at the root of the tree.
Note the error check in the final clause of <tt>choose-branch</tt>, which
complains if the procedure finds something other than a zero or a one in the
input data.</p>

<p class="trans" lang="ja">
<tt>decode-1</tt> ã¨ã„ã†æ‰‹ç¶šãã¯äºŒã¤ã®å¼•æ•°ã‚’å–ã‚‹ã€‚ã™ãªã‚ã¡ã€æ®‹ã‚Šã®ãƒ“ãƒƒãƒˆã®é€£ãªã‚Šã¨ã€æœ¨ã®ä¸­ã§ã®ç¾åœ¨ä½ç½®ã§ã‚ã‚‹ã€‚
ã“ã®æ‰‹ç¶šãã¯ã€æœ¨ã‚’ã€Œä¸‹ã¸ã¨é™ã‚Šã¦ã€ã„ãã€ä¸Šè¨˜ã®é€£ãªã‚Šã«ãŠã‘ã‚‹æ¬¡ã®ãƒ“ãƒƒãƒˆãŒ0ãªã®ã‹1ãªã®ã‹ã«å¿œã˜ã¦ã€å·¦ã¾ãŸã¯å³ã®åˆ†å²ã‚’é¸ã¶ã€ã¨ã„ã†ã“ã¨ã‚’ç¶šã‘ã‚‹ã€‚
(ã“ã®é¸æŠã¯ã€<tt>choose-branch</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’ä½¿ã£ã¦è¡Œã‚ã‚Œã‚‹ã€‚)
<tt>decode-1</tt> ã¨ã„ã†æ‰‹ç¶šãã¯ã€æœ¨ã®æ ¹ã‹ã‚‰é–‹å§‹ã™ã‚‹ã®ã ãŒã€è‘‰ã«åˆ°é”ã™ã‚‹ã¨ã€ãã®è‘‰ã®ã‚·ãƒ³ãƒœãƒ«ã‚’ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®æ®‹ã‚Šã‚’å¾©å·ã—ãŸçµæœã®å‰ã« <tt>cons</tt> ã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€ãã®è‘‰ã®ã‚·ãƒ³ãƒœãƒ«ã‚’ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ä¸­ã®æ¬¡ã®ã‚·ãƒ³ãƒœãƒ«ã¨ã—ã¦è¿”ã™ã€‚
<tt>choose-branch</tt> ã®æœ€å¾Œã®ç¯€ã§ã®ã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯â€”â€”ã“ã®æ‰‹ç¶šããŒ0ã¾ãŸã¯1ä»¥å¤–ã®ä½•ã‹ã‚’å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ä¸­ã«è¦‹ã¤ã‘ãŸã‚‰ã€æ–‡å¥ã‚’è¨€ã†â€”â€”ã«æ³¨æ„ã—ã‚ˆã†ã€‚
</p>

<a name="%_sec_Temp_261"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_261">Sets of weighted elements</a></h4>
<h4 class="trans" lang="ja">é‡ã¿ã¥ã‘ã•ã‚ŒãŸè¦ç´ ã®é›†åˆ</h4>

<p class="orig" lang="en">
In our representation of trees, each non-leaf node contains a set of
symbols, which we have represented as a simple list.  However, the
tree-generating algorithm discussed above requires that we also work
with sets of leaves and trees, successively merging the two smallest
items.  Since we will be required to repeatedly find the smallest item
in a set, it is convenient to use an ordered representation for this
kind of set.</p>

<p class="trans" lang="ja">
ç§ãŸã¡ã®æœ¨ã®è¡¨ç¾ã§ã¯ã€è‘‰ã§ã¯ãªã„å„ãƒãƒ¼ãƒ‰ãŒã‚·ãƒ³ãƒœãƒ«ã®é›†åˆã‚’å«ã‚“ã§ã„ã‚‹ã‚ã‘ã ãŒã€ãã®ã‚·ãƒ³ãƒœãƒ«ã®é›†åˆã‚’ç§ãŸã¡ã¯å˜ç´”ãªãƒªã‚¹ãƒˆã¨ã—ã¦è¡¨ç¾ã—ã¦ããŸã€‚
ã—ã‹ã—ã€ä¸Šè¨˜ã§è­°è«–ã—ãŸã€æœ¨ã‚’ç”Ÿæˆã™ã‚‹ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯ã€æ¬¡ã€…ã¨æœ€å°ã®äºŒã¤ã®ã‚‚ã®ã‚’ä½µåˆã—ãªãŒã‚‰ã€è‘‰ã¨æœ¨ã®é›†åˆã‚’ä½¿ã£ã¦ä½œæ¥­ã™ã‚‹ã“ã¨ã‚‚ã€å¿…è¦ã¨ã—ã¦ã„ã‚‹ã€‚
ç¹°ã‚Šè¿”ã—ã€é›†åˆå†…ã§æœ€å°ã®äºŒã¤ã®ã‚‚ã®ã‚’è¦‹ã¤ã‘ã¦ã„ãã“ã¨ãŒã€æ±‚ã‚ã‚‰ã‚Œã‚‹ã ã‚ã†ã‹ã‚‰ã€ã“ã®ç¨®ã®é›†åˆã«ã¤ã„ã¦ã¯ã€é †åºã¥ã‘ã•ã‚ŒãŸè¡¨ç¾ã‚’ä½¿ã†ã®ãŒä¾¿åˆ©ã ã€‚
</p>

<p class="orig" lang="en">
We will represent a set of leaves and trees as a list of elements,
arranged in increasing order of weight.  The following <tt>adjoin-set</tt> procedure for constructing sets is similar to the one
described in exercise <a href="#%_thm_2.61">2.61</a>; however, items are compared
by their weights, and the element being added to the set is
never already in it.
</p>

<p class="trans" lang="ja">
è‘‰ã¨æœ¨ã®é›†åˆã‚’ã€é‡ã¿ã®æ˜‡é †ã§ä¸¦ã¹ã‚‰ã‚ŒãŸè¦ç´ ã®ãƒªã‚¹ãƒˆã¨ã—ã¦ã€è¡¨ç¾ã—ã‚ˆã†ã€‚
é›†åˆã‚’æ§‹ç¯‰ã™ã‚‹ãŸã‚ã®ã€ä»¥ä¸‹ã® <tt>adjoin-set</tt> ã¨ã„ã†æ‰‹ç¶šãã¯ã€ç·´ç¿’å•é¡Œ<a href="#%_thm_2.61">2.61</a>ã§è¿°ã¹ãŸã‚‚ã®ã«ä¼¼ã¦ã„ã‚‹ã€‚ã—ã‹ã—ã€é …ç›®åŒå£«ã¯ã€é‡ã¿ã«ã‚ˆã‚Šæ¯”è¼ƒã•ã‚Œã€ãã®é›†åˆã«è¿½åŠ ã•ã‚Œã‚‹è¦ç´ ã¯ã€æ±ºã—ã¦ã€ãã®é›†åˆã®ä¸­ã«æ—¢ã«å­˜åœ¨ã—ã¦ã„ã‚‹ã‚‚ã®ã§ã¯ãªã„ã€‚
</p>

<p class="lisp"><a name="%_idx_2274"></a>(define (adjoin-set x set)
  (cond ((null? set) (list x))
        ((&lt; (weight x) (weight (car set))) (cons x set))
        (else (cons (car set)
                    (adjoin-set x (cdr set))))))
</p>

<p class="orig" lang="en">
The following procedure takes a list of
symbol-frequency pairs such as <tt>((A 4) (B 2) (C 1) (D 1))</tt> and
constructs an initial ordered set of leaves, ready to be merged
according to the Huffman algorithm:
</p>

<p class="trans" lang="ja">
ä»¥ä¸‹ã®æ‰‹ç¶šãã¯ã€<tt>((A 4) (B 2) (C 1) (D 1))</tt> ã®ã‚ˆã†ãªã€ã‚·ãƒ³ãƒœãƒ«ã¨é »åº¦ã®å¯¾ã®ãƒªã‚¹ãƒˆã‚’ã¨ã‚Šã€è‘‰ã®é †åºä»˜ãåˆæœŸé›†åˆã‚’æ§‹ç¯‰ã™ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_2276"></a>(define (make-leaf-set pairs)
  (if (null? pairs)
      '()
      (let ((pair (car pairs)))
        (adjoin-set (make-leaf (car pair)    <em>; symbol</em>
                               (cadr pair))  <em>; frequency</em>
                    (make-leaf-set (cdr pairs))))))
</p>

<p class="orig" lang="en">
<a name="%_thm_2.67"></a>
<b>Exercise 2.67.</b>  Define an encoding tree and a sample message:</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.67.</b> ç¬¦å·åŒ–æœ¨ã¨ã‚µãƒ³ãƒ—ãƒ«ãƒ»ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å®šç¾©ã—ã‚ˆã†ã€‚
</p>

<p class="lisp">(define sample-tree
  (make-code-tree (make-leaf 'A 4)
                  (make-code-tree
                   (make-leaf 'B 2)
                   (make-code-tree (make-leaf 'D 1)
                                   (make-leaf 'C 1)))))

(define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))
</p>

<p class="orig" lang="en">
Use the <tt>decode</tt> procedure to decode the
message, and give the result.</p>

<p class="trans" lang="ja">
<tt>decode</tt> ã®æ‰‹ç¶šãã‚’ä½¿ã£ã¦ã€ã“ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å¾©å·ã—ã€ãã®çµæœã‚’ç¤ºã›ã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_2.68"></a>
<b>Exercise 2.68.</b>  The <tt>encode</tt> procedure takes as arguments a message and a tree and
produces the list of bits that gives the encoded message.</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.68.</b> <tt>encode</tt> ã®æ‰‹ç¶šãã¯ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨æœ¨ã‚’å¼•æ•°ã¨ã—ã¦ã¨ã‚Šã€ç¬¦å·åŒ–ã—ãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ç¤ºã™ãƒ“ãƒƒãƒˆã®é€£ãªã‚Šã‚’ä½œã‚Šå‡ºã™ã€‚
</p>

<p class="lisp"><a name="%_idx_2278"></a>(define (encode message tree)
  (if (null? message)
      '()
      (append (encode-symbol (car message) tree)
              (encode (cdr message) tree))))
</p>

<p class="orig" lang="en">
<tt>Encode-symbol</tt> is a procedure, which you must write, that returns
the list of bits that encodes a given symbol according to a given
tree.  You should design <tt>encode-symbol</tt> so that it signals an
error if the symbol is not in the tree at all.  Test your procedure by
encoding the result you obtained in exercise <a href="#%_thm_2.67">2.67</a> with
the sample tree and seeing whether it is the same as the original
sample message.
</p>

<p class="trans" lang="ja">
<tt>encode-symbol</tt> ã¯ã€ä¸ãˆã‚‰ã‚ŒãŸæœ¨ã«ã—ãŸãŒã£ã¦ã€ä¸ãˆã‚‰ã‚ŒãŸè¨˜å·ã‚’ç¬¦å·åŒ–ã—ã¦ã„ã‚‹ã€ãƒ“ãƒƒãƒˆã®é€£ãªã‚Šã‚’ã€è¿”ã™æ‰‹ç¶šãã§ã‚ã£ã¦ã€å›ã¯ã“ã‚Œã‚’æ›¸ã‹ã­ã°ãªã‚‰ãªã„ã€‚
ã‚‚ã—ã€è¨˜å·ãŒæœ¨ã®ä¸­ã«ã¾ã£ãŸãå­˜åœ¨ã—ã¦ã„ãªã‘ã‚Œã°ã€ã‚¨ãƒ©ãƒ¼ã®åˆå›³ã‚’é€ã‚‹ã‚ˆã†ã«ã€ <tt>encode-symbol</tt> ã‚’è¨­è¨ˆã™ã¹ãã§ã‚ã‚‹ã€‚
ç·´ç¿’å•é¡Œ<a href="#%_thm_2.67">2.67</a>ã§ã‚µãƒ³ãƒ—ãƒ«æœ¨ã‚’ä½¿ã£ã¦å¾—ãŸçµæœã‚’ç¬¦å·åŒ–ã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€ãã—ã¦ã€ãã®ç¬¦å·åŒ–ã—ãŸã‚‚ã®ãŒå…ƒã®ã‚µãƒ³ãƒ—ãƒ«ãƒ»ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨åŒã˜ã‹ã©ã†ã‹ã‚’èª¿ã¹ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€å›ã®æ‰‹ç¶šãã‚’æ¤œæŸ»ã—ãŸã¾ãˆã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_2.69"></a>
<b>Exercise 2.69.</b>  The following procedure takes as its argument a list of
symbol-frequency pairs (where no symbol appears in more than one pair)
and generates a Huffman encoding tree according to the Huffman
algorithm.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.69.</b> ä»¥ä¸‹ã®æ‰‹ç¶šãã¯ã€è¨˜å·ã¨é »åº¦ã®å¯¾ã®ãƒªã‚¹ãƒˆ (ã“ã®ãƒªã‚¹ãƒˆã®ä¸­ã§ã¯ã€ã©ã®è¨˜å·ã‚‚ã€ä¸€ã¤ã‚ˆã‚Šå¤šãã®å¯¾ã«ã¯å‡ºç¾ã—ãªã„) ã‚’å¼•æ•°ã¨ã—ã¦ã¨ã‚Šã€ãƒãƒ•ãƒãƒ³ãƒ»ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã«ã—ãŸãŒã£ã¦ã€ãƒãƒ•ãƒãƒ³ç¬¦å·åŒ–æœ¨ã‚’ç”Ÿæˆã™ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_2280"></a>(define (generate-huffman-tree pairs)
  (successive-merge (make-leaf-set pairs)))
</p>

<p class="orig" lang="en">
<tt>Make-leaf-set</tt> is the procedure given above that transforms the
list of pairs into an ordered set of leaves.  <tt>Successive-merge</tt>
is the procedure you must write, using <tt>make-code-tree</tt> to
successively merge the smallest-weight elements of the set until there
is only one element left, which is the desired Huffman tree.  (This
procedure is slightly tricky, but not really complicated.  If you find
yourself designing a complex procedure, then you are almost certainly
doing something wrong.  You can take significant advantage of the fact
that we are using an ordered set representation.)
</p>

<p class="trans" lang="ja">
<tt>make-leaf-set</tt> ã¯ã€å¯¾ã®ãƒªã‚¹ãƒˆã‚’è‘‰ã®é †åºä»˜ãé›†åˆã«å¤‰æ›ã™ã‚‹ã€ä¸Šè¨˜ã®æ‰‹ç¶šãã§ã‚ã‚‹ã€‚
<tt>successive-merge</tt> ã¯ã€å›ãŒæ›¸ã‹ã­ã°ãªã‚‰ãªã„æ‰‹ç¶šãã§ã‚ã‚Šã€<tt>make-code-tree</tt> ã‚’ä½¿ã£ã¦ã€ãŸã ä¸€ã¤ã®è¦ç´ ã—ã‹æ®‹ã£ã¦ã„ãªã„ã‚ˆã†ã«ãªã‚‹ã¾ã§ã€é›†åˆå†…ã§æœ€å°ã®é‡ã¿ã®è¦ç´ åŒå£«ã‚’æ¬¡ã€…ã¨åˆä½µã—ã¦ã‚†ãã‚‚ã®ã§ã€ãã®çµæœãŒæ‰€æœ›ã®ãƒãƒ•ãƒãƒ³æœ¨ã¨ãªã‚‹ã€‚
(ã“ã®æ‰‹ç¶šãã¯ã€å°‘ã—æ‰‹ãŒè¾¼ã‚“ã§ã¯ã„ã‚‹ãŒã€æœ¬å½“ã«è¤‡é›‘ãªã‚ã‘ã§ã¯ãªã„ã€‚
è‡ªåˆ†ãŒè¤‡é›‘ãªæ‰‹ç¶šãã‚’è¨­è¨ˆã—ã¦ã„ã‚‹ãªã€ã¨æ°—ã¥ãå ´åˆã¯ã€ã»ã¨ã‚“ã©ç¢ºå®Ÿã«ã€ä½•ã‹é–“é•ã£ãŸã“ã¨ã‚’ã—ã¦ã„ã‚‹ã®ã ã€‚
é †åºä»˜ãé›†åˆã®è¡¨ç¾ã‚’ä½¿ã£ã¦ã„ã‚‹ã“ã¨ã‚’ã€å›ã¯ã€ååˆ†ã«åˆ©ç”¨ã§ãã‚‹ã®ã ã‚ˆã€‚)
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_2.70"></a>
<b>Exercise 2.70.</b>  <a name="%_idx_2282"></a>The following eight-symbol alphabet with associated relative
frequencies was designed to efficiently encode the lyrics of 1950s
rock songs.  (Note that the ``symbols'' of an ``alphabet'' need not be
individual letters.)</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.70.</b> é–¢é€£ã™ã‚‹ç›¸å¯¾é »åº¦ä»˜ãã®ã€å…«ã¤ã®è¨˜å·ã‹ã‚‰ãªã‚‹ä»¥ä¸‹ã®ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã¯ã€1950å¹´ä»£ã®ãƒ­ãƒƒã‚¯ã®æ­Œã®æ­Œè©ã‚’åŠ¹ç‡ã‚ˆãç¬¦å·åŒ–ã™ã‚‹ãŸã‚ã«è¨­è¨ˆã•ã‚ŒãŸã€‚
(ã€Œã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã€ã®ã€Œè¨˜å·ã€ã¯ã€å€‹ã€…ã®æ–‡å­—ã§ãªãã¦ã‚‚æ§‹ã‚ãªã„ã“ã¨ã«æ³¨æ„ã€‚)
</p>

<figure>
<table class="common">
<tr><td valign=top >A    </td><td valign=top >2 </td><td valign=top >NA  </td><td valign=top >16</td></tr>
<tr><td valign=top >BOOM </td><td valign=top >1 </td><td valign=top >SHA </td><td valign=top >3</td></tr>
<tr><td valign=top >GET  </td><td valign=top >2 </td><td valign=top >YIP </td><td valign=top >9</td></tr>
<tr><td valign=top >JOB  </td><td valign=top >2 </td><td valign=top >WAH </td><td valign=top >1
</td></tr></table>
</figure>

<p class="orig" lang="en">
Use <tt>generate-huffman-tree</tt> (exercise <a href="#%_thm_2.69">2.69</a>)
to generate a corresponding Huffman tree, and use
<tt>encode</tt> (exercise <a href="#%_thm_2.68">2.68</a>)
to encode the following message:</p>

<p class="trans" lang="ja">
<tt>generate-huffman-tree</tt> (ç·´ç¿’å•é¡Œ<a href="#%_thm_2.69">2.69</a>) ã‚’ä½¿ã£ã¦ã€å¯¾å¿œã™ã‚‹ãƒãƒ•ãƒãƒ³æœ¨ã‚’ç”Ÿæˆã›ã‚ˆã€‚ãã—ã¦ã€<tt>encode</tt> (ç·´ç¿’å•é¡Œ<a href="#%_thm_2.68">2.68</a>) ã‚’ä½¿ã£ã¦ã€ä»¥ä¸‹ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ç¬¦å·åŒ–ã›ã‚ˆã€‚
</p>

<p class="lisp">Get a job
Sha na na na na na na na na
Get a job
Sha na na na na na na na na
Wah yip yip yip yip yip yip yip yip yip
Sha boom</p>

<p class="orig" lang="en">
How many bits are required for the encoding?  What is the smallest
number of bits that would be needed to encode this song if we 
used a fixed-length code for the eight-symbol alphabet?
</p>

<p class="trans" lang="ja">
ç¬¦å·åŒ–ã«ã¯ä½•ãƒ“ãƒƒãƒˆãŒå¿…è¦ã‹?
å…«ã¤ã®è¨˜å·ã‹ã‚‰ãªã‚‹ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆç”¨ã®å›ºå®šé•·ç¬¦å·ã‚’ä½¿ã£ã¦ã„ãŸå ´åˆã«ã€ã“ã®æ­Œã‚’ç¬¦å·åŒ–ã™ã‚‹ã®ã«å¿…è¦ã¨ãªã£ãŸã§ã‚ã‚ã†æœ€å°‘ã®ãƒ“ãƒƒãƒˆæ•°ã¯ã€ã„ãã¤ã‹?
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_2.71"></a>
<b>Exercise 2.71.</b>  Suppose we have a Huffman tree for an alphabet of <em>n</em> symbols, and
that the relative frequencies of the symbols are 1, 2, 4, <tt>...</tt>,
2<sup><em>n</em>-1</sup>.  Sketch the tree for <em>n</em>=5; for <em>n</em>=10.  In such a tree
(for general <em>n</em>) how many bits are required to encode the most
frequent symbol?  the least frequent symbol?
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.71.</b> <em class="en">n</em> å€‹ã®è¨˜å·ã‹ã‚‰ãªã‚‹ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆç”¨ã®ã€ãƒãƒ•ãƒãƒ³æœ¨ãŒã‚ã‚‹ã‚‚ã®ã¨ã—ã€ãã‚Œã‚‰ã®è¨˜å·ã®ç›¸å¯¾é »åº¦ãŒã€
1, 2, 4, <tt>...</tt>, 2<sup><em class="en">n</em>&minus;1</sup>
ã§ã‚ã‚‹ã¨ã—ã‚ˆã†ã€‚
<em class="en">n</em>=5 ã®å ´åˆã€ãŠã‚ˆã³ã€<em class="en">n</em>=10 ã®å ´åˆã«ã¤ã„ã¦ã€æœ¨ã‚’ç°¡å˜ã«æã‘ã€‚
ãã®ã‚ˆã†ãªæœ¨ã«ãŠã„ã¦ã¯ã€(ä¸€èˆ¬ã® <em class="en">n</em> ã«å¯¾ã—ã¦) æœ€ã‚‚é »åº¦ãŒé«˜ã„è¨˜å·ã‚’ç¬¦å·åŒ–ã™ã‚‹ã®ã«ä½•ãƒ“ãƒƒãƒˆãŒå¿…è¦ã‹? 
æœ€ã‚‚é »åº¦ãŒä½ã„è¨˜å·ã«ã¯ä½•ãƒ“ãƒƒãƒˆãŒå¿…è¦ã‹?
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_2.72"></a>
<b>Exercise 2.72.</b>  <a name="%_idx_2284"></a>Consider the encoding procedure that you designed in
exercise <a href="#%_thm_2.68">2.68</a>.  What is the order of growth in the
number of steps needed to encode a symbol?  Be sure to include the
number of steps needed to search the symbol list at each node
encountered.  To answer this question in general is difficult.
Consider the special case where the relative frequencies of the <em>n</em>
symbols are as described in exercise <a href="#%_thm_2.71">2.71</a>, and give
the order of growth (as a function of <em>n</em>) of the number of steps
needed to encode the most frequent and least frequent symbols in the
alphabet.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.72.</b> ç·´ç¿’å•é¡Œ<a href="#%_thm_2.68">2.68</a>ã§è¨­è¨ˆã—ãŸç¬¦å·åŒ–æ‰‹ç¶šãã‚’è€ƒãˆã‚ˆã†ã€‚
ã‚ã‚‹ä¸€ã¤ã®è¨˜å·ã‚’ç¬¦å·åŒ–ã™ã‚‹ã®ã«å¿…è¦ãªã‚¹ãƒ†ãƒƒãƒ—ã®æ•°ã®ã€å¢—å¤§ã®ã‚ªãƒ¼ãƒ€ã¯ã€ã©ã‚Œãã‚‰ã„ã‹?

å‡ºãã‚ã—ãŸå„ãƒãƒ¼ãƒ‰ã«ãŠã„ã¦è¨˜å·ãƒªã‚¹ãƒˆã‚’æ¢ç´¢ã™ã‚‹ã®ã«å¿…è¦ãªã‚¹ãƒ†ãƒƒãƒ—ã®æ•°ã‚’å«ã‚ã‚‹ã“ã¨ã‚’ã€å¿˜ã‚Œãªã„ã‚ˆã†ã«ã€‚
ã“ã®å•é¡Œã«å¯¾ã—ã¦ä¸€èˆ¬çš„ã«ç­”ãˆã‚‹ã“ã¨ã¯ã€é›£ã—ã„ã€‚
<em class="en">n</em> å€‹ã®è¨˜å·ã®ç›¸å¯¾é »åº¦ãŒã€ç·´ç¿’å•é¡Œ<a href="#%_thm_2.71">2.71</a>ã§è¿°ã¹ãŸã¨ãŠã‚Šã§ã‚ã‚‹ã‚ˆã†ãªã€ç‰¹æ®Šãªå ´åˆã‚’è€ƒãˆã€ãã—ã¦ã€ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã®ä¸­ã§æœ€ã‚‚é »åº¦ãŒé«˜ã„è¨˜å·ã¨æœ€ã‚‚é »åº¦ãŒä½ã„è¨˜å·ã‚’ç¬¦å·åŒ–ã™ã‚‹ã®ã«å¿…è¦ãªã‚¹ãƒ†ãƒƒãƒ—ã®æ•°ã®ã€å¢—å¤§ã®ã‚ªãƒ¼ãƒ€ã‚’ã€(<em class="en">n</em> ã®é–¢æ•°ã¨ã—ã¦) ç¤ºã›ã€‚

</p>

<p class="exercise"><span class="ex_comment">
</span></p>


<a name="footnotes"></a>
<hr>

<p class="orig" lang="en">
<a name="footnote_Temp_227" href="#call_footnote_Temp_227"><sup><small>32</small></sup></a> Allowing quotation in a language wreaks havoc
with the ability to reason about the language in simple terms, because
it destroys the notion that equals can be substituted for equals.  For
example, three is one plus two, but the word ``three'' is not the
phrase ``one plus two.''  Quotation is powerful because it gives us a way
to build expressions that manipulate other expressions (as we will see
when we write an interpreter in chapter 4). But allowing statements in
a language that talk about other statements in that language makes it
very difficult to maintain any coherent principle of what ``equals can
be substituted for equals'' should mean.  For example, if we know that
<a name="%_idx_1996"></a>the evening star is the morning star, then from the statement ``the
evening star is Venus'' we can deduce ``the morning star is Venus.''
However, given that ``John knows that the evening star is Venus'' we
cannot infer that ``John knows that the morning star is Venus.''
</p>

<p class="trans" lang="ja">
ã‚ã‚‹è¨€èªã§å¼•ç”¨ã‚’è¨±ã™ã“ã¨ã¯ã€ç°¡å˜ãªç”¨èªã§ãã®è¨€èªã«ã¤ã„ã¦è€ƒãˆã‚‹èƒ½åŠ›ã‚’ã€å¤§æ··ä¹±ã«é™¥ã‚Œã‚‹ã€‚ã¨ã„ã†ã®ã‚‚ã€ç­‰ä¾¡ãªã‚‚ã®ã¯ç­‰ä¾¡ãªã‚‚ã®ä»£ã‚ã‚Šã«ã§ãã‚‹ã€ã¨ã„ã†æ¦‚å¿µã‚’ç ´å£Šã™ã‚‹ã‹ã‚‰ã ã€‚
ãŸã¨ãˆã°ã€ä¸‰ã¯ã€ä¸€è¶³ã™äºŒã ãŒã€ã€Œä¸‰ã€ã¨ã„ã†å˜èªã¯ã€ã€Œä¸€è¶³ã™äºŒã€ã¨ã„ã†å¥ã§ã¯ãªã„ã€‚
å¼•ç”¨ã¯ã€(4ç« ã§ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã‚’æ›¸ãã¨ãã«è¦‹ã‚‹ã“ã¨ã«ãªã‚‹ã¨ãŠã‚Š) ä»–ã®å¼ã‚’æ“ä½œã™ã‚‹ã‚ˆã†ãªå¼ã‚’æ§‹ç¯‰ã™ã‚‹æ–¹æ³•ã‚’ä¸ãˆã¦ãã‚Œã‚‹ã®ã§ã€å¼·åŠ›ã§ã‚ã‚‹ã€‚
ã—ã‹ã—ã€ã‚ã‚‹è¨€èªã«ãŠã„ã¦ã€ä»–ã®é™³è¿°ã«ã¤ã„ã¦å½“è©²è¨€èªã§èªã‚‹ã‚ˆã†ãªé™³è¿°ã‚’è¨±ã™ã¨ã€ã€Œç­‰ä¾¡ãªã‚‚ã®ã¯ç­‰ä¾¡ãªã‚‚ã®ä»£ã‚ã‚Šã«ã§ãã‚‹ã€ãŒä½•ã‚’æ„å‘³ã™ã¹ãã‹ã¨ã„ã†ã“ã¨ã«ã¤ã„ã¦ã®ã€é¦–å°¾ä¸€è²«ã—ãŸä½•ã‚‰ã‹ã®æ–¹é‡ã‚’ç¶­æŒã™ã‚‹ã“ã¨ãŒã€ã¨ã¦ã‚‚é›£ã—ããªã‚‹ã€‚
ãŸã¨ãˆã°ã€å®µã®æ˜æ˜Ÿã¯æ˜ã‘ã®æ˜æ˜Ÿã ã¨ã„ã†ã“ã¨ã‚’ç§ãŸã¡ãŒçŸ¥ã£ã¦ã„ã‚Œã°ã€ã€Œå®µã®æ˜æ˜Ÿã¯é‡‘æ˜Ÿã ã€ã¨ã„ã†é™³è¿°ã‹ã‚‰ã€ç§ãŸã¡ã¯ã€ã€Œæ˜ã‘ã®æ˜æ˜Ÿã¯é‡‘æ˜Ÿã ã€ã¨æ¼”ç¹¹ã§ãã‚‹ã€‚
ã—ã‹ã—ã€ã€Œå®µã®æ˜æ˜Ÿã¯é‡‘æ˜Ÿã ã€ã¨ã‚¸ãƒ§ãƒ³ã¯çŸ¥ã£ã¦ã„ã‚‹ã€ã¨è¨€ã‚ã‚ŒãŸã¨ã—ã¦ã€ç§ãŸã¡ã¯ã€ã€Œæ˜ã‘ã®æ˜æ˜Ÿã¯é‡‘æ˜Ÿã ã€ã¨ã‚¸ãƒ§ãƒ³ã¯çŸ¥ã£ã¦ã„ã‚‹ã€ã¨æ¨è«–ã™ã‚‹ã“ã¨ã¯ã§ããªã„ã®ã ã€‚
</p>


<p class="orig" lang="en"><a name="footnote_Temp_228" href="#call_footnote_Temp_228"><sup><small>33</small></sup></a> The single quote is different <a name="%_idx_2002"></a><a name="%_idx_2004"></a><a name="%_idx_2006"></a><a name="%_idx_2008"></a>from the double quote we have
been using to enclose character strings to be printed.  Whereas the
single quote can be used to denote lists or symbols, the double quote
is used only with character strings.  In this book, the only use for
character strings is as items to be printed.
</p>

<p class="trans" lang="ja">
ä¸€é‡å¼•ç”¨ç¬¦ã¯ã€å°å­—ã™ã¹ãæ–‡å­—åˆ—ã‚’å›²ã†ãŸã‚ã«ç§ãŸã¡ãŒä½¿ã£ã¦ãã¦ã„ã‚‹äºŒé‡å¼•ç”¨ç¬¦ã¨ã¯ã€ç•°ãªã‚‹ã€‚
ä¸€é‡å¼•ç”¨ç¬¦ãŒã€ãƒªã‚¹ãƒˆã¾ãŸã¯è¨˜å·ã‚’ç¤ºã™ã®ã«ä½¿ãˆã‚‹ã®ã«å¯¾ã—ã€äºŒé‡å¼•ç”¨ç¬¦ã¯ã€æ–‡å­—åˆ—ã‚’å¼•ç”¨ã™ã‚‹ã®ã«ã ã‘ä½¿ã‚ã‚Œã‚‹ã€‚
æœ¬æ›¸ã§ã¯ã€æ–‡å­—åˆ—ã®å”¯ä¸€ã®ä½¿ã„é“ã¯ã€å°å­—ã™ã¹ãé …ç›®ã¨ã—ã¦ã®ã‚‚ã®ã§ã‚ã‚‹ã€‚
</p>


<p class="orig" lang="en"><a name="footnote_Temp_229" href="#call_footnote_Temp_229"><sup><small>34</small></sup></a> Strictly, our
use of the quotation mark violates the general rule that all compound
expressions in our language should be delimited by parentheses
and look like lists.  We
<a name="%_idx_2014"></a><a name="%_idx_2016"></a>can recover this consistency by introducing a special form <tt>quote</tt>, which serves the same purpose as the quotation mark.  Thus, we
would type <tt>(quote a)</tt> instead of <tt>'a</tt>, and we would type <tt>(quote (a b c))</tt> instead of <tt>'(a b c)</tt>.  This is precisely how the
interpreter works.  The quotation mark is just a single-character
abbreviation for wrapping the next complete expression with <tt>quote</tt> to form <tt>(quote &lt;<em>expression</em>&gt;)</tt>.  This is important
because it maintains the principle that any expression seen by the
interpreter can be manipulated as a data object.  For instance, we
could construct the expression
<tt>(car '(a b c))</tt>, which is the same as <tt>(car (quote (a b c)))</tt>,
by evaluating <tt>(list 'car (list 'quote '(a b c)))</tt>.
</p>

<p class="trans" lang="ja">
å³å¯†ã«ã¯ã€ç§ãŸã¡ã®å¼•ç”¨ç¬¦ã®ä½¿ã„æ–¹ã¯ã€ç§ãŸã¡ã®è¨€èªã«ãŠã‘ã‚‹ã™ã¹ã¦ã®è¤‡åˆçš„ãªå¼ã¯æ‹¬å¼§ã§å¢ƒç•Œã‚’å®šã‚ã‚‰ã‚Œã‚‹ã¹ãã§ã‚ã‚Šã€ã‹ã¤ã€ãƒªã‚¹ãƒˆã®ã‚ˆã†ã«è¦‹ãˆã‚‹ã¹ãã§ã‚ã‚‹ã€ã¨ã„ã†ä¸€èˆ¬çš„è¦å‰‡ã«é•åã—ã¦ã„ã‚‹ã€‚
<tt>quote</tt> ã¨ã„ã†ç‰¹æ®Šå½¢å¼â€”â€”å¼•ç”¨ç¬¦ã¨ã—ã¦ã®åŒã˜ç›®çš„ã«ã‹ãªã†â€”â€”ã‚’å°å…¥ã™ã‚‹ã“ã¨ã§ã€ã“ã®æ•´åˆæ€§ã‚’å–ã‚Šæˆ»ã›ã‚‹ã€‚
ã‚ˆã£ã¦ã€ç§ãŸã¡ã¯ã€<tt>'a</tt> ã®ä»£ã‚ã‚Šã« <tt>(quote a)</tt> ã¨æ‰“ã£ã¦ã‚‚ã‚ˆã„ã—ã€<tt>'(a b c)</tt> ã®ä»£ã‚ã‚Šã« <tt>(quote (a b c))</tt> ã¨æ‰“ã£ã¦ã‚‚ã‚ˆã„ã€‚
ã“ã‚Œã¯ã€ã¾ã•ã«ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã®å‹•ãæ–¹ã§ã‚ã‚‹ã€‚
å¼•ç”¨ç¬¦ã¯ã€ã¾ã•ã«ã¡ã‚‡ã†ã©ã€<tt>quote</tt> ã§æ¬¡ã®å®Œå…¨ãªå¼ã‚’åŒ…ã¿è¾¼ã‚“ã§ <tt>(quote &lt;<em>expression</em>&gt;)</tt> ã‚’å½¢æˆã™ã‚‹ã“ã¨ã«å¯¾ã™ã‚‹ã€ä¸€æ–‡å­—ã®ç•¥ç§°ãªã®ã ã€‚
ã“ã®ã“ã¨ã¯é‡è¦ã ã€‚ãªãœãªã‚‰ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã‹ã‚‰è¦‹ãˆã‚‹ä»»æ„ã®å¼ã¯ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦æ“ä½œã•ã‚Œå¾—ã‚‹ã€ã¨ã„ã†åŸå‰‡ãŒã€ã“ã®ã“ã¨ã«ã‚ˆã£ã¦ç¶­æŒã•ã‚Œã‚‹ã‹ã‚‰ã ã€‚
ãŸã¨ãˆã°ã€<tt>(list 'car (list 'quote '(a b c)))</tt> ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ã§ã€<tt>(car '(a b c))</tt> ã¨ã„ã†å¼â€”â€” <tt>(car (quote (a b c)))</tt> ã¨ç­‰ã—ã„â€”â€”ã‚’ã€æ§‹ç¯‰ã§ãã‚‹ã ã‚ã†ã€‚
</p>


<p class="orig" lang="en"><a name="footnote_Temp_230" href="#call_footnote_Temp_230"><sup><small>35</small></sup></a> We can consider two symbols to be ``the same'' if they
consist of the same characters in the same order.  Such a definition
skirts a deep issue that we are not yet ready to address: the meaning
of ``sameness'' in a programming language.  We will return to this in
chapter 3 (section <a href="20_sec3_1.html#%_sec_3.1.3">3.1.3</a>).
</p>

<p class="trans" lang="ja">
äºŒã¤ã®è¨˜å·ãŒã€ã‚‚ã—ã€åŒã˜é †åºã§ä¸¦ã‚“ã åŒã˜æ–‡å­—ã‹ã‚‰æˆã‚Šç«‹ã£ã¦ã„ã‚‹ãªã‚‰ã°ã€ãã‚Œã‚‰äºŒã¤ã®è¨˜å·ãŒã€ŒåŒã˜ã€ã ã¨è¦‹ãªã›ã‚‹ã€‚
ã“ã®ã‚ˆã†ãªå®šç¾©ã¯ã€ç§ãŸã¡ãŒã¾ã å–ã‚Šçµ„ã‚€æº–å‚™ã®ã§ãã¦ã„ãªã„æ·±é ãªå•é¡Œâ€”â€”ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã«ãŠã‘ã‚‹ã€ŒåŒä¸€æ€§ã€ã®æ„å‘³â€”â€”ã‚’å›é¿ã—ã¦ã„ã‚‹ã€‚
ã“ã®ã“ã¨ã«ã¤ã„ã¦ã¯ã€3ç«  (<a href="20_sec3_1.html#%_sec_3.1.3">3.1.3</a>ç¯€) ã§ç«‹ã¡æˆ»ã‚‹ã“ã¨ã«ã—ã‚ˆã†ã€‚
</p>


<p class="orig" lang="en"><a name="footnote_Temp_233" href="#call_footnote_Temp_233"><sup><small>36</small></sup></a> In practice, programmers
use <tt>equal?</tt> to compare lists that contain numbers as well as
symbols.  Numbers are not considered to be symbols.  The question
<a name="%_idx_2038"></a><a name="%_idx_2040"></a>of whether two numerically equal numbers (as tested by <tt>=</tt>) are also
<tt>eq?</tt> is highly implementation-dependent.  A better definition
of <tt>equal?</tt> (such as the one that comes as a primitive in Scheme)
would also stipulate that if <tt>a</tt> and <tt>b</tt> are
both numbers, then <tt>a</tt> and <tt>b</tt> are <tt>equal?</tt> if they are
numerically equal.
</p>

<p class="trans" lang="ja">
å®Ÿéš›ã«ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒãŸã¡ã¯ã€è¨˜å·ã ã‘ã§ãªãæ•°ã‚’å«ã‚€ãƒªã‚¹ãƒˆåŒå£«ã‚’æ¯”ã¹ã‚‹ã®ã«ã‚‚ã€<tt>equal?</tt> ã‚’ä½¿ã†ã€‚
æ•°ã¯ã€è¨˜å·ã¨ã¯è¦‹ãªã•ã‚Œãªã„ã€‚
æ•°çš„ã«ç­‰ã—ã„ (<tt>=</tt> ã«ã‚ˆã‚Šæ¤œæŸ»ã•ã‚Œã‚‹ã‚ˆã†ãª) äºŒã¤ã®æ•°ã¯ã€<tt>eq?</tt> ã§ã‚‚ã‚ã‚‹ã®ã‹ã€ã¨ã„ã†ç–‘å•ã¯ã€éå¸¸ã«å®Ÿè£…ä¾å­˜ã§ã‚ã‚‹ã€‚
<tt>equal?</tt> ã®ã‚ˆã‚Šè‰¯ã„å®šç¾© (Schemeã§ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã¨ã—ã¦ç¾ã‚Œã¦ã„ã‚‹ã‚‚ã®ãªã©) ã§ã¯ã€ã€Œã‚‚ã— <tt>a</tt> ã¨ <tt>b</tt> ãŒã¨ã‚‚ã«æ•°ãªã‚‰ã€ä¸¡è€…ãŒæ•°çš„ã«ç­‰ã—ã„ã¨ãã«ã€<tt>a</tt> ã¨ <tt>b</tt> ã¯ <tt>equal?</tt> ã§ã‚ã‚‹ã€ã¨ã‚‚è¦å®šã—ã¦ã„ã‚‹ã ã‚ã†ã€‚
</p>


<p class="orig" lang="en"><a name="footnote_Temp_240" href="#call_footnote_Temp_240"><sup><small>37</small></sup></a> If
we want to be more formal, we can specify ``consistent with the
interpretations given above'' to mean that the operations satisfy a
collection of rules such as these:</p>

<p class="trans" lang="ja">
ã‚‚ã—ã€ã‚ˆã‚Šå½¢å¼çš„ã«è¨€ã„ãŸã‘ã‚Œã°ã€ã€Œä»¥ä¸Šã®ã‚ˆã†ã«ä¸ãˆã‚‰ã‚ŒãŸè§£é‡ˆã¨æ•´åˆæ€§ãŒã¨ã‚ŒãŸã€ã¨ã¯ã€ä¸Šè¨˜ã®è«¸æ¼”ç®—ãŒä»¥ä¸‹ã®ã‚ˆã†ãªè¦å‰‡ã®é›†ã¾ã‚Šã‚’æº€ãŸã™ã“ã¨ã‚’æ„å‘³ã™ã‚‹ã®ã ã€ã¨æŒ‡å®šã—ã¦ã‚‚ã‚ˆã„ã€‚
</p>

<ul class="orig" lang="en">
<li>For any set <tt>S</tt> and any object <tt>x</tt>,
<tt>(element-of-set? x (adjoin-set x S))</tt>
is true (informally: ``Adjoining an object to a 
set produces a set that contains the object'').</li>
<li>For any sets <tt>S</tt> and <tt>T</tt> and any object <tt>x</tt>,
<tt>(element-of-set? x (union-set S T))</tt>
is equal to
<tt>(or (element-of-set? x S) (element-of-set? x T))</tt>
(informally: ``The elements of <tt>(union S T)</tt> are the elements that
are in <tt>S</tt> or in <tt>T</tt>'').</li>
<li>For any object <tt>x</tt>,
<tt>(element-of-set? x '())</tt>
is false (informally: ``No object is an element of the empty set'').</li>
</ul>

<ul class="trans" lang="ja">
<li>ä»»æ„ã®é›†åˆ <tt>S</tt> ã¨ä»»æ„ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <tt>x</tt> ã«å¯¾ã—ã¦ã€
<tt>(element-of-set? x (adjoin-set x S))</tt>
ã¯çœŸã§ã‚ã‚‹ã€‚
(ãã ã‘ã¦è¨€ãˆã°ã€ã€Œã‚ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚ã‚‹é›†åˆã«è¿½åŠ ã™ã‚‹ã“ã¨ã§ã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å«ã‚€é›†åˆãŒä½œã‚Šå‡ºã•ã‚Œã‚‹ã€ã¨ã„ã†ã“ã¨ã€‚)</li>
<li>ä»»æ„ã®é›†åˆ <tt>S</tt> ã¨ <tt>T</tt> ãªã‚‰ã³ã«ä»»æ„ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <tt>x</tt> ã«å¯¾ã—ã¦ã€
<tt>(element-of-set? x (union-set S T))</tt>
ã¯ã€
<tt>(or (element-of-set? x S) (element-of-set? x T))</tt>
ã«ç­‰ã—ã„ã€‚
(ãã ã‘ã¦è¨€ãˆã°ã€ã€Œ<tt>(union S T)</tt> ã®è¦ç´ ã¯ã€<tt>S</tt> ã‹ <tt>T</tt> ã®è¦ç´ ã§ã‚ã‚‹ã€ã¨ã„ã†ã“ã¨ã€‚)</li>
<li>ä»»æ„ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <tt>x</tt> ã«å¯¾ã—ã¦ã€
<tt>(element-of-set? x '())</tt>
ã¯å½ã§ã‚ã‚‹ã€‚
(ãã ã‘ã¦è¨€ãˆã°ã€ã€Œã„ã‹ãªã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚‚ã€ç©ºé›†åˆã®è¦ç´ ã§ã¯ãªã„ã€ã¨ã„ã†ã“ã¨ã€‚)</li>
</ul>

<p class="orig" lang="en">
<a name="footnote_Temp_248" href="#call_footnote_Temp_248"><sup><small>38</small></sup></a> Halving the size of the problem at each step is the
distinguishing characteristic of <a name="%_idx_2148"></a>logarithmic growth, as we saw with
the fast-exponentiation algorithm of section <a href="11_sec1_2.html#%_sec_1.2.4">1.2.4</a>
and the half-interval search method of
section <a href="12_sec1_3.html#%_sec_1.3.3">1.3.3</a>.
</p>

<p class="trans" lang="ja">
å„ã‚¹ãƒ†ãƒƒãƒ—ã§å•é¡Œã®å¤§ãã•ã‚’åŠåˆ†ã«ã™ã‚‹ã“ã¨ã¯ã€å¯¾æ•°çš„ãªå¢—å¤§ã®éš›ç«‹ã£ãŸç‰¹å¾´ã§ã‚ã‚‹â€”â€”<a href="11_sec1_2.html#%_sec_1.2.4">1.2.4</a>ç¯€ã®é«˜é€Ÿå†ªä¹—ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚„ã€<a href="12_sec1_3.html#%_sec_1.3.3">1.3.3</a>ç¯€ã®åŠåŒºé–“æ¢ç´¢æ³•ã§è¦‹ãŸã¨ãŠã‚Šã€‚
</p>


<p class="orig" lang="en"><a name="footnote_Temp_249" href="#call_footnote_Temp_249"><sup><small>39</small></sup></a> We are
representing sets in terms of trees, and trees in terms of lists -- in
effect, a data abstraction built upon a data abstraction.  We can
regard the procedures <tt>entry</tt>, <tt>left-branch</tt>, <tt>right-branch</tt>, and <tt>make-tree</tt> as a way of isolating the
abstraction of a ``binary tree'' from the particular way we might wish
to represent such a tree in terms of list structure.
</p>

<p class="trans" lang="ja">
ç§ãŸã¡ã¯ã€æœ¨ã‚’ä½¿ã£ã¦é›†åˆã‚’è¡¨ç¾ã—ã¦ãŠã‚Šã€ãƒªã‚¹ãƒˆã‚’ä½¿ã£ã¦æœ¨ã‚’è¡¨ç¾ã—ã¦ã„ã‚‹â€”â€”å®Ÿéš›ã€ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ã®ã†ãˆã«ç¯‰ã‹ã‚ŒãŸãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ã§ã‚ã‚‹ã€‚
<tt>entry</tt>ã€<tt>left-branch</tt>ã€<tt>right-branch</tt>ã€<tt>make-tree</tt>ã¨ã„ã†æ‰‹ç¶šãã¯ã€ã€ŒäºŒåˆ†æœ¨ã€ã«ã¤ã„ã¦ã®æŠ½è±¡åŒ–ã‚’ã€ãã†ã„ã†æœ¨ã‚’ãƒªã‚¹ãƒˆæ§‹é€ ã‚’ç”¨ã„ã¦è¡¨ç¾ã™ã‚‹ã‚ˆã†ã«ã¨ç§ãŸã¡ãŒæœ›ã‚€ã‹ã‚‚ã—ã‚Œãªã„ç‰¹å®šã®æ–¹æ³•ã‹ã‚‰ã€éš”é›¢ã—ã¦ãŠãæ–¹æ³•ã§ã‚ã‚‹ã€ã¨è¦‹ãªã›ã‚‹ã€‚
</p>


<p class="orig" lang="en"><a name="footnote_Temp_250" href="#call_footnote_Temp_250"><sup><small>40</small></sup></a> Examples of such structures include
<a name="%_idx_2168"></a><a name="%_idx_2170"></a><a name="%_idx_2172"></a><a name="%_idx_2174"></a><em>B-trees</em> and <em>red-black trees</em>.  There is a large literature on
data structures devoted to this problem.  See Cormen,
<a name="%_idx_2176"></a><a name="%_idx_2178"></a><a name="%_idx_2180"></a>Leiserson, and Rivest 1990.
</p>

<p class="trans" lang="ja">
ã“ã®ã‚ˆã†ãªæ§‹é€ ã®ä¾‹ã¨ã—ã¦ã¯ã€<em>Bæœ¨</em>ã‚„<em>èµ¤é»’æœ¨</em>ãªã©ãŒã‚ã‚‹ã€‚
ã“ã®å•é¡Œã‚’å°‚é–€ã¨ã™ã‚‹ã€ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã«ã¤ã„ã¦ã®å¤§éƒ¨ã®æ–‡çŒ®ãŒã‚ã‚‹ã€‚
Cormen, Leiserson, and Rivest 1990 ã‚’å‚ç…§ã®ã“ã¨ã€‚
</p>


<p class="orig" lang="en"><a name="footnote_Temp_254" href="#call_footnote_Temp_254"><sup><small>41</small></sup></a> Exercises <a href="#%_thm_2.63">2.63</a>-<a href="#%_thm_2.65">2.65</a>
<a name="%_idx_2198"></a>are due to Paul Hilfinger.
</p>

<p class="trans" lang="ja">
ç·´ç¿’å•é¡Œ<a href="#%_thm_2.63">2.63</a>ã€œ<a href="#%_thm_2.65">2.65</a>ã¯ã€ãƒãƒ¼ãƒ«ãƒ»ãƒ’ãƒ«ãƒ•ã‚£ãƒ³ã‚¬ã«ã‚ˆã‚‹ã€‚
</p>


<p class="orig" lang="en"><a name="footnote_Temp_258" href="#call_footnote_Temp_258"><sup><small>42</small></sup></a> See Hamming 1980
<a name="%_idx_2248"></a>for a discussion of the mathematical properties of Huffman codes.
</p>

<p class="trans" lang="ja">
ãƒãƒ•ãƒãƒ³ç¬¦å·ã®æ•°å­¦çš„æ€§è³ªã«ã¤ã„ã¦ã®è­°è«–ã«é–¢ã—ã¦ã¯ã€Hamming 1980 ã‚’å‚ç…§ã›ã‚ˆã€‚
</p>


</div>

</body>
</html>
