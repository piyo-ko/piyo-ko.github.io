<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<link rel="stylesheet" href="sicp.css" type="text/css">
	<base target="_top">
	<title>SICP私訳: 1.2 手続きと、手続きが生成するプロセス</title>
    <link rel="canonical" href="https://piyo-ko.github.io/SICP/11_sec1_2.html" />
</head>

<body>

<div class="idx-bar">
<nav>
<a href="https://twitter.com/share" class="twitter-share-button" data-lang="ja">ツイート</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
<span class="status">推敲中</span>
[
<a href="00_cover.html">先頭へ</a> |
<a href="10_sec1_1.html">前へ</a> |
<a href="12_sec1_3.html">次へ</a> | 
<a href="04_toc.html#%_toc_start">目次</a> |
<a href="38_index.html#%_index_start">索引</a>
] [<a href="99_about.html">この対訳版について</a> | <a href="../index.html">ホーム</a>]
[
§<a href="#%_sec_1.2">1.2</a>
§<a href="#%_sec_1.2.1">1.2.1</a>
🎨<a href="#%_fig_1.3">1.3</a>
🎨<a href="#%_fig_1.4">1.4</a>
📝<a href="#%_thm_1.9">1.9</a>
📝<a href="#%_thm_1.10">1.10</a>
§<a href="#%_sec_1.2.2">1.2.2</a>
🎨<a href="#%_fig_1.5">1.5</a>
📚<a href="#%_sec_Temp_52">&hellip;</a>
📝<a href="#%_thm_1.11">1.11</a>
📝<a href="#%_thm_1.12">1.12</a>
📝<a href="#%_thm_1.13">1.13</a>
§<a href="#%_sec_1.2.3">1.2.3</a>
📝<a href="#%_thm_1.14">1.14</a>
📝<a href="#%_thm_1.15">1.15</a>
§<a href="#%_sec_1.2.4">1.2.4</a>
📝<a href="#%_thm_1.16">1.16</a>
📝<a href="#%_thm_1.17">1.17</a>
📝<a href="#%_thm_1.18">1.18</a>
📝<a href="#%_thm_1.19">1.19</a>
§<a href="#%_sec_1.2.5">1.2.5</a>
📝<a href="#%_thm_1.20">1.20</a>
§<a href="#%_sec_1.2.6">1.2.6</a>
📚<a href="#%_sec_Temp_74">&hellip;</a>
📚<a href="#%_sec_Temp_76">&hellip;</a>
📚<a href="#%_sec_Temp_79">&hellip;</a>
📝<a href="#%_thm_1.21">1.21</a>
📝<a href="#%_thm_1.22">1.22</a>
📝<a href="#%_thm_1.23">1.23</a>
📝<a href="#%_thm_1.24">1.24</a>
📝<a href="#%_thm_1.25">1.25</a>
📝<a href="#%_thm_1.26">1.26</a>
📝<a href="#%_thm_1.27">1.27</a>
📝<a href="#%_thm_1.28">1.28</a>
<a href="#footnotes">脚注</a>
]</nav>
</div>

<div class="main-txt">
<a name="%_sec_1.2"></a>
<h2 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_1.2">1.2&nbsp;&nbsp;Procedures and the Processes They Generate</a></h2>
<h2 class="trans" lang="ja">1.2 手続きと、手続きが生成するプロセス</h2>

<p class="orig" lang="en">
We have now considered the elements of programming: We have used
primitive arithmetic operations, we have combined these operations, and
we have abstracted these composite operations by defining them as compound
procedures.  But that is not enough to enable us to say that we know
how to program.  Our situation is analogous to that of someone who has
learned the rules for how the pieces move in chess but knows nothing
of typical openings, tactics, or strategy.  Like the novice chess
player, we don't yet know the common patterns of usage in the domain.
We lack the knowledge of which moves are worth making (which
procedures are worth defining).  We lack the experience to predict the
consequences of making a move (executing a procedure).
</p>

<p class="trans" lang="ja">
今や私たちは、プログラミングの諸要素について熟考したところである——原始的な算術演算を使ったし、これらの演算を結合したし、これらの合成演算を複合的手続きとして定義することにより、これらの合成演算を抽象化した。
しかし、それだけでは、どうやってプログラムを書くのかを自分は知っている、と言える<!--ためには-->ようになるのに十分ではない。
私たちの状況は、チェスの駒の動き方の規則を学んだけれども典型的な開始手や作戦や戦略については少しも知らない、という人の状況と似ている。
新米のチェス・プレイヤと同様、私たちはまだ当該分野での使用法のよくあるパタンについて知らない。
行うに足る価値を持つのは、どの動きなのか (定義するに足る価値を持つのは、どの手続きなのか)、ということについての知識が、私たちには欠けている。
駒を動かすこと (手続きを実行すること) の結果を予測するための経験が、私たちには欠けている。
</p>

<p class="orig" lang="en">
The ability to visualize the consequences of the actions under
consideration is crucial to becoming an expert programmer, just as it
is in any synthetic, creative activity.  In becoming an expert
photographer, for example, one must learn how to look at a scene and
know how dark each region will appear on a print for each possible
choice of exposure and development conditions.  Only then can one
reason backward, planning framing, lighting, exposure, and development
to obtain the desired effects.  So it is with programming, where we
are planning the course of action to be taken by a process and where
we control the process by means of a program.  To become experts, we
must learn to visualize the processes generated by various types of
procedures.  Only after we have developed such a skill can we learn
to reliably construct programs that exhibit the desired behavior.
</p>

<p class="trans" lang="ja">
検討中の行為の結末を思い描くことができる能力は、達人プログラマになるのには欠かせない——総合的で創造的などんな活動においても欠かせないのとちょうど同じように。
たとえば、達人写真家になる過程において、ひとは、光景の見方を習得せねばならず、露光と現像の条件についての可能な選択肢の各々に関して、個々の領域が印画紙上ではどれほど暗く見えるのかを知っていなくてはならない。
そうしてはじめて、ひとは逆算ができるようになる——つまり、所望の効果を得るために、フレーミング・照明・露光・現像を計画するわけだ。
<!--さて、プログラミングの場合は、と言えば、大事な点は、あるプロセスによりとられることになる行動の成り行きを私たちが計画しているところと、プログラムによってそのプロセスを制御するところだ。-->
プログラミングでも同様であり、プログラミングでは、私たちは、プロセスにより行われるはずの動作の成り行きを計画しているし、プログラムによってそのプロセスを制御している。
達人になるには、色々な種類の手続きによって生成されるプロセスを思い描くことを習得しなくてはならない。
そのような技能を高めた後になってはじめて、私たちは、所望の振る舞いを示すプログラムを期待どおりに構築することを学べる。
</p>

<p class="orig" lang="en">
<a name="%_idx_630"></a><a name="%_idx_632"></a><a name="%_idx_634"></a>A procedure is a pattern for the <em>local evolution</em> of a
computational process.  It specifies how each stage of the process is
built upon the previous stage.  We would like to be able to make
statements about the overall, or <em>global</em>, behavior of a
process whose local evolution has been specified by a procedure.  This
is very difficult to do in general, but we can at least try to
describe some typical patterns of process evolution.
</p>

<!-- evolve=進展、展開、発達、発展、どれがいいかな? -->

<p class="trans" lang="ja">
手続きは、計算プロセスの<em>局所的な<!--展開-->進展</em>のための見本である。
手続きは、そのプロセスの各段階が、前の段階の上にどのように構築されるのかを指定する。
私たちは、局所的な<!--展開-->進展が手続きによって既に指定されたプロセスの、全体的な——つまり、<em>大域的な</em>——振る舞いについての陳述ができるようになりたい。
これは、一般的には行うのが難しいのだが、少なくとも、プロセス<!--展開-->進展についての典型的ないくつかのパタンについて記述しようと試みることは、可能だ。
</p>

<p class="orig" lang="en">
In this section we will examine some common ``shapes'' for processes
generated by simple procedures.  We will also investigate the
rates at which these processes consume the important computational
resources of time and space.  The procedures we will consider
are very simple.  Their role is like that played by test patterns in
photography: as oversimplified prototypical patterns, rather than
practical examples in their own right.
</p>

<p class="trans" lang="ja">
本節では、単純な手続きによって生成されるプロセスの、ある種の共通の「形」について、吟味しよう。
これらのプロセスが、時間と空間という重要な計算資源を消費する速度についても、調査しよう。
私たちが検討する手続きは、とても単純だ。
これらの手続きの役割は、写真撮影術においてテスト・パタンが果たす役割と似ている——それ自体で実践的な例というより、むしろ、簡略化されすぎた試作品的なパタンとしての役割だ。
</p>

<a name="%_sec_1.2.1"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_1.2.1">1.2.1&nbsp;&nbsp;Linear Recursion and Iteration</a></h3>
<h3 class="trans" lang="ja">1.2.1  線形的な再帰と反復</h3>

<figure>
<a name="%_idx_636"></a><a name="%_idx_638"></a>
<a name="%_fig_1.3"></a>
<img src="ch1-Z-G-7.gif">
<figcaption class="orig" lang="en"><b>Figure 1.3:</b>&nbsp;&nbsp;A linear recursive process for computing 6!.</figcaption>
<figcaption class="trans" lang="ja"><b>図 1.3:</b>  6! を計算するための、線形の再帰的プロセス</figcaption>
</figure>

<a name="%_idx_640"></a>
<p class="orig" lang="en">We begin by considering the factorial function, defined by
</p>

<p class="trans" lang="ja">
以下のように定義される階乗関数を検討することから始める。
</p>

<figure>
<img src="ch1-Z-G-8.gif">
</figure>

<p class="orig" lang="en">
There are many ways to compute factorials.  One way is to make use of
the observation that <em>n</em>! is equal to <em>n</em> times (<em>n</em> - 1)! for
any positive integer&nbsp;<em>n</em>:
</p>

<p class="trans" lang="ja">
階乗を計算するための多くの方法がある。
ひとつの方法は、任意の正整数 <em class="en">n</em>に対して 
<em class="en">n</em>! が
<span class="math">(<em class="en">n</em> &minus; 1)!</span>
の <em class="en">n</em> 倍に等しい、という知見を利用することだ。
</p>

<figure>
<img src="ch1-Z-G-9.gif">
</figure>

<p class="orig" lang="en">
Thus, we can compute <em>n</em>! by computing (<em>n</em> - 1)! and multiplying the
result by <em>n</em>.  If we add the stipulation that 1! is equal to 1,
this observation translates directly into a procedure:
</p>

<p class="trans" lang="ja">
よって、
<span class="math">(<em class="en">n</em> &minus; 1)!</span>
を計算し、その結果を <em class="en">n</em> 倍することで、 
<em class="en">n</em>! を計算できる。
もし、1! は 1 である、という規定を加えるなら、この知見は直接的に以下の手続きになる。
</p>

<p class="lisp"><a name="%_idx_642"></a>(define (factorial n)
  (if (= n 1)
      1
      (* n (factorial (- n 1)))))
</p>

<p class="orig" lang="en">
<a name="%_idx_644"></a>We can use the substitution model of
section&nbsp;<a href="10_sec1_1.html#%_sec_1.1.5">1.1.5</a> to watch this procedure in action
computing 6!, as shown in figure&nbsp;<a href="#%_fig_1.3">1.3</a>.
</p>

<p class="trans" lang="ja">
動作中のこの関数が 6! を計算するのをよく見るために、<a href="10_sec1_1.html#%_sec_1.1.5">1.1.5</a>節の<ruby><rb>代入</rb><rp> (</rp><rt>おきかえ</rt><rp>) </rp></ruby>モデルを使うことができる——図<a href="#%_fig_1.3">1.3</a>に示すように。
</p>

<p class="orig" lang="en">
Now let's take a different perspective on computing factorials.  We
could describe a rule for computing <em>n</em>! by specifying that we
first multiply 1 by 2, then multiply the result by 3, then by 4,
and so on until we reach <em>n</em>.
More formally, we maintain a running product, together with a counter
that counts from 1 up to <em>n</em>.  We can describe the computation by
saying that the counter and the product simultaneously change from one
step to the next according to the rule</p>

<p class="trans" lang="ja">
ではここで、階乗の計算について別の見方をしてみよう。
まず 1 に 2 を掛け、次にその結果に 3 を掛け、次に 4 を掛け、……というふうにして、<em class="en">n</em> に到達するまで続ける、と指定することで、<em class="en">n!</em> を計算するための規則を記述することができるだろう。
より形式的には、1 から <em class="en">n</em> まで数えるカウンタとともに、現在の積を保持しておく。
私たちはこの計算を記述できる——ひとつのステップから次のステップへと進むたびに、以下の規則にしたがって、そのカウンタと積が同時に変化する、と述べることによって、
</p>

<figure>
product  <img src="book-Z-G-D-14.gif">  counter  &middot;  product <br>
counter  <img src="book-Z-G-D-14.gif">  counter  +  1
</figure>

<p class="orig" lang="en">
and stipulating that <em>n</em>! is the value of the product when
the counter exceeds <em>n</em>.</p>

<p class="trans" lang="ja">
そしてまた、カウンタが <em class="en">n</em> を越えたときの積の値が <em class="en">n</em>! なのだ、と規定することによって。
</p>

<a name="%_fig_1.4"></a>
<figure>
<img src="ch1-Z-G-10.gif">
<figcaption class="orig" lang="en"><b>Figure 1.4:</b>&nbsp;&nbsp;A linear iterative process for computing 6!.</figcaption>
<figcaption class="trans" lang="ja"><b>図1.4:</b> 6! を計算するための線形の反復的プロセス</figcaption>
</figure>

<p class="orig" lang="en">
Once again, we can recast our description as a procedure for computing
factorials:<a name="call_footnote_Temp_46" href="#footnote_Temp_46"><sup><small>29</small></sup></a></p>

<p class="trans" lang="ja">
またしても私たちは、階乗を計算するための手続きとして、記述を再構成することができる<a href="#footnote_Temp_46"><sup><small>29</small></sup></a>。
</p>

<p class="lisp"><a name="%_idx_646"></a>(define (factorial n)
  (fact-iter 1 1 n))

(define (fact-iter product counter max-count)
  (if (&gt; counter max-count)
      product
      (fact-iter (* counter product)
                 (+ counter 1)
                 max-count)))</p>

<p class="orig" lang="en">
As before, we can use the substitution model to visualize the process
of computing 6!, as shown in figure&nbsp;<a href="#%_fig_1.4">1.4</a>.</p>

<p class="trans" lang="ja">
前のときと同様に、6! を計算するプロセスを可視化するために<ruby><rb>代入</rb><rp> (</rp><rt>おきかえ</rt><rp>) </rp></ruby>モデルを使える——図<a href="#%_fig_1.4">1.4</a>に示すように。
</p>

<p class="orig" lang="en">
Compare the two processes.  From one point of view, they seem hardly
different at all.  Both compute the same mathematical function on the
same domain, and each requires a number of steps proportional to <em>n</em>
to compute <em>n</em>!.  Indeed, both processes even carry out the same
sequence of multiplications, obtaining the same sequence of partial
products.  On the other hand, when we consider the <a name="%_idx_648"></a><a name="%_idx_650"></a>``shapes'' of the
two processes, we find that they evolve quite differently.</p>

<p class="trans" lang="ja">
二つのプロセスを比べてみよう。
一つの観点からすれば、これら二つのプロセスは、ほとんど違わないように見える。
両方とも、同じ定義域上で同じ数学的関数を計算し、各々は、<em class="en">n</em>! を計算するために、<em class="en">n</em> に比例する数のステップを要する。
実際、双方のプロセスは、乗算の同じ連なりを実行しさえする——そして不完全な積の同じ連なりを得ている。
他方、二つのプロセスの「形」を考慮する場合には、二つのプロセスがまったく違うやり方で<!--発達-->進展することに気づく。
</p>

<p class="orig" lang="en">
Consider the first process.  The substitution model reveals a shape of
expansion followed by contraction, indicated by the arrow in
figure&nbsp;<a href="#%_fig_1.3">1.3</a>.  The expansion occurs as the
process builds up a chain of <a name="%_idx_652"></a><em>deferred operations</em> (in this case,
a chain of multiplications).  The contraction occurs as 
the operations are
actually performed.  This type of process, characterized by a chain of
deferred operations, is called a <a name="%_idx_654"></a><a name="%_idx_656"></a><em>recursive process</em>.  Carrying
out this process requires that the interpreter keep track of the
operations to be performed later on.  In the computation of <em>n</em>!,
the length of the chain of deferred multiplications, and hence the amount
of information needed to keep track of it, <a name="%_idx_658"></a>grows linearly with <em>n</em>
(is proportional to <em>n</em>), just like the number of steps.
<a name="%_idx_660"></a><a name="%_idx_662"></a><a name="%_idx_664"></a>Such a process is called a <em>linear recursive process</em>.</p>

<p class="trans" lang="ja">
一番目のプロセスを検討しよう。
<ruby><rb>代入</rb><rp> (</rp><rt>おきかえ</rt><rp>) </rp></ruby>モデルは、展開の後で縮約<!--簡約-->する形を明らかにしている——図<a href="#%_fig_1.3">1.3</a>の矢印で示されるように。
展開は、<em>遅延された演算</em>の連なり (この場合は乗算の連なり) をプロセスが構築するにつれて、起こる。
縮約は、それらの演算が実際に実行されるにしたがって、起こる。
この種のプロセス——遅延された演算の連なりにより特徴づけられる——は、<em>再帰的プロセス</em>と呼ばれる。
このプロセスを実行するには、後で実行されるべき演算をインタプリタが把握しておくことが必要である。
<em class="en">n</em>! の計算では、遅延された乗算の連なりの長さ——したがって、その連なりを把握するのに必要な情報の量も——が、<em class="en">n</em> に対して線形に増える (<em class="en">n</em> に比例する) ——ちょうどステップ数と同様に。
こういうプロセスは、<em>線形の再帰的プロセス</em>と呼ばれる。
</p>

<p class="orig" lang="en">
By contrast, the second process does not grow and shrink.  At each
step, all we need to keep track of, for any <em>n</em>, are the current
values of the variables <tt>product</tt>, <tt>counter</tt>, and <tt>max-count</tt>.  We call this an <a name="%_idx_666"></a><a name="%_idx_668"></a><em>iterative process</em>.  In general, an
iterative process is one whose state can be summarized by a fixed
number of <a name="%_idx_670"></a><em>state variables</em>, together with a fixed rule that
describes how the state variables should be updated as the process
moves from state to state and an (optional) end test that specifies
conditions under which the process should terminate.  In computing
<em>n</em>!, the number of steps required grows linearly with <em>n</em>.  Such a process is
called a <a name="%_idx_672"></a><a name="%_idx_674"></a><a name="%_idx_676"></a><em>linear iterative process</em>.</p>

<p class="trans" lang="ja">
それに対して、二番目のプロセスは、伸びたり縮んだりはしない。
任意の<em class="en">n</em>に対して、個々のステップで把握しておかなくてはならないものは、<tt>product</tt> と <tt>counter</tt> と <tt>max-count</tt> という変数の現在の値だけである。
私たちは、これを<em>反復的プロセス</em>と呼んでいる。
一般に、反復的プロセスとは、決められた個数の<em>状態変数</em>によって——それから、状態から状態へとプロセスが移り変わるにつれて状態変数をどのように更新すべきなのかを記述する所定の規則と、プロセスが終了すべき条件を指定する (オプショナルな) 終了テストと、によって——状態を要約できるようなプロセスである。
<em class="en">n</em>! の計算では、必要なステップ数は、<em class="en">n</em> に対して線形に増える。
こういうプロセスは、<em>線形の反復的プロセス</em>と呼ばれる。
</p>

<p class="orig" lang="en">
The contrast between the two processes can be seen in another way.  In
the iterative case, the program variables provide a complete
description of the state of the process at any point.  If we stopped
the computation between steps, all we would need to do to resume the
computation is to supply the interpreter with the values of the three
program variables.  Not so with the recursive process.  In this case
there is some additional ``hidden'' information, maintained by the
interpreter and not contained in the program variables, which
indicates ``where the process is'' in negotiating the chain of
deferred operations.  The longer the chain, the more information must
be maintained.<a name="call_footnote_Temp_47" href="#footnote_Temp_47"><sup><small>30</small></sup></a></p>

<p class="trans" lang="ja">
二つのプロセスの差異について、別の見方もできる。
反復的な場合、任意の時点において、プログラム変数が、プロセスの状態の完全な記述を与えてくれる。
もし、ステップとステップの間で計算を止めたなら、計算を再開するためにしなくてはならないであろうことは、三つのプログラム変数の値をインタプリタに与えることだけだ。
再帰的プロセスでは、そうはいかない。
<!--この場合、何らかの付加的な「隠れた」情報があり、それは、インタプリタにより保持されるが、プログラム変数——遅延された演算の連なりを切り抜けてゆく際に、「プロセスがどこにいるのか」を示す——には含まれない。-->
この場合、何らかの付加的な「隠れた」情報があり、それは、インタプリタにより保持されているがプログラム変数には含まれていないものであって、遅延された演算の連なりを切り抜けてゆく際に「プロセスがどこにいるのか」を示している。
その連なりが長いほど、多くの情報が保持されなくてはならない<a href="#footnote_Temp_47"><sup><small>30</small></sup></a>。
</p>

<p class="orig" lang="en">
In contrasting iteration and recursion, we must be careful not to
confuse the notion of a <a name="%_idx_680"></a><a name="%_idx_682"></a>recursive <em>process</em> with the notion of a
recursive <em>procedure</em>.  When we describe a procedure as recursive,
we are referring to the syntactic fact that the procedure definition
refers (either directly or indirectly) to the procedure itself.  But
when we describe a process as following a pattern that is, say,
linearly recursive, we are speaking about how the process evolves, not
about the syntax of how a procedure is written.  It may seem
disturbing that we refer to a recursive procedure such as <tt>fact-iter</tt> as generating an iterative process.  However, the process
really is iterative: Its state is captured completely by its three
state variables, and an interpreter need keep track of only three
variables in order to execute the process.</p>

<p class="trans" lang="ja">
反復と再帰の対比においては、再帰的な<em>プロセス</em>という概念と再帰的な<em>手続き</em>という概念を混同しないように、気をつけなくてはならない。
ある手続きが再帰的だと述べるとき、私たちは、その手続きの定義が (直接的または間接的に) その手続き自体を参照している、という構文的事実のことを言っている。
一方、あるプロセスのことを、例えば線形の再帰的なパタンにしたがっている、と述べるとき、私たちは、そのプロセスがどのように<!--発達-->進展するのかについて話しているのであって、手続きがどう書かれているかという構文について話しているわけではない。
<tt>fact-iter</tt> などの再帰的手続きのことを、反復的プロセスを生成するものだ、と言うことは、混乱させる言い方かもしれない。
しかし、事実、そのプロセスは反復的である——そのプロセスの状態は、三つの状態変数によって完全に捉えられるし、インタプリタは、プロセスを実行するために三つの状態変数だけを把握しておけばよいのだから。
</p>

<p class="orig" lang="en">
One reason that the distinction between process and procedure may be
confusing is that most implementations of common languages (including
<a name="%_idx_684"></a><a name="%_idx_686"></a><a name="%_idx_688"></a>Ada, Pascal, and C) are designed in such a way that the
interpretation of any recursive procedure consumes an amount of memory
that grows with the number of procedure calls, even when the process
described is, in principle, iterative.  As a consequence, these
languages can describe iterative processes only by resorting to
special-purpose <a name="%_idx_690"></a>``looping constructs'' such as <tt>do</tt>, <tt>repeat</tt>,
<tt>until</tt>, <tt>for</tt>, and <tt>while</tt>.  The implementation of Scheme
we shall consider in chapter&nbsp;5 does not share this defect.  It will
execute an iterative process in constant space, even if the iterative
process is described by a recursive procedure.  An implementation with
this property is called <a name="%_idx_692"></a><em>tail-recursive</em>.  With a tail-recursive
implementation, <a name="%_idx_694"></a>iteration can be expressed using the ordinary
procedure call mechanism, so that special iteration constructs are
useful only as <a name="%_idx_696"></a>syntactic sugar.<a name="call_footnote_Temp_48" href="#footnote_Temp_48"><sup><small>31</small></sup></a></p>

<p class="trans" lang="ja">
<!--プロセスと手続きの違いが紛らわしいかもしれない、ということの理由の一つは、こうである——記述されているプロセスが原理的には反復的であるときでさえも、手続き呼び出しの回数に応じて増える量のメモリを、任意の再帰的手続きの解釈によって消費してしまうような方法で、(Ada、Pascal、Cなどの) 普通の言語のほとんどの実装が設計されているからなのだ。-->
プロセスと手続きの違いが紛らわしいかもしれない、ということの理由の一つは、こうである——記述されているプロセスが原理的には反復的であるときでさえ、どの再帰的手続きの解釈も、手続き呼び出しの回数に応じて増える量のメモリを消費してしまうような方法で、(Ada、Pascal、Cを含む) 普通の言語のほとんどの実装が、設計されているからなのだ。
その結果、これらの言語は、<tt>do</tt> や、<tt>repeat</tt> や、<tt>until</tt> や、<tt>for</tt> や、<tt>while</tt> などの、特定用途の「ループ構造」に頼ることでしか、反復的プロセスを記述できない。
5章で検討することになるSchemeの実装には、この欠点がない。
その実装は、反復的なプロセスを一定の空間内で実行するだろう——たとえ、その反復的プロセスが、再帰的手続きにより記述されていても。
このような性質を持った実装は、<em>末尾再帰的</em>と呼ばれる。
末尾再帰的な実装を使うと、通常の手続き呼び出しの仕組みを用いて反復を表現でき、その結果として、特殊な反復構造は糖衣構文としてのみ有用だ、ということになる<a href="#footnote_Temp_48"><sup><small>31</small></sup></a>。
</p>

<p class="orig" lang="en">
<a name="%_thm_1.9"></a>
<b>Exercise 1.9.</b>&nbsp;&nbsp;Each of the following two procedures defines a method for adding two
positive integers in terms of the procedures <tt>inc</tt>,
which increments its argument by 1, and <tt>dec</tt>, which decrements
its argument by 1.</p>

<p class="trans" lang="ja">
<b>練習問題 1.9.</b>  以下の二つの手続きのそれぞれは、<tt>inc</tt> という手続き——引数を 1 だけ増やす——と、<tt>dec</tt> という手続き——引数を 1 だけ減らす——を使って、二つの正整数を足す方法を定義している。
</p>

<p class="lisp">(define (+ a b)
  (if (= a 0)
      b
      (inc (+ (dec a) b))))

(define (+ a b)
  (if (= a 0)
      b
      (+ (dec a) (inc b))))</p>

<p class="orig" lang="en">
Using the substitution model, illustrate the process generated by each
procedure in evaluating <tt>(+ 4 5)</tt>.  Are these processes
iterative or recursive?</p>

<p class="trans" lang="ja">
<tt>(+ 4 5)</tt> を評価する際にそれぞれの手続きにより生成されるプロセスについて、<ruby><rb>代入</rb><rp> (</rp><rt>おきかえ</rt><rp>) </rp></ruby>モデルを使って説明せよ。
これらのプロセスは、反復的か、それとも再帰的か？
</p>

<p class="exercise"><span class="ex_comment">; 上の定義を使った場合は以下のようになり、再帰的。
; (inc と dec は原始的と仮定する。
;  また、if が特殊形式であることに注意しながら展開・簡約を行う。)

; 適用順でやってみる。</span>
<span class="hilit1">(+ 4 5)</span>

<span class="hilit1">(if (= 4 0) 5 <span class="hilit2">(inc (+ (dec 4) 5))</span>)</span>

<span class="hilit2">(inc (+ (dec 4) 5))</span>

<span class="hilit2">(inc <span class="hilit3">(+ 3 5)</span>)</span>

<span class="hilit2">(inc <span class="hilit3">(if (= 3 0) 5 <span class="hilit4">(inc (+ (dec 3) 5))</span>)</span>)</span>

<span class="hilit2">(inc <span class="hilit4">(inc (+ (dec 3) 5))</span>)</span>

<span class="hilit2">(inc <span class="hilit4">(inc (+ 2 5))</span>)</span>

<span class="hilit2">(inc <span class="hilit4">(inc <span class="hilit5">(if (= 2 0) 5 <span class="hilit6">(inc (+ (dec 2) 5))</span>)</span>)</span>)</span>

<span class="hilit2">(inc <span class="hilit4">(inc <span class="hilit6">(inc (+ (dec 2) 5))</span>)</span>)</span>

<span class="hilit2">(inc <span class="hilit4">(inc <span class="hilit6">(inc (+ 1 5))</span>)</span>)</span>

<span class="hilit2">(inc <span class="hilit4">(inc <span class="hilit6">(inc <span class="hilit7">(if (= 1 0) 5 <span class="hilit8">(inc (+ (dec 1) 5))</span>)</span>)</span>)</span>)</span>

<span class="hilit2">(inc <span class="hilit4">(inc <span class="hilit6">(inc <span class="hilit8">(inc (+ (dec 1) 5))</span>)</span>)</span>)</span>

<span class="hilit2">(inc <span class="hilit4">(inc <span class="hilit6">(inc <span class="hilit8">(inc (+ 0 5))</span>)</span>)</span>)</span>

<span class="hilit2">(inc <span class="hilit4">(inc <span class="hilit6">(inc <span class="hilit8">(inc <span class="hilit9">(if (= 0 0) 5 (inc (+ (dec 0) 5)))</span>)</span>)</span>)</span>)</span>

<span class="hilit2">(inc <span class="hilit4">(inc <span class="hilit6">(inc <span class="hilit8">(inc <span class="hilit9">5</span>)</span>)</span>)</span>)</span>

<span class="hilit2">(inc <span class="hilit4">(inc <span class="hilit6">(inc <span class="hilit8">6</span>)</span>)</span>)</span>

<span class="hilit2">(inc <span class="hilit4">(inc <span class="hilit6">7</span>)</span>)</span>

<span class="hilit2">(inc <span class="hilit4">8</span>)</span>

<span class="hilit2">9</span>
</p>

<p class="exercise"><span class="ex_comment">; 正規順で考えたものも、せっかくなので以下に残しておく。</span>
<span class="hilit1">(+ 4 5)</span>

<span class="hilit1">(if (= 4 0) 5 
    <span class="hilit2">(inc (+ (dec 4) 5))</span>)</span>

<span class="hilit2">(inc <span class="hilit3">(+ (dec 4) 5)</span>)</span>

<span class="hilit2">(inc <span class="hilit3">(if (= (dec 4) 0) 5 
         <span class="hilit4">(inc (+ (dec (dec 4)) 5))</span>)</span>)</span>

<span class="hilit2">(inc <span class="hilit4">(inc <span class="hilit5">(+ (dec (dec 4)) 5)</span>)</span>)</span>

<span class="hilit2">(inc <span class="hilit4">(inc <span class="hilit5">(if (= (dec (dec 4)) 0) 5 
              <span class="hilit6">(inc (+ (dec (dec (dec 4))) 5))</span>)</span>)</span>)</span>

<span class="hilit2">(inc <span class="hilit4">(inc <span class="hilit6">(inc <span class="hilit7">(+ (dec (dec (dec 4))) 5)</span>)</span>)</span>)</span>

<span class="hilit2">(inc <span class="hilit4">(inc <span class="hilit6">(inc <span class="hilit7">(if (= (dec (dec (dec 4))) 0) 5 
                   <span class="hilit8">(inc (+ (dec (dec (dec (dec 4)))) 5))</span>)</span>)</span>)</span>)</span>

<span class="hilit2">(inc <span class="hilit4">(inc <span class="hilit6">(inc <span class="hilit8">(inc <span class="hilit9">(+ (dec (dec (dec (dec 4)))) 5)</span>)</span>)</span>)</span>)</span>

<span class="hilit2">(inc <span class="hilit4">(inc <span class="hilit6">(inc <span class="hilit8">(inc <span class="hilit9">(if (= (dec (dec (dec (dec 4)))) 0) 5
                        (inc (+ (dec (dec (dec (dec (dec 4))))) 5)))</span>)</span>)</span>)</span>)</span>

<span class="hilit2">(inc <span class="hilit4">(inc <span class="hilit6">(inc <span class="hilit8">(inc <span class="hilit9">5</span>)</span>)</span>)</span>)</span>

<span class="hilit2">(inc <span class="hilit4">(inc <span class="hilit6">(inc <span class="hilit8">6</span>)</span>)</span>)</span>

<span class="hilit2">(inc <span class="hilit4">(inc <span class="hilit6">7</span>)</span>)</span>

<span class="hilit2">(inc <span class="hilit4">8</span>)</span>

<span class="hilit2">9</span>
</p>

<p class="exercise"><span class="ex_comment">; 下の定義を使った場合は以下のようになり、反復的。
; 適用順</span>
<span class="hilit1">(+ 4 5)</span>

<span class="hilit1">(if (= 4 0) 5 <span class="hilit2">(+ (dec 4) (inc 5))</span>)</span>

<span class="hilit2">(+ (dec 4) (inc 5))</span>

<span class="hilit2">(+ 3 6)</span>

<span class="hilit2">(if (= 3 0) 6 <span class="hilit3">(+ (dec 3) (inc 6))</span>)</span>

<span class="hilit3">(+ (dec 3) (inc 6))</span>

<span class="hilit3">(+ 2 7)</span>

<span class="hilit3">(if (= 2 0) 7 <span class="hilit4">(+ (dec 2) (inc 7))</span>)</span>

<span class="hilit4">(+ (dec 2) (inc 7))</span>

<span class="hilit4">(+ 1 8)</span>

<span class="hilit4">(if (= 1 0) 8 <span class="hilit5">(+ (dec 1) (inc 8))</span>)</span>

<span class="hilit5">(+ (dec 1) (inc 8))</span>

<span class="hilit5">(+ 0 9)</span>

<span class="hilit5">(if (= 0 0) <span class="hilit6">9</span> (+ (dec 0) (inc 9)))</span>

<span class="hilit6">9</span>
</p>

<p class="exercise"><span class="ex_comment">; 正規順のも書いておく。これも反復的。</span>
<span class="hilit1">(+ 4 5)</span>

<span class="hilit1">(if (= 4 0) 5
    <span class="hilit2">(+ (dec 4) (inc 5))</span>)</span>

<span class="hilit2">(+ (dec 4) (inc 5))</span>

<span class="hilit2">(if (= (dec 4) 0) (inc 5)
    <span class="hilit3">(+ (dec (dec 4)) (inc (inc 5)))</span>)</span>

<span class="hilit3">(+ (dec (dec 4)) (inc (inc 5)))</span>

<span class="hilit3">(if (= (dec (dec 4)) 0) (inc (inc 5))
    <span class="hilit4">(+ (dec (dec (dec 4))) (inc (inc (inc 5))))</span>)</span>

<span class="hilit4">(+ (dec (dec (dec 4))) (inc (inc (inc 5))))</span>

<span class="hilit4">(if (= (dec (dec (dec 4))) 0) (inc (inc (inc 5)))
    <span class="hilit5">(+ (dec (dec (dec (dec 4)))) (inc (inc (inc (inc 5)))))</span>)</span>

<span class="hilit5">(+ (dec (dec (dec (dec 4)))) (inc (inc (inc (inc 5))))))</span>

<span class="hilit5">(if (= (dec (dec (dec (dec 4)))) 0) <span class="hilit7">(inc (inc (inc (inc 5))))</span>
    <span class="hilit6">(+ (dec (dec (dec (dec (dec 4))))) (inc (inc (inc (inc (inc 5))))))</span>)</span>

<span class="hilit7">(inc (inc (inc <span class="hilit8">(inc 5)</span>)))</span>

<span class="hilit7">(inc (inc <span class="hilit9">(inc <span class="hilit8">6</span>)</span>))</span>

<span class="hilit7">(inc <span class="hilit10">(inc <span class="hilit9">7</span>)</span>)</span>

<span class="hilit7">(inc <span class="hilit10">8</span>)</span>

<span class="hilit7">9</span>
</p>

<p class="orig" lang="en"><a name="%_thm_1.10"></a>
<b>Exercise 1.10.</b>&nbsp;&nbsp;<a name="%_idx_708"></a><a name="%_idx_710"></a>The following procedure computes a mathematical function called
Ackermann's function.</p>

<p class="trans" lang="ja">
<b>練習問題 1.10.</b>  以下の手続きは、アッカーマン関数と呼ばれる数学的関数を計算する。
</p>

<p class="lisp">(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))</p>

<p class="orig" lang="en">
What are the values of the following expressions?</p>

<p class="trans" lang="ja">
以下の式の値はいくつか？
</p>

<p class="lisp">(A 1 10)

(A 2 4)

(A 3 3)</p>

<p class="exercise">(A 1 10)
(A 0 (A 1 9))
(A 0 (A 0 (A 1 8)))
(A 0 (A 0 (A 0 (A 1 7))))
(A 0 (A 0 (A 0 (A 0 (A 1 6)))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 1 5))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 4)))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 3))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 2)))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8)))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 16))))))
(A 0 (A 0 (A 0 (A 0 (A 0 32)))))
(A 0 (A 0 (A 0 (A 0 64))))
(A 0 (A 0 (A 0 128)))
(A 0 (A 0 256))
(A 0 512)
1024
</p>

<p class="exercise">(A 2 4)
(A 1 (A 2 3))
(A 1 (A 1 (A 2 2)))
(A 1 (A 1 (A 1 (A 2 1))))
(A 1 (A 1 (A 1 2)))
(A 1 (A 1 (A 0 (A 1 1))))
(A 1 (A 1 (A 0 2)))
(A 1 (A 1 4))
(A 1 (A 0 (A 1 3)))
(A 1 (A 0 (A 0 (A 1 2))))
(A 1 (A 0 (A 0 (A 0 (A 1 1)))))
(A 1 (A 0 (A 0 (A 0 2))))
(A 1 (A 0 (A 0 4)))
(A 1 (A 0 8))
(A 1 16)
(A 0 (A 1 15))
  :
  :          <span class="ex_comment">; 上の問題の計算過程より、(A 1 n)=2<sup>n</sup>と推定できる。</span>
  :          <span class="ex_comment">; 後で示すようにこの推定は一般に成り立つ。</span>
(A 0 32768)  <span class="ex_comment">; 2<sup>15</sup>=32768</span>
65536
</p>

<p class="exercise">(A 3 3)
(A 2 (A 3 2))
(A 2 (A 2 (A 3 1)))
(A 2 (A 2 2))
(A 2 (A 1 (A 2 1)))
(A 2 (A 1 2))
(A 2 (A 0 (A 1 1)))
(A 2 (A 0 2))
(A 2 4)   <span class="ex_comment">; これは直前の問題と同じ。</span>
  :
  :
65536
</p>

<p class="orig" lang="en">
Consider the following procedures, where <tt>A</tt> is the procedure  
defined above:</p>

<p class="trans" lang="ja">
<tt>A</tt> が、上記のように定義された手続きだとして、以下の手続きについて検討せよ。
</p>

<p class="lisp">(define (f n) (A 0 n))

(define (g n) (A 1 n))

(define (h n) (A 2 n))

(define (k n) (* 5 n n))</p>


<p class="orig" lang="en">
Give concise mathematical definitions for the functions computed by
the procedures <tt>f</tt>, <tt>g</tt>, and <tt>h</tt> for positive integer
values of <em>n</em>.  For example, <tt>(k n)</tt> computes 5<em>n</em><sup>2</sup>.</p>

<p class="trans" lang="ja">
正の整数値 <em class="en">n</em> に対して、<tt>f</tt> と <tt>g</tt> と <tt>h</tt> という手続きにより計算される関数の、簡潔な数学的定義を与えよ。
たとえば、<tt>(k n)</tt>は 5<em class="en">n</em><sup>2</sup> を計算する。
</p>

<p class="exercise">  (f n)
= (A 0 n)
= (* 2 n)
<span class="ex_comment">なので、<tt>(f n)</tt> は <em class="en">2n</em> を計算する。</span>
</p>

<p class="exercise"><span class="ex_comment"><tt>(g n)</tt> は <em>2<sup>n</sup></em> を計算する。と、推定できる (上記の計算例より)。
帰納法で証明しておく。

n=1 のとき、(g 1) は、定義より (A 1 1) であり、これは、2である。
<em>2<sup>n</sup> = 2<sup>1</sup> = 2</em> だから、n=1 のとき、上記の推定は成立。

次に、n が 1 から j までのときに上記の推定が成立する、と仮定する。すると、</span>
  (g (+ j 1))
= (A 1 (+ j 1))
= (A 0 (A 1 j))
= (A 0 <em>2<sup>j</sup></em>)
= (* 2 <em>2<sup>j</sup></em>)
= <em>2<sup>j+1</sup></em>
<span class="ex_comment">なので、n=j+1 のときも上記の推定が成立する。
したがって、任意の正整数 n に対して、<tt>(g n)</tt> は <em>2<sup>n</sup></em> を計算する。</span>
</p>

<p class="exercise"><span class="ex_comment">上記の計算例より、</span>
(h 1) = (A 2 1) = 2 = 2<sup>1</sup>
(h 2) = (A 2 2) = 4 = 2<sup>2</sup>
(h 3) = (A 2 3) = 16 = 2<sup>4</sup>
(h 4) = (A 2 4) = 65536 = 2<sup>16</sup>
<span class="ex_comment">である。また、</span>
  (h 5)
= (A 2 5)
= (A 1 (A 2 4))
= (A 1 65536)
= 2<sup>65536</sup>
<span class="ex_comment">である。というわけで、(h n) は、
<span style="line-height:80%">                   <span style="font-size: x-small">2</span>
               . 
           .
       .
    2
<span style="font-size: x-large">2</span></span>
を計算するものである (ただし、ここで、累乗の累乗の……と続いてゆく2の個数は、
全部で n 個である)、と推定できる (※)。帰納法で証明しておく。

n=1のとき、(h 1) = 2 より、上記推定 (※) は成立する。

次に、n が 1 から j までのときに上記の推定 (※) が成立する、と仮定する。</span>
  (h (+ j 1))
= (A 2 (+ j 1))
= (A 1 (A 2 j))
= (g (h j))
= 2<sup>(h j)</sup>
<span class="ex_comment">なので、n=j+1 のときも上記の推定 (※) が成立する。
したがって、任意の正整数 n に対して、上記の推定 (※) が成立する。</span>
</p>

<a name="%_sec_1.2.2"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_1.2.2">1.2.2&nbsp;&nbsp;Tree Recursion</a></h3>
<h3 class="trans" lang="ja">1.2.2 木構造再帰</h3>

<a name="%_idx_712"></a><a name="%_idx_714"></a><a name="%_idx_716"></a>
<p class="orig" lang="en">
Another common pattern of computation is called <em>tree recursion</em>.
As an example, consider computing the sequence of <a name="%_idx_718"></a>Fibonacci numbers,
in which each number is the sum of the preceding two:
</p>

<p class="trans" lang="ja">
別のよくある計算パタンは、<em>木構造再帰</em>と呼ばれる。
例として、フィボナッチ数の列——各々の数は、先行する二つの和である——を計算することを考えてみよう。
</p>

<figure><img src="ch1-Z-G-11.gif"></figure>

<p class="orig" lang="en">
In general, the Fibonacci numbers can be defined by the rule</p>

<p class="trans" lang="ja">
一般に、フィボナッチ数は、以下の規則により定義できる。
</p>

<figure><img src="ch1-Z-G-12.gif"></figure>

<p class="orig" lang="en">
We can immediately translate this definition into a recursive
procedure for computing Fibonacci numbers:
</p>

<p class="trans" lang="ja">
私たちは即座にこの定義を、フィボナッチ数を計算する再帰的手続きへと書き換えられる。
</p>

<p class="lisp"><a name="%_idx_720"></a>(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))</p>

<figure>
<a name="%_fig_1.5"></a>
<img src="ch1-Z-G-13.gif">
<figcaption class="orig" lang="en"><b>Figure 1.5:</b>&nbsp;&nbsp;The tree-recursive process generated in computing <tt>(fib 5)</tt>.</figcaption>
<figcaption class="trans" lang="ja"><b>図 1.5:</b>  <tt>(fib 5)</tt>を計算する際に生成される木構造再帰プロセス</figcaption>
</figure>

<p class="orig" lang="en">
Consider the pattern of this computation.  To compute <tt>(fib 5)</tt>,
we compute <tt>(fib 4)</tt> and <tt>(fib 3)</tt>.  To compute <tt>(fib 4)</tt>,
we compute <tt>(fib 3)</tt> and <tt>(fib 2)</tt>.  In general, the evolved
process looks like a tree, as shown in figure&nbsp;<a href="#%_fig_1.5">1.5</a>.
Notice that the branches split into two at each level (except at the
bottom); this reflects the fact that the <tt>fib</tt> procedure calls
itself twice each time it is invoked.
</p>

<p class="trans" lang="ja">
この計算のパタンについて考えよう。
<tt>(fib 5)</tt> を計算するには、<tt>(fib 4)</tt> と <tt>(fib 3)</tt> を計算する。
<tt>(fib 4)</tt> を計算するには、<tt>(fib 3)</tt> と <tt>(fib 2)</tt> を計算する。
一般に、<!--発達-->進展したプロセスは、図<a href="#%_fig_1.5">1.5</a>に示すとおり、木のように見える。
各レベルで (ただし最下層を除く)、枝が二つに分かれることに注意してほしい。このことは、<tt>fib</tt> という手続きが、呼び出されるたびに自分自身を二回呼び出す、という事実を反映している。
</p>

<p class="orig" lang="en">
This procedure is instructive as a prototypical tree recursion, but it
is a terrible way to compute Fibonacci numbers because it does so much
redundant computation.  Notice in figure&nbsp;<a href="#%_fig_1.5">1.5</a> that
the entire computation of <tt>(fib 3)</tt> -- almost half the work -- is
duplicated.  In fact, it is not hard to show that the number of times
the procedure will compute <tt>(fib 1)</tt> or <tt>(fib 0)</tt> (the number
of leaves in the above tree, in general) is precisely 
<em>F</em><em>i</em><em>b</em>(<em>n</em> + 1).  To get an idea of how bad this is, one can show that the
value of  <em>F</em><em>i</em><em>b</em>(<em>n</em>) <a name="%_idx_722"></a>grows exponentially with <em>n</em>.  More precisely
(see exercise&nbsp;<a href="#%_thm_1.13">1.13</a>),  <em>F</em><em>i</em><em>b</em>(<em>n</em>) is the closest
integer to <img src="book-Z-G-D-11.gif" border="0"><sup><em>n</em></sup> /<img src="book-Z-G-D-13.gif" border="0">5, where
</p>

<p class="trans" lang="ja">
この手続きは、試作品的な木構造再帰としては、教育上、役立つが、非常に多くの冗長な計算を行うので、フィボナッチ数を計算するにはひどい方法である。
図<a href="#%_fig_1.5">1.5</a>において、<tt>(fib 3)</tt> の計算の全体——仕事のほぼ半分だ——が繰り返されていることに注意してほしい。
実際、この手続きが <tt>(fib 1)</tt> または <tt>(fib 0)</tt> を計算するだろう回数 (一般には上記の木の中の葉の数) が、正確に
<span class="math"><em class="en">Fib</em>(<em class="en">n</em> + 1)</span>
回である、ということを示すのは難しくない。
この手続きがいかに駄目かという考えにたどり着くためには、
<span class="math"><em class="en">Fib</em>(<em class="en">n</em>)</span> 
の値が <em class="en">n</em> に対して指数関数的に大きくなることを示せばよい。
より正確には (練習問題<a href="#%_thm_1.13">1.13</a>を参照)、
<em class="en">Fib</em>(<em class="en">n</em>) は、
<span class="math">&phi;<sup><em class="en">n</em></sup>/&radic;5</span>
に最も近い整数である——ただし、ここで、
</p>

<figure><img src="ch1-Z-G-14.gif"></figure>

<p class="orig" lang="en">
is the <a name="%_idx_724"></a><em>golden ratio</em>, which satisfies the equation
</p>

<p class="trans" lang="ja">
は<em>黄金比</em>であるものとし、黄金比とは次の等式を満たすものである。
</p>

<figure><img src="ch1-Z-G-15.gif"></figure>

<p class="orig" lang="en">
Thus, the process uses a number of steps that grows exponentially
with the input.  On the other hand, the space required grows only
linearly with the input, because we need keep track only of which
nodes are above us in the tree at any point in the computation.  In
general, the number of steps required by a tree-recursive process will be
proportional to the number of nodes in the tree, while the space
required will be proportional to the maximum depth of the tree.
</p>

<p class="trans" lang="ja">
このように、このプロセスは、入力に対して指数関数的に増える数のステップを用いる。
他方、必要な空間は、入力に対して線形にしか増えない——なぜなら、計算途中のどの時点でも、木の中で自分より上にあるのはどのノードなのか、ということだけを把握しておけばよいからだ。
一般には、木構造再帰的なプロセスで必要なステップの数は、木の中のノードの数に比例するだろうが、他方で、必要な空間は、木の最大深さに比例するだろう。
</p>

<p class="orig" lang="en">
We can also formulate an iterative process for computing the
Fibonacci numbers.  The idea is to use a pair of integers <em>a</em> and
<em>b</em>, initialized to  <em>F</em><em>i</em><em>b</em>(1) = 1 and  <em>F</em><em>i</em><em>b</em>(0) = 0,
and to repeatedly apply the simultaneous
transformations
</p>

<p class="trans" lang="ja">
フィボナッチ数を計算する反復的プロセスを定式化することもできる。
要点は、<em class="en">a</em>と<em class="en">b</em>という整数の対——
<span class="math"><em class="en">Fib</em>(1) = 1</span> と 
<span class="math"><em class="en">Fib</em>(0) = 0</span> 
に初期化される——を使うことと、以下に示す同時の変形を繰り返し適用することである。
</p>

<figure><img src="ch1-Z-G-16.gif"></figure>

<p class="orig" lang="en">
It is not hard to show that, after applying this transformation <em>n</em>
times, <em>a</em> and <em>b</em> will be equal, respectively, to  <em>F</em><em>i</em><em>b</em>(<em>n</em> + 1) and
 <em>F</em><em>i</em><em>b</em>(<em>n</em>).  Thus, we can compute Fibonacci numbers iteratively using
the procedure
</p>

<p class="trans" lang="ja">
この変形を<em class="en">n</em>回適用した後で、<em class="en">a</em>と<em class="en">b</em>が、それぞれ、 
<span class="math"><em class="en">Fib</em>(<em class="en">n</em> + 1)</span> と 
<span class="math"><em class="en">Fib</em>(<em class="en">n</em>)</span> 
に等しくなる、と示すことは難しくない。
よって、以下の手続きを使って、フィボナッチ数を反復的に計算することができる。
</p>

<p class="lisp"><a name="%_idx_726"></a>(define (fib n)
  (fib-iter 1 0 n))

(define (fib-iter a b count)
  (if (= count 0)
      b
      (fib-iter (+ a b) a (- count 1))))</p>

<p class="orig" lang="en">
This second method for computing  <em>F</em><em>i</em><em>b</em>(<em>n</em>) is a linear iteration.  The
difference in number of steps required by the two methods -- one linear in <em>n</em>,
one growing as fast as  <em>F</em><em>i</em><em>b</em>(<em>n</em>) itself -- is enormous, even for
small inputs.
</p>

<p class="trans" lang="ja">
<span class="math"><em class="en">Fib</em>(<em class="en">n</em>)</span> 
を計算するための、この二番目の方法は、線形的な反復である。
二つの方法で必要なステップの数の違い——片方は <em class="en">n</em> に対して線形であり、もう片方は 
<span class="math"><em class="en">Fib</em>(<em class="en">n</em>)</span>
自体と同じくらい速く増大する——は、小さな入力に対してでさえも、とても大きい。
</p>

<p class="orig" lang="en">
One should not conclude from this that tree-recursive processes are
useless.  When we consider processes that operate on hierarchically
structured data rather than numbers, we will find that tree recursion
is a natural and powerful tool.<a name="call_footnote_Temp_51" href="#footnote_Temp_51"><sup><small>32</small></sup></a> But even in numerical operations,
tree-recursive processes can be useful in helping us to understand and
design programs.  For instance, although the first <tt>fib</tt> procedure
is much less efficient than the second one, it is more
straightforward, being little more than a translation into Lisp of the
definition of the Fibonacci sequence.  To formulate the iterative
algorithm required noticing that the computation could be recast as an
iteration with three state variables.
</p>

<p class="trans" lang="ja">
だが、このことから、木構造再帰的なプロセスが無用だ、と結論づけるべきではない。
<!--木構造再帰的なプロセスが無用だと、このことから結論づけるべきではない。-->
数に関してというよりもむしろ、階層的に構造化されたデータに関して動作するプロセスについて考える場合、私たちは、木構造再帰が自然かつ強力な道具だと気づくだろう<a href="#footnote_Temp_51"><sup><small>32</small></sup></a>。
だが、数値的な演算においてであっても、木構造再帰的なプロセスは、私たちがプログラムを理解したり設計したりするのを助けるうえで、有用であり得る。
たとえば、一番目の <tt>fib</tt> という手続きは、二番目のものより遥かに非効率的だが、より分かりやすい——フィボナッチ列の定義の、Lispへの変換にすぎないので。
<!--反復的アルゴリズムを定式化するためには、三つの状態変数を用いた反復として計算を書き直せる、と気づくことが必要だった。-->
反復的アルゴリズムを定式化することは、三つの状態変数を用いた反復として計算を書き直せる、と気づくことを必要とした。
</p>

<a name="%_sec_Temp_52"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_52">Example: Counting change</a></h4>
<h4 class="trans" lang="ja">例: 両替方法を数える</h4>

<a name="%_idx_728"></a>
<p class="orig" lang="en">
It takes only a bit of cleverness to come up with the iterative
Fibonacci algorithm.  In contrast, consider the
following problem: How many different ways can we make change of $ 1.00,
given half-dollars, quarters, dimes, nickels, and pennies?  More
generally, can we write a procedure to compute the number of ways to
change any given amount of money?
</p>

<p class="trans" lang="ja">
反復的なフィボナッチ・アルゴリズムを考えつくには、ちょっとした賢ささえあればよい。
それに対して、以下の問題を検討してみよう。
何通りの異なる方法で、1.00ドルをくずせるだろうか？——50セント硬貨、25セント硬貨、10セント硬貨、5セント硬貨、1セント硬貨があるものとして。
より一般的には、任意の所与の金額を両替する仕方の数を計算する手続きを書けるだろか？
</p>

<p class="orig" lang="en">
This problem has a simple solution as a recursive procedure.  Suppose
we think of the types of coins available as arranged in some order.
Then the following relation holds:
</p>

<p class="trans" lang="ja">
この問題には、再帰的手続きとしての簡潔な解法がある。
利用可能な硬貨の種類が、何らかの順序で並べられている、と見なすことにしよう。
すると、以下の関係が成り立つ。
</p>

<p class="orig" lang="en">
The number of ways to change amount <em>a</em> using <em>n</em> kinds of coins equals
</p>

<p class="trans" lang="ja">
<em class="en">n</em> 種類の硬貨を使って、<em class="en">a</em> という金額を両替する方法の数は、以下に等しい。
</p>

<ul class="orig" lang="en">
<li>the number of ways to change amount <em>a</em> using all but the first
kind of coin, plus</li>
<li>the number of ways to change amount <em>a</em> - <em>d</em> using all <em>n</em> kinds of
coins, where <em>d</em> is the denomination of the first kind of coin.</li>
</ul>

<ul class="trans" lang="ja">
<li>最初の種類以外のすべての種類の硬貨を使って、<em class="en">a</em> という金額を両替する方法の数、に足すことの、</li>
<li><em class="en">d</em> を最初の種類の硬貨の額面として、<em class="en">n</em> 種類すべての硬貨を使って、
<span class="math"><em class="en">a</em> &minus; <em class="en">d</em></span>
という金額を両替する方法の数。<!--ただしここで、<em class="en">d</em> は、最初の種類の硬貨の額面である。--></li>
</ul>

<p class="orig" lang="en">
To see why this is true, observe that the ways to make change can be
divided into two groups: those that do not use any of the first kind
of coin, and those that do.  Therefore, the total number of ways to
make change for some amount is equal to the number of ways to make
change for the amount without using any of the first kind of coin,
plus the number of ways to make change assuming that we do use the
first kind of coin.  But the latter number is equal to the number of
ways to make change for the amount that remains after using a coin of
the first kind.</p>

<p class="trans" lang="ja">
なぜこれが本当なのかということを確かめるために、両替するための方法を二つのグループ——最初の種類の硬貨を一枚も使わない方法と、最初の種類の硬貨を使う方法——に分けることができる、ということに気づいてほしい。
よって、ある金額を両替する方法の総数は、最初の種類の硬貨を一枚も使わずに当該金額を両替する方法の数に足すことの、最初の種類の硬貨を確かに使うという仮定のもとで両替を行う方法の数、に等しい。
<!--さて、-->ところが後者の数は、最初の種類の一枚の硬貨を使った後に残る金額を両替する方法の数に等しい。
</p>

<p class="orig" lang="en">
Thus, we can recursively reduce the problem of changing a given amount
to the problem of changing smaller amounts using fewer kinds of coins.
Consider this reduction rule carefully, and convince yourself that we
can use it to describe an algorithm if we specify the following
degenerate cases:<a name="call_footnote_Temp_53" href="#footnote_Temp_53"><sup><small>33</small></sup></a>
</p>

<p class="trans" lang="ja">
よって、所与の金額を両替する問題を、より少ない種類の硬貨を使ってより少ない金額を両替する問題へと、再帰的に<!--小さくしてゆくことが-->還元できる。
この<!--縮小-->還元の法則を注意深く考えてみよう。そして、<!--もし以下の退化した場合を指定するなら、アルゴリズムを記述するのにこの法則を使うことができるのだ、-->以下の退化した場合を指定すれば、アルゴリズムを記述するのにこの還元の法則を使えるのだ、と自分を納得させよう<a href="#footnote_Temp_53"><sup><small>33</small></sup></a>。
</p>

<ul class="orig" lang="en">
<li>If <em>a</em> is exactly 0, we should count that as 1 way to make change.</li>
<li>If <em>a</em> is less than 0, we should count that as 0 ways to make change.</li>
<li>If <em>n</em> is 0, we should count that as 0 ways to make change.</li>
</ul>

<ul class="trans" lang="ja">
<li>もし <em class="en">a</em>  がちょうど 0 なら、そのことをもって、両替の方法が 1 通りだと見なすべきである。</li>
<li>もし <em class="en">a</em> が 0 未満なら、そのことをもって、両替の方法が 0 <!--ゼロ-->通りだと見なすべきである。</li>
<li>もし <em class="en">n</em> が 0 なら、そのことをもって、両替の方法が 0 <!--ゼロ-->通りだと見なすべきである。</li> 
</ul>

<p class="orig" lang="en">
We can easily translate this description into a recursive
procedure:
</p>

<p class="trans" lang="ja">
この記述を、以下のような再帰的手続きに簡単に書き換えることができる。
</p>

<p class="lisp"><a name="%_idx_730"></a>(define (count-change amount)
  (cc amount 5))
(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (&lt; amount 0) (= kinds-of-coins 0)) 0)
        (else (+ (cc amount
                     (- kinds-of-coins 1))
                 (cc (- amount
                        (first-denomination kinds-of-coins))
                     kinds-of-coins)))))
(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))</p>

<p class="orig" lang="en">
(The <tt>first-denomination</tt> procedure takes as input the number of
kinds of coins available and returns the denomination of the first
kind.  Here we are thinking of the coins as arranged in order from
largest to smallest, but any order would do as well.)  We can now
answer our original question about changing a dollar:
</p>

<p class="trans" lang="ja">
(<tt>first-denomination</tt> という手続きは、入力として、利用可能な硬貨の種類の数をとり、最初の種類の額面を返す。
ここでは、硬貨が、最も高額なものから最も低額なものへ、という順序で並べられているものと見なしているが、どんな順序でも同様にうまくいくだろう)。
さて今や、1 ドルの両替についての最初の質問に答えられるわけだ。
</p>

<p class="lisp">(count-change 100)
<i>292</i></p>

<p class="orig" lang="en">
<tt>Count-change</tt> generates a tree-recursive process with
redundancies similar to those in our first implementation of <tt>fib</tt>.  (It will take quite a while for that 292 to be computed.)  On
the other hand, it is not obvious how to design a better algorithm
for computing the result, and we leave this problem as a challenge.
The observation that a <a name="%_idx_732"></a>tree-recursive process may be highly
inefficient but often easy to specify and understand has led people to
propose that one could get the best of both worlds by designing a
``smart compiler'' that could transform tree-recursive procedures into
more efficient procedures that compute the same result.<a name="call_footnote_Temp_54" href="#footnote_Temp_54"><sup><small>34</small></sup></a>
</p>

<p class="trans" lang="ja">
<tt>count-change</tt> は、私たちの最初の <tt>fib</tt> の実装における冗長性と類似の冗長性を有する、木構造再帰的なプロセスを生成する
(あの292が計算されるには結構時間がかかるだろう)。
他方、結果を計算するためのより良いアルゴリズムをどのように設計すべきか、ということは自明ではないし、私たちはこの問題を課題として残しておく。
木構造再帰的なプロセスが、非常に非効率になり得るものの、多くの場合では、その明細を規定したり理解したりするのに容易であり得る、という観察結果は、人々を、次のような提案へと向かわせてきた。すなわち、木構造再帰的な手続きを、それと同じ結果を計算する、より効率的な手続きに変換できるような、「賢いコンパイラ」を設計することで、両者のいいとこ取りができるだろう、という提案を行うように仕向けてきたのである<a href="#footnote_Temp_54"><sup><small>34</small></sup></a>。
</p>

<p class="orig" lang="en"><a name="%_thm_1.11"></a>
<b>Exercise 1.11.</b>&nbsp;&nbsp;A function <em>f</em> is defined by the rule that <em>f</em>(<em>n</em>) = <em>n</em> if <em>n</em>&lt;3 and
<em>f</em>(<em>n</em>) = <em>f</em>(<em>n</em> - 1) + 2<em>f</em>(<em>n</em> - 2) + 3<em>f</em>(<em>n</em> - 3) if <em>n</em><u>&gt;</u> 3.  Write a procedure that
computes <em>f</em> by means of a recursive process.  Write a procedure that
computes <em>f</em> by means of an iterative process.
</p>

<p class="trans" lang="ja">
<b>練習問題 1.11.</b> <em class="en">f</em> という関数は、 
<span class="math"><em class="en">n</em> &lt; 3</span>
の場合は
<span class="math"><em class="en">f</em>(<em class="en">n</em>) = <em class="en">n</em></span>
であり、
<span class="math"><em class="en">n</em> &ge; 3</span>
の場合は
<span class="math"><em class="en">f</em>(<em class="en">n</em>) = <em class="en">f</em>(<em class="en">n</em> &minus; 1) + 2<em class="en">f</em>(<em class="en">n</em> &minus; 2) + 3<em class="en">f</em>(<em class="en">n</em> &minus; 3)</span> 
である、という規則により定義される。
再帰的プロセスにより <em class="en">f</em> を計算する手続きを書け。
反復的プロセスにより <em class="en">f</em> を計算する手続きを書け。
</p>

<p class="exercise"><span class="ex_comment">; 再帰的</span>
(define (f n)
  (cond ((< n 3) n)
        (else (+ (f (- n 1)) (* 2 (f (- n 2))) (* 3 (f (- n 3)))))))
</p>

<p class="exercise"><span class="ex_comment">; 反復的</span>
(define (f n) (f-iter 2 1 0 n))
<span class="ex_comment">; p1=f(j&minus;1), p2=f(j&minus;2), p3=f(j&minus;3) の意。
; なお、n &ge; 3 の場合は j&minus;3 + count = n</span>
(define (f-iter p1 p2 p3 count)
  (cond ((< count 0) count)  <span class="ex_comment">; countの定義域が0以上に限定されるならここは不要。</span>
        ((= count 0) p3)
        ((= count 1) p2)
        ((= count 2) p1)
        (else (f-iter (+ p1 (* 2 p2) (* 3 p3)) p1 p2 (- count 1)))))

<span class="ex_comment">; 以下のようになる。</span>
(f 0) = (f-iter 2 1 0 0) = 0
(f 1) = (f-iter 2 1 0 1) = 1
(f 2) = (f-iter 2 1 0 2) = 2

(f 3) = (f-iter 2 1 0 3)
      = (f-iter 4 2 1 2) = 4<span class="ex_comment">    ; 2+2*1+3*0=4</span>

(f 4) = (f-iter 2 1 0 4)
      = (f-iter 4 2 1 3)
      = (f-iter 11 4 2 2) = 11<span class="ex_comment">    ; 4+2*2+3*1=4+4+3=11</span>

(f 5) = (f-iter 2 1 0 5)
      = (f-iter 4 2 1 4)
      = (f-iter 11 4 2 3)
      = (f-iter 25 11 4 2) = 25<span class="ex_comment">    ; 11+2*4+3*2=11+8+6=25</span>

(f 6) = (f-iter 2 1 0 6)
      = (f-iter 4 2 1 5)
      = (f-iter 11 4 2 4)
      = (f-iter 25 11 4 3)
      = (f-iter 59 25 11 2) = 59<span class="ex_comment">    ; 25+2*11+3*4=25+22+12=59</span>
</p>

<p class="orig" lang="en"><a name="%_thm_1.12"></a>
<b>Exercise 1.12.</b>&nbsp;&nbsp;<a name="%_idx_738"></a>The following pattern of numbers is called
<em>Pascal's triangle</em>.
</p>

<p class="trans" lang="ja">
<b>練習問題 1.12.</b> 以下の数のパタンは、<em>パスカルの三角形</em>と呼ばれる。
</p>

<figure><img src="ch1-Z-G-17.gif"></figure>

<p class="orig" lang="en">
The numbers at the edge of the triangle are all 1, and
each number inside the triangle is the sum of the two numbers above it.<a name="call_footnote_Temp_57" href="#footnote_Temp_57"><sup><small>35</small></sup></a>
Write a procedure that computes elements of Pascal's triangle by means
of a recursive process.
</p>

<p class="trans" lang="ja">
三角形の辺上の数はどれも1であり、三角形の内部にある各々の数は、その数の上にある二つの数の和である<a href="#footnote_Temp_57"><sup><small>35</small></sup></a>。
再帰的プロセスによりパスカルの三角形の要素を計算する手続きを書け。
</p>

<p class="exercise"><span class="ex_comment">; 面倒なのでエラー処理なし。
; row=上から何段目か?  col=左から何番目か?  とする。</span>
(define (pascal-element row col)
  (cond ((< row 3) 1)
         ((or (= col 1) (= col row)) 1)
         (else (+ (pascal-element (- row 1) (- col 1))
                  (pascal-element (- row 1) col)))))
</p>
<p class="exercise"><span class="ex_comment">; 実行例</span>
gosh&gt; (pascal-element 1 1)
1
gosh&gt; (pascal-element 2 1)
1
gosh&gt; (pascal-element 2 2)
1
gosh&gt; (pascal-element 3 1)
1
gosh&gt; (pascal-element 3 2)
2
gosh&gt; (pascal-element 3 3)
1
gosh&gt; (pascal-element 4 1)
1
gosh&gt; (pascal-element 4 2)
3
gosh&gt; (pascal-element 4 3)
3
gosh&gt; (pascal-element 4 4)
1
gosh&gt; (pascal-element 5 1)
1
gosh&gt; (pascal-element 5 2)
4
gosh&gt; (pascal-element 5 3)
6
gosh&gt; (pascal-element 5 4)
4
gosh&gt; (pascal-element 5 5)
1
</p>

<p class="orig" lang="en"><a name="%_thm_1.13"></a>
<b>Exercise 1.13.</b>&nbsp;&nbsp;Prove that  <em>F</em><em>i</em><em>b</em>(<em>n</em>) is the closest integer to <img src="book-Z-G-D-11.gif" border="0"><sup><em>n</em></sup>/<img src="book-Z-G-D-13.gif" border="0">5,
where <img src="book-Z-G-D-11.gif" border="0"> =  (1 + <img src="book-Z-G-D-13.gif" border="0">5)/2.  Hint: Let <img src="book-Z-G-D-12.gif" border="0"> =  (1 - <img src="book-Z-G-D-13.gif" border="0">5)/2.  Use
induction and the definition of the Fibonacci numbers (see
section&nbsp;<a href="#%_sec_1.2.2">1.2.2</a>) to prove that  <em>F</em><em>i</em><em>b</em>(<em>n</em>) = (<img src="book-Z-G-D-11.gif" border="0"><sup><em>n</em></sup>
 - <img src="book-Z-G-D-12.gif" border="0"><sup><em>n</em></sup>)/<img src="book-Z-G-D-13.gif" border="0">5.
</p>

<p class="trans" lang="ja">
<b>練習問題 1.13.</b>  
<span class="math"><em class="en">Fib</em>(<em class="en">n</em>)</span>
が
<span class="math">&phi;<sup><em class="en">n</em></sup>/&radic;5</span>
に最も近い整数であることを証明せよ——ただしここで、
<span class="math">&phi; =  (1 + &radic;5)/2</span>
である。<br>
ヒント: 
<span class="math">&psi; =  (1 &minus; &radic;5)/2</span>
とする。
帰納法と、フィボナッチ数の定義 (<a href="#%_sec_1.2.2">1.2.2</a>節を参照) を使って、
<span class="math"><em class="en">Fib</em>(<em class="en">n</em>) = (&phi;<sup><em class="en">n</em></sup> &minus; &psi;<sup><em class="en">n</em></sup>)/&radic;5</span>
と証明せよ。
</p>

<p class="exercise"><span class="ex_comment">(A) <em class="en">n</em>=0 の場合について。
定義より Fib(0) = 0 である。また、&phi;<sup><em class="en">n</em></sup>/&radic;5 = &phi;<sup>0</sup>/&radic;5 = 1/&radic;5 である。
ここで、0 &lt; 1/&radic;5 &lt; 1/2 &lt; 1 だから、&phi;<sup><em class="en">n</em></sup>/&radic;5 は1より0に近い。
つまり、Fib(0) は &phi;<sup>0</sup>/&radic;5 に最も近い整数である。&hellip; (A-1)とする。
ついでに言うと、
(&phi;<sup><em class="en">n</em></sup>&minus;&psi;<sup><em class="en">n</em></sup>)/&radic;5 = (&phi;<sup>0</sup>&minus;&psi;<sup>0</sup>)/&radic;5 = (1&minus;1)/&radic;5 = 0
なので、ヒントのとおり、Fib(0)=(&phi;<sup>0</sup>&minus;&psi;<sup>0</sup>)/&radic;5 である。&hellip; (A-2)とする。

(B) <em class="en">n</em>=1 の場合について。
定義より Fib(1) = 1 である。また、&phi;<sup><em class="en">n</em></sup>/&radic;5 = &phi;<sup>1</sup>/&radic;5 = (&radic;5+5)/10 である。
ここで、0 &lt; 0.5 = 5/10 &lt; (&radic;5+5)/10 &lt; 10/10 = 1 だから、&phi;<sup><em class="en">n</em></sup>/&radic;5 は0より1に近い。
つまり、Fib(1) は &phi;<sup>1</sup>/&radic;5 に最も近い整数である。&hellip; (B-1)とする。
ついでに言うと、
(&phi;<sup><em class="en">n</em></sup>&minus;&psi;<sup><em class="en">n</em></sup>)/&radic;5 = (&phi;<sup>1</sup>&minus;&psi;<sup>1</sup>)/&radic;5 = ((1+&radic;5)/2 &minus; (1&minus;&radic;5)/2)/&radic;5 = &radic;5/&radic;5 = 1
なので、ヒントのとおり、Fib(1)=(&phi;<sup>1</sup>&minus;&psi;<sup>1</sup>)/&radic;5 である。&hellip; (B-2)とする。

(C) ここで少し横道にそれることにする。<a href="#%_sec_1.2.2">1.2.2</a>節で<a href="#%_idx_724">黄金比</a>について
&phi;<sup>2</sup>=&phi;+1
と書いてあったが、たしかに、
&phi;<sup>2</sup> = ((1+&radic;5)/2)<sup>2</sup> = (1+2&radic;5+5)/4 = (3+&radic;5)/2 = (1+&radic;5)/2 + 1 = &phi;+1
である。&hellip; (C-1)とする。
また、
&psi;<sup>2</sup> = ((1&minus;&radic;5)/2)<sup>2</sup> = (1&minus;2&radic;5+5)/4 = (3&minus;&radic;5)/2 = (1&minus;&radic;5)/2 + 1 = &psi;+1
でもある。&hellip; (C-2)とする。
要するに &phi; と &psi; は、x<sup>2</sup> &minus; x &minus; 1 = 0 の二つの解である。

(D) 話を <em class="en">n</em> &ge; 2 の場合に戻す。
定義より Fib(n)=Fib(n&minus;1)+Fib(n&minus;2) である。&hellip; (D-1)とする。
ここで、
「0 &le; k &le; n&minus;1 なるすべての k について、Fib(k)=(&phi;<sup>k</sup>&minus;&psi;<sup>k</sup>)/&radic;5 が成り立つ」
と仮定する。&hellip; (D-2)とする。
ここで、(D-1)の定義に、(D-2)の等式を代入し、式を整理して(C-1)と(C-2)を代入する。すると、
  Fib(n) 
= Fib(n&minus;1)+Fib(n&minus;2)
= (&phi;<sup>n&minus;1</sup>&minus;&psi;<sup>n&minus;1</sup>)/&radic;5 + (&phi;<sup>n&minus;2</sup>&minus;&psi;<sup>n&minus;2</sup>)/&radic;5
= (&phi;<sup>n&minus;2</sup> &middot; (&phi;+1) &minus; &psi;<sup>n&minus;2</sup> &middot; (&psi;+1))/&radic;5
= (&phi;<sup>n&minus;2</sup> &middot; &phi;<sup>2</sup> &minus; &psi;<sup>n&minus;2</sup> &middot; &psi;<sup>2</sup> )/&radic;5
= (&phi;<sup>n</sup>&minus;&psi;<sup>n</sup>)/&radic;5
なので、ヒントの式は n のときにも成り立つ。&hellip; (D-3)とする。
(A-2)と(B-2)が成り立っており、かつ、(D-2)の仮定からは(D-3)の結論が得られる
のだから、数学的帰納法により、
「0 &le; n なるすべての n について、Fib(n)=(&phi;<sup>n</sup>&minus;&psi;<sup>n</sup>)/&radic;5 が成り立つ」
と言える。&hellip; (D-4)とする。

(E) ということは、あとは、
「(&phi;<sup>n</sup>&minus;&psi;<sup>n</sup>)/&radic;5 は&phi;<sup>n</sup>/&radic;5に最も近い整数である」
と言えればよい (ふう、やれやれ)。&hellip; (E-1)とする。
ここで、
&psi; = (1 &minus; &radic;5)/2 = &minus;0.61&hellip;
なので、n &ge; 2 の場合には明らかに
|&psi;<sup>n</sup>/&radic;5| &lt; |&psi;<sup>n</sup>| &lt; 1/2
である。
つまり、n &ge; 2 の場合には、(&phi;<sup>n</sup>&minus;&psi;<sup>n</sup>)/&radic;5 は、
&phi;<sup>n</sup>/&radic;5 との差の絶対値が 1/2 より小さい整数なのであり、
それは換言すれば、&phi;<sup>n</sup>/&radic;5 に最も近い整数ということである。
これで、n &ge; 2 の場合については(E-1)が証明できた。
そして、n=0の場合とn=1の場合にも、既に(A-1)と(B-1)に示したとおり、(E-1)が成立している。
結局、0 &le; n なるすべてのnについて、(E-1)が証明できた訳である。
したがって、このことと(D-4)より、0 &le; n なるすべてのnについて、
「<span class="math"><em class="en">Fib</em>(<em class="en">n</em>)</span> は <span class="math">&phi;<sup><em class="en">n</em></sup>/&radic;5</span> に最も近い整数である」
と証明された。以上。</span></p>

<a name="%_sec_1.2.3"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_1.2.3">1.2.3&nbsp;&nbsp;Orders of Growth</a></h3>
<h3 class="trans" lang="ja">1.2.3  増大のオーダ</h3>

<p class="orig" lang="en">
<a name="%_idx_752"></a>
The previous examples illustrate that processes can differ
considerably in the rates at which they consume computational
resources.  One convenient way to describe this difference is to use
the notion of <a name="%_idx_754"></a><em>order of growth</em> to obtain a gross measure of the
<a name="%_idx_756"></a>resources required by a process as the inputs become larger.
</p>

<p class="trans" lang="ja">
先の例は、計算資源を消費する<!--割合-->速さという点で、プロセス同士が非常に異なり得る、ということを示している。
この差異を記述するための一つの便利な方法は、<!--入力が大きくなるにつれてプロセスが必要とする資源の総量の目安を得るために、<em>増大のオーダ (階級)</em>の概念を使うことである。--><em>増大のオーダ (階級)</em>の概念を使って、入力が大きくなるにつれてプロセスが必要とする資源の総量の目安を得ることである。
</p>

<p class="orig" lang="en">
Let <em>n</em> be a parameter that measures the size of the problem, and let
<em>R</em>(<em>n</em>) be the amount of resources the process requires for a problem
of size <em>n</em>.  In our previous examples we took <em>n</em> to be the number
for which a given function is to be computed, but there are other
possibilities.  For instance, if our goal is to compute an
approximation to the square root of a number, we might take <em>n</em> to be
the number of digits accuracy required.  For matrix multiplication we
might take <em>n</em> to be the number of rows in the matrices.  In general
there are a number of properties of the problem with respect to which
it will be desirable to analyze a given process.  Similarly, <em>R</em>(<em>n</em>)
might measure the number of internal storage registers used, the
number of elementary machine operations performed, and so on.  In
computers that do only a fixed number of operations at a time, the
time required will be proportional to the number of elementary machine
operations performed.
</p>

<p class="trans" lang="ja">
<em class="en">n</em> を、問題の大きさを測るパラメタだとし、<em class="en">R</em>(<em class="en">n</em>) を、大きさが <em class="en">n</em> の問題のためにプロセスが必要とする資源の量だとする。
先の例では、私たちは、<em class="en">n</em> を、与えられた関数を計算すべき対象となっている数だと考えたのだが、他の可能性もある。
たとえば、もし、ある数の二乗根の近似値を計算することが目的ならば、<em class="en">n</em> を、必要な精度の桁数だと考えてもよいかもしれない。
行列の乗算に関しては、<em class="en">n</em> を、行列の行の数だと考えてもよいかもしれない。
一般に、問題には、与えられたプロセスをその属性に関して分析するのが望ましいだろうな、という属性がいくつもある。
同様に、<em class="en">R</em>(<em class="en">n</em>) は、使用される内部記憶レジスタの数や、実行される基本的なマシン演算の数などを計測するものかもしれない。
一度に所定の数の演算しか行わないコンピュータでは、必要な時間は、実行される基本的なマシン演算の数に比例するだろう。
</p>

<p class="orig" lang="en">
<a name="%_idx_758"></a><a name="%_idx_760"></a>We say that <em>R</em>(<em>n</em>) has order of growth <img src="book-Z-G-D-3.gif" border="0">(<em>f</em>(<em>n</em>)), written
<em>R</em>(<em>n</em>) = <img src="book-Z-G-D-3.gif" border="0">(<em>f</em>(<em>n</em>)) (pronounced ``theta of <em>f</em>(<em>n</em>)''), if there are
positive constants <em>k</em><sub>1</sub> and <em>k</em><sub>2</sub> independent of <em>n</em> such that
</p>

<p class="trans" lang="ja">
以下を満たす場合、<em class="en">R</em>(<em class="en">n</em>) 
の増大のオーダは
&Theta;(<em class="en">f</em>(<em class="en">n</em>)) 
であると言い、これは、
<span class="math"><em class="en">R</em>(<em class="en">n</em>) = &Theta;(<em class="en">f</em>(<em class="en">n</em>))</span> 
のように書かれる (「<em class="en">f</em>(<em class="en">n</em>) のシータ」と発音する)。すなわち、
<em class="en">n</em> とは独立な正の定数 <em class="en">k</em><sub>1</sub> と <em class="en">k</em><sub>2</sub> が存在して、
</p>

<figure><img src="ch1-Z-G-18.gif"></figure>

<p class="orig" lang="en">
for any sufficiently large value of <em>n</em>.  (In other
words, for large <em>n</em>, the value <em>R</em>(<em>n</em>) is sandwiched between <em>k</em><sub>1</sub><em>f</em>(<em>n</em>)
and <em>k</em><sub>2</sub><em>f</em>(<em>n</em>).)
</p>

<p class="trans" lang="ja">
という式が、任意の十分に大きな値の <em class="en">n</em> に対して満たされる場合である
(換言すれば、大きな <em class="en">n</em> に対して、
<em class="en">R</em>(<em class="en">n</em>) という値が、
<em class="en">k</em><sub>1</sub><em class="en">f</em>(<em class="en">n</em>) 
と 
<em class="en">k</em><sub>2</sub><em class="en">f</em>(<em class="en">n</em>) で挟まれるわけだ)。
</p>

<p class="orig" lang="en">
<a name="%_idx_762"></a><a name="%_idx_764"></a><a name="%_idx_766"></a>For instance, with the linear recursive process for computing
factorial described in section&nbsp;<a href="#%_sec_1.2.1">1.2.1</a> the
number of steps grows proportionally to the input <em>n</em>.  Thus, the
steps required for this process grows as <img src="book-Z-G-D-3.gif" border="0">(<em>n</em>).  We also saw
that the space required grows as <img src="book-Z-G-D-3.gif" border="0">(<em>n</em>).  For the <a name="%_idx_768"></a><a name="%_idx_770"></a><a name="%_idx_772"></a>iterative
factorial, the number of steps is still <img src="book-Z-G-D-3.gif" border="0">(<em>n</em>) but the space is
<img src="book-Z-G-D-3.gif" border="0">(1) -- that is, constant.<a name="call_footnote_Temp_59" href="#footnote_Temp_59"><sup><small>36</small></sup></a> The <a name="%_idx_774"></a><a name="%_idx_776"></a><a name="%_idx_778"></a>tree-recursive Fibonacci computation requires
<img src="book-Z-G-D-3.gif" border="0">(<img src="book-Z-G-D-11.gif" border="0"><sup><em>n</em></sup>) steps and space <img src="book-Z-G-D-3.gif" border="0">(<em>n</em>), where <img src="book-Z-G-D-11.gif" border="0"> is the
golden ratio described in section&nbsp;<a href="#%_sec_1.2.2">1.2.2</a>.
</p>

<p class="trans" lang="ja">
たとえば、<a href="#%_sec_1.2.1">1.2.1</a>節で説明した、階乗を計算する線形再帰的プロセスでは、ステップ数は、入力たる <em class="en">n</em> に比例して増える。
よって、このプロセスに必要なステップは、&Theta;(<em class="en">n</em>) <!--と同様に-->のように増える。
また、必要な空間が &Theta;(<em class="en">n</em>) <!--と同様に-->のように増えることも見た。
反復的な階乗については、ステップ数は依然として &Theta;(<em class="en">n</em>) のままだが、空間は &Theta;(1) である——つまり、定数である<a href="#footnote_Temp_59"><sup><small>36</small></sup></a>。
木構造的再帰によるフィボナッチ計算は、
&Theta;(&phi;<sup><em class="en">n</em></sup>) 個のステップを要し、 
&Theta;(<em class="en">n</em>) <!--という大きさ-->の空間を要する——ただしここで、&phi; は、<a href="#%_sec_1.2.2">1.2.2</a>節で説明した黄金比である。
</p>

<p class="extra" id="polishing">***ここから</p>
<p class="orig" lang="en">
Orders of growth provide only a crude description of the behavior of a
process.  For example, a process requiring <em>n</em><sup>2</sup> steps and a process
requiring 1000<em>n</em><sup>2</sup> steps and a process requiring 3<em>n</em><sup>2</sup> + 10<em>n</em> + 17 steps
all have <img src="book-Z-G-D-3.gif" border="0">(<em>n</em><sup>2</sup>) order of growth.  On the other hand, order of
growth provides a useful indication of how we may expect the behavior
of the process to change as we change the size of the problem.  For a
<a name="%_idx_780"></a><img src="book-Z-G-D-3.gif" border="0">(<em>n</em>) (linear) process, doubling the size will roughly double the amount
of resources used.  For an <a name="%_idx_782"></a>exponential process, each increment in
problem size will multiply the resource utilization by a constant
factor.  In the remainder of section&nbsp;<a href="#%_sec_1.2">1.2</a>
we will examine two
algorithms whose order of growth is <a name="%_idx_784"></a>logarithmic, so that doubling the
problem size increases the resource requirement by a constant amount.
</p>

<p class="trans" lang="ja">
増大のオーダは、プロセスの振る舞いについての大まかな説明を与えてくれるだけだ。
たとえば、
<em class="en">n</em><sup>2</sup> 
個のステップを要するプロセスと、
1000<em class="en">n</em><sup>2</sup> 
個のステップを要するプロセスと、
<span class="math">3<em class="en">n</em><sup>2</sup> + 10<em class="en">n</em> + 17</span> 
個のステップを要するプロセスは、すべて、増大のオーダが 
&Theta;(<em class="en">n</em><sup>2</sup>) である。
その一方で、増大のオーダは、問題の大きさを変えるにつれてプロセスの振る舞いがどのように変化すると予測し得るのか、ということについての、有益な指標を与えてくれる。
&Theta;(<em class="en">n</em>) の (線形な) プロセスでは、問題の大きさを二倍にすることで、使われる資源の量がほぼ二倍になるだろう。
指数関数的なプロセスでは、問題の大きさにおける各加算によって、資源利用量に定数の因子を乗じることになるだろう。
<a href="#%_sec_1.2">1.2</a>節の残りの部分では、増大のオーダが対数的である——問題の大きさを二倍にすると、資源の必要量が定数量だけ増えるようになっている——ような、二つのアルゴリズムについて、検討しよう。
</p>

<p class="orig" lang="en"><a name="%_thm_1.14"></a>
<b>Exercise 1.14.</b>&nbsp;&nbsp;Draw the tree illustrating the process generated by the <tt>count-change</tt> procedure of section&nbsp;<a href="#%_sec_1.2.2">1.2.2</a> in making
change for 11 cents.  What are the orders of growth of the space and
number of steps used by this process as the amount to be changed
increases?
</p>

<p class="trans" lang="ja">
<b>練習問題 1.14.</b>  11セントを両替する場合に関して、<a href="#%_sec_1.2.2">1.2.2</a>節の <tt>count-change</tt> という手続きにより生成されるプロセスを図解する木を描け。
このプロセスにより使われる、空間とステップの数それぞれの、両替すべき金額が増えるにつれての増大のオーダは、どのようなものか?
</p>

<p class="exercise" style="line-height:100%"><span class="ex_comment">木は以下の図のとおり。
なお、以下の図の葉ノードのうち値が1となるものは4個で、あとのものは値が0。実際、
(a) 10セント硬貨1枚+1セント1枚
(b) 5セント硬貨2枚+1セント1枚
(c) 5セント硬貨1枚+1セント6枚
(d) 1セント硬貨11枚
の4通りの両替の仕方がある
(以下の図のうち、値が1の葉は、下から順に、(a)、(b)、(c)、(d)の場合に対応する)。
</span>

(count-change 11)
  └(cc 11 5)
    ├(cc 11 4)
    │  ├(cc 11 3)
    │  │  ├(cc 11 2)
    │  │  │  ├(cc 11 1)
    │  │  │  │  ├(cc 11 0)   <span class="ex_comment">; これは 0</span>
    │  │  │  │  └(cc (- 11 1) 1)
    │  │  │  │    ├(cc 10 0)   <span class="ex_comment">; これは 0</span>
    │  │  │  │    └(cc (- 10 1) 1)
    │  │  │  │      ├(cc 9 0)   <span class="ex_comment">; これは 0</span>
    │  │  │  │      └(cc (- 9 1) 1)
    │  │  │  │        ├(cc 8 0)   <span class="ex_comment">; これは 0</span>
    │  │  │  │        └(cc (- 8 1) 1)
    │  │  │  │          ├(cc 7 0)   <span class="ex_comment">; これは 0</span>
    │  │  │  │          └(cc (- 7 1) 1)
    │  │  │  │            ├(cc 6 0)   <span class="ex_comment">; これは 0</span>
    │  │  │  │            └(cc (- 6 1) 1)
    │  │  │  │              ├(cc 5 0)  <span class="ex_comment">; これは 0</span>
    │  │  │  │              └(cc (- 5 1) 1)
    │  │  │  │                ├(cc 4 0)  <span class="ex_comment">; これは 0</span>
    │  │  │  │                └(cc (- 4 1) 1)
    │  │  │  │                  ├(cc 3 0)  <span class="ex_comment">; これは 0</span>
    │  │  │  │                  └(cc (- 3 1) 1)
    │  │  │  │                    ├(cc 2 0)  <span class="ex_comment">; これは 0</span>
    │  │  │  │                    └(cc (- 2 1) 1)
    │  │  │  │                      ├(cc 1 0)  <span class="ex_comment">; これは 0</span>
    │  │  │  │                      └(cc (- 1 1) 1)   <span class="ex_comment">; <tt>(cc 0 1)</tt> なので 1</span>
    │  │  │  └(cc (- 11 5) 2)
    │  │  │    ├(cc 6 1)
    │  │  │    │  ├(cc 6 0)  <span class="ex_comment">; これは 0</span>
    │  │  │    │  └(cc (- 6 1) 1)
    │  │  │    │    ├(cc 5 0)  <span class="ex_comment">; これは 0</span>
    │  │  │    │    └(cc (- 5 1) 1)
    │  │  │    │      ├(cc 4 0)  <span class="ex_comment">; これは 0</span>
    │  │  │    │      └(cc (- 4 1) 1)
    │  │  │    │        ├(cc 3 0)  <span class="ex_comment">; これは 0</span>
    │  │  │    │        └(cc (- 3 1) 1)
    │  │  │    │          ├(cc 2 0)  <span class="ex_comment">; これは 0</span>
    │  │  │    │          └(cc (- 2 1) 1)
    │  │  │    │            ├(cc 1 0)  <span class="ex_comment">; これは 0</span>
    │  │  │    │            └(cc (- 1 1) 1)   <span class="ex_comment">; <tt>(cc 0 1)</tt> なので 1</span>
    │  │  │    └(cc (- 6 5) 2)
    │  │  │      ├(cc 1 1)
    │  │  │      │  ├(cc 1 0)  <span class="ex_comment">; これは 0</span>
    │  │  │      │  └(cc (- 1 1) 1)   <span class="ex_comment">; <tt>(cc 0 1)</tt> なので 1</span>
    │  │  │      └(cc (- 1 5) 2)  <span class="ex_comment">; <tt>(cc -4 2)</tt> なので 0</span>
    │  │  └(cc (- 11 10) 3)
    │  │     ├(cc 1 2)
    │  │     │  ├(cc 1 1)
    │  │     │  │  ├(cc 1 0)  <span class="ex_comment">; これは 0</span>
    │  │     │  │  └(cc (- 1 1) 1)   <span class="ex_comment">; <tt>(cc 0 1)</tt> なので 1</span>
    │  │     │  └(cc (- 1 5) 2)   <span class="ex_comment">; <tt>(cc -4 2)</tt> なので 0</span>
    │  │     └(cc (- 1 10) 3)   <span class="ex_comment">; <tt>(cc -9 3)</tt> なので 0</span>
    │  └(cc (- 11 25) 4)   <span class="ex_comment">; <tt>(cc -14 4)</tt> なので 0</span>
    └(cc (- 11 50) 5)   <span class="ex_comment">; <tt>(cc -39 5)</tt> なので 0</span>
</p>

<p class="exercise"><span class="ex_comment">木の絵を描いただけでうんざりしたので、増大のオーダについてはまた今度考える。
どう見ても線形ではない。ぱっと見た感じだと、&Theta;(<em class="en">n<sup>2</sup></em>) あたりのような雰囲気だが……。</span></p>

<p class="orig" lang="en"><a name="%_thm_1.15"></a>
<b>Exercise 1.15.</b>&nbsp;&nbsp;<a name="%_idx_786"></a>The sine of an angle (specified in
radians) can be computed by making use of the approximation
<tt>sin</tt> <em>x</em> <img src="book-Z-G-D-20.gif" border="0">  <em>x</em>
if <em>x</em> is
sufficiently small, and the trigonometric identity </p>

<p class="trans" lang="ja">
<b>練習問題 1.15.</b>  角 (ラジアンで指定されている) の正弦は、<em class="en">x</em> が十分に小さい場合の 
<span class="math"><tt>sin</tt> <em class="en">x</em> &asymp; <em class="en">x</em></span> 
という近似と、以下の三角関数の恒等式
</p>

<p class="lisp"><img src="ch1-Z-G-19.gif" border="0"></p> 

<p class="orig" lang="en">
to reduce the size of the argument of <tt>sin</tt>.  (For
purposes of this exercise an angle is considered ``sufficiently
small'' if its magnitude is not greater than 0.1 radians.) These
ideas are incorporated in the following procedures:
</p>

<p class="trans" lang="ja">
—— <tt>sin</tt> の引数の大きさを小さくするためのものである——とを利用して、計算することができる
(この練習問題の目的では、角は、その大きさが0.1ラジアン以下のときに、「かなり小さい」と見なされる)。
以上の考えは、以下の手続きに取り込まれる。
</p>

<p class="lisp"><a name="%_idx_788"></a>(define (cube x) (* x x x))
(define (p x) (- (* 3 x) (* 4 (cube x))))
(define (sine angle)
   (if (not (&gt; (abs angle) 0.1))
       angle
       (p (sine (/ angle 3.0)))))
</p>

<p class="orig" lang="en">
a.&nbsp;&nbsp;How many times is the procedure <tt>p</tt> 
applied when <tt>(sine 12.15)</tt> is evaluated?
</p>

<p class="trans" lang="ja">
a.  <tt>(sine 12.15)</tt> が評価されるとき、<tt>p</tt> という手続きが何度適用されるか?
</p>

<p class="exercise"><span class="ex_comment">以下から分かるように5回。</span>
(sine 12.15)
(p (sine 4.05))
(p (p (sine 1.35)))
(p (p (p (sine 0.45))))
(p (p (p (p (sine 0.15)))))
(p (p (p (p (p (sine 0.05))))))
(p (p (p (p (p 0.05)))))
(p (p (p (p 0.14950000000000002))))
(p (p (p 0.43513455050000005)))
(p (p 0.9758465331678772))
(p -0.7895631144708228)
-0.39980345741334

<span class="ex_comment">ちなみに、</span>
gosh&gt; (sin 12.15)
-0.4044438228491401
<span class="ex_comment">であるから、まあまあの近似だろう。</span>
</p>

<p class="orig" lang="en">
b.&nbsp;&nbsp;What is the order of growth in space and number of steps (as a
function of&nbsp;<em>a</em>) used by the process generated by the <tt>sine</tt>
procedure when <tt>(sine a)</tt> is evaluated?
</p>

<p class="trans" lang="ja">
b.  <tt>(sine a)</tt> が評価されるときに <tt>sine</tt> という手続きにより生成されるプロセスにより使われる、空間とステップの数の、増大のオーダは、(<em class="en">a</em> の関数として) どのようなものか?
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_1.2.4"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_1.2.4">1.2.4&nbsp;&nbsp;Exponentiation</a></h3>
<h3 class="trans" lang="ja">1.2.4  冪乗</h3>

<p class="orig" lang="en">
<a name="%_idx_790"></a>
Consider the problem of computing the exponential of a given number.
We would like a procedure that takes as arguments a base <em>b</em> and a
positive integer exponent <em>n</em> and computes <em>b</em><sup><em>n</em></sup>.  One way to do this
is via the recursive definition</p>

<p class="trans" lang="ja">
与えられた数の冪乗を計算する問題を考えよう。
<em class="en">b</em> という基数と、<em class="en">n</em> という正整数の指数を引数としてとり、<em class="en">b</em><sup><em class="en">n</em></sup> を計算する手続きがほしい。
これを行うための一つの方法は、以下の再帰的定義を通じた方法であり、
</p>

<figure><img src="ch1-Z-G-20.gif"></figure>

<p class="orig" lang="en">
which translates readily into the procedure 
</p>

<p class="trans" lang="ja">
これは、難なく次の手続きへと変換される。
</p>

<p class="lisp"><a name="%_idx_792"></a>(define (expt b n)
  (if (= n 0)
      1
      (* b (expt b (- n 1)))))</p>

<p class="orig" lang="en">
This is a linear recursive process, which requires <img src="book-Z-G-D-3.gif" border="0">(<em>n</em>) steps
and <img src="book-Z-G-D-3.gif" border="0">(<em>n</em>) space.  Just as with factorial, we can readily
formulate an equivalent linear iteration:
</p>

<p class="trans" lang="ja">
これは、線形な再帰的プロセス—— &Theta;(<em class="en">n</em>) 個のステップと、 &Theta;(<em class="en">n</em>) の大きさの空間とを必要とする——である。
階乗の場合とちょうど同じように、等価な線形反復をすぐさま定式化することができる。
</p>

<p class="lisp"><a name="%_idx_794"></a>(define (expt b n)
  (expt-iter b n 1))

(define (expt-iter b counter product)
  (if (= counter 0)
      product
      (expt-iter b
                (- counter 1)
                (* b product)))) </p>

<p class="orig" lang="en">
This version requires <img src="book-Z-G-D-3.gif" border="0">(<em>n</em>) steps and <img src="book-Z-G-D-3.gif" border="0">(1) space.
</p>

<p class="trans" lang="ja">
このバージョンは、&Theta;(<em class="en">n</em>) 個のステップと、&Theta;(1) の大きさの空間を必要とする。
</p>

<p class="orig" lang="en">
<a name="%_idx_796"></a>We can compute exponentials in fewer steps by using successive
squaring.  For instance, rather than computing <em>b</em><sup>8</sup> as</p>

<p class="trans" lang="ja">
連続する二乗を使うことにより、より少数のステップで冪乗を計算できる。
たとえば、<em class="en">b</em><sup>8</sup> を次のように計算するよりむしろ、
</p>

<figure><img src="ch1-Z-G-21.gif" border="0"></figure>

<p class="orig" lang="en">
we can compute it using three multiplications:
</p>

<p class="trans" lang="ja">
以下のような3回の乗算を使って、<em class="en">b</em><sup>8</sup> を計算することができる。
</p>

<figure><img src="ch1-Z-G-22.gif"></figure>

<p class="orig" lang="en">
This method works fine for exponents that are powers of 2.  We can
also take advantage of successive squaring in computing exponentials
in general if we use the rule
</p>

<p class="trans" lang="ja">
この方法は、2の累乗であるような指数に対しては、うまくゆく。
以下の規則を使えば、一般の冪乗を計算する際にも、連続する二乗を利用できる。
</p>

<figure id="err01"><img src="ch1-Z-G-23.gif"></figure>

<p class="orig" lang="en">
We can express this method as a procedure:
</p>

<p class="trans" lang="ja">
この方法は、次のような手続きとして表現できる。
</p>

<p class="lisp"><a name="%_idx_798"></a>(define (fast-expt b n)
  (cond ((= n 0) 1)
        ((even? n) (square (fast-expt b (/ n 2))))
        (else (* b (fast-expt b (- n 1))))))</p>

<p class="orig" lang="en">
where the predicate to test whether an integer is even is defined in terms of
the <a name="%_idx_800"></a><a name="%_idx_802"></a>primitive procedure <tt>remainder</tt> by
</p>

<p class="trans" lang="ja">
ただしここで、整数が偶数かどうかを検査するための述語が、<tt>remainder</tt> という原始的な手続きを使って、次のように定義されているものとする。
</p>

<p class="lisp"><a name="%_idx_804"></a>(define (even? n)
  (= (remainder n 2) 0))</p>

<p class="orig" lang="en">
<a name="%_idx_806"></a><a name="%_idx_808"></a>The process evolved by <tt>fast-expt</tt> grows logarithmically with <em>n</em>
in both space and number of steps.  To see this, observe that
computing <em>b</em><sup>2<em>n</em></sup> using <tt>fast-expt</tt> requires only one more
multiplication than computing <em>b</em><sup><em>n</em></sup>.  The size of the exponent we can
compute therefore doubles (approximately) with every new
multiplication we are allowed.  Thus, the number of multiplications
required for an exponent of <em>n</em> grows about as fast as the logarithm
of <em>n</em> to the base 2.  The process has <img src="book-Z-G-D-3.gif" border="0">(<tt>log</tt> <em>n</em>)
growth.<a name="call_footnote_Temp_62" href="#footnote_Temp_62"><sup><small>37</small></sup></a>
</p>

<p class="trans" lang="ja">
<tt>fast-expt</tt> が<!--発達-->進展させるプロセスは、空間とステップ数の双方に関して、<em class="en">n</em> に対して対数的に増大する。
このことを理解するためには、<tt>fast-expt</tt> を使った 
<em class="en">b</em><sup>2<em class="en">n</em></sup> 
の計算が、
<em class="en">b</em><sup><em class="en">n</em></sup> 
の計算よりも、乗算を一回多く必要とするだけである、ということに気づこう。
よって、計算できる指数の大きさは、許される新たな一回の乗算ごとに、(ほぼ) 二倍になる。
このように、<em class="en">n</em> という指数の場合に必要な乗算の回数は、2を底とする <em class="en">n</em> の対数とほぼ同じ速さで増大する。
プロセスは、&Theta;(<tt>log</tt> <em class="en">n</em>) で増大する<a href="#footnote_Temp_62"><sup><small>37</small></sup></a>。
</p>

<p class="orig" lang="en">
The difference between <img src="book-Z-G-D-3.gif" border="0">(<tt>log</tt> <em>n</em>) growth and <img src="book-Z-G-D-3.gif" border="0">(<em>n</em>) growth
becomes striking as <em>n</em> becomes large.  For example, <tt>fast-expt</tt>
for <em>n</em> = 1000 requires only 14 multiplications.<a name="call_footnote_Temp_63" href="#footnote_Temp_63"><sup><small>38</small></sup></a> It is also possible to use the idea of
successive squaring to devise an iterative algorithm that computes
exponentials with a logarithmic number of steps
(see exercise&nbsp;<a href="#%_thm_1.16">1.16</a>), although, as is often
the case with iterative algorithms, this is not written down so
straightforwardly as the recursive algorithm.<a name="call_footnote_Temp_64" href="#footnote_Temp_64"><sup><small>39</small></sup></a>
</p>

<p class="trans" lang="ja">
&Theta;(<tt>log</tt> <em class="en">n</em>) の増大と、
&Theta;(<em class="en">n</em>) の増大の差は、<em class="en">n</em> が大きくなるにつれて著しくなる。
たとえば、<em class="en">n</em> = 1000 のときの <tt>fast-expt</tt> は、14回の乗算を要するだけである<a href="#footnote_Temp_63"><sup><small>38</small></sup></a>。
連続する二乗の考え方を使って、対数的なステップ数で冪乗を計算するような反復的アルゴリズムを考案することも可能である (練習問題<a href="#%_thm_1.16">1.16</a>を参照) ——とはいえ、そのような反復的アルゴリズムは、反復的アルゴリズムにありがちなように、再帰的アルゴリズムほど分かりやすくは書き下せないのだが<a href="#footnote_Temp_64"><sup><small>39</small></sup></a>。
</p>

<p class="orig" lang="en"><a name="%_thm_1.16"></a>
<b>Exercise 1.16.</b>&nbsp;&nbsp;Design a procedure that evolves an iterative exponentiation process
that uses successive squaring and uses a logarithmic number of steps,
as does <tt>fast-expt</tt>.  (Hint: Using the observation that
(<em>b</em><sup><em>n</em>/2</sup>)<sup>2</sup>  = (<em>b</em><sup>2</sup>)<sup><em>n</em>/2</sup>, keep, along with the exponent <em>n</em> and the
base <em>b</em>, an additional state variable <em>a</em>, and define the state
transformation in such a way that the product <em>a</em> <em>b</em><sup><em>n</em></sup> is unchanged
from state to state.  At the beginning of the process <em>a</em> is taken to
be 1, and the answer is given by the value of <em>a</em> at the end of the
process.  In general, the technique of defining an <a name="%_idx_816"></a><em>invariant
quantity</em> that remains unchanged from state to state is a powerful way
to think about the <a name="%_idx_818"></a>design of iterative algorithms.)
</p>

<p class="trans" lang="ja">
<b>練習問題 1.16.</b>   <tt>fast-expt</tt>と同様に、連続する二乗を使い、かつ、対数的な回数のステップを使うような、反復的な冪乗プロセスを<!--発達-->進展させる手続きを設計せよ。
(ヒント: 
(<span class="math"><em class="en">b</em><sup><em class="en">n</em>/2</sup>)<sup>2</sup>  = (<em class="en">b</em><sup>2</sup>)<sup><em class="en">n</em>/2</sup></span> 
という知見を使い、<em class="en">n</em> という指数および <em class="en">b</em> という基数とともに追加の状態変数の <em class="en">a</em> を保持し、 
<span class="math"><em class="en">a</em> <em class="en">b</em><sup><em class="en">n</em></sup></span> 
という積が状態ごとには変わらないような方法で状態変換を定義せよ。
プロセスの始まりにおいて <em class="en">a</em> は1とされ、プロセスの最後での <em class="en">a</em> の値により答えが与えられる。
一般に、状態ごとには変わらない<em>不変量</em>を定義する技法は、反復的アルゴリズムについて考えるための強力な方法である。)
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_1.17"></a>
<b>Exercise 1.17.</b>&nbsp;&nbsp;The exponentiation algorithms in this section are based on performing
exponentiation by means of repeated multiplication.  In a similar way,
one can perform integer multiplication by means of repeated addition.
The following multiplication procedure (in which it is assumed that
our language can only add, not multiply) is analogous to the <tt>expt</tt> procedure:
</p>

<p class="trans" lang="ja">
<b>練習問題 1.17.</b>   本節での冪乗アルゴリズムは、乗算の繰り返しという手段による冪乗の実行に基づいている。
似たようなやり方で、加算の繰り返しという手段によって、整数の乗算を実行できる。
以下のような (私たちの言語が、加算のみ可能で乗算はできない、という仮定のもとでの) 乗算手続きは、<tt>expt</tt> という手続きに類似している。
</p>

<p class="lisp">(define (* a b)
  (if (= b 0)
      0
      (+ a (* a (- b 1)))))</p>

<p class="orig" lang="en">
This algorithm takes a number of steps that is linear in <tt>b</tt>.
Now suppose we include, together with addition, operations <tt>double</tt>,
which doubles an integer, and <tt>halve</tt>, which divides an (even)
integer by 2.  Using these, design a multiplication procedure analogous
to <tt>fast-expt</tt> that uses a logarithmic number of steps. 
</p>

<p class="trans" lang="ja">
このアルゴリズムには、<tt>b</tt> に対して線形な数のステップが必要である。
ここで、加算とともに、<tt>double</tt> という演算——整数を二倍にする——と、<tt>halve</tt> という演算——(偶数の) 整数を2で割る——を含めるものと仮定しよう。
これらを使って、<tt>fast-expt</tt> と類似の、対数的な回数のステップを使う乗算手続きを設計せよ。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_1.18"></a>
<b>Exercise 1.18.</b>&nbsp;&nbsp;Using the results of exercises&nbsp;<a href="#%_thm_1.16">1.16</a>
and&nbsp;<a href="#%_thm_1.17">1.17</a>, devise a procedure that generates an iterative
process for multiplying two integers in terms of adding, doubling, and
halving and uses a logarithmic number of steps.<a name="call_footnote_Temp_68" href="#footnote_Temp_68"><sup><small>40</small></sup></a></p>

<p class="trans" lang="ja">
<b>練習問題 1.18.</b>   加算と二倍演算と半減演算を使って二つの整数を掛け合わせるための反復的プロセスを生成し、かつ、対数的な回数のステップを使うような手続きを、練習問題<a href="#%_thm_1.16">1.16</a>と<a href="#%_thm_1.17">1.17</a>の結果を使って、考案せよ<a href="#footnote_Temp_68"><sup><small>40</small></sup></a>。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_1.19"></a>
<b>Exercise 1.19.</b>&nbsp;&nbsp;
<a name="%_idx_828"></a>There is a clever algorithm for computing the Fibonacci numbers in
a logarithmic number of steps.
Recall the transformation of the state variables
<em>a</em> and <em>b</em> in the <tt>fib-iter</tt> process of
section&nbsp;<a href="#%_sec_1.2.2">1.2.2</a>: <em>a</em> <img src="book-Z-G-D-14.gif" border="0">  <em>a</em> + <em>b</em> and <em>b</em> <img src="book-Z-G-D-14.gif" border="0"> 
<em>a</em>.  Call this transformation <em>T</em>, and observe that applying <em>T</em> over
and over again <em>n</em> times, starting with 1 and 0, produces the pair
 <em>F</em><em>i</em><em>b</em>(<em>n</em> + 1) and  <em>F</em><em>i</em><em>b</em>(<em>n</em>).  In other words, the Fibonacci
numbers are produced by applying <em>T</em><sup><em>n</em></sup>, the <em>n</em>th power of the
transformation <em>T</em>, starting with the pair (1,0).  Now consider <em>T</em>
to be the special case of <em>p</em> = 0 and <em>q</em> = 1 in a family of
transformations <em>T</em><sub><em>p</em><em>q</em></sub>, where <em>T</em><sub><em>p</em><em>q</em></sub> transforms the pair (<em>a</em>,<em>b</em>)
according to <em>a</em> <img src="book-Z-G-D-14.gif" border="0">  <em>b</em><em>q</em> + <em>a</em><em>q</em> + <em>a</em><em>p</em> and <em>b</em> <img src="book-Z-G-D-14.gif" border="0">  <em>b</em><em>p</em> + <em>a</em><em>q</em>.  Show
that if we apply such a transformation <em>T</em><sub><em>p</em><em>q</em></sub> twice, the effect is
the same as using a single transformation <em>T</em><sub><em>p</em>'<em>q</em>'</sub> of the same form,
and compute <em>p</em>' and <em>q</em>' in terms of <em>p</em> and&nbsp;<em>q</em>.  This gives us an
explicit way to square these transformations, and thus we can compute
<em>T</em><sup><em>n</em></sup> using successive squaring, as in the <tt>fast-expt</tt>
procedure.  Put this all together to complete the following procedure,
which runs in a logarithmic number of steps:<a name="call_footnote_Temp_70" href="#footnote_Temp_70"><sup><small>41</small></sup></a>
</p>

<p class="trans" lang="ja">
<b>練習問題 1.19.</b>   対数的なステップ数でフィボナッチ数を計算する、賢いアルゴリズムがある。
<a href="#%_sec_1.2.2">1.2.2</a>節における <tt>fib-iter</tt> というプロセスでの、<em class="en">a</em> および <em class="en">b</em> という状態変数の変形——<span class="math"><em class="en">a</em> &larr;  <em class="en">a</em> + <em class="en">b</em></span> 
と 
<span class="mathe"><em class="en">b</em> &larr; <em class="en">a</em></span>
——を思い出そう。
この変換を <em class="en">T</em> と呼ぼう。そして、<em class="en">T</em> を <em class="en">n</em> 回にわたって繰り返し適用すること——1と0から始めて——で、
<span class="math"><em class="en">Fib</em>(<em class="en">n</em> + 1)</span> 
と 
<span class="math"><em class="en">Fib</em>(<em class="en">n</em>)</span> 
の対を作り出していることに気づいてほしい。
換言すれば、フィボナッチ数は、<span class="math">(1, 0)</span> という対から始めて、
<em class="en">T<sup>n</sup></em>
——すなわち、<em class="en">T</em> という変換の <em class="en">n</em> 乗——を適用することで、作り出される。
さて、<em class="en">T</em> を、
<em class="en">T<sub>pq</sub></em> 
という変換の族のうちで 
<span class="math"><em class="en">p</em> = 0</span> かつ 
<span class="math"><em class="en">q</em> = 1</span>  
という特殊な場合だと見なそう——なおここで、
<em class="en">T<sub>pq</sub></em> は、
<span class="math">(<em class="en">a</em>, <em class="en">b</em>)</span>
という対を、
<span class="math"><em class="en">a</em> &larr;  <em class="en">bq</em> + <em class="en">aq</em> + <em class="en">ap</em></span> 
および
<span class="math"><em class="en">b</em> &larr;  <em class="en">bp</em> + <em class="en">aq</em></span> 
 により変換する。
このような変換 <em class="en">T<sub>pq</sub></em> を二回適用したら、その効果は、同じ形式の <em class="en">T<sub>p'q'</sub></em> という一回の変換を使ったときと同じであることを示せ。そして、<em class="en">p</em>' と <em class="en">q</em>' を、<em class="en">p</em> と <em class="en">q</em> を用いて計算せよ。
このことは、これらの変換を二乗する明示的な方法を与えてくれるので、私たちは、<tt>fast-expt</tt> という手続きで行ったのと同様に、連続する二乗を用いて 
<em class="en">T<sup>n</sup></em> を計算できる。
これをすべて一緒にして、以下の手続き——対数的な回数のステップで実行される——を完成させよ<a href="#footnote_Temp_70"><sup><small>41</small></sup></a>。
</p>

<p class="lisp">(define (fib n)
  (fib-iter 1 0 0 1 n))
(define (fib-iter a b p q count)
  (cond ((= count 0) b)
        ((even? count)
         (fib-iter a
                   b
                   &lt;<em>??</em>&gt;      <em>; compute <em>p</em>'</em>
                   &lt;<em>??</em>&gt;      <em>; compute <em>q</em>'</em>
                   (/ count 2)))
        (else (fib-iter (+ (* b q) (* a q) (* a p))
                        (+ (* b p) (* a q))
                        p
                        q
                        (- count 1)))))</p>

<!--

T = \left(
    \begin{array}{cc}
      1 & 1 \\
      1 & 0
    \end{array}
  \right)

-->
<!--

T_{pq} = \left(
    \begin{array}{rr}
      p+q & q \\
      q & p
    \end{array}
  \right)

-->

<!--

\begin{array}{lll}

{T_{pq}}^2 & = & 
\left(
  \begin{array}{rr}
      p+q & q \\
      q & p
  \end{array}
\right)

\left(
  \begin{array}{rr}
      p+q & q \\
      q & p
  \end{array}
\right)
\\
\\
& = &
\left(
  \begin{array}{rr}
      (p+q)^2+q^2 & (p+q)q+pq \\
      (p+q)q+pq & q^2+p^2
  \end{array}
\right)
\\
\\
& = &
\left(
  \begin{array}{rr}
      p^2+q^2+2pq+q^2 & 2pq+q^2 \\
      2pq+q^2 & p^2+q^2
  \end{array}
\right)

\end{array}

-->

<!--
-->
<p class="exercise">
<img src="T_1110.png">
<img src="T_1110_.png">
T =⎛1  1⎞
   ⎝1  0⎠
<img src="Tpq.png">
<img src="T_pq_.png">
T<sub>pq</sub> = ⎛p+q  q⎞
      ⎝  q  p⎠


<img src="T_pq_square.png">
<img src="T_pq_2_right.png">
  ⎛p+q  q⎞⎛p+q  q⎞
  ⎝  q  p⎠⎝  q  p⎠
= ⎛(p+q)<sup>2</sup>+q<sup>2</sup>   (p+q)q+pq⎞
  ⎝(p+q)q+pq       q<sup>2</sup>+p<sup>2</sup>⎠
= ⎛p<sup>2</sup>+q<sup>2</sup>+2pq+q<sup>2</sup>   2pq+q<sup>2</sup>⎞
  ⎝2pq+q<sup>2</sup>          p<sup>2</sup>+q<sup>2</sup>⎠
<span class="ex_comment">
<em class="en">p' = p<sup>2</sup>+q<sup>2</sup>
q' = 2pq+q<sup>2</sup></em>
</span></p>

<a name="%_sec_1.2.5"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_1.2.5">1.2.5&nbsp;&nbsp;Greatest Common Divisors</a></h3>
<h3 class="trans" lang="ja">1.2.5  最大公約数</h3>

<p class="orig" lang="en">
<a name="%_idx_834"></a>
The greatest common divisor (GCD) of two integers <em>a</em> and <em>b</em> is
defined to be the largest integer that divides both <em>a</em> and
<em>b</em> with no remainder.  For example, the GCD of 16 and 28 is 4.  In chapter&nbsp;2,
when we investigate how to implement rational-number arithmetic, we
will need to be able to compute GCDs in order to reduce
rational numbers to lowest terms.  (To reduce a rational number to
lowest terms, we must divide both the numerator and the denominator by their
GCD.  For example, 16/28 reduces to 4/7.)  One way to find the
GCD of two integers is to factor them and search for common
factors, but there is a famous algorithm that is much more efficient.
</p>

<p class="trans" lang="ja">
<em class="en">a</em> と <em class="en">b</em> という二つの整数の最大公約数 (GCD) は、<em class="en">a</em> と <em class="en">b</em> の双方を割り切る最大の整数である、と定義されている。
たとえば、16と28のGCDは4である。
有理数の算術をどのように実装するかを2章で研究するときに、有理数を約分するためにはGCDを計算できなくてはならなくなるだろう。
(有理数を約分するためには、分子と分母の双方を、分子と分母のGCDで割らなくてはならない。
たとえば、16/28は約分すると4/7となる。)
二つの整数のGCDを見つける一つの方法は、それら二つの整数を因数分解して共通の因子を探すことだが、ずっと効率的な有名なアルゴリズムが存在する。
</p>

<p class="orig" lang="en">
<a name="%_idx_836"></a>The idea of the algorithm is based on the observation that, if <em>r</em> is
the remainder when <em>a</em> is divided by <em>b</em>, then the common divisors of
<em>a</em> and <em>b</em> are precisely the same as the common divisors of <em>b</em> and
<em>r</em>.  Thus, we can use the equation</p>

<p class="trans" lang="ja">
そのアルゴリズムは、もし <em class="en">r</em> が <em class="en">a</em> を <em class="en">b</em> で割った余りならば、<em class="en">a</em> と <em class="en">b</em> の公約数は、<em class="en">b</em> と <em class="en">r</em> の公約数と正確に同じである、という知見に基づいている。
よって、以下の等式を使って、
</p>

<figure><img src="ch1-Z-G-24.gif"></figure>

<p class="orig" lang="en">
to successively reduce the problem of computing a GCD to the
problem of computing the GCD of smaller and smaller pairs of
integers.  For example,</p>

<p class="trans" lang="ja">
GCDを計算する問題を、より小さな整数の対のGCDを計算する問題へと、どんどん縮退させてゆくことができる。
たとえば、
</p>

<figure><img src="ch1-Z-G-25.gif"></figure>

<p class="orig" lang="en">
reduces GCD(206,40) to GCD(2,0), which is 2.  It is
possible to show that starting with any two positive integers and
performing repeated reductions will always eventually produce a pair
where the second number is 0.  Then the GCD is the other
number in the pair.  This method for computing the GCD is
known as <em>Euclid's Algorithm</em>.<a name="call_footnote_Temp_71" href="#footnote_Temp_71"><sup><small>42</small></sup></a>
</p>

<p class="trans" lang="ja">
は、GCD(206,40) を GCD(2,0) ——つまり2——へと縮退させる。
任意の二つの正整数から始めて縮退を繰り返し実行することで、いつでも最終的には、二番目の数が0であるような対を作り出せるだろう。
すると、GCDは、その対における他方の数である。
GCDを計算するためのこの方法は、<em>ユークリッドのアルゴリズム</em>として知られる<a href="#footnote_Temp_71"><sup><small>42</small></sup></a>。
</p>

<p class="orig" lang="en">
It is easy to express Euclid's Algorithm as a procedure:
</p>

<p class="trans" lang="ja">
ユークリッドのアルゴリズムを手続きとして表現するのは簡単である。
</p>

<p class="lisp"><a name="%_idx_842"></a>(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))</p>

<p class="orig" lang="en">
This generates an iterative process, whose number of steps grows as
the logarithm of the numbers involved.
</p>

<p class="trans" lang="ja">
これは反復的プロセスを生成し、そのステップ数は、問題としている数の対数と同様に増大する。
</p>

<p class="orig" lang="en">
<a name="%_idx_844"></a>The fact that the number of steps required by Euclid's Algorithm has
logarithmic growth bears an interesting relation to the Fibonacci
numbers:
</p>

<p class="trans" lang="ja">
ユークリッドのアルゴリズムに必要なステップの数が対数的に増大する、という事実は、フィボナッチ数に対する、ますます強まる関係を示す。
</p>

<p class="orig" lang="en">
<a name="%_idx_846"></a><a name="%_idx_848"></a><strong>Lam&eacute;'s Theorem:</strong> If Euclid's Algorithm requires <em>k</em> steps to
compute the GCD of some pair, then the smaller number in the pair
must be greater than or equal to the <em>k</em>th Fibonacci
number.<a name="call_footnote_Temp_72" href="#footnote_Temp_72"><sup><small>43</small></sup></a>
</p>

<p class="trans" lang="ja">
<strong>ラメの定理:</strong> もし、ユークリッドのアルゴリズムが、ある対のGCDを計算するのに <em class="en">k</em> 個のステップを要するならば、
その対のうちの小さい方の数は、<em class="en">k</em> 番目のフィボナッチ数以上でなければならない<a href="#footnote_Temp_72"><sup><small>43</small></sup></a>。
</p>

<p class="orig" lang="en">
We can use this theorem to get an order-of-growth estimate for Euclid's
Algorithm.  Let <em>n</em> be the smaller of the two inputs to the
procedure.  If the process takes <em>k</em> steps, then we must have 
<em>n</em><u>&gt;</u>  <em>F</em><em>i</em><em>b</em> (<em>k</em>) <img src="book-Z-G-D-20.gif" border="0"> <img src="book-Z-G-D-11.gif" border="0"><sup><em>k</em></sup>/<img src="book-Z-G-D-13.gif" border="0">5.  Therefore
the number of steps <em>k</em> grows as the logarithm (to the base
<img src="book-Z-G-D-11.gif" border="0">) of <em>n</em>.  Hence, the order of growth is <img src="book-Z-G-D-3.gif" border="0">(<tt>log</tt> <em>n</em>).
</p>

<p class="trans" lang="ja">
私たちは、この定理を使って、ユークリッドのアルゴリズムの増大のオーダの見積もりを得ることができる。
<em class="en">n</em> を、手続きへの二つの入力のうちの小さい方だとしよう。
もし、プロセスが <em class="en">k</em> 個のステップを要するなら、<em class="en">n</em> &ge; <em class="en">Fib</em> (<em class="en">k</em>) &asymp; &phi;<sup><em class="en">k</em></sup>/&radic;5 とならなくてはいけない。
よって、<em class="en">k</em> というステップ数は、(&phi; を底とする) <em class="en">n</em> の対数と同様に増大する。
したがって、増大のオーダは、&Theta;(<tt>log</tt> <em class="en">n</em>) である。
</p>

<p class="orig" lang="en"><a name="%_thm_1.20"></a>
<b>Exercise 1.20.</b>&nbsp;&nbsp;<a name="%_idx_852"></a><a name="%_idx_854"></a>The process that a procedure generates is of course dependent on the
rules used by the interpreter.  As an example, consider the iterative
<tt>gcd</tt> procedure given above.
Suppose we were to interpret this procedure using normal-order
evaluation, as discussed in section&nbsp;<a href="10_sec1_1.html#%_sec_1.1.5">1.1.5</a>.
(The normal-order-evaluation rule for <tt>if</tt> is described in
exercise&nbsp;<a href="10_sec1_1.html#%_thm_1.5">1.5</a>.)  Using the
substitution method (for normal order), illustrate the process
generated in evaluating <tt>(gcd 206 40)</tt> and indicate the
<tt>remainder</tt> operations that are actually performed.
How many <tt>remainder</tt> operations are actually performed
in the normal-order evaluation of <tt>(gcd 206&nbsp;40)</tt>?
In the applicative-order evaluation?
</p>

<p class="trans" lang="ja">
<b>練習問題1.20.</b>  ある手続きが生成するプロセスは、もちろん、インタプリタが使う諸規則に依存する。
例として、上記の反復的な <tt>gcd</tt> の手続きを考えよう。
<a href="10_sec1_1.html#%_sec_1.1.5">1.1.5</a>節で議論したような正規順の評価を使って、この手続きを解釈するものと仮定しよう。
(<tt>if</tt> についての正規順評価の規則は、練習問題<a href="10_sec1_1.html#%_thm_1.5">1.5</a> に説明されている。)
(正規順の) 代入法を用いて、<tt>(gcd 206 40)</tt> を評価するときに生成されるプロセスについて説明し、実際に実行される <tt>remainder</tt> の演算を示せ。
<tt>(gcd 206 40)</tt> の正規順の評価において、 <tt>remainder</tt> の演算は、実際に何回実行されるか?
適用順の評価だったらどうなるか?
</p>

<p class="exercise"><span class="ex_comment">正規順で考える。</span>
(gcd 206 40)
<span class="ex_comment">を展開すると、</span>
(if (= 40 0)
    206
    (gcd 40 (remainder 206 40))) 
<span class="ex_comment">となって、条件不成立なので、次に</span>
(gcd 40 (remainder 206 40)) 
<span class="ex_comment">を展開することになる。すると、</span>
(if (= (remainder 206 40) 0)
    40
    (gcd (remainder 206 40) (remainder 40 (remainder 206 40))))
<span class="ex_comment">となって、ここの条件判断で、remainderの1回目の実行。
ここで、(remainder 206 40) = 6なので、条件不成立となり、よって、</span>
(gcd (remainder 206 40) (remainder 40 (remainder 206 40)))
<span class="ex_comment">を展開することになる。すると、</span>
(if (= (remainder 40 (remainder 206 40)) 0)
    (remainder 206 40)
    (gcd (remainder 40 (remainder 206 40))
         (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))
<span class="ex_comment">となって、ここの条件判断で、remainderの2回目と3回目の実行。
ここで、(remainder 40 (remainder 206 40)) = (remainder 40 6) = 4 なので、
条件不成立となり、よって、</span>
(gcd (remainder 40 (remainder 206 40))
     (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))
<span class="ex_comment">を展開することになる。すると、</span>
(if (= (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) 0)
    (remainder 40 (remainder 206 40))
    (gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
         (remainder (remainder 40 (remainder 206 40))
                    (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))))
<span class="ex_comment">となって、ここの条件判断で、remainderの4〜7回目の実行。ここで、
   (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
= (remainder 6 (remainder 40 6))
= (remainder 6 4)
= 2
なので、条件不成立となり、よって、</span>
(gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
     (remainder (remainder 40 (remainder 206 40))
                (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))
<span class="ex_comment">を展開することになる。すると、</span>
(if (= (remainder (remainder 40 (remainder 206 40))
                  (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))
        0)
    (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
    (gcd
       (remainder (remainder 40 (remainder 206 40))
                  (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))
       (remainder (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
                  (remainder (remainder 40 (remainder 206 40))
                             (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))))
<span class="ex_comment">となって、ここの条件判断で、remainderの8〜14回目の実行。ここで、
   (remainder (remainder 40 (remainder 206 40))
                    (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))
= (remainder (remainder 40 6)
                    (remainder 6 (remainder 40 6)))
= (remainder 4 (remainder 6 4))
= (remainder 4 2)
= 0
なので、やっと条件成立となり、よって、</span>
(remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
<span class="ex_comment">を評価することになる。この評価の中に、remainderの15〜18回目の実行が含まれる。ここで、
   (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
= (remainder 6 (remainder 40 6))
= (remainder 6 4)
= 2
なので、最終的に、(gcd 206 40) = 2 という結果が得られる。はあ、大変。
</p>

<p class="exercise"><span class="ex_comment">つぎに、適用順で考える。</span>
(gcd 206 40) 
<span class="ex_comment">を展開すると、</span>
(if (= 40 0) 206 (gcd 40 (remainder 206 40))) 
<span class="ex_comment">となって、条件不成立なので、</span>
(gcd 40 (remainder 206 40)) 
<span class="ex_comment">を評価することになる。その中で remainder が実行されて (1回目)、</span>
(gcd 40 6) 
<span class="ex_comment">となり、これを展開すると、</span>
(if (= 6 0) 40 (gcd 6 (remainder 40 6))) 
<span class="ex_comment">となって、条件不成立なので、</span>
(gcd 6 (remainder 40 6)) 
<span class="ex_comment">を評価することになる。その中で remainder が実行されて (2回目)、</span>
(gcd 6 4) 
<span class="ex_comment">となり、これを展開すると、</span>
(if (= 4 0) 6 (gcd 4 (remainder 6 4))) 
<span class="ex_comment">となって、条件不成立なので、</span>
(gcd 4 (remainder 6 4))
<span class="ex_comment">を評価することになる。その中で remainder が実行されて (3回目)、</span>
(gcd 4 2) 
<span class="ex_comment">となり、これを展開すると、</span>
(if (= 2 0) 4 (gcd 2 (remainder 4 2))) 
<span class="ex_comment">となって、条件不成立なので、</span>
(gcd 2 (remainder 4 2))
<span class="ex_comment">を評価することになる。その中で remainder が実行されて (4回目)、</span>
(gcd 2 0) 
<span class="ex_comment">となり、これを展開すると、</span>
(if (= 0 0) 2 (gcd 0 (remainder 2 0))) 
<span class="ex_comment">となって、条件成立なので、2 という結果が得られる。</span>
</p>

<a name="%_sec_1.2.6"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_1.2.6">1.2.6&nbsp;&nbsp;Example: Testing for Primality</a></h3>
<h3 class="trans" lang="ja">1.2.6  例: 素数性を調べる</h3>

<p class="orig" lang="en">
<a name="%_idx_856"></a><a name="%_idx_858"></a>
This section describes two methods for checking the primality of an
integer <em>n</em>, one with order of growth <img src="book-Z-G-D-3.gif" border="0">(<img src="book-Z-G-D-13.gif" border="0"><em>n</em>), and a
``probabilistic'' algorithm with order of growth <img src="book-Z-G-D-3.gif" border="0">(<tt>log</tt> <em>n</em>).  The
exercises at the end of this section suggest programming
projects based on these algorithms.
</p>

<p class="trans" lang="ja">
本節では、<em class="en">n</em> という整数の素数性を調べるための二つの方法——増大のオーダが &Theta;(&radic;<em class="en">n</em>) であるものと、増大のオーダが &Theta;(<tt>log</tt> <em class="en">n</em>) の「確率的な」アルゴリズム——を説明する。
本節最後の練習問題では、これらのアルゴリズムに基づくプログラミング・プロジェクトを提案している。
</p>

<a name="%_sec_Temp_74"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_74">Searching for divisors</a></h4>
<h4 class="trans" lang="ja">約数を探す</h4>

<p class="orig" lang="en">
Since ancient times, mathematicians have been fascinated by problems
concerning prime numbers, and many people have worked on the problem
of determining ways to test if numbers are prime.  One way
to test if a number is prime is to find the number's divisors.  The
following program finds the smallest integral divisor (greater than 1)
of a given number&nbsp;<em>n</em>.  It does this in a straightforward way, by
testing <em>n</em> for divisibility by successive integers starting with 2.
</p>

<p class="trans" lang="ja">
古代から、数学者たちは素数に関する諸問題に魅了され続けてきたし、数が素数かどうかを試す判定方法の問題に多くの人々が従事してきた。
ある数が素数かどうかを調べるための一つの方法は、その数の約数を見つけることだ。
以下のプログラムは、与えられた数 <em class="en">n</em> の整数の約数のうち最小のもの (ただし1より大きいもの) を見つける。
このプログラムは、単純な方法で——つまり、2から始まる連続する整数のそれぞれによって <em class="en">n</em>が割り切れるかどうかを試すことによって——これ (最小の約数を見つけること) を行う。
</p>

<p class="lisp"><a name="%_idx_860"></a>(define (smallest-divisor n)
  (find-divisor n 2))
<a name="%_idx_862"></a>(define (find-divisor n test-divisor)
  (cond ((&gt; (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))
<a name="%_idx_864"></a>(define (divides? a b)
  (= (remainder b a) 0))</p>

<p class="orig" lang="en">
We can test whether a number is prime as follows: <em>n</em> is prime if
and only if <em>n</em> is its own smallest divisor.
</p>

<p class="trans" lang="ja">
ある数が素数かどうかは、次のようにして調べることができる。もし、<em class="en">n</em> が <em class="en">n</em> 自体の最小の約数ならば、そして、その場合に限り、<em class="en">n</em> は素数である。
</p>

<p class="lisp"><a name="%_idx_866"></a>(define (prime? n)
  (= n (smallest-divisor n)))</p>

<p class="orig" lang="en">
The end test for <tt>find-divisor</tt> is based on the fact that if <em>n</em>
is not prime it must have a divisor less than or equal to
<img src="book-Z-G-D-13.gif" border="0"><em>n</em>.<a name="call_footnote_Temp_75" href="#footnote_Temp_75"><sup><small>44</small></sup></a>  This
means that the algorithm need only test divisors between 1 and
<img src="book-Z-G-D-13.gif" border="0"><em>n</em>.  Consequently, the number of steps required to identify
<em>n</em> as prime will have order of growth <img src="book-Z-G-D-3.gif" border="0">(<img src="book-Z-G-D-13.gif" border="0"><em>n</em>).
</p>

<p class="trans" lang="ja">
<tt>find-divisor</tt> の終了テストは、もし <em class="en">n</em> が素数でなければ <em class="en">n</em> には &radic;<em class="en">n</em> 以下の約数がなくてはならない、という事実に基づいている<a href="#footnote_Temp_75"><sup><small>44</small></sup></a>。
これは、このアルゴリズムが、1と &radic;<em class="en">n</em> の間の約数だけを調べればよいことを意味する。
よって、<em class="en">n</em> が素数だと突き止めるのに必要なステップの数の増大のオーダは、&Theta;(&radic;<em class="en">n</em>) となるだろう。
</p>

<a name="%_sec_Temp_76"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_76">The Fermat test</a></h4>
<h4 class="trans" lang="ja">フェルマーのテスト</h4>

<p class="orig" lang="en">
<a name="%_idx_868"></a><a name="%_idx_870"></a>The <img src="book-Z-G-D-3.gif" border="0">(<tt>log</tt> <em>n</em>) primality test is based on a result from number
theory known as Fermat's Little Theorem.<a name="call_footnote_Temp_77" href="#footnote_Temp_77"><sup><small>45</small></sup></a>
</p>

<p class="trans" lang="ja">
&Theta;(<tt>log</tt> <em class="en">n</em>) の素数性判定は、フェルマーの小定理として知られる数論から得られる結果に基づいている<a href="#footnote_Temp_77"><sup><small>45</small></sup></a>。
</p>

<p class="orig" lang="en">
<a name="%_idx_886"></a><strong>Fermat's Little Theorem:</strong> If <em>n</em> is a prime number and 
<em>a</em> is any positive integer less than <em>n</em>, then <em>a</em> raised to the
<em>n</em>th power is congruent to <em>a</em> modulo <em>n</em>.
</p>

<p class="trans" lang="ja">
<strong>フェルマーの小定理:</strong> もし <em class="en">n</em> が素数であり、かつ、<em class="en">a</em> が <em class="en">n</em> 未満の任意の正整数であるならば、<em class="en">a</em> の <em class="en">n</em> 乗は、<em class="en">n</em> を法として <em class="en">a</em> と合同である。
</p>

<p class="orig" lang="en">
<a name="%_idx_888"></a>(Two numbers are said to be <em>congruent modulo</em> <em>n</em> if
they both have the same remainder when divided by <em>n</em>.  The
remainder of a number <em>a</em> when divided by <em>n</em> is also referred to as
the <a name="%_idx_890"></a><a name="%_idx_892"></a><em>remainder of</em> <em>a</em> <em>modulo</em> <em>n</em>, or simply as <em>a</em> 
<em>modulo</em> <em>n</em>.)
</p>

<p class="trans" lang="ja">
(二つの数は、<em class="en">n</em> で割ったときの余りが同じ場合に、<em class="en">n を法として合同</em>と言われる。
<em class="en">a</em> という数を<em class="en">n</em> で割ったときの余りは、<em class="en">n を法とする a の剰余</em>、または単に、<em class="en">n を法とする a</em> と呼ばれる。)
</p>

<p class="orig" lang="en">
If <em>n</em> is not prime, then, in general, most of the numbers <em>a</em>&lt; <em>n</em> will not
satisfy the above relation.  This leads to the following algorithm for
testing primality: Given a number <em>n</em>, pick a <a name="%_idx_894"></a>random number <em>a</em> &lt; <em>n</em> and
compute the remainder of <em>a</em><sup><em>n</em></sup> modulo <em>n</em>.  If the result is not equal to
<em>a</em>, then <em>n</em> is certainly not prime.  If it is <em>a</em>, then chances are good
that <em>n</em> is prime.  Now pick another random number <em>a</em> and test it with the
same method.  If it also satisfies the equation, then we can be even more
confident that <em>n</em> is prime.  By trying more and more values of <em>a</em>, we can
increase our confidence in the result.  This algorithm is known as the
Fermat test.
</p>

<p class="trans" lang="ja">
<em class="en">n</em> が素数でなければ、一般には、<em class="en">a</em>&lt; <em class="en">n</em> なるほとんどの数は、上記の関係を満たさない。
このことは、素数性を調べるための次のアルゴリズムへとつながってゆく。
つまり、<em class="en">n</em> という数が与えられると、 <em class="en">a</em> &lt; <em class="en">n</em> なる乱数を選び、<em class="en">n</em> を法とする <em class="en">a</em><sup><em class="en">n</em></sup> の剰余を計算する。
もし、その結果が <em class="en">a</em> と等しくなければ、<em class="en">n</em> は確実に素数ではない。
もし、その結果が <em class="en">a</em> ならば、<em class="en">n</em> が素数だという見込みが十分にある。
そこで別の乱数 <em class="en">a</em> を選び、それを同じ方法で調べる。
もしそれが上述の等式を満たすなら、<em class="en">n</em> が素数だということについて、一層、確信を深められる。
より様々な <em class="en">a</em> の値を試してみることで、結果についての確信を深めることができる。
このアルゴリズムは、フェルマーのテストとして知られる。
</p>

<p class="orig" lang="en">
<a name="%_idx_896"></a>To implement the Fermat test, we need a procedure that computes the
exponential of a number modulo another number:
</p>

<p class="trans" lang="ja">
フェルマーのテストを実装するためには、ある数の、もう一つの数を法とした冪乗を計算するような手続きが必要だ。
</p>

<p class="lisp"><a name="%_idx_898"></a>(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder (square (expmod base (/ exp 2) m))
                    m))
        (else
         (remainder (* base (expmod base (- exp 1) m))
                    m))))        </p>

<p class="orig" lang="en">
This is very similar to the <tt>fast-expt</tt> procedure of
section&nbsp;<a href="#%_sec_1.2.4">1.2.4</a>.  It uses successive squaring, so
that the number of steps grows logarithmically with the
exponent.<a name="call_footnote_Temp_78" href="#footnote_Temp_78"><sup><small>46</small></sup></a>
</p>

<p class="trans" lang="ja">
これは、<a href="#%_sec_1.2.4">1.2.4</a>節の <tt>fast-expt</tt> という手続きにとても似ている。
これは、連続する二乗を使っており、指数に対してステップ数が対数的に増大するようになっている<a href="#footnote_Temp_78"><sup><small>46</small></sup></a>。
</p>

<p class="orig" lang="en">
The Fermat test is performed by choosing at random a number <em>a</em>
between 1 and <em>n</em> - 1 inclusive and checking whether the remainder
modulo <em>n</em> of the <em>n</em>th power of <em>a</em> is equal to <em>a</em>.  The random
number <em>a</em> is chosen using the procedure <a name="%_idx_900"></a><a name="%_idx_902"></a><tt>random</tt>, which we assume is
included as a primitive in Scheme. <tt>Random</tt> returns a
nonnegative integer less than its integer input.  Hence, to obtain a random
number between 1 and <em>n</em> - 1, we call <tt>random</tt> with an input of
<em>n</em> - 1 and add 1 to the result:
</p>

<p class="trans" lang="ja">
フェルマーのテストは、1 以上 <em class="en">n</em> &minus; 1 以下の <em class="en">a</em> なる数を無作為に選んで、<em class="en">a</em> の <em class="en">n</em> 乗の、<em class="en">n</em> を法とする剰余が、 <em class="en">a</em> と等しいかどうかを検査することにより、実行される。
<em class="en">a</em> という乱数は、<tt>random</tt> という手続き——私たちは、これが原始的手続きとしてSchemeに含まれている、と想定している——を使って、選ばれる。
<tt>random</tt> は、整数の入力よりも小さな非負整数を返す。
よって、1 以上 <em class="en">n</em> &minus; 1 以下の乱数を得るには、<em class="en">n</em> &minus; 1 という入力を与えて <tt>random</tt> を呼び出して、結果に 1 を足せばよい。
</p>

<p class="lisp"><a name="%_idx_904"></a>(define (fermat-test n)
  (define (try-it a)
    (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))</p>

<p class="orig" lang="en">
The following procedure runs the test a given number of times, as
specified by a parameter.  Its value is true if the test succeeds
every time, and false otherwise.
</p>

<p class="trans" lang="ja">
以下の手続きは、パラメタで指定されたとおりに、所与の回数だけ、上記の判定を実行する。
この手続きの値は、判定が毎回成功したとき真であり、その他の場合には偽である。
</p>

<p class="lisp"><a name="%_idx_906"></a>(define (fast-prime? n times)
  (cond ((= times 0) true)
        ((fermat-test n) (fast-prime? n (- times 1)))
        (else false)))</p>

<a name="%_sec_Temp_79"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_79">Probabilistic methods</a></h4>
<h4 class="trans" lang="ja">確率的な方法</h4>

<p class="orig" lang="en">
<a name="%_idx_908"></a><a name="%_idx_910"></a>
The Fermat test differs in character from most familiar algorithms, in
which one computes an answer that is guaranteed to be correct.  Here,
the answer obtained is only probably correct.  More precisely, if <em>n</em>
ever fails the Fermat test, we can be certain that <em>n</em> is not prime.
But the fact that <em>n</em> passes the test, while an extremely strong
indication, is still not a guarantee that <em>n</em> is prime.  What we would
like to say is that for any number <em>n</em>, if we perform the test enough
times and find that <em>n</em> always passes the test, then the probability
of error in our primality test can be made as small as we like.
</p>

<p class="trans" lang="ja">
フェルマーのテストは、ほとんどのおなじみのアルゴリズム——正しいと保証された答えを計算するもの——とは、性質が異なる。
ここでは、得られた答えは、たぶん正しい、というだけだ。
より正確には、もし <em class="en">n</em> が一度でもフェルマーのテストに失敗したなら、<em class="en">n</em> は素数でないという確信を持てる。
しかし、<em class="en">n</em> がテストに合格したという事実は、非常に強い兆候ではあるものの、それでも、<em class="en">n</em> が素数だという保証ではない。
私たちが言いたいことは、任意の数 <em class="en">n</em> に対して、もし十分な回数のテストを実行し、かつ、<em class="en">n</em> が常にテストに合格することが分かったならば、素数性テストでの誤りの確率を、望んだとおりの低さにできる、ということだ。
</p>

<p class="orig" lang="en">
Unfortunately, this assertion is not quite correct.  There do exist
numbers that fool the Fermat test: numbers <em>n</em> that are not prime and
yet have the property that <em>a</em><sup><em>n</em></sup> is congruent to <em>a</em> modulo <em>n</em> for
all integers <em>a</em> &lt; <em>n</em>.  Such numbers are extremely rare, so the Fermat
test is quite reliable in practice.<a name="call_footnote_Temp_80" href="#footnote_Temp_80"><sup><small>47</small></sup></a>
There are variations of the Fermat test that cannot be fooled.  In
these tests, as with the Fermat method, one tests the primality of an
integer <em>n</em> by choosing a random integer <em>a</em>&lt;<em>n</em> and checking some
condition that depends upon <em>n</em> and <em>a</em>.  (See
exercise&nbsp;<a href="#%_thm_1.28">1.28</a> for an example of such a test.)  On the
other hand, in contrast to the Fermat test, one can prove that, for
any <em>n</em>, the condition does not hold for most of the integers <em>a</em>&lt;<em>n</em>
unless <em>n</em> is prime.  Thus, if <em>n</em> passes the test for some random
choice of&nbsp;<em>a</em>, the chances are better than even that <em>n</em> is prime.  If
<em>n</em> passes the test for two random choices of <em>a</em>, the chances are better
than 3 out of 4 that <em>n</em> is prime. By running the test with more and
more randomly chosen values of <em>a</em> we can make the probability of
error as small as we like.
</p>

<p class="trans" lang="ja">
あいにく、この言明は必ずしも正しくはない。
フェルマーのテストを騙すような数が実際に存在する。つまり、素数ではないのに、それでもなお、<em class="en">a</em> &lt; <em class="en">n</em> なるすべての整数 <em class="en">a</em> に対して、<em class="en">n</em> を法として <em class="en">a</em><sup><em class="en">n</em></sup> が <em class="en">a</em> と合同だ、という性質を持つような数 <em class="en">n</em> がある。
そういう数は非常に稀なので、フェルマーのテストは実際にはかなり信頼できる<a href="#footnote_Temp_80"><sup><small>47</small></sup></a>。
フェルマーのテストの変種で、騙され得ないようなものがある。
それらのテストでは、フェルマーの方法と同様に、<em class="en">a</em>&lt;<em class="en">n</em> なる乱数 <em class="en">a</em> を選んで、<em class="en">a</em> および <em class="en">n</em> に依存する何らかの条件を検査することで、<em class="en">n</em> という整数の素数性を検査する。
(そのようなテストの例については、練習問題<a href="#%_thm_1.28">1.28</a>を参照。)
一方で、フェルマーのテストとは対照的に、任意の <em class="en">n</em> に対して、<em class="en">n</em> が素数でない限りは、<em class="en">a</em>&lt;<em class="en">n</em> なる整数 <em class="en">a</em> のほとんどに対して当該条件が成り立たない、と証明できる。
よって、<em class="en">a</em> の何らかの無作為な選択に対して <em class="en">n</em> がテストに合格するならば、<em class="en">n</em> が素数だという見込みは、五分五分よりも良い。
もし、<em class="en">a</em> の2回の無作為な選択に対して <em class="en">n</em> がテストに合格するならば、<em class="en">n</em> が素数だという見込みは、3/4 よりも良い。
より多くの個数の無作為に選ばれた <em class="en">a</em> の値を使ってテストを実行することで、誤りの確率を、望んだとおりに低くすることができる。
</p>

<p class="orig" lang="en">
The existence of tests for which one can prove that the chance of
error becomes arbitrarily small has sparked interest in algorithms of
this type, which have come to be known as <em>probabilistic
algorithms</em>.  There is a great deal of research activity in this area,
and probabilistic algorithms have been fruitfully applied to many
fields.<a name="call_footnote_Temp_81" href="#footnote_Temp_81"><sup><small>48</small></sup></a>
</p>

<p class="trans" lang="ja">
誤りの可能性が任意に小さくなる、と証明できるようなテストの存在は、この種のアルゴリズム——<em>確率的アルゴリズム</em>として知られるようになってきた——への興味をかきたててきた。
この領域では大量の研究活動がなされており、確率的アルゴリズムは多くの分野に有益に適用されてきた<a href="#footnote_Temp_81"><sup><small>48</small></sup></a>。
</p>

<p class="orig" lang="en"><a name="%_thm_1.21"></a>
<b>Exercise 1.21.</b>&nbsp;&nbsp;Use the <tt>smallest-divisor</tt> procedure to find the smallest divisor
of each of the following numbers: 199, 1999, 19999.
</p>

<p class="trans" lang="ja">
<b>練習問題 1.21.</b>  <tt>smallest-divisor</tt> という手続きを使って、199と、1999と、19999という数それぞれの、最小の約数を求めよ。
</p>

<p class="exercise">gosh&gt; (smallest-divisor 199)
199
gosh&gt; (smallest-divisor 1999)
1999
gosh&gt; (smallest-divisor 19999)
7
</p>

<p class="orig" lang="en"><a name="%_thm_1.22"></a>
<b>Exercise 1.22.</b>&nbsp;&nbsp;<a name="%_idx_932"></a><a name="%_idx_934"></a>Most Lisp implementations include a primitive called <tt>runtime</tt>
that returns an integer that specifies the amount of time the system
has been running (measured, for example, in microseconds).  The
following <tt>timed-prime-test</tt> procedure, when called with an
integer <em>n</em>, prints <em>n</em> and checks to see if <em>n</em> is prime.  If <em>n</em> is
prime, the procedure prints three asterisks followed by the amount of time
used in performing the test.
</p>

<p class="trans" lang="ja">
<b>練習問題 1.22.</b>  ほとんどのLispの実装は、システムが今まで動いてきた時間の量 (たとえば、マイクロ秒単位で計測される) を示す整数を返すような、<tt>runtime</tt> と呼ばれる原始的関数を含む。
以下の <tt>timed-prime-test</tt> という手続きは、<em class="en">n</em> という整数とともに呼び出されると、<em class="en">n</em> を印字し、そして、<em class="en">n</em> が素数かどうかを確かめるために検査する。
もし <em class="en">n</em> が素数なら、この手続きは、三つのアスタリスクを印字し、続いて、テストの実行に使われた時間の量を印字する。
</p>

<p class="lisp"><a name="%_idx_936"></a><a name="%_idx_938"></a><a name="%_idx_940"></a>(define (timed-prime-test n)
  (newline)
  (display n)
  (start-prime-test n (runtime)))
(define (start-prime-test n start-time)
  (if (prime? n)
      (report-prime (- (runtime) start-time))))
(define (report-prime elapsed-time)
  (display &quot; *** &quot;)
  (display elapsed-time))</p>

<p class="orig" lang="en">
Using this procedure, write a procedure <tt>search-for-primes</tt> that
checks the primality of consecutive odd integers in a specified range.
Use your procedure to find the three smallest primes larger than 1000;
larger than 10,000; larger than 100,000; larger than 1,000,000.  Note
the time needed to test each prime.  Since the testing algorithm has
order of growth of <img src="book-Z-G-D-3.gif" border="0">(<img src="book-Z-G-D-13.gif" border="0"><em>n</em>), you should expect that testing
for primes around 10,000 should take about <img src="book-Z-G-D-13.gif" border="0">10 times as long
as testing for primes around 1000.  Do your timing data bear this out?
How well do the data for 100,000 and 1,000,000 support the <img src="book-Z-G-D-13.gif" border="0"><em>n</em>
prediction?  Is your result compatible with the notion that programs
on your machine run in time proportional to the number of steps
required for the computation?
</p>

<p class="trans" lang="ja">
指定された範囲内の連続する奇数の整数の素数性を調べるような、<tt>search-for-primes</tt> という手続きを、上記の手続きを使って書け。
君が書いた手続きを使って、1,000より大きい最小の三つの素数を見つけ出せ。同様に、10,000より大きい最小の三つの素数、100,000より大きい最小の三つの素数、1,000,000より大きい最小の三つの素数を見つけ出せ。
素数それぞれを調べるのに必要な時間に気をつけよ。
テストを行うアルゴリズムの増大のオーダが &Theta;(&radic;<em class="en">n</em>) なので、10,000くらいの素数をテストするには、1,000くらいの素数のテストの &radic;10 倍くらいの時間がかかるはずだ、と君は予測するはずだ。
君の計時データは、このことの裏づけを示しているだろうか?
100,000と1,000,000についてのデータは、どれくらいぴったりと &radic;<em class="en">n</em> の予測を裏づけているか?
君のマシン上のプログラムは、計算に必要なステップ数に比例する時間、動くのだ、という考えに、君の結果は合っているか?
</p>

<p class="exercise"><span class="ex_comment">
</span></p>


<p class="orig" lang="en"><a name="%_thm_1.23"></a>
<b>Exercise 1.23.</b>&nbsp;&nbsp;<a name="%_idx_942"></a>The <tt>smallest-divisor</tt> procedure shown at the start of this section
does lots of needless testing: After it checks to see if the
number is divisible by 2 there is no point in checking to see if
it is divisible by any larger even numbers.  This suggests that the
values used for <tt>test-divisor</tt> should not be 2, 3, 4, 5, 6,
<tt>...</tt>, but rather 2, 3, 5, 7, 9, <tt>...</tt>.  To implement this
change, define a procedure <tt>next</tt> that returns 3 if its input is
equal to 2 and otherwise returns its input plus&nbsp;2.  Modify the <tt>smallest-divisor</tt> procedure to use <tt>(next test-divisor)</tt> instead
of <tt>(+ test-divisor 1)</tt>.  With <tt>timed-prime-test</tt>
incorporating this modified version of <tt>smallest-divisor</tt>, run the
test for each of the 12 primes found in
exercise&nbsp;<a href="#%_thm_1.22">1.22</a>.  Since this modification halves the
number of test steps, you should expect it to run about twice as fast.
Is this expectation confirmed?  If not, what is the observed ratio of
the speeds of the two algorithms, and how do you explain the fact that
it is different from 2?
</p>

<p class="trans" lang="ja">
<b>練習問題1.23.</b>  本節の最初に示した <tt>smallest-divisor</tt> という手続きは、多くの不要なテストを行う。数が2で割り切れるかどうかを調べた後は、その数が、より大きい任意の偶数で割り切れるかどうかを調べることに意味はない。
このことは、<tt>test-divisor</tt> に使われる値が、2, 3, 4, 5, 6, ……であるべきではなく、むしろ、2, 3, 5, 7, 9, ……であるべきだ、ということを示唆している。
この変更を実装するために、入力が2に等しければ3を返し、その他の場合には入力に2を足したものを返すような、<tt>next</tt> という手続きを定義せよ。
<tt>(next test-divisor)</tt> を <tt>(+ test-divisor 1)</tt> の代わりに使って、<tt>smallest-divisor</tt> の手続きを修正せよ。
この修正版の <tt>smallest-divisor</tt> を取り込んだ <tt>timed-prime-test</tt> を使って、練習問題<a href="#%_thm_1.22">1.22</a>で見つかった12個の素数のそれぞれについて、テストを実行せよ。
この修正はテストのステップ数を半減させるので、二倍ほど早く実行されることを君は期待するはずだ。
この期待は確かめられたか?
もし確かめられなかったとすれば、二つのアルゴリズムの速さの、観察された比率は、どのようなものか? そして、その比率が2とは違うという事実を、君はどう説明するか?
</p>

<p class="exercise"><span class="ex_comment">; nextを定義</span>
(define (next x) (if (= x 2) 3 (+ x 2)))
<span class="ex_comment">; 再掲</span>
(define (smallest-divisor n) (find-divisor n 2))
<span class="ex_comment">; nextを使うように1箇所だけ修正</span>
(define (find-divisor n test-divisor)
  (cond ((&gt; (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (next test-divisor)))))
<span class="ex_comment">; 再掲</span>
(define (divides? a b) (= (remainder b a) 0))</p>

<p class="orig" lang="en"><a name="%_thm_1.24"></a>
<b>Exercise 1.24.</b>&nbsp;&nbsp;Modify the <tt>timed-prime-test</tt> procedure of
exercise&nbsp;<a href="#%_thm_1.22">1.22</a> to use <tt>fast-prime?</tt> (the
Fermat method), and test each of the 12 primes you found in that
exercise.  Since the Fermat test has <img src="book-Z-G-D-3.gif" border="0">(<tt>log</tt> <em>n</em>) growth, how
would you expect the time to test primes near 1,000,000 to compare
with the time needed to test primes near 1000?  Do your data bear this
out?  Can you explain any discrepancy you find?
</p>

<p class="trans" lang="ja">
<b>練習問題1.24.</b>  練習問題<a href="#%_thm_1.22">1.22</a>の <tt>timed-prime-test</tt> という手続きを、<tt>fast-prime?</tt> (フェルマーの方法) を用いるように修正せよ。そして、その練習問題で見つけた12個の素数の各々をテストせよ。
フェルマーのテストは &Theta;(<tt>log</tt> <em class="en">n</em>) で増大するわけだが、1,000,000付近の素数をテストするのにかかる時間が、1,000付近の素数をテストするのに必要な時間と比べて、どれくらいだと君は予測するだろうか?
君のデータは、このことの裏づけを示しているだろうか?
何か不一致が見つかれば、君はそれを説明できるか?
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_1.25"></a>
<b>Exercise 1.25.</b>&nbsp;&nbsp;Alyssa P. Hacker complains that we went to a lot of extra work in
writing <tt>expmod</tt>.  After all, she says, since we already know how
to compute exponentials, we could have simply written
</p>

<p class="trans" lang="ja">
<b>練習問題1.25.</b>  アリッサ・P・ハッカは、 <tt>expmod</tt> を書く際に、多くの余計な仕事をしたと文句を言っている。
結局は、私たちは冪乗をどう計算するのかを既に知っているのだから、簡潔に次のように書けただろう、と彼女は言う。
</p>

<p class="lisp"><a name="%_idx_944"></a>(define (expmod base exp m)
  (remainder (fast-expt base exp) m))</p>

<p class="orig" lang="en">
Is she correct?  Would this procedure serve as well for our fast prime
tester?  Explain.
</p>

<p class="trans" lang="ja">
彼女は正しいか?
この手続きは、私たちの高速素数テスタでうまく動くだろうか?
説明せよ。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_1.26"></a>
<b>Exercise 1.26.</b>&nbsp;&nbsp;Louis Reasoner is having great difficulty doing
exercise&nbsp;<a href="#%_thm_1.24">1.24</a>.  His <tt>fast-prime?</tt> test
seems to run more slowly than his <tt>prime?</tt> test.  Louis calls his
friend Eva Lu Ator over to help.  When they examine Louis's code, they
find that he has rewritten the <tt>expmod</tt> procedure to use an
explicit multiplication, rather than calling <tt>square</tt>:
</p>

<p class="trans" lang="ja">
<b>練習問題1.26.</b>  ルイス・リーズナは、練習問題<a href="#%_thm_1.24">1.24</a>をこなすのに多大なる困難を抱えている。
彼の <tt>fast-prime?</tt> テストは、彼の <tt>prime?</tt> テストよりものろのろと実行されるようなのだ。
ルイスは、助けを求めて友人のエヴァ・リュ・エイタを呼び寄せる。
二人でルイスのコードを検討しているとき、かれらは、ルイスが <tt>expmod</tt> の手続きを、<tt>square</tt> ではなくむしろ明示的な乗算を使うように書き直していたことを発見する。
</p>

<p class="lisp"><a name="%_idx_946"></a>(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder (* (expmod base (/ exp 2) m)
                       (expmod base (/ exp 2) m))
                    m))
        (else
         (remainder (* base (expmod base (- exp 1) m))
                    m))))</p>

<p class="orig" lang="en">
``I don't see what difference that could make,'' says Louis.  ``I
do.''  says Eva.  ``By writing the procedure like that, you have
transformed the <img src="book-Z-G-D-3.gif" border="0">(<tt>log</tt> <em>n</em>) process into a <img src="book-Z-G-D-3.gif" border="0">(<em>n</em>) process.''
Explain.
</p>

<p class="trans" lang="ja">
「それがどんな違いを生じ得るのか、分からないよ」とルイスが言う。
「私は分かるよ」とエヴァが言う。
「それみたいな手続きを書くことで、君は、&Theta;(<tt>log</tt> <em class="en">n</em>) のプロセスを、&Theta;(<em class="en">n</em>) のプロセスに変形してしまったんだ。」
説明せよ。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_1.27"></a>
<b>Exercise 1.27.</b>&nbsp;&nbsp;<a name="%_idx_948"></a>Demonstrate that the Carmichael numbers listed in
footnote&nbsp;<a href="#footnote_Temp_80">47</a> really do fool
the Fermat test.  That is, write a procedure that takes an integer <em>n</em>
and tests whether <em>a</em><sup><em>n</em></sup> is congruent to <em>a</em> modulo <em>n</em> for every
<em>a</em>&lt;<em>n</em>, and try your procedure on the given Carmichael numbers.
</p>

<p class="trans" lang="ja">
<b>練習問題1.27.</b>  脚注<a href="#footnote_Temp_80">47</a>に挙げられているカーマイケル数が、実際にフェルマー・テストを欺くことを実証せよ。
つまり、<em class="en">n</em> という整数をもらい、<em class="en">a</em>&lt;<em class="en">n</em> なるすべての<em class="en">a</em> について、<em class="en">a</em><sup><em class="en">n</em></sup> が <em class="en">n</em> を法として <em class="en">a</em> と合同かどうかを調べるような手続きを書け。そして、君の書いた手続きを、与えられたカーマイケル数について試してみよ。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_1.28"></a>
<b>Exercise 1.28.</b>&nbsp;&nbsp;<a name="%_idx_950"></a><a name="%_idx_952"></a><a name="%_idx_954"></a><a name="%_idx_956"></a><a name="%_idx_958"></a>One variant of the Fermat test that cannot be fooled is called the
<em>Miller-Rabin test</em> (Miller 1976; Rabin 1980).  This starts from
<a name="%_idx_960"></a>an alternate form of Fermat's Little Theorem, which states that if <em>n</em>
is a prime number and <em>a</em> is any positive integer less than <em>n</em>, then
<em>a</em> raised to the (<em>n</em> - 1)st power is congruent to 1 modulo&nbsp;<em>n</em>.  To test
the primality of a number <em>n</em> by the Miller-Rabin test, we pick a
random number <em>a</em>&lt;<em>n</em> and raise <em>a</em> to the (<em>n</em> - 1)st power modulo&nbsp;<em>n</em>
using the <tt>expmod</tt> procedure.  However, whenever we perform the
squaring step in <tt>expmod</tt>, we check to see if we have discovered a
``nontrivial square root of 1 modulo&nbsp;<em>n</em>,'' that is, a number not
equal to 1 or <em>n</em> - 1 whose square is equal to 1 modulo&nbsp;<em>n</em>.  It is
possible to prove that if such a nontrivial square root of 1 exists,
then <em>n</em> is not prime.  It is also possible to prove that if <em>n</em> is an
odd number that is not prime, then, for at least half the numbers
<em>a</em>&lt;<em>n</em>, computing <em>a</em><sup><em>n</em>-1</sup> in this way will reveal a nontrivial
square root of 1 modulo&nbsp;<em>n</em>.  (This is why the Miller-Rabin test
cannot be fooled.)  Modify the <tt>expmod</tt> procedure to signal if it
discovers a nontrivial square root of 1, and use this to implement
the Miller-Rabin test with a procedure analogous to <tt>fermat-test</tt>.
Check your procedure by testing various known primes and non-primes.
Hint: One convenient way to make <tt>expmod</tt> signal is to have it
return 0.
</p>

<p class="trans" lang="ja">
<b>練習問題1.28.</b>  欺かれ得ない、フェルマーテストの変種の一つは、<em>ミラー・ラビン・テスト</em>と呼ばれる (Miller 1976; Rabin 1980)。
これは、フェルマーの小定理の代替形式——もし <em class="en">n</em> が素数であり、 <em class="en">a</em> が <em class="en">n</em> 未満の任意の正整数なら、<em class="en">a</em> の (<em class="en">n</em> &minus; 1) 乗は、<em class="en">n</em> を法として1と合同である——から始まる。
<em class="en">n</em> という数の素数性をミラー・ラビン・テストにより調べるには、<em class="en">a</em> &lt; <em class="en">n</em> なる乱数 <em class="en">a</em> を選び、 <em class="en">n</em> を法とする <em class="en">a</em> の (<em class="en">n</em> &minus; 1) 乗を、<tt>expmod</tt> の手続きを使って求める。
ただし、<tt>expmod</tt> において二乗するステップを実行するときはいつでも、「<em class="en">n</em> を法とする、1の自明でない二乗根」——つまり、1でも <em class="en">n</em> &minus; 1 でもない数で、<em class="en">n</em> を法とする二乗が1に等しいもの——を既に発見したかどうかを検査する。
もし、そのような1の非自明な二乗根が存在するなら、<em class="en">n</em> は素数ではない、と証明することが可能である。
もし、<em class="en">n</em> が素数でない奇数なら、<em class="en">a</em>&lt;<em class="en">n</em> なる数 <em class="en">a</em> のうち少なくとも半分の個数の数に対して、<em class="en">a</em><sup><em class="en">n</em>&minus;1</sup> をこの方法で計算することで、<em class="en">n</em> を法とする、1の自明でない二乗根が明らかになるだろう。
(これが、ミラー・ラビン・テストが欺かれ得ない理由だ。)
<tt>expmod</tt> の手続きを、もし1の非自明な二乗根を発見したら合図するように、修正せよ。そして、それを使って、<tt>fermat-test</tt> に似た手続きによるミラー・ラビン・テストを実装せよ。
種々の既知の素数と非素数をテストすることにより、君の手続きを検査せよ。
ヒント: <tt>expmod</tt> に合図させるための一つの便利な方法は、<tt>expmod</tt> に0を返させることである。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>


<a name="footnotes"></a>
<hr>

<p class="orig" lang="en">
<a name="footnote_Temp_46" href="#call_footnote_Temp_46"><sup><small>29</small></sup></a> In a real program we would probably use the
block structure introduced in the last section to hide the definition
of <tt>fact-iter</tt>:
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_46"><sup><small>29</small></sup></a>
現実のプログラムでは、私たちはたぶん、<tt>fact-iter</tt> の定義を隠すために、<a href="10_sec1_1.html#%_sec_Temp_43">前節</a>で導入したブロック構造を使うだろう。
</p>

<p class="lisp">(define (factorial n)
  (define (iter product counter)
    (if (&gt; counter n)
        product
        (iter (* counter product)
              (+ counter 1))))
  (iter 1 1))</p>

<p class="orig" lang="en">
We avoided doing this here so as to minimize the number of things to
think about at once.
</p>

<p class="trans" lang="ja">
ここでは、<!--私たちは、-->一度に考える物事の数を最小化するために、そうすることを避けた。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_47" href="#call_footnote_Temp_47"><sup><small>30</small></sup></a> When we discuss the implementation of
procedures on register machines in chapter&nbsp;5, we will see that any
iterative process can be realized ``in hardware'' as a machine that
has a fixed set of registers and no auxiliary memory.  In contrast,
realizing a recursive process requires a machine that uses an
<a name="%_idx_678"></a>auxiliary data structure known as a <em>stack</em>.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_47"><sup><small>30</small></sup></a>
レジスタ・マシン上での手続きの実装について5章で議論するときに、私たちは、所定の一揃いのレジスタを有しており補助メモリを持たないマシンとして、任意の反復的プロセスを「ハードウェアで」実現できる、ということを知るだろう。
対照的に、再帰的プロセスを実現するには、<em>スタック</em>として知られる補助的なデータ構造を使うマシンが必要である。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_48" href="#call_footnote_Temp_48"><sup><small>31</small></sup></a> Tail recursion has long been
<a name="%_idx_698"></a><a name="%_idx_700"></a><a name="%_idx_702"></a>known as a compiler optimization trick.  A coherent semantic basis for
tail recursion was provided by Carl Hewitt (1977), who explained it in
<a name="%_idx_704"></a>terms of the ``message-passing'' model of computation that we shall
discuss in chapter&nbsp;3. Inspired by this, Gerald Jay Sussman and Guy
Lewis Steele Jr. (see Steele 1975) constructed a tail-recursive
interpreter for Scheme.  Steele later showed how tail recursion is a
consequence of the natural way to compile procedure calls (Steele
1977).  The IEEE standard for Scheme requires that Scheme implementations
<a name="%_idx_706"></a>be tail-recursive.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_48"><sup><small>31</small></sup></a>
末尾再帰は、長い間、コンパイラ最適化の秘訣として知られてきた。
末尾再帰についての首尾一貫した意味的基礎は、カール・ヒューイット——彼は、私たちが3章で議論することになる、計算の「メッセージ・パッシング」モデルの言葉で、末尾再帰を説明した——により与えられた (1977)。
これに着想を得て、ジェラルド・ジェイ・サスマンとガイ・ルイス・スティール・ジュニアが、Scheme 用の末尾再帰的インタプリタを構築した (Steele 1975 を参照)。
いかにして末尾再帰が、手続き呼び出しをコンパイルするための自然な方法の帰結になるのか、ということを、スティールは後に示した (Steele 1977)。
Scheme の IEEE 標準は、Scheme の実装が末尾再帰的であることを要求している。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_51" href="#call_footnote_Temp_51"><sup><small>32</small></sup></a> An example of this was hinted
at in section&nbsp;<a href="10_sec1_1.html#%_sec_1.1.3">1.1.3</a>:
The interpreter itself evaluates expressions
using a tree-recursive process.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_51"><sup><small>32</small></sup></a> 
これの例は、<a href="10_sec1_1.html#%_sec_1.1.3">1.1.3</a>節でほのめかされていた。
つまり、インタプリタ自体が、木構造再帰的なプロセスを使って式を評価している。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_53" href="#call_footnote_Temp_53"><sup><small>33</small></sup></a> For example, work through in detail how the
reduction rule applies to the problem of making change for 10 cents
using pennies and nickels.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_53"><sup><small>33</small></sup></a>
たとえば、1セント硬貨と5セント硬貨を使って10セントを両替する問題には、<!--縮小-->還元の法則がどのように適用されるのか、詳しく<!--解答してみよ-->取り組んでみたまえ。
</p>
<p class="exercise"><span class="ex_comment">図を描いてみる (横スクロールしてね)。たった3通りなんだが面倒だな。</span>
<span class="inline-aa">全部で10セント
  |
  +-- 5セント硬貨を (とりあえず1枚は) 使う (→ 残り5セント)
  |     |
  |     +-- 5セント硬貨を (とりあえずもう1枚は) 使う (→ 残り0セント) …… <span class="hilit1">5+5</span>
  |     |
  |     +-- 5セント硬貨を (さらには) 使わない (→ 残り5セントのまま)
  |          |
  |          +-- 1セント硬貨を (とりあえず1枚は) 使う (→ 残り4セント)
  |          :    |
  |          :    +-- 1セント硬貨を (とりあえずもう1枚は) 使う (→ 残り3セント)
  |          :    :    |
  |          :    :    +-- 1セント硬貨を (とりあえずもう1枚は) 使う (→ 残り2セント)
  |          :    :    :    |
  |          :    :    :    +-- 1セント硬貨を (とりあえずもう1枚は) 使う (→ 残り1セント)
  |          :    :    :    :    |
  |          :    :    :    :    +-- 1セント硬貨を (とりあえずもう1枚は) 使う (→ 残り0セント) …… <span class="hilit1">5+1+1+1+1+1</span>
  |          :    :    :    :    :
  |          :    :    :    :    +-- 1セント硬貨を (さらには) 使わない …… (0通り; 残り1セント)
  |          :    :    :    :
  |          :    :    :    +-- 1セント硬貨を (さらには) 使わない …… (0通り; 残り2セント)
  |          :    :    :
  |          :    :    +-- 1セント硬貨を (さらには) 使わない …… (0通り; 残り3セント)
  |          :    :
  |          :    +-- 1セント硬貨を (さらには) 使わない …… (0通り; 残り4セント)
  |          :
  |          +-- 1セント硬貨を (さらには) 使わない …… (0通り; 残り5セント)
  |
  +-- 5セント硬貨を使わない (→ 残り10セントのまま)
        |
        +-- 1セント硬貨を (とりあえず1枚は) 使う (→ 残り9セント)
        :    |
        :    +-- 1セント硬貨を (とりあえずもう1枚は) 使う (→ 残り8セント)
        :    :    |
        :    :    +-- 1セント硬貨を (とりあえずもう1枚は) 使う (→ 残り7セント)
        :    :    :    |
        :    :    :    +-- 1セント硬貨を (とりあえずもう1枚は) 使う (→ 残り6セント)
        :    :    :    :    |
        :    :    :    :    +-- 1セント硬貨を (とりあえずもう1枚は) 使う (→ 残り5セント)
        :    :    :    :    :    |
        :    :    :    :    :    +-- 1セント硬貨を (とりあえずもう1枚は) 使う (→ 残り4セント)
        :    :    :    :    :    :    |
        :    :    :    :    :    :    +-- 1セント硬貨を (とりあえずもう1枚は) 使う (→ 残り3セント)
        :    :    :    :    :    :    :    |
        :    :    :    :    :    :    :    +-- 1セント硬貨を (とりあえずもう1枚は) 使う (→ 残り2セント)
        :    :    :    :    :    :    :    :    |
        :    :    :    :    :    :    :    :    +-- 1セント硬貨を (とりあえずもう1枚は) 使う (→ 残り1セント)
        :    :    :    :    :    :    :    :    :    |
        :    :    :    :    :    :    :    :    :    +-- 1セント硬貨を (とりあえずもう1枚は) 使う (→ 残り0セント) …… <span class="hilit1">1+1+1+1+1+1+1+1+1+1</span>
        :    :    :    :    :    :    :    :    :    :
        :    :    :    :    :    :    :    :    :    +-- 1セント硬貨を (さらには) 使わない …… (0通り; 残り1セント)
        :    :    :    :    :    :    :    :    :
        :    :    :    :    :    :    :    :    +-- 1セント硬貨を (さらには) 使わない …… (0通り; 残り2セント)
        :    :    :    :    :    :    :    :
        :    :    :    :    :    :    :    +-- 1セント硬貨を (さらには) 使わない …… (0通り; 残り3セント)
        :    :    :    :    :    :    :
        :    :    :    :    :    :    +-- 1セント硬貨を (さらには) 使わない …… (0通り; 残り4セント)
        :    :    :    :    :    :
        :    :    :    :    :    +-- 1セント硬貨を (さらには) 使わない …… (0通り; 残り5セント)
        :    :    :    :    :
        :    :    :    :    +-- 1セント硬貨を (さらには) 使わない …… (0通り; 残り6セント)
        :    :    :    :
        :    :    :    +-- 1セント硬貨を (さらには) 使わない …… (0通り; 残り7セント)
        :    :    :
        :    :    +-- 1セント硬貨を (さらには) 使わない …… (0通り; 残り8セント)
        :    :
        :    +-- 1セント硬貨を (さらには) 使わない …… (0通り; 残り9セント)
        :
        +-- 1セント硬貨を (さらには) 使わない …… (0通り; 残り10セント)
</span></p>


<p class="orig" lang="en"><a name="footnote_Temp_54" href="#call_footnote_Temp_54"><sup><small>34</small></sup></a> One
approach to coping with redundant computations is to arrange matters
so that we automatically construct a table of values as they
are computed.  Each time we are asked to apply the procedure to some
argument, we first look to see if the value is already stored in the
table, in which case we avoid performing the redundant computation.
This strategy, known as <a name="%_idx_734"></a><a name="%_idx_736"></a><em>tabulation</em> or <em>memoization</em>, can be
implemented in a straightforward way.  Tabulation can sometimes be
used to transform processes that require an exponential number of
steps (such as <tt>count-change</tt>) into processes whose space and time
requirements grow linearly with the input.  See
exercise&nbsp;<a href="22_sec3_3.html#%_thm_3.27">3.27</a>.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_54"><sup><small>34</small></sup></a> 
冗長な計算に対処するための一つの手法は、諸々の値が計算されるのにつれて、それらの値の一覧表を自動的に構築するように、物事を整理することである。
ある引数に手続きを適用するように求められるたびに、まず、その値が既に一覧表に記憶されているかどうかを見て確かめる——そして、記憶されている場合には、冗長な計算の実行を避ける。
この戦略——<em>一覧表化</em>または<em>メモ化</em>と呼ばれる——は、分かりやすい方法で実装できる。
一覧表化は、時として、(たとえば <tt>count-change</tt> のように) 指数関数的な数のステップを要するプロセスを、空間と時間の要求が入力に対して線形に増大するプロセスへと変換するために<!--、使われ得る-->使用できる。
練習問題<a href="22_sec3_3.html#%_thm_3.27">3.27</a>を参照。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_57" href="#call_footnote_Temp_57"><sup><small>35</small></sup></a> The elements of Pascal's triangle are called the <em>binomial
coefficients</em>, because the <em>n</em>th row consists of
<a name="%_idx_740"></a>the coefficients of the terms in the
expansion of (<em>x</em> + <em>y</em>)<sup><em>n</em></sup>.  This pattern for computing the coefficients
<a name="%_idx_742"></a>appeared in Blaise Pascal's 1653 seminal work on probability theory, <em>Trait&eacute; du triangle arithm&eacute;tique</em>.  According to
<a name="%_idx_744"></a>Knuth (1973), the same pattern appears in the <em>Szu-yuen
Y&uuml;-chien</em> (``The Precious Mirror of the Four Elements''), published
<a name="%_idx_746"></a><a name="%_idx_748"></a><a name="%_idx_750"></a>by the Chinese mathematician Chu Shih-chieh in 1303, in the
works of the twelfth-century Persian poet and mathematician Omar
Khayyam, and in the works of the twelfth-century Hindu mathematician
Bh&aacute;scara &Aacute;ch&aacute;rya.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_57"><sup><small>35</small></sup></a>
パスカルの三角形の要素は、<em>二項係数</em>と呼ばれる。というのも、<em class="en">n</em> 番目の行は、
<span class="math">(<em class="en">x</em> + <em class="en">y</em>)<sup><em class="en">n</em></sup></span> 
の展開式の中の項の係数からなるので。
係数を計算するこのパタンは、確率論に関するブレーズ・パスカルの1653年の画期的な著作——すなわち、<em class="en">Trait&eacute; du triangle arithm&eacute;tique</em>——に記載されていた。
クヌース (1973) によれば、同じパタンは、中国の数学者・朱世傑 (朱世杰) により1303年に出版された『四元玉鑑』や、12世紀のペルシャの詩人にして数学者たるウマル・ハイヤームの著作や、12世紀のインドの数学者<!--・ブハスカラ・アチャリャ--> Bh&aacute;scara &Aacute;ch&aacute;rya の著作にも見られる。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_59" href="#call_footnote_Temp_59"><sup><small>36</small></sup></a> These statements mask a
great deal of oversimplification.  For instance, if we count process
steps as ``machine operations'' we are making the assumption that the
number of machine operations needed to perform, say, a multiplication
is independent of the size of the numbers to be multiplied, which is
false if the numbers are sufficiently large.  Similar remarks hold for
the estimates of space.  Like the design and description of a process,
the analysis of a process can be carried out at various levels of
abstraction.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_59"><sup><small>36</small></sup></a>
これらの陳述は、たくさんの過剰な簡略化を隠してしまう。
たとえば、プロセスのステップを「マシン演算」として数える場合、私たちは、実行する必要のあるマシン演算——たとえば乗算——の回数が、乗算<!--されることになる-->すべき数の大きさとは独立だ、と仮定しているが、これは、それらの数が十分に大きければ、間違いである。
同様の注記は、空間の見積もりについても成り立つ。
プロセスの設計・記述と同様に、プロセスの分析も、抽象化の様々なレベルで実行できる。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_62" href="#call_footnote_Temp_62"><sup><small>37</small></sup></a> More precisely, the number of multiplications
required is equal to 1 less than the log base 2 of <em>n</em> plus the number
of ones in the binary representation of <em>n</em>.  This total is always
less than twice the log base 2 of <em>n</em>.  The arbitrary constants
<em>k</em><sub>1</sub> and <em>k</em><sub>2</sub> in
the definition of order notation imply that, for a logarithmic
process, the base to which logarithms are taken does not matter, so
all such processes are described as <img src="book-Z-G-D-3.gif" border="0">(<tt>log</tt> <em>n</em>).
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_62"><sup><small>37</small></sup></a>
より正確には、必要な乗算の回数は、2を底とする <em class="en">n</em> の対数より1小さい数に、<em class="en">n</em> の2進表現における1の個数を足したものである。<!--要確認-->
この総和は常に、2を底とする <em class="en">n</em> の対数の2倍よりは小さい。
オーダ表記の定義における <em class="en">k</em><sub>1</sub> および <em class="en">k</em><sub>2</sub> という任意の定数は、対数的プロセスに関しては、対数をとる底が重要でないことを暗示しており、そのため、そういうプロセスはすべて &Theta;(<tt>log</tt> <em class="en">n</em>) のように記述される。

<!--
n=8=0b1000
	(fase-expt b 8)
	=> (square (fast-expt b 4))
		=> (square (fast-expt b 2))
			=> (square (fast-expt b 1))
				=> (* b (fast-expt b 0))
				=> (* b 1)
n=11=0b1011
	(fase-expt b 11)
	=> (* b (fase-expt b 10))
		=> (square (fast-expt b 5))
			=> (* b (fase-expt b 4))
				=> (square (fast-expt b 2))
					=> (square (fast-expt b 1))
						=> (* b (fast-expt b 0))
						=> (* b 1)
n=12=0b1100
	(fase-expt b 12)
	=> (square (fast-expt b 6))
		=> (square (fast-expt b 3))
			=> (* b (fast-expt b 2))
				=> (square (fast-expt b 1))
					=> (* b (fast-expt b 0))
					=> (* b 1)
-->
</p>

<p class="orig" lang="en"><a name="footnote_Temp_63" href="#call_footnote_Temp_63"><sup><small>38</small></sup></a> You may wonder
why anyone would care about raising numbers to the 1000th power.  See
section&nbsp;<a href="#%_sec_1.2.6">1.2.6</a>.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_63"><sup><small>38</small></sup></a>
なぜ数を1000乗もすることに誰かが関心を持ったりするのだろうか、と君は不思議に思うかもしれない。
<a href="#%_sec_1.2.6">1.2.6</a> を参照。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_64" href="#call_footnote_Temp_64"><sup><small>39</small></sup></a> This iterative
algorithm is ancient.  It appears in the <em>Chandah-sutra</em> by
<a name="%_idx_810"></a><a name="%_idx_812"></a><a name="%_idx_814"></a>&Aacute;ch&aacute;rya Pingala, written before 200 <font size=-2>B</font>.<font size=-2>C</font>. See Knuth 1981, section
4.6.3, for a full discussion and analysis of this and other methods of
exponentiation.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_64"><sup><small>39</small></sup></a>
この反復的アルゴリズムは、昔からあるものだ。
これは、アチャリャ・ピンガラによる <em class="en">Chandah-sutra</em>——紀元前200年より前に書かれた——に記載されている。
これやら、その他の冪乗の方法やらについての、詳細な議論と分析については、Knuth 1981の4.6.3節を参照。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_68" href="#call_footnote_Temp_68"><sup><small>40</small></sup></a> This
<a name="%_idx_820"></a><a name="%_idx_822"></a>algorithm, which is sometimes known as the ``Russian peasant method''
of multiplication, is ancient.  Examples of its use are found in the
<a name="%_idx_824"></a>Rhind Papyrus, one of the two oldest mathematical documents in
existence, written about 1700 <font size=-2>B</font>.<font size=-2>C</font>. (and copied from an even
<a name="%_idx_826"></a>older document) by an Egyptian scribe named A'h-mose.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_68"><sup><small>40</small></sup></a>
このアルゴリズム——乗算についての「ロシアの小作農の方法」として知られているときもある——は、昔からあるものだ。
その使用例は、リンド・パピルス——現存する最古の二つの数学的文書のうちの一つで、アフモセという名のエジプトの書記官により、紀元前1700年頃に書かれた (そしてこれは、より古い文書から複写されたものである) ——に見られる。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_70" href="#call_footnote_Temp_70"><sup><small>41</small></sup></a> This exercise was
<a name="%_idx_830"></a><a name="%_idx_832"></a>suggested to us by Joe Stoy, based on an example in Kaldewaij 1990.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_70"><sup><small>41</small></sup></a>
この練習問題は、Kaldewaij 1990の中の例に基づいて、ジョー・ストイから私たちに提案されたものである。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_71" href="#call_footnote_Temp_71"><sup><small>42</small></sup></a> Euclid's Algorithm is so
<a name="%_idx_838"></a>called because it appears in Euclid's <em>Elements</em> (Book 7, ca. 300
<font size=-2>B</font>.<font size=-2>C</font>.).  According to Knuth (1973), it can be considered the
<a name="%_idx_840"></a>oldest known nontrivial algorithm.  The ancient Egyptian method of
multiplication (exercise&nbsp;<a href="#%_thm_1.18">1.18</a>) is surely older,
but, as Knuth explains, Euclid's algorithm is the oldest known to have
been presented as a general algorithm, rather than as a set of
illustrative examples.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_71"><sup><small>42</small></sup></a>
ユークリッドのアルゴリズムは、ユークリッドの『原論』 (第7巻、紀元前300年頃) に記載されているので、こう呼ばれる。
クヌース (1973年) によれば、これは、既知の非自明なアルゴリズムのうちで最古のものと見なせる。
古代エジプトの乗算方法 (練習問題<a href="#%_thm_1.18">1.18</a>) は、確かにもっと古いのだが、クヌースが説明しているように、ユークリッドのアルゴリズムは、説明に役立つ例の集合というよりむしろ一般的なアルゴリズムとして提示されたことが知られているものの中で、最古のものなのだ。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_72" href="#call_footnote_Temp_72"><sup><small>43</small></sup></a> This theorem was proved in 1845 by Gabriel Lam&eacute;, a
<a name="%_idx_850"></a>French mathematician and engineer known chiefly for his contributions
to mathematical physics.  To prove the theorem, we consider pairs
(<em>a</em><sub><em>k</em></sub> ,<em>b</em><sub><em>k</em></sub>), where <em>a</em><sub><em>k</em></sub><u>&gt;</u> <em>b</em><sub><em>k</em></sub>, for which Euclid's Algorithm
terminates in <em>k</em> steps.  The proof is based on the claim that, if
(<em>a</em><sub><em>k</em>+1</sub>, <em>b</em><sub><em>k</em>+1</sub>)  <img src="book-Z-G-D-15.gif" border="0">  (<em>a</em><sub><em>k</em></sub>, <em>b</em><sub><em>k</em></sub>)
 <img src="book-Z-G-D-15.gif" border="0">  (<em>a</em><sub><em>k</em>-1</sub>, <em>b</em><sub><em>k</em>-1</sub>) are three successive pairs in the
reduction process, then we must have <em>b</em><sub><em>k</em>+1</sub><u>&gt;</u> <em>b</em><sub><em>k</em></sub>  +  <em>b</em><sub><em>k</em>-1</sub>.
To verify the claim, consider that a reduction step is defined by
applying the transformation <em>a</em><sub><em>k</em>-1</sub>  =  <em>b</em><sub><em>k</em></sub>, <em>b</em><sub><em>k</em>-1</sub>  = 
 remainder of  <em>a</em><sub><em>k</em></sub> divided by <em>b</em><sub><em>k</em></sub>.  
The second equation means that <em>a</em><sub><em>k</em></sub>  =  <em>q</em><em>b</em><sub><em>k</em></sub>  +  <em>b</em><sub><em>k</em>-1</sub> for some
positive integer <em>q</em>.  And since <em>q</em> must be at least 1 we have <em>a</em><sub><em>k</em></sub>
 =  <em>q</em><em>b</em><sub><em>k</em></sub>  +  <em>b</em><sub><em>k</em>-1</sub> <u>&gt;</u> <em>b</em><sub><em>k</em></sub>  +  <em>b</em><sub><em>k</em>-1</sub>.  But in the previous
reduction step we have <em>b</em><sub><em>k</em>+1</sub> =  <em>a</em><sub><em>k</em></sub>.  Therefore, <em>b</em><sub><em>k</em>+1</sub>  = 
<em>a</em><sub><em>k</em></sub><u>&gt;</u> <em>b</em><sub><em>k</em></sub>  +  <em>b</em><sub><em>k</em>-1</sub>.  This verifies the claim.  Now we can
prove the theorem by induction on <em>k</em>, the number of steps that the
algorithm requires to terminate.  The result is true for <em>k</em> = 1, since
this merely requires that <em>b</em> be at least as large as 
<em>F</em><em>i</em><em>b</em>(1) = 1.  Now, assume that the result is true for all integers less
than or equal to <em>k</em> and establish the result for <em>k</em> + 1.  Let
(<em>a</em><sub><em>k</em>+1</sub>, <em>b</em><sub><em>k</em>+1</sub>) <img src="book-Z-G-D-15.gif" border="0"> (<em>a</em><sub><em>k</em></sub>, <em>b</em><sub><em>k</em></sub>)
 <img src="book-Z-G-D-15.gif" border="0"> (<em>a</em><sub><em>k</em>-1</sub>, <em>b</em><sub><em>k</em>-1</sub>) be successive pairs in the
reduction process.  By our induction hypotheses, we have <em>b</em><sub><em>k</em>-1</sub><u>&gt;</u>
 <em>F</em><em>i</em><em>b</em>(<em>k</em> - 1) and <em>b</em><sub><em>k</em></sub><u>&gt;</u>  <em>F</em><em>i</em><em>b</em>(<em>k</em>).  Thus, applying the claim we just
proved together with the definition of the Fibonacci numbers gives
<em>b</em><sub><em>k</em>+1</sub> <u>&gt;</u> <em>b</em><sub><em>k</em></sub>  +  <em>b</em><sub><em>k</em>-1</sub><u>&gt;</u>  <em>F</em><em>i</em><em>b</em>(<em>k</em>)  +   <em>F</em><em>i</em><em>b</em>(<em>k</em> - 1)  =  <em>F</em><em>i</em><em>b</em>(<em>k</em> + 1), which
completes the proof of Lam&eacute;'s Theorem.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_72"><sup><small>43</small></sup></a>
この定理は、ガブリエル・ラメ——数理物理学への貢献によって主に知られている、フランスの数学者・エンジニア——によって、1845年に証明された。
この定理を証明するために、私たちは、ユークリッドのアルゴリズムが <em class="en">k</em> 個のステップで終了するような、
<span class="math">(<em class="en">a</em><sub><em class="en">k</em></sub>, <em class="en">b</em><sub><em class="en">k</em></sub>)</span>
という対——ただし、
<span class="math"><em class="en">a</em><sub><em class="en">k</em></sub> &ge; <em class="en">b</em><sub><em class="en">k</em></sub></span> 
とする——を考える。
証明は、次のような主張に基づく。すなわち、もし、
<span class="math">(<em class="en">a</em><sub><em class="en">k</em>+1</sub>, <em class="en">b</em><sub><em class="en">k</em>+1</sub>) &rarr; 
(<em class="en">a</em><sub><em class="en">k</em></sub>, <em class="en">b</em><sub><em class="en">k</em></sub>) &rarr;
(<em class="en">a</em><sub><em class="en">k</em>&minus;1</sub>, <em class="en">b</em><sub><em class="en">k</em>&minus;1</sub>)</span>
が、縮退過程において連続する三つの対ならば、
<span class="math"><em class="en">b</em><sub><em class="en">k</em>+1</sub> &ge; <em class="en">b</em><sub><em class="en">k</em></sub>  +  <em class="en">b</em><sub><em class="en">k</em>&minus;1</sub></span>
でなければならない。
この主張を立証するためには、
<span class="math"><em class="en">a</em><sub><em class="en">k</em>&minus;1</sub>  =  <em class="en">b</em><sub><em class="en">k</em></sub></span> かつ 
<span class="math"><em class="en">b</em><sub><em class="en">k</em>&minus;1</sub>  =  <em class="en">a</em><sub><em class="en">k</em></sub> を <em class="en">b</em><sub><em class="en">k</em></sub> で割った余り</span>、
という変換の適用により縮退ステップが定義されていることを考慮せよ。
二つ目の等式は、何らかの正整数 <em class="en">q</em> に対して
<span class="math"><em class="en">a</em><sub><em class="en">k</em></sub>  =  <em class="en">q</em><em class="en">b</em><sub><em class="en">k</em></sub>  +  <em class="en">b</em><sub><em class="en">k</em>&minus;1</sub></span>
であることを意味する。
そして、<em class="en">q</em> は最小でも1でなければならないのだから、
<span class="math"><em class="en">a</em><sub><em class="en">k</em></sub>
=  <em class="en">q</em><em class="en">b</em><sub><em class="en">k</em></sub>  +  <em class="en">b</em><sub><em class="en">k</em>&minus;1</sub> &ge; 
<em class="en">b</em><sub><em class="en">k</em></sub>  +  <em class="en">b</em><sub><em class="en">k</em>&minus;1</sub></span>
である。
一方、前の縮退ステップでは
<span class="math"><em class="en">b</em><sub><em class="en">k</em>+1</sub> =  <em class="en">a</em><sub><em class="en">k</em></sub></span>
である。
よって、
<span class="math">
<em class="en">b</em><sub><em class="en">k</em>+1</sub>  = 
<em class="en">a</em><sub><em class="en">k</em></sub> &ge; <em class="en">b</em><sub><em class="en">k</em></sub>  +  <em class="en">b</em><sub><em class="en">k</em>&minus;1</sub>
</span>
である。
これが、上記主張の立証である。
さて、私たちは今や、<em class="en">k</em>——アルゴリズムが終了するのに要するステップの数——についての帰納法によって、定理を証明できる。
<em class="en">k</em> = 1 の場合、結果は真である。なぜなら、この場合、<em class="en">b</em> が <span class="math"><em class="en">Fib</em>(1) = 1</span> 以上でなくてはならない、というだけだからだ。
さて、<em class="en">k</em> 以下のすべての整数について、結果が真であるものとせよ。そして、<span class="math"><em class="en">k</em> + 1</span> の場合の結果を証明せよ。
<span class="math">
(<em class="en">a</em><sub><em class="en">k</em>+1</sub>, <em class="en">b</em><sub><em class="en">k</em>+1</sub>) &rarr; 
(<em class="en">a</em><sub><em class="en">k</em></sub>, <em class="en">b</em><sub><em class="en">k</em></sub>) &rarr;
(<em class="en">a</em><sub><em class="en">k</em>&minus;1</sub>, <em class="en">b</em><sub><em class="en">k</em>&minus;1</sub>)
</span>
を、縮退過程において連続する対だとする。
帰納法における仮定より、
<span class="math"><em class="en">b</em><sub><em class="en">k</em>&minus;1</sub> &ge; <em class="en">Fib</em>(<em class="en">k</em> &minus; 1)</span> かつ
<span class="math"><em class="en">b</em><sub><em class="en">k</em></sub> &ge; <em class="en">Fib</em>(<em class="en">k</em>)</span>
である。
よって、私たちが証明したばかりの上記主張を、フィボナッチ数の定義とともに適用することで、
<span class="math">
<em class="en">b</em><sub><em class="en">k</em>+1</sub> &ge; 
<em class="en">b</em><sub><em class="en">k</em></sub>  +  <em class="en">b</em><sub><em class="en">k</em>&minus;1</sub> &ge;
<em class="en">Fib</em>(<em class="en">k</em>) + <em class="en">Fib</em>(<em class="en">k</em> &minus; 1)  =  <em class="en">Fib</em>(<em class="en">k</em> + 1)
</span>
が得られ、これよりラメの定理の証明は完了する。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_75" href="#call_footnote_Temp_75"><sup><small>44</small></sup></a> If <em>d</em> is a divisor of <em>n</em>, then so is <em>n</em>/<em>d</em>.
But <em>d</em> and <em>n</em>/<em>d</em> cannot both be greater than <img src="book-Z-G-D-13.gif" border="0"><em>n</em>.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_75"><sup><small>44</small></sup></a>
もし <em class="en">d</em> が <em class="en">n</em> の約数なら、<span class="math"><em class="en">n</em>/<em class="en">d</em></span> も <em class="en">n</em> の約数である。
ただし、<em class="en">d</em> と <span class="math"><em class="en">n</em>/<em class="en">d</em></span> の双方がともに &radic;<em class="en">n</em> より大きい、ということはあり得ない。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_77" href="#call_footnote_Temp_77"><sup><small>45</small></sup></a> Pierre de Fermat (1601-1665) is considered to be the founder of
<a name="%_idx_872"></a><a name="%_idx_874"></a>modern number theory.  He obtained many important number-theoretic
results, but he usually announced just the results, without providing
his proofs.  <a name="%_idx_876"></a>Fermat's Little Theorem was stated in a letter he wrote in
1640.  The first published proof was given by <a name="%_idx_878"></a>Euler in 1736 (and an
<a name="%_idx_880"></a>earlier, identical proof was discovered in the unpublished manuscripts
of Leibniz).  The most famous of Fermat's results -- known as Fermat's
Last Theorem -- was jotted down in 1637 in his copy of the book <em>Arithmetic</em> (by the third-century Greek mathematician <a name="%_idx_882"></a>Diophantus) with the
remark ``I have discovered a truly remarkable proof, but this margin is
too small to contain it.''  Finding a proof of Fermat's Last Theorem
became one of the most famous challenges in number theory.  A complete
<a name="%_idx_884"></a>solution was finally given in 1995 by Andrew Wiles of Princeton University.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_77"><sup><small>45</small></sup></a>
ピエール・ド・フェルマー (1601〜1665年) は、近代数論の創始者だと考えられている。
彼は、多くの重要な数論上の成果を得たが、大抵は、彼自身の証明を提示せずに、その成果だけを発表した。
フェルマーの小定理は、彼が1640年に書いた手紙の中に記述されていた。
公表された最初の証明は、1736年にオイラーによって与えられた (そして、より早い同一の証明が、ライプニッツの未刊行の手稿の中に発見された)。
フェルマーの成果のうち最も有名なもの——フェルマーの最終定理として知られる——は、彼の持っていた『算術』という本 (3世紀のギリシャの数学者・ディオファントス著) に、1637年に、「私は実に驚くべき証明を発見したが、この余白は、その証明を収めるには小さすぎる」という注記とともに、書き留められた。
フェルマーの最終定理の証明を見つけることは、数論における最も有名な難問の一つとなった。
完全な解法は、1995年に遂に、プリンストン大学のアンドリュー・ワイルズによって与えられた。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_78" href="#call_footnote_Temp_78"><sup><small>46</small></sup></a> The reduction steps in the cases where the exponent
<em>e</em> is greater than 1 are based on the fact that, for any integers
<em>x</em>, <em>y</em>, and <em>m</em>, we can find the remainder of <em>x</em> times <em>y</em> modulo
<em>m</em> by computing separately the remainders of <em>x</em> modulo <em>m</em> and <em>y</em>
modulo <em>m</em>, multiplying these, and then taking the remainder of the
result modulo <em>m</em>.  For instance, in the case where <em>e</em> is even, we
compute the remainder of <em>b</em><sup><em>e</em>/2</sup> modulo <em>m</em>, square this, and take
the remainder modulo <em>m</em>.  This technique is useful because it means
we can perform our computation without ever having to deal with
numbers much larger than <em>m</em>.  (Compare
exercise&nbsp;<a href="#%_thm_1.25">1.25</a>.)
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_78"><sup><small>46</small></sup></a>
指数の <em class="en">e</em> が1より大きい場合の縮退ステップは、次の事実に基づいている。すなわち、任意の整数 <em class="en">x</em> と <em class="en">y</em> と <em class="en">m</em> に対して、<em class="en">m</em> を法とする <em class="en">x</em> の剰余と、<em class="en">m</em> を法とする <em class="en">y</em> の剰余を別々に計算して、それらを掛け合わせ、<em class="en">m</em> を法として乗算結果の剰余を取ることにより、<em class="en">x</em> 掛ける <em class="en">y</em> の、<em class="en">m</em> を法とする剰余を得ることができる。
たとえば、<em class="en">e</em> が偶数の場合、<em class="en">m</em> を法とする <em class="en">b</em><sup><em class="en">e</em>/2</sup> の剰余を計算し、それを二乗し、<em class="en">m</em> を法として剰余を取る。
この技法は、いつも <em class="en">m</em> よりずっと大きな数を扱う必要なしに計算ができることを意味しているので、有用である
(練習問題<a href="#%_thm_1.25">1.25</a>と比べよ)。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_80" href="#call_footnote_Temp_80"><sup><small>47</small></sup></a> Numbers that fool the
<a name="%_idx_912"></a>Fermat test are called <em>Carmichael numbers</em>, and little is known
about them other than that they are extremely rare.  There are 255
Carmichael numbers below 100,000,000.  The smallest few are 561, 1105,
1729, 2465, 2821, and 6601.  In testing primality of very large
numbers chosen at random, the chance of stumbling upon a value that
fools the Fermat test is less than the chance that <a name="%_idx_914"></a>cosmic radiation
will cause the computer to make an error in carrying out a ``correct''
algorithm.  Considering an algorithm to be inadequate for the first
reason but not for the second illustrates the difference between
<a name="%_idx_916"></a><a name="%_idx_918"></a>mathematics and engineering.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_80"><sup><small>47</small></sup></a>
フェルマーのテストを欺く数は、<em>カーマイケル数</em>と呼ばれ、それらが非常に稀だということ以外は、ほとんど何も知られていない。
100,000,000未満のカーマイケル数が255個ある。
最も小さいいくつかは、561、1105、1729、2465、2821、6601である。
無作為に選ばれたとても大きな数の素数性を調べる際に、フェルマーのテストを欺く値に偶然に出くわす可能性は、「正しい」アルゴリズムの実行中に、宇宙線がコンピュータに誤りを引き起こす可能性よりも、低い。
二番目の理由ゆえにではなく、一番目の理由ゆえにアルゴリズムを不適切と見なすことは、数学と工学の差異を示している。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_81" href="#call_footnote_Temp_81"><sup><small>48</small></sup></a> One of the most striking applications of
<a name="%_idx_920"></a>probabilistic prime testing has been to the field of cryptography.
Although it is now computationally infeasible to factor an arbitrary
200-digit number, the primality of such a number can be checked in a
few seconds with the Fermat test.  This fact forms the basis of a
technique for constructing ``unbreakable codes'' suggested by <a name="%_idx_922"></a>Rivest,
<a name="%_idx_924"></a>Shamir, and <a name="%_idx_926"></a>Adleman (1977).  The resulting <a name="%_idx_928"></a><em>RSA algorithm</em> has
become a widely used technique for enhancing the security of
electronic communications.  Because of this and related developments,
the study of <a name="%_idx_930"></a>prime numbers, once considered the epitome of a topic in
``pure'' mathematics to be studied only for its own sake, now turns
out to have important practical applications to cryptography,
electronic funds transfer, and information retrieval.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_81"><sup><small>48</small></sup></a>
確率的な素数判定の、最も目を引く応用の一つは、今に至るまで、暗号技術分野への応用である。
任意の200桁の数を因数分解することは、今は計算量的に実現不可能だが、そういう数の素数性は、フェルマーのテストにより2〜3秒で調べられる。
この事実は、リベストとシャミアとエーデルマンにより1977年に提案された「解読不能なコード」を構築するための技法の、土台を形成している。
その結果として生じた<em>RSAアルゴリズム</em>は、電子通信のセキュリティを高めるための、広く使われる技法となった。
このことと、これに関連する発展のゆえに、素数の研究——かつては、それ自体のために研究されるべき「純粋な」数学の題目の典型例だと考えられていた——は、今や、暗号技術・電子資金取引・情報検索への重要かつ実用的な応用があることが判明した。
</p>

<footer class="note">
<ul>
<li>2015-07-24: 練習問題は解いていないが、それ以外はとりあえず訳した。</li>
<li>2015-08-01: アンカータグの修正。</li>
<li>2015-08-13: ちょっと修正。<!--memoizationをmemorizationと見間違えていた……--></li>
<li>2015-08-14: ちょっと修正。<!--「約分」云々のところ--></li>
<li>2015-09-03: ページ上下のナビゲーションに少し追加。</li>
<li>2016-02-29: ナビゲーションの形式を変えた。ページ内索引も追加。</li>
</ul>
</footer>

</div>
</body>
</html>
