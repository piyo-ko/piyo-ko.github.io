<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="sicp.css" type="text/css">
<base target="_top">
<title>SICP私訳: 5.5 コンパイル</title>
<link rel="canonical" href="https://piyo-ko.github.io/SICP/35_sec5_5.html" />
</head>
<body>

<div class="idx-bar">
<nav>
<a href="https://twitter.com/share" class="twitter-share-button" data-lang="ja">ツイート</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
<span class="status">翻訳中</span>
[
<a href="00_cover.html">先頭へ</a> |
<a href="34_sec5_4.html">前へ</a> |
<a href="36_ref.html">次へ</a> |
<a href="04_toc.html#%_toc_start">目次</a> |
<a href="38_index.html#%_index_start">索引</a>
] [<a href="99_about.html">この対訳版について</a> | <a href="../index.html">ホーム</a>]
[
§<a href="#%_sec_5.5">5.5</a>
📚<a href="#%_sec_Temp_796">&hellip;</a>
§<a href="#%_sec_5.5.1">5.5.1</a>
📚<a href="#%_sec_Temp_798">&hellip;</a>
📚<a href="#%_sec_Temp_799">&hellip;</a>
📝<a href="#%_thm_5.31">5.31</a>
📝<a href="#%_thm_5.32">5.32</a>
§<a href="#%_sec_5.5.2">5.5.2</a>
📚<a href="#%_sec_Temp_802">&hellip;</a>
📚<a href="#%_sec_Temp_804">&hellip;</a>
📚<a href="#%_sec_Temp_805">&hellip;</a>
📚<a href="#%_sec_Temp_807">&hellip;</a>
📚<a href="#%_sec_Temp_808">&hellip;</a>
§<a href="#%_sec_5.5.3">5.5.3</a>
📚<a href="#%_sec_Temp_810">&hellip;</a>
📚<a href="#%_sec_Temp_811">&hellip;</a>
§<a href="#%_sec_5.5.4">5.5.4</a>
§<a href="#%_sec_5.5.5">5.5.5</a>
📝<a href="#%_thm_5.33">5.33</a>
📝<a href="#%_thm_5.34">5.34</a>
🎨<a href="#%_fig_5.17">5.17</a>
🎨<a href="#%_fig_5.17">5.17</a>
📝<a href="#%_thm_5.35">5.35</a>
🎨<a href="#%_fig_5.18">5.18</a>
🎨<a href="#%_fig_5.18">5.18</a>
📝<a href="#%_thm_5.36">5.36</a>
📝<a href="#%_thm_5.37">5.37</a>
📝<a href="#%_thm_5.38">5.38</a>
§<a href="#%_sec_5.5.6">5.5.6</a>
📝<a href="#%_thm_5.39">5.39</a>
📝<a href="#%_thm_5.40">5.40</a>
📝<a href="#%_thm_5.41">5.41</a>
📝<a href="#%_thm_5.42">5.42</a>
📝<a href="#%_thm_5.43">5.43</a>
📝<a href="#%_thm_5.44">5.44</a>
§<a href="#%_sec_5.5.7">5.5.7</a>
📚<a href="#%_sec_Temp_836">&hellip;</a>
📝<a href="#%_thm_5.45">5.45</a>
📝<a href="#%_thm_5.46">5.46</a>
📝<a href="#%_thm_5.47">5.47</a>
📝<a href="#%_thm_5.48">5.48</a>
📝<a href="#%_thm_5.49">5.49</a>
📝<a href="#%_thm_5.50">5.50</a>
📝<a href="#%_thm_5.51">5.51</a>
📝<a href="#%_thm_5.52">5.52</a>
<a href="#footnotes">脚注</a>
]</nav>
</div>

<div class="main-txt">


<a name="%_sec_5.5"></a>
<h2 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_5.5">5.5  Compilation</a></h2>
<h2 class="trans" lang="ja">5.5 コンパイル</h2>

<p class="orig" lang="en">
<a name="%_idx_6194"></a>
The explicit-control evaluator of section <a href="34_sec5_4.html#%_sec_5.4">5.4</a> is a
register machine whose controller interprets Scheme programs.  In this
section we will see how to run Scheme programs on a register machine
whose controller is not a Scheme interpreter.</p>

<p class="trans" lang="ja">
<a href="34_sec5_4.html#%_sec_5.4">5.4</a>節の明示的制御方式の評価器は、その<span class="note"> (レジスタ・マシン自身の) </span>コントローラが Scheme プログラムを解釈するというレジスタ・マシンである。
本節では、その<span class="note"> (レジスタ・マシン自身の) </span>コントローラが Scheme インタプリタではないようなレジスタ・マシン上で Scheme プログラムを動かす方法を見ることにしよう。
</p>

<p class="orig" lang="en">
<a name="%_idx_6196"></a><a name="%_idx_6198"></a>The explicit-control evaluator machine is universal -- it can carry out
any computational process that can be described in Scheme.  The
evaluator's controller orchestrates the use of its data paths to
perform the desired computation.  Thus, the evaluator's data paths are
universal: They are sufficient to perform any computation we desire,
given an appropriate controller.<a name="call_footnote_Temp_794" href="#footnote_Temp_794"><sup><small>33</small></sup></a></p>

<p class="trans" lang="ja">
明示的制御方式の評価器マシンは普遍的である——つまり、Scheme で記述できる任意の計算プロセスを実行できる。
評価器のコントローラは、所望の計算を実行するために、その<span class="note"> (コントロー自身の) </span>データ経路の使用を組織化する。
よって、評価器のデータ経路は、普遍的である。すなわち、適切なコントローラが与えられるなら、それらのデータ経路は、私たちが望む任意の計算を実行するのに十分なのである<a href="#footnote_Temp_794"><sup><small>33</small></sup></a>。
</p>

<p class="orig" lang="en">
<a name="%_idx_6200"></a><a name="%_idx_6202"></a>Commercial general-purpose computers are register machines organized
around a collection of registers and operations that constitute
an efficient and convenient universal set of data paths.
The controller for a general-purpose machine is an interpreter for
a register-machine language like the one we have been using.  This
language is called the <a name="%_idx_6204"></a><em>native language</em> of the machine, or simply
<a name="%_idx_6206"></a><em>machine language</em>.  Programs written in machine language are
sequences of instructions that use the machine's data paths.
For example, the <a name="%_idx_6208"></a>explicit-control evaluator's instruction sequence
can be thought of as a machine-language program for a general-purpose
computer rather than as the controller for a specialized interpreter
machine.</p>

<p class="trans" lang="ja">
商用の汎用コンピュータは、レジスタの集まりと、データ経路の効率的で便利な普遍的集合を構成する演算とを中心に系統立てられた、レジスタ・マシンである。
汎用マシン用のコントローラとは、私たちがこれまで使ってきた<!--ものの-->ようなレジスタ・マシン言語についてのインタプリタである。
この言語は、マシンの<em>ネイティブ言語</em>、または単に<em>マシン語</em>と呼ばれる。
マシン語で書かれたプログラムは、マシンのデータ経路を使う命令の列である。
たとえば、明示的制御方式の評価器の命令列は、特別のインタプリタ用のコントローラなのではなく、むしろ、汎用コンピュータ用のマシン語プログラムなのだ、と見なせる。
</p>

<p class="orig" lang="en">
<a name="%_idx_6210"></a><a name="%_idx_6212"></a>There are two common strategies for bridging the gap between
higher-level languages and register-machine languages.  The
explicit-control evaluator illustrates the
strategy of interpretation.  An interpreter written in the native
language of a machine configures the machine to execute programs
written in a language (called the <a name="%_idx_6214"></a><em>source language</em>) that may
differ from the native language of the machine performing the
evaluation.  The primitive procedures of the source language are
implemented as a library of subroutines written in the native language
of the given machine.  A program to be interpreted (called the <a name="%_idx_6216"></a><em>source program</em>) is represented as a data structure.  The interpreter
traverses this data structure, analyzing the source program.  As it
does so, it simulates the intended behavior of the source program by
calling appropriate primitive subroutines from the library.</p>

<p class="trans" lang="ja">
高水準言語とレジスタ・マシン言語の間の隔たりを埋めるための、二つの<!--平凡な-->よくある戦略がある。
明示的制御方式の評価器は、<ruby><rb>解釈</rb><rp> (</rp><rt>インタプリテーション</rt><rp>) </rp></ruby>の戦略を例解している。
あるマシンのネイティブ言語で書かれたインタプリタは、評価を実行する当該マシンのネイティブ言語とは異なるかもしれない言語 (<em>ソース言語</em>と呼ばれる) で書かれたプログラムを実行するように、そのマシンを構成する。
ソース言語の原始的手続きは、与えられたマシンのネイティブ言語で書かれたサブルーチンのライブラリとして、実装される。
解釈されるべきプログラム (<em>ソース・プログラム</em>と呼ばれる) は、データ構造として表現される。
インタプリタは、ソース・プログラムを分析する際、このデータ構造をトラバースする。
インタプリタがそのようにするに連れて、インタプリタは、ライブラリから適切な原始的サブルーチンを呼び出すことによって、ソース・プログラムの、意図された振る舞いをシミュレートする。
</p>

<p class="orig" lang="en">
In this section, we explore the alternative strategy of <em>compilation</em>.  A compiler for a given source language and machine
translates a source program into an equivalent program (called the
<a name="%_idx_6218"></a><em>object program</em>) written in the machine's native language.  The
compiler that we implement in this section translates programs written
in Scheme into sequences of instructions to be executed using
the explicit-control evaluator machine's data paths.<a name="call_footnote_Temp_795" href="#footnote_Temp_795"><sup><small>34</small></sup></a></p>

<p class="trans" lang="ja">
本節では、<em>コンパイル</em>という別の戦略を探究する。
与えられたソース言語とマシンについてのコンパイラは、ソース・プログラムを、そのマシンのネイティブ言語で書かれた等価なプログラム (<em>オブジェクト・プログラム</em>と呼ばれる) へと、翻訳する。
本節で私たちが実装するコンパイラは、Scheme で書かれたプログラムを、明示的制御方式の評価器マシンのデータ経路を用いて実行されるべき命令の列へと、翻訳する<a name="call_footnote_Temp_795" href="#footnote_Temp_795"><sup><small>34</small></sup></a>。
</p>

<p class="orig" lang="en">
Compared with interpretation, compilation can provide a great increase
in the efficiency of program execution, as we will explain below in
the overview of the compiler.  On the other hand, an interpreter
provides a more powerful environment for interactive program
development and debugging, because the source program being executed
is available at run time to be examined and modified.  In addition,
because the entire library of primitives is present, new programs can
be constructed and added to the system during debugging.</p>

<p class="trans" lang="ja">
解釈と比べると、コンパイルは——コンパイラの概要において以下に説明するとおり——プログラム実行の効率性における非常な進歩をもたらすことができる。
一方、インタプリタは、インタラクティブなプログラム開発とデバッグのためのより強力な環境をもたらす。なぜなら、実行されている最中のソース・プログラムが、実行時において、吟味したり改変したりするのに使えるからだ。
さらに、プリミティブの完全なライブラリが存在するので、デバッグの最中に新たなプログラムを構築してシステムに追加することができる。
</p>

<p class="orig" lang="en">
In view of the complementary advantages of compilation and
interpretation, modern program-development environments pursue a mixed
strategy.  Lisp interpreters are generally organized so that
interpreted procedures and compiled procedures can call each other.
This enables a programmer to compile those parts of a program that are
assumed to be debugged, thus gaining the efficiency advantage of
compilation, while retaining the interpretive mode of execution for
those parts of the program that are in the flux of interactive
development and debugging.  In
section <a href="#%_sec_5.5.7">5.5.7</a>, after we have implemented
the compiler, we will show how to interface it with our interpreter to
produce an integrated interpreter-compiler development system.</p>

<p class="trans" lang="ja">
コンパイルと解釈の相補的な利点を考慮して、現代的なプログラム開発環境は、混合した戦略を追求している。
Lisp インタプリタは、一般的には、解釈された手続きとコンパイルされた手続きがお互いを呼び出せるように、組織化されている。
これによってプログラマは、デバッグすべきだと想定されているプログラムの部分をコンパイルすることが可能となり、それゆえに、コンパイルの効率性の利点を得つつ、その一方で、インタラクティブな開発とデバッグの流動の中にあるプログラムの部分について、解釈による実行方式を保てるのだ。
コンパイラを実装した後の<a href="#%_sec_5.5.7">5.5.7</a>節では、統合インタプリタ・コンパイラ開発システムを作り出すためにコンパイラをインタプリタに仲介する方法を、示すことにしよう。

</p>

<a name="%_sec_Temp_796"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_796">An overview of the compiler</a></h4>
<h4 class="trans" lang="ja">コンパイラの概要</h4>

<p class="orig" lang="en"><a name="%_idx_6224"></a><a name="%_idx_6226"></a>
Our compiler is much like our interpreter, both in its structure and in
the function it performs.  Accordingly, the mechanisms used by the
compiler for analyzing expressions will be similar to those used by
the interpreter.  Moreover, to make it easy to interface compiled and
interpreted code, we will design the compiler to generate code that
obeys the same conventions of <a name="%_idx_6228"></a>register usage as the interpreter: The
environment will be kept in the <tt>env</tt> register, argument lists
will be accumulated in <tt>argl</tt>, a procedure to be applied will be
in <tt>proc</tt>, procedures will return their answers in <tt>val</tt>,
and the location to which a procedure should return will be kept in
<tt>continue</tt>.
In general, the compiler translates a source program into an object
program that performs essentially the same register operations as
would the interpreter in evaluating the same source program.</p>

<p class="trans" lang="ja">
私たちのコンパイラは、私たちのインタプリタに——構造と、実行する機能の、双方の点で——とてもよく似ている。
したがって、式を分析するためにコンパイラにより使われる仕組みは、インタプリタにより使われる仕組みに似たものとなるだろう。
さらに、コンパイルされたコードと解釈されたコードとを仲介するのを簡単にするために、レジスタ使用についてインタプリタと同じ慣習に従うコードを生成するように、コンパイラを設計しよう。つまり、環境は <tt>env</tt> レジスタに保持されるだろうし、実引数リストは <tt>argl</tt> に蓄積されるだろうし、適用すべき手続きは <tt>proc</tt> にあるだろうし、手続きは答えを <tt>val</tt> の中に返すだろうし、手続きが返ってくるべき場所は <tt>continue</tt> に保持されるだろう。
一般に、コンパイラは、ソース・プログラムを、インタプリタが同じソース・プログラムを評価する際に行うであろうものと本質的に同じレジスタ演算を行うオブジェクト・プログラムへと、翻訳する。
</p>

<p class="orig" lang="en">
This description suggests a strategy for implementing a rudimentary
compiler: We traverse the expression in the same way the
interpreter does.  When we encounter a register instruction that the
interpreter would perform in evaluating the expression, we do not
execute the instruction but instead accumulate it into a sequence.  The
resulting sequence of instructions will be the object code.  Observe
the <a name="%_idx_6230"></a><a name="%_idx_6232"></a>efficiency advantage of compilation over interpretation.  Each
time the interpreter evaluates an expression -- for example,
<tt>(f 84 96)</tt> -- it performs the work of
classifying the expression (discovering that this
is a procedure application) and testing for the end of the operand list
(discovering that there are two operands).  With a
compiler, the expression is analyzed only once, when the
instruction sequence is generated at compile time.  The object code
produced by the compiler contains only the instructions that evaluate
the operator and the two operands, assemble the argument list,
and apply the procedure (in <tt>proc</tt>) to the arguments (in <tt>argl</tt>).</p>

<p class="trans" lang="ja">
この説明は、基本的なコンパイラを実装するための戦略を示唆する。つまり、インタプリタが行うのと同じ方法で、式をトラバースするのだ。
その式を評価する際にインタプリタが行うであろうレジスタ命令に遭遇したら、その命令は実行せず、その代わりに、その命令を列に蓄積する。
結果としてできあがる命令列が、オブジェクト・コードになっているだろう。
解釈に対するコンパイルの効率上の優位に、気づいてほしい。
インタプリタは、式——例えば <tt>(f 84 96)</tt> ——を評価するたびに、その式を分類して (これは手続き適用だ、と突き止めて)、オペランド・リストの最後かどうかを検査する (二つのオペランドがある、と突き止める)、という仕事を行う。
コンパイラを使うと、式は一度だけ——コンパイル時に命令列が生成されるときに——分析される。
コンパイラにより作り出されたオブジェクト・コードは、オペレータと二つのオペランドを評価し、実引数リストを組み上げ、(<tt>proc</tt> にある) 手続きを (<tt>argl</tt> にある) 実引数に適用する命令だけを含む。
</p>

<p class="orig" lang="en">
<a name="%_idx_6234"></a>This is the same kind of optimization we implemented in the
analyzing evaluator of section <a href="26_sec4_1.html#%_sec_4.1.7">4.1.7</a>.
But there are further opportunities to gain efficiency in compiled code.
As the interpreter runs, it follows a process that must be applicable
to any expression in the language.  In contrast, a given segment of
compiled code is meant to execute some particular expression.  This
can make a big difference, for example in the use of the stack to
save registers.  When the interpreter evaluates an expression, it must
be prepared for any contingency.  Before evaluating a subexpression,
the interpreter saves all
registers that will be needed later, because
the subexpression might require an arbitrary evaluation.
A compiler, on the other hand, can exploit the structure of the
particular expression it is processing to generate code that avoids
unnecessary stack operations.</p>

<p class="trans" lang="ja">
これは、<a href="26_sec4_1.html#%_sec_4.1.7">4.1.7</a>節での評価器の分析において実装したものと、同じ種類の最適化である。
しかし、コンパイルされたコードにおいて効率性を達成するための、さらなる機会がある。
インタプリタが動く際、インタプリタは、当該言語で書かれたどのような式にも適用可能であらねばならないプロセスに従う。
対照的に、コンパイルされたコードの所与の断片は、何らかの特定の式を実行することを意図したものである。
これは、たとえば、レジスタを退避するためのスタックの使用において、大きな違いを生じる可能性がある。
インタプリタが式を評価するとき、インタプリタは、いかなる不測の事態にも備えていなくてはならない。
部分式を評価する前に、インタプリタは、後で必要になるであろうすべてのレジスタを退避する。なぜなら、その部分式が任意の評価を必要とするかもしれないからである。
一方、コンパイラは、自分が処理している最中の特定の式の構造を、不要なスタック演算を避けるコードを生成するために活用できるのだ。
</p>

<p class="orig" lang="en">
As a case in point, consider the combination <tt>(f 84 96)</tt>.  Before
the interpreter evaluates the operator of the combination, it prepares
for this evaluation by saving the registers containing the operands
and the environment, whose values will be needed later.  The
interpreter then evaluates the operator to obtain the result in <tt>val</tt>, restores the saved registers, and finally moves the result from
<tt>val</tt> to <tt>proc</tt>.  However, in the particular expression we are
dealing with, the operator is the symbol <tt>f</tt>, whose evaluation is
accomplished by the machine operation <tt>lookup-variable-value</tt>,
which does not alter any registers.  The compiler that we implement in
this section will take advantage of this fact and generate code that
evaluates the operator using the instruction
</p>

<p class="trans" lang="ja">
好例として、<tt>(f 84 96)</tt> というコンビネーションを考えよう。
インタプリタは、このコンビネーションの演算子を評価する前に、オペランドと環境を含むレジスタ——後でその値が必要になるだろう——を退避することで、この評価に備える。
それから、インタプリタは演算子を評価して結果を <tt>val</tt> の中に得て、退避してあるレジスタを復旧し、最後に結果を <tt>val</tt> から <tt>proc</tt> に移動する。
しかし、私たちが取り扱っている特定の式においては、演算子は <tt>f</tt> という記号であり、その評価は <tt>lookup-variable-value</tt> というマシン演算により達成され、このマシン演算はいかなるレジスタも変更しない。
本節で私たちが実装するコンパイラは、この事実を利用するだろうし、以下の命令を用いてこの演算子を評価するようなコードを生成するだろう。
</p>

<p class="lisp">(assign proc (op lookup-variable-value) (const f) (reg env))
</p>

<p class="orig" lang="en">This code not only avoids the unnecessary saves and
restores but also assigns the value of the lookup directly to
<tt>proc</tt>, whereas the interpreter would obtain the result in <tt>val</tt>
and then move this to <tt>proc</tt>.</p>

<p class="trans" lang="ja">
インタプリタは <tt>val</tt> の中の結果を取得して、それからこの結果を <tt>proc</tt> へ移動するであろうが、それに対してこのコードは、不要な退避・復旧を避けるだけでなく、ルックアップの値を直接的に <tt>proc</tt> に割り当てもするのだ。
</p>

<p class="orig" lang="en">
A compiler can also optimize access to the environment.  Having
analyzed the code, the compiler can in many cases know in which frame
a particular variable will be located and access that frame directly,
rather than performing the <tt>lookup-variable-value</tt> search.  We
will discuss how to implement such variable access in
section <a href="#%_sec_5.5.6">5.5.6</a>.  Until then, however, we will
focus on the kind of register and stack optimizations described above.
There are many other optimizations that can be performed by a
compiler, such as coding primitive operations ``in line'' instead of
using a general <tt>apply</tt> mechanism (see
exercise <a href="#%_thm_5.38">5.38</a>); but we will not emphasize these here.
Our main goal in this section is to illustrate the compilation process
in a simplified (but still interesting) context.</p>

<p class="trans" lang="ja">
コンパイラは、環境へのアクセスも最適化できる。
コードを分析し終えたら、多くの場合、コンパイラは、特定の変数がどのフレームに配置されるだろうかということを知ることができるし、<tt>lookup-variable-value</tt> 探索を実行するのではなく直接的にそのフレームにアクセスできる。
<a href="#%_sec_5.5.6">5.5.6</a>節では、そうした変数アクセスを実装する方法を議論しよう。
しかし、それまでは、上述のレジスタとスタックの最適化の種類に焦点を絞ろう。
一般的な <tt>apply</tt> の仕組みを使う代わりに原始的演算を「インライン形式で」コード化する (練習問題<a href="#%_thm_5.38">5.38</a>を参照) などといった、コンパイラによって実行できる他の多くの最適化が存在する。しかし、これらのことは、ここでは強調しないでおこう。
本節での私たちの主たる目標は、簡略化された (しかしそれでもまだ興味深い) 文脈において、コンパイル過程を例解することである。
</p>

<a name="%_sec_5.5.1"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_5.5.1">5.5.1  Structure of the Compiler</a></h3>
<h3 class="trans" lang="ja">5.5.1 コンパイラの構造</h3>

<p class="orig" lang="en"><a name="%_idx_6236"></a>
<a name="%_idx_6238"></a>In section <a href="26_sec4_1.html#%_sec_4.1.7">4.1.7</a> we modified our original
metacircular interpreter to separate analysis from execution.  We
analyzed each expression to produce an execution procedure that took
an environment as argument and performed the required operations.  In
our compiler, we will do essentially the same analysis.  Instead of
producing execution procedures, however, we will generate sequences of
instructions to be run by our register machine.</p>

<p class="trans" lang="ja">
<a href="26_sec4_1.html#%_sec_4.1.7">4.1.7</a>節で私たちは、元のメタ循環的インタプリタを、実行から分析を切り離すように改変した。
私たちは、それぞれの式を分析して、引数として環境をとる実行手続きを作り出し、必要な演算を実行した。
私たちのコンパイラでは、本質的に同じ分析を行おう。
しかし、実行手続きを作り出す代わりに、私たちのレジスタ・マシンによって実行されるべき命令の列を生成しよう。
</p>

<p class="orig" lang="en">
The procedure <tt>compile</tt> is the top-level dispatch in the compiler.
It corresponds to the <tt>eval</tt> procedure of
section <a href="26_sec4_1.html#%_sec_4.1.1">4.1.1</a>, the <tt>analyze</tt> procedure of
section <a href="26_sec4_1.html#%_sec_4.1.7">4.1.7</a>, and the <tt>eval-dispatch</tt>
entry point of the explicit-control-evaluator in
section <a href="34_sec5_4.html#%_sec_5.4.1">5.4.1</a>.
The compiler, like the interpreters, uses the <a name="%_idx_6240"></a>expression-syntax
procedures defined in section <a href="26_sec4_1.html#%_sec_4.1.2">4.1.2</a>.<a name="call_footnote_Temp_797" href="#footnote_Temp_797"><sup><small>35</small></sup></a>
<tt>Compile</tt> performs a case
analysis on the syntactic type of the expression to be compiled.  For
each type of expression, it dispatches to a specialized <a name="%_idx_6242"></a><em>code
generator</em>:</p>

<p class="trans" lang="ja">
<tt>compile</tt> という手続きは、コンパイラにおけるトップ・レベルの<ruby><rb>振り分け</rb><rp> (</rp><rt>ディスパッチ</rt><rp>) </rp></ruby>である。
これは、<a href="26_sec4_1.html#%_sec_4.1.1">4.1.1</a>節の <tt>eval</tt> 手続きや、<a href="26_sec4_1.html#%_sec_4.1.7">4.1.7</a>節の <tt>analyze</tt> 手続きや、<a href="34_sec5_4.html#%_sec_5.4.1">5.4.1</a>節の明示的制御方式の評価器での <tt>eval-dispatch</tt> というエントリ・ポイントに、対応する。
インタプリタと同様にコンパイラは、<a href="26_sec4_1.html#%_sec_4.1.2">4.1.2</a>節で定義した、式の文法についての手続きを使う<a href="#footnote_Temp_797"><sup><small>35</small></sup></a>。
 <tt>compile</tt> は、コンパイルすべき式の文法的種類に基づく場合分け分析を行う。
 式の各種類に対して、コンパイラは、専門の<em>コード<ruby><rb>生成器</rb><rp> (</rp><rt>ジェネレータ</rt><rp>) </rp></ruby></em>への振り分けを行う。
</p>

<p class="lisp"><a name="%_idx_6244"></a>(define (compile exp target linkage)
  (cond ((self-evaluating? exp)
         (compile-self-evaluating exp target linkage))
        ((quoted? exp) (compile-quoted exp target linkage))
        ((variable? exp)
         (compile-variable exp target linkage))
        ((assignment? exp)
         (compile-assignment exp target linkage))
        ((definition? exp)
         (compile-definition exp target linkage))
        ((if? exp) (compile-if exp target linkage))
        ((lambda? exp) (compile-lambda exp target linkage))
        ((begin? exp)
         (compile-sequence (begin-actions exp)
                           target
                           linkage))
        ((cond? exp) (compile (cond-&gt;if exp) target linkage))
        ((application? exp)
         (compile-application exp target linkage))
        (else
         (error &quot;Unknown expression type -- COMPILE&quot; exp))))
</p>


<a name="%_sec_Temp_798"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_798">Targets and linkages</a></h4>
<h4 class="trans" lang="ja">ターゲットとリンケージ</h4>

<p class="orig" lang="en"><a name="%_idx_6246"></a><tt>Compile</tt> and the code generators that it calls take two arguments
in addition to the expression to compile.  There is a <a name="%_idx_6248"></a><em>target</em>,
which specifies the register in which the compiled code is to return
the value of the expression.  There is also a <a name="%_idx_6250"></a><em>linkage
descriptor</em>, which describes how the code resulting from the
compilation of the expression should proceed when it has finished its
execution.  The linkage descriptor can require that the code do one of
the following three things:</p>

<p class="trans" lang="ja">
<tt>compile</tt> と、<tt>compile</tt> が呼び出すコード生成器は、コンパイルすべき式に加えてさらに二つの引数をとる。
<em>ターゲット</em>——コンパイルされたコードが式の値を返すことになる先のレジスタを指定する——がある。
<em>リンケージ記述子</em>——式のコンパイルから生じたコードが、自分の実行を終了したときに、どのように進むべきかを記述する——もある。
リンケージ記述子は、以下の三つの事柄のうちの一つをコードが行うことを、要求することができる。
</p>

<ul class="orig" lang="en">
<li>continue at the next instruction in sequence (this is
<a name="%_idx_6252"></a>specified by the linkage descriptor <tt>next</tt>),</li>

<li>return from the procedure being compiled (this is specified
<a name="%_idx_6254"></a>by the linkage descriptor <tt>return</tt>), or</li>

<li>jump to a named entry point (this is specified by using the
designated label as the linkage descriptor).</li>
</ul>

<ul class="trans" lang="ja">
<li>列の中の次の命令を続ける (これは、<tt>next</tt> というリンケージ記述子によって指定される)<span class="note"> (一般的なマシン語の説明において、プログラム・カウンタを1だけインクリメントする場合に対応)</span></li>
<li>コンパイルされている最中の当該手続きから戻る (これは、<tt>return</tt> というリンケージ記述子によって指定される)</li>
<li>名前の付けられたエントリ・ポイントへジャンプする (これは、指定されたラベルをリンケージ記述子として用いることによって、指定される)</li>
</ul>

<p class="orig" lang="en">
For example, compiling the expression <tt>5</tt> (which is
self-evaluating) with a target of the <tt>val</tt> register and a
linkage of <tt>next</tt> should produce the instruction</p>

<p class="trans" lang="ja">
たとえば、<tt>5</tt> という式 (これは自己評価的である) を、<tt>val</tt> レジスタというターゲットおよび <tt>next</tt> というリンケージとともにコンパイルすることで、次の命令が生成されるはずである。
</p>

<p class="lisp">(assign val (const 5))
</p>

<p class="orig" lang="en">Compiling the same expression with a linkage of <tt>return</tt> should
produce the instructions</p>

<p class="trans" lang="ja">
同じ式を、<tt>return</tt> というリンケージとともにコンパイルすることで、次の命令が生成されるはずである。
</p>

<p class="lisp">(assign val (const 5))
(goto (reg continue))
</p>

<p class="orig" lang="en">In the first case, execution will continue with the next instruction
in the sequence. In the second case, we will return from a procedure
call.  In both cases, the value of the expression will be placed into
the target <tt>val</tt> register.</p>

<p class="trans" lang="ja">
1番目の場合では、列の中の次の命令から、実行が継続するだろう。
2番目の場合では、手続き呼び出しから戻るだろう。
どちらの場合でも、式の値は、ターゲットたる <tt>val</tt> レジスタの中に入れられるだろう。
</p>

<a name="%_sec_Temp_799"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_799">Instruction sequences and stack usage</a></h4>
<h4 class="trans" lang="ja">命令列とスタック使用</h4>

<p class="orig" lang="en"><a name="%_idx_6256"></a><a name="%_idx_6258"></a>Each code generator returns an <em>instruction sequence</em> containing
the object code it has generated for the expression.  Code generation
for a compound expression is accomplished by combining the output from
simpler code generators for component expressions, just as
evaluation of a compound expression is accomplished by evaluating the
component expressions.</p>

<p class="trans" lang="ja">
それぞれのコード生成器は、自分が式に対して生成し終えたオブジェクト・コードを含む<em>命令列</em>を返す。
複合的な式に対するコード生成は、構成要素の式のためのより単純なコード生成器からの出力を結合することによって、成し遂げられる——ちょうど、複合的な式の評価が、構成要素の式を評価することによって成し遂げられるのと同様に。
</p>

<p class="orig" lang="en">
The simplest method for combining instruction sequences is a procedure
<a name="%_idx_6260"></a>called <tt>append-instruction-sequences</tt>.  It takes as arguments any
number of instruction sequences that are to be executed sequentially;
it appends them and returns the combined sequence.  That is, if
&lt;<em><em>s</em><em>e</em><em>q</em><sub>1</sub></em>&gt; and &lt;<em><em>s</em><em>e</em><em>q</em><sub>2</sub></em>&gt; are sequences of instructions, then
evaluating
</p>

<p class="trans" lang="ja">
命令列同士を結合するためのもっとも単純な方法は、<tt>append-instruction-sequences</tt> と呼ばれる手続きである。
これは、引数として、逐次的に実行されるべき任意の個数の命令列をとる。そして、それらの命令列を連結して、結合した列を返す。
つまり、もし 
<span class="math">&lt;<em class="en">seq</em><sub>1</sub>&gt;</span>
と
<span class="math">&lt;<em class="en">seq</em><sub>2</sub>&gt;</span>
が命令列であれば、以下のものを評価することで、
</p>

<p class="lisp">(append-instruction-sequences &lt;<em><em>s</em><em>e</em><em>q</em><sub>1</sub></em>&gt; &lt;<em><em>s</em><em>e</em><em>q</em><sub>2</sub></em>&gt;)
</p>

<p class="orig" lang="en">produces the sequence</p>

<p class="trans" lang="ja">
次の式が作り出される。
</p>

<p class="lisp">&lt;<em><em>s</em><em>e</em><em>q</em><sub>1</sub></em>&gt;
&lt;<em><em>s</em><em>e</em><em>q</em><sub>2</sub></em>&gt;
</p>

<p class="orig" lang="en">
<a name="%_idx_6262"></a>Whenever registers might need to be saved, the compiler's code generators use
<a name="%_idx_6264"></a><tt>preserving</tt>, which is a more subtle method for combining
instruction sequences.  <tt>Preserving</tt> takes three arguments: a set
of registers and two instruction sequences that are to be executed
sequentially.  It appends the sequences in such a way that the
contents of each register in the set is preserved over the execution
of the first sequence, if this is needed for the execution of the
second sequence.  That is, if the first sequence modifies the register
and the second sequence actually needs the register's original
contents, then <tt>preserving</tt> wraps a <tt>save</tt> and a <tt>restore</tt>
of the register around the first sequence before appending the
sequences.  Otherwise, <tt>preserving</tt> simply returns the appended
instruction sequences.  Thus, for example,</p>

<p class="trans" lang="ja">
レジスタを退避する必要があるかもしれないときはいつでも、コンパイラのコード生成器は <tt>preserving</tt> を使うのだが、これは、命令列を結合するための、より巧妙な方法である。
<tt>preserving</tt> は、三つの引数をとる。すなわち、レジスタの集合と、逐次的に実行すべき二つの命令列である。
<tt>preserving</tt> は、この集合内の各レジスタの中身が、1番目の列の実行中ずっと保全されるように、列同士をつなげる——もし、このことが2番目の列の実行に必要とされるならば。
つまり、もし1番目の列が当該レジスタを変更し、かつ、2番目の列が実際に当該レジスタの元の中身を必要とするならば、<tt>preserving</tt> は、列同士をつなげる前に、当該レジスタの <tt>save</tt> と <tt>restore</tt> を1番目の列にまとわせる。
それ以外の場合、<tt>preserving</tt> は単純に、つなげた命令列を返す。
よって、たとえば、
</p>

<p class="lisp">(preserving (list &lt;<em><em>r</em><em>e</em><em>g</em><sub>1</sub></em>&gt; &lt;<em><em>r</em><em>e</em><em>g</em><sub>2</sub></em>&gt;) &lt;<em><em>s</em><em>e</em><em>q</em><sub>1</sub></em>&gt; &lt;<em><em>s</em><em>e</em><em>q</em><sub>2</sub></em>&gt;)
</p>

<p class="orig" lang="en">produces one of the following four sequences of instructions, depending on how
&lt;<em><em>s</em><em>e</em><em>q</em><sub>1</sub></em>&gt; and &lt;<em><em>s</em><em>e</em><em>q</em><sub>2</sub></em>&gt; use &lt;<em><em>r</em><em>e</em><em>g</em><sub>1</sub></em>&gt; and &lt;<em><em>r</em><em>e</em><em>g</em><sub>2</sub></em>&gt;:</p>

<p class="trans" lang="ja">
は、
<span class="math">&lt;<em class="en">seq</em><sub>1</sub>&gt;</span>
と
<span class="math">&lt;<em class="en">seq</em><sub>2</sub>&gt;</span>
が
<span class="math">&lt;<em class="en">reg</em><sub>1</sub>&gt;</span>
と
<span class="math">&lt;<em class="en">reg</em><sub>2</sub>&gt;</span>
をどのように用いるのかによって、以下の四つの命令列のうちの一つを作り出す。
</p>

<figure><img src="ch5-Z-G-9.gif" border="0"></figure>

<p class="orig" lang="en">
By using <tt>preserving</tt> to combine instruction sequences the
compiler avoids unnecessary stack operations.  This also isolates the
details of whether or not to generate <tt>save</tt> and <tt>restore</tt>
instructions within the <tt>preserving</tt> procedure, separating them
from the concerns that arise in writing each of the individual code
generators.
In fact no <tt>save</tt> or <tt>restore</tt> instructions are explicitly
produced by the code generators.</p>

<p class="trans" lang="ja">
命令列同士を結合するために <tt>preserving</tt> を用いることによって、コンパイラは、不要なスタック演算を避ける。
これは、<tt>save</tt> 命令と <tt>restore</tt> 命令を生成すべきかどうかという詳細を、<tt>preserving</tt> 手続きの内部に隔離することにもなる——その詳細を、個々のコード生成器の各々を書く際に生じる問題から切り離すわけである。
実際、コード生成器によって明示的に <tt>save</tt> 命令または <tt>restore</tt> 命令が作り出されることはない。
</p>

<p class="orig" lang="en">
In principle, we could represent an instruction sequence simply as a
list of instructions.  <tt>Append-instruction-sequences</tt> could then
combine instruction sequences by performing an ordinary list <tt>append</tt>.  However, <tt>preserving</tt> would then be a complex operation,
because it would have to analyze each instruction sequence to
determine how the sequence uses its registers.  <tt>Preserving</tt>
would be inefficient as well as complex, because it would have to
analyze each of its instruction sequence arguments, even though these
sequences might themselves have been constructed by calls to <tt>preserving</tt>, in which case their parts would have already been
analyzed.  To avoid such repetitious analysis we will associate with each
instruction sequence some information about its register use.
When we construct a basic instruction sequence we
will provide this information explicitly,
and the procedures that combine instruction sequences will derive
register-use information for the combined sequence from the
information associated with the component sequences.</p>

<p class="trans" lang="ja">
原理的には、私たちは、命令列を単純に命令のリストとして表現できるだろう。
すると、<tt>append-instruction-sequences</tt> は、普通のリスト用の <tt>append</tt> を実行することで、命令列同士を結合できるだろう。
しかし、そうすると、<tt>preserving</tt> は、複雑な演算になってしまうだろう。なぜなら、列がどのようにしてレジスタを使うのかを明らかにするために各命令列を分析しなくてはならないだろうからである。
<tt>preserving</tt> は、複雑である上に非効率にもなるだろう。なぜなら、命令列引数のそれぞれを——たとえ、これらの列自体が、<tt>preserving</tt> への呼び出しにより構築されたのかもしれなくても (その場合には、これらの列の部分はもう分析済みであろう) ——分析しなくてはならないだろうからである。
そうした繰り返しの分析を避けるため、私たちは、各命令列に、そのレジスタ使用についてのある種の情報を関連づけよう。
基本的な命令列を構築するときには、この情報を明示的に提供しよう。すると、命令列同士を結合する手続きは、結合後の列についてのレジスタ使用の情報を、構成部品の列に関連づけられた情報から導き出すだろう。
</p>

<p class="orig" lang="en">
An instruction sequence will contain three pieces of information:</p>

<p class="trans" lang="ja">
命令列は三つの情報を含むだろう。
</p>


<ul class="orig" lang="en">
<li>the set of registers that must be initialized before the
instructions in the sequence are executed (these registers are said to
be <em>needed</em> by the sequence),</li>

<li>the set of registers whose values are modified by the
instructions in the sequence, and</li>

<li>the actual instructions (also called <em>statements</em>) in
the sequence.</li>
</ul>

<ul class="trans" lang="ja">
<li>その列の中の命令が実行される前に初期化されねばならないレジスタの集合 (これらのレジスタは、その列によって<em>必要とされる</em>のだ、と言われる)</li>
<li>その列の中の命令によって値が変更されるレジスタの集合</li>
<li>実際の命令 (<em><ruby><rb>文</rb><rp> (</rp><rt>ステートメント</rt><rp>) </rp></ruby></em>とも呼ばれる)</li>
</ul>

<p class="orig" lang="en">
We will represent an instruction sequence as a list of its three
parts.  The constructor for instruction sequences is thus</p>

<p class="trans" lang="ja">
命令列を、その三つの部分のリストとして表そう。
よって、命令列のためのコンストラクタは、以下のとおりである。
</p>

<p class="lisp"><a name="%_idx_6266"></a>(define (make-instruction-sequence needs modifies statements)
  (list needs modifies statements))
</p>

<p class="orig" lang="en">
For example, the two-instruction sequence that looks up the value of
the variable <tt>x</tt> in the current environment, assigns the result
to <tt>val</tt>, and then returns, requires registers <tt>env</tt> and <tt>continue</tt> to have been initialized, and modifies register <tt>val</tt>.
This sequence would therefore be constructed as</p>

<p class="trans" lang="ja">
たとえば、現在の環境における <tt>x</tt> という変数の値を調べて、その結果を <tt>val</tt> に<ruby><rb>代入し</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>、それから戻るような、二つの命令からなる列は、<tt>env</tt> および <tt>continue</tt> というレジスタが初期化済みであることを要求し、<tt>val</tt> というレジスタを変更する。
したがって、この列は、次のように構築されるだろう。
</p>

<p class="lisp">(make-instruction-sequence '(env continue) '(val)
 '((assign val
           (op lookup-variable-value) (const x) (reg env))
   (goto (reg continue))))
</p>

<p class="orig" lang="en">
We sometimes need to construct an instruction sequence with no statements:</p>

<p class="trans" lang="ja">
ときには、文のない命令列を構築する必要がある。
</p>

<p class="lisp"><a name="%_idx_6268"></a>(define (empty-instruction-sequence)
  (make-instruction-sequence '() '() '()))
</p>

<p class="orig" lang="en">
The procedures for combining instruction sequences are shown in
section <a href="#%_sec_5.5.4">5.5.4</a>.</p>

<p class="trans" lang="ja">
命令列同士を結合するための手続きは、<a href="#%_sec_5.5.4">5.5.4</a>節に示されている。
</p>

<p class="orig" lang="en">
<a name="%_thm_5.31"></a>
<b>Exercise 5.31.</b>  <a name="%_idx_6270"></a><a name="%_idx_6272"></a>In evaluating a procedure application, the explicit-control evaluator
always saves and restores
the <tt>env</tt> register around the evaluation of the operator, saves and
restores <tt>env</tt> around the evaluation of each operand (except the
final one), saves and restores <tt>argl</tt> around the evaluation of each
operand, and saves and restores <tt>proc</tt> around the evaluation of the
operand sequence.  For each of the following combinations, say which
of these <tt>save</tt> and <tt>restore</tt> operations are superfluous and
thus could be eliminated by the compiler's <tt>preserving</tt> mechanism:</p>

<p class="trans" lang="ja">
<b>練習問題5.31.</b> 手続き適用を評価する際、明示的制御方式の評価器は、いつも、演算子の評価を囲んで <tt>env</tt> レジスタを退避および復旧し、(最後の一つを除く) 各オペランドの評価を囲んで <tt>env</tt> を退避および復旧し、各オペランドの評価を囲んで <tt>argl</tt> を退避および復旧し、オペランド列の評価を囲んで <tt>proc</tt> を退避および復旧する。
以下のコンビネーションの各々について、これらの <tt>save</tt> 操作と <tt>restore</tt> 操作のうちのいずれが無駄であり、それゆえコンパイラの <tt>preserving</tt> の仕組みによって削除され得るのか、ということを述べよ。
</p>

<p class="lisp">(f 'x 'y)

((f) 'x 'y)

(f (g 'x) y)

(f (g 'x) 'y)
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.32"></a>
<b>Exercise 5.32.</b>  <a name="%_idx_6274"></a><a name="%_idx_6276"></a>Using the <tt>preserving</tt> mechanism, the compiler will avoid saving
and restoring <tt>env</tt> around the evaluation of the operator of a
combination in the case where the operator is a symbol.  We could also
build such optimizations into the evaluator.  Indeed, the
explicit-control evaluator of section <a href="34_sec5_4.html#%_sec_5.4">5.4</a> already
performs a similar optimization, by treating combinations with no
operands as a special case.</p>

<p class="trans" lang="ja">
<b>練習問題5.32.</b> <tt>preserving</tt> の仕組みを使うと、コンパイラは、演算子が記号である場合に、コンビネーションの演算子の評価を囲んで <tt>env</tt> を退避および復旧することを避けるだろう。
評価器の中にも、そういった最適化を組み入れることができるだろう。
実際、<a href="34_sec5_4.html#%_sec_5.4">5.4</a>節の明示的制御方式の評価器は、オペランドのないコンビネーションを特別な場合として取り扱うことによって、すでに類似の最適化を行っている。
</p>

<ol class="orig alph" lang="en">
<li>Extend the explicit-control evaluator to recognize as a separate class
of expressions combinations whose operator is a symbol, and to take
advantage of this fact in evaluating such expressions.</li>

<li>Alyssa P. Hacker suggests that by extending the evaluator to recognize
more and more special cases we could incorporate all the compiler's
optimizations, and that this would eliminate the advantage of compilation
altogether.  What do you think of this idea?</li>
</ol>

<ol class="trans alph" lang="ja">
<li>演算子が記号であるようなコンビネーションを、別の種類の式だと認識するように、かつ、そうした式を評価する際に、この事実を利用するように、明示的制御方式の評価器を拡張せよ。</li>
<li>ますます多くの特別な場合を認識するように評価器を拡張することによって、コンパイラの最適化のすべてを取り込むことができるだろうし、これはコンパイルの優位性を完全に消し去ってしまうだろう、とアリッサ・P・ハッカは示唆する。
この考えについて、君はどう思う?</li>
</ol>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_5.5.2"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_5.5.2">5.5.2  Compiling Expressions</a></h3>
<h3 class="trans" lang="ja">5.5.2 式をコンパイルする</h3>

<p class="orig" lang="en">In this section and the next we implement the code generators to which the <tt>compile</tt> procedure dispatches.</p>

<p class="trans" lang="ja">
本節と次節では、<tt>compile</tt> 手続きが振り分けを行う先のコード生成器を実装する。
</p>

<a name="%_sec_Temp_802"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_802">Compiling linkage code</a></h4>
<h4 class="trans" lang="ja">リンケージ・コードをコンパイルする</h4>

<p class="orig" lang="en"><a name="%_idx_6278"></a>In general, the output of each code generator will end with
instructions -- generated by the procedure <tt>compile-linkage</tt> -- that
implement the required linkage.  If the linkage is <tt>return</tt> then
we must generate the instruction <tt>(goto (reg continue))</tt>.  This
needs the <tt>continue</tt> register and does not modify any registers.
If the linkage is <tt>next</tt>, then we needn't include any additional
instructions.  Otherwise, the linkage is a label, and we generate a
<tt>goto</tt> to that label, an instruction that does not need or modify
any registers.<a name="call_footnote_Temp_803" href="#footnote_Temp_803"><sup><small>36</small></sup></a></p>

<p class="trans" lang="ja">
一般に、各コード生成器の出力は、要求されたリンケージを実装する命令—— <tt>compile-linkage</tt> という手続きにより生成される——で終わる。
もしリンケージが <tt>return</tt> なら、<tt>(goto (reg continue))</tt> という命令を生成しなくてはならない。
これは、<tt>continue</tt> レジスタを必要とし、どのレジスタも変更しない。
もしリンケージが <tt>next</tt> なら、何も追加の命令を含める必要はない。
それ以外の場合、リンケージはラベルであり、そのラベルへの <tt>goto</tt> ——つまり、どのレジスタも必要とはしないし、どのレジスタも変更しない命令——を生成する<a href="#footnote_Temp_803"><sup><small>36</small></sup></a>。
</p>

<p class="lisp"><a name="%_idx_6292"></a>(define (compile-linkage linkage)
  (cond ((eq? linkage 'return)
         (make-instruction-sequence '(continue) '()
          '((goto (reg continue)))))
        ((eq? linkage 'next)
         (empty-instruction-sequence))
        (else
         (make-instruction-sequence '() '()
          `((goto (label ,linkage)))))))
</p>

<p class="orig" lang="en">The linkage code is appended to an instruction sequence by <tt>preserving</tt>
the <tt>continue</tt> register, since a <tt>return</tt> linkage will
require the <tt>continue</tt> register:
If the given instruction sequence modifies <tt>continue</tt> and the
linkage code needs it, <tt>continue</tt> will be saved and restored.</p>

<p class="trans" lang="ja">
リンケージ・コードは、<tt>continue</tt> レジスタを <tt>preserving</tt> することによって、命令列に付加される。というのも、<tt>return</tt> リンケージは、<tt>continue</tt> レジスタを必要とするだろうからである。
与えられた命令列が <tt>continue</tt> を変更し、かつ、リンケージ・コードが <tt>continue</tt> を必要とする場合、<tt>continue</tt> は退避され、復旧されるだろう。
</p>

<p class="lisp"><a name="%_idx_6294"></a>(define (end-with-linkage linkage instruction-sequence)
  (preserving '(continue)
   instruction-sequence
   (compile-linkage linkage)))
</p>

<a name="%_sec_Temp_804"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_804">Compiling simple expressions</a></h4>
<h4 class="trans" lang="ja">単純な式をコンパイルする</h4>

<p class="orig" lang="en"><a name="%_idx_6296"></a><a name="%_idx_6298"></a><a name="%_idx_6300"></a>The code generators for self-evaluating expressions,
quotations, and variables construct instruction
sequences that assign the required value to the target register
and then proceed as specified by the linkage descriptor.</p>

<p class="trans" lang="ja">
自己評価的な式、<ruby><rb>引用</rb><rp> (</rp><rt>クオテーション</rt><rp>) </rp></ruby>、および変数に対するコード生成器は、必要とされる値をターゲット・レジスタに<ruby><rb>代入し</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>、その後、リンケージ記述子により指定されたように続行するような命令列を、構築する。
</p>

<p class="lisp"><a name="%_idx_6302"></a>(define (compile-self-evaluating exp target linkage)
  (end-with-linkage linkage
   (make-instruction-sequence '() (list target)
    `((assign ,target (const ,exp))))))
<a name="%_idx_6304"></a>(define (compile-quoted exp target linkage)
  (end-with-linkage linkage
   (make-instruction-sequence '() (list target)
    `((assign ,target (const ,(text-of-quotation exp)))))))
<a name="%_idx_6306"></a>(define (compile-variable exp target linkage)
  (end-with-linkage linkage
   (make-instruction-sequence '(env) (list target)
    `((assign ,target
              (op lookup-variable-value)
              (const ,exp)
              (reg env))))))
</p>

<p class="orig" lang="en">All these assignment instructions modify the target register,
and the one that looks up a variable needs the <tt>env</tt> register.</p>

<p class="trans" lang="ja">
これらすべての<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>命令はターゲット・レジスタを変更し、変数を調べる<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>命令は<tt>env</tt> レジスタを必要とする。
</p>

<p class="extra">***ここから先はあまり考えずに訳している***</p>

<p class="orig" lang="en">
<a name="%_idx_6308"></a><a name="%_idx_6310"></a>Assignments and definitions are handled much as they are in the
interpreter.  We recursively generate code that computes the value to
be assigned to the variable, and append to it a two-instruction
sequence that actually sets or defines the variable and assigns the
value of the whole expression (the symbol <tt>ok</tt>) to the target
register.  The recursive compilation has target <tt>val</tt> and linkage
<tt>next</tt> so that the code will put its result into <tt>val</tt> and
continue with the code that is appended after it.  The appending is
done preserving <tt>env</tt>, since the environment is needed for setting
or defining the variable and the code for the variable value could be
the compilation of a complex expression that might modify the
registers in arbitrary ways.</p>

<p class="trans" lang="ja">
<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>と定義は、インタプリタにおけるのとほぼ同様に扱われる。
私たちは、変数に<ruby><rb>代入される</rb><rp> (</rp><rt>わりあてられる</rt><rp>) </rp></ruby>べき値を計算するコード<span class="note"> (<tt>get-value-code</tt>) </span>を<span class="note"> (<tt>compile</tt> により) </span>再帰的に生成する。そして、実際に変数を設定または定義して<span class="note"> (<tt>(perform (op set-variable-value!) ...)</tt> で設定、または <tt>(perform (op define-variable!) ...)</tt> で定義して) </span>式全体の値 (<tt>ok</tt> という記号) をターゲット・レジスタに<ruby><rb>代入する</rb><rp> (</rp><rt>わりあてる</rt><rp>) </rp></ruby><span class="note"> (<tt>(assign ,target (const ok))</tt> による代入を行う) </span>ような、二つの命令からなる列<span class="note"> (<tt>make-instruction-sequence</tt> で作ったもの) </span>を、そのコード<span class="note"> (<tt>get-value-code</tt>) </span>の後ろに付加する。
再帰的なコンパイル<span class="note"> (<tt>compile (assignment-value exp) 'val 'next)</tt> または <tt>(compile (definition-value exp) 'val 'next)</tt>) </span>は、コードがその結果を <tt>val</tt> の中に入れるように、そして、そのコードの後に付加されるコードから続行するように、ターゲットたる <tt>val</tt> とリンケージたる <tt>next</tt> をもらう。
付加は、<tt>env</tt> を<ruby><rb>保全</rb><rp> (</rp><rt><tt>preserving</tt></rt><rp>) </rp></ruby>することによってなされる。というのも、変数を設定または定義するのには環境が必要であり、かつ、変数の値のためのコード<span class="note"> (<tt>get-value-code</tt>) </span>は、レジスタを任意の方法で変更するかもしれない複雑な式をコンパイルしたものであり得るからである。
</p>

<p class="lisp"><a name="%_idx_6312"></a>(define (compile-assignment exp target linkage)
  (let ((var (assignment-variable exp))
        (get-value-code
         (compile (assignment-value exp) 'val 'next)))
    (end-with-linkage linkage
     (preserving '(env)
      get-value-code
      (make-instruction-sequence '(env val) (list target)
       `((perform (op set-variable-value!)
                  (const ,var)
                  (reg val)
                  (reg env))
         (assign ,target (const ok))))))))
<a name="%_idx_6314"></a>(define (compile-definition exp target linkage)
  (let ((var (definition-variable exp))
        (get-value-code
         (compile (definition-value exp) 'val 'next)))
    (end-with-linkage linkage
     (preserving '(env)
      get-value-code
      (make-instruction-sequence '(env val) (list target)
       `((perform (op define-variable!)
                  (const ,var)
                  (reg val)
                  (reg env))
         (assign ,target (const ok))))))))
</p>

<p class="orig" lang="en">The appended two-instruction sequence requires <tt>env</tt> and <tt>val</tt>
and modifies the target.  Note that although we preserve <tt>env</tt> for
this sequence, we do not preserve <tt>val</tt>, because the <tt>get-value-code</tt> is designed to explicitly place its result in <tt>val</tt> for use by this sequence.
(In fact, if we did preserve <tt>val</tt>, we would
have a bug, because this would cause the previous contents of <tt>val</tt> to be restored right after the <tt>get-value-code</tt> is run.)</p>

<p class="trans" lang="ja">
つなげられる、二つの命令からなる列<span class="note"> (<tt>(perform ...)</tt> と <tt>(assign ...)</tt> からなる列) </span>は、<tt>env</tt> と <tt>val</tt> を必要とし、ターゲットを変更する。
この列のために <tt>env</tt> を保全している<span class="note"> (<tt>(preserving '(env) ...)</tt> としている) </span>ものの、<tt>val</tt> は保全していない——なぜなら、<tt>get-value-code</tt> は、この列による使用のために、その結果を明示的に <tt>val</tt> に入れるように設計されている<span class="note"> (<tt>(compile (assignment-value exp) 'val 'next)</tt> または <tt>(compile (definition-value exp) 'val 'next)</tt> と定義されている) </span>ためである——ということに、注意してほしい。
</p>

<a name="%_sec_Temp_805"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_805">Compiling conditional expressions</a></h4>
<h4 class="trans" lang="ja">条件式をコンパイルする</h4>

<p class="orig" lang="en"><a name="%_idx_6316"></a>The code for an <tt>if</tt> expression
compiled with a given target and linkage has the form</p>

<p class="trans" lang="ja">
与えられたターゲットおよびリンケージを使ってコンパイルされた、<tt>if</tt> 式に対するコードは、以下の形をとる。
</p>

<p class="lisp"> &lt;<em>compilation of predicate, target <tt>val</tt>, linkage <tt>next</tt></em>&gt;
 (test (op false?) (reg val))
 (branch (label false-branch))
true-branch
 &lt;<em>compilation of consequent with given target and given linkage or <tt>after-if</tt></em>&gt;
false-branch
 &lt;<em>compilation of alternative with given target and linkage</em>&gt;
after-if
</p>

<p class="exercise" lang="ja">&lt;<i class="ex_comment">述語と、ターゲットたる <tt>val</tt> と、リンケージたる <tt>next</tt> とをコンパイルしたもの</i>&gt;
 (test (op false?) (reg val))
 (branch (label false-branch))
true-branch
 &lt;<i class="ex_comment">帰結式を、与えられたターゲット、および、与えられたリンケージまたは <tt>after-if</tt> とともに、コンパイルしたもの</i>&gt;
false-branch
 &lt;<i class="ex_comment">代替式を、与えられたターゲットおよびリンケージとともに、コンパイルしたもの</i>&gt;
after-if
</p>

<p class="orig" lang="en">
To generate this code, we compile the predicate, consequent,
and alternative, and combine the resulting code with instructions
to test the predicate result and with newly generated labels
to mark the true and false branches and the end of the conditional.<a name="call_footnote_Temp_806" href="#footnote_Temp_806"><sup><small>37</small></sup></a>
In this arrangement of code, we must branch around the true branch
if the test is false.  The only slight complication is in how the
linkage for the true branch should be handled.  If the linkage for the
conditional is <tt>return</tt> or a label, then the true and false
branches will both use this same linkage.  If the linkage is <tt>next</tt>, the true branch ends with a jump around the code for the false
branch to the label at the end of the conditional.</p>

<p class="trans" lang="ja">
このコードを生成するために、述語と帰結式と代替式をコンパイルし、できあがったコード<span class="note"> (<tt>p-code</tt> と <tt>c-code</tt> と <tt>a-code</tt>) </span>を、述語の結果を検査する命令<span class="note"> (<tt>(test (op false?) (reg val))</tt>)</span>、および、真の分岐と偽の分岐と条件式の最後に印をつけるための新たに生成されたラベル<span class="note"> (<tt>t-branch</tt> と <tt>f-branch</tt> と <tt>after-if</tt>)</span> と、結合する<a href="#footnote_Temp_806"><sup><small>37</small></sup></a>。
コードのこうした配置において、検査が偽の場合には、真の分岐を避けるように分岐せねばならない。
ほんのちょっとした厄介ごとは、真の分岐についてのリンケージをどのように扱うべきか、という点にある。
もし条件式に対するリンケージが <tt>return</tt> またはラベルなら、真の分岐と偽の分岐は、どちらも、この同じリンケージを使うだろう。
もしそのリンケージが <tt>next</tt> であれば、真の分岐は、偽の分岐に対するコードを避けて条件式の最後にあるラベルへと飛ぶジャンプで終わる<span class="note"> (<tt>consequent-linkage</tt> を <tt>(if (eq? linkage 'next) after-if linkage)</tt> と定義して、<tt>c-code</tt> を求める際に、この<tt>consequent-linkage</tt> を使っている)</span>。
</p>

<p class="lisp"><a name="%_idx_6324"></a>(define (compile-if exp target linkage)
  (let ((t-branch (make-label 'true-branch))
        (f-branch (make-label 'false-branch))                    
        (after-if (make-label 'after-if)))
    (let ((consequent-linkage
           (if (eq? linkage 'next) after-if linkage)))
      (let ((p-code (compile (if-predicate exp) 'val 'next))
            (c-code
             (compile
              (if-consequent exp) target consequent-linkage))
            (a-code
             (compile (if-alternative exp) target linkage)))
        (preserving '(env continue)
         p-code
         (append-instruction-sequences
          (make-instruction-sequence '(val) '()
           `((test (op false?) (reg val))
             (branch (label ,f-branch))))
          (parallel-instruction-sequences
           (append-instruction-sequences t-branch c-code)
           (append-instruction-sequences f-branch a-code))
          after-if))))))
</p>

<p class="orig" lang="en"><tt>Env</tt> is preserved around the predicate code because it could be needed by
the true and false branches, and <tt>continue</tt> is preserved because it could
be needed by the linkage code in those branches.  The code for the true and
false branches (which are not executed sequentially) is appended using a
special combiner <tt>parallel-instruction-sequences</tt> described in
section <a href="#%_sec_5.5.4">5.5.4</a>.</p>

<p class="trans" lang="ja">
述語のコードを囲んで <tt>env</tt> が保全される。なぜなら、<tt>env</tt> は、真の分岐と偽の分岐により必要とされる可能性があるからである。また、<tt>continue</tt> は、これらの分岐でのリンケージ・コードにより必要とされる可能性があるため、保全される。
真の分岐と偽の分岐 (これらは逐次的に実行される訳ではない) についてのコードは、<a href="#%_sec_5.5.4">5.5.4</a>節で説明する <tt>parallel-instruction-sequences</tt> という特別な結合器を使って、つなげられる。
</p>

<p class="orig" lang="en">
Note that <tt>cond</tt> is a derived expression, so all that the
compiler needs to do handle it is to apply the <tt>cond-&gt;if</tt>
transformer (from section <a href="26_sec4_1.html#%_sec_4.1.2">4.1.2</a>) and
compile the resulting <tt>if</tt> expression.</p>

<p class="trans" lang="ja">
<tt>cond</tt> は派生式であり、その結果、<tt>cond</tt> を扱うためにコンパイラがしなくてはならないことは、ただ、(<a href="26_sec4_1.html#%_sec_4.1.2">4.1.2</a>節の) <a href="26_sec4_1.html#%_idx_4370"><tt>cond-&gt;if</tt> 変換器</a>を適用して、その結果できあがる <tt>if</tt> 式をコンパイルすることだけである、ということに注意してほしい。
</p>

<a name="%_sec_Temp_807"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_807">Compiling sequences</a></h4>
<h4 class="trans" lang="ja">列をコンパイルする</h4>

<p class="orig" lang="en"><a name="%_idx_6326"></a>The compilation of sequences (from procedure bodies or explicit <tt>begin</tt> expressions) parallels their evaluation.  Each expression of the
sequence is compiled -- the last expression with the linkage specified
for the sequence, and the other expressions with linkage <tt>next</tt>
(to execute the rest of the sequence).
The instruction sequences for the individual expressions are appended
to form a single instruction sequence, such that <tt>env</tt> (needed for
the rest of the sequence) and <tt>continue</tt> (possibly needed for the
linkage at the end of the sequence) are preserved.</p>

<p class="trans" lang="ja">
(手続き本体または明示的な <tt>begin</tt> 式の) 列のコンパイルは、それらの列の評価と似ている。
列のうちの各式がコンパイルされるのだ——ただし、最後の式は、列に対して指定されたリンケージを用いてコンパイルされ、それ以外の式は、(列の残りの部分を実行するために) <tt>next</tt> というリンケージを用いてコンパイルされる。
個々の式についての命令列同士がつなげられて単一の命令列を形成するが、その際、(列の残りの部分に必要な) <tt>env</tt> と、(もしかすると列の最後のリンケージのために必要な) <tt>continue</tt> が保全されるようにする。
</p>

<p class="lisp"><a name="%_idx_6328"></a>(define (compile-sequence seq target linkage)
  (if (last-exp? seq)
      (compile (first-exp seq) target linkage)
      (preserving '(env continue)
       (compile (first-exp seq) target 'next)
       (compile-sequence (rest-exps seq) target linkage))))
</p>

<a name="%_sec_Temp_808"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_808">Compiling <tt>lambda</tt> expressions</a></h4>
<h4 class="trans" lang="ja"><tt>lambda</tt> 式をコンパイルする</h4>

<p class="orig" lang="en"><a name="%_idx_6330"></a><tt>Lambda</tt> expressions construct procedures.
The object code for a <tt>lambda</tt> expression must have the form</p>

<p class="trans" lang="ja">
<tt>lambda</tt> 式は手続きを構築する。
<tt>lambda</tt> 式に対するオブジェクト・コードは、次の形をとらねばならない。
</p>

<p class="lisp">&lt;<em>construct procedure object and assign it to target register</em>&gt;
&lt;<em>linkage</em>&gt;
</p>

<p class="exercise" lang="ja">&lt;<i class="ex_comment">手続きオブジェクトを構築してそれをターゲット・レジスタに代入する</i>&gt;
&lt;<i class="ex_comment">リンケージ</i>&gt;
</p>

<p class="orig" lang="en">When we compile the <tt>lambda</tt> expression, we also generate the code for the
procedure body.  Although the body won't be executed at the time of procedure
construction, it is convenient to insert it into the object code right after
the code for the <tt>lambda</tt>.  If the linkage for the <tt>lambda</tt> expression
is a label or <tt>return</tt>, this is fine.  But if the linkage is <tt>next</tt>,
we will need to skip around the code for the procedure body by using a linkage
that jumps to a label that is inserted after the body.  The object code thus
has the form</p>

<p class="trans" lang="ja">
<tt>lambda</tt> 式をコンパイルするとき、私たちは、手続き本体に対するコードも生成する。
本体は、手続き構築の時点では実行されないだろうが、<tt>lambda</tt> に対するコードの直後において、それ<span class="note"> (手続き本体に対するコード) </span>をオブジェクト・コードの中へ挿入することは、便利である。
もし <tt>lambda</tt> 式に対するリンケージがラベルか <tt>return</tt> なら、これは申し分ない。
しかし、もしそのリンケージが <tt>next</tt> なら、本体の後に挿入されたラベル<span class="note"> (<tt>after-lambda</tt> と表されている) </span>へとジャンプするリンケージを使って、手続き本体に対するコードを飛ばして避ける必要があるだろう。
よって、オブジェクト・コードは次の形をとる。
</p>

<p class="lisp"> &lt;<em>construct procedure object and assign it to target register</em>&gt;
 &lt;<em>code for given linkage</em>&gt;<em>or</em> <tt>(goto (label after-lambda))</tt>
 &lt;<em>compilation of procedure body</em>&gt;
after-lambda
</p>

<p class="exercise" lang="ja">&lt;<i class="ex_comment">手続きオブジェクトを構築してそれをターゲット・レジスタに代入する</i>&gt;
&lt;<i class="ex_comment">与えられたリンケージに対するコード</i>&gt; <i class="ex_comment">または</i> (goto (label after-lambda))
&lt;<i class="ex_comment">手続き本体をコンパイルしたもの</i>&gt;
after-lambda
</p>

<p class="orig" lang="en">
<tt>Compile-lambda</tt> generates the code for constructing the procedure
object followed by the code for the procedure body.
The procedure object will be constructed at run time by combining
the current environment (the environment at the point of definition)
with the entry point to the compiled procedure body (a newly generated
label).<a name="call_footnote_Temp_809" href="#footnote_Temp_809"><sup><small>38</small></sup></a></p>

<p class="trans" lang="ja">
<tt>compile-lambda</tt> は、手続き本体に対するコード<span class="note"> (<tt>(compile-lambda-body exp proc-entry)</tt> で作られるコード) </span>が後続する、手続きオブジェクトを構築するためのコード<span class="note"> (<tt>(end-with-linkage lambda-linkage ...)</tt> で作られるコード) </span>を、生成する。<!--手続きオブジェクトを構築するためのコードとそれに後続する手続き本体に対するコードを、生成する。-->
実行時に、現在の環境 (定義の時点での環境) を、コンパイルされた手続き本体へのエントリ・ポイント (新たに生成されたラベル)<span class="note"> (<tt>proc-entry</tt>) </span>と結合することによって、手続きオブジェクトが構築されるだろう<a href="#footnote_Temp_809"><sup><small>38</small></sup></a>。
</p>

<p class="lisp"><a name="%_idx_6340"></a>(define (compile-lambda exp target linkage)
  (let ((proc-entry (make-label 'entry))
        (after-lambda (make-label 'after-lambda)))
    (let ((lambda-linkage
           (if (eq? linkage 'next) after-lambda linkage)))
      (append-instruction-sequences
       (tack-on-instruction-sequence
        (end-with-linkage lambda-linkage
         (make-instruction-sequence '(env) (list target)
          `((assign ,target
                    (op make-compiled-procedure)
                    (label ,proc-entry)
                    (reg env)))))
        (compile-lambda-body exp proc-entry))
       after-lambda))))
</p>

<p class="orig" lang="en"><tt>Compile-lambda</tt> uses the special combiner <tt>tack-on-instruction-sequence</tt>
(section <a href="#%_sec_5.5.4">5.5.4</a>) rather than <tt>append-instruction-sequences</tt> to append the procedure body to the <tt>lambda</tt>
expression code, because the body is not part of the sequence of instructions
that will be executed when the combined sequence is entered; rather, it is in
the sequence only because that was a convenient place to put it.</p>

<p class="trans" lang="ja">
<tt>compile-lambda</tt> は、手続き本体を <tt>lambda</tt> 式のコードの後ろにつなげるために、<tt>append-instruction-sequences</tt> ではなくて、むしろ、<tt>tack-on-instruction-sequence</tt> という特別な結合器 (<a href="#%_sec_5.5.4">5.5.4</a>節) を使う。なぜなら、本体は、結合された列がエンターされた<span class="note"> (結合された列のところまで、実行が進んできた) </span>ときに実行されるであろう命令の列の一部ではないからだ。むしろ、本体は、ただ本体を置くのに便利な場所だったから、というだけの理由で、その列の中にあるのだ。
</p>

<p class="orig" lang="en">
<tt>Compile-lambda-body</tt> constructs the code for the body of the
procedure.  This code begins with a label for the entry point.  Next
come instructions that will cause the run-time evaluation environment
to switch to the correct environment for evaluating the procedure
body -- namely, the definition environment of the procedure, extended
to include the bindings of the formal parameters to the arguments with
which the procedure is called.  After this comes the code for the
sequence of expressions that makes up the procedure body.
The sequence is compiled with linkage <tt>return</tt> and target <tt>val</tt>
so that it will end by returning from the procedure with the
procedure result in <tt>val</tt>.</p>

<p class="trans" lang="ja">
<tt>compile-lambda-body</tt> は、手続きの本体に対するコードを構築する。
このコードは、エントリ・ポイント用のラベル<span class="note"> (<tt>proc-entry</tt>) </span>から始まる。
次に、実行時の評価環境を、手続き本体を評価するための正しい環境、つまり、手続きの定義環境——手続きが呼び出されるときの実引数への仮引数の束縛を含むように拡張されたもの——へと、切り替えさせるであろう命令<span class="note"> (二つの <tt>(assign env ...)</tt>)</span> が来る。
これの後に、手続き本体を構成する式の列に対するコード<span class="note"> (<tt>(compile-sequence (lambda-body exp) 'val 'return)</tt> で作られたもの) </span>が来る。
<tt>val</tt> の中に手続き結果がある状態で手続きから返ることで、その<span class="note"> (式の) </span>列が終了するように、その列は、<tt>return</tt> というリンケージおよび <tt>val</tt> というターゲットとともに、コンパイルされる。
</p>

<p class="lisp">(define (compile-lambda-body exp proc-entry)
  (let ((formals (lambda-parameters exp)))
    (append-instruction-sequences
     (make-instruction-sequence '(env proc argl) '(env)
      `(,proc-entry
        (assign env (op compiled-procedure-env) (reg proc))
        (assign env
                (op extend-environment)
                (const ,formals)
                (reg argl)
                (reg env))))
     (compile-sequence (lambda-body exp) 'val 'return))))
</p>

<a name="%_sec_5.5.3"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_5.5.3">5.5.3  Compiling Combinations</a></h3>
<h3 class="trans" lang="ja">5.5.3 コンビネーションをコンパイルする</h3>

<p class="orig" lang="en"><a name="%_idx_6342"></a><a name="%_idx_6344"></a>
The essence of the compilation process is the compilation of procedure
applications.
The code for a combination compiled with a given target and linkage
has the form</p>

<p class="trans" lang="ja">
コンパイル過程の真髄は、手続き適用のコンパイルである。
与えられたターゲットおよびリンケージとともにコンパイルされた、コンビネーションに対するコードは、以下の形をとる。
</p>

<p class="lisp">&lt;<em>compilation of operator, target <tt>proc</tt>, linkage <tt>next</tt></em>&gt;
&lt;<em>evaluate operands and construct argument list in <tt>argl</tt></em>&gt;
&lt;<em>compilation of procedure call with given target and linkage</em>&gt;
</p>

<p class="exercise" lang="ja">&lt;<i class="ex_comment">演算子と、<tt>proc</tt> というターゲットと、<tt>next</tt> というリンケージとをコンパイルしたもの</i>&gt;
&lt;<i class="ex_comment">オペランドを評価して引数リストを <tt>argl</tt> の中に構築する</i>&gt;
&lt;<i class="ex_comment">与えられたターゲットとリンケージを用いた手続き呼び出しをコンパイルしたもの</i>&gt;
</p>

<p class="orig" lang="en">The registers <tt>env</tt>, <tt>proc</tt>, and <tt>argl</tt> may have to be
saved and restored during evaluation of the operator and operands.
Note that this is the only place in the compiler where a target other
than <tt>val</tt> is specified.</p>

<p class="trans" lang="ja">
演算子およびオペランドの評価の間に、<tt>env</tt> と <tt>proc</tt> と <tt>argl</tt> というレジスタを、退避・復旧する必要があるかもしれない。
ここは、コンパイラ内で <tt>val</tt> 以外のターゲットが指定される唯一の場所である、ということに注意してほしい。
</p>

<p class="orig" lang="en">
The required code is generated by <tt>compile-application</tt>.  This
recursively compiles the operator, to produce code that puts the
procedure to be applied into <tt>proc</tt>, and compiles the operands, to
produce code that evaluates the individual operands of the
application.  The instruction sequences for the operands are combined
(by <tt>construct-arglist</tt>) with code that constructs the list of
arguments in <tt>argl</tt>, and the resulting argument-list code is
combined with the procedure code and the code that performs the
procedure call (produced by <tt>compile-procedure-call</tt>).  In
appending the code sequences, the <tt>env</tt> register must be preserved
around the evaluation of the operator (since evaluating the operator
might modify <tt>env</tt>, which will be needed to evaluate the
operands), and the <tt>proc</tt> register must be preserved around the
construction of the argument list (since evaluating the operands might
modify <tt>proc</tt>, which will be needed for the actual procedure
application).  <tt>Continue</tt> must also be preserved throughout, since
it is needed for the linkage in the procedure call.</p>

<p class="trans" lang="ja">
必要なコードは、<tt>compile-application</tt> により生成される。
これは、再帰的に演算子をコンパイルして、適用されるべき手続きを <tt>proc</tt> へ入れるコードを作り出し、また、オペランドをコンパイルして、適用の個々のオペランドを評価するコードを作り出す。
オペランドに対する命令列は、実引数のリストを <tt>argl</tt> の中に構築するコードと (<tt>construct-arglist</tt> によって) 結合され、結果としてできあがる引数リストのコードが、手続きコードおよび手続き呼び出しを行うコード (<tt>compile-procedure-call</tt> により作り出される) と結合される。
コード列をつなげる際には、演算子の評価を囲んで <tt>env</tt> レジスタを保全せねばならないし (なぜなら、演算子を評価することで、<tt>env</tt> を変更するかもしれないが、<tt>env</tt> はオペランドを評価するのに必要になるであろうから)、実引数リストの構築を囲んで <tt>proc</tt> レジスタを保全せねばならない (なぜなら、オペランドを評価することで <tt>proc</tt> を変更するかもしれないが、<tt>proc</tt> は実際の手続き適用に必要になるであろうから)。
<tt>continue</tt> も全体を通じて保全されねばならない。というのも、これは手続き呼び出しでのリンケージに必要になるからである。
</p>

<p class="lisp"><a name="%_idx_6346"></a>(define (compile-application exp target linkage)
  (let ((proc-code (compile (operator exp) 'proc 'next))
        (operand-codes
         (map (lambda (operand) (compile operand 'val 'next))
              (operands exp))))
    (preserving '(env continue)
     proc-code
     (preserving '(proc continue)
      (construct-arglist operand-codes)
      (compile-procedure-call target linkage)))))
</p>

<p class="orig" lang="en">
The code to construct the argument list will evaluate each operand into
<tt>val</tt> and then <tt>cons</tt> that value onto the argument list being
accumulated in <tt>argl</tt>.
Since we <tt>cons</tt> the arguments onto <tt>argl</tt> in sequence, we must
start with the last argument and end with the first, so that the
arguments will appear in order from first to last in the resulting list.
Rather than waste an instruction by initializing <tt>argl</tt> to the empty list
to set up for this sequence of evaluations,
we make the first code sequence construct the initial <tt>argl</tt>.
The general form of the argument-list construction is thus as follows:</p>

<p class="trans" lang="ja">
引数リストを構築するためのコードは、各オペランドを評価して <tt>val</tt> に入れ、それから、その値を、<tt>argl</tt> に蓄積されている途中の引数リストに <tt>cons</tt> するであろう。
逐次的に <tt>argl</tt> に引数を <tt>cons</tt> してゆく訳だから、私たちは、最後の引数から始めて最初の引数で終えなくてはならず、するとその結果、できあがったリストの中では、引数が最初から最後へ、という順序で現れることだろう。
この一連の評価のために準備すべく、<tt>argl</tt> を空リストに初期化することで、命令を無駄遣いする代わりに、私たちはむしろ、最初のコード列に、初期 <tt>argl</tt> を構築させる。
引数リスト構築の一般形式は、したがって、以下のとおりである。
</p>

<p class="lisp">&lt;<em>compilation of last operand, targeted to <tt>val</tt></em>&gt;
(assign argl (op list) (reg val))
&lt;<em>compilation of next operand, targeted to <tt>val</tt></em>&gt;
(assign argl (op cons) (reg val) (reg argl))
<tt>...</tt>&lt;<em>compilation of first operand, targeted to <tt>val</tt></em>&gt;
(assign argl (op cons) (reg val) (reg argl))
</p>

<p class="exercise" lang="ja">&lt;<i class="ex_comment"><tt>val</tt> をターゲットとして、最後のオペランドをコンパイルしたもの</i>&gt;
(assign argl (op list) (reg val))
&lt;<i class="ex_comment"><tt>val</tt> をターゲットとして、次のオペランドをコンパイルしたもの</i>&gt;
(assign argl (op cons) (reg val) (reg argl))
<tt>...</tt>
&lt;<i class="ex_comment"><tt>val</tt> をターゲットとして、最初のオペランドをコンパイルしたもの</i>&gt;
(assign argl (op cons) (reg val) (reg argl))
</p>

<p class="orig" lang="en"><tt>Argl</tt> must be preserved around each operand evaluation except
the first (so that arguments accumulated so far won't be lost), and
<tt>env</tt> must be preserved around each operand evaluation
except the last (for use by subsequent operand evaluations).</p>

<p class="trans" lang="ja">
(これまでのところ蓄積した引数が失われてしまわないように) 最初のものを除く各オペランド評価を囲って <tt>argl</tt> を保全せねばならないし、(後続のオペランド評価で使うために) 最後のものを除く各オペランド評価を囲って <tt>env</tt> を保全せねばならない。
</p>

<p class="orig" lang="en">
Compiling this argument code is a bit tricky, because of
the special treatment of the first operand to be evaluated and the
need to preserve <tt>argl</tt> and <tt>env</tt> in different places.
The <tt>construct-arglist</tt> procedure takes as arguments the code that
evaluates the individual operands.  If there are no operands at all, it simply
emits the instruction</p>

<p class="trans" lang="ja">
この引数コードをコンパイルすることは、評価すべき最初のオペランドの特殊な扱い、および、<tt>artl</tt> と <tt>env</tt> を異なる場所で保全する必要性のせいで、やや技巧を要する<!--手が込んでいる-->。
<tt>construct-arglist</tt> は、引数として、個々のオペランドを評価するコードをとる。
もしオペランドがまったくなければ、<tt>construct-arglist</tt> は、単に以下の命令を発行する。
</p>

<p class="lisp">(assign argl (const ()))
</p>

<p class="orig" lang="en">Otherwise, <tt>construct-arglist</tt> creates code that initializes <tt>argl</tt> with the last argument, and appends code that evaluates
the rest of the arguments and adjoins them to <tt>argl</tt> in
succession.  In order to process the arguments from last to
first, we must reverse the list of operand code sequences from the order
supplied by <tt>compile-application</tt>.</p>

<p class="trans" lang="ja">
それ以外の場合、<tt>construct-arglist</tt> は、<tt>argl</tt> を最後の引数で初期化するコードを作成し、引数の残りのものを評価するコードをつなげ、それらを次々に <tt>argl</tt> に加える。
最後のものから最初のものへと引数を処理するために、私たちは、オペランドのコード列のリストを、<tt>compile-application</tt> から供給された順序から、逆転させねばならない。
</p>

<p class="lisp"><a name="%_idx_6348"></a>(define (construct-arglist operand-codes)
  (let ((operand-codes (reverse operand-codes)))
    (if (null? operand-codes)
        (make-instruction-sequence '() '(argl)
         '((assign argl (const ()))))
        (let ((code-to-get-last-arg
               (append-instruction-sequences
                (car operand-codes)
                (make-instruction-sequence '(val) '(argl)
                 '((assign argl (op list) (reg val)))))))
          (if (null? (cdr operand-codes))
              code-to-get-last-arg
              (preserving '(env)
               code-to-get-last-arg
               (code-to-get-rest-args
                (cdr operand-codes))))))))
(define (code-to-get-rest-args operand-codes)
  (let ((code-for-next-arg
         (preserving '(argl)
          (car operand-codes)
          (make-instruction-sequence '(val argl) '(argl)
           '((assign argl
              (op cons) (reg val) (reg argl)))))))
    (if (null? (cdr operand-codes))
        code-for-next-arg
        (preserving '(env)
         code-for-next-arg
         (code-to-get-rest-args (cdr operand-codes))))))
</p>

<a name="%_sec_Temp_810"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_810">Applying procedures</a></h4>
<h4 class="trans" lang="ja">手続きを適用する</h4>

<p class="orig" lang="en">After evaluating the elements of a combination, the compiled code must
apply the procedure in <tt>proc</tt> to the arguments in <tt>argl</tt>.  The
code performs essentially the same dispatch as the <tt>apply</tt> procedure in the
metacircular evaluator of section <a href="26_sec4_1.html#%_sec_4.1.1">4.1.1</a> or the
<tt>apply-dispatch</tt> entry point in the explicit-control evaluator of
section <a href="34_sec5_4.html#%_sec_5.4.1">5.4.1</a>.  It checks whether the
procedure to be applied is a primitive procedure or a compiled
procedure.  For a primitive procedure, it uses <tt>apply-primitive-procedure</tt>; we will see shortly how it handles
compiled procedures.  The procedure-application code has the following
form:</p>

<p class="trans" lang="ja">
コンビネーションの要素を評価した後、コンパイルされたコードは、<tt>argl</tt> 内の引数に <tt>proc</tt> 内の手続きを適用せねばならない。
そのコードは、<a href="26_sec4_1.html#%_sec_4.1.1">4.1.1</a>節のメタ循環的な評価器における <tt>apply</tt> 手続き、あるいは、<a href="34_sec5_4.html#%_sec_5.4.1">5.4.1</a>節の明示的制御方式の評価器における <tt>apply-dispatch</tt> エントリ・ポイントと、本質的には同じ振り分けを行う。
そのコードは、適用すべき手続きが原始的手続きなのか、それともコンパイルされた手続きなのかを調べる。
原始的手続きに対して、そのコードは、<tt>apply-primitive-procedure</tt> を使う。そのコードが、コンパイルされた手続きをどのように扱うのかについて、手短に見ることにしよう。
手続き適用のコードは、以下の形をしている。
</p>

<p class="lisp"> (test (op primitive-procedure?) (reg proc))
 (branch (label primitive-branch))
compiled-branch
 &lt;<em>code to apply compiled procedure with given target and appropriate linkage</em>&gt;
primitive-branch
 (assign &lt;<em>target</em>&gt;
         (op apply-primitive-procedure)
         (reg proc)
         (reg argl))
 &lt;<em>linkage</em>&gt;
after-call
</p>

<p class="exercise" lang="ja"> (test (op primitive-procedure?) (reg proc))
 (branch (label primitive-branch))
compiled-branch
  &lt;<i class="ex_comment">コンパイルされたコードを、与えられたターゲットと適宜のリンケージを使って適用するためのコード</i>&gt;<span class="note"> (withの係り先について見直すこと)</span>
primitive-branch
 (assign &lt;<i class="ex_comment">ターゲット</i>&gt;
         (op apply-primitive-procedure)
         (reg proc)
         (reg argl))
 &lt;<i class="ex_comment">リンケージ</i>&gt;
after-call
</p>

<p class="orig" lang="en">Observe that the compiled branch must skip around the primitive
branch.  Therefore, if the linkage for the original procedure call was
<tt>next</tt>, the compound branch must use a linkage that jumps to a
label that is inserted after the primitive branch.  (This is similar
to the linkage used for the true branch in <tt>compile-if</tt>.)</p>

<p class="trans" lang="ja">
コンパイルされた方の分岐は、プリミティブの方の分岐を避けるように飛ばさなくてはならない。
よって、もし元の手続き呼び出しに対するリンケージが <tt>next</tt> だったなら、複合式の方の分岐は、プリミティブの方の分岐の後に挿入されたラベルへとジャンプするリンケージを使わなくてはならない
(これは、<tt>compile-if</tt> における真の分岐に対して使ったリンケージに似ている)。
</p>

<p class="lisp"><a name="%_idx_6350"></a>(define (compile-procedure-call target linkage)
  (let ((primitive-branch (make-label 'primitive-branch))
        (compiled-branch (make-label 'compiled-branch))
        (after-call (make-label 'after-call)))
    (let ((compiled-linkage
           (if (eq? linkage 'next) after-call linkage)))
      (append-instruction-sequences
       (make-instruction-sequence '(proc) '()
        `((test (op primitive-procedure?) (reg proc))
          (branch (label ,primitive-branch))))
       (parallel-instruction-sequences
        (append-instruction-sequences
         compiled-branch
         (compile-proc-appl target compiled-linkage))
        (append-instruction-sequences
         primitive-branch
         (end-with-linkage linkage
          (make-instruction-sequence '(proc argl)
                                     (list target)
           `((assign ,target
                     (op apply-primitive-procedure)
                     (reg proc)
                     (reg argl)))))))
       after-call))))
</p>

<p class="orig" lang="en">The primitive and compound branches, like the true
and false branches in <tt>compile-if</tt>, are appended using
<tt>parallel-instruction-sequences</tt> rather than the ordinary <tt>append-instruction-sequences</tt>, because they will
not be executed sequentially.</p>

<p class="trans" lang="ja">
プリミティブの方の分岐と複合式の方の分岐は、<tt>compile-if</tt> における真の分岐と偽の分岐と同様に、通常の  <tt>append-instruction-sequences</tt> ではなくてむしろ <tt>parallel-instruction-sequences</tt> を用いてつなげられる。なぜなら、両分岐は逐次的に実行されるものではないからである。
</p>

<a name="%_sec_Temp_811"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_811">Applying compiled procedures</a></h4>
<h4 class="trans" lang="ja">コンパイル済みの手続きを適用する</h4>


<p class="orig" lang="en">The code that handles procedure application is the most subtle part of
the compiler, even though the instruction sequences it generates are
very short.  A compiled procedure (as constructed by <tt>compile-lambda</tt>) has an entry point, which is a label that designates
where the code for the procedure starts.  The code at this entry point
computes a result in <tt>val</tt> and returns by executing the
instruction <tt>(goto (reg continue))</tt>.  Thus, we might expect the
code for a compiled-procedure application (to be generated by <tt>compile-proc-appl</tt>) with a given target and linkage to look like this
if the linkage is a label
</p>

<p class="trans" lang="ja">
手続き適用を扱うコードは、たとえコンパイラが生成する命令列が非常に短くてさえも、コンパイラのうちで最も微妙な部分である。
コンパイルされた手続き (<tt>compile-lambda</tt> により構築されたとおりのもの) にはエントリ・ポイントがあるが、このエントリ・ポイントは、手続きに対するコードがどこから始まるのかを指定するラベルである。
このエントリ・ポイントにあるコードは、<tt>val</tt> の中に結果を計算して入れ、<tt>(goto (reg continue))</tt> という命令を実行することにより返る。
よって、与えられたターゲットとリンケージをともなった、コンパイルされた手続きの適用についての (<tt>compile-proc-appl</tt> により生成されるはずの) コードが、そのリンケージがラベルである場合には次のように見える、と私たちは期待するかもしれない。
</p>

<p class="lisp"> (assign continue (label proc-return))
 (assign val (op compiled-procedure-entry) (reg proc))
 (goto (reg val))
proc-return
 (assign &lt;<em>target</em>&gt; (reg val))   <em>; included if target is not <tt>val</tt></em>
 (goto (label &lt;<em>linkage</em>&gt;))   <em>; linkage code</em>
</p>

<p class="orig" lang="en">or like this if the linkage is <tt>return</tt>.
</p>

<p class="trans" lang="ja">
あるいは、そのリンケージが <tt>return</tt> である場合には次のように見える、と期待するかもしれない。
</p>

<p class="lisp"> (save continue)
 (assign continue (label proc-return))
 (assign val (op compiled-procedure-entry) (reg proc))
 (goto (reg val))
proc-return
 (assign &lt;<em>target</em>&gt; (reg val))   <em>; included if target is not <tt>val</tt></em>
 (restore continue)
 (goto (reg continue))   <em>; linkage code</em>
</p>

<!--
<p class="exercise" lang="ja">
&lt;<i class="ex_comment"></i>&gt;
&lt;<i class="ex_comment"></i>&gt;
&lt;<i class="ex_comment"></i>&gt;
&lt;<i class="ex_comment"></i>&gt;
&lt;<i class="ex_comment"></i>&gt;
</p>
-->

<p class="orig" lang="en">This code sets up <tt>continue</tt> so that the procedure will return to a
label <tt>proc-return</tt> and jumps to the procedure's entry point.  The code
at <tt>proc-return</tt> transfers the procedure's result from <tt>val</tt>
to the target register (if necessary) and then jumps to
the location specified by the linkage.
(The linkage is always <tt>return</tt> or a label, because <tt>compile-procedure-call</tt> replaces a <tt>next</tt> linkage for the
compound-procedure branch by an <tt>after-call</tt> label.)</p>

<p class="trans" lang="ja">
このコードは、手続きが <tt>proc-return</tt> というラベルへと返り、それからその手続きのエントリ・ポイントへとジャンプするように、<tt>continue</tt> を設定する。
<tt>proc-return</tt> にあるコードは、(もし必要なら) 手続きの結果を <tt>val</tt> からターゲット・レジスタへと転送し、それから、リンケージにより指定された場所へとジャンプする
(リンケージは常に <tt>return</tt> またはラベルである。なぜなら、複合的な手続きの分岐に対する <tt>next</tt> リンケージを、<tt>compile-procedure-call</tt> が <tt>after-call</tt> ラベルで置き換えるからである)。
</p>

<p class="orig" lang="en">
In fact, if the target is not <tt>val</tt>, that is exactly the code our
compiler will generate.<a name="call_footnote_Temp_812" href="#footnote_Temp_812"><sup><small>39</small></sup></a>
Usually, however, the target is <tt>val</tt> (the only time the compiler
specifies a different register is when targeting the evaluation of an
operator to <tt>proc</tt>), so the procedure result is put directly into
the target register and there is no need to return to a special
location that copies it.  Instead, we simplify the code by
setting up <tt>continue</tt> so that the procedure will ``return''
directly to the place specified by the caller's linkage:
</p>

<p class="trans" lang="ja">
実際、もしターゲットが <tt>val</tt> でなければ、それこそまさに、私たちのコンパイラが生成するであろうコードである<a href="#footnote_Temp_812"><sup><small>39</small></sup></a>。
しかし、普通、ターゲットは <tt>val</tt> である (コンパイラが別のレジスタを指定する唯一の場合は、演算子の評価のターゲットを <tt>proc</tt> にするときなのだ) し、それゆえ、手続きの結果は直接ターゲット・レジスタに入れられ、その手続き結果を複製する特別な場所へ返る必要などない。
その代わりに、呼び出し側のリンケージにより指定される場所へ手続きが直接「返る」ように、<tt>continue</tt> を設定することによって、私たちは、コードを単純化する。
</p>

<p class="lisp">&lt;<em>set up <tt>continue</tt> for linkage</em>&gt;
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
</p>

<p class="orig" lang="en">If the linkage is a label, we set up <tt>continue</tt> so that the procedure will return to
that label.  (That is, the <tt>(goto (reg continue))</tt> the procedure
ends with becomes equivalent to the <tt>(goto (label &lt;<em>linkage</em>&gt;))</tt> at
<tt>proc-return</tt> above.)</p>

<p class="trans" lang="ja">
リンケージがラベルのときは、手続きがそのラベルへ返るように <tt>continue</tt> を設定する
(つまり、手続きがそこで終わる <tt>(goto (reg continue))</tt> は、上記の <tt>proc-return</tt> にある <tt>(goto (label &lt;<em class="en">linkage</em>&gt;))</tt> と等価になる)。
</p>

<p class="lisp">(assign continue (label &lt;<em>linkage</em>&gt;))
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
</p>

<p class="orig" lang="en">If the linkage is <tt>return</tt>, we don't need to set up <tt>continue</tt>
at all: It already holds the desired location.  (That is, the <tt>(goto (reg continue))</tt> the procedure ends with goes directly to the
place where the <tt>(goto (reg continue))</tt> at <tt>proc-return</tt> would
have gone.)
</p>

<p class="trans" lang="ja">
リンケージが <tt>return</tt> のときは、<tt>continue</tt> を設定する必要がまったくない。<tt>continue</tt> は既に所望の場所を保持しているのだ (つまり、手続きがそこで終わる <tt>(goto (reg continue))</tt> は、<tt>proc-return</tt> にある <tt>(goto (reg continue))</tt> ならそこへ行ったであろう場所へと、直接行くのである)。
</p>

<p class="lisp">(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
</p>

<p class="orig" lang="en"><a name="%_idx_6352"></a><a name="%_idx_6354"></a>With this implementation of the <tt>return</tt> linkage, the compiler
generates tail-recursive code.  Calling a procedure as the final step
in a procedure body does a direct transfer, without saving any
information on the stack.</p>

<p class="trans" lang="ja">
<tt>return</tt> リンケージのこの実装を使って、コンパイラは末尾再帰的なコードを生成する。
手続き本体の中での最後のステップとして手続きを呼び出すことは、何の情報もスタック上に退避することなしに、直接の転送を行うのである。
</p>

<p class="orig" lang="en">
Suppose instead that we had handled the case of a procedure call with
a linkage of <tt>return</tt> and a target of <tt>val</tt> as shown above for
a non-<tt>val</tt> target.  This would destroy tail recursion.  Our
system would still give the same value for any expression.  But each
time we called a procedure, we would save <tt>continue</tt> and return
after the call to undo the (useless) save.  These extra saves would
accumulate during a nest of procedure calls.<a name="call_footnote_Temp_813" href="#footnote_Temp_813"><sup><small>40</small></sup></a></p>

<p class="trans" lang="ja">
そうする代わりに、私たちが、 <tt>return</tt> というリンケージと <tt>val</tt> というターゲットをともなう手続き適用の場合を、<tt>val</tt> でないターゲットに対して上述したようにして取り扱ったのだ、と仮定しよう。<span class="note">(← as 以下の係り先がちょっと自信がないが、多分こう?)</span>
これは末尾再帰を破壊するだろう。
任意の式に対して、私たちのシステムは、依然として同じ値を与えるであろう。
しかし、手続きを呼び出すたびに、<tt>continue</tt> を退避することになるだろうし、(無用の) 退避を帳消しにするための呼び出しの後に、戻ることになるだろう。
手続き呼び出しの入れ子の間、この余計な退避は蓄積していくだろう<a href="#footnote_Temp_813"><sup><small>40</small></sup></a>。
</p>

<p class="orig" lang="en">
<tt>Compile-proc-appl</tt> generates the above procedure-application code by
considering four cases, depending on whether the target for the call
is <tt>val</tt> and whether the linkage is <tt>return</tt>.
Observe that the instruction sequences are
declared to modify all the registers, since executing the procedure
body can change the registers in arbitrary ways.<a name="call_footnote_Temp_814" href="#footnote_Temp_814"><sup><small>41</small></sup></a>
Also note that the code sequence for the case with target <tt>val</tt>
and linkage <tt>return</tt> is declared to need <tt>continue</tt>:  Even
though <tt>continue</tt> is not explicitly used in the two-instruction
sequence, we must be sure that <tt>continue</tt> will have the correct
value when we enter the compiled procedure.</p>

<p class="trans" lang="ja">
<tt>compile-proc-appl</tt> は、四つの場合を考慮することで——つまり、呼出しに対するターゲットが <tt>val</tt> かどうかと、リンケージが <tt>return</tt> かどうかによって——上記の手続き適用のコードを生成する。
手続き本体を実行することにより、任意の仕方でレジスタを変更してしまう可能性があるため、すべてのレジスタを変更するように命令列が宣言される、ということに気づいてほしい<a href="#footnote_Temp_814"><sup><small>41</small></sup></a>。
さらにまた、
<tt>val</tt> というターゲットと <tt>return</tt> というリンケージをともなう場合についてのコード列が、<tt>continue</tt> を必要とするように宣言されていることにも、注意してほしい。
2個の命令からなる列の中では <tt>continue</tt> が明示的には使われていなくてさえも、私たちは、コンパイルされた手続きに入るときには <tt>continue</tt> が正しい値を持っているだろう、と確信しているに違いない。
</p>


<p class="lisp"><a name="%_idx_6376"></a>(define (compile-proc-appl target linkage)
  (cond ((and (eq? target 'val) (not (eq? linkage 'return)))
         (make-instruction-sequence '(proc) all-regs
           `((assign continue (label ,linkage))
             (assign val (op compiled-procedure-entry)
                         (reg proc))
             (goto (reg val)))))
        ((and (not (eq? target 'val))
              (not (eq? linkage 'return)))
         (let ((proc-return (make-label 'proc-return)))
           (make-instruction-sequence '(proc) all-regs
            `((assign continue (label ,proc-return))
              (assign val (op compiled-procedure-entry)
                          (reg proc))
              (goto (reg val))
              ,proc-return
              (assign ,target (reg val))
              (goto (label ,linkage))))))
        ((and (eq? target 'val) (eq? linkage 'return))
         (make-instruction-sequence '(proc continue) all-regs
          '((assign val (op compiled-procedure-entry)
                        (reg proc))
            (goto (reg val)))))
        ((and (not (eq? target 'val)) (eq? linkage 'return))
         (error &quot;return linkage, target not val -- COMPILE&quot;
                target))))
</p>


<a name="%_sec_5.5.4"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_5.5.4">5.5.4  Combining Instruction Sequences</a></h3>
<h3 class="trans" lang="ja">5.5.4 命令列を結合する</h3>


<p class="orig" lang="en"><a name="%_idx_6378"></a>
This section describes the details on how instruction sequences are
represented and combined.  Recall from
section <a href="#%_sec_5.5.1">5.5.1</a> that an instruction sequence
is represented as a list of the registers needed, the registers
modified, and the actual instructions.  We will also consider a label
(symbol) to be a degenerate case of an instruction sequence, which doesn't
need or modify any registers.
So to determine the registers needed
and modified by instruction sequences we use the selectors
</p>

<p class="trans" lang="ja">
本節では、どのように命令列を表現し、結合するのか、ということを説明する。
必要なレジスタと、変更されるレジスタと、実際の命令とからなるリストとして、命令列が表現される、ということを<a href="#%_sec_5.5.1">5.5.1</a>節から思い出そう。
また、ラベル (記号) を、命令列の縮退した場合——何のレジスタも必要とせず、何のレジスタも変更しないもの——と見なそう。
よって、命令列により必要とされるレジスタと変更されるレジスタとを特定するには、次のセレクタを使い、
</p>

<p class="lisp"><a name="%_idx_6380"></a>(define (registers-needed s)
  (if (symbol? s) '() (car s)))
<a name="%_idx_6382"></a>(define (registers-modified s)
  (if (symbol? s) '() (cadr s)))
<a name="%_idx_6384"></a>(define (statements s)
  (if (symbol? s) (list s) (caddr s)))
</p>

<p class="orig" lang="en">and to determine whether a given
sequence needs or modifies a given register we use the predicates
</p>

<p class="trans" lang="ja">
与えられた列が与えられたレジスタを必要とするか否か、あるいは変更するか否かを特定するには、次の述語を使う。
</p>

<p class="lisp"><a name="%_idx_6386"></a>(define (needs-register? seq reg)
  (memq reg (registers-needed seq)))
<a name="%_idx_6388"></a>(define (modifies-register? seq reg)
  (memq reg (registers-modified seq)))
</p>

<p class="orig" lang="en">In terms of these predicates and selectors, we can implement the
various instruction sequence combiners used throughout the compiler.</p>

<p class="trans" lang="ja">
これらの述語とセレクタを用いると、コンパイラの全体を通じて使われる様々な命令列結合器を実装できる。
</p>

<p class="orig" lang="en">
The basic combiner is <tt>append-instruction-sequences</tt>.  This takes as
arguments an arbitrary number of instruction sequences that are to be executed
sequentially and returns an instruction sequence whose statements are the
statements of all the sequences appended together.  The subtle point is to
determine the registers that are needed and modified by the resulting
sequence.  It modifies those registers that are modified by any of the
sequences; it needs those registers that must be initialized before the first
sequence can be run (the registers needed by the first sequence), together
with those registers needed by any of the other sequences that are not
initialized (modified) by sequences preceding it.</p>

<p class="trans" lang="ja">
基本的な結合器は <tt>append-instruction-sequences</tt> だ。
これは、逐次的に実行されるべき任意の個数の命令列を引数としてとり、そして、一つにつなげられた、すべての列の<ruby><rb>文</rb><rp> (</rp><rt>ステートメント</rt><rp>) </rp></ruby>をその文とするような、一つの命令列を返す。
<!-- すべての列の<ruby><rb>文</rb><rp> (</rp><rt>ステートメント</rt><rp>) </rp></ruby>をひとまとまりにつなげたもの -->
<!-- その<ruby><rb>文</rb><rp> (</rp><rt>ステートメント</rt><rp>) </rp></ruby>が、すべての列の文を一つにつなげたものであるような、-->
巧妙な点は、結果としてできあがる列によって必要とされたり変更されたりするレジスタを特定することである。
それ<span class="note"> (結果としてできあがる列) </span>は、列のうちのどれかによって変更されるレジスタを、変更する。それは、最初の列が実行され得るときよりも前に初期化されねばならないレジスタ (最初の列により必要とされるレジスタ) を、必要とするとともに、残りの列のどれかにより必要とされるレジスタであって、当該の列に先行する列によっては初期化される (変更される) ことのないものをも、必要とする。
</p>

<p class="orig" lang="en">
The sequences are appended two at a time by <tt>append-2-sequences</tt>.  This
takes two instruction sequences <tt>seq1</tt> and <tt>seq2</tt> and returns the
instruction sequence whose statements are the statements of <tt>seq1</tt>
followed by the statements of <tt>seq2</tt>, whose modified registers are those
registers that are modified by either <tt>seq1</tt> or <tt>seq2</tt>, and whose
needed registers are the registers needed by <tt>seq1</tt> together with those
registers needed by <tt>seq2</tt> that are not modified by <tt>seq1</tt>.  (In terms
of set operations, the new set of needed registers is the union of the set of
registers needed by <tt>seq1</tt> with the set difference of the registers needed
by <tt>seq2</tt> and the registers modified by <tt>seq1</tt>.)  Thus, <tt>append-instruction-sequences</tt> is implemented as follows:</p>

<p class="trans" lang="ja">
列同士は、<tt>append-2-sequences</tt> によって、一度に二つずつ、つなげられる。
これ<span class="note"> (<tt>append-2-sequences</tt>) </span>は、<tt>seq1</tt> および <tt>seq2</tt> という二つの命令列をとる。そして、<tt>seq1</tt> の文の後に <tt>seq2</tt> の文が続いたものをその文とし、かつ、<tt>seq1</tt> か <tt>seq2</tt> のいずれかによって変更されるレジスタを、その変更されるレジスタとし、かつ、<tt>seq1</tt> により必要とされるレジスタ、および、<tt>seq1</tt> によっては変更されない、<tt>seq2</tt> によって必要とされるレジスタを、その必要なレジスタとするような、命令列を返す
(集合演算の観点からは、必要なレジスタの新規集合とは、<tt>seq1</tt> により必要とされるレジスタの集合と、<tt>seq2</tt> により必要とされるレジスタと <tt>seq1</tt> により変更されるレジスタとの集合差分との、和集合である)。
よって、<tt>append-2-sequences</tt> は次のように実装される。
</p>

<p class="lisp"><a name="%_idx_6390"></a>(define (append-instruction-sequences . seqs)
  (define (append-2-sequences seq1 seq2)
    (make-instruction-sequence
     (list-union (registers-needed seq1)
                 (list-difference (registers-needed seq2)
                                  (registers-modified seq1)))
     (list-union (registers-modified seq1)
                 (registers-modified seq2))
     (append (statements seq1) (statements seq2))))
  (define (append-seq-list seqs)
    (if (null? seqs)
        (empty-instruction-sequence)
        (append-2-sequences (car seqs)
                            (append-seq-list (cdr seqs)))))
  (append-seq-list seqs))
</p>

<p class="orig" lang="en">
This procedure uses some simple operations for manipulating sets
represented as lists, similar to the (unordered) set representation
described in section <a href="16_sec2_3.html#%_sec_2.3.3">2.3.3</a>:
</p>

<p class="trans" lang="ja">
この手続きは、リストとして表現された集合——<a href="16_sec2_3.html#%_sec_2.3.3">2.3.3</a>節で説明した (順序づけられていない) 集合表現に似ている——を操作するための、いくつかの単純な演算を利用する。
</p>

<p class="lisp"><a name="%_idx_6392"></a>(define (list-union s1 s2)
  (cond ((null? s1) s2)
        ((memq (car s1) s2) (list-union (cdr s1) s2))
        (else (cons (car s1) (list-union (cdr s1) s2)))))
<a name="%_idx_6394"></a>(define (list-difference s1 s2)
  (cond ((null? s1) '())
        ((memq (car s1) s2) (list-difference (cdr s1) s2))
        (else (cons (car s1)
                    (list-difference (cdr s1) s2)))))
</p>

<p class="orig" lang="en">
<tt>Preserving</tt>, the second major instruction sequence combiner, takes a list
of registers <tt>regs</tt> and two instruction sequences <tt>seq1</tt> and <tt>seq2</tt> that are to be executed sequentially.  It returns an instruction
sequence whose statements are the statements of <tt>seq1</tt> followed by the
statements of <tt>seq2</tt>, with appropriate <tt>save</tt> and <tt>restore</tt>
instructions around <tt>seq1</tt> to protect the registers in <tt>regs</tt> that are
modified by <tt>seq1</tt> but needed by <tt>seq2</tt>.  To accomplish this, <tt>preserving</tt> first creates a sequence that has the required <tt>save</tt>s
followed by the statements of <tt>seq1</tt> followed by the required <tt>restore</tt>s.  This sequence needs the registers being saved and restored in
addition to the registers needed by <tt>seq1</tt>, and modifies the registers
modified by <tt>seq1</tt> except for the ones being saved and restored.  This
augmented sequence and <tt>seq2</tt> are then appended in the usual way.  The
following procedure implements this strategy recursively, walking down the
list of registers to be preserved:<a name="call_footnote_Temp_815" href="#footnote_Temp_815"><sup><small>42</small></sup></a>
</p>

<p class="trans" lang="ja">
<tt>preserving</tt> ——すなわち、第二の重要な命令列結合器——は、<tt>regs</tt> というレジスタのリストと、逐次的に実行されるべき、<tt>seq1</tt> および <tt>seq2</tt> という二つの命令列とをとる。
これは、<tt>seq1</tt> の文の後に <tt>seq2</tt> の文が続いたものをその文とする命令列—— <tt>seq1</tt> により変更されるが <tt>seq2</tt> により必要とされるような、<tt>regs</tt> 中のレジスタを保全するための、<tt>seq1</tt> のまわりでの適宜の <tt>save</tt> 命令と <tt>restore</tt> 命令とをともなう——を返す。
これを達成するために、<tt>preserving</tt> はまず、必要な <tt>save</tt> と、その後に続く <tt>seq1</tt> の文と、その後に続く必要な <tt>restore</tt> とを有する列を、作成する。
この列は、<tt>seq1</tt> により必要とされる列に加えて、退避・復旧されるレジスタを必要とし、退避・復旧されるものを除いた、<tt>seq1</tt> により変更されるレジスタを、変更する。
その後、この拡張された列と、<tt>seq2</tt> とが、通常の方法でつなげられる。
以下の手続きは、この戦略を——保全されるべきレジスタのリストをたどりつつ——再帰的に実装している<a href="#footnote_Temp_815"><sup><small>42</small></sup></a>。
</p>

<p class="lisp"><a name="%_idx_6398"></a>(define (preserving regs seq1 seq2)
  (if (null? regs)
      (append-instruction-sequences seq1 seq2)
      (let ((first-reg (car regs)))
        (if (and (needs-register? seq2 first-reg)
                 (modifies-register? seq1 first-reg))
            (preserving (cdr regs)
             (make-instruction-sequence
              (list-union (list first-reg)
                          (registers-needed seq1))
              (list-difference (registers-modified seq1)
                               (list first-reg))
              (append `((save ,first-reg))
                      (statements seq1)
                      `((restore ,first-reg))))
             seq2)
            (preserving (cdr regs) seq1 seq2)))))
</p>

<p class="orig" lang="en">
Another sequence combiner, <tt>tack-on-instruction-sequence</tt>,
is used by <tt>compile-lambda</tt> to append a procedure body to another
sequence.  Because the procedure body is not ``in line'' to be
executed as part of the combined sequence, its register use has no
impact on the register use of the sequence in which it is embedded.
We thus ignore the procedure body's sets of needed and modified
registers when we tack it onto the other sequence.</p>

<p class="trans" lang="ja">
もう一つの列結合器、すなわち <tt>tack-on-instruction-sequence</tt> は、手続き本体を他の列につなげるために、<tt>compile-lambda</tt> により用いられる。
手続き本体は、結合された列の一部として実行されるべく「インラインに」なっている訳ではないので、手続き本体のレジスタ使用は、その手続き本体が埋め込まれる列のレジスタ使用に対しては何の影響も与えない。
よって、手続き本体を上記の他の列に接合する際には、手続き本体の、必要なレジスタの集合および変更されるレジスタの集合を、無視する。
</p>

<p class="lisp"><a name="%_idx_6400"></a>(define (tack-on-instruction-sequence seq body-seq)
  (make-instruction-sequence
   (registers-needed seq)
   (registers-modified seq)
   (append (statements seq) (statements body-seq))))
</p>

<p class="orig" lang="en">
<tt>Compile-if</tt> and <tt>compile-procedure-call</tt> use a special
combiner called <tt>parallel-instruction-sequences</tt> to append the two
alternative branches that follow a test.  The two branches will never be
executed sequentially; for any particular evaluation of the test, one
branch or the other will be entered.  Because of this, the registers
needed by the second branch are still needed by the combined sequence,
even if these are modified by the first branch.</p>

<p class="trans" lang="ja">
<tt>compile-if</tt> と <tt>compile-procedure-call</tt> は、検査に続く二つの選択肢たる分岐同士をつなげるために、<tt>parallel-instruction-sequences</tt> と呼ばれる特別な結合器を使う。
二つの分岐は、決して逐次的に実行されないだろう。検査のいかなる特定の評価に対しても、一方の分岐または他方の分岐へと入るだろう。
このため、二番目の分岐により必要とされるレジスタは、仮に一番目の分岐によって変更されるのだとしても、依然として、結合された列によっても必要とされるのだ。
</p>

<p class="lisp"><a name="%_idx_6402"></a>(define (parallel-instruction-sequences seq1 seq2)
  (make-instruction-sequence
   (list-union (registers-needed seq1)
               (registers-needed seq2))
   (list-union (registers-modified seq1)
               (registers-modified seq2))
   (append (statements seq1) (statements seq2))))
</p>

<a name="%_sec_5.5.5"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_5.5.5">5.5.5  An Example of Compiled Code</a></h3>
<h3 class="trans" lang="ja">5.5.5 コンパイル済みのコードの例</h3>


<p class="orig" lang="en"><a name="%_idx_6404"></a><a name="%_idx_6406"></a>
Now that we have seen all the elements of the compiler, let us examine
an example of compiled code to see how things fit together.  We will
compile the definition of a recursive <tt>factorial</tt> procedure by
calling <tt>compile</tt>:</p>

<p class="trans" lang="ja">
今や私たちはコンパイラの全要素を見たわけだから、コンパイル済みのコードの例を吟味して、ものごとがどのように組み合わさるのかを見てみよう。
<tt>compile</tt> を呼び出すことによって、再帰的な <tt>factorial</tt> 手続きの定義をコンパイルしよう。
</p>

<p class="lisp">(compile
 '(define (factorial n)
    (if (= n 1)
        1
        (* (factorial (- n 1)) n)))
 'val
 'next)
</p>

<p class="orig" lang="en">We have specified that the value of the <tt>define</tt> expression should
be placed in the <tt>val</tt> register.  We don't care what the compiled
code does after executing the <tt>define</tt>, so our choice of <tt>next</tt> as the linkage descriptor is arbitrary.</p>

<p class="trans" lang="ja">
<tt>define</tt> 式の値が <tt>val</tt> レジスタに置かれるべきだ、と私たちは指定した。
コンパイル済みのコードが、<tt>define</tt> を実行した後に何をするのか、という点について、私たちは気にしないので、リンケージ記述子として <tt>next</tt> を選択したことは、任意的なものである。
</p>

<p class="orig" lang="en">
<tt>Compile</tt> determines that the expression is a definition, so it calls <tt>compile-definition</tt> to compile code to compute the value to be assigned
(targeted to <tt>val</tt>), followed by code to install the definition, followed
by code to put the value of the <tt>define</tt> (which is the symbol <tt>ok</tt>)
into the target register, followed finally by the linkage code.  <tt>Env</tt> is
preserved around the computation of the value, because it is needed in order
to install the definition.  Because the linkage is <tt>next</tt>, there is no
linkage code in this case.  The skeleton of the compiled code is thus</p>

<p class="trans" lang="ja">
<tt>compile</tt> は、この式が定義であることを特定し、それゆえ、<tt>compile-definition</tt> を呼び出して、<ruby><rb>代入される</rb><rp> (</rp><rt>わりあてられる</rt><rp>) </rp></ruby>べき (<tt>val</tt> をターゲットとした) 値を計算するためのコードと、それに続く、当該定義を組み込むためのコードと、それに続く、<tt>define</tt> の値 (<tt>ok</tt> という記号である) をターゲット・レジスタに入れるためのコードと、それに続く最後のリンケージ・コードとを、コンパイルする。
<tt>env</tt> は、値の計算のまわりで保全される。なぜなら、定義を組み込むために <tt>env</tt> が必要だからである。
リンケージが <tt>next</tt> であるため、この場合はリンケージ・コードがない。
よって、コンパイル済みコードの骨格は、以下のようになる。
</p>

<p class="lisp">  &lt;<em>save <tt>env</tt> if modified by code to compute value</em>&gt;
  &lt;<em>compilation of definition value, target <tt>val</tt>, linkage <tt>next</tt></em>&gt;
  &lt;<em>restore <tt>env</tt> if saved above</em>&gt;
  (perform (op define-variable!)
           (const factorial)
           (reg val)
           (reg env))
  (assign val (const ok))
</p>

<p class="exercise" lang="ja">  &lt;<i class="ex_comment">もし、値を計算するためのコードによって変更されるならば、<tt>env</tt> を退避する</i>&gt;
  &lt;<i class="ex_comment">定義の値と、<tt>val</tt> というターゲットと、<tt>next</tt> というリンケージについて、コンパイルしたもの</i>&gt;
  &lt;<i class="ex_comment">上で退避される場合には、<tt>env</tt> を復旧する</i>&gt;
  (perform (op define-variable!)
           (const factorial)
           (reg val)
           (reg env))
  (assign val (const ok))
</p>


<p class="orig" lang="en">
The expression that is to be compiled to produce the value for the
variable <tt>factorial</tt> is a <tt>lambda</tt> expression whose value is
the procedure that computes factorials.  <tt>Compile</tt> handles this by
calling <tt>compile-lambda</tt>, which compiles the procedure body,
labels it as a new entry point, and generates the instruction that
will combine the procedure body at the new entry point with the
run-time environment and assign the result to <tt>val</tt>.  The sequence
then skips around the compiled procedure code, which is inserted at
this point.  The procedure code itself begins by extending the
procedure's definition environment by a frame that binds
the formal parameter <tt>n</tt> to the procedure argument.  Then comes the actual
procedure body.  Since this code for the value of the variable
doesn't modify the <tt>env</tt> register, the optional <tt>save</tt>
and <tt>restore</tt> shown above aren't generated.  (The procedure code at
<tt>entry2</tt> isn't executed at this point, so its use of <tt>env</tt>
is irrelevant.)
Therefore, the skeleton for the compiled code becomes</p>

<p class="trans" lang="ja">
<tt>factorial</tt> という変数についての値を作り出すためにコンパイルされるべき式は、階乗を計算する手続きを値とする <tt>lambda</tt> 式である。
<tt>compile</tt> はこれを、<tt>compile-lambda</tt> ——手続き本体をコンパイルする——を呼び出すことによって扱い、それを新たなエントリ・ポイントとしてラベルづけし、そのエントリ・ポイントにある手続き本体を実行時の環境に結合して結果を <tt>val</tt> に割り当てるであろう命令を生成する。
<span class="note">(which の範囲について一応見直した方がよいかもしれない)</span>
その後、この<ruby><rb>一連の流れ</rb><rp> (</rp><rt>シーケンス</rt><rp>) </rp></ruby>はコンパイル済みの手続きコード——このポイントに挿入されている——を避けて飛ばす。
手続きコード自体は、<tt>n</tt> という仮引数を手続き実引数に束縛するフレームによって手続きの定義環境を拡張することから、始まる。
それから、実際の手続き本体がくる。
変数の値に対するこのコードは <tt>env</tt> レジスタを変更しないため、上記で示したオプショナルな <tt>save</tt> と <tt>restore</tt> は生成されない
(<tt>entry2</tt> にある手続きコードは、この箇所では実行されないので、この手続きコードによる <tt>env</tt> の使用は無関係である)。
したがって、コンパイル済みコードについての骨格は、次のようになる。
</p>

<p class="lisp">  (assign val (op make-compiled-procedure)
              (label entry2)
              (reg env))
  (goto (label after-lambda1))
entry2
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env (op extend-environment)
              (const (n))
              (reg argl)
              (reg env))
  &lt;<em>compilation of procedure body</em>&gt;
after-lambda1
  (perform (op define-variable!)
           (const factorial)
           (reg val)
           (reg env))
  (assign val (const ok))
</p>

<p class="orig" lang="en">
A procedure body is always compiled (by <tt>compile-lambda-body</tt>) as
a sequence with target <tt>val</tt> and linkage <tt>return</tt>.  The
sequence in this case consists of a single <tt>if</tt> expression:</p>

<p class="trans" lang="ja">
手続き本体は常に、<tt>val</tt> というターゲットと <tt>return</tt> というリンケージを有する列として、(<tt>compile-lambda-body</tt> によって) コンパイルされる。
この場合における列は、次のような一つの <tt>if</tt> 式からなる。
</p>

<p class="lisp">(if (= n 1)
    1
    (* (factorial (- n 1)) n))
</p>

<p class="orig" lang="en"><tt>Compile-if</tt> generates code that first computes the predicate (targeted to
<tt>val</tt>), then checks the result and branches around the true branch if the
predicate is false.  <tt>Env</tt> and <tt>continue</tt> are preserved around the
predicate code, since they may be needed for the rest of the <tt>if</tt>
expression.  Since the <tt>if</tt> expression is the final expression (and only
expression) in the sequence making up the procedure body, its target is <tt>val</tt> and its linkage is <tt>return</tt>, so the true and false branches are both
compiled with target <tt>val</tt> and linkage <tt>return</tt>.
(That is, the value of the conditional, which is the value computed by
either of its branches, is the value of the procedure.)</p>

<p class="trans" lang="ja">
(<tt>val</tt> をターゲットとした) 述語をまず計算して、それから結果を調べ、もしその述語が偽であれば、真の分岐を避けて分岐するようなコードを、<tt>compile-if</tt> は生成する。
<tt>env</tt> と <tt>continue</tt> が、述語コードのまわりで保全される。というのも、これらは、<tt>if</tt> 式の残りの部分にとって必要かもしれないためである。
<tt>if</tt> 式は、手続き本体を構成する列における最後の式 (そして唯一の式) なので、そのターゲットは <tt>val</tt> であり、そのリンケージは <tt>return</tt> であり、そのため、真の分岐と偽の分岐は、双方とも、<tt>val</tt> というターゲットおよび <tt>return</tt> というリンケージとともにコンパイルされる
(すなわち、条件式の値——その条件式の分岐のうちのいずれかによって計算される値——が、手続きの値である)。
</p>

<p class="lisp">  &lt;<em>save <tt>continue</tt>, <tt>env</tt> if modified by predicate and needed by branches</em>&gt;
  &lt;<em>compilation of predicate, target <tt>val</tt>, linkage <tt>next</tt></em>&gt;
  &lt;<em>restore <tt>continue</tt>, <tt>env</tt> if saved above</em>&gt;
  (test (op false?) (reg val))
  (branch (label false-branch4))
true-branch5
  &lt;<em>compilation of true branch, target <tt>val</tt>, linkage <tt>return</tt></em>&gt;
false-branch4
  &lt;<em>compilation of false branch, target <tt>val</tt>, linkage <tt>return</tt></em>&gt;
after-if3
</p>

<p class="exercise" lang="ja">  &lt;<i class="ex_comment">もし述語により変更され、かつ、分岐により必要とされるならば、<tt>continue</tt> と <tt>env</tt> を退避する</i>&gt;
  &lt;<i class="ex_comment">述語と、<tt>val</tt> というターゲットと、<tt>next</tt> というリンケージとを、コンパイルしたもの</i>&gt;
  &lt;<i class="ex_comment">上で退避した場合には <tt>continue</tt> と <tt>env</tt> を復旧する</i>&gt;
  (test (op false?) (reg val))
  (branch (label false-branch4))
true-branch5
  &lt;<i class="ex_comment">真の分岐と、<tt>val</tt> というターゲットと、<tt>return</tt> というリンケージとを、コンパイルしたもの</i>&gt;
false-branch4
  &lt;<i class="ex_comment">偽の分岐と、<tt>val</tt> というターゲットと、<tt>return</tt> というリンケージとを、コンパイルしたもの</i>&gt;
after-if3
</p>

<p class="orig" lang="en">
The predicate <tt>(= n 1)</tt> is a procedure call.  This
looks up the operator (the symbol <tt>=</tt>) and places this value in
<tt>proc</tt>.  It then assembles the arguments <tt>1</tt> and the value of
<tt>n</tt> into <tt>argl</tt>.  Then it tests whether <tt>proc</tt> contains a
primitive or a compound procedure, and dispatches to a primitive branch
or a compound branch accordingly.  Both branches resume at the <tt>after-call</tt> label.  The requirements to preserve registers
around the evaluation of the operator and operands don't result in
any saving of registers, because in this case those evaluations don't
modify the registers in question.</p>

<p class="trans" lang="ja">
<tt>(= n 1)</tt> という述語は手続き呼び出しである。
これは、演算子 (<tt>=</tt> という記号) を調べて、この値を <tt>proc</tt> に入れる。
それから、これは、<tt>1</tt> という実引数と、<tt>n</tt> の値という実引数を、<tt>argl</tt> の中に組み立てる。
それから、<tt>proc</tt> がプリミティブを含むのか、それとも複合的手続きを含むのかを検査し、それに応じて、プリミティブの分岐か、または複合的な方の分岐へと振り分ける。
双方の分岐は、<tt>after-call</tt> において再開する。
演算子とオペランドの評価のまわりでレジスタを保全するための要件は、レジスタのいかなる退避にもつながらない。なぜなら、この場合、それらの評価は、当該レジスタを変更しないからである。
</p>

<p class="lisp">  (assign proc
          (op lookup-variable-value) (const =) (reg env))
  (assign val (const 1))
  (assign argl (op list) (reg val))
  (assign val (op lookup-variable-value) (const n) (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch17))
compiled-branch16
  (assign continue (label after-call15))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch17
  (assign val (op apply-primitive-procedure)
              (reg proc)
              (reg argl))
after-call15
</p>

<p class="orig" lang="en">
The true branch, which is the constant 1, compiles (with target
<tt>val</tt> and linkage <tt>return</tt>) to</p>

<p class="trans" lang="ja">
真の分岐—— 1 という定数である——は、(<tt>val</tt> というターゲットおよび <tt>return</tt> というリンケージとともに) 以下のようにコンパイルされる。
</p>

<p class="lisp">  (assign val (const 1))
  (goto (reg continue))
</p>

<p class="orig" lang="en">The code for the false branch is another a procedure call, where the
procedure is the value of the symbol <tt>*</tt>, and the arguments are
<tt>n</tt> and the result of another procedure call (a call to <tt>factorial</tt>).
Each of these calls sets up <tt>proc</tt> and <tt>argl</tt> and its own primitive
and compound branches.  Figure <a href="#%_fig_5.17">5.17</a>
shows the complete compilation of the
definition of the <tt>factorial</tt> procedure.
Notice that the possible <tt>save</tt> and <tt>restore</tt> of
<tt>continue</tt> and <tt>env</tt> around the predicate, shown above,
are in fact generated, because these registers are modified by the procedure
call in the predicate and needed for the procedure call and the
<tt>return</tt> linkage in the branches.</p>

<p class="trans" lang="ja">
偽の分岐に対する分岐は、もう一つの手続き呼び出しであって、そこでは、手続きは <tt>*</tt> という記号の値であり、引数は、<tt>n</tt> と、もう一つの手続き呼び出し (<tt>factorial</tt> に対する呼び出し) の結果である。
これらの呼び出しの各々は、<tt>proc</tt> および <tt>argl</tt> と、自分自身のプリミティブおよび複合的分岐とを、設定する。
図<a href="#%_fig_5.17">5.17</a>は、<tt>factorial</tt> 手続きの定義を完全にコンパイルしたものを示している。
述語のまわりでの <tt>continue</tt> と <tt>env</tt> のあり得る <tt>save</tt> と <tt>restore</tt> ——上で示したもの——が、実際に生成されること、なぜなら、これらのレジスタは述語内での手続き呼び出しにより改変され、分岐中の手続き呼び出しおよび <tt>return</tt> リンケージに必要とされるためであることに、注目してほしい。
</p>


<p class="orig" lang="en"><a name="%_thm_5.33"></a>
<b>Exercise 5.33.</b>  Consider the following definition of a factorial procedure, which is
slightly different from the one given above:</p>

<p class="trans" lang="ja">
<b>練習問題5.33.</b> 階乗手続きの以下の定義——上記のものとは少し異なる——を考えよう。
</p>

<p class="lisp">(define (factorial-alt n)
  (if (= n 1)
      1
      (* n (factorial-alt (- n 1)))))
</p>

<p class="orig" lang="en">Compile this procedure and compare the resulting code with that produced for
<tt>factorial</tt>.  Explain any differences you find.  Does either
program execute more efficiently than the other?
</p>

<p class="trans" lang="ja">
この手続きをコンパイルし、結果としてできあがるコードを、<tt>factorial</tt> に対して作り出されたものと比較せよ。
君が見つけた相違点が何かあれば、説明せよ。
どちらかのプログラムの方が、他方よりも効率よく実行されるのだろうか?
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.34"></a>
<b>Exercise 5.34.</b>  <a name="%_idx_6408"></a><a name="%_idx_6410"></a>Compile the iterative factorial procedure</p>

<p class="trans" lang="ja">
<b>練習問題5.34.</b> 以下の反復的な階乗手続きをコンパイルせよ。
</p>

<p class="lisp">(define (factorial n)
  (define (iter product counter)
    (if (&gt; counter n)
        product
        (iter (* counter product)
              (+ counter 1))))
  (iter 1 1))
</p>

<p class="orig" lang="en">Annotate the resulting code, showing the essential difference between
the code for iterative and recursive versions of <tt>factorial</tt> that
makes one process build up stack space and the other run in constant
stack space.
</p>

<p class="trans" lang="ja">
結果として生じるコードに注釈をつけよ—— 一方のプロセスにスタック空間を築きあげさせつつ、他方のプロセスを一定のスタック空間で動作せしめるような、<tt>factorial</tt> の反復的バージョンと再帰的バージョンに対するコード同士の間の相違を示すように。
</p>

<figure>
<a name="%_fig_5.17"></a>
<p class="infig-lisp"><em>;; construct the procedure and skip over code for the procedure body</em>
  (assign val
          (op make-compiled-procedure) (label entry2) (reg env))
  (goto (label after-lambda1))

entry2     <em>; calls to <tt>factorial</tt> will enter here</em>
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env
          (op extend-environment) (const (n)) (reg argl) (reg env))
<em>;; begin actual procedure body</em>
  (save continue)
  (save env)

<em>;; compute <tt>(= n 1)</tt></em>
  (assign proc (op lookup-variable-value) (const =) (reg env))
  (assign val (const 1))
  (assign argl (op list) (reg val))
  (assign val (op lookup-variable-value) (const n) (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch17))
compiled-branch16
  (assign continue (label after-call15))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch17
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))

after-call15   <em>; <tt>val</tt> now contains result of <tt>(= n 1)</tt></em>
  (restore env)
  (restore continue)
  (test (op false?) (reg val))
  (branch (label false-branch4))
true-branch5  <em>; return 1</em>
  (assign val (const 1))
  (goto (reg continue))

false-branch4
<em>;; compute and return <tt>(* (factorial (- n 1)) n)</tt></em>
  (assign proc (op lookup-variable-value) (const *) (reg env))
  (save continue)
  (save proc)   <em>; save <tt>*</tt></em> procedure
  (assign val (op lookup-variable-value) (const n) (reg env))
  (assign argl (op list) (reg val))
  (save argl)   <em>; save partial argument list for <tt>*</tt></em>

<em>;; compute <tt>(factorial (- n 1))</tt>, which is the other argument for <tt>*</tt></em>
  (assign proc
          (op lookup-variable-value) (const factorial) (reg env))
  (save proc)  <em>; save <tt>factorial</tt> procedure</em>
</p>

<figcaption class="orig" lang="en"><b>Figure 5.17:</b>  Compilation of the definition of the <tt>factorial</tt>
procedure (continued on next page).</figcaption>
<figcaption class="trans" lang="ja"><b>図5.17.:</b> <tt>factorial</tt> 手続きの定義をコンパイルしたもの (次ページに続く)</figcaption>
</figure>

<figure>
<a name="%_fig_5.17"></a>
<p class="infig-lisp"><em>;; compute <tt>(- n 1)</tt>, which is the argument for <tt>factorial</tt></em>
  (assign proc (op lookup-variable-value) (const -) (reg env))
  (assign val (const 1))
  (assign argl (op list) (reg val))
  (assign val (op lookup-variable-value) (const n) (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch8))
compiled-branch7
  (assign continue (label after-call6))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch8
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))

after-call6   <em>; <tt>val</tt> now contains result of <tt>(- n 1)</tt></em>
  (assign argl (op list) (reg val))
  (restore proc) <em>; restore <tt>factorial</tt></em>
<em>;; apply <tt>factorial</tt></em>
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch11))
compiled-branch10
  (assign continue (label after-call9))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch11
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))

after-call9      <em>; <tt>val</tt> now contains result of <tt>(factorial (- n 1))</tt></em>
  (restore argl) <em>; restore partial argument list for <tt>*</tt></em>
  (assign argl (op cons) (reg val) (reg argl))
  (restore proc) <em>; restore <tt>*</tt></em>
  (restore continue)
<em>;; apply <tt>*</tt></em> and return its value
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch14))
compiled-branch13
<em>;; note that a compound procedure here is called tail-recursively</em>
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch14
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  (goto (reg continue))
after-call12
after-if3
after-lambda1
<em>;; assign the procedure to the variable <tt>factorial</tt></em>
  (perform
   (op define-variable!) (const factorial) (reg val) (reg env))
  (assign val (const ok))
</p>

<figcaption class="orig" lang="en"><b>Figure 5.17:</b>  (continued)</figcaption>
<figcaption class="trans" lang="ja"><b>図5.17.:</b> (承前)</figcaption>
</figure>

<p class="exercise"><span class="ex_comment">
</span></p>


<p class="orig" lang="en">
<a name="%_thm_5.35"></a>
<b>Exercise 5.35.</b>  What expression was compiled to produce the code shown in
figure <a href="#%_fig_5.18">5.18</a>?</p>

<p class="trans" lang="ja">
<b>練習問題5.35.</b> いかなる式がコンパイルされて、図<a href="#%_fig_5.18">5.18</a>に示したコードを作り出したのだろうか?
</p>

<figure>
<a name="%_fig_5.18"></a>
<p class="infig-lisp">  (assign val (op make-compiled-procedure) (label entry16)
                                           (reg env))
  (goto (label after-lambda15))
entry16
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env
          (op extend-environment) (const (x)) (reg argl) (reg env))
  (assign proc (op lookup-variable-value) (const +) (reg env))
  (save continue)
  (save proc)
  (save env)
  (assign proc (op lookup-variable-value) (const g) (reg env))
  (save proc)
  (assign proc (op lookup-variable-value) (const +) (reg env))
  (assign val (const 2))
  (assign argl (op list) (reg val))
  (assign val (op lookup-variable-value) (const x) (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch19))
compiled-branch18
  (assign continue (label after-call17))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch19
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
after-call17
  (assign argl (op list) (reg val))
  (restore proc)
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch22))
compiled-branch21
  (assign continue (label after-call20))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch22
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
</p>

<figcaption class="orig" lang="en"><b>Figure 5.18:</b>  An example of compiler output (continued on next page).
See exercise <a href="#%_thm_5.35">5.35</a>.</figcaption>
<figcaption class="trans" lang="ja"><b>図5.18.:</b> コンパイラ出力の例 (次ページに続く)。練習問題<a href="#%_thm_5.35">5.35</a>を参照。</figcaption>
</figure>

<figure>
<a name="%_fig_5.18"></a>
<p class="infig-lisp">after-call20
  (assign argl (op list) (reg val))
  (restore env)
  (assign val (op lookup-variable-value) (const x) (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (restore proc)
  (restore continue)
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch25))
compiled-branch24
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch25
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  (goto (reg continue))
after-call23
after-lambda15
  (perform (op define-variable!) (const f) (reg val) (reg env))
  (assign val (const ok))
</p>

<figcaption class="orig" lang="en"><b>Figure 5.18:</b>  (continued)</figcaption>
<figcaption class="trans" lang="ja"><b>図5.18.:</b> (承前)</figcaption>
</figure>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.36"></a>
<b>Exercise 5.36.</b>  <a name="%_idx_6414"></a><a name="%_idx_6416"></a>What order of evaluation does our compiler produce for operands of a
combination?  Is it left-to-right, right-to-left, or some other order?
Where in the compiler is this order determined?  Modify the compiler
so that it produces some other order of evaluation.  (See the
discussion of order of evaluation for the explicit-control evaluator
in section <a href="34_sec5_4.html#%_sec_5.4.1">5.4.1</a>.)  How does changing the order of
operand evaluation affect the efficiency of the code that constructs
the argument list?
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="trans" lang="ja">
<b>練習問題5.36.</b> 私たちのコンパイラは、コンビネーションのオペランドに対して、どのような評価の順序を作り出すだろうか?
左から右へという順序か、右から左へという順序か、それとも何らかの他の順序だろうか?
この順序は、コンパイラ内のどこで決定されるのか?
コンパイラが、評価についての何らかの他の順序を作り出すように、コンパイラを改変せよ
(<a href="34_sec5_4.html#%_sec_5.4.1">5.4.1</a>節における、明示的制御方式の評価器についての、評価の順序に関す議論を参照せよ)。
オペランド評価の順序を変更することは、実引数リストを構築するコードの効率に対して、どのように影響するだろうか?
</p>

<p class="orig" lang="en">
<a name="%_thm_5.37"></a>
<b>Exercise 5.37.</b>  <a name="%_idx_6418"></a><a name="%_idx_6420"></a>One way to understand the compiler's <tt>preserving</tt> mechanism for
optimizing stack usage is to see what extra operations would
be generated if we did not use this idea.  Modify <tt>preserving</tt> so
that it always generates the <tt>save</tt> and <tt>restore</tt> operations.
Compile some simple expressions and identify the unnecessary stack
operations that are generated.
Compare the code to that generated with the <tt>preserving</tt> mechanism intact.
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="trans" lang="ja">
<b>練習問題5.37.</b> スタック使用を最適化するための、コンパイラの <tt>preserving</tt> の仕組みを理解するための一つの方法とは、もしこの考えを利用していなかったとしたら、いかなる余計な演算が生成されたであろうか、ということを調べることである。
<tt>save</tt> 演算と <tt>restore</tt> 演算を常に生成するように、<tt>preserving</tt> を改変せよ。
何らかの単純な式をコンパイルして、生成される不要なスタック演算を突き止めよ。
そのコードを、元のままの <tt>preserving</tt> の仕組みを用いて生成されるものと、比較せよ。
</p>

<p class="orig" lang="en">
<a name="%_thm_5.38"></a>
<b>Exercise 5.38.</b>  <a name="%_idx_6422"></a><a name="%_idx_6424"></a>Our compiler is clever about avoiding unnecessary stack operations,
but it is not clever at all when it comes to compiling calls to the primitive
procedures of the language in terms of the primitive operations
supplied by the machine.  For example, consider how much code is
compiled to compute <tt>(+ a 1)</tt>: The code sets up an argument list
in <tt>argl</tt>, puts the primitive addition procedure (which it finds
by looking up the symbol <tt>+</tt> in the environment) into <tt>proc</tt>,
and tests whether the procedure is primitive or compound.  The
compiler always generates code to perform the test, as well as code
for primitive and compound branches (only one of which will be executed).
We have not shown the part of the controller that implements
primitives, but we presume that these instructions make use of
primitive arithmetic operations in the machine's data paths.  Consider
how much less code would be generated if the compiler could <em>open-code</em> primitives -- that is, if it could generate code to directly
use these primitive machine operations.  The expression <tt>(+ a 1)</tt>
might be compiled into something as simple as <a name="call_footnote_Temp_822" href="#footnote_Temp_822"><sup><small>43</small></sup></a>
</p>

<p class="trans" lang="ja">
<b>練習問題5.38.</b> 私たちのコンパイラは、不要なスタック演算を避けることについては巧みだが、マシンにより供給される原始的演算を用いた、言語の原始的手続きに対する呼び出しを、コンパイルするところになると、まったく巧みではない。
たとえば、<tt>(+ a 1)</tt> を計算するのに、どれほど大量のコードがコンパイルされるのかを考えよう。
コードは、引数リストを <tt>argl</tt> の中に設定し、(環境内で <tt>+</tt> という記号を調べることで見つかる) 原始的な加算手続きを <tt>proc</tt> に入れ、手続きが原始的か複合的かを検査する。
コンパイラは常に、検査を行うためのコードを生成し、また、原始的な方の分岐用と複合的な方の分岐用のコード (それらのうち一方のみが実行されるだろう) を生成する。
コントローラのうち、プリミティブを実装する部分を、私たちは示してこなかったが、これらの命令がマシンのデータ経路における原始的算術演算を利用することを、私たちは想定している。
もしコンパイラがプリミティブを<em>オープン・コード</em>できたなら——つまり、もしコンパイラがこれらの原始的マシン演算を直接的に使うためのコードを生成できたなら——どれほど少なくなったコードが生成されるだろうか、と考えてほしい。
<tt>(+ a 1)</tt> という式は、以下と同じくらい簡潔な何かへとコンパイルされるかもしれないのだ<a href="#footnote_Temp_822"><sup><small>43</small></sup></a>。
</p>

<p class="lisp">(assign val (op lookup-variable-value) (const a) (reg env))
(assign val (op +) (reg val) (const 1))
</p>

<p class="orig" lang="en">In this exercise we will extend our compiler to support open coding of
selected primitives.  Special-purpose code will be generated
for calls to these primitive procedures instead of the general
procedure-application code.  In order to support this, we will augment
our machine with special argument registers <tt>arg1</tt> and <tt>arg2</tt>.
The primitive arithmetic operations of the machine will take their
inputs from <tt>arg1</tt> and <tt>arg2</tt>. The results may be put into
<tt>val</tt>, <tt>arg1</tt>, or <tt>arg2</tt>.</p>

<p class="trans" lang="ja">
この練習問題では、選択されたプリミティブのオープン・コーディングをサポートするように、私たちのコンパイラを拡張することにしよう。
これらの原始的手続きに対する呼び出しについては、汎用の手続き適用コードの代わりに、専用のコードが生成されるだろう。
これをサポートするために、<tt>arg1</tt> および <tt>arg2</tt> という特別な引数レジスタを使って、私たちのマシンを拡張しよう。
このマシンの原始的算術演算は、<tt>arg1</tt> および <tt>arg2</tt> から入力をとることだろう。
結果は、<tt>val</tt> か <tt>arg1</tt> か <tt>arg2</tt> に入れられ得る。
</p>

<p class="orig" lang="en">
The compiler must be able to recognize the application of an
open-coded primitive in the source program.  We will augment the
dispatch in the <tt>compile</tt> procedure to recognize the names of
these primitives in addition to the <a name="%_idx_6426"></a>reserved words (the special forms)
it currently recognizes.<a name="call_footnote_Temp_823" href="#footnote_Temp_823"><sup><small>44</small></sup></a> For each special form our compiler has a code generator.  In
this exercise we will construct a family of code generators for the
open-coded primitives.</p>

<p class="trans" lang="ja">
コンパイラは、ソース・プログラムにおける、オープン・コーディングされたプリミティブの適用を認識できなくてはならない。
<tt>compile</tt> 手続きでの振り分けが今のところ認識する予約語 (特殊形式) に加えて、これらのプリミティブの名前をも認識するように、<tt>compile</tt> 手続きでの振り分けを拡張しよう<a href="#footnote_Temp_823"><sup><small>44</small></sup></a>。
それぞれの特殊形式について、私たちのコンパイラはコード生成器を有する。
本練習問題では、オープン・コーディングされたプリミティブについてのコード生成器の一群を構築しよう。
</p>

<ol class="orig alph" lang="en">
<li>The open-coded primitives, unlike the special forms, all need their
operands evaluated.  Write a code generator <tt>spread-arguments</tt> for use by
all the open-coding code generators.  <tt>Spread-arguments</tt> should take an
operand list and compile the given operands targeted to successive argument
registers.  Note that an operand may contain a call to an open-coded
primitive, so argument registers will have to be preserved during operand
evaluation.</li>

<li>For each of the primitive procedures <tt>=</tt>, <tt>*</tt>, <tt>-</tt>, and
<tt>+</tt>, write a code generator that takes a combination with that
operator, together with a target and a linkage descriptor, and
produces code to spread the arguments into the registers and then
perform the operation targeted to the given target with the given
linkage.  You need only handle expressions with two operands.  Make
<tt>compile</tt> dispatch to these code generators.</li>

<li>Try your new compiler on the <tt>factorial</tt> example.  Compare the
resulting code with the result produced without open coding.</li>

<li>Extend your code generators for <tt>+</tt> and <tt>*</tt> so that they
can handle expressions with arbitrary numbers of operands.  An
expression with more than two operands will have to be compiled into a
sequence of operations, each with only two inputs.</li>
</ol>

<ol class="trans alph" lang="ja">
<li>オープン・コーディングされたプリミティブは、特殊形式とは異なり、皆すべて、自身のオペランドが評価済みであることを要する。
すべてのオープン・コーディング・コード生成器が使うための、<tt>spread-arguments</tt> というコード生成器を書け。
<tt>spread-arguments</tt> は、オペランド・リストをとって、一連の引数レジスタをターゲットとするその与えられたオペランドをコンパイルするべきである。
オープン・コーディングされたプリミティブに対する呼び出しをオペランドが含むかもしれず、すると、オペランド評価の間、引数レジスタが保全されることになるだろう、ということに、注意せよ。</li>

<li><tt>=</tt>、<tt>*</tt>、<tt>-</tt>、<tt>+</tt> という原始的手続きのそれぞれについて、当該演算子を有するコンビネーションをターゲットおよびリンケージ記述子とともにとって、そして、引数をレジスタへ分配してから所与のリンケージをともなう所与のターゲットに向けられた当該演算を実行するコードを作り出すような、コード生成器を書け。
二つのオペランドを有する式を扱うだけでよい。
これらのコード生成器への振り分けを、<tt>compile</tt> に行わせよ。
</li>

<li><tt>factorial</tt> の事例について、君の新コンパイラを試してみたまえ。
結果としてできあがるコードを、オープン・コーディングなしで作り出される結果と比較せよ。</li>

<li><tt>+</tt> と <tt>*</tt> についての君のコード生成器を、任意の個数のオペランドを有する式を扱えるように拡張せよ。
二つよりも多くのオペランドを有する式は、一連の演算——それぞれの演算はただ二つの入力のみを有する——へとコンパイルされる必要があるだろう。</li>
</ol>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_5.5.6"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_5.5.6">5.5.6  Lexical Addressing</a></h3>
<h3 class="trans" lang="ja">5.5.6 レキシカル・アドレシング</h3>

<p class="orig" lang="en"><a name="%_idx_6428"></a><a name="%_idx_6430"></a>
One of the most common optimizations performed by compilers is the
optimization of variable lookup.  Our compiler, as we have implemented
it so far, generates code that uses the <tt>lookup-variable-value</tt>
operation of the evaluator machine.  This searches for a variable by
comparing it with each variable that is currently bound, working frame
by frame outward through the run-time environment.  This search can be
expensive if the frames are deeply nested or if there are many
variables.  For example, consider the problem of looking up the value
of <tt>x</tt> while evaluating the expression <tt>(* x y z)</tt> in an
application of the procedure that is returned by</p>

<p class="trans" lang="ja">
コンパイラにより行われる、もっともよくある最適化の一つは、変数<ruby><rb>を調べること</rb><rp> (</rp><rt>ルックアップ</rt><rp>) </rp></ruby>の最適化である。
ここまで私たちが実装してきたような私たちのコンパイラは、評価器マシンの <tt>lookup-variable-value</tt> 演算を使うコードを生成する。
これは、実行時の環境を外側に向かって通ってフレームごとに動作しながら<span class="note"> (訳がイマイチ)</span>、現在束縛されている各変数と比べることによって、変数を探索する。
もしフレームが深く入れ子になっていたり、あるいは、多くの変数があったりすれば、この探索は、高くつく可能性がある。
たとえば、以下のものにより返される手続きの適用において <tt>(* x y z)</tt> という式を評価するときに <tt>x</tt> の値を調べる、という問題を考えよう。
</p>

<p class="lisp">(let ((x 3) (y 4))
  (lambda (a b c d e)
    (let ((y (* a b x))
          (z (+ c d x)))
      (* x y z))))
</p>

<p class="orig" lang="en">Since a <tt>let</tt> expression is just syntactic sugar for a <tt>lambda</tt> combination, this expression is equivalent to</p>

<p class="trans" lang="ja">
<tt>let</tt> 式は、 <tt>lambda</tt> コンビネーションに対するただの糖衣構文であるから、この式は、次のものと等価である。
</p>

<p class="lisp">((lambda (x y)
   (lambda (a b c d e)
     ((lambda (y z) (* x y z))
      (* a b x)
      (+ c d x))))
 3
 4)
</p>

<p class="orig" lang="en">Each time <tt>lookup-variable-value</tt> searches for <tt>x</tt>, it must
determine that the symbol <tt>x</tt> is not <tt>eq?</tt> to <tt>y</tt> or <tt>z</tt> (in the first frame), nor to <tt>a</tt>, <tt>b</tt>, <tt>c</tt>, <tt>d</tt>, or
<tt>e</tt> (in the second frame).  We will assume, for the moment, that
our programs do not use <tt>define</tt> -- that variables are
bound only with <tt>lambda</tt>.  Because our language is <a name="%_idx_6432"></a>lexically
scoped, the run-time environment for any expression will have a
structure that parallels the lexical structure of the program in which
the expression appears.<a name="call_footnote_Temp_824" href="#footnote_Temp_824"><sup><small>45</small></sup></a>
Thus, the compiler can know, when it analyzes the
above expression, that each time the procedure is applied the variable
<tt>x</tt> in <tt>(* x y z)</tt> will be found two frames out from the
current frame and will be the first variable in that frame.</p>

<p class="trans" lang="ja">
<tt>lookup-variable-value</tt> が <tt>x</tt> を探すたびに、<tt>lookup-variable-value</tt> は、<tt>x</tt> という記号が (1番目のフレームにおいて) <tt>y</tt> とも <tt>z</tt> とも <tt>eq?</tt> ではないことを判定せねばならず、<tt>x</tt> という記号が (2番目のフレームにおいて) <tt>a</tt> とも <tt>b</tt> とも <tt>c</tt> とも <tt>d</tt> とも <tt>e</tt> とも <tt>eq?</tt> ではないことを判定せねばならない。
さしあたり、私たちのプログラムは <tt>define</tt> ——変数が <tt>lambda</tt> とだけしか束縛されない——を使わないのだ、と仮定しよう。
私たちの言語はレキシカルにスコープが決まるので、いかなる式についての実行時の環境も、その式が現れる、プログラムのレキシカルな構造と、<ruby><rb>並列</rb><rp> (</rp><rt>パラレル</rt><rp>) </rp></ruby>である<a href="#footnote_Temp_824"><sup><small>45</small></sup></a>。<!--と<ruby><rb>相同</rb><rp> (</rp><rt>パラレル</rt><rp>) </rp></ruby>なのだ。-->
よって、当該手続きが適用されるたびに、<tt>(* x y z)</tt> の中の <tt>x</tt> という変数が、現在のフレームから二つ外側のフレームで見つかるだろうし、この <tt>x</tt> という変数は、そのフレームにおける最初の変数であろう、ということを、コンパイラは、上記の式を分析するときに、知ることができる。
</p>

<p class="orig" lang="en">
<a name="%_idx_6434"></a>We can exploit this fact by inventing a new kind of variable-lookup
operation, <tt>lexical-address-lookup</tt>, that takes as arguments an
environment and a <em>lexical address</em> that consists of two numbers:
a <em>frame number</em>, which specifies how many frames to pass over,
and a <em>displacement number</em>, which specifies how many variables to
pass over in that frame.  <a name="%_idx_6436"></a><tt>Lexical-address-lookup</tt> will produce
the value of the variable stored at that lexical address relative to
the current environment.  If we add the <tt>lexical-address-lookup</tt>
operation to our machine, we can make the compiler generate code that
references variables using this operation, rather than <tt>lookup-variable-value</tt>.  Similarly, our compiled code can use a new
<a name="%_idx_6438"></a><tt>lexical-address-set!</tt>  operation instead of <tt>set-variable-value!</tt>.</p>

<p class="trans" lang="ja">
この事実を、私たちは、環境と、二つの番号から構成される<em>レキシカル・アドレス</em>とを引数としてとるような、新たな種類の変数ルックアップ演算——すなわち <tt>lexical-address-lookup</tt> ——を考案することによって、利用できる。その二つの番号とは、<em>フレーム番号</em>——いくつのフレームを考慮から外して飛ばすべきかを指定する——と、<em>位置ずれ番号</em>——そのフレームの中でいくつの変数を考慮から外して飛ばすべきかを指定する——である。
<tt>lexical-address-lookup</tt> は、現在の環境に対するそのレキシカル・アドレスに記憶されている変数の値を、作り出すだろう。
もし私たちのマシンに <tt>lexical-address-lookup</tt> 演算を追加すれば、私たちは、<tt>lookup-variable-value</tt> ではなくこの演算を使って変数を参照するコードをコンパイラに生成させることができる。
同様に、コンパイル済みのコードは、<tt>set-variable-value!</tt> の代わりに新たな <tt>lexical-address-set!</tt> 演算を使える。
</p>

<p class="orig" lang="en">
In order to generate such code, the compiler must be able to determine
the lexical address of a variable it is about to compile a reference
to.  The lexical address of a variable in a program depends on where
one is in the code.  For example, in the following program, the
address of <tt>x</tt> in expression &lt;<em>e1</em>&gt; is (2,0) -- two frames back
and the first variable in the frame.  At that point <tt>y</tt> is at
address (0,0) and <tt>c</tt> is at address (1,2).  In expression
&lt;<em>e2</em>&gt;,  <tt>x</tt> is at (1,0),   <tt>y</tt> is at (1,1), and <tt>c</tt> is at (0,2).</p>

<p class="trans" lang="ja">
そうしたコードを生成するために、コンパイラは、今まさにそこへの参照をコンパイルしようとしているところの変数のレキシカル・アドレスを、特定できなくてはならない。
プログラム中の変数のレキシカル・アドレスは、コード内で変数がどこにあるか、ということに依存する。
たとえば、以下のプログラムにおいては、&lt;<em class="en">e1</em>&gt; という式の中の <tt>x</tt> のアドレスは、<span class="math">(2, 0)</span> ——すなわち、二つフレームを戻り、そのフレーム内で最初の変数——というものである。
この時点で <tt>y</tt> は <span class="math">(0, 0)</span> というアドレスにあり、<tt>c</tt> は <span class="math">(1, 2)</span> というアドレスにある。
&lt;<em class="en">e2</em>&gt; という式の中では、<tt>x</tt> は <span class="math">(1, 0)</span> にあり、<tt>y</tt> は <span class="math">(1, 1)</span> にあり、<tt>c</tt> は <span class="math">(0, 2)</span> にある。
</p>

<p class="lisp">((lambda (x y)
   (lambda (a b c d e)
     ((lambda (y z) &lt;<em>e1</em>&gt;)
      &lt;<em>e2</em>&gt;
      (+ c d x))))
 3
 4)
</p>

<p class="orig" lang="en">
<a name="%_idx_6440"></a>One way for the compiler to produce code that uses lexical addressing
is to maintain a data structure called a <em>compile-time
environment</em>.  This keeps track of which variables will be at which
positions in which frames in the run-time environment when a
particular variable-access operation is executed.  The compile-time
environment is a list of frames, each containing a list of variables.
(There will of course be no values bound to the variables, since
values are not computed at compile time.)  The compile-time
environment becomes an additional argument to <tt>compile</tt> and is
passed along to each code generator.  The top-level call to <tt>compile</tt> uses an empty compile-time environment.
When a <tt>lambda</tt> body is compiled, <tt>compile-lambda-body</tt>
extends the compile-time environment by a frame containing the
procedure's parameters, so that the sequence making up the body
is compiled with that extended environment.
At each point in the compilation, <tt>compile-variable</tt> and <tt>compile-assignment</tt> use the compile-time
environment in order to generate the appropriate lexical addresses.</p>

<p class="trans" lang="ja">
レキシカル・アドレシングを用いるコードをコンパイラが作り出すための一つの方法は、<em>コンパイル時環境</em>と呼ばれるデータ構造を維持することである。
これは、特定の変数アクセス演算が実行されるときに、実行時環境におけるどのフレームのどの場所にどの変数があるだろうか、ということを追跡・把握する。
コンパイル時環境はフレームのリストであり、ここでの各フレームは、変数のリストである (もちろん、コンパイル時には値は計算されないので、変数に束縛された値は存在しないだろう)。
コンパイル時環境は <tt>compile</tt> に対する追加の引数となり、各コード生成器へと伝えられる。
<tt>compile</tt> に対するトップレベルの呼び出しは、空のコンパイル時環境を用いる。
<tt>lambda</tt> 本体がコンパイルされる際に、<tt>compile-lambda-body</tt> が、手続きの仮引数を含むフレームのぶんだけコンパイル時環境を拡張し、するとその結果、本体を構成する列は、その拡張された環境とともにコンパイルされる。
コンパイルの各時点において、<tt>compile-variable</tt> と <tt>compile-assignment</tt> は、適宜のレキシカル・アドレスを生成するためにコンパイル時環境を使う。
</p>

<p class="orig" lang="en">
Exercises <a href="#%_thm_5.39">5.39</a>
through <a href="#%_thm_5.43">5.43</a> describe how to complete this sketch of
the lexical-addressing strategy in order to incorporate lexical lookup
into the compiler.
Exercise <a href="#%_thm_5.44">5.44</a> describes another use for the
compile-time environment.</p>

<p class="trans" lang="ja">
練習問題<a href="#%_thm_5.39">5.39</a>から練習問題<a href="#%_thm_5.43">5.43</a>まででは、コンパイラにレキシカル・ルックアップを取り入れるためのレキシカル・アドレシング戦略についてのこの概略を、どのようにして完成させるのかについて、説明している。
練習問題<a href="#%_thm_5.44">5.44</a>では、コンパイル時環境についての別の用法を記述している。
</p>

<p class="orig" lang="en">
<a name="%_thm_5.39"></a>
<b>Exercise 5.39.</b>  <a name="%_idx_6442"></a><a name="%_idx_6444"></a>Write a procedure <tt>lexical-address-lookup</tt> that implements the new
lookup operation.  It should take two arguments -- a lexical address
and a run-time environment -- and return the value of the variable
stored at the specified lexical address.  <tt>Lexical-address-lookup</tt>
should signal an error if the value of the variable is the symbol <tt>*unassigned*</tt>.<a name="call_footnote_Temp_826" href="#footnote_Temp_826"><sup><small>46</small></sup></a> Also write a procedure <tt>lexical-address-set!</tt> that
implements the operation that changes the value of the variable at a
specified lexical address.
</p>

<p class="trans" lang="ja">
<b>練習問題5.39.</b> 新規ルックアップ演算を実装する <tt>lexical-address-lookup</tt> という手続きを書け。
これは、二つの引数——レキシカル・アドレスと実行時環境——をとるべきであり、指定されたレキシカル・アドレスに記憶されている変数の値を返すべきである。
もし、その変数の値が <tt>*unassigned*</tt> という記号であれば、<tt>lexical-address-lookup</tt> は、エラーを知らせるべきである<a href="#footnote_Temp_826"><sup><small>46</small></sup></a>。
また、指定されたレキシカル・アドレスにある変数の値を変更する演算を実装する、<tt>lexical-address-set!</tt> という手続きを書け。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.40"></a>
<b>Exercise 5.40.</b>  <a name="%_idx_6450"></a>Modify the compiler to maintain the compile-time environment as
described above.  That is, add a compile-time-environment argument to
<tt>compile</tt> and the various code generators, and extend it in
<tt>compile-lambda-body</tt>.
</p>

<p class="trans" lang="ja">
<b>練習問題5.40.</b> 上述のとおりコンパイル時環境を維持するように、コンパイラを改変せよ。
つまり、<tt>compile</tt> および種々のコード生成器にコンパイル時環境の引数を加え、その引数を <tt>compile-lambda-body</tt> において拡張せよ。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.41"></a>
<b>Exercise 5.41.</b>  <a name="%_idx_6452"></a>Write a procedure <tt>find-variable</tt> that takes as arguments a
variable and a compile-time environment and returns the lexical
address of the variable with respect to that environment.  For
example, in the program fragment that is shown above, the compile-time
environment during the compilation of expression &lt;<em>e1</em>&gt; is <tt>((y
z) (a b c d e) (x y))</tt>.  <tt>Find-variable</tt> should produce</p>

<p class="trans" lang="ja">
<b>練習問題5.41.</b> 変数とコンパイル時環境を引数としてとり、その環境についてのその変数のレキシカル・アドレスを返すような、<tt>find-variable</tt> という手続きを書け。
たとえば、上記のプログラム断片では、&lt;<em class="en">e1</em>&gt; という式のコンパイルの間におけるコンパイル時環境は、
<tt>((y z) (a b c d e) (x y))</tt>
である。
<tt>find-variable</tt> は以下のものを作り出すはずである。
</p>

<p class="lisp">(find-variable 'c '((y z) (a b c d e) (x y)))
<i>(1 2)</i>

(find-variable 'x '((y z) (a b c d e) (x y)))
<i>(2 0)</i>

(find-variable 'w '((y z) (a b c d e) (x y)))
<i>not-found</i>
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.42"></a>
<b>Exercise 5.42.</b>  Using <tt>find-variable</tt> from exercise <a href="#%_thm_5.41">5.41</a>,
rewrite <tt>compile-variable</tt> and <tt>compile-assignment</tt> to output
lexical-address instructions.  In cases where <tt>find-variable</tt>
returns <tt>not-found</tt> (that is, where the variable is not in the
compile-time environment), you should have the code generators use the
evaluator operations, as before, to search for the binding.
(The only place a variable that is not found at compile time can be is in
the global environment, which is part of the run-time environment but
is not part of the compile-time environment.<a name="call_footnote_Temp_830" href="#footnote_Temp_830"><sup><small>47</small></sup></a>
Thus, if you wish, you may have the evaluator operations look directly in
the global environment, which can be obtained with the operation <tt>(op get-global-environment)</tt>, instead of having them search the whole run-time
environment found in <tt>env</tt>.)
Test the modified compiler on a few simple cases, such as the nested
<tt>lambda</tt> combination at the beginning of this section.
</p>

<p class="trans" lang="ja">
<b>練習問題5.42.</b> 練習問題<a href="#%_thm_5.41">5.41</a>の <tt>find-variable</tt> を用いて、レキシカル・アドレス方式の命令を出力するように <tt>compile-variable</tt> と <tt>compile-assignment</tt> を書き換えよ。
<tt>find-variable</tt> が <tt>not-found</tt> を返す (つまり、変数がコンパイル時環境にはない) 場合には、従来と同様に、コード生成器に、束縛を探すための評価器の演算を使わせるべきである 
(コンパイル時に見つからない変数が存在し得る唯一の箇所は、大域環境——実行時環境の一部であるがコンパイル時環境の一部ではない——の中である)<a href="#footnote_Temp_830"><sup><small>47</small></sup></a>。
よって、もし君が望むなら、君は、評価器の演算に、<tt>env</tt> の中で見つかる実行時環境全体を探索させる代わりに、大域環境—— <tt>(op get-global-environment)</tt> という演算を使って取得できる——の中を直接、見させても構わない。
本節の最初にある入れ子になった <tt>lambda</tt> コンビネーションなどの、二、三の単純な事例について、改変したコンパイラを試してみよ。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.43"></a>
<b>Exercise 5.43.</b>  <a name="%_idx_6454"></a><a name="%_idx_6456"></a>We argued in section <a href="26_sec4_1.html#%_sec_4.1.6">4.1.6</a> that internal definitions
for block structure should not be considered ``real'' <tt>define</tt>s.  Rather,
a procedure body should be interpreted as if the internal variables being
defined were installed as ordinary <tt>lambda</tt> variables initialized to their
correct values using <tt>set!</tt>.  Section <a href="26_sec4_1.html#%_sec_4.1.6">4.1.6</a> and
exercise <a href="26_sec4_1.html#%_thm_4.16">4.16</a> showed how to modify the metacircular
interpreter to accomplish this by scanning out internal definitions.  Modify
the compiler to perform the same transformation before it compiles a procedure
body.
</p>

<p class="trans" lang="ja">
<b>練習問題5.43.</b> <a href="26_sec4_1.html#%_sec_4.1.6">4.1.6</a>節において私たちは、ブロック構造のための内部定義を「現実の」<tt>define</tt> だと考えるべきではないのだ、と論じた。
そうではなく <span class="note">(現実の <tt>define</tt> なのではなく)</span>、定義されている内部変数が、あたかも、<tt>set!</tt> を用いて正しい値に初期化される通常の <tt>lambda</tt> 変数として組み込まれたかのように、手続き本体が解釈されるべきなのだ。
<a href="26_sec4_1.html#%_sec_4.1.6">4.1.6</a>節および練習問題<a href="26_sec4_1.html#%_thm_4.16">4.16</a>では、内部定義を走査し尽くすことでこれを達成するようにメタ循環的なインタプリタを改変する方法を示した。
コンパイラが手続き本体をコンパイルする前に、同じ変形を実行するよう、コンパイラを改変せよ。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.44"></a>
<b>Exercise 5.44.</b>  <a name="%_idx_6458"></a><a name="%_idx_6460"></a><a name="%_idx_6462"></a><a name="%_idx_6464"></a>In this section we have focused on the use of the compile-time
environment to produce lexical addresses.  But there are other uses
for compile-time environments.  For instance, in
exercise <a href="#%_thm_5.38">5.38</a> we increased the efficiency of compiled
code by open-coding primitive procedures.  Our implementation treated
the names of open-coded procedures as reserved words.  If a program
were to rebind such a name, the mechanism described in
exercise <a href="#%_thm_5.38">5.38</a> would still open-code it as a primitive,
ignoring the new binding.  For example, consider the procedure</p>

<p class="trans" lang="ja">
<b>練習問題5.44.</b> 本節で私たちは、レキシカル・アドレスを作り出すための、コンパイル時環境の使用に、焦点を当ててきた。
しかし、コンパイル時環境についての別の用途もある。
たとえば、練習問題<a href="#%_thm_5.38">5.38</a>では、オープン・コーディング方式の原始的手続きによって、コンパイル済みコードの効率を増大させた。
私たちの実装は、オープン・コーディングされた手続きの名前を、予約語として扱っていた。
もし、プログラムがそうした名前を束縛し直そうとしたならば、練習問題<a href="#%_thm_5.38">5.38</a>で説明した仕組みは、新たな束縛を無視して、依然として、その名前をプリミティブとしてオープン・コーディングするだろう。
たとえば、以下の手続きを考えよ。
</p>

<p class="lisp">(lambda (+ * a b x y)
  (+ (* a x) (* b y)))
</p>

<p class="orig" lang="en">which computes a linear combination of <tt>x</tt> and <tt>y</tt>.  We might
call it with arguments <tt>+matrix</tt>, <tt>*matrix</tt>, and four
matrices, but the open-coding compiler would still open-code the <tt>+</tt> and the <tt>*</tt> in <tt>(+ (* a x) (* b y))</tt> as primitive <tt>+</tt>
and <tt>*</tt>.  Modify the open-coding compiler to consult the
compile-time environment in order to compile the correct code for
expressions involving the names of primitive procedures.
(The code will work correctly as long as the program does not <tt>define</tt> or <tt>set!</tt> these names.)
</p>

<p class="trans" lang="ja">
これは、<tt>x</tt> と <tt>y</tt> の線形結合を計算する。
私たちはこれを、<tt>+matrix</tt> と <tt>*matrix</tt> と四つの行列、という引数とともに呼び出すかもしれないが、オープン・コーディング式コンパイラは、依然として、<tt>(+ (* a x) (* b y))</tt> の中の <tt>+</tt> および <tt>*</tt> を、原始的な <tt>+</tt> および <tt>*</tt> として、オープン・コーディングするだろう。
原始的手続きの名前を含む式について正しいコードをコンパイルするために、コンパイル時環境を調べるよう、オープン・コーディング式コンパイラを改変せよ (プログラムがこれらの名前を <tt>define</tt> も <tt>set!</tt> もしない限りは、コードは正しく動くだろう)。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_5.5.7"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_5.5.7">5.5.7  Interfacing Compiled Code to the Evaluator</a></h3>
<h3 class="trans" lang="ja">5.5.7 コンパイル済みコードを評価器に対して仲介する</h3>

<p class="orig" lang="en"><a name="%_idx_6466"></a><a name="%_idx_6468"></a><a name="%_idx_6470"></a>
We have not yet explained how to load compiled code into the evaluator machine
or how to run it.  We will assume that the explicit-control-evaluator machine
has been defined as in section <a href="34_sec5_4.html#%_sec_5.4.4">5.4.4</a>, with the
additional operations specified in footnote <a href="#footnote_Temp_809">38</a>.
We will implement
a procedure <a name="%_idx_6472"></a><tt>compile-and-go</tt> that compiles a Scheme expression, loads the
resulting object code into the evaluator machine,
and causes the machine to run the code in the
evaluator global environment, print the result, and
enter the evaluator's driver loop.  We will also modify the evaluator so that
interpreted expressions can call compiled procedures as well as interpreted
ones.  We can then put a compiled procedure into the machine and use the
evaluator to call it:</p>

<p class="trans" lang="ja">
どのようにしてコンパイル済みコードを評価器マシンにロードするのかについても、どのようにしてコンパイル済みコードを実行するのかについても、私たちはまだ説明していない。
脚注<a href="#footnote_Temp_809">38</a>で指定された付加的な演算を備えつつ、<a href="34_sec5_4.html#%_sec_5.4.4">5.4.4</a>節でのように明示的制御方式評価器マシンが定義済みであるものとしよう。
Scheme 式をコンパイルし、結果としてできあがったオブジェクト・コードを評価器マシンにロードし、そして、マシンに、当該コードを評価器の大域環境内で実行させ、結果を印字させ、評価器のドライバ・ループへと入らせるような、<tt>compile-and-go</tt> という手続きを実装しよう。
また、解釈された式が、解釈済みの手続きだけでなくコンパイル済みの手続きも呼び出せるようにも、評価器を改変しよう。
すると、コンパイル済みの手続きをマシンに入れ、評価器を使って、そのコンパイル済みの手続きを呼び出す、ということができる。
</p>

<p class="lisp">(compile-and-go
 '(define (factorial n)
    (if (= n 1)
        1
        (* (factorial (- n 1)) n))))
<i> ;;; EC-Eval value:</i>
<i>ok</i>
<i> ;;; EC-Eval input:</i>
(factorial 5)
<i>;;; EC-Eval value:</i>
<i>120</i>
</p>

<p class="orig" lang="en">
To allow the evaluator to handle compiled procedures (for example,
to evaluate the call to <tt>factorial</tt> above),
we need to change the code at <tt>apply-dispatch</tt>
(section <a href="34_sec5_4.html#%_sec_5.4.1">5.4.1</a>) so that it recognizes
compiled procedures (as distinct from compound or primitive
procedures) and transfers control directly to the entry point of the
compiled code:<a name="call_footnote_Temp_833" href="#footnote_Temp_833"><sup><small>48</small></sup></a>
</p>


<p class="trans" lang="ja">
評価器がコンパイル済み手続きを扱えるように (たとえば、上記の <tt>factorial</tt> に対する呼び出しを評価できるように) するために、私たちは、<tt>apply-dispatch</tt> (<a href="34_sec5_4.html#%_sec_5.4.1">5.4.1</a>節) のところにあるコードを、(複合的手続きあるいは原始的手続きとは別のものとして) コンパイル済み手続きを認識してそのコンパイル済みコードのエントリ・ポイントへと直接的に制御を移すように、変更する必要がある<a href="#footnote_Temp_833"><sup><small>48</small></sup></a>。
</p>

<p class="lisp"><a name="%_idx_6474"></a>apply-dispatch
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-apply))
  (test (op compound-procedure?) (reg proc))  
  (branch (label compound-apply))
  (test (op compiled-procedure?) (reg proc))  
  (branch (label compiled-apply))
  (goto (label unknown-procedure-type))
<a name="%_idx_6476"></a>compiled-apply
  (restore continue)
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
</p>

<p class="orig" lang="en">Note the restore of <tt>continue</tt> at <tt>compiled-apply</tt>.  Recall that the
evaluator was arranged so that at <tt>apply-dispatch</tt>, the continuation would
be at the top of the stack.  The compiled code entry point, on the other hand,
expects the continuation to be in <tt>continue</tt>, so <tt>continue</tt> must be
restored before the compiled code is executed.</p>

<p class="trans" lang="ja">
<tt>compiled-apply</tt> における <tt>continue</tt> の復旧に注意してほしい。
<tt>apply-dispatch</tt> においては継続がスタックの先頭にあるだろう、というふうに評価器が整えられたことを、思い出してほしい。
他方、コンパイル済みコードのエントリ・ポイントは、継続が <tt>continue</tt> にあると予期しており、そのため、コンパイル済みコードが実行される前に <tt>continue</tt> が復旧されねばならないのだ。
</p>

<p class="orig" lang="en">
To enable us to run some compiled code when we start the evaluator
machine, we add a <tt>branch</tt> instruction at
the beginning of the evaluator machine, which causes the machine to
go to a new entry point if the <tt>flag</tt> register is set.<a name="call_footnote_Temp_834" href="#footnote_Temp_834"><sup><small>49</small></sup></a></p>

<p class="trans" lang="ja">
評価器マシンを始動させたときに、何らかのコンパイル済みコードを実行できるようにするために、私たちは、評価器マシンの最初のところに <tt>branch</tt> 命令を追加するのだが、これにより、マシンを、<tt>flag</tt> レジスタがセットされていれば新規エントリ・ポイントへ行くようにさせるのだ<a href="#footnote_Temp_834"><sup><small>49</small></sup></a>。
</p>


<p class="lisp">  (branch (label external-entry))      <em>; branches if <tt>flag</tt> is set</em>
read-eval-print-loop
  (perform (op initialize-stack))
  <tt>...</tt></p>

<p class="orig" lang="en"><tt>External-entry</tt> assumes that the machine is started with
<tt>val</tt> containing the location of an instruction sequence that
puts a result into <tt>val</tt> and ends with <tt>(goto (reg
continue))</tt>.  Starting at this entry point jumps to the location designated
by <tt>val</tt>, but first assigns <tt>continue</tt> so that execution will return
to <tt>print-result</tt>, which prints the value in <tt>val</tt> and then goes to
the beginning of the evaluator's read-eval-print loop.<a name="call_footnote_Temp_835" href="#footnote_Temp_835"><sup><small>50</small></sup></a></p>

<p class="trans" lang="ja">
結果を <tt>val</tt> に入れて <tt>(goto (reg continue))</tt> で終わるような命令列の場所を <tt>val</tt> が含んでいる状態で、マシンが始動される、ということを <tt>external-entry</tt> は想定している。
このエントリ・ポイントから始めると、<tt>val</tt> により指定される場所へとジャンプするが、まず先に、実行が <tt>print-result</tt> ——これは、<tt>val</tt> にある値を印字し、それから、評価器の読み取り・評価・印字ループの最初のところへ行く——へと戻るように、<tt>continue</tt> を割り当てる<a href="#footnote_Temp_835"><sup><small>50</small></sup></a>。
</p>

<p class="lisp"><a name="%_idx_6482"></a>external-entry
  (perform (op initialize-stack))
  (assign env (op get-global-environment))
  (assign continue (label print-result))
  (goto (reg val))
</p>

<p class="orig" lang="en">
Now we can use the following procedure to compile a procedure definition,
execute the compiled code, and run the read-eval-print loop so we can try the
procedure.  Because we want the compiled code to return to the location in
<tt>continue</tt> with its result in <tt>val</tt>, we compile the expression with a
target of <tt>val</tt> and a linkage of <tt>return</tt>.  In order to transform the
object code produced by the compiler into executable instructions for the
evaluator register machine, we use the procedure <tt>assemble</tt> from the
register-machine simulator (section <a href="32_sec5_2.html#%_sec_5.2.2">5.2.2</a>).  We then initialize
the <tt>val</tt> register to point to the list of instructions, set the
<tt>flag</tt> so that the evaluator will go to <tt>external-entry</tt>, and start
the evaluator.</p>

<p class="trans" lang="ja">
手続き定義をコンパイルし、そのコンパイル済みコードを実行し、その手続きを試すことができるように読み取り・評価・印字ループを実行するために、今や私たちは、以下の手続きをを使うことができる。
コンパイル済みコードには、<tt>val</tt> の中の結果とともに、<tt>continue</tt> の中の場所へと戻って来てほしいので、私たちは、式を、<tt>val</tt> というターゲット、および、<tt>return</tt> というリンケージとともに、コンパイルする。
コンパイラによって作り出されたオブジェクト・コードを、評価器レジスタ・マシンにとって実行可能な命令へと変換するためには、レジスタ・マシン・シミュレータの <tt>assemble</tt> という手続き (<a href="32_sec5_2.html#%_sec_5.2.2">5.2.2</a>節) を使う。
それから、命令のリストを指すように <tt>val</tt> レジスタを初期化し、評価器が <tt>external-entry</tt> へ行くように <tt>flag</tt> をセットし、評価器を始動させる。
</p>

<p class="lisp"><a name="%_idx_6484"></a>(define (compile-and-go expression)
  (let ((instructions
         (assemble (statements
                    (compile expression 'val 'return))
                   eceval)))
    (set! the-global-environment (setup-environment))
    (set-register-contents! eceval 'val instructions)
    (set-register-contents! eceval 'flag true)
    (start eceval)))

</p>

<p class="orig" lang="en">
<a name="%_idx_6486"></a>If we have set up stack monitoring, as at the end of
section <a href="34_sec5_4.html#%_sec_5.4.4">5.4.4</a>, we can examine the
stack usage of compiled code:</p>

<p class="trans" lang="ja">
もし、<a href="34_sec5_4.html#%_sec_5.4.4">5.4.4</a>節の終わりにおけるのと同様にスタック監視を設定済みであれば、コンパイル済みコードのスタック使用を検討できる。
</p>

<p class="lisp">(compile-and-go
 '(define (factorial n)
    (if (= n 1)
        1
        (* (factorial (- n 1)) n))))

<i>(total-pushes = 0 maximum-depth = 0)</i>
<i> ;;; EC-Eval value:</i>
<i>ok</i>
<i> ;;; EC-Eval input:</i>
(factorial 5)
<i>(total-pushes = 31 maximum-depth = 14)</i>
<i>;;; EC-Eval value:</i>
<i>120</i>
</p>

<p class="orig" lang="en"><a name="%_idx_6488"></a>Compare this example with the evaluation of <tt>(factorial 5)</tt> using
the interpreted version of the same procedure, shown at the end of
section <a href="34_sec5_4.html#%_sec_5.4.4">5.4.4</a>.  The interpreted version required
144 pushes and a maximum stack depth of 28.  This illustrates the
optimization that results from our compilation strategy.</p>

<p class="trans" lang="ja">
この例を、<a href="34_sec5_4.html#%_sec_5.4.4">5.4.4</a>節の最後に示した、同じ手続きの解釈されたバージョンを用いた、<tt>(factorial 5)</tt> の評価と比較せよ。
解釈されたバージョンは、144 回のプッシュと、28 という最大スタック深さを要した。
これは、私たちのコンパイル戦略に起因する最適化を例示している。
</p>


<p class="extra" id="translating">***ここから</p>
<a name="%_sec_Temp_836"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_836">Interpretation and compilation</a></h4>
<h4 class="trans" lang="ja">解釈とコンパイル</h4>

<p class="orig" lang="en"><a name="%_idx_6490"></a><a name="%_idx_6492"></a>
With the programs in this section, we can now experiment with the
alternative execution strategies of interpretation and
compilation.<a name="call_footnote_Temp_837" href="#footnote_Temp_837"><sup><small>51</small></sup></a>  An interpreter raises
the machine to the level of the user program; a compiler lowers the
user program to the level of the machine language.  We can regard the
Scheme language (or any programming language) as a coherent family of
abstractions erected on the machine language.  Interpreters are good
for interactive program development and debugging because the steps of
program execution are organized in terms of these abstractions, and
are therefore more intelligible to the programmer.  Compiled code can
execute faster, because the steps of program execution are organized
in terms of the machine language, and the compiler is free to make
optimizations that cut across the higher-level
abstractions.<a name="call_footnote_Temp_838" href="#footnote_Temp_838"><sup><small>52</small></sup></a></p>

<p class="trans" lang="ja">
</p>

<p class="orig" lang="en">
The alternatives of interpretation and compilation also lead to
<a name="%_idx_6504"></a>different strategies for porting languages to new computers. Suppose
that we wish to implement Lisp for a new machine.  One strategy is
to begin with the explicit-control evaluator of section <a href="34_sec5_4.html#%_sec_5.4">5.4</a>
and translate its instructions to instructions for the
new machine.  A different strategy is to begin with the compiler and
change the code generators so that they generate code for the new
machine.  The second strategy allows us to run any Lisp program on
the new machine by first compiling it with the compiler running on our
original Lisp system, and linking it with a compiled version of the
run-time library.<a name="call_footnote_Temp_839" href="#footnote_Temp_839"><sup><small>53</small></sup></a>  Better yet, we can compile the compiler itself, and run
this on the new machine to compile other Lisp programs.<a name="call_footnote_Temp_840" href="#footnote_Temp_840"><sup><small>54</small></sup></a>  Or we can
compile one of the interpreters of section <a href="26_sec4_1.html#%_sec_4.1">4.1</a> to
produce an interpreter that runs on the new machine.</p>

<p class="trans" lang="ja">
</p>

<p class="orig" lang="en">
<a name="%_thm_5.45"></a>
<b>Exercise 5.45.</b>  <a name="%_idx_6506"></a><a name="%_idx_6508"></a>By comparing the stack operations used by compiled code to the stack
operations used by the evaluator for the same computation, we can
determine the extent to which the compiler optimizes use of the stack,
both in speed (reducing the total number of stack operations) and in
space (reducing the maximum stack depth).  Comparing this optimized
stack use to the performance of a special-purpose machine for the same
computation gives some indication of the quality of the compiler.</p>

<p class="trans" lang="ja">
<b>練習問題5.45.</b> 
</p>

<ol class="orig alph" lang="en">
<li>Exercise <a href="34_sec5_4.html#%_thm_5.27">5.27</a> asked you to determine, as a function of
<em>n</em>, the number of pushes and the maximum stack depth needed by the
evaluator to compute <em>n</em>! using the recursive factorial procedure
given above.  Exercise <a href="32_sec5_2.html#%_thm_5.14">5.14</a> asked you to do the same
measurements for the special-purpose factorial machine shown in
figure <a href="31_sec5_1.html#%_fig_5.11">5.11</a>. Now perform the same analysis using the
compiled <tt>factorial</tt> procedure.
<br>
Take the ratio of the number of pushes in the compiled version to the
number of pushes in the interpreted version, and do the same for the
maximum stack depth.  Since the number of operations and the stack
depth used to compute <em>n</em>! are linear in <em>n</em>, these ratios should
approach constants as <em>n</em> becomes large.  What are these constants?
Similarly, find the ratios of the stack usage in the special-purpose
machine to the usage in the interpreted version.
<br>
Compare the ratios for special-purpose versus interpreted code to the ratios
for compiled versus interpreted code.  You should find that the
special-purpose machine does much better than the compiled code, since
the hand-tailored controller code should be much better than what is
produced by our rudimentary general-purpose compiler.</li>

<li>Can you suggest improvements to the compiler that would help it
generate code that would come closer in performance to the
hand-tailored version?</li>
</ol>

<ol class="trans alph" lang="ja">
<li></li>
<li></li>
</ol>


<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.46"></a>
<b>Exercise 5.46.</b>  <a name="%_idx_6510"></a><a name="%_idx_6512"></a>Carry out an analysis like the one in
exercise <a href="#%_thm_5.45">5.45</a> to determine the effectiveness of
compiling the tree-recursive Fibonacci procedure</p>

<p class="trans" lang="ja">
<b>練習問題5.46.</b> 
</p>

<p class="lisp">(define (fib n)
  (if (&lt; n 2)
      n
      (+ (fib (- n 1)) (fib (- n 2)))))
</p>

<p class="orig" lang="en">compared to the effectiveness of using the special-purpose Fibonacci machine of
figure <a href="31_sec5_1.html#%_fig_5.12">5.12</a>.  (For measurement of the interpreted
performance, see exercise <a href="34_sec5_4.html#%_thm_5.29">5.29</a>.)
For Fibonacci, the time resource used is not linear in <em>n</em>; hence the
ratios of stack operations will not approach a limiting value that is
independent of <em>n</em>.
</p>

<p class="trans" lang="ja">
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.47"></a>
<b>Exercise 5.47.</b>  This section described how to modify the explicit-control evaluator so
that interpreted code can call compiled procedures.  Show how to
modify the compiler so that compiled procedures can call not only
primitive procedures and compiled procedures, but interpreted
procedures as well.  This requires modifying <tt>compile-procedure-call</tt>
to handle the case of compound (interpreted) procedures.
Be sure to handle all the same <tt>target</tt> and <tt>linkage</tt> combinations
as in <tt>compile-proc-appl</tt>.  To do the actual procedure application,
the code needs to jump to the evaluator's <tt>compound-apply</tt> entry point.
This label cannot be directly referenced in object code
(since the assembler requires that all labels referenced by the
code it is assembling be defined there), so we will add a register
called <tt>compapp</tt> to the evaluator machine to hold this
entry point, and add an instruction to initialize it:
</p>

<p class="trans" lang="ja">
<b>練習問題5.47.</b> 
</p>

<p class="lisp">  (assign compapp (label compound-apply))
  (branch (label external-entry))      <em>; branches if <tt>flag</tt> is set</em>
read-eval-print-loop
  <tt>...</tt></p>


<p class="orig" lang="en">To test your code, start by defining a procedure <tt>f</tt> that calls a
procedure <tt>g</tt>.  Use <tt>compile-and-go</tt> to compile the definition
of <tt>f</tt> and start the evaluator.  Now, typing at the evaluator,
define <tt>g</tt> and try to call <tt>f</tt>.
</p>

<p class="trans" lang="ja">
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.48"></a>
<b>Exercise 5.48.</b>  <a name="%_idx_6514"></a>The <tt>compile-and-go</tt> interface implemented in this section is
awkward, since the compiler can be called only once (when the
evaluator machine is started).  Augment the compiler-interpreter
interface by providing a <tt>compile-and-run</tt> primitive that can be
called from within the explicit-control evaluator as follows:</p>

<p class="trans" lang="ja">
<b>練習問題5.48.</b> 
</p>

<p class="lisp"><i>;;; EC-Eval input:</i>
(compile-and-run
 '(define (factorial n)
    (if (= n 1)
        1
        (* (factorial (- n 1)) n))))
<i>;;; EC-Eval value:</i>
<i>ok</i>
<i>;;; EC-Eval input:</i>
(factorial 5)
<i>;;; EC-Eval value:</i>
<i>120</i>
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.49"></a>
<b>Exercise 5.49.</b>  As an alternative to using the explicit-control evaluator's
read-eval-print loop, design a register machine that performs a
read-compile-execute-print loop.  That is, the machine should run a
loop that reads an expression, compiles it, assembles and
executes the resulting code, and prints the result.  This is easy to
run in our simulated setup, since we can arrange to call the
procedures <tt>compile</tt> and <tt>assemble</tt> as ``register-machine
operations.''
</p>

<p class="trans" lang="ja">
<b>練習問題5.49.</b> 
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.50"></a>
<b>Exercise 5.50.</b>  <a name="%_idx_6516"></a>Use the compiler to compile the metacircular evaluator of
section <a href="26_sec4_1.html#%_sec_4.1">4.1</a> and run this program using the register-machine
simulator.  (To compile more than one definition at a time, you can
package the definitions in a <tt>begin</tt>.)  The resulting interpreter
will run very slowly because of the multiple levels of interpretation,
but getting all the details to work is an instructive exercise.
</p>

<p class="trans" lang="ja">
<b>練習問題5.50.</b> 
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.51"></a>
<b>Exercise 5.51.</b>  <a name="%_idx_6518"></a>Develop a rudimentary implementation of Scheme in C (or some other
low-level language of your choice) by translating the explicit-control
evaluator of section <a href="34_sec5_4.html#%_sec_5.4">5.4</a> into C.  In order to run this code
you will need to also
provide appropriate storage-allocation routines and other run-time
support.
</p>

<p class="trans" lang="ja">
<b>練習問題5.51.</b> 
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.52"></a>
<b>Exercise 5.52.</b>  <a name="%_idx_6520"></a><a name="%_idx_6522"></a><a name="%_idx_6524"></a>As a counterpoint to exercise <a href="#%_thm_5.51">5.51</a>, modify the compiler
so that it compiles Scheme procedures into sequences of C
instructions.  Compile the metacircular evaluator of
section <a href="26_sec4_1.html#%_sec_4.1">4.1</a> to produce a Scheme interpreter written in C.
</p>

<p class="trans" lang="ja">
<b>練習問題5.52.</b> 
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="footnotes"></a>
<hr>

<p class="orig" lang="en"><a name="footnote_Temp_794" href="#call_footnote_Temp_794"><sup><small>33</small></sup></a> This is a theoretical statement.  We are not claiming
that the evaluator's data paths are a particularly convenient or
efficient set of data paths for a general-purpose computer.  For example,
they are not very good for implementing high-performance floating-point
calculations or calculations that intensively manipulate bit vectors.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_794"><sup><small>33</small></sup></a>
これは理論上の陳述である。
評価器のデータ経路が、汎用コンピュータ用のデータ経路の、特に便利または効率的な集合である、と主張しているわけではないのだ。
たとえば、それらのデータ経路は、高性能の浮動小数点計算や、あるいは、ビット・ベクタを徹底的に操作しまくる計算を実装するのには、非常に適しているという訳ではない。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_795" href="#call_footnote_Temp_795"><sup><small>34</small></sup></a> Actually, the machine that runs
compiled code can be simpler than the interpreter machine, because we
<a name="%_idx_6220"></a>won't use the <tt>exp</tt> and <tt>unev</tt> registers.  The interpreter
used these to hold pieces of unevaluated expressions.  With the
compiler, however, these expressions get built into the
compiled code that the register machine will run.  For the same
reason, <a name="%_idx_6222"></a>we don't need the machine operations that deal with expression
syntax.  But compiled code will use a few additional machine
operations (to represent compiled procedure objects) that didn't
appear in the explicit-control evaluator machine.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_795"><sup><small>34</small></sup></a>
実際のところ、コンパイルされたコードを動かすマシンは、インタプリタ・マシンよりも単純になり得る。なぜなら、私たちは、<tt>exp</tt> レジスタと <tt>unev</tt> レジスタを使わないだろうから。
インタプリタは、未評価の式のかけらを保持するために、これらのレジスタを使った。
しかし、コンパイラがあれば、これらの式は、レジスタ・マシンが動かすであろう、コンパイルされたコードの中に、組み込まれるようになる。
同じ理由のため、私たちは、式の文法を扱うマシン演算を必要としない。
しかし、コンパイルされたコードは、明示的制御方式の評価器マシンには出てこなかった、(コンパイルされた手続きオブジェクトを表現するための) 少数の付加的なマシン演算を、使うだろう。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_797" href="#call_footnote_Temp_797"><sup><small>35</small></sup></a> Notice, however, that our
compiler is a Scheme program, and the syntax procedures that it uses
to manipulate expressions are the actual Scheme procedures used with
the metacircular evaluator.  For the explicit-control evaluator, in
contrast, we assumed that equivalent syntax operations were available
as operations for the register machine.  (Of course, when we simulated
the register machine in Scheme, we used the actual Scheme procedures
in our register machine simulation.)
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_797"><sup><small>35</small></sup></a>
しかし、私たちのコンパイラは Scheme プログラムなのだということ、そして、このコンパイラが式を操作するために使う文法手続きは、メタ循環的なインタプリタとともに使われた現実の Scheme 手続きなのだということに、注意してほしい。
対照的に、明示的制御方式の評価器について私たちは、等価な文法的演算がレジスタ・マシン用の演算として利用可能なのだ、と想定した
(もちろん、私たちがレジスタ・マシンを Scheme でシミュレートする際には、現実の Scheme 手続きをレジスタ・マシン・シミュレーションにおいて使った)。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_803" href="#call_footnote_Temp_803"><sup><small>36</small></sup></a> This procedure uses a feature of Lisp called <em><a name="%_idx_6280"></a><a name="%_idx_6282"></a><a name="%_idx_6284"></a><a name="%_idx_6286"></a><a name="%_idx_6288"></a><a name="%_idx_6290"></a>backquote</em> (or <em>quasiquote</em>) that is handy for constructing lists.
Preceding a list with a backquote symbol is much like quoting it,
except that anything in the list that is flagged with a comma is evaluated.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_803"><sup><small>36</small></sup></a>
この手続きは、リストを構築するのに便利な、<em>バッククオート</em> (または<em>準クオート</em>) と呼ばれる Lisp の機能を利用する。
リストをバッククオート記号で始めることは、リスト内においてカンマで印が付けられたものは何でも評価されるという点を除いて、リストを<ruby><rb>引用</rb><rp> (</rp><rt>クオート</rt><rp>) </rp></ruby>することとそっくりだ。
</p>

<p class="orig" lang="en">
For example, if the value of <tt>linkage</tt> is the symbol
<tt>branch25</tt>, then the expression
<tt>`((goto (label ,linkage)))</tt>
evaluates to the list
<tt>((goto (label branch25)))</tt>.
Similarly, if the value of <tt>x</tt> is the list <tt>(a b c)</tt>, then
<tt>`(1 2 ,(car x))</tt>
evaluates to the list
<tt>(1 2 a)</tt>.
</p>

<p class="trans" lang="ja">
たとえば、<tt>linkage</tt> の値が <tt>branch25</tt> という記号であれば、
<tt>`((goto (label ,linkage)))</tt>
という式は、
<tt>((goto (label branch25)))</tt>
というリストへと評価される。
同様に、<tt>x</tt> の値が <tt>(a b c)</tt> というリストであれば、
<tt>`(1 2 ,(car x))</tt>
という式は、
<tt>(1 2 a)</tt>
というリストへと評価される。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_806" href="#call_footnote_Temp_806"><sup><small>37</small></sup></a> We can't just
use the labels <tt>true-branch</tt>, <tt>false-branch</tt>, and
<tt>after-if</tt> as shown above,
because there might be more than one <tt>if</tt> in the program.
<a name="%_idx_6318"></a>The compiler uses the procedure <tt>make-label</tt> to generate labels.
<tt>Make-label</tt> takes a symbol as argument and returns a new symbol
that begins with the given symbol.  For example, successive calls to
<tt>(make-label 'a)</tt> would return <tt>a1</tt>, <tt>a2</tt>, and so on.
<tt>Make-label</tt> can be implemented similarly to the generation of
unique variable names in the query language, as follows:
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_806"><sup><small>37</small></sup></a>
上記で示したように、ただ単に <tt>true-branch</tt> と <tt>false-branch</tt> と <tt>after-if</tt> というラベルを使ってはならない。なぜなら、プログラム中には、一つよりも多くの <tt>if</tt> があるかもしれないからだ。
コンパイラは、ラベルを生成するために <tt>make-label</tt> という手続きを使う。
<tt>make-label</tt> は、引数として記号をとり、その与えられた記号から始まる新たな記号を返す。
たとえば、<tt>(make-label 'a)</tt> に対する連続した呼び出しは、<tt>a1</tt>、<tt>a2</tt> などを返すだろう。
以下のとおり、クエリ言語における一意的な変数名の生成と同様にして、<tt>make-label</tt> を実装できる。
</p>

<p class="lisp">(define label-counter 0)

(define (new-label-number)
  (set! label-counter (+ 1 label-counter))
  label-counter)

<a name="%_idx_6320"></a><a name="%_idx_6322"></a>(define (make-label name)
  (string-&gt;symbol
    (string-append (symbol-&gt;string name)
                   (number-&gt;string (new-label-number)))))
</p>



<p class="orig" lang="en"><a name="footnote_Temp_809" href="#call_footnote_Temp_809"><sup><small>38</small></sup></a> We need machine operations to implement a data
structure for representing compiled procedures, analogous to the structure for
compound procedures described in section <a href="26_sec4_1.html#%_sec_4.1.3">4.1.3</a>:
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_809"><sup><small>38</small></sup></a>
コンパイルされた手続きを表すためのデータ構造——<a href="26_sec4_1.html#%_sec_4.1.3">4.1.3</a>節で説明した複合的な手続きのための構造に類似のもの——を実装する、マシン演算が必要である。
</p>


<p class="lisp"><a name="%_idx_6332"></a>(define (make-compiled-procedure entry env)
  (list 'compiled-procedure entry env))

<a name="%_idx_6334"></a>(define (compiled-procedure? proc)
  (tagged-list? proc 'compiled-procedure))

<a name="%_idx_6336"></a>(define (compiled-procedure-entry c-proc) (cadr c-proc))

<a name="%_idx_6338"></a>(define (compiled-procedure-env c-proc) (caddr c-proc))
</p>


<p class="orig" lang="en"><a name="footnote_Temp_812" href="#call_footnote_Temp_812"><sup><small>39</small></sup></a> Actually, we signal an error when the target is not <tt>val</tt>
and the linkage is <tt>return</tt>, since
the only place we request <tt>return</tt> linkages is in compiling
procedures, and our convention is that procedures return their
values in <tt>val</tt>.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_812"><sup><small>39</small></sup></a>
実際、ターゲットが <tt>val</tt> ではなく、かつ、リンケージが <tt>return</tt> のとき、私たちはエラーの合図を出す。なぜなら、私たちが <tt>return</tt> リンケージを要求する唯一の場所は、手続きをコンパイルする最中にあるからであり、また、私たちの慣習は、手続きは値を <tt>val</tt> に返す、というものだからである。
</p>


<p class="orig" lang="en"><a name="footnote_Temp_813" href="#call_footnote_Temp_813"><sup><small>40</small></sup></a> Making a
<a name="%_idx_6356"></a>compiler generate tail-recursive code might seem like a
straightforward idea.  But most compilers for common languages,
including C and Pascal, do not do this, and therefore these languages
cannot represent iterative processes in terms of procedure call alone.
The difficulty with <a name="%_idx_6358"></a><a name="%_idx_6360"></a><a name="%_idx_6362"></a>tail recursion in these languages is that their
implementations use the stack to store procedure arguments and local
variables as well as return addresses.  The Scheme implementations
described in this book store arguments and variables in memory to be
garbage-collected.  The reason for using the stack for variables and
arguments is that it avoids the need for garbage collection in
languages that would not otherwise require it, and is generally
believed to be more efficient.  Sophisticated Lisp compilers can, in
fact, use the stack for arguments without destroying tail recursion.
(See <a name="%_idx_6364"></a>Hanson 1990 for a description.)  There is also some debate about
whether stack allocation is actually more efficient than garbage
collection in the first place, but the details seem to hinge on fine
points of computer architecture.  (See <a name="%_idx_6366"></a>Appel 1987 and <a name="%_idx_6368"></a><a name="%_idx_6370"></a>Miller and Rozas
1994 for opposing views on this issue.)
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_813"><sup><small>40</small></sup></a>
コンパイラに末尾再帰的なコードを生成させることは、分かりやすい考え方のように見えるかもしれない。
しかし、C や Pascal を含む普通の言語に対するほとんどのコンパイラは、こうしたことを行わないし、それゆえに、これらの言語は、手続き呼び出しだけを用いて反復的プロセスを表現することができない。
これらの言語での末尾再帰にともなう厄介な点は、これらの言語の実装が、スタックを使って、戻りアドレスだけでなく手続き引数と局所変数をも記憶していることである。
本書に記述した Scheme の実装は、ガーベジ・コレクションされるべきメモリ<span class="note"> (ヒープ領域) </span>の中に、引数と変数を記憶する。
変数と引数のためにスタックを使う理由は、そうすることによって、それ以外の場合には<span class="note"> (スタックに記憶したものが不要になったときにポップしていく場合以外には、ということ?) </span>ガーベジ・コレクションを必要としないであろう言語における、ガーベジ・コレクションの必要性を避けることになるためであり、そうすること<span class="note"> (引数と変数のためにスタックを使うこと) </span>がより効率的なのだ、と一般に信じされているためである。
洗練された Lisp コンパイラは、実際に、末尾再帰を破壊することなく、引数用にスタックを使うことが可能だ (説明については Hanson 1990 を参照)。
そもそも、実際にガーベジ・コレクションよりもスタック割り当ての方が効率的なのか、という議論もいくらかあるのだが、その詳細は、コンピュータ・アーキテクチャの細かい点に依存するように思われる (この論点についての相反する見方については、Appel 1987 と Miller and Rozas 1994 を参照)。
</p>


<p class="orig" lang="en"><a name="footnote_Temp_814" href="#call_footnote_Temp_814"><sup><small>41</small></sup></a> The variable
<a name="%_idx_6372"></a><tt>all-regs</tt> is bound to the list of names of all the registers:
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_814"><sup><small>41</small></sup></a>
<tt>all-regs</tt> という変数が、すべてのレジスタの名前のリストに束縛される。
</p>


<p class="lisp"><a name="%_idx_6374"></a>(define all-regs '(env proc val argl continue))
</p>

<p class="orig" lang="en"><a name="footnote_Temp_815" href="#call_footnote_Temp_815"><sup><small>42</small></sup></a> Note that <tt>preserving</tt> calls <tt>append</tt> with three
<a name="%_idx_6396"></a>arguments.  Though the definition of <tt>append</tt> shown in this book
accepts only two arguments, Scheme standardly provides an <tt>append</tt>
procedure that takes an arbitrary number of arguments.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_815"><sup><small>42</small></sup></a>
<tt>preserving</tt> が三つの引数とともに <tt>append</tt> を呼び出すことに注意してほしい。
本書で示した <tt>append</tt> の定義は二つの引数のみを受け入れるが、Scheme は、任意の個数の引数をとる <tt>append</tt> 手続きを標準的に提供している。
</p>


<p class="orig" lang="en"><a name="footnote_Temp_822" href="#call_footnote_Temp_822"><sup><small>43</small></sup></a> We have used
the same symbol <tt>+</tt> here to denote both the source-language
procedure and the machine operation.  In general there will not be a
one-to-one correspondence between primitives of the source language
and primitives of the machine.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_822"><sup><small>43</small></sup></a>
ここでは、ソース言語の手続きと、マシン演算の双方を示すのに、<tt>+</tt> という同じ記号を用いた。
一般には、ソース言語のプリミティブとマシンのプリミティブとの間には、一対一対応は存在しないだろう。
</p>


<p class="orig" lang="en"><a name="footnote_Temp_823" href="#call_footnote_Temp_823"><sup><small>44</small></sup></a> Making the primitives into reserved
words is in general a bad idea, since a user cannot then rebind these
names to different procedures.  Moreover, if we add reserved words to
a compiler that is in use, existing programs that define procedures
with these names will stop working.  See
exercise <a href="#%_thm_5.44">5.44</a> for ideas on how to avoid this
problem.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_823"><sup><small>44</small></sup></a>
プリミティブを予約語にすることは、一般には悪い考え方だ。というのも、そうするとユーザがこれらの名前を別の手続きへと束縛し直すことができないからである。
さらに、もし使用中のコンパイラに予約語を加えると、これらの名前を用いた手続きを定義している既存のプログラムが、動かなくなってしまうだろう。
この問題をどう避けるかについての考え方については、練習問題<a href="#%_thm_5.44">5.44</a>を参照せよ。
</p>


<p class="orig" lang="en"><a name="footnote_Temp_824" href="#call_footnote_Temp_824"><sup><small>45</small></sup></a> This is not true if we allow
internal definitions, unless we scan them out.
See exercise <a href="#%_thm_5.43">5.43</a>.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_824"><sup><small>45</small></sup></a>
これは、内部定義を許す場合には、内部定義を走査し尽くすのでない限り、真ではない。
練習問題<a href="#%_thm_5.43">5.43</a>を参照のこと。
</p>


<p class="orig" lang="en"><a name="footnote_Temp_826" href="#call_footnote_Temp_826"><sup><small>46</small></sup></a> This is the modification to variable lookup
<a name="%_idx_6446"></a><a name="%_idx_6448"></a>required if we implement the scanning method to eliminate internal
definitions (exercise <a href="#%_thm_5.43">5.43</a>).  We will need
to eliminate these definitions in order for lexical addressing to
work.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_826"><sup><small>46</small></sup></a>
これは、内部定義を削除するための走査方法 (練習問題<a href="#%_thm_5.43">5.43</a>) を実装するときに必要とされる変数ルックアップに対する改変である。
私たちは、レキシカル・アドレシングがうまく動くようにするために、これらの定義を削除する必要があるだろう。
</p>


<p class="orig" lang="en"><a name="footnote_Temp_830" href="#call_footnote_Temp_830"><sup><small>47</small></sup></a> Lexical addresses cannot be used to access variables in the global
environment, because these names can be defined and redefined
interactively at any time.  With internal definitions scanned out, as
in exercise <a href="#%_thm_5.43">5.43</a>, the only definitions the
compiler sees are those at top level, which act on the global
environment.  Compilation of a definition does not cause the defined
name to be entered in the compile-time environment.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_830"><sup><small>47</small></sup></a>
レキシカル・アドレスは、大域環境内の変数にアクセスするためには使えない。なぜなら、これらの名前は、任意の時点においてインタラクティブに定義され得るし、また、再定義もされ得るからである。
練習問題<a href="#%_thm_5.43">5.43</a>のように内部定義を走査し尽くす場合には、コンパイラが目にする定義は、ただ、トップレベルの定義——大域環境上で動作する——のみである。
定義をコンパイルすることが、定義済みの名前をコンパイル時環境に入らせる、というわけではないのだ。
</p>


<p class="orig" lang="en"><a name="footnote_Temp_833" href="#call_footnote_Temp_833"><sup><small>48</small></sup></a> Of course, compiled procedures as well as interpreted
procedures are compound (nonprimitive).  For compatibility with
the terminology used in the explicit-control evaluator, in this
section we will use ``compound'' to mean interpreted (as opposed
to compiled).
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_833"><sup><small>48</small></sup></a>
もちろん、解釈済み手続きだけでなくコンパイル済み手続きも、複合的 (非原始的) である。
明示的制御方式の評価器で用いた用語法との一致のために、本節では、(コンパイル済みではなく) 解釈済みということを意味するために、「複合的」<span class="note">(という言葉)</span> を用いよう。
</p>


<p class="orig" lang="en"><a name="footnote_Temp_834" href="#call_footnote_Temp_834"><sup><small>49</small></sup></a> Now that the evaluator machine starts
with a <tt>branch</tt>, we must always initialize the <tt>flag</tt> register
before starting the evaluator machine.  To start the machine at
its ordinary read-eval-print loop, we could use
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_834"><sup><small>49</small></sup></a>
今や評価器マシンは <tt>branch</tt> とともに始動するわけだから、私たちは常に、評価器マシンを始動させる前に <tt>flag</tt> レジスタを初期化せねばならない。
通常の読み取り・評価・印字ループからマシンを始動させるには、私たちは、以下のものを使えることだろう。
</p>


<p class="lisp"><a name="%_idx_6478"></a>(define (start-eceval)
  (set! the-global-environment (setup-environment))
  (set-register-contents! eceval 'flag false)
  (start eceval))
</p>

<p class="orig" lang="en"><a name="footnote_Temp_835" href="#call_footnote_Temp_835"><sup><small>50</small></sup></a> Since a compiled procedure is an
object that the system may try to print, we also modify the system
print operation <tt>user-print</tt> (from section <a href="26_sec4_1.html#%_sec_4.1.4">4.1.4</a>)
so that it will not attempt to print the
components of a compiled procedure:
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_835"><sup><small>50</small></sup></a>
コンパイル済み手続きは、システムが印字しようとするかもしれないオブジェクトであるから、私たちは、(<a href="26_sec4_1.html#%_sec_4.1.4">4.1.4</a>節の) <a href="26_sec4_1.html#%_idx_4538"><tt>user-print</tt> というシステム印字演算</a>がコンパイル済み手続きの構成要素を印字しようと試みないように、<tt>user-print</tt> をも改変する。
</p>


<p class="lisp"><a name="%_idx_6480"></a>(define (user-print object)
  (cond ((compound-procedure? object)
         (display (list 'compound-procedure
                        (procedure-parameters object)
                        (procedure-body object)
                        '&lt;procedure-env&gt;)))
        ((compiled-procedure? object)
         (display '&lt;compiled-procedure&gt;))
        (else (display object))))
</p>


<p class="orig" lang="en"><a name="footnote_Temp_837" href="#call_footnote_Temp_837"><sup><small>51</small></sup></a> We can do even better by extending the compiler
to allow compiled code to call interpreted procedures.  See
exercise <a href="#%_thm_5.47">5.47</a>.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_837"><sup><small>51</small></sup></a>
</p>


<p class="orig" lang="en"><a name="footnote_Temp_838" href="#call_footnote_Temp_838"><sup><small>52</small></sup></a> Independent of the strategy of execution, we
<a name="%_idx_6494"></a>incur significant overhead if we insist that errors encountered in
execution of a user program be detected and signaled, rather than being
allowed to kill the system or produce wrong answers.  For example, an
out-of-bounds array reference can be detected by checking the validity
of the reference before performing it.  The overhead of checking,
however, can be many times the cost of the array reference itself, and
a programmer should weigh speed against safety in determining whether
such a check is desirable.  A good compiler should be able to produce
code with such checks, should avoid redundant checks, and should allow
programmers to control the extent and type of error checking in the
compiled code.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_838"><sup><small>52</small></sup></a>
</p>

<p class="orig" lang="en">
<a name="%_idx_6496"></a>Compilers for popular languages, such as C and C++,
put hardly any error-checking operations into
running code, so as to make things run as fast as possible.  As a
result, it falls to programmers to explicitly provide error checking.
Unfortunately, people often neglect to do this, even in
critical applications where speed is not a constraint.  Their programs
lead fast and dangerous lives.  For example, the notorious <a name="%_idx_6498"></a>``Worm''
that paralyzed the Internet in 1988 exploited the <a name="%_idx_6500"></a>UNIX<sup> <em>T</em><em>M</em></sup>
operating system's failure to check whether the input buffer has
<a name="%_idx_6502"></a>overflowed in the finger daemon. (See Spafford 1989.)
</p>

<p class="trans" lang="ja">
</p>


<p class="orig" lang="en"><a name="footnote_Temp_839" href="#call_footnote_Temp_839"><sup><small>53</small></sup></a> Of course, with either the
interpretation or the compilation strategy we must also implement for
the new machine storage allocation, input and output, and all the
various operations that we took as ``primitive'' in our discussion of
the evaluator and compiler.  One strategy for minimizing work here is
to write as many of these operations as possible in Lisp and then
compile them for the new machine.  Ultimately, everything reduces to a
small kernel (such as garbage collection and the mechanism for
applying actual machine primitives) that is hand-coded for the new
machine.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_839"><sup><small>53</small></sup></a>
</p>


<p class="orig" lang="en"><a name="footnote_Temp_840" href="#call_footnote_Temp_840"><sup><small>54</small></sup></a> 
This strategy leads to amusing tests of correctness of
the compiler, such as checking
whether the compilation of a program on the new machine, using the
compiled compiler, is identical with the
compilation of the program on the original Lisp system.  Tracking
down the source of differences is fun but often frustrating, because
the results are extremely sensitive to minuscule details.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_840"><sup><small>54</small></sup></a>
</p>

</div>
</body>
</html>
