<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<link rel="stylesheet" href="sicp.css" type="text/css">
	<base target="_top">
	<title>Structure and Interpretation of Computer Programs: SICP私訳</title>
</head>

<body>

<div class="idx-bar">
<nav>
<a href="https://twitter.com/share" class="twitter-share-button" data-lang="ja">ツイート</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
<span class="status">推敲待ち</span>
[
<a href="00_cover.html">先頭へ</a> |
<a href="14_sec2_1.html">前へ</a> |
<a href="16_sec2_3.html">次へ</a> | 
<a href="04_toc.html#%_toc_start">目次</a> |
<a href="38_index.html#%_index_start">索引</a>
] [<a href="99_about.html">この対訳版について</a> | <a href="../index.html">ホーム</a>]
[
§<a href="#%_sec_2.2">2.2</a>
🎨<a href="#%_fig_2.2">2.2</a>
🎨<a href="#%_fig_2.3">2.3</a>
§<a href="#%_sec_2.2.1">2.2.1</a>
🎨<a href="#%_fig_2.4">2.4</a>
📚<a href="#%_sec_Temp_159">&hellip;</a>
📝<a href="#%_thm_2.17">2.17</a>
📝<a href="#%_thm_2.18">2.18</a>
📝<a href="#%_thm_2.19">2.19</a>
📝<a href="#%_thm_2.20">2.20</a>
📚<a href="#%_sec_Temp_165">&hellip;</a>
📝<a href="#%_thm_2.21">2.21</a>
📝<a href="#%_thm_2.22">2.22</a>
📝<a href="#%_thm_2.23">2.23</a>
§<a href="#%_sec_2.2.2">2.2.2</a>
🎨<a href="#%_fig_2.5">2.5</a>
🎨<a href="#%_fig_2.6">2.6</a>
📝<a href="#%_thm_2.24">2.24</a>
📝<a href="#%_thm_2.25">2.25</a>
📝<a href="#%_thm_2.26">2.26</a>
📝<a href="#%_thm_2.27">2.27</a>
📝<a href="#%_thm_2.28">2.28</a>
📝<a href="#%_thm_2.29">2.29</a>
📚<a href="#%_sec_Temp_177">&hellip;</a>
📝<a href="#%_thm_2.30">2.30</a>
📝<a href="#%_thm_2.31">2.31</a>
📝<a href="#%_thm_2.32">2.32</a>
§<a href="#%_sec_2.2.3">2.2.3</a>
🎨<a href="#%_fig_2.7">2.7</a>
📚<a href="#%_sec_Temp_181">&hellip;</a>
📝<a href="#%_thm_2.33">2.33</a>
📝<a href="#%_thm_2.34">2.34</a>
📝<a href="#%_thm_2.35">2.35</a>
📝<a href="#%_thm_2.36">2.36</a>
📝<a href="#%_thm_2.37">2.37</a>
📝<a href="#%_thm_2.38">2.38</a>
📝<a href="#%_thm_2.39">2.39</a>
📚<a href="#%_sec_Temp_193">&hellip;</a>
📝<a href="#%_thm_2.40">2.40</a>
📝<a href="#%_thm_2.41">2.41</a>
📝<a href="#%_thm_2.42">2.42</a>
🎨<a href="#%_fig_2.8">2.8</a>
📝<a href="#%_thm_2.43">2.43</a>
§<a href="#%_sec_2.2.4">2.2.4</a>
🎨<a href="#%_fig_2.9">2.9</a>
📚<a href="#%_sec_Temp_203">&hellip;</a>
🎨<a href="#%_fig_2.10">2.10</a>
🎨<a href="#%_fig_2.11">2.11</a>
🎨<a href="#%_fig_2.12">2.12</a>
🎨<a href="#%_fig_2.13">2.13</a>
🎨<a href="#%_fig_2.14">2.14</a>
📝<a href="#%_thm_2.44">2.44</a>
📚<a href="#%_sec_Temp_206">&hellip;</a>
📝<a href="#%_thm_2.45">2.45</a>
📚<a href="#%_sec_Temp_210">&hellip;</a>
🎨<a href="#%_fig_2.15">2.15</a>
📝<a href="#%_thm_2.46">2.46</a>
📝<a href="#%_thm_2.47">2.47</a>
📚<a href="#%_sec_Temp_214">&hellip;</a>
📝<a href="#%_thm_2.48">2.48</a>
📝<a href="#%_thm_2.49">2.49</a>
📚<a href="#%_sec_Temp_219">&hellip;</a>
📝<a href="#%_thm_2.50">2.50</a>
📝<a href="#%_thm_2.51">2.51</a>
📚<a href="#%_sec_Temp_224">&hellip;</a>
📝<a href="#%_thm_2.52">2.52</a>
<a href="#footnotes">脚注</a>
]
</nav>

</div>

<div class="main-txt">

<a name="%_sec_2.2"></a>
<h2 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_2.2">2.2  Hierarchical Data and the Closure Property</a></h2>
<h2 class="trans" lang="ja">2.2 階層的データと閉包特性</h2>

<p class="orig" lang="en">
As we have seen, pairs provide a primitive ``glue'' that we can use to
construct compound data objects.
Figure <a href="#%_fig_2.2">2.2</a> shows a standard way to
visualize a <a name="%_idx_1526"></a>pair -- in this case, the pair formed by <tt>(cons 1 2)</tt>.
In this representation, which is called <a name="%_idx_1528"></a><em>box-and-pointer
notation</em>, each object is shown as a <a name="%_idx_1530"></a><em>pointer</em> to a box.  The box
for a primitive object contains a representation of the object.  For
example, the box for a number contains a numeral.  The box for a pair
is actually a double box, the left part containing (a pointer to) the
<tt>car</tt> of the pair and the right part containing the <tt>cdr</tt>.</p>

<p class="trans" lang="ja">
今まで見てきたとおり、対は、複合的データオブジェクトを構築ために使えるプリミティブな「接着剤」を提供してくれる。
図<a href="#%_fig_2.2">2.2</a>は、対——この事例では、<tt>(cons 1 2)</tt> により形成された対——を図像化するための、標準的方法を示している。
この表現——<em>箱・ポインタ式の表記</em>と呼ばれる——では、各オブジェクトは箱への<em>ポインタ</em>として示される。
プリミティブなオブジェクトの箱は、そのオブジェクトの表現を含む。
たとえば、数の箱は、数字を含む。
対の箱は、実際には二連続の箱であり、左の部分はその対の <tt>car</tt> (へのポインタ) を含み、右の部分は <tt>cdr</tt> を含む。
</p>

<p class="orig" lang="en">
We have already seen that <tt>cons</tt> can be used to combine not
only numbers but pairs as well.  (You made use of this fact, or
should have, in doing exercises <a href="14_sec2_1.html#%_thm_2.2">2.2</a>
and <a href="14_sec2_1.html#%_thm_2.3">2.3</a>.)  As a consequence, pairs provide a universal
building block from which we can construct all sorts of data
structures.  Figure <a href="#%_fig_2.3">2.3</a> shows two ways
to use pairs to combine the numbers 1, 2, 3, and 4.</p>

<p class="trans" lang="ja">
<tt>cons</tt> が、数を結合するために使えるだけでなく、対を結合するためにも同様に使える、ということを私たちは既に見た。
(練習問題<a href="14_sec2_1.html#%_thm_2.2">2.2</a>と<a href="14_sec2_1.html#%_thm_2.3">2.3</a>を解くときに、君はこの事実を利用した、あるいは、したはずである。)
結果として、対は、あらゆる種類のデータ構造を構築できる元となる普遍的な基本構成要素を提供する。
図<a href="#%_fig_2.3">2.3</a>は、対を使って1、2、3、4という数を結合するための二つの方法を示している。
</p>

<figure>
<a name="%_fig_2.2"></a>
<img src="ch2-Z-G-11.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 2.2:</b>  Box-and-pointer representation of <tt>(cons 1 2)</tt>.</figcaption>
<figcaption class="trans" lang="ja"><b>図2.2:</b> <tt>(cons 1 2)</tt> の箱・ポインタ式の表現</figcaption>
</figure>

<figure>
<a name="%_fig_2.3"></a>
<img src="ch2-Z-G-12.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 2.3:</b>  Two ways to combine 1, 2, 3, and 4 using pairs.</figcaption>
<figcaption class="trans" lang="ja"><b>図2.3:</b> 対を使って1、2、3、4を結合するための二つの方法</figcaption>
</figure>

<p class="orig" lang="en">The ability to create pairs whose elements are pairs is the essence of
list structure's importance as a representational tool.  We refer to
this ability as the <a name="%_idx_1532"></a><a name="%_idx_1534"></a><em>closure property</em> of <tt>cons</tt>.  In general,
an operation for combining data objects satisfies the closure property
if the results of combining things with that operation can themselves
be combined using the same operation.<a name="call_footnote_Temp_154" href="#footnote_Temp_154"><sup><small>6</small></sup></a>
Closure is the key to power in
any means of combination because it permits us to create <a name="%_idx_1538"></a><a name="%_idx_1540"></a><em>hierarchical</em> structures -- structures made up of parts, which
themselves are made up of parts, and so on.</p>

<p class="trans" lang="ja">
要素が対であるような対を作成する能力は、表現の道具としてのリスト構造の重要性の本質である。
この能力のことを、私たちは、<tt>cons</tt>の<em>閉包特性</em>と呼んでいる。
一般的に、データオブジェクト同士を結合するための演算は、もし、その演算によってもの同士を結合した結果が、それ自体、その同じ演算を用いて結合できるならば、閉包特性を満たす<a href="#footnote_Temp_154"><sup><small>6</small></sup></a>。
閉包は、どの結合手段においても、力につながる鍵である。なぜなら、閉包によって、私たちは、<em>階層的な</em>構造——部分からできあがっている構造であって、それらの部分自体が部分からできあがっていて、といったもの——を作れるようになるからだ。
</p>

<p class="orig" lang="en">From the outset of chapter 1, we've made essential use of closure in
dealing with procedures, because all but the very simplest programs
rely on the fact that the elements of a combination can themselves be
combinations.  In this section, we take up the consequences of closure
for compound data.  We describe some conventional techniques for using
pairs to represent sequences and trees, and we exhibit a graphics
language that illustrates closure in a vivid way.<a name="call_footnote_Temp_155" href="#footnote_Temp_155"><sup><small>7</small></sup></a></p>

<p class="trans" lang="ja">
1章の最初から、私たちは、手続きを扱う際に、既に閉包を本質的に利用していた。というのも、まさに最も単純なもの以外のすべてのプログラムは、コンビネーションの要素はそれ自体がコンビネーションであり得る、という事実に頼っているからだ。
本節では、複合的データに対する閉包の影響を取り上げる。
対を使って列や木を表現するためのいくつかの従来の技法について述べ、それから、鮮やかな方法で閉包を図解するグラフィックス言語を示そう<a href="#footnote_Temp_155"><sup><small>7</small></sup></a>。
</p>

<a name="%_sec_2.2.1"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_2.2.1">2.2.1  Representing Sequences</a></h3>
<h3 class="trans" lang="ja">2.2.1 列を表現する</h3>

<a name="%_fig_2.4"></a>
<figure>
<img src="ch2-Z-G-13.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 2.4:</b>  The sequence 1, 2, 3, 4 represented as a chain of pairs.</figcaption>
<figcaption class="trans" lang="ja"><b>図2.4:</b> 対の連なりとして表現された、1、2、3、4という列</figcaption>
</figure>

<p class="orig" lang="en">One of the useful structures we can build with pairs is a <a name="%_idx_1554"></a><a name="%_idx_1556"></a><a name="%_idx_1558"></a><em>sequence</em> -- an ordered collection of data objects.  There are, of
course, many ways to represent sequences in terms of pairs.  One
particularly straightforward representation is illustrated in
figure <a href="#%_fig_2.4">2.4</a>, where the sequence 1, 2, 3, 4 is
represented as a chain of pairs.  The <tt>car</tt> of each pair is the
corresponding item in the chain, and the <tt>cdr</tt> of the pair is
the next pair in the chain.  The <tt>cdr</tt> of the final pair
signals the end of the sequence by pointing to a distinguished
value that is not a pair,
represented in box-and-pointer diagrams as a diagonal line
<a name="%_idx_1560"></a>and in programs as the value of the variable <a name="%_idx_1562"></a><a name="%_idx_1564"></a><tt>nil</tt>.
The entire sequence is constructed by nested <tt>cons</tt> operations:
</p>

<p class="trans" lang="ja">
対を使って構築できる有用な構造のうちの一つは、<em>列</em>——データオブジェクトの順序付きの集まり——である。
もちろん、対を使って列を表現するには、多くの方法がある。
特に単純な一つの表現が、図<a href="#%_fig_2.4">2.4</a>に示されており、ここでは、1、2、3、4が対の連なりとして表現されている。
各対の <tt>car</tt> は、その連なりの中で対応する項目であり、その対の <tt>cdr</tt> は、その連なりの中の次の対である。
最後の対の <tt>cdr</tt> は、対ではない際立った値を指すことで、列の終わりを知らせており、これは、箱・ポインタ式の図においては斜線で表現され、プログラムにおいては <tt>nil</tt> という変数で表現される。
列全体は、入れ子になった <tt>cons</tt> 演算により構築される。
</p>

<p class="lisp">(cons 1
      (cons 2
            (cons 3
                  (cons 4 nil))))
</p>

<p class="orig" lang="en">
Such a sequence of pairs, formed by nested <tt>cons</tt>es, is called a
<a name="%_idx_1566"></a><em>list</em>, and Scheme provides a
primitive called <a name="%_idx_1568"></a><a name="%_idx_1570"></a><tt>list</tt> to help in constructing lists.<a name="call_footnote_Temp_156" href="#footnote_Temp_156"><sup><small>8</small></sup></a>
The above sequence could be produced by <tt>(list 1 2 3 4)</tt>.  In
general,</p>

<p class="trans" lang="ja">
このような対からなる列——入れ子になった <tt>cons</tt> により形成される——は、<em>リスト</em>と呼ばれ、Schemeは、リストを構築する助けとなるように、<tt>list</tt> と呼ばれるプリミティブを提供している<a href="#footnote_Temp_156"><sup><small>8</small></sup></a>。
上記の列は、<tt>(list 1 2 3 4)</tt> により作り出されたものかもしれない。
一般に、
</p>

<p class="lisp">(list &lt;<em>a<sub>1</sub></em>&gt; &lt;<em>a<sub>2</sub></em>&gt; <tt>...</tt> &lt;<em>a<sub><em>n</em></sub></em>&gt;)
</p>

<p class="orig" lang="en">is equivalent to</p>

<p class="trans" lang="ja">は、以下と等価である。</p>

<p class="lisp">(cons &lt;<em>a<sub>1</sub></em>&gt; (cons &lt;<em>a<sub>2</sub></em>&gt; (cons <tt>...</tt> (cons &lt;<em>a<sub><em>n</em></sub></em>&gt; nil) <tt>...</tt>)))
</p>

<p class="orig" lang="en">
Lisp systems conventionally print lists by printing the sequence of
<a name="%_idx_1576"></a>elements, enclosed in parentheses.  Thus, the data object in
figure <a href="#%_fig_2.4">2.4</a> is printed as <tt>(1 2 3 4)</tt>:</p>

<p class="trans" lang="ja">
Lispシステムは、慣習的に、要素の列を括弧で括って印字することで、リストを印字する。
よって、図<a href="#%_fig_2.4">2.4</a>のデータオブジェクトは、<tt>(1 2 3 4)</tt> のように印字される。
</p>

<p class="lisp">(define one-through-four (list 1 2 3 4))

one-through-four
<i>(1 2 3 4)</i>
</p>

<p class="orig" lang="en">
Be careful not to confuse the expression <tt>(list 1 2 3 4)</tt> with the
list <tt>(1 2 3 4)</tt>, which is the result obtained when the expression
is evaluated.  Attempting to evaluate the expression <tt>(1 2 3 4)</tt> will
signal an error when the interpreter tries to apply the procedure <tt>1</tt> to arguments <tt>2</tt>, <tt>3</tt>, and <tt>4</tt>.</p>

<p class="trans" lang="ja">
<tt>(list 1 2 3 4)</tt> という式と、<tt>(1 2 3 4)</tt> というリスト——その式が評価されたときに得られる結果——を、取り違えないように気をつけよう。
<tt>(1 2 3 4)</tt> という式を評価しようという試みは、インタプリタが <tt>1</tt> という手続きを <tt>2</tt> と <tt>3</tt> と <tt>4</tt> という引数に適用しようとするときに、エラーを知らせてくるだろう。
</p>

<p class="orig" lang="en">
We can think of <a name="%_idx_1578"></a><a name="%_idx_1580"></a><tt>car</tt> as selecting the first item in the list, and
of <a name="%_idx_1582"></a><tt>cdr</tt> as selecting the sublist consisting of all but the first
item.  Nested applications of <tt>car</tt> and <tt>cdr</tt> can be used to
extract the second, third, and subsequent items in the
list.<a name="call_footnote_Temp_157" href="#footnote_Temp_157"><sup><small>9</small></sup></a>
The constructor <a name="%_idx_1592"></a><tt>cons</tt> makes a list like the original one,
but with an additional item at the beginning.</p>

<p class="trans" lang="ja">
<tt>car</tt> は、リストの最初の項目を選択することだと見なせるし、<tt>cdr</tt> は、最初の項目以外のすべてからなる部分リストを選択することだと見なせる。
<tt>car</tt> と <tt>cdr</tt> の、入れ子になった適用は、リスト中の、2番目、3番目、そしてその後の項目を、取り出すのに使える<a href="#footnote_Temp_157"><sup><small>9</small></sup></a>。
<tt>cons</tt> というコンストラクタは、先頭に追加の項目がある以外は元のリストと同様のリストを作る。
</p>

<p class="lisp">(car one-through-four)
<i>1</i>

(cdr one-through-four)
<i>(2 3 4)</i>
(car (cdr one-through-four))
<i>2</i>

(cons 10 one-through-four)
<i>(10 1 2 3 4)</i>

(cons 5 one-through-four)
<i>(5 1 2 3 4)</i>
</p>

<p class="orig" lang="en">
The value of <tt>nil</tt>, used to terminate the chain of pairs, can be
thought of as a sequence of no elements, the <a name="%_idx_1594"></a><a name="%_idx_1596"></a><em>empty list</em>.  The
word <em>nil</em> is a contraction of the Latin word <em>nihil</em>, which
means ``nothing.''<a name="call_footnote_Temp_158" href="#footnote_Temp_158"><sup><small>10</small></sup></a></p>

<p class="trans" lang="ja">
<tt>nil</tt>——対の連なりを終わらせるために使われる——の値は、要素のない列、すなわち、<em>空リスト</em>だと見なせる。
<em>nil</em> という言葉は、ラテン語の <em>nihil</em> という単語——「無」を意味する——の短縮形である<a href="#footnote_Temp_158"><sup><small>10</small></sup></a>。
</p>

<a name="%_sec_Temp_159"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_159">List operations</a></h4>
<h4 class="trans" lang="ja">リスト演算</h4>

<p class="orig" lang="en"><a name="%_idx_1602"></a><a name="%_idx_1604"></a>
The use of pairs to represent sequences of elements as lists is
accompanied by conventional programming techniques for manipulating
lists by successively <a name="%_idx_1606"></a><a name="%_idx_1608"></a>``<tt>cdr</tt>ing down'' the lists.  For example,
the procedure <a name="%_idx_1610"></a><tt>list-ref</tt> takes as arguments a list and a number
<em>n</em> and returns the <em>n</em>th item of the list.  It is customary to
number the elements of the list beginning with 0.  The method for
computing <tt>list-ref</tt> is the following:</p>

<p class="trans" lang="ja">
要素の列をリストとして表現するのに対を使うことは、リストを次々と「<tt>cdr</tt> して小さくする」ことでリストを操作するための、従来のプログラミング技法を伴う。
たとえば、</a><tt>list-ref</tt> という手続きは、リストと <em class="en">n</em> という数を引数として取り、そのリストの <em class="en">n</em> 番目の要素を返す。
リストの要素には、0から始まる番号をつけるのが慣例である。
<tt>list-ref</tt> を計算する方法は以下のとおりだ。
</p>

<ul class="orig" lang="en">
<li>For <em>n</em> = 0, <tt>list-ref</tt> should return the <tt>car</tt> of the list.</li>
<li>Otherwise, <tt>list-ref</tt> should return  the (<em>n</em> - 1)st item of the
<tt>cdr</tt> of the list.</li>
</ul>

<ul class="trans" lang="ja">
<li><em class="en">n</em> = 0 のとき、<tt>list-ref</tt> は、そのリストの <tt>car</tt> を返すべきである。</li>
<li>それ以外のとき、<tt>list-ref</tt> は、そのリストの <tt>cdr</tt> の、(<em class="en">n</em> &minus; 1) 番目の項目を返すべきである。</li>
</ul>

<p class="lisp"><a name="%_idx_1612"></a>(define (list-ref items n)
  (if (= n 0)
      (car items)
      (list-ref (cdr items) (- n 1))))
(define squares (list 1 4 9 16 25))

(list-ref squares 3)
<i>16</i>
</p>

<p class="orig" lang="en">Often we <tt>cdr</tt> down the whole list.  To aid in this, Scheme includes
a primitive predicate <a name="%_idx_1614"></a><a name="%_idx_1616"></a><a name="%_idx_1618"></a><tt>null?</tt>, which tests whether its argument is
the empty list.  The procedure <a name="%_idx_1620"></a><a name="%_idx_1622"></a><tt>length</tt>, which
returns the number of items in a list, illustrates this typical
pattern of use:
</p>

<p class="trans" lang="ja">
リスト全体を <tt>cdr</tt> して下ることもしばしばである。
この点を付け加えるために、Schemeは、<tt>null?</tt> という原始的述語——引数が空リストかどうかをテストする——を含んでいる。
<tt>length</tt>という手続き——リスト内の項目の数を返す——は、この典型的な使用パターンを示す。
</p>

<p class="lisp"><a name="%_idx_1624"></a>(define (length items)
  (if (null? items)
      0
      (+ 1 (length (cdr items)))))
(define odds (list 1 3 5 7))

(length odds)
<i>4</i>
</p>

<p class="orig" lang="en">
The <tt>length</tt> procedure implements a simple recursive plan. The
reduction step is:</p>

<p class="trans" lang="ja">
<tt>length</tt> の手続きは、単純な再帰的計画を実装している。
還元ステップは以下のとおりだ。
</p>

<ul class="orig" lang="en">
<li>The <tt>length</tt> of any list is 1 plus the <tt>length</tt> of the
<tt>cdr</tt> of the list.</li>
</ul>

<ul class="trans" lang="ja">
<li>いかなるリストの <tt>length</tt> (長さ) も、1と、そのリストの <tt>cdr</tt> の <tt>length</tt> との和である。</li>
</ul>

<p class="orig" lang="en">This is applied successively until we reach the base case:</p>

<p class="trans" lang="ja">
これは、基底の場合に到達するまで、次々に適用される。
</p>

<ul class="orig" lang="en">
<li>The <tt>length</tt> of the empty list is 0.</li>
</ul>

<ul class="trans" lang="ja">
<li>空リストの <tt>length</tt> (長さ) は0である。</li>
</ul>

<p class="orig" lang="en">We could also compute <tt>length</tt> in an iterative style:
</p>

<p class="trans" lang="ja">
<tt>length</tt> を反復的な様式で計算することもできるだろう。
</p>

<p class="lisp"><a name="%_idx_1626"></a>(define (length items)
  (define (length-iter a count)
    (if (null? a)
        count
        (length-iter (cdr a) (+ 1 count))))
  (length-iter items 0))
</p>

<p class="orig" lang="en">Another conventional programming technique is to <a name="%_idx_1628"></a><a name="%_idx_1630"></a>``<tt>cons</tt> up'' an
answer list while <tt>cdr</tt>ing down a list, as in the procedure <a name="%_idx_1632"></a><a name="%_idx_1634"></a><tt>append</tt>, which takes two lists as arguments and combines their
elements to make a new list:
</p>

<p class="trans" lang="ja">
別の従来のプログラミング技法は、<tt>append</tt> という手続き——二つのリストを引数として取り、それらのリストの要素を合わせて新たなリストを作る——に見られるように、リストを <tt>cdr</tt> して小さくする一方で、答えのリストを「<tt>cons</tt> して大きくする」ことである。
</p>

<p class="lisp">(append squares odds)
<i>(1 4 9 16 25 1 3 5 7)</i>

(append odds squares)
<i>(1 3 5 7 1 4 9 16 25)</i>
</p>

<p class="orig" lang="en">
<tt>Append</tt> is also implemented using a recursive plan.  To <tt>append</tt>
lists <tt>list1</tt> and <tt>list2</tt>, do the following:</p>

<p class="trans" lang="ja">
<tt>append</tt> も、再帰的計画を使って実装される。
<tt>list1</tt> と <tt>list2</tt> というリストを <tt>append</tt> する (つなげる) には、以下のようにする。
</p>

<ul class="orig" lang="en">
<li>If <tt>list1</tt> is the empty list, then the result is just <tt>list2</tt>.</li>
<li>Otherwise, <tt>append</tt> the <tt>cdr</tt> of <tt>list1</tt> and 
<tt>list2</tt>, and <tt>cons</tt> the <tt>car</tt> of <tt>list1</tt> onto the result:</li>
</ul>

<ul class="trans" lang="ja">
<li>もし <tt>list1</tt> が空リストなら、結果は丁度 <tt>list2</tt> である。</li>
<li>それ以外の場合、<tt>list1</tt> の <tt>cdr</tt> と <tt>list2</tt> を <tt>append</tt> し、その結果の上に <tt>list1</tt> の <tt>car</tt> を <tt>cons</tt> して載せよ。</li>
</ul>

<p class="lisp"><a name="%_idx_1636"></a>(define (append list1 list2)
  (if (null? list1)
      list2
      (cons (car list1) (append (cdr list1) list2))))
</p>

<p class="orig" lang="en"><a name="%_thm_2.17"></a>
<b>Exercise 2.17.</b>  Define a procedure <a name="%_idx_1638"></a><a name="%_idx_1640"></a><tt>last-pair</tt> that returns the list that contains only
the last element of a given (nonempty) list:
</p>

<p class="trans" lang="ja">
<b>練習問題2.17.</b> 与えられた (非空の) リストの最後の要素のみを含むリストを返すような、<tt>last-pair</tt> という手続きを定義せよ。
</p>

<p class="lisp">(last-pair (list 23 72 149 34))
<i>(34)</i>
</p>

<p class="exercise"><span class="ex_comment">; 引数が非空かどうかのエラーチェックはしていない。</span>
(define (last-pair arg-list)
  (if (null? (cdr arg-list))
      arg-list
      (last-pair (cdr arg-list))))
</p>

<p class="orig" lang="en"><a name="%_thm_2.18"></a>
<b>Exercise 2.18.</b>  Define a procedure <a name="%_idx_1642"></a><a name="%_idx_1644"></a><tt>reverse</tt> that takes a list as argument and
returns a list of the same elements in reverse order:
</p>

<p class="trans" lang="ja">
<b>練習問題2.18.</b> リストを引数としてとり、逆順で同じ要素を持つリストを返すような、<tt>reverse</tt> という手続きを定義せよ。
</p>

<p class="lisp">(reverse (list 1 4 9 16 25))
<i>(25 16 9 4 1)</i>
</p>

<p class="exercise"><span class="ex_comment">; たとえば、</span>
(define (reverse arg-list)
  (if (null? arg-list)
      arg-list
      (append (reverse (cdr arg-list)) (list (car arg-list)))))
<span class="ex_comment">; とか、</span>
(define (reverse arg-list)
  (if (or (null? arg-list) (null? (cdr arg-list)))
      arg-list
      (append (reverse (cdr arg-list)) (list (car arg-list)))))
<span class="ex_comment">; とかでもよいけれど、</span>
(define (reverse arg-list)
  (define (reverse-iter remaining-list working-reversed-list)
    (if (null? remaining-list)
         working-reversed-list
        (reverse-iter (cdr remaining-list) (cons (car remaining-list) working-reversed-list))))
  (reverse-iter arg-list '()))
<span class="ex_comment">; とするのがシンプルでよいと思う。
; なお、Gauche だと、空リストはクオートしなくてもよいみたい。</span>
</p>

<p class="orig" lang="en"><a name="%_thm_2.19"></a>
<b>Exercise 2.19.</b>  Consider the <a name="%_idx_1646"></a>change-counting program of
section <a href="11_sec1_2.html#%_sec_1.2.2">1.2.2</a>.  It would be nice to be able to
easily change the currency used by the program, so that we could
compute the number of ways to change a British pound, for example.  As
the program is written, the knowledge of the currency is distributed
partly into the procedure <tt>first-denomination</tt> and partly into the
procedure <tt>count-change</tt> (which knows that there are five
kinds of U.S. coins).  It would be nicer to be able to
supply a list of coins to be used for making change.</p>

<p class="trans" lang="ja">
<b>練習問題2.19.</b> <a href="11_sec1_2.html#%_sec_1.2.2">1.2.2</a>節での、両替方法を数えるプログラムを考えよう。
あのプログラムで使われる通貨を簡単に変更できたら、素晴らしいことだろう。そうすれば、たとえば、英国ポンドを両替する方法の数を計算できるだろうから。
あのプログラムに書かれているとおり、通貨についての知識は、一部は <tt>first-denomination</tt> という手続きに振り分けられており、一部は <tt>count-change</tt> という手続き (5種類の米国硬貨があることを知っている) に振り分けられている。
両替に使われる硬貨のリストを供給できたら、もっと素晴らしいだろう。
</p>

<p class="orig" lang="en">We want to rewrite the procedure <tt>cc</tt> so that its
second argument is a list of the values of the
coins to use rather than an integer specifying which coins to use.  We
could then have lists that defined each kind of currency:
</p>

<p class="trans" lang="ja">
<tt>cc</tt> という手続きの2番目の引数が、どの硬貨を使うべきかを指定する整数ではなく、むしろ、使うべき硬貨の価格のリストとなるように、<tt>cc</tt> という手続きを書き換えたい。
また、通貨の各種類を定義したリストを持つこともできるだろう。
</p>

<p class="lisp">(define us-coins (list 50 25 10 5 1))
(define uk-coins (list 100 50 20 10 5 2 1 0.5))
</p>

<p class="orig" lang="en">
We could then call <tt>cc</tt> as follows:
</p>

<p class="trans" lang="ja">
すると、<tt>cc</tt> を次のように呼び出せるだろう。
</p>

<p class="lisp">(cc 100 us-coins)
<i>292</i>
</p>

<p class="orig" lang="en">
To do this will require changing the program <tt>cc</tt> somewhat.  It will
still have the same form, but it will access its second argument
differently, as follows:</p>

<p class="trans" lang="ja">
このようにするには、ある程度 <tt>cc</tt> のプログラムを変更することを要する。
<tt>cc</tt> のプログラムは、依然として同じ形式を保つだろうが、2番目の引数には、以下のとおり、違った方法でアクセスするだろう。
</p>

<p class="lisp">(define (cc amount coin-values)
  (cond ((= amount 0) 1)
        ((or (&lt; amount 0) (no-more? coin-values)) 0)
        (else
         (+ (cc amount
                (except-first-denomination coin-values))
            (cc (- amount
                   (first-denomination coin-values))
                coin-values)))))
</p>

<p class="orig" lang="en">
Define the procedures <tt>first-denomination</tt>, <tt>except-first-denomination</tt>, and <tt>no-more?</tt> in terms of primitive
operations on list structures.  Does the order of the list <tt>coin-values</tt> affect the answer produced by <tt>cc</tt>?  Why or why not?
</p>

<p class="trans" lang="ja">
リスト構造に関する原始的演算を用いて、<tt>first-denomination</tt> と <tt>except-first-denomination</tt> と <tt>no-more?</tt> という手続きを定義せよ。
<tt>coin-values</tt> というリストでの順序は、<tt>cc</tt> により生み出される答えに影響するか?
なぜ影響するのか、あるいは、なぜ影響しないのか?
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_2.20"></a>
<b>Exercise 2.20.</b>  <a name="%_idx_1648"></a><a name="%_idx_1650"></a><a name="%_idx_1652"></a><a name="%_idx_1654"></a>The procedures <tt>+</tt>, <tt>*</tt>, and <tt>list</tt> take arbitrary numbers
of arguments. One way to define such procedures is to use <tt>define</tt>
with <em>dotted-tail notation</em>.  In a procedure definition, a parameter
list that has a dot before the last parameter name indicates that, when the
procedure is called, the initial parameters (if any) will have as values
the initial arguments,
as usual, but the final parameter's value will be a <em>list</em> of
any remaining arguments.
For instance, given the definition
</p>

<p class="trans" lang="ja">
<b>練習問題2.20.</b>  <tt>+</tt> や <tt>*</tt> や <tt>list</tt> という手続きは、任意の個数の引数をとる。
そういう手続きを定義するための一つの方法は、<em>末尾にドットがついた記法</em>とともに <tt>define</tt> を使うことである。
手続き定義においては、最後の仮引数名の前にドットを含むような仮引数リストが、手続きが呼ばれるときに、(もしあれば) 先頭側の仮引数は通常どおりに先頭側の実引数の値を持つ一方で、最後の仮引数の値は残りのすべての実引数の <em>リスト</em> となる、ということを示す。
たとえば、以下の定義が与えられると、
</p>

<p class="lisp">(define (f x y . z) <em>&lt;body&gt;</em>)
</p>

<p class="orig" lang="en">
the procedure <tt>f</tt> can be called with two or more arguments.
If we evaluate
</p>

<p class="trans" lang="ja">
<tt>f</tt> という手続きを、2個以上の実引数とともに呼ぶことができる。
もし以下のものを評価するなら、
</p>

<p class="lisp">(f 1 2 3 4 5 6)
</p>

<p class="orig" lang="en">
then in the body of <tt>f</tt>, <tt>x</tt> will be 1, <tt>y</tt> will be
2, and <tt>z</tt> will be the list <tt>(3 4 5 6)</tt>.
Given the definition
</p>

<p class="trans" lang="ja">
<tt>f</tt> の本体において <tt>x</tt> は1となり、<tt>y</tt> は2となり、<tt>z</tt> は <tt>(3 4 5 6)</tt> というリストになるだろう。
以下の定義が与えられると、
</p>

<p class="lisp">(define (g . w) <em>&lt;body&gt;</em>)
</p>

<p class="orig" lang="en">
the procedure <tt>g</tt> can be called with zero or more arguments.
If we evaluate
</p>

<p class="trans" lang="ja">
<tt>g</tt>  という手続きを、0個以上の実引数とともに呼ぶことができる。
もし以下のものを評価するなら、
</p>

<p class="lisp">(g 1 2 3 4 5 6)
</p>

<p class="orig" lang="en">
then in the body of <tt>g</tt>, <tt>w</tt> will be the
list <tt>(1 2 3 4 5 6)</tt>.<a name="call_footnote_Temp_164" href="#footnote_Temp_164"><sup><small>11</small></sup></a></p>

<p class="trans" lang="ja">
<tt>g</tt> の本体において、<tt>w</tt> は <tt>(1 2 3 4 5 6)</tt> というリストになるだろう<a href="#footnote_Temp_164"><sup><small>11</small></sup></a>。
</p>

<p class="orig" lang="en">Use this notation
to write a procedure <tt>same-parity</tt> that takes one or more integers
and returns a list of all the arguments that have the same even-odd
parity as the first argument.  For example,</p>

<p class="trans" lang="ja">
1個以上の整数を取り、1番目の実引数と同じ偶奇性を持つすべての実引数のリストを返すような、<tt>same-parity</tt> という手続きを、この記法を使って書け。
</p>

<p class="lisp">(same-parity 1 2 3 4 5 6 7)
<i>(1 3 5 7)</i>

(same-parity 2 3 4 5 6 7)
<i>(2 4 6)</i>
</p>

<p class="exercise"><span class="ex_comment">; とりあえずこんな感じ?</span>
(define (same-parity ref-num . list-of-nums)
  (define (parity-check ref-parity same-parity-nums nums-to-be-checked)
     (cond
       ((null? nums-to-be-checked) same-parity-nums)
       ((= ref-parity (mod (car nums-to-be-checked) 2))
       (parity-check ref-parity (cons (car nums-to-be-checked) same-parity-nums) (cdr nums-to-be-checked)))
      (else (parity-check ref-parity same-parity-nums (cdr nums-to-be-checked)))))
  (cons ref-num (reverse (parity-check (mod ref-num 2) () list-of-nums))))</p>


<a name="%_sec_Temp_165"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_165">Mapping over lists</a></h4>
<h4 class="trans" lang="ja">リスト全体にわたる写像</h4>

<p class="orig" lang="en"><a name="%_idx_1658"></a><a name="%_idx_1660"></a>
One extremely useful operation is to apply some transformation
to each element in a list and generate the list of results.
For instance, the following procedure scales each number in a list by
a given factor:
</p>

<p class="trans" lang="ja">
非常に有用な一つの演算は、なんらかの変換をリスト内の各要素に適用して、結果のリストを生成することである。
たとえば、以下の手続きは、リスト内のそれぞれの数に、与えられた因子を掛ける。
</p>

<p class="lisp"><a name="%_idx_1662"></a>(define (scale-list items factor)
  (if (null? items)
      nil
      (cons (* (car items) factor)
            (scale-list (cdr items) factor))))
(scale-list (list 1 2 3 4 5) 10)
<i>(10 20 30 40 50)</i>
</p>

<p class="orig" lang="en">We can abstract this general idea and capture it as a common pattern
expressed as a higher-order procedure, just as in
section <a href="12_sec1_3.html#%_sec_1.3">1.3</a>.  The higher-order procedure
here is called <tt>map</tt>.  <tt>Map</tt> takes as arguments a procedure
of one argument
and a list, and returns a list of the results produced by
applying the procedure to each element in the list:<a name="call_footnote_Temp_166" href="#footnote_Temp_166"><sup><small>12</small></sup></a>
</p>

<p class="trans" lang="ja">
私たちは、この一般的な考え方を抽象化することができ、それを、高階手続きとして表された共通パタンとして捉えることができる——<a href="12_sec1_3.html#%_sec_1.3">1.3</a>節とちょうど同様に。
ここでの高階手続きは、<tt>map</tt> と呼ばれる。
<tt>map</tt> は、1引数の手続きとリストとを引数として取り、その手続きをそのリスト内の各要素に適用することで作り出される結果のリストを返す<a href="#footnote_Temp_166"><sup><small>12</small></sup></a>。
</p>

<p class="lisp"><a name="%_idx_1666"></a>(define (map proc items)
  (if (null? items)
      nil
      (cons (proc (car items))
            (map proc (cdr items)))))
(map abs (list -10 2.5 -11.6 17))
<i>(10 2.5 11.6 17)</i>
(map (lambda (x) (* x x))
     (list 1 2 3 4))
<i>(1 4 9 16)</i>
</p>

<p class="orig" lang="en">
Now we can give a new definition of <tt>scale-list</tt> in terms of <tt>map</tt>:</p>

<p class="trans" lang="ja">
今や私たちは、<tt>map</tt> を使って、<tt>scale-list</tt> の新しい定義を与えることができる。
</p>

<p class="lisp"><a name="%_idx_1668"></a>(define (scale-list items factor)
  (map (lambda (x) (* x factor))
       items))
</p>

<p class="orig" lang="en"><tt>Map</tt> is an important construct, not only because it captures a
common pattern, but because it establishes a higher level of
abstraction in dealing with lists.  In the original definition of <tt>scale-list</tt>, the recursive structure of the program draws attention to
the element-by-element processing of the list.  Defining <tt>scale-list</tt> in terms of <tt>map</tt> suppresses that level of detail and
emphasizes that scaling transforms a list of elements to a list of
results.  The difference between the two definitions is not that the
computer is performing a different process (it isn't) but that we
think about the process differently.  In effect, <tt>map</tt> helps
establish an abstraction barrier that isolates the implementation of
procedures that transform lists from the details of how the
elements of the list are extracted and combined.  Like the barriers
shown in figure <a href="14_sec2_1.html#%_fig_2.1">2.1</a>, this abstraction gives
us the flexibility to change the low-level details of how sequences
are implemented, while preserving the conceptual framework of
operations that transform sequences to sequences.
Section <a href="#%_sec_2.2.3">2.2.3</a> expands on this use
of sequences as a framework for organizing programs.</p>

<p class="trans" lang="ja">
<tt>map</tt> は、共通パタンを捉えるから、というだけでなく、リストを扱う際に、より高い水準の抽象概念を築き上げるので、重要な構成である。
<tt>scale-list</tt> の元の定義では、プログラムの再帰的構造のせいで、リストの要素ごとの処理へと関心が向いてしまう。
<tt>map</tt> を使って <tt>scale-list</tt> を定義することで、その水準の細目は隠されるし、変倍によって要素のリストが結果のリストへと変換とれるのだ、ということが強調される。
二つの定義の違いは、コンピュータが異なるプロセスを実行している (そうではないのだが) という点ではなく、私たちが異なるやり方でプロセスについて考えるという点である。
実際には、リストの要素がどのように抽出されたり結合されたりするのか、という詳細から、リストを変換する手続きの実装を隔離するような、抽象化の防壁を築くのを、<tt>map</tt> が助けてくれる。
図<a href="14_sec2_1.html#%_fig_2.1">2.1</a>に示した防壁と同様、この抽象化は、列を列に変換するという演算の概念的枠組みを保ちつつも、私たちに、列がどのように実装されているかという低水準の詳細を変更するための、融通性を与えてくれる。
<a href="#%_sec_2.2.3">2.2.3</a>節では、プログラムを組織化するための枠組みとしての、列のこのような使用について、さらに詳しく説明する。
</p>

<p class="orig" lang="en"><a name="%_thm_2.21"></a>
<b>Exercise 2.21.</b>  The procedure <tt>square-list</tt> takes a list of
numbers as argument and returns a list of the squares of those
numbers.
</p>

<p class="trans" lang="ja">
<b>練習問題2.21.</b> <tt>square-list</tt> という手続きは、数のリストを引数として取り、それらの数の二乗のリストを返す。
</p>

<p class="lisp">(square-list (list 1 2 3 4))
<i>(1 4 9 16)</i>
</p>

<p class="orig" lang="en">
Here are two different definitions of <tt>square-list</tt>.  Complete
both of them by filling in the missing expressions:
</p>

<p class="trans" lang="ja">
ここに、<tt>square-list</tt> の二つの異なる定義がある。
それらのどちらについても、欠けている式を埋めることで、完成させよ。
</p>

<p class="lisp">(define (square-list items)
  (if (null? items)
      nil
      (cons &lt;<em>??</em>&gt; &lt;<em>??</em>&gt;)))
(define (square-list items)
  (map &lt;<em>??</em>&gt; &lt;<em>??</em>&gt;))
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_2.22"></a>
<b>Exercise 2.22.</b>  Louis Reasoner tries to rewrite the first <tt>square-list</tt> procedure of
exercise <a href="#%_thm_2.21">2.21</a> so that it evolves an iterative
process:
</p>

<p class="trans" lang="ja">
<b>練習問題2.22.</b> ルイス・リーズナは、練習問題<a href="#%_thm_2.21">2.21</a>の最初の <tt>square-list</tt> の手続きを、反復的プロセスを発達させるように、書き直そうと試みる。
</p>

<p class="lisp">(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things) 
              (cons (square (car things))
                    answer))))
  (iter items nil))
</p>

<p class="orig" lang="en">
Unfortunately, defining <tt>square-list</tt> this way produces the answer
list in the reverse order of the one desired.  Why?</p>

<p class="trans" lang="ja">
あいにく、この方法で <tt>square-list</tt> を定義すると、所望の順序の逆順になった答えのリストが作り出される。
なぜか?
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">Louis then tries to fix his bug by interchanging the arguments to
<tt>cons</tt>:
</p>

<p class="trans" lang="ja">
ルイスはそれから、<tt>cons</tt> に与える引数を入れ替えることで、自分のバグを直そうと試みる。
</p>

<p class="lisp">(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons answer
                    (square (car things))))))
  (iter items nil))
</p>

<p class="orig" lang="en">
This doesn't work either.  Explain.
</p>

<p class="trans" lang="ja">
これもうまくいかない。
説明せよ。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_2.23"></a>
<b>Exercise 2.23.</b>  The procedure <a name="%_idx_1670"></a><tt>for-each</tt> is similar to <tt>map</tt>.  It takes as
arguments a procedure and a list of elements.  However, rather than
forming a list of the  results, <tt>for-each</tt> just applies the procedure
to each of the elements in turn, from left to right.  The values
returned by applying the procedure to the elements are not used at
all -- <tt>for-each</tt> is used with procedures that perform an action,
such as printing.  For example,</p>

<p class="trans" lang="ja">
<b>練習問題2.23.</b> 
<tt>for-each</tt> という手続きは <tt>map</tt> に似ている。
これは、手続きと、要素のリストとを、引数として取る。
しかし、<tt>for-each</tt> は、結果のリストを形成するというよりはむしろ、単に、その手続きを順々に左から右へと、要素の各々へと適用するだけである。
要素に手続きを適用することで返される値は、まったく使われない——<tt>for-each</tt> は、印字などの動作を実行する手続きとともに使われる。
たとえば、以下のように。
</p>

<p class="lisp">(for-each (lambda (x) (newline) (display x))
          (list 57 321 88))
<i>57</i>
<i>321</i>
<i>88</i>
</p>

<p class="orig" lang="en">
The value returned by the call to <tt>for-each</tt> (not illustrated above)
can be something arbitrary, such as true.  Give an
implementation of <tt>for-each</tt>.
</p>

<p class="trans" lang="ja">
<tt>for-each</tt> の呼び出しにより返される値 (上記には示されていない) は、任意の何か——たとえば真など——であってよい。
<tt>for-each</tt> の実装を与えよ。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_2.2.2"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_2.2.2">2.2.2  Hierarchical Structures</a></h3>
<h3 class="trans" lang="ja">2.2.2 階層的構造</h3>

<p class="orig" lang="en">
<a name="%_idx_1672"></a><a name="%_idx_1674"></a><a name="%_idx_1676"></a><a name="%_idx_1678"></a>
The representation of sequences in terms of lists generalizes
naturally to represent sequences whose elements may
themselves be sequences.  For example, we can regard the object
<tt>((1 2) 3 4)</tt> constructed by
</p>

<p class="trans" lang="ja">
リストを使った列の表現は、要素自体が列であるかもしれないような列を表現するように、自然と一般化してゆく。
たとえば、以下により構築された <tt>((1 2) 3 4)</tt> というオブジェクトを、
</p>

<p class="lisp">(cons (list 1 2) (list 3 4))
</p>

<p class="orig" lang="en">
as a list of three items, the first of which is itself a list, <tt>(1 2)</tt>.  Indeed, this is suggested by the form in which the result is
printed by the interpreter.  Figure <a href="#%_fig_2.5">2.5</a> shows
the representation of this structure in terms of pairs.</p>

<p class="trans" lang="ja">
三つの項目のリスト——その三つの項目のうちの一つ目は、それ自体が、<tt>(1 2)</tt> というリストである——と見なすことができる。
実際、このことは、インタプリタにより結果が印字されている、その形式から、示唆される。
図<a href="#%_fig_2.5">2.5</a>は、対の観点からこの構造の表現を示している。
</p>

<figure>
<a name="%_fig_2.5"></a>
<img src="ch2-Z-G-15.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 2.5:</b>  Structure formed by <tt>(cons (list 1 2) (list 3 4))</tt>.</figcaption>
<figcaption class="trans" lang="ja"><b>図2.5:</b> <tt>(cons (list 1 2) (list 3 4))</tt> により形成される構造</figcaption>
</figure>

<p class="orig" lang="en">Another way to think of sequences whose elements are sequences is as
<em>trees</em>.  The elements of the sequence are the branches of the
tree, and elements that are themselves sequences are subtrees.
Figure <a href="#%_fig_2.6">2.6</a> shows the structure in
figure <a href="#%_fig_2.5">2.5</a> viewed as a tree.</p>

<p class="trans" lang="ja">
要素が列であるような列を考えるための別の方法は、<em>木</em>として考えることである。
列の要素は、木の分枝であり、それ自体が列であるような要素は、部分木である。
図 <a href="#%_fig_2.6">2.6</a>は、木として見た、図<a href="#%_fig_2.5">2.5</a>の構造を、示している。
</p>

<a name="%_fig_2.6"></a>
<figure>
<img src="ch2-Z-G-16.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 2.6:</b>  The list structure in figure <a href="#%_fig_2.5">2.5</a> viewed as a tree.</figcaption>
<figcaption class="trans" lang="ja"><b>図2.6:</b> 木として見た、図<a href="#%_fig_2.5">2.5</a>のリスト構造</figcaption>
</figure>

<p class="orig" lang="en">
<a name="%_idx_1680"></a>Recursion is a natural tool for dealing with tree structures, since
we can often reduce operations on trees to operations on their
branches, which reduce in turn to operations on the branches of the
branches, and so on, until we reach the leaves of the tree.
As an example, compare the <tt>length</tt> procedure of
section <a href="#%_sec_2.2.1">2.2.1</a> with the <a name="%_idx_1682"></a><a name="%_idx_1684"></a><tt>count-leaves</tt> procedure, which
returns the total number of leaves of a tree:</p>

<p class="trans" lang="ja">
再帰は、木構造を扱うための自然な手段だ。というのも、私たちは、しばしば、木の葉に到達するまで、木に対する演算をその分枝に対する演算へと還元し、そして、それを今度は分枝の分枝に対する演算へと還元し、というふうにしていくことができるからだ。
例として、<a href="#%_sec_2.2.1">2.2.1</a>節の <tt>length</tt> の手続きを、<tt>count-leaves</tt> という手続き——木の中の葉の総数を返す——と比較せよ。
</p>

<p class="lisp">(define x (cons (list 1 2) (list 3 4)))

(length x)
<i>3</i>
(count-leaves x)
<i>4</i>

(list x x)
<i>(((1 2) 3 4) ((1 2) 3 4))</i>

(length (list x x))
<i>2</i>

(count-leaves (list x x))
<i>8</i>
</p>

<p class="orig" lang="en">
To implement <tt>count-leaves</tt>, recall the recursive plan for computing
<tt>length</tt>:</p>

<p class="trans" lang="ja">
<tt>count-leaves</tt> を実装するために、<tt>length</tt> を計算するための再帰的計画を思い出そう。
</p>

<ul class="orig" lang="en">
<li><tt>Length</tt> of a list <tt>x</tt> is 1 plus <tt>length</tt> of the
<tt>cdr</tt> of <tt>x</tt>.</li>
<li><tt>Length</tt> of the empty list is 0.</li>
</ul>

<ul class="trans" lang="ja">
<li><tt>x</tt> なるリストの <tt>length</tt> (長さ) は、1と、<tt>x</tt> の <tt>cdr</tt> の <tt>length</tt> との和である。</li>
<li>空リストの <tt>length</tt> は0である。</li>
</ul>

<p class="orig" lang="en"><tt>Count-leaves</tt> is similar.  The value for the empty list is the same:</p>

<p class="trans" lang="ja">
<tt>count-leaves</tt> も似たようなものだ。
空リストに対する値は同じである。
</p>

<ul class="orig" lang="en">
<li><tt>Count-leaves</tt> of the empty list is 0.</li>
</ul>

<ul class="trans" lang="ja">
<li>空リストの <tt>count-leaves</tt> は0である。</li>
</ul>

<p class="orig" lang="en">But in the reduction step, where we strip off the <tt>car</tt> of the
list, we must take into account that the <tt>car</tt> may itself be a
tree whose leaves we need to count.  Thus, the appropriate reduction
step is</p>

<p class="trans" lang="ja">
しかし、還元ステップ——リストの <tt>car</tt> を剥ぎ取るところ——では、<tt>car</tt> 自体が、その葉を数える必要があるような木かもしれない、ということを、考慮に入れねばならない。
よって、適切な還元ステップは以下のとおりである。
</p>

<ul class="orig" lang="en">
<li><tt>Count-leaves</tt> of a tree <tt>x</tt> is <tt>count-leaves</tt> of the <tt>car</tt> of <tt>x</tt> plus <tt>count-leaves</tt> of the
<tt>cdr</tt> of <tt>x</tt>.</li>
</ul>

<ul class="trans" lang="ja">
<li><tt>x</tt> なる木の <tt>count-leaves</tt> は、<tt>x</tt> の <tt>car</tt> の <tt>count-leaves</tt> と、<tt>x</tt> の <tt>cdr</tt> の <tt>count-leaves</tt> との和である。</li>
</ul>

<p class="orig" lang="en">Finally, by taking <tt>car</tt>s we reach
actual leaves, so we need another base case:</p>

<p class="trans" lang="ja">
最後に、<tt>car</tt> を取ることで実際の葉に到達するので、もう一つの基底の場合が必要だ。
</p>

<ul class="orig" lang="en">
<li><tt>Count-leaves</tt> of a leaf is 1.</li>
</ul>

<ul class="trans" lang="ja">
<li>葉の<tt>count-leaves</tt> は1である。</li>
</ul>

<p class="orig" lang="en">To aid
in writing recursive procedures on trees, Scheme provides the primitive
predicate <a name="%_idx_1686"></a><a name="%_idx_1688"></a><tt>pair?</tt>, which tests whether its argument is a pair.
Here is the complete procedure:<a name="call_footnote_Temp_170" href="#footnote_Temp_170"><sup><small>13</small></sup></a></p>

<p class="trans" lang="ja">
木に対する再帰的手続きを書くのを支援するために、Schemeは、<tt>pair?</tt> という原始的述語——引数が対かどうかをテストする——を提供している。
ここに、完全な手続きがある<a href="#footnote_Temp_170"><sup><small>13</small></sup></a>。
</p>

<p class="lisp"><a name="%_idx_1690"></a>(define (count-leaves x)
  (cond ((null? x) 0)  
        ((not (pair? x)) 1)
        (else (+ (count-leaves (car x))
                 (count-leaves (cdr x))))))
</p>

<p class="orig" lang="en"><a name="%_thm_2.24"></a>
<b>Exercise 2.24.</b>  Suppose we evaluate the expression <tt>(list 1 (list 2 (list 3 4)))</tt>.
Give the result printed by the interpreter, the corresponding
box-and-pointer structure, and the interpretation of this as a tree
(as in figure <a href="#%_fig_2.6">2.6</a>).
<p></p>

<p class="trans" lang="ja">
<b>練習問題2.24</b> <tt>(list 1 (list 2 (list 3 4)))</tt> という式を評価するものと想定せよ。
インタプリタにより印字される結果と、それに対応する箱・ポインタ式の構造と、これの木としての解釈 (図<a href="#%_fig_2.6">2.6</a>のようなもの) を示せ。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_2.25"></a>
<b>Exercise 2.25.</b>  Give combinations of <tt>car</tt>s and <tt>cdr</tt>s that will pick 7 from
each of the following lists:
</p>

<p class="trans" lang="ja">
<b>練習問題2.25.</b> 以下のリストの各々から7を選び出すような、<tt>car</tt> と <tt>cdr</tt> の組み合わせを示せ。
</p>

<p class="lisp">(1 3 (5 7) 9)

((7))

(1 (2 (3 (4 (5 (6 7))))))
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_2.26"></a>
<b>Exercise 2.26.</b>  Suppose we define <tt>x</tt> and <tt>y</tt> to be two lists:
</p>

<p class="trans" lang="ja">
<b>練習問題2.26.</b> <tt>x</tt> と <tt>y</tt> を、以下の二つのリストだと定義するものとする。
</p>

<p class="lisp">(define x (list 1 2 3))
(define y (list 4 5 6))
</p>

<p class="orig" lang="en">
What result is printed by the interpreter in response to evaluating
each of the following expressions:
</p>

<p class="trans" lang="ja">
以下の式の各々を評価するのに応じて、インタプリタにより印字される結果は、どのようなものか?
</p>

<p class="lisp">(append x y)

(cons x y)

(list x y)
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_2.27"></a>
<b>Exercise 2.27.</b>  Modify your <tt>reverse</tt> procedure of exercise <a href="#%_thm_2.18">2.18</a> to
produce a <a name="%_idx_1692"></a><a name="%_idx_1694"></a><tt>deep-reverse</tt> procedure that takes a list as argument
and returns as its value the list with its elements reversed and with
all sublists deep-reversed as well.  For example,
</p>

<p class="trans" lang="ja">
<b>練習問題2.27.</b> 練習問題<a href="#%_thm_2.18">2.18</a>で君の書いた <tt>reverse</tt> の手続きを修正して、<tt>deep-reverse</tt> の手続きを作り出せ。この手続きは、リストを引数として取る。そして、要素が逆順になっていて、すべての部分リストも奥まで逆順になっているようなリストを、値として返す。
たとえば、以下のように。
</p>

<p class="lisp">(define x (list (list 1 2) (list 3 4)))

x
<i>((1 2) (3 4))</i>

(reverse x)
<i>((3 4) (1 2))</i>

(deep-reverse x)
<i>((4 3) (2 1))</i>
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_2.28"></a>
<b>Exercise 2.28.</b>  Write a procedure <a name="%_idx_1696"></a><a name="%_idx_1698"></a><tt>fringe</tt> that takes as argument a tree
(represented as a list) and returns a list whose elements are all the
leaves of the tree arranged in left-to-right order.  For example,
</p>

<p class="trans" lang="ja">
<b>練習問題2.28.</b> 引数として木 (リストとして表現されているもの) を取り、その木のすべての葉を左から右へ向かう順序で並べたものを要素とするリストを返す、<tt>fringe</tt> という手続きを書け。
例えば、以下のようになる。
</p>

<p class="lisp">(define x (list (list 1 2) (list 3 4)))

(fringe x)
<i>(1 2 3 4)</i>

(fringe (list x x))
<i>(1 2 3 4 1 2 3 4)</i>
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_2.29"></a>
<b>Exercise 2.29.</b>  <a name="%_idx_1700"></a>A binary mobile consists of two branches, a left branch and a right
branch.  Each branch is a rod of a certain length, from which hangs
either a weight or another binary mobile.  We can represent a binary
mobile using compound data by constructing it from two branches (for
example, using <tt>list</tt>):</p>

<p class="trans" lang="ja">
<b>練習問題2.29.</b> 二分式モビールは二つの分枝——すなわち、左分枝と右分枝——からなる。
各分枝は、ある長さの棒であり、そこからは、錘か、別の二分式モビールがぶら下がる。
二つの分枝から (たとえば <tt>list</tt> を使って) 複合的データを構築することにより、私たちは、その複合的データを使って二分式モビールを表現できる。
</p>

<p class="lisp">(define (make-mobile left right)
  (list left right))
</p>

<p class="orig" lang="en">
A branch is constructed from a <tt>length</tt> (which must be a number)
together with a <tt>structure</tt>, which may be either a number
(representing a simple weight) or another mobile:</p>

<p class="trans" lang="ja">
分枝は、<tt>length</tt> (これは、数でなくてはならない) と、<tt>structure</tt>——これは、数 (単純な錘を表す) または他のモビールであり得る——から、構築される。
</p>

<p class="lisp">(define (make-branch length structure)
  (list length structure))
</p>

<ol class="orig" lang="en" style="list-style-type: lower-alpha">
<li>Write the corresponding selectors <tt>left-branch</tt> and
<tt>right-branch</tt>, which return the branches of a mobile, and
<tt>branch-length</tt> and <tt>branch-structure</tt>, which return 
the components of a branch.</li>

<li>Using your selectors, define a procedure <tt>total-weight</tt> 
that returns the total weight of a mobile.</li>

<li>A mobile is said to be <a name="%_idx_1702"></a><em>balanced</em> if the torque applied
by its top-left branch is equal to that applied by its top-right
branch (that is, if the length of the left rod multiplied by the
weight hanging from that rod is equal to the corresponding product for
the right side) and if each of the submobiles hanging off its branches
is balanced. Design a predicate that tests whether a binary mobile is
balanced.</li>

<li>Suppose we change the representation of mobiles so that the
constructors are</li>
</ol>

<ol class="trans" lang="ja" style="list-style-type: lower-alpha">
<li>対応するセレクタたる、<tt>left-branch</tt> および <tt>right-branch</tt>——モビールの分枝を返す——と、<tt>branch-length</tt> および <tt>branch-structure</tt>——分枝の構成要素を返す——と、を書け。</li>
<li>君のセレクタを使って、モビールの総重量を返す、<tt>total-weight</tt> という手続きを定義せよ。</li>
<li>次の場合に、モビールは、<em>平衡</em>であると言われる。すなわち、一番上の左側の分枝により加えられるトルクが、一番上の右側の分枝により加えられるトルクと等しくて (つまり、左の棒の長さに、その棒からぶら下がっている重量を掛けたものが、右側の対応する積と等しくて)、かつ、分枝からぶら下がっている部分モビールの各々が平衡である場合だ。
二分式モビールが平衡かどうかをテストする述語を設計せよ。
</li>
<li>コンストラクタが以下のとおりになるように、モビールの表現を変更するものとする。</li>
</ol>

<p class="lisp">(define (make-mobile left right)
  (cons left right))
(define (make-branch length structure)
  (cons length structure))
</p>

<p class="orig" lang="en">
How much do you need to change your programs to convert to the new
representation?</p>

<p class="trans" lang="ja">
新しい表現へと転換するために、君のプログラムをどれくらい変更する必要があるか?
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_Temp_177"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_177">Mapping over trees</a></h4>
<h4 class="trans" lang="ja">木全体にわたる写像</h4>

<p class="orig" lang="en"><a name="%_idx_1704"></a><a name="%_idx_1706"></a>
Just as <tt>map</tt> is a powerful abstraction for dealing with sequences,
<tt>map</tt> together with recursion is a powerful abstraction for
dealing with trees.  For instance, the <tt>scale-tree</tt>
procedure, analogous to <tt>scale-list</tt> of
section <a href="#%_sec_2.2.1">2.2.1</a>, takes as arguments a numeric factor and a
tree whose leaves are numbers.  It returns a tree of the same shape,
where each number is multiplied by the factor.
The recursive plan for <tt>scale-tree</tt> is similar to the one for
<tt>count-leaves</tt>:
</p>

<p class="trans" lang="ja">
<tt>map</tt> が、列を扱うための強力な抽象概念であるのとちょうど同じように、再帰をともなう <tt>map</tt> は、木を扱うための強力な抽象概念である。
たとえば、<tt>scale-tree</tt> という手続き——<a href="#%_sec_2.2.1">2.2.1</a>節の <tt>scale-list</tt> に類似している——は、数値の因子と、葉が数であるような木を、引数として取る。
これは、同じ形の木を返すが、その木においては、各々の数は、上記の因子を掛けたものである。
<tt>scale-tree</tt> のための再帰的計画は、<tt>count-leaves</tt> のための再帰的計画に似ている。
</p>

<p class="lisp"><a name="%_idx_1708"></a>(define (scale-tree tree factor)
  (cond ((null? tree) nil)
        ((not (pair? tree)) (* tree factor))
        (else (cons (scale-tree (car tree) factor)
                    (scale-tree (cdr tree) factor)))))
(scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7))
            10)
<i>(10 (20 (30 40) 50) (60 70))</i>
</p>

<p class="orig" lang="en">Another way to implement <tt>scale-tree</tt> is to regard the
tree as a sequence of sub-trees and use <tt>map</tt>.  We map
over the sequence, scaling each sub-tree in turn, and return the list
of results.  In the base case, where the tree is a leaf, we simply
multiply by the factor:
</p>

<p class="trans" lang="ja">
<tt>scale-tree</tt> を実装する別の方法は、木を部分木の列とみなして、<tt>map</tt> を使うことだ。
各部分木を順に変倍しながら、列の全体にわたって写像を行い、その結果のリストを返すわけだ。
基底の場合——木が葉である場合——では、単純に因子を掛ける。
</p>

<p class="lisp"><a name="%_idx_1710"></a>(define (scale-tree tree factor)
  (map (lambda (sub-tree)
         (if (pair? sub-tree)
             (scale-tree sub-tree factor)
             (* sub-tree factor)))
       tree))
</p>

<p class="orig" lang="en">
Many tree operations can be implemented by similar combinations of
sequence operations and recursion.</p>

<p class="trans" lang="ja">
木についての多くの演算は、列についての演算と再帰との類似の組み合わせにより、実装できる。
</p>

<p class="orig" lang="en"><a name="%_thm_2.30"></a>
<b>Exercise 2.30.</b>  Define a procedure <tt>square-tree</tt> analogous to the <tt>square-list</tt>
procedure of exercise <a href="#%_thm_2.21">2.21</a>.  That is, <tt>square-list</tt> should behave as follows:
</p>

<p class="trans" lang="ja">
<b>練習問題2.30.</b> 練習問題<a href="#%_thm_2.21">2.21</a>の <tt>square-list</tt> の手続きに類似した、<tt>square-tree</tt> という手続きを定義せよ。つまり、<tt>square-tree</tt> は以下のように振る舞うべきである。
<span class="note">(原文の、<tt>square-list</tt> should &hellip; は誤記だろう。)</span>
</p>

<p class="lisp">(square-tree
 (list 1
       (list 2 (list 3 4) 5)
       (list 6 7)))
<i>(1 (4 (9 16) 25) (36 49))</i>
</p>

<p class="orig" lang="en">
Define <tt>square-tree</tt> both directly (i.e., without using any
higher-order procedures) and also by using <tt>map</tt> and recursion.
</p>

<p class="trans" lang="ja">
<tt>square-tree</tt> を、直接的に (つまり、高階手続きを何も使わずに) 定義するとともに、<tt>map</tt> と再帰を使っても定義せよ。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_2.31"></a>
<b>Exercise 2.31.</b>  Abstract your answer to exercise <a href="#%_thm_2.30">2.30</a> to produce a
procedure <a name="%_idx_1712"></a><tt>tree-map</tt> with the property that <tt>square-tree</tt>
could be defined as
</p>

<p class="trans" lang="ja">
<b>練習問題2.31.</b> <tt>square-tree</tt> が以下のように定義できたであろう、という特性を持った、<tt>tree-map</tt> という手続きを、練習問題<a href="#%_thm_2.30">2.30</a>に対する君の答えを抽象化して作り出せ。
</p>

<p class="lisp">(define (square-tree tree) (tree-map square tree))
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_2.32"></a>
<b>Exercise 2.32.</b>  We can represent a <a name="%_idx_1714"></a>set as a list of distinct elements, and we can
represent the set of all subsets of the set as a list of lists.  For
example, if the set is <tt>(1 2 3)</tt>, then the set of all subsets is
<tt>(() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))</tt>.  Complete the
following definition of a procedure that generates the set of subsets
of a set and give a clear explanation of why it works:</p>

<p class="trans" lang="ja">
<b>練習問題2.32.</b> 集合は、異なる要素のリストとして表現することができ、その集合のすべての部分集合の集合は、リストのリストとして表現することができる。
たとえば、集合が <tt>(1 2 3)</tt> のとき、すべての部分集合の集合は、
<tt>(() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))</tt>
である。
ある集合の部分集合の集合を生成する手続きについての、以下の定義を完成させて、なぜそれがうまく動くのか、明確に説明せよ。
</p>

<p class="lisp"><a name="%_idx_1716"></a>(define (subsets s)
  (if (null? s)
      (list nil)
      (let ((rest (subsets (cdr s))))
        (append rest (map &lt;<em>??</em>&gt; rest)))))
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_2.2.3"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_2.2.3">2.2.3  Sequences as Conventional Interfaces</a></h3>
<h3 class="trans" lang="ja">2.2.3 従来のインタフェイスとしての列</h3>

<p class="orig" lang="en">
<a name="%_idx_1718"></a><a name="%_idx_1720"></a>
In working with compound data, we've stressed how data abstraction
permits us to design programs without becoming enmeshed in the details
of data representations, and how abstraction preserves for us the
flexibility to experiment with alternative representations.  In this
section, we introduce another powerful design principle for working
with data structures -- the use of <em>conventional interfaces</em>.</p>

<p class="trans" lang="ja">
データ抽象化のおかげで、どのようにして、データ表現の詳細に搦め捕られずにプログラムを設計できるようになるか、ということ、および、抽象化のおかげで、どのようにして、代替表現を使って実験するための融通性が保たれるか、ということを、私たちは、複合的データを使って作業する際に、強調してきた。
本節では、データ構造を使って作業するための、もう一つの強力な設計原理——つまり、<em>従来のインタフェイス</em>——を導入する。
</p>

<p class="orig" lang="en">In section <a href="12_sec1_3.html#%_sec_1.3">1.3</a> we saw how program
abstractions, implemented as higher-order procedures, can capture
common patterns in programs that deal with numerical data.  Our
ability to formulate analogous operations for working with compound
data depends crucially on the style in which we manipulate our data
structures.  Consider, for example, the following procedure, analogous
to the <tt>count-leaves</tt> procedure of section <a href="#%_sec_2.2.2">2.2.2</a>, which
takes a tree as argument and computes the sum of the squares of the
leaves that are odd:</p>

<p class="trans" lang="ja">
プログラム抽象化——高階手続きとして実装される——が、数値的データを扱うプログラムの中の共通パタンを、いかにして捕まえることができるのか、ということを、<a href="12_sec1_3.html#%_sec_1.3">1.3</a>節で見た。
複合的データを使って作業するための類似の演算を定式化する能力は、私たちがデータ構造を操作する流儀に、非常に依存している。
たとえば、以下の手続き——<a href="#%_sec_2.2.2">2.2.2</a>節の <tt>count-leaves</tt> という手続きに類似している——を考えよう。以下の手続きは、引数として木を取り、奇数であるような葉の二乗の和を計算する。
</p>

<p class="lisp"><a name="%_idx_1722"></a>(define (sum-odd-squares tree)
  (cond ((null? tree) 0)  
        ((not (pair? tree))
         (if (odd? tree) (square tree) 0))
        (else (+ (sum-odd-squares (car tree))
                 (sum-odd-squares (cdr tree))))))
</p>

<p class="orig" lang="en">
On the surface, this procedure is very different from the following
one, which constructs a list of all the even Fibonacci numbers
 <em>F</em><em>i</em><em>b</em>(<em>k</em>), where <em>k</em> is less than or equal to a given integer <em>n</em>:</p>
 
<p class="trans" lang="ja">
表面上は、この手続きは、以下の手続き——すべての偶数のフィボナッチ数 
<span class="math"><em class="en">Fib</em>(<em class="en">k</em>)</span> 
のリストを構築する——とは全然違う。なおここで、<em class="en">k</em> は、<em class="en">n</em> という与えられた整数以下である。
</p>

<p class="lisp"><a name="%_idx_1724"></a>(define (even-fibs n)
  (define (next k)
    (if (&gt; k n)
        nil
        (let ((f (fib k)))
          (if (even? f)
              (cons f (next (+ k 1)))
              (next (+ k 1))))))
  (next 0))
</p>

<p class="orig" lang="en">
Despite the fact that these two procedures are structurally very
different, a more abstract description of the two computations reveals
a great deal of similarity.  The first program</p>

<p class="trans" lang="ja">
これらの二つの手続きが構造上は全然違う、という事実にもかかわらず、二つの計算についての、より抽象的な説明により、多大なる類似性が明らかにされる。
1番目のプログラムは、
</p>

<ul class="orig" lang="en">
<li>enumerates the leaves of a tree;</li>
<li>filters them, selecting the odd ones;</li>
<li>squares each of the selected ones; and</li>
<li>accumulates the results using <tt>+</tt>, starting with 0.</li>
</ul>

<ul class="trans" lang="ja">
<li>木の葉を一つ一つ列挙し、</li>
<li>それらをフィルタにかけて取捨選択して、奇数のものを選び、</li>
<li>選んだもののそれぞれを二乗し、</li>
<li>0から始めて、<tt>+</tt> を使って結果を累積する。</li>
</ul>

<p class="orig" lang="en">
The second program
</p>

<p class="trans" lang="ja">
2番目のプログラムは、
</p>

<ul class="orig" lang="en">
<li>enumerates the integers from 0 to <em>n</em>;</li>
<li>computes the Fibonacci number for each integer;</li>
<li>filters them, selecting the even ones; and</li>
<li>accumulates the results using <tt>cons</tt>,  starting with the
empty list.</li>
</ul>

<ul class="trans" lang="ja">
<li>0から <em class="en">n</em> までの整数を一つ一つ列挙し、</li>
<li>各整数に対してフィボナッチ数を計算し、</li>
<li>それらをフィルタにかけて取捨選択して、偶数のものを選び、</li>
<li>空リストから始めて、<tt>cons</tt> を使って結果を累積する。</li>
</ul>

<p class="orig" lang="en"><a name="%_idx_1726"></a><a name="%_idx_1728"></a>A signal-processing engineer would find it natural to conceptualize
these processes in terms of signals flowing through a cascade of
stages, each of which implements part of the program plan, as shown in
figure <a href="#%_fig_2.7">2.7</a>.  In <tt>sum-odd-squares</tt>, we
begin with an <a name="%_idx_1730"></a><em>enumerator</em>, which generates a ``signal''
consisting of the leaves of a given tree.  This signal is passed
through a <a name="%_idx_1732"></a><em>filter</em>, which eliminates all but the odd elements.
The resulting signal is in turn passed through a <a name="%_idx_1734"></a><em>map</em>, which is a
``transducer'' that applies the <tt>square</tt> procedure to each
element.  The output of the map is then fed to an <a name="%_idx_1736"></a><em>accumulator</em>,
which combines the elements using <tt>+</tt>, starting from an initial 0.
The plan for <tt>even-fibs</tt> is analogous.</p>

<p class="trans" lang="ja">
信号処理のエンジニアなら、これらのプロセスを、次々と生じる段階という観点から、概念化することが自然だと思うだろう——それら段階の各々は、図<a href="#%_fig_2.7">2.7</a>に示すように、プログラム計画の一部を実装するものである。
<tt>sum-odd-squares</tt>では、<em>列挙器</em>——与えられた木の葉からなる「信号」を生成する——から始めている。
この信号は、<em>フィルタ</em>——奇数の要素以外のすべてを削除する——を介して、渡される。
その結果生じる信号は、今度は、<em>マップ</em>——各要素に  <tt>square</tt> の手続きを適用する「変換器」である——を介して、渡される。
マップの出力は、それから、<em>累積器</em>——最初の0から始めて、<tt>+</tt> を使って要素を結合する——へと投入される。
<tt>even-fibs</tt> についての計画も類似である。
</p>

<a name="%_fig_2.7"></a>
<figure>
<img src="ch2-Z-G-17.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 2.7:</b>  The signal-flow plans for the procedures <tt>sum-odd-squares</tt> (top) and <tt>even-fibs</tt> (bottom) reveal the
commonality between the two programs.</figcaption>
<figcaption class="trans" lang="ja"><b>図2.7:</b> <tt>sum-odd-squares</tt> (上段) と <tt>even-fibs</tt> (下段) の手続きについての、信号の流れを示す計画図が、二つのプログラムの共通点を明らかにする。</figcaption>
</figure>

<p class="orig" lang="en">Unfortunately, the two procedure definitions above fail to exhibit this
signal-flow structure.  For instance, if we examine the <tt>sum-odd-squares</tt> procedure, we find that the enumeration is
implemented partly by the <tt>null?</tt> and <tt>pair?</tt> tests and partly
by the tree-recursive structure of the procedure.  Similarly, the
accumulation is found partly in the tests and partly in the addition used
in the recursion.  In general, there are no distinct parts of either
procedure that correspond to the elements in the signal-flow
description.
Our two procedures decompose the computations in a different way,
spreading the enumeration over the program and mingling it with the
map, the filter, and the accumulation.  If we could organize our
programs to make the signal-flow structure manifest in the procedures
we write, this would increase the conceptual clarity of the resulting
code.</p>

<p class="trans" lang="ja">
あいにく、上記の二つの手続き定義は、このような信号の流れの構造を示せていない。
たとえば、<tt>sum-odd-squares</tt> の手続きを吟味すると、列挙が、部分的には、<tt>null?</tt> と <tt>pair?</tt> のテストにより実装されつつ、部分的には、手続きにおける、木に関する再帰的構造により実装されている、ということに気づく。
同様に、累積は、部分的には、これらのテストの中に見つかり、部分的には、再帰の中で使われる加算の中に見つかる。
全般的に、どちらの手続きにも、信号の流れの説明の中の要素に対応するような、明瞭な部分はない。
私たちの二つの手続きは、異なる方法で計算を分解する——列挙を、プログラム全体に撒き散らして、マップとフィルタと累積に混ぜ合わせるのだ。
もし、私たちの書く手続きにおいて、信号の流れの構造を明白にするように、私たちのプログラムを系統立てることができたなら、これにより、結果として生じるコードの概念的な明晰さが増していただろう。
</p>

<a name="%_sec_Temp_181"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_181">Sequence Operations</a></h4>
<h4 class="trans" lang="ja">列演算</h4>

<p class="orig" lang="en">
<a name="%_idx_1738"></a>
The key to organizing programs so as to more clearly reflect the
signal-flow structure is to concentrate on the ``signals'' that flow
from one stage in the process to the next.  If we represent these
signals as lists, then we can use list operations to implement the
processing at each of the stages.  For instance, we can implement the
mapping stages of the signal-flow diagrams using the <tt>map</tt>
procedure from section <a href="#%_sec_2.2.1">2.2.1</a>:
</p>

<p class="trans" lang="ja">
信号の流れの構造をより明瞭に反映するようにプログラムを系統立てるための鍵は、プロセス内の一つの段階から次の段階へと流れる「信号」に集中することである。
もしこれらの信号をリストとして表現するなら、各段階での処理を実装するのにリスト演算を使うことができる。
たとえば、信号の流れの図における写像の段階を、<a href="#%_sec_2.2.1">2.2.1</a>節からの <tt>map</tt> の手続きを用いて、実装することができる。
</p>

<p class="lisp">(map square (list 1 2 3 4 5))
<i>(1 4 9 16 25)</i>
</p>

<p class="orig" lang="en">Filtering a sequence to select only those elements that satisfy a
given predicate is accomplished by
</p>

<p class="trans" lang="ja">
与えられた述語を満たすような要素のみを選ぶために列をフィルタにかけることは、以下のようにして達成される。
</p>

<p class="lisp"><a name="%_idx_1740"></a>(define (filter predicate sequence)
  (cond ((null? sequence) nil)
        ((predicate (car sequence))
         (cons (car sequence)
               (filter predicate (cdr sequence))))
        (else (filter predicate (cdr sequence)))))
</p>

<p class="orig" lang="en">
For example,</p>

<p class="trans" lang="ja">
たとえば、以下のとおり。
</p>

<p class="lisp">(filter odd? (list 1 2 3 4 5))
<i>(1 3 5)</i>
</p>


<p class="orig" lang="en">Accumulations can be implemented by</p>

<p class="trans" lang="ja">
累積は、以下により実装できる。
</p>

<p class="lisp"><a name="%_idx_1742"></a>(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))
(accumulate + 0 (list 1 2 3 4 5))
<i>15</i>
(accumulate * 1 (list 1 2 3 4 5))
<i>120</i>
(accumulate cons nil (list 1 2 3 4 5))
<i>(1 2 3 4 5)</i>
</p>

<p class="orig" lang="en">
All that remains to implement signal-flow diagrams is to enumerate the
sequence of elements to be processed.  For <tt>even-fibs</tt>, we need to
generate the sequence of
integers in a given range, which we can do as follows:</p>

<p class="trans" lang="ja">
信号の流れの図を実装するためにまだ残っているものは、処理すべき要素の列を一つ一つ列挙することだけだ。
<tt>even-fibs</tt> については、与えられた範囲内の整数の列を生成する必要があるが、以下のようにしてこれを行うことが可能だ。
</p>

<p class="lisp"><a name="%_idx_1744"></a>(define (enumerate-interval low high)
  (if (&gt; low high)
      nil
      (cons low (enumerate-interval (+ low 1) high))))
(enumerate-interval 2 7)
<i>(2 3 4 5 6 7)</i>
</p>

<p class="orig" lang="en">
To enumerate the leaves of a tree, we can use<a name="call_footnote_Temp_182" href="#footnote_Temp_182"><sup><small>14</small></sup></a></p>

<p class="trans" lang="ja">
木の葉を列挙するためには、以下のものを利用できる<a href="#footnote_Temp_182"><sup><small>14</small></sup></a>。
</p>

<p class="lisp"><a name="%_idx_1748"></a><a name="%_idx_1750"></a>(define (enumerate-tree tree)
  (cond ((null? tree) nil)
        ((not (pair? tree)) (list tree))
        (else (append (enumerate-tree (car tree))
                      (enumerate-tree (cdr tree))))))
(enumerate-tree (list 1 (list 2 (list 3 4)) 5))
<i>(1 2 3 4 5)</i>
</p>

<p class="orig" lang="en">Now we can reformulate <tt>sum-odd-squares</tt> and <tt>even-fibs</tt> as in
the signal-flow diagrams.  For <tt>sum-odd-squares</tt>, we enumerate the
sequence of leaves of the tree, filter this to keep only the odd
numbers in the sequence, square each element, and sum the results:
</p>

<p class="trans" lang="ja">
さて今や私たちは、<tt>sum-odd-squares</tt> と <tt>even-fibs</tt> を、信号の流れの図にあるように再定式化できる。
<tt>sum-odd-squares</tt> については、木の葉の列を列挙し、これをフィルタにかけて奇数のみを列の中に保持し、各要素を二乗し、その結果を合計する。
</p>

<p class="lisp"><a name="%_idx_1752"></a>(define (sum-odd-squares tree)
  (accumulate +
              0
              (map square
                   (filter odd?
                           (enumerate-tree tree)))))
</p>

<p class="orig" lang="en">
For <tt>even-fibs</tt>, we enumerate the integers from 0 to <em>n</em>, generate
the Fibonacci number for each of these integers, filter the resulting
sequence to keep only the even elements, and accumulate the results
into a list:
</p>

<p class="trans" lang="ja">
<tt>even-fibs</tt> については、0から <em class="en">n</em> までの整数を列挙し、これらの整数それぞれに対してフィボナッチ数を生成し、その結果生じる列をフィルタにかけて偶数の要素のみを保持し、その結果をリストに累積する。
</p>

<p class="lisp"><a name="%_idx_1754"></a>(define (even-fibs n)
  (accumulate cons
              nil
              (filter even?
                      (map fib
                           (enumerate-interval 0 n)))))
</p>

<p class="orig" lang="en">
The value of expressing programs as sequence operations is that this
helps us make program designs that are modular, that is, designs that
are constructed by combining relatively independent pieces.  We can
encourage modular design by providing a library of standard components
together with a conventional interface for connecting the components
in flexible ways.</p>

<p class="trans" lang="ja">
列演算としてプログラムを表現することの価値は、こうすることが、モジュール性のあるプログラム設計図——つまり、比較的独立した部分同士を結合することで構築される設計図——を作るうえで助けとなる、という点である。
標準的な構成要素のライブラリを、構成要素同士を柔軟な方法で結びつけるための従来のインタフェイスと一緒に供給することで、モジュール性のある設計を促進することができる。
</p>

<p class="orig" lang="en"><a name="%_idx_1756"></a><a name="%_idx_1758"></a>Modular construction is a powerful strategy for
controlling complexity in engineering design.  In real
signal-processing applications, for example, designers regularly build
systems by cascading elements selected from standardized families of
filters and transducers.  Similarly, sequence operations provide a
library of standard program elements that we can mix and match.  For
instance, we can reuse pieces from the <tt>sum-odd-squares</tt> and <tt>even-fibs</tt> procedures in a program that constructs a list of the
squares of the first <em>n</em> + 1 Fibonacci numbers:
</p>

<p class="trans" lang="ja">
モジュール方式の構築は、工学的な設計における複雑さを抑制するための、強力な戦略である。
現実の信号処理アプリケーションでは、たとえば、しばしば設計者たちは、一群の標準化されたフィルタと変換器の中から選んだ要素同士を順々につなぐことで、システムを構築する。
同様に、列演算は、異なるもの同士をうまく組み合わせられるような標準的なプログラム要素のライブラリを提供する。
たとえば、最初の 
<span class="math"><em class="en">n</em> + 1</span> 
個のフィボナッチ数の二乗のリストを構築するようなプログラムにおいて、私たちは、<tt>sum-odd-squares</tt> と <tt>even-fibs</tt> の手続きの一部分を使いまわせる。
</p>

<p class="lisp">(define (list-fib-squares n)
  (accumulate cons
              nil
              (map square
                   (map fib
                        (enumerate-interval 0 n)))))
(list-fib-squares 10)
<i>(0 1 1 4 9 25 64 169 441 1156 3025)</i>
</p>

<p class="orig" lang="en" id="err03">
We can rearrange the pieces and use them in computing the product of
the odd integers in a sequence:</p>

<p class="trans" lang="ja">
上記の一部分を配置しなおして、それらを、列の中の奇数の整数の積を計算するのに用いることもできる。
</p>

<p class="lisp">(define (product-of-squares-of-odd-elements sequence)
  (accumulate *
              1
              (map square
                   (filter odd? sequence))))
(product-of-squares-of-odd-elements (list 1 2 3 4 5))
<i>225</i>
</p>

<p class="orig" lang="en">We can also formulate conventional data-processing applications in
terms of sequence operations.  Suppose we have a sequence of personnel
records and we want to find the salary of the highest-paid programmer.
Assume that we have a selector <tt>salary</tt> that returns the salary of
a record, and a predicate <tt>programmer?</tt> that tests if a record is
for a programmer.  Then we can write</p>

<p class="trans" lang="ja">
従来のデータ処理アプリケーションを、列演算の観点から定式化することもできる。
人事記録の列があるものとして、一番高給取りのプログラマの給料を見つけたいものとしよう。
記録のうちの給料を返す、<tt>salary</tt> というセレクタと、記録がプログラマのものかどうかをテストする、<tt>programmer?</tt> という述語があるものと想定しよう。
すると、以下のように書ける。
</p>

<p class="lisp">(define (salary-of-highest-paid-programmer records)
  (accumulate max
              0
              (map salary
                   (filter programmer? records))))
</p>

<p class="orig" lang="en">
These examples give just a hint of the vast range of operations that
can be expressed as sequence operations.<a name="call_footnote_Temp_183" href="#footnote_Temp_183"><sup><small>15</small></sup></a></p>

<p class="trans" lang="ja">
これらの例は、列演算として表現できる、とても広い範囲の演算のうちの、ほんのわずかなものを示しているだけである<a href="#footnote_Temp_183"><sup><small>15</small></sup></a>。
</p>

<p class="orig" lang="en">Sequences, implemented here as lists, serve
as a conventional interface that permits us to combine processing
modules.  Additionally, when we uniformly represent structures as
sequences, we have localized the data-structure dependencies in our
programs to a small number of sequence operations.  By changing these,
we can experiment with alternative representations of sequences, while
leaving the overall design of our programs intact.  We will exploit
this capability in section <a href="24_sec3_5.html#%_sec_3.5">3.5</a>, when we generalize the
sequence-processing paradigm to admit infinite sequences.</p>

<p class="trans" lang="ja">
列——ここではリストとして実装されている——は、処理モジュール同士を結合することを可能にしてくれるような従来のインタフェイスとして、機能する。
さらに、諸構造を一様に列として表現する場合には、プログラムにおけるデータ構造依存性を、少数の列演算だけに局限した。
これらを変更することで、私たちは、プログラムの全体的な設計は元のままにしておきつつも、列の代替表現を使って実験することができる。
この能力は、<a href="24_sec3_5.html#%_sec_3.5">3.5</a>節で列処理のバラダイムを一般化して無限の列を認めるときに、活用することにしよう。
</p>

<p class="orig" lang="en"><a name="%_thm_2.33"></a>
<b>Exercise 2.33.</b>  Fill in the missing expressions to complete the following definitions
of some basic list-manipulation operations as accumulations:</p>

<p class="trans" lang="ja">
<b>練習問題2.33.</b> 欠けている式を埋めて、累積動作としての、いくつかの基本的なリスト操作演算についての、以下の定義を完成させよ。
</p>

<p class="lisp"><a name="%_idx_1766"></a>(define (map p sequence)
  (accumulate (lambda (x y) &lt;<em>??</em>&gt;) nil sequence))
<a name="%_idx_1768"></a>(define (append seq1 seq2)
  (accumulate cons &lt;<em>??</em>&gt; &lt;<em>??</em>&gt;))
<a name="%_idx_1770"></a>(define (length sequence)
  (accumulate &lt;<em>??</em>&gt; 0 sequence))
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_2.34"></a>
<b>Exercise 2.34.</b>  <a name="%_idx_1772"></a>Evaluating a polynomial in <em>x</em> at a given value of <em>x</em> can be
formulated as an accumulation.  We evaluate the polynomial</p>

<p class="trans" lang="ja">
<b>練習問題2.34</b> <em class="en">x</em> についての多項式を、与えられた <em class="en">x</em> の値において評価することは、累積として定式化できる。以下の式を評価するのに、
</p>

<figure><img src="ch2-Z-G-18.gif" border="0"></figure>

<p class="orig" lang="en">
using a well-known algorithm called <a name="%_idx_1774"></a><em>Horner's rule</em>, which
structures the computation as
</p>

<p class="trans" lang="ja">
<em>ホーナの法則</em>と呼ばれる周知のアルゴリズム——計算を以下のように組織立てる——を使う。
</p>

<figure><img src="ch2-Z-G-19.gif" border="0"></figure>

<p class="orig" lang="en">
In other words, we start with <em>a</em><sub><em>n</em></sub>, multiply by <em>x</em>, add <em>a</em><sub><em>n</em>-1</sub>,
multiply by <em>x</em>, and so on, until we reach <em>a</em><sub>0</sub>.<a name="call_footnote_Temp_186" href="#footnote_Temp_186"><sup><small>16</small></sup></a>
Fill in the following template to produce a procedure that evaluates a
polynomial using Horner's rule.
Assume that the coefficients of the
polynomial are arranged in a sequence, from <em>a</em><sub>0</sub> through <em>a</em><sub><em>n</em></sub>.</p>

<p class="trans" lang="ja">
換言すれば、<em class="en">a<sub>n</sub></em> から始めて、<em class="en">x</em> を掛け、<em class="en">a</em><sub><em class="en">n</em>&minus;1</sub> を足し、<em class="en">x</em> を掛け、などとしていって、<em class="en">a</em><sub>0</sub> に到達するまで続けるのだ<a href="#footnote_Temp_186"><sup><small>16</small></sup></a>。
以下の雛型を埋めて、ホーナの法則を用いて多項式を評価するような手続きを作り出せ。
多項式の係数が、 <em class="en">a</em><sub>0</sub> から <em class="en">a</em><sub><em class="en">n</em></sub> までの列の形で用意されているものとせよ。
</p>

<p class="lisp">(define (horner-eval x coefficient-sequence)
  (accumulate (lambda (this-coeff higher-terms) &lt;<em>??</em>&gt;)
              0
              coefficient-sequence))
</p>

<p class="orig" lang="en">
For example, to compute 1 + 3<em>x</em> + 5<em>x</em><sup>3</sup> + <em>x</em><sup>5</sup> at <em>x</em> = 2 you would evaluate</p>

<p class="trans" lang="ja">
たとえば、
<span class="math"><em class="en">x</em> = 2</span>
において
<span class="math">1 + 3<em class="en">x</em> + 5<em class="en">x</em><sup>3</sup> + <em class="en">x</em><sup>5</sup></span>
を計算するには、以下を評価する。
</p>

<p class="lisp">(horner-eval 2 (list 1 3 0 5 0 1))
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_2.35"></a>
<b>Exercise 2.35.</b>  Redefine <tt>count-leaves</tt> from section <a href="#%_sec_2.2.2">2.2.2</a> as an
accumulation:</p>

<p class="trans" lang="ja">
<b>練習問題2.35.</b> 節<a href="#%_sec_2.2.2">2.2.2</a>の <tt>count-leaves</tt> を、累積として再定義せよ。
</p>

<p class="lisp"><a name="%_idx_1792"></a>(define (count-leaves t)
  (accumulate &lt;<em>??</em>&gt; &lt;<em>??</em>&gt; (map &lt;<em>??</em>&gt; &lt;<em>??</em>&gt;)))
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_2.36"></a>
<b>Exercise 2.36.</b>  The procedure <tt>accumulate-n</tt> is similar to <tt>accumulate</tt> except
that it takes as its third argument a sequence of sequences, which are all
assumed to have the same number of elements.  It applies the
designated accumulation procedure to combine all the first elements of
the sequences, all the second elements of the sequences, and so on, and
returns a sequence of the results.  For instance, if <tt>s</tt> is a sequence
containing four sequences, <tt>((1 2 3) (4 5 6) (7 8 9) (10 11 12)),</tt>
then the value of <tt>(accumulate-n + 0 s)</tt> should be the sequence <tt>(22 26 30)</tt>.  Fill in the missing expressions
in the following definition of <tt>accumulate-n</tt>:</p>

<p class="trans" lang="ja">
<b>練習問題2.36.</b> <tt>accumulate-n</tt> という手続きは、列——どの列も同数の要素を有するものと想定されている——の列を、3番目の引数として取ること以外は、<tt>accumulate</tt> に似ている。
<tt>accumulate-n</tt> という手続きは、指定された累積手続きを適用して、それらの列の1番目の要素すべてを結合し、それらの列の2番目の要素すべてを結合し、などとしていき、そして、その結果の列を返す。
たとえば、<tt>s</tt> が、四つの列を含む <tt>((1 2 3) (4 5 6) (7 8 9) (10 11 12))</tt> という列であるとき、
<tt>(accumulate-n + 0 s)</tt>
の値は、
<tt>(22 26 30)</tt>
という列になるべきである。
以下の <tt>accumulate-n</tt> の定義中の欠けている式を埋めよ。
</p>

<p class="lisp"><a name="%_idx_1794"></a>(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      nil
      (cons (accumulate op init &lt;<em>??</em>&gt;)
            (accumulate-n op init &lt;<em>??</em>&gt;))))
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_2.37"></a>
<b>Exercise 2.37.</b>  <a name="%_idx_1796"></a><a name="%_idx_1798"></a><a name="%_idx_1800"></a>Suppose we represent vectors <em>v</em> = (<em>v</em><sub><em>i</em></sub>) as sequences of numbers, and
matrices <em>m</em> = (<em>m</em><sub><em>i</em><em>j</em></sub>) as sequences of vectors (the rows of the matrix).
For example, the matrix</p>

<p class="trans" lang="ja">
<b>練習問題2.37.</b> <span class="math"><em class="en">v</em> = (<em class="en">v</em><sub><em class="en">i</em></sub>)</span>
なるベクトルを、数の列として表現するものとし、
<span class="math"><em class="en">m</em> = (<em class="en">m<sub>ij</sub></em>)</span>
なる行列を、ベクトル (行列の行) の列として表現するものとする。
たとえば、以下の行列は、
</p>

<figure><div align=left><img src="ch2-Z-G-20.gif" border="0"></figure>

<p class="orig" lang="en">
is represented as the sequence <tt>((1 2 3 4) (4 5 6 6) (6 7 8 9))</tt>.
With this representation, we can use sequence operations to concisely
express the basic matrix and vector operations.  These operations
(which are described in any book on matrix algebra) are the following:</p>

<p class="trans" lang="ja">
<tt>((1 2 3 4) (4 5 6 6) (6 7 8 9))</tt>
という列として表現される。
この表現を使うと、列演算を用いて、基本的な行列とベクトルの演算を簡潔に表すことができる。
これらの演算 (行列代数についてのどんな本でも説明されている) とは、以下のようなものである。
</p>

<figure><img src="ch2-Z-G-21.gif" border="0"></figure>

<p class="orig" lang="en">We can define the dot product as<a name="call_footnote_Temp_190" href="#footnote_Temp_190"><sup><small>17</small></sup></a></p>

<p class="trans" lang="ja">
内積を次のように定義できる<a href="#footnote_Temp_190"><sup><small>17</small></sup></a>。
</p>

<p class="lisp"><a name="%_idx_1802"></a>(define (dot-product v w)
  (accumulate + 0 (map * v w)))
</p>

<p class="orig" lang="en">
Fill in the missing expressions in the following procedures for
computing the other matrix operations.  (The procedure <tt>accumulate-n</tt> is
defined in exercise <a href="#%_thm_2.36">2.36</a>.)</p>

<p class="trans" lang="ja">
残りの行列演算を計算するための、以下の手続きの中の、欠けている式を埋めよ。
(<tt>accumulate-n</tt> という手続きは、練習問題<a href="#%_thm_2.36">2.36</a>で定義されている。)
</p>

<p class="lisp"><a name="%_idx_1804"></a>(define (matrix-*-vector m v)
  (map &lt;<em>??</em>&gt; m))
<a name="%_idx_1806"></a>(define (transpose mat)
  (accumulate-n &lt;<em>??</em>&gt; &lt;<em>??</em>&gt; mat))
<a name="%_idx_1808"></a>(define (matrix-*-matrix m n)
  (let ((cols (transpose n)))
    (map &lt;<em>??</em>&gt; m)))
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_2.38"></a>
<b>Exercise 2.38.</b>  <a name="%_idx_1810"></a><a name="%_idx_1812"></a>The <tt>accumulate</tt> procedure is also known as <tt>fold-right</tt>,
because it combines the first element of the sequence with the result
of combining all the elements to the right.  There is also a <tt>fold-left</tt>, which is 
similar to <tt>fold-right</tt>, except
that it combines elements working in the opposite direction:</p>

<p class="trans" lang="ja">
<b>練習問題2.38.</b> <tt>accumulate</tt> の手続きは、<tt>fold-right</tt> としても知られる。というのも、これは、列の最初の要素を、右側のすべての要素を結合した結果に、結合するからである。
<tt>fold-left</tt> もあって、これは、逆方向にはたらいて要素を結合する点を除いては、<tt>fold-right</tt> に似ている。
</p>

<p class="lisp"><a name="%_idx_1814"></a>(define (fold-left op initial sequence)
  (define (iter result rest)
    (if (null? rest)
        result
        (iter (op result (car rest))
              (cdr rest))))
  (iter initial sequence))
</p>

<p class="orig" lang="en">
What are the values of</p>

<p class="trans" lang="ja">
以下のものの値は、どのようなものだろうか?
</p>

<p class="lisp">(fold-right / 1 (list 1 2 3))
(fold-left / 1 (list 1 2 3))
(fold-right list nil (list 1 2 3))
(fold-left list nil (list 1 2 3))
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
Give a property that <tt>op</tt> should satisfy to guarantee that <tt>fold-right</tt> and <tt>fold-left</tt> will produce the same values for any
sequence.
</p>

<p class="trans" lang="ja">
<tt>fold-right</tt> と <tt>fold-left</tt> が任意の列に対して同じ値を作り出すだろう、と保証するために、<tt>op</tt> が満たすべき性質を述べよ。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_2.39"></a>
<b>Exercise 2.39.</b>  
Complete the following definitions of <tt>reverse</tt>
<a name="%_idx_1816"></a>(exercise <a href="#%_thm_2.18">2.18</a>) in terms of <tt>fold-right</tt> and <tt>fold-left</tt> from exercise <a href="#%_thm_2.38">2.38</a>:</p>

<p class="trans" lang="ja">
<b>練習問題2.39.</b> 練習問題<a href="#%_thm_2.38">2.38</a>の <tt>fold-right</tt> と <tt>fold-left</tt> を用いた、以下の <tt>reverse</tt> (練習問題<a href="#%_thm_2.18">2.18</a>) の定義を、完成させよ。
</p>

<p class="lisp">(define (reverse sequence)
  (fold-right (lambda (x y) &lt;<em>??</em>&gt;) nil sequence))
(define (reverse sequence)
  (fold-left (lambda (x y) &lt;<em>??</em>&gt;) nil sequence))
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_Temp_193"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_193">Nested Mappings</a></h4>
<h4 class="trans" lang="ja">入れ子になった写像</h4>

<p class="orig" lang="en">
<a name="%_idx_1818"></a>
We can extend the sequence paradigm to include many
computations that are commonly expressed using nested loops.<a name="call_footnote_Temp_194" href="#footnote_Temp_194"><sup><small>18</small></sup></a>
Consider
this problem: Given a positive integer <em>n</em>, find all ordered pairs of
distinct positive integers <em>i</em> and <em>j</em>, where 1<u>&lt;</u> <em>j</em>&lt; <em>i</em><u>&lt;</u> <em>n</em>, such
that <em>i</em>  + <em>j</em> is prime.  For example, if <em>n</em> is 6, then the pairs are
the following:
</p>

<p class="trans" lang="ja">
一般には、入れ子になったループを用いて表されるような、多くの計算を含むように、列パラダイムを拡張できる<a href="#footnote_Temp_194"><sup><small>18</small></sup></a>。
次の問題を考えよう。
<em class="en">n</em> という正の整数が与えられたとき、
<span class="math">1 &le; <em class="en">j</em> &le; <em class="en">i</em> &le; <em class="en">n</em></span>
だとして、
<span class="math"><em class="en">i</em>  + <em class="en">j</em></span>
が素数となるような、相異なる正の整数 <em class="en">i</em> と <em class="en">j</em> の、すべての順序付きの対を見つけ出せ。
たとえば、<em class="en">n</em> が6のとき、そのような対とは、以下のとおりのものである。
</p>

<figure><img src="ch2-Z-G-22.gif" border="0"></figure>

<p class="orig" lang="en">
A natural way to organize this computation is to generate the sequence
of all ordered pairs of positive integers less than or equal to <em>n</em>,
filter to select those pairs whose sum is prime, and
then, for each pair (<em>i</em>, <em>j</em>) that passes through the filter, produce the triple
(<em>i</em>,<em>j</em>,<em>i</em> + <em>j</em>).</p>

<p class="trans" lang="ja">
この計算を組織立てる自然な方法は、<em class="en">n</em> 以下の正整数同士のすべての順序付きの対の列を生成し、その対の和が素数であるような対を選択するようにフィルタにかけ、それから、フィルタを通過した各々の対
<span class="math">(<em class="en">i</em>, <em class="en">j</em>)</span>
に対して、
<span class="math">(<em class="en">i</em>, <em class="en">j</em>, <em class="en">i</em> + <em class="en">j</em>)</span>
という三つ組を作り出すことである。
</p>

<p class="orig" lang="en">Here is a way to generate the sequence of pairs: For each integer
<em>i</em><u>&lt;</u> <em>n</em>, enumerate the integers <em>j</em>&lt;<em>i</em>, and for each such <em>i</em> and <em>j</em>
generate the pair (<em>i</em>,<em>j</em>).  In terms of sequence operations, we map
along the sequence <tt>(enumerate-interval 1 n)</tt>.  For each <em>i</em> in
this sequence, we map along the sequence <tt>(enumerate-interval 1 (-
i 1))</tt>.  For each <em>j</em> in this latter sequence, we generate the pair
<tt>(list i j)</tt>.  This gives us a sequence of pairs for each <em>i</em>.
Combining all the sequences for all the <em>i</em> (by accumulating with <tt>append</tt>) produces the required sequence of pairs:<a name="call_footnote_Temp_195" href="#footnote_Temp_195"><sup><small>19</small></sup></a></p>

<p class="trans" lang="ja">
ここに、対の列を生成する方法がある。
<span class="math"><em class="en">i</em> &le; <em class="en">n</em></span>
なる各整数 <em class="en">i</em> に対して、
<span class="math"><em class="en">j</em> &lt; <em class="en">i</em></span>
なる整数 <em class="en">j</em> を列挙し、
そのようなそれぞれの <em class="en">i</em> と <em class="en">j</em> に対して、
<span class="math">(<em class="en">i</em>, <em class="en">j</em>)</span>
という対を生成するのである。
列演算の観点から言うと、
<tt>(enumerate-interval 1 n)</tt>
という列に沿って写像を行うわけだ。
この列の中の各 <em class="en">i</em> に対して、
<tt>(enumerate-interval 1 (- i 1))</tt>
という列に沿って写像を行う。
この後者の列の中の各 <em class="en">j</em> に対して、
<tt>(list i j)</tt>
という対を生成する。
これにより、各 <em class="en">i</em> に対する対の列が与えられる。
すべての <em class="en">i</em> についての列を、(<tt>append</tt> を用いて累積することにより) 結合すると、必要な対の列ができあがる<a href="#footnote_Temp_195"><sup><small>19</small></sup></a>。
</p>

<p class="lisp">(accumulate append
            nil
            (map (lambda (i)
                   (map (lambda (j) (list i j))
                        (enumerate-interval 1 (- i 1))))
                 (enumerate-interval 1 n)))
</p>

<p class="orig" lang="en">
The combination of mapping and accumulating with <tt>append</tt> is so common in this
sort of program that we will isolate it as a separate procedure:</p>

<p class="trans" lang="ja">
写像と、<tt>append</tt> を使った累積との組み合わせは、この種のプログラムではとても一般的なので、この組み合わせを単独の手続きとして分離しよう。
</p>

<p class="lisp"><a name="%_idx_1826"></a>(define (flatmap proc seq)
  (accumulate append nil (map proc seq)))
</p>

<p class="orig" lang="en">
Now filter this sequence of pairs to find those whose sum is prime. The
filter predicate is called for each element of the sequence; its
argument is a pair and it must extract the integers from the pair.
Thus, the predicate to apply to each element in the sequence is</p>

<p class="trans" lang="ja">
さて、この対の列をフィルタにかけて、和が素数であるような対を見つけ出そう。
フィルタ述語は、列の各要素に対して呼ばれる。その引数は対であり、フィルタ述語は、その対から整数を抽出しなくてはならない。
よって、列の各要素に適用すべき述語は、以下のとおりである。
</p>

<p class="lisp">(define (prime-sum? pair)
  (prime? (+ (car pair) (cadr pair))))
</p>

<p class="orig" lang="en">
Finally, generate the sequence of results by mapping over the filtered
pairs using the following procedure, which constructs a triple
consisting of the two elements of the pair along with their sum:</p>

<p class="trans" lang="ja">
最後に、フィルタにかけた後の対のすべてにわたって、以下の手続き——その対の二つの要素と、それら要素同士の和からなる三つ組を構築する——を使って写像を行うことにより、得られた結果の列を、生成する。
</p>

<p class="lisp">(define (make-pair-sum pair)
  (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))
</p>

<p class="orig" lang="en">
Combining all these steps yields the complete procedure:</p>

<p class="trans" lang="ja">
これらすべてのステップを組み合わせることで、完全な手続きが生み出される。
</p>

<p class="lisp"><a name="%_idx_1828"></a>(define (prime-sum-pairs n)
  (map make-pair-sum
       (filter prime-sum?
               (flatmap
                (lambda (i)
                  (map (lambda (j) (list i j))
                       (enumerate-interval 1 (- i 1))))
                (enumerate-interval 1 n)))))
</p>

<p class="orig" lang="en">Nested mappings are also useful for sequences other than those that
enumerate intervals.  Suppose we wish to generate all the <a name="%_idx_1830"></a><a name="%_idx_1832"></a>permutations
of a set <em>S</em>; that is, all the ways of ordering the items in
the set.  For instance, the permutations of {1,2,3} are
{1,2,3}, { 1,3,2}, {2,1,3}, { 2,3,1}, { 3,1,2}, and
{ 3,2,1}.  Here is a plan for generating the permutations of <em>S</em>:
For each item <em>x</em> in <em>S</em>, recursively generate the sequence of
permutations of <em>S</em> - <em>x</em>,<a name="call_footnote_Temp_196" href="#footnote_Temp_196"><sup><small>20</small></sup></a> and adjoin
<em>x</em> to the front of each one.  This yields, for each <em>x</em> in <em>S</em>, the sequence
of permutations of <em>S</em> that begin with <em>x</em>.  Combining these
sequences for all <em>x</em> gives all the permutations of <em>S</em>:<a name="call_footnote_Temp_197" href="#footnote_Temp_197"><sup><small>21</small></sup></a></p>

<p class="trans" lang="ja">
区間で列挙を行うもの以外の列についても、入れ子になった写像は有用である。
<em class="en">S</em> という集合のすべての順列——つまり、この集合内の項目を順序付けて並べるすべての方法——を生成したいのだとしよう。
たとえば、
<span class="math">{1,2,3}</span>
の順列は、
<span class="math">(1,2,3}</span> と
<span class="math">{1,3,2}</span> と
<span class="math">{2,1,3}</span> と
<span class="math">{2,3,1}</span> と
<span class="math">{3,1,2}</span> と
<span class="math">{3,2,1}</span>
である。
ここに、<em class="en">S</em> の順列を生成する計画がある。
<em class="en">S</em> の中の各要素 <em class="en">x</em> に対して、
<span class="math"><em class="en">S</em> &minus; <em class="en">x</em></span>
の順列の列を再帰的に生成し<a href="#footnote_Temp_196"><sup><small>20</small></sup></a>、そのそれぞれの先頭に <em class="en">x</em> を連結する。
これにより、<em class="en">S</em> の中の各 <em class="en">x</em> に対して、<em class="en">x</em> から始まるような <em class="en">S</em> の順列の列が生み出される。
すべての <em class="en">x</em> についてのこれらの列を結合することで、<em class="en">S</em> のすべての順列が与えられる<a href="#footnote_Temp_197"><sup><small>21</small></sup></a>。
</p>

<p class="lisp"><a name="%_idx_1840"></a>(define (permutations s)
  (if (null? s)                    <em>; empty set?</em>
      (list nil)                   <em>; sequence containing empty set</em>
      (flatmap (lambda (x)
                 (map (lambda (p) (cons x p))
                      (permutations (remove x s))))
               s)))
</p>

<p class="orig" lang="en">
Notice how this strategy reduces the problem of generating
permutations of <em>S</em> to the problem of generating the permutations of
sets with fewer elements than <em>S</em>.  In the terminal case, we work our
way down to the empty list, which represents a set of no elements.
For this, we generate <tt>(list nil)</tt>, which is a sequence with one
item, namely the set with no elements.  The <tt>remove</tt> procedure
used in <tt>permutations</tt> returns all the items in a given sequence
except for a given item.  This can be expressed as a simple filter:
</p>

<p class="trans" lang="ja">
どのようにしてこの戦略が、<em class="en">S</em> の順列を生成するという問題を、<em class="en">S</em> より少ない要素からなる集合の順列を生成するという問題へと帰着させるのか、ということに注意せよ。
終端となる場合において、なんとか空リスト——要素を持たない集合を表す——にたどりつく。
これのために、<tt>(list nil)</tt>——一つの項目を有する列、すなわち、要素を持たない集合——を生成する。
<tt>permutations</tt> の中で使われている <tt>remove</tt> という手続きは、与えられた列の中の、与えられた項目以外のすべての項目を返す。
これは、単純なフィルタとして表せる。
</p>

<p class="lisp"><a name="%_idx_1842"></a>(define (remove item sequence)
  (filter (lambda (x) (not (= x item)))
          sequence))
</p>

<p class="orig" lang="en"><a name="%_thm_2.40"></a>
<b>Exercise 2.40.</b>  Define a procedure <a name="%_idx_1844"></a><tt>unique-pairs</tt> that, given an integer <em>n</em>,
generates the sequence of pairs (<em>i</em>,<em>j</em>) with 1<u>&lt;</u> <em>j</em>&lt; <em>i</em><u>&lt;</u> <em>n</em>.  Use <tt>unique-pairs</tt> to simplify the definition of <tt>prime-sum-pairs</tt>
given above.
</p>

<p class="trans" lang="ja">
<b>練習問題2.40.</b> <em class="en">n</em> という整数が与えられたときに、
<span class="math">1 &le; <em class="en">j</em> &lt; <em class="en">i</em> &le; <em class="en">n</em></span>
を満たすような、
<span class="math">(<em class="en">i</em>,<em class="en">j</em>)</span>
という対の列を生成する、<tt>unique-pairs</tt> という手続きを、定義せよ。
<tt>unique-pairs</tt> を使って、上記の <tt>prime-sum-pairs</tt> の定義を簡単化せよ。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_2.41"></a>
<b>Exercise 2.41.</b>  Write a procedure to find all ordered
triples of distinct positive integers <em>i</em>, <em>j</em>, and <em>k</em> less than or
equal to a given integer <em>n</em> that sum to a given integer <em>s</em>.
</p>

<p class="trans" lang="ja">
<b>練習問題2.41.</b> 合計が、与えられた <em class="en">s</em> という整数になるような、<em class="en">i</em>、<em class="en">j</em>、<em class="en">k</em> という、相異なる、与えられた <em class="en">n</em> という整数以下の、正の整数の、すべての順序付き三つ組を、見つける手続きを書け。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_2.42"></a>
<b>Exercise 2.42.</b>
</p>

<p class="trans" lang="ja">
<b>練習問題2.42.</b> 
</p>

<figure>
<a name="%_fig_2.8"></a>
<img src="ch2-Z-G-23.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 2.8:</b>  A solution to the eight-queens puzzle.</figcaption>
<figcaption class="trans" lang="ja">エイトクイーン問題の解</figcaption>
</figure>

<p class="orig" lang="en">
The <a name="%_idx_1846"></a><a name="%_idx_1848"></a><a name="%_idx_1850"></a>``eight-queens puzzle'' asks how to place eight queens on a
chessboard so that no queen is in check from any other (i.e., no two
queens are in the same row, column, or diagonal).  One possible
solution is shown in figure <a href="#%_fig_2.8">2.8</a>.  One way to solve the
puzzle is to work across the board, placing a queen in each column.
Once we have placed <em>k</em> - 1 queens, we must place the <em>k</em>th queen in a
position where it does not check any of the queens already on the
board.  We can formulate this approach recursively: Assume that we
have already generated the sequence of all possible ways to place
<em>k</em> - 1 queens in the first <em>k</em> - 1 columns of the board.  For each of
these ways, generate an extended set of positions by placing a queen
in each row of the <em>k</em>th column.  Now filter these, keeping only
the positions for which the queen in the <em>k</em>th column is safe with
respect to the other queens.  This produces the sequence of all ways
to place <em>k</em> queens in the first <em>k</em> columns.  By continuing this
process, we will produce not only one solution, but all solutions to
the puzzle.</p>

<p class="trans" lang="ja">
「エイトクイーン・パズル」は、他のいずれかのクイーンから王手をかけられているクイーンがないように (つまり、どの二つのクイーンも、同じ行、同じ列、または同じ斜線上にはないように)、八つのクイーンをチェス盤上に配置する方法を問うものである。
一つの可能な解が、図<a href="#%_fig_2.8">2.8</a>に示されている。
このパズルを解くための一つの方法は、各列にクイーンを配置しながら、盤全体にわたって作業することだ。
一旦、<span class="math"><em class="en">k</em> &minus; 1</span> 個のクイーンを配置したら、既に盤上にあるどのクイーンにも王手をかけないような位置に、<em class="en">k</em> 番目のクイーンを配置しなくてはならない。
この取り組み方を、再帰的に定式化することができる。
<span class="math"><em class="en">k</em> &minus; 1</span> 個のクイーンを、盤の最初の
<span class="math"><em class="en">k</em> &minus; 1</span> 列に配置するための、すべての可能な方法の列を、既に生成してあるものとする。
これらの方法の各々に対して、<em class="en">k</em> 番目の列の各行にクイーンを配置することにより、位置の、拡張された集合を生成しよう。
さてここで、これらをフィルタにかけ、<em class="en">k</em> 番目の列のクイーンが、他の残りのクイーンに関して安全であるような位置のみを、保つようにしよう。
これにより、
<span class="math"><em class="en">k</em> &minus; 1</span> 個のクイーンを、最初の
<span class="math"><em class="en">k</em> &minus; 1</span> 列に配置するための、すべての方法の列が、作り出される。
このプロセスを続けることで、一つの解だけでなく、このパズルに対するすべての解が作り出されるだろう。
</p>

<p class="orig" lang="en">
We implement this solution as a procedure <tt>queens</tt>, which returns
a sequence of all solutions to the problem of placing <em>n</em> queens on an
<em>n</em>&times; <em>n</em> chessboard.  <tt>Queens</tt> has an internal procedure <tt>queen-cols</tt> that returns the sequence of all ways to place queens in
the first <em>k</em> columns of the board.
</p>

<p class="trans" lang="ja">
私たちは、この解法を <tt>queens</tt> という手続きとして実装する——この手続きは、
<span class="math"><em class="en">n</em>&times; <em class="en">n</em></span> のチェス盤上に <em class="en">n</em> 個のクイーンを配置するという問題に対する、すべての解の列を返す。
<tt>queens</tt> は、盤の最初の <em class="en">k</em> 列にクイーンを配置するためのすべての方法の列を返すような、<tt>queen-cols</tt> という内部手続きを有する。
</p>

<p class="lisp"><a name="%_idx_1852"></a>(define (queens board-size)
  (define (queen-cols k)  
    (if (= k 0)
        (list empty-board)
        (filter
         (lambda (positions) (safe? k positions))
         (flatmap
          (lambda (rest-of-queens)
            (map (lambda (new-row)
                   (adjoin-position new-row k rest-of-queens))
                 (enumerate-interval 1 board-size)))
          (queen-cols (- k 1))))))
  (queen-cols board-size))
</p>

<p class="orig" lang="en">
In this procedure <tt>rest-of-queens</tt> is a way to place <em>k</em> - 1 queens
in the first <em>k</em> - 1 columns, and <tt>new-row</tt> is a proposed row in
which to place the queen for the <em>k</em>th column.  Complete the program
by implementing the representation for sets of board positions,
including the procedure <tt>adjoin-position</tt>, which adjoins a new row-column
position to a set of positions, and <tt>empty-board</tt>, which
represents an empty set of positions.  You must also write the
procedure <tt>safe?</tt>, which determines for a set of positions,
whether the queen in the <em>k</em>th column is safe with respect to the
others.  (Note that we need only check whether the new queen is
safe -- the other queens are already guaranteed safe with respect to
each other.)
</p>

<p class="trans" lang="ja">
この手続きにおいて、<tt>rest-of-queens</tt> は、
<span class="math"><em class="en">k</em> &minus; 1</span> 個のクイーンを、最初の
<span class="math"><em class="en">k</em> &minus; 1</span> 列に配置するための方法であり、
<tt>new-row</tt> は、<em class="en">k</em> 番目の列のクイーンを配置すべきところとして提案された行である。
<tt>adjoin-position</tt> という手続き——位置の集合に、新たな行・列の位置を接合する——と、<tt>empty-board</tt>——位置の空集合を表現する——も含めて、盤上の位置の集合のための表現を実装することで、このプログラムを完成させよ。
また、<tt>safe?</tt> という手続き——位置の集合に対して、<em class="en">k</em> 番目の列のクイーンが、残りのクイーンに関して安全かどうかを判定する——も、書かねばならない。
(新たなクイーンが安全かどうか、ということだけを調べればよい——というのも、残りのクイーンは、お互いに関して安全であることが既に保証されているので——ということに注意せよ。)
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_2.43"></a>
<b>Exercise 2.43.</b>  Louis Reasoner is having a terrible time doing exercise <a href="#%_thm_2.42">2.42</a>.  His
<tt>queens</tt> procedure seems to work, but it runs extremely slowly.
(Louis never does manage to wait long enough for it to solve even the
6&times; 6 case.)  When Louis asks Eva Lu Ator for help, she points
out that he has interchanged the order of the nested mappings in the
<tt>flatmap</tt>, writing it as</p>

<p class="trans" lang="ja">
<b>練習問題2.43.</b> ルイス・リーズナは、練習問題<a href="#%_thm_2.42">2.42</a>を解くのに、ひどい目にあっているところである。
彼の <tt>queens</tt> の手続きは、動きはするようなのだが、ひどくのろのろと実行されるのだ
(ルイスは、6&times;6 の場合でさえ、この手続きが解を出すのに十分な長さだけどうにか待ってみせる、ということが決してなかった)。
ルイスがエヴァ・リュ・エイタに助けを求めると、エヴァは、<tt>flatmap</tt> における入れ子の写像の順序を、ルイスが入れ替えて、以下のように書いたのだ、と指摘する。
</p>

<p class="lisp">(flatmap
 (lambda (new-row)
   (map (lambda (rest-of-queens)
          (adjoin-position new-row k rest-of-queens))
        (queen-cols (- k 1))))
 (enumerate-interval 1 board-size))
</p>

<p class="orig" lang="en">
Explain why this interchange makes the program run slowly.  Estimate
how long it will take Louis's program to solve the eight-queens
puzzle, assuming that the program in exercise <a href="#%_thm_2.42">2.42</a> solves
the puzzle in time <em>T</em>.
</p>

<p class="trans" lang="ja">
なぜこの入れ替えのせいで、プログラムの実行が遅くなるのか、説明せよ。
ルイスのプログラムがエイトクイーン・パズルを解くのに、どれくらいの時間がかかるかを、見積もれ——ただし、練習問題<a href="#%_thm_2.42">2.42</a> のプログラムは、このパズルを <em class="en">T</em> なる時間で解くものとする。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_2.2.4"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_2.2.4">2.2.4  Example: A Picture Language</a></h3>
<h3 class="trans" lang="ja">2.2.4 例: お絵描き言語</h3>

<p class="orig" lang="en">
<a name="%_idx_1854"></a>
This section presents a simple language for drawing
pictures that illustrates the
power of data abstraction and closure,
and also exploits higher-order procedures in
an essential way.  The language
is designed to make it easy to experiment with patterns
such as the ones in figure <a href="#%_fig_2.9">2.9</a>, which are
composed of repeated elements that are shifted and scaled.<a name="call_footnote_Temp_202" href="#footnote_Temp_202"><sup><small>22</small></sup></a> In this language,
the data objects being combined
are represented as procedures rather than as list structure.
Just as <tt>cons</tt>, which satisfies the <a name="%_idx_1860"></a>closure property,
allowed us to easily build arbitrarily complicated
list structure, the operations in this language, which also
satisfy the closure property, allow us to easily build
arbitrarily complicated patterns.</p>

<p class="trans" lang="ja">
本節では、データ抽象化と閉包の威力を例示する、お絵描き用の簡単な言語を提示し、本質的なやり方で高階手続きを利用する。
その言語は、図<a href="#%_fig_2.9">2.9</a>にあるようなパタン——移動されたり変倍されたりした繰り返し要素からなる——を使って実験を行うのを容易にするように、設計されている<a href="#footnote_Temp_202"><sup><small>22</small></sup></a>。
この言語では、結合されているデータオブジェクトは、リスト構造というよりむしろ手続きとして表現される。
<tt>cons</tt>——閉包特性を満たす——のおかげで、任意に入り組んだリスト構造を容易に構築できるようになったのとちょうど同じように、この言語における演算——これらも閉包特性を満たす——のおかげで、任意に入り組んだパタンを容易に構築できる。
</p>

<figure>
<a name="%_fig_2.9"></a>
<img src="ch2-Z-G-24.gif" border="0"> &nbsp;&nbsp;
<img src="ch2-Z-G-25.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 2.9:</b>  Designs generated with the picture language.</figcaption>
<figcaption class="trans" lang="ja"><b>図2.9:</b> お絵描き言語を使って生成された図柄</figcaption>
</figure>

<a name="%_sec_Temp_203"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_203">The picture language</a></h4>
<h4 class="trans" lang="ja">お絵描き言語</h4>

<p class="orig" lang="en">When we began our study of programming in
section <a href="10_sec1_1.html#%_sec_1.1">1.1</a>, we emphasized the
importance of describing a language by focusing on the language's
primitives, its means of combination, and its means of abstraction.
We'll follow that framework here.</p>

<p class="trans" lang="ja">
<a href="10_sec1_1.html#%_sec_1.1">1.1</a>節でプログラミングの勉強を始めたとき、私たちは、言語のプリミティブと、結合の手段と、抽象化の手段とに焦点を合わせて言語を記述することの重要性を、強調した。
私たちは、ここでもその枠組みに従おう。
</p>

<p class="orig" lang="en">Part of the elegance of this picture language is that there is
only one kind of element, called a <a name="%_idx_1862"></a><em>painter</em>.  A painter
draws an image that is shifted and scaled to fit within a designated
<a name="%_idx_1864"></a>parallelogram-shaped frame.  For example, there's a primitive painter
we'll call <tt>wave</tt> that makes a crude line drawing, as
shown in figure <a href="#%_fig_2.10">2.10</a>.
The actual shape of the drawing depends on the frame -- all
four images in figure <a href="#%_fig_2.10">2.10</a> are produced by the same <tt>wave</tt> painter, but with respect to four different frames.  Painters
can be more elaborate than this:
The primitive
painter called <tt>rogers</tt> paints a picture of MIT's founder,
William Barton Rogers, as shown in figure <a href="#%_fig_2.11">2.11</a>.<a name="call_footnote_Temp_204" href="#footnote_Temp_204"><sup><small>23</small></sup></a>
The four images in figure <a href="#%_fig_2.11">2.11</a>
are drawn with respect to the same four frames
as the <tt>wave</tt> images in figure <a href="#%_fig_2.10">2.10</a>.</p>

<p class="trans" lang="ja">
このお絵描き言語の洗練ぶりの一端は、一種類の要素——<em><ruby><rb>描画子</rb><rp> (</rp><rt>ペインタ</rt><rp>)</rp></em>と呼ばれる——しかない、という点にある。
ペインタは、指定された平行四辺形の枠の中に合うように移動されたり変倍されたりする画像を描く。
たとえば、私たちがこれから <tt>wave</tt> と呼ぶもので、図<a href="#%_fig_2.10">2.10</a>に示すように大雑把な線描を行う、原始的なペインタがある。
実際の図面の形は、枠に依存する——図<a href="#%_fig_2.10">2.10</a>の四つの画像はすべて、同じ <tt>wave</tt> ペインタにより作り出されるものだが、四つの異なる枠に関して作り出されるのである。
ペインタは、これよりも、もっと手の込んだものであり得る。
<tt>rogers</tt> と呼ばれる原始的ペインタは、MITの創立者たる、ウィリアム・バートン・ロジャースの絵を、図<a href="#%_fig_2.11">2.11</a>に示すように、描く<a href="#footnote_Temp_204"><sup><small>23</small></sup></a>。
図<a href="#%_fig_2.11">2.11</a>の四つの画像は、図<a href="#%_fig_2.10">2.10</a>の <tt>wave</tt> 画像のと同じ四つの枠に関して、描かれている。
</p>

<p class="orig" lang="en">
<a name="%_idx_1876"></a>To combine images,
we use various operations that construct new painters
from given painters.
For example, the <a name="%_idx_1878"></a><tt>beside</tt> operation takes two painters and produces a new,
compound painter that draws the first painter's image in the left half
of the frame and the second painter's image in the right half of the frame.
Similarly, <a name="%_idx_1880"></a><tt>below</tt> takes two painters and produces a compound
painter that draws the first painter's image below the second
painter's image.
Some operations transform a single painter to produce
a new painter.  For example, <a name="%_idx_1882"></a><tt>flip-vert</tt> takes a painter and
produces a painter that draws its image upside-down, and
<a name="%_idx_1884"></a><tt>flip-horiz</tt> produces a painter that draws the original
painter's image left-to-right reversed.</p>

<p class="trans" lang="ja">
画像を結合するために、私たちは、与えられたペインタから新たなペインタを構築する様々な演算を使う。
たとえば、<tt>beside</tt> 演算は、二つのペインタを取る。そして、一つ目のペインタの画像を枠の左半分に描くとともに二つ目のペインタの画像を枠の右半分に描くような、新しい複合ペインタを、作り出す。
同様に、<tt>below</tt> は、二つのペインタを取る。そして、一つ目のペインタの画像を二つ目のペインタの画像の下に描くような複合ペインタを、作り出す。
いくつかの演算は、単一のペインタを変形して、新たなペインタを作り出す。
たとえば、<tt>flip-vert</tt> は、ペインタを取り、その画像を上下さかさまに描くようなペインタを作り出すし、<tt>flip-horiz</tt> は、元のペインタの画像を左右逆に描くようなペインタを作り出す。
</p>

<figure>
<a name="%_fig_2.10"></a>
<table>
<tr>
	<td><img src="ch2-Z-G-26.gif" border="0"></td>
	<td>&nbsp;</td>
	<td><img src="ch2-Z-G-27.gif" border="0"></td>
</tr>
<tr>
	<td><img src="ch2-Z-G-28.gif" border="0"></td>
	<td>&nbsp;</td>
	<td><img src="ch2-Z-G-29.gif" border="0"></td>
</tr>
</table>
<figcaption class="orig" lang="en"><b>Figure 2.10:</b>  Images produced by the <tt>wave</tt> painter, with respect
to four different frames.  The frames, shown with dotted lines, are not
part of the images.</figcaption>
<figcaption class="trans" lang="ja"><b>図2.10:</b> 異なる四つの枠について、<tt>wave</tt> ペインタにより作り出された画像。枠——点線で示されている——は、画像の一部ではない。</figcaption>
</figure>

<figure>
<a name="%_fig_2.11"></a>
<table>
<tr>
	<td><img src="ch2-Z-G-30.gif" border="0"></td>
	<td>&nbsp;</td>
	<td><img src="ch2-Z-G-31.gif" border="0"></td>
<tr>
<tr>
	<td><img src="ch2-Z-G-32.gif" border="0"></td>
	<td>&nbsp;</td>
	<td><img src="ch2-Z-G-33.gif" border="0"></td>
</tr>
</table>
<figcaption class="orig" lang="en"><b>Figure 2.11:</b>  Images of William Barton Rogers, founder and first
president of MIT, painted with respect to the same four frames as in
figure <a href="#%_fig_2.10">2.10</a> (original image reprinted with the permission
of the MIT Museum).</figcaption>
<figcaption class="trans" lang="ja"><b>図2.11:</b> MITの創立者かつ初代学長であるウィリアム・バートン・ロジャースの画像——図<a href="#%_fig_2.10">2.10</a>と同じ四つの枠について描かれたもの (もとの画像はMIT博物館の許可のもとで再版されている)</figcaption>
</figure>

<p class="orig" lang="en">
Figure <a href="#%_fig_2.12">2.12</a> shows the drawing of a painter called
<tt>wave4</tt> that is built up in two stages starting from <tt>wave</tt>:</p>

<p class="trans" lang="ja">
図<a href="#%_fig_2.12">2.12</a>は、<tt>wave</tt> から始めて二段階で構築される、<tt>wave4</tt> と呼ばれるペインタの、線画を示す。
</p>

<p class="lisp">(define wave2 (beside wave (flip-vert wave)))
(define wave4 (below wave2 wave2))
</p>


<figure>
<a name="%_fig_2.12"></a>
<table>
<tr>
<td><img src="ch2-Z-G-34.gif" border="0"></td>
<td><img src="ch2-Z-G-35.gif" border="0"></td>
</tr>
<tr>
<td><tt>(define wave2
  (beside wave (flip-vert wave)))</tt></td>
<td><tt>(define wave4
  (below wave2 wave2))</tt></td>
</tr>
</table>
<figcaption class="orig" lang="en"><b>Figure 2.12:</b>  Creating a complex figure,
starting from the <tt>wave</tt> painter of figure <a href="#%_fig_2.10">2.10</a>.</figcaption>
<figcaption class="trans" lang="ja"><b>図2.12:</b> 図<a href="#%_fig_2.10">2.10</a>の <tt>wave</tt> ペインタから始めて、複雑な図形を作成している</figcaption>
</figure>

<p class="orig" lang="en"><a name="%_idx_1886"></a>In building up a complex image in this manner we are exploiting the
fact that painters are closed under the language's means of
combination.  The <tt>beside</tt> or <tt>below</tt> of two painters is
itself a painter; therefore, we can use it as an element in making
more complex painters.  As with building up list structure using <tt>cons</tt>, the closure of our data under the means of combination is
crucial to the ability to create complex structures while using only a
few operations.</p>

<p class="trans" lang="ja">
このやり方で複雑な画像を構築する際に、私たちは、ペインタが言語の結合手段のもとで閉じているという事実を、利用している。
二つのペインタの <tt>beside</tt> または <tt>below</tt> は、それ自体がペインタである。よって、それを、より複雑なペインタを作る際に、要素として使うことができる。
<tt>cons</tt> を使ってリスト構造を構築するときと同様に、結合手段のもとでの私たちのデータの閉包は、少数の演算のみを使いつつも複雑な構造を作成する能力には不可欠である。
</p>

<p class="orig" lang="en">
Once we can combine painters, we would like to be able to abstract
typical patterns of combining painters.
We will implement the painter operations as Scheme procedures.
This means that we don't need a special abstraction mechanism
in the picture language:
Since the means of combination
are ordinary Scheme procedures, we automatically have the capability
to do anything with painter operations that we can do with
procedures.
For example, we can abstract the pattern in <tt>wave4</tt> as</p>

<p class="trans" lang="ja">
一旦ペインタ同士を結合できれば、ペインタ同士を結合する典型的パタンを抽象化したくなるだろう。
私たちは、ペインタ演算を、Scheme手続きとして実装しよう。
これは、お絵描き言語での特殊な抽象化の仕組みを必要としない、ということを意味する。
結合手段は普通のSchemeの手続きなので、私たちは、自動的に、手続きを使って行えることは何でもペインタ演算を使って行える能力を持っている。
たとえば、<tt>wave4</tt> の中のパタンを次のように抽象化できるし、
</p>

<p class="lisp"><a name="%_idx_1888"></a>(define (flipped-pairs painter)
  (let ((painter2 (beside painter (flip-vert painter))))
    (below painter2 painter2)))
</p>

<p class="orig" lang="en">
and define <tt>wave4</tt> as an instance of this pattern:</p>

<p class="trans" lang="ja">
このパタンの<ruby><rb>一例</rb><rp> (</rp><rt>インスタンス</rt><rp>) </rp></ruby>として、<tt>wave4</tt> を定義できる。
</p>

<p class="lisp">(define wave4 (flipped-pairs wave))
</p>

<p class="orig" lang="en">We can also define recursive operations.
Here's one that makes painters split and branch
towards the right as shown in figures <a href="#%_fig_2.13">2.13</a>
and  <a href="#%_fig_2.14">2.14</a>:</p>

<p class="trans" lang="ja">
私たちは、再帰的演算も定義できる。
図<a href="#%_fig_2.13">2.13</a>と<a href="#%_fig_2.14">2.14</a>に示すように、右へ向かってペインタを分裂・枝分かれさせる再帰的演算が、ここにある。
</p>

<p class="lisp"><a name="%_idx_1890"></a>(define (right-split painter n)
  (if (= n 0)
      painter
      (let ((smaller (right-split painter (- n 1))))
        (beside painter (below smaller smaller)))))
</p>

<figure>
<a name="%_fig_2.13"></a>
<table>
<tr>
<td><img src="ch2-Z-G-36.gif" border="0"></td>
<td><img src="ch2-Z-G-37.gif" border="0"></td>
</tr>
<td><tt>     right-split</tt> <em>n</em></td>
<td><tt>     corner-split</tt> <em>n</em></td>
</tr>
</table>
<figcaption class="orig" lang="en"><b>Figure 2.13:</b>  Recursive plans for <tt>right-split</tt> and <tt>corner-split</tt>.</figcaption>
<figcaption class="trans" lang="ja"><b>図2.13:</b> <tt>right-split</tt> と <tt>corner-split</tt> についての再帰的計画</figcaption>
</figure>

<p class="orig" lang="en">We can produce balanced patterns by branching upwards
as well as towards the right (see exercise <a href="#%_thm_2.44">2.44</a>
and figures <a href="#%_fig_2.13">2.13</a> and  <a href="#%_fig_2.14">2.14</a>):
</p>

<p class="trans" lang="ja">
右向きと同様に上向きにも枝分かれすることで、釣り合いの取れたパタンを作り出せる (練習問題<a href="#%_thm_2.44">2.44</a>、図<a href="#%_fig_2.13">2.13</a>、図<a href="#%_fig_2.14">2.14</a>を参照)。
</p>

<p class="lisp"><a name="%_idx_1892"></a>(define (corner-split painter n)
  (if (= n 0)
      painter
      (let ((up (up-split painter (- n 1)))
            (right (right-split painter (- n 1))))
        (let ((top-left (beside up up))
              (bottom-right (below right right))
              (corner (corner-split painter (- n 1))))
          (beside (below painter top-left)
                  (below bottom-right corner))))))
</p>

<figure>
<a name="%_fig_2.14"></a>
<table>
<tr>
<td><img src="ch2-Z-G-38.gif" border="0"></td>
<td><img src="ch2-Z-G-39.gif" border="0"></td>
</tr>
<tr>
<td><tt>     (right-split wave 4)</tt></td>
<td><tt>     (right-split rogers 4)</tt></td>
</tr>
<tr>
<td><img src="ch2-Z-G-40.gif" border="0"></td>
<td><img src="ch2-Z-G-41.gif" border="0"></td>
</tr>
<tr>
<td><tt>    (corner-split wave 4)</tt></td>
<td><tt>    (corner-split rogers 4)</tt></td>
</tr>
</table>
<figcaption class="orig" lang="en"><b>Figure 2.14:</b>  The recursive operations <tt>right-split</tt> and <tt>corner-split</tt> applied to the painters <tt>wave</tt> and <tt>rogers</tt>.
Combining four <tt>corner-split</tt> figures produces
symmetric <tt>square-limit</tt> designs as shown
in figure <a href="#%_fig_2.9">2.9</a>.</figcaption>
<figcaption class="trans" lang="ja"><b>図2.14:</b> <tt>wave</tt> および <tt>rogers</tt> というペインタに対して適用された、<tt>right-split</tt> および <tt>corner-split</tt> という再帰的演算。
四つの <tt>corner-split</tt> の図を結合することで、図<a href="#%_fig_2.9">2.9</a>に示したような、対称的な <tt>square-limit</tt> の図柄が作り出される。</figcaption>
</figure>

<p class="orig" lang="en">By placing four copies of a <tt>corner-split</tt>
appropriately, we obtain a pattern called <tt>square-limit</tt>, whose
application to <tt>wave</tt> and <tt>rogers</tt> is shown in
figure <a href="#%_fig_2.9">2.9</a>:</p>

<p class="trans" lang="ja">
<tt>corner-split</tt> の四つの写しを適宜配置することで、<tt>square-limit</tt> と呼ばれるパタンが得られて、それを <tt>wave</tt> と <tt>rogers</tt> に適用したものは、図<a href="#%_fig_2.9">2.9</a>に示されている。
</p>

<p class="lisp"><a name="%_idx_1894"></a>(define (square-limit painter n)
  (let ((quarter (corner-split painter n)))
    (let ((half (beside (flip-horiz quarter) quarter)))
      (below (flip-vert half) half))))
</p>

<p class="orig" lang="en"><a name="%_thm_2.44"></a>
<b>Exercise 2.44.</b>  Define the procedure <a name="%_idx_1896"></a><tt>up-split</tt> used by <tt>corner-split</tt>.
It is similar to <tt>right-split</tt>, except that it switches the
roles of <tt>below</tt> and <tt>beside</tt>.
</p>

<p class="trans" lang="ja">
<b>練習問題2.44.</b> <tt>corner-split</tt> で使われている <tt>up-split</tt> という手続きを定義せよ。
それは、<tt>below</tt> と <tt>beside</tt> の役割を交換しているという点を除いて、<tt>right-split</tt> に似ている。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_Temp_206"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_206">Higher-order operations</a></h4>
<h4 class="trans" lang="ja">高階演算</h4>

<p class="orig" lang="en"><a name="%_idx_1898"></a>
In addition to abstracting patterns of combining painters, we can work
at a higher level, abstracting patterns of combining painter operations.
That is, we can view the painter operations as elements to manipulate
and can write means of combination for these elements -- procedures that
take painter operations as arguments and create new painter operations.</p>

<p class="trans" lang="ja">
ペインタ同士を結合するパタンを抽象化することだけでなく、私たちは、より高いレベルで作業することができる——ペインタ演算同士を結合するパタンを抽象化するのだ。
つまり、私たちは、ペインタ演算を、操作すべき要素と見なすことができるし、これらの要素同士の結合手段——ペインタ演算を引数として取り、新しいペインタ演算を作成するような手続き——を書くことができる。
</p>

<p class="orig" lang="en">For example, <tt>flipped-pairs</tt> and <tt>square-limit</tt> each
arrange four copies of a painter's image in a square pattern; they differ
only in how they orient the copies.
One way to abstract this pattern of painter combination is with
the following procedure, which takes four one-argument painter operations
and produces a painter operation that transforms a given
painter with those four operations and arranges the results in a square.
<tt>Tl</tt>, <tt>tr</tt>, <tt>bl</tt>, and <tt>br</tt> are the
transformations to apply to the top left copy, the top right copy,
the bottom left copy, and the bottom right copy, respectively.
</p>

<p class="trans" lang="ja">
たとえば、<tt>flipped-pairs</tt> と <tt>square-limit</tt> は、各々、ペインタの画像の四つの写しを、四角いパタンに配置する。両者は、それらの写しの向きをどう定めるかという点でのみ、異なる。
ペインタ結合のこのパタンを抽象化する一つの方法は、以下の手続きを使うことである。以下の手続きは、1引数のペインタ演算を四つ取る。そして、与えられたペインタを、それら四つの演算を使って変形して、その結果を四角形の中に配置する。
<tt>tl</tt> と <tt>tr</tt> と <tt>bl</tt> と <tt>br</tt> は、それぞれ、左上の写し、右上の写し、左下の写し、右下の写しに対して、適用すべき変形である。
</p>

<p class="lisp"><a name="%_idx_1900"></a>(define (square-of-four tl tr bl br)
  (lambda (painter)
    (let ((top (beside (tl painter) (tr painter)))
          (bottom (beside (bl painter) (br painter))))
      (below bottom top))))
</p>

<p class="orig" lang="en">
Then <tt>flipped-pairs</tt> can be defined in terms
of <tt>square-of-four</tt> as follows:<a name="call_footnote_Temp_207" href="#footnote_Temp_207"><sup><small>24</small></sup></a>
</p>

<p class="trans" lang="ja">
すると、<tt>square-of-four</tt> を用いて、以下のように <tt>flipped-pairs</tt> を定義できて<a href="#footnote_Temp_207"><sup><small>24</small></sup></a>、
</p>

<p class="lisp"><a name="%_idx_1904"></a>(define (flipped-pairs painter)
  (let ((combine4 (square-of-four identity flip-vert
                                  identity flip-vert)))
    (combine4 painter)))
</p>

<p class="orig" lang="en">
and <tt>square-limit</tt> can be expressed as<a name="call_footnote_Temp_208" href="#footnote_Temp_208"><sup><small>25</small></sup></a>
</p>

<p class="trans" lang="ja">
<tt>square-limit</tt> を次のように表せる<a href="#footnote_Temp_208"><sup><small>25</small></sup></a>。
</p>

<p class="lisp"><a name="%_idx_1906"></a>(define (square-limit painter n)
  (let ((combine4 (square-of-four flip-horiz identity
                                  rotate180 flip-vert)))
    (combine4 (corner-split painter n))))
</p>

<p class="orig" lang="en"><a name="%_thm_2.45"></a>
<b>Exercise 2.45.</b>  <tt>Right-split</tt> and <tt>up-split</tt> can be expressed as
instances of a general splitting operation.
Define a procedure <a name="%_idx_1908"></a><tt>split</tt> with the property that evaluating</p>

<p class="trans" lang="ja">
<b>練習問題2.45.</b> <tt>right-split</tt> と <tt>up-split</tt> は、一般的な分割演算の一例として表せる。
次のような性質を持つ、<tt>split</tt> という手続きを定義せよ——すなわち、その性質とは、以下のものを評価することで、
</p>

<p class="lisp">(define right-split (split beside below))
(define up-split (split below beside))
</p>

<p class="orig" lang="en">
produces procedures <tt>right-split</tt> and <tt>up-split</tt> with the same
behaviors as the ones already defined.
</p>

<p class="trans" lang="ja">
定義済みのものと同じ振る舞いをするような、<tt>right-split</tt> と <tt>up-split</tt> という手続きが作り出される、という性質である。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_Temp_210"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_210">Frames</a></h4>
<h4 class="trans" lang="ja">枠</h4>

<p class="orig" lang="en"><a name="%_idx_1910"></a>
Before we can show how to implement painters and their
means of combination, we must first consider
<a name="%_idx_1912"></a>frames.  A frame can be described by three vectors -- an origin vector
and two edge vectors.  The origin vector specifies the offset of the
frame's origin from some absolute origin in the plane, and the edge
vectors specify the offsets of the frame's corners from its origin.
If the edges are perpendicular, the frame will be rectangular.
Otherwise the frame will be a more general parallelogram.</p>

<p class="trans" lang="ja">
ペインタの実装の仕方と、ペインタ同士の結合の手段とを私たちが示せる前に、私たちはまず、枠について考えねばならない。
枠は、三つのベクトル——原点ベクトルと、二つの辺ベクトル——で記述できる。
原点ベクトルは、平面内の何らかの絶対的原点からの、枠の原点のずれを指定し、辺ベクトルは、枠の原点からの、枠の角のずれを指定する。
もし、それらの辺同士が直角をなしているなら、その枠は、長方形になるだろう。
それ以外の場合は、その枠は、より一般的な平行四辺形になるだろう。
</p>

<p class="orig" lang="en">Figure <a href="#%_fig_2.15">2.15</a> shows a frame and its associated vectors.  In
accordance with data abstraction, we need not be
specific yet about how frames are represented, other than to say that
there is a constructor <a name="%_idx_1914"></a><tt>make-frame</tt>, which takes three vectors and
produces a frame, and three corresponding selectors <a name="%_idx_1916"></a><tt>origin-frame</tt>, <a name="%_idx_1918"></a><tt>edge1-frame</tt>, and <a name="%_idx_1920"></a><tt>edge2-frame</tt> (see
exercise <a href="#%_thm_2.47">2.47</a>).</p>

<p class="trans" lang="ja">
図<a href="#%_fig_2.15">2.15</a>は、枠と、その枠に関連づけられたベクトルを、示している。
データ抽象化にしたがうと、私たちは、枠がどのように表現されるのかということについては、<tt>make-frame</tt> というコンストラクタ——三つのベクトルを取って枠を作り出す——と、三つの対応するセレクタたる <tt>origin-frame</tt> と <tt>edge1-frame</tt> と <tt>edge2-frame</tt> とが存在する、と述べることを除いて、まだ明確に言う必要はない (練習問題<a href="#%_thm_2.47">2.47</a>を参照)。
</p>

<a name="%_fig_2.15"></a>
<figure>
<img src="ch2-Z-G-42.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 2.15:</b>  A frame is described by three vectors -- an
origin and two edges.</figcaption>
<figcaption class="trans" lang="ja"><b>図2.15:</b> 枠は、三つのベクトル——原点と二つの辺——により記述される。</figcaption>
</figure>

<p class="orig" lang="en"><a name="%_idx_1922"></a>We will use coordinates in the unit square (0<u>&lt;</u> <em>x</em>,<em>y</em><u>&lt;</u> 1)
to specify images.
With each frame, we associate a <a name="%_idx_1924"></a><em>frame coordinate map</em>, which
will be used to shift and scale images to fit the frame.  The map
transforms the unit square into the frame by
mapping the vector <strong><em>v</em></strong> = (<em>x</em>,<em>y</em>) to the vector sum</p>

<p class="trans" lang="ja">
画像を指定するのに、単位正方形
<span class="math">(0 &le; <em class="en">x</em>,<em class="en">y</em> &le; 1)</span>
内の座標を使おう。
それぞれの枠に、私たちは、<em>枠座標写像</em>——その枠に合うように画像を移動したり変倍したりするのに使われるだろう——を対応づける。
その写像は、
<span class="math"><strong><em class="en">v</em></strong> = (<em class="en">x</em>,<em class="en">y</em>)</span>
というベクトルを、以下のベクトル和に写像することにより、単位正方形を枠へと変形する。
</p>

<figure><img src="ch2-Z-G-43.gif" border="0"></figure>

<p class="orig" lang="en">
For example, (0,0) is mapped to the origin of the frame, (1,1) to
the vertex diagonally opposite the origin, and (0.5,0.5) to the
center of the frame.  We can create a frame's coordinate map with the
following procedure:<a name="call_footnote_Temp_211" href="#footnote_Temp_211"><sup><small>26</small></sup></a></p>

<p class="trans" lang="ja">
たとえば、
<span class="math">(0, 0)</span> は、枠の原点に写像され、
<span class="math">(1, 1)</span> は、対角線上で原点と逆側の頂点に写像され、
<span class="math">(0.5, 0.5)</span> は、枠の中心に写像される。
私たちは、以下の手続きを使って、枠の座標写像を作れる<a href="#footnote_Temp_211"><sup><small>26</small></sup></a>。
</p>

<p class="lisp"><a name="%_idx_1926"></a>(define (frame-coord-map frame)
  (lambda (v)
    (add-vect
     (origin-frame frame)
     (add-vect (scale-vect (xcor-vect v)
                           (edge1-frame frame))
               (scale-vect (ycor-vect v)
                           (edge2-frame frame))))))
</p>

<p class="orig" lang="en">
Observe that applying <tt>frame-coord-map</tt> to a frame returns
a procedure that, given a vector, returns a vector.
If the argument vector is in the unit square, the result vector
will be in the frame.  For example,</p>

<p class="trans" lang="ja">
<tt>frame-coord-map</tt> を枠に適用することで、ベクトルが与えられるとベクトルを返すような手続きが返される、ということに気づいてほしい。
もし引数のベクトルが単位正方形の中にあれば、結果のベクトルは枠の中にあるだろう。
たとえば、以下のものは、
</p>

<p class="lisp">((frame-coord-map a-frame) (make-vect 0 0))
</p>

<p class="orig" lang="en">
returns the same vector as
</p>

<p class="trans" lang="ja">
以下のものと同じベクトルを返す。
</p>

<p class="lisp">(origin-frame a-frame)
</p>

<p class="orig" lang="en"><a name="%_thm_2.46"></a>
<b>Exercise 2.46.</b>  <a name="%_idx_1928"></a><a name="%_idx_1930"></a>A two-dimensional vector <strong>v</strong> running from the origin to a point
can be represented as a pair
consisting of an <em>x</em>-coordinate and a <em>y</em>-coordinate.  Implement a data
abstraction for vectors by giving a constructor <a name="%_idx_1932"></a><tt>make-vect</tt> and
corresponding selectors <a name="%_idx_1934"></a><tt>xcor-vect</tt> and <a name="%_idx_1936"></a><tt>ycor-vect</tt>.  In
terms of your selectors and constructor, implement procedures <a name="%_idx_1938"></a><tt>add-vect</tt>, <a name="%_idx_1940"></a><tt>sub-vect</tt>, and <a name="%_idx_1942"></a><tt>scale-vect</tt> that perform
the operations vector addition, vector subtraction, and multiplying a
vector by a scalar:</p>

<p class="trans" lang="ja">
<b>練習問題2.46.</b> 原点からある点までの二次元ベクトル <strong>v</strong> は、<em class="en">x</em> 座標と <em class="en">y</em> 座標からなる対として表現できる。
コンストラクタである <tt>make-vect</tt> と、対応するセレクタである <tt>xcor-vect</tt> および <tt>ycor-vect</tt> を与えることによって、ベクトル用のデータ抽象を実装せよ。
ベクトル加算と、ベクトル減算と、ベクトルをスカラ倍する乗算、という演算を行うような、<tt>add-vect</tt> と <tt>sub-vect</tt> と <tt>scale-vect</tt> という手続きを、君のセレクタとコンストラクタを使って実装せよ。
</p>

<figure><img src="ch2-Z-G-44.gif" border="0"></figure>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_2.47"></a>
<b>Exercise 2.47.</b>  Here are two possible constructors for frames:</p>

<p class="trans" lang="ja">
<b>練習問題2.47.</b> 枠のための可能なコンストラクタが、ここに二つある。
</p>

<p class="lisp"><a name="%_idx_1944"></a>(define (make-frame origin edge1 edge2)
  (list origin edge1 edge2))

(define (make-frame origin edge1 edge2)
  (cons origin (cons edge1 edge2)))
</p>

<p class="orig" lang="en">
For each constructor supply the appropriate selectors to produce an
implementation for frames.
</p>

<p class="trans" lang="ja">
各コンストラクタに対して、枠の実装を作り出すための適切なセレクタを提供せよ。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_Temp_214"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_214">Painters</a></h4>
<h4 class="trans" lang="ja">ペインタ</h4>

<p class="orig" lang="en"><a name="%_idx_1946"></a>
A painter is represented as a procedure that, given a frame
as argument, draws a particular image shifted and scaled to fit the frame.
That is to say, if <tt>p</tt> is a painter and <tt>f</tt> is a frame, then we
produce <tt>p</tt>'s image in <tt>f</tt> by calling <tt>p</tt> with <tt>f</tt> as
argument.</p>

<p class="trans" lang="ja">
枠が引数として与えられたときに、その枠に合うように移動・変倍された特定の画像を描くような手続きとして、ペインタは表現される。
つまり、もし <tt>p</tt> がペインタであり <tt>f</tt> が枠であるならば、私たちは、<tt>f</tt> を引数として <tt>p</tt> を呼ぶことで、<tt>f</tt> の中に <tt>p</tt> の画像を作り出す。
</p>

<p class="orig" lang="en">The details of how primitive painters are implemented depend on the
particular characteristics of the graphics system and the type of
image to be drawn.  For instance, suppose we have a procedure <a name="%_idx_1948"></a><tt>draw-line</tt> that draws a line on the screen between two specified
points.  Then we can create painters for line drawings, such as the
<tt>wave</tt> painter in figure <a href="#%_fig_2.10">2.10</a>, from lists of line
segments as follows:<a name="call_footnote_Temp_215" href="#footnote_Temp_215"><sup><small>27</small></sup></a>
</p>

<p class="trans" lang="ja">
原始的なペインタがどう実装されるのかという詳細は、グラフィックス・システムの特定の性質と、描かれるべき画像の種類に、依存する。
たとえば、画面上で、指定された二つの点の間に線を引くような、<tt>draw-line</tt> という手続きがあるとしよう。
すると、図<a href="#%_fig_2.10">2.10</a>における <tt>wave</tt> ペインタのような、線描用のペインタを、以下のように線分のリストから作成することができる<a href="#footnote_Temp_215"><sup><small>27</small></sup></a>。
</p>

<p class="lisp"><a name="%_idx_1950"></a>(define (segments-&gt;painter segment-list)
  (lambda (frame)
    (for-each
     (lambda (segment)
       (draw-line
        ((frame-coord-map frame) (start-segment segment))
        ((frame-coord-map frame) (end-segment segment))))
     segment-list)))
</p>

<p class="orig" lang="en">
The segments are given using coordinates with respect to the unit
square.  For each segment in the list, the painter transforms the
segment endpoints with the frame coordinate map and draws a line
between the transformed points.</p>

<p class="trans" lang="ja">
線分は、単位正方形に対する座標を用いて、与えられる。
リスト中の各線分に対して、ペインタは、枠座標写像を使ってセグメントの両端点を変換し、変換した点同士の間に線を引く。
</p>

<p class="orig" lang="en">Representing painters as procedures erects a powerful abstraction
barrier in the picture language.  We can create and intermix
all sorts of primitive painters, based on a variety of graphics
capabilities. The details of their implementation do not matter.  Any
procedure can serve as a painter, provided that it takes a frame as
argument and draws something scaled to fit the frame.<a name="call_footnote_Temp_216" href="#footnote_Temp_216"><sup><small>28</small></sup></a></p>

<p class="trans" lang="ja">
ペインタを手続きとして表すことで、お絵描き言語には、強力な抽象化の防壁が打ち立てられる。
様々なグラフィックス性能に基づいて、私たちは、あらゆる種類の原始的ペインタを作成できるし、混ぜ合わせられる。
それら様々なグラフィックス性能の実装の詳細は、重要ではない。
任意の手続きは、ペインタとして機能できる——引数として枠を取り、その枠に合うように変倍した何かを描く限りは<a href="#footnote_Temp_216"><sup><small>28</small></sup></a>。
</p>

<p class="orig" lang="en">
<a name="%_thm_2.48"></a>
<b>Exercise 2.48.</b>  <a name="%_idx_1952"></a>A directed line segment in the
plane can be represented as a pair of vectors -- the
vector running from the origin to the start-point of the segment, and
the vector running from the origin to the end-point of the segment.
Use your vector representation from exercise <a href="#%_thm_2.46">2.46</a> to
define a representation for segments with a constructor <a name="%_idx_1954"></a><tt>make-segment</tt> and selectors <a name="%_idx_1956"></a><tt>start-segment</tt> and <a name="%_idx_1958"></a><tt>end-segment</tt>.
</p>

<p class="trans" lang="ja">
<b>練習問題2.48.</b> 平面上の有向線分は、ベクトル——原点から線分の始点までのベクトルと、原点から線分の終点までのベクトル——の対として表せる。
<tt>make-segment</tt> というコンストラクタと、<tt>start-segment</tt> および <tt>end-segment</tt> というセレクタを有するような、線分用の表現を、練習問題<a href="#%_thm_2.46">2.46</a>での君のベクトル表現を使って、定義せよ。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_2.49"></a>
<b>Exercise 2.49.</b>  Use <tt>segments-&gt;painter</tt> to define the following primitive painters:</p>

<p class="trans" lang="ja">
<b>練習問題2.49.</b> <tt>segments-&gt;painter</tt> を用いて、以下の原始的ペインタを定義せよ。
</p>

<ol class="orig" lang="en" style="list-style-type: lower-alpha">
<li>The painter that draws the outline of the designated frame.</li>
<li>The painter that draws an ``X'' by connecting opposite corners of
the frame.</li>
<li>The painter that draws a diamond shape by connecting the midpoints of
the sides of the frame.</li>
<li>The <tt>wave</tt> painter.</li>
</ol>

<ol class="trans" lang="ja" style="list-style-type: lower-alpha">
<li>指定された枠の輪郭を描くペインタ。</li>
<li>枠の、向かい合う角同士を結ぶことで「X」を描くペインタ。</li>
<li>枠の辺の中点同士を結ぶことでダイヤ形を描くペインタ。</li>
<li><tt>wave</tt> ペインタ。</li>
</ol>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_Temp_219"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_219">Transforming and combining painters</a></h4>
<h4 class="trans" lang="ja">ペインタを変形し結合する</h4>

<p class="orig" lang="en"><a name="%_idx_1960"></a>
An operation on painters (such as <tt>flip-vert</tt> or <tt>beside</tt>)
works by creating a painter that invokes the original painters
with respect to frames derived from the argument frame.
Thus, for example, <tt>flip-vert</tt> doesn't have to know how a painter
works in order to flip it -- it just has to know how to turn a frame
upside down:
The flipped painter just uses the original painter,
but in the inverted frame.</p>

<p class="trans" lang="ja">
ペインタに対する (<tt>flip-vert</tt> あるいは <tt>beside</tt> のような) 演算は、引数の枠から導出される枠に対して元のペインタを呼び出すようなペインタを作成することで、動作する。
よって、たとえば <tt>flip-vert</tt> は、ペインタが自身をひっくり返すためにどのように動作するのかについて、知らなくてよい
——ただ、枠をどうやって上下さかさまにするのかさえ、知っていればよいのである。
ひっくり返されたペインタは、単に元のペインタを使うだけである——ただし、裏返しになった枠の中で、ではあるが。</p>

<p class="orig" lang="en">Painter operations are based on
the procedure <tt>transform-painter</tt>, which takes as arguments a painter and
information on how to transform a frame and
produces a new painter.  The transformed painter, when called on a frame,
transforms the frame and
calls the original painter on the transformed frame.
The arguments to <tt>transform-painter</tt> are points (represented as vectors)
that specify the corners of the new frame:
When mapped into
the frame, the first point specifies the new frame's origin
and the other two specify the ends of its edge vectors.
Thus, arguments within the
unit square specify a frame contained within the original frame.</p>

<p class="trans" lang="ja">
ペインタ演算は、<tt>transform-painter</tt> という手続きに基づいていて、この手続きは、引数として、ペインタと、枠をどう変形するのかについての情報を取り、新たなペインタを作り出す。
変形されたペインタは、ある枠について呼ばれると、その枠を変形し、変形した枠について元のペインタを呼び出す。
<tt>transform-painter</tt> に対する引数は、新たな枠の角を指定する点 (ベクトルとして表されている) である。
つまり、その枠の中に写像されたときに、1番目の点は新たな枠の原点を指定し、残りの二つは新たな枠の辺ベクトルの端を指定する。
よって、単位正方形の中に収まる引数は、元の枠の中に含まれる枠を指定する。
</p>

<p class="lisp"><a name="%_idx_1962"></a>(define (transform-painter painter origin corner1 corner2)
  (lambda (frame)
    (let ((m (frame-coord-map frame)))
      (let ((new-origin (m origin)))
        (painter
         (make-frame new-origin
                     (sub-vect (m corner1) new-origin)
                     (sub-vect (m corner2) new-origin)))))))
</p>

<p class="orig" lang="en">Here's how to flip painter images vertically:</p>

<p class="trans" lang="ja">
ここに、ペインタ画像を縦にひっくり返す方法を示す。
</p>

<p class="lisp"><a name="%_idx_1964"></a>(define (flip-vert painter)
  (transform-painter painter
                     (make-vect 0.0 1.0)   <em>; new <tt>origin</tt></em>
                     (make-vect 1.0 1.0)   <em>; new end of <tt>edge1</tt></em>
                     (make-vect 0.0 0.0))) <em>; new end of <tt>edge2</tt></em>
</p>

<p class="orig" lang="en">
Using <tt>transform-painter</tt>, we can easily define new transformations.
For example, we can define a painter that shrinks its image to the
upper-right quarter of the frame it is given:</p>

<p class="trans" lang="ja">
<tt>transform-painter</tt> を使うと、新しい変形を簡単に定義できる。
たとえば、自分の画像を、自分に与えられた枠の右上の四分の一へと縮めるようなペインタを、定義できる。
</p>

<p class="lisp"><a name="%_idx_1966"></a>(define (shrink-to-upper-right painter)
  (transform-painter painter
                     (make-vect 0.5 0.5)
                     (make-vect 1.0 0.5)
                     (make-vect 0.5 1.0)))
</p>

<p class="orig" lang="en">
Other transformations rotate images counterclockwise by 90 degrees<a name="call_footnote_Temp_220" href="#footnote_Temp_220"><sup><small>29</small></sup></a></p>

<p class="trans" lang="ja">
他の変形は、反時計回りに90度、画像を回転する<a href="#footnote_Temp_220"><sup><small>29</small></sup></a>か、
</p>

<p class="lisp"><a name="%_idx_1968"></a>(define (rotate90 painter)
  (transform-painter painter
                     (make-vect 1.0 0.0)
                     (make-vect 1.0 1.0)
                     (make-vect 0.0 0.0)))
</p>

<p class="orig" lang="en">
or squash images towards the center of the frame:<a name="call_footnote_Temp_221" href="#footnote_Temp_221"><sup><small>30</small></sup></a></p>

<p class="trans" lang="ja">
あるいは、枠の中心に向けて画像を押し込む<a href="#footnote_Temp_221"><sup><small>30</small></sup></a>。
</p>

<p class="lisp"><a name="%_idx_1970"></a>(define (squash-inwards painter)
  (transform-painter painter
                     (make-vect 0.0 0.0)
                     (make-vect 0.65 0.35)
                     (make-vect 0.35 0.65)))
</p>

<p class="orig" lang="en">Frame transformation is also the key to
defining means of combining two or more painters.
The <tt>beside</tt> procedure,
for example, takes two painters, transforms them
to paint in the left and right halves of an argument frame respectively,
and produces a new, compound painter.
When the compound painter is given a frame, it
calls the first transformed painter to paint in the left half of
the frame and calls the second transformed painter to paint in the
right half of the frame:</p>

<p class="trans" lang="ja">
枠の変形は、二つ以上のペインタを結合する手段を定義する鍵でもある。
たとえば、<tt>beside</tt> という手続きは、二つのペインタを取り、それらを変形して、引数の枠の左半分と右半分をそれぞれ描画し、新たな複合ペインタを作り出す。
その複合ペインタに枠が与えられると、その複合ペインタは、変形された1番目のペインタを呼び出して枠の左半分を描画し、変形された2番目のペインタを呼び出して枠の右半分を描画する。
</p>

<p class="lisp"><a name="%_idx_1972"></a>(define (beside painter1 painter2)
  (let ((split-point (make-vect 0.5 0.0)))
    (let ((paint-left
           (transform-painter painter1
                              (make-vect 0.0 0.0)
                              split-point
                              (make-vect 0.0 1.0)))
          (paint-right
           (transform-painter painter2
                              split-point
                              (make-vect 1.0 0.0)
                              (make-vect 0.5 1.0))))
      (lambda (frame)
        (paint-left frame)
        (paint-right frame)))))
</p>

<p class="orig" lang="en">Observe how the painter data abstraction, and in particular the
representation of painters as procedures, makes <tt>beside</tt> easy to
implement.  The <tt>beside</tt> procedure need not know anything
about the details of the component painters other than that each
painter will draw something in its designated frame.</p>

<p class="trans" lang="ja">
ペインタのデータ抽象化——とりわけ、手続きとしてのペインタの表現——が、いかに <tt>beside</tt> を実装しやすくしているかに、気づいてほしい。
 <tt>beside</tt> の手続きは、構成要素のペインタの詳細については、各ペインタが当該ペインタに指定された枠の中に何かを描くだろう、ということ以外は、何も知る必要がない。
</p>

<p class="orig" lang="en"><a name="%_thm_2.50"></a>
<b>Exercise 2.50.</b>  Define the transformation <a name="%_idx_1974"></a><tt>flip-horiz</tt>, which flips
painters horizontally, and transformations that rotate
painters counterclockwise by 180 degrees and 270 degrees.
</p>

<p class="trans" lang="ja">
<b>練習問題2.50.</b> <tt>flip-horiz</tt> という変形——ペインタを水平方向にひっくり返す——と、ペインタを反時計回りに180度および270度回転する変形を、定義せよ。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_2.51"></a>
<b>Exercise 2.51.</b>  Define the <a name="%_idx_1976"></a><tt>below</tt> operation for painters.  <tt>Below</tt> takes two
painters as arguments.  The resulting painter, given a frame,
draws with the first painter in the
bottom of the frame and with the second painter in the top.  Define <tt>below</tt> in two different ways -- first by writing a procedure that is
analogous to the <tt>beside</tt> procedure given above, and
again in terms of <tt>beside</tt> and suitable
rotation operations (from exercise <a href="#%_thm_2.50">2.50</a>).
</p>

<p class="trans" lang="ja">
<b>練習問題2.51.</b> ペインタ用の <tt>below</tt> という演算を定義せよ。
<tt>below</tt> は、二つのペインタを引数として取る。
結果として生じるペインタは、枠を与えられると、その枠の下側に1番目のペインタを使って描画し、上側に2番目のペインタを使って描画する。
<tt>below</tt> を、二つの異なる方法で定義せよ——まずは、上記の <tt>beside</tt> の手続きに類似の手続きを書くことによって、そして、もう一度は、<tt>beside</tt> と、(練習問題<a href="#%_thm_2.50">2.50</a>の) 適切な回転とを用いて。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_Temp_224"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_224">Levels of language for robust design</a></h4>
<h4 class="trans" lang="ja">頑健な設計のための言語の諸水準</h4>

<p class="orig" lang="en">The picture language exercises some of the critical ideas
we've introduced about abstraction with procedures and data.  The
fundamental data abstractions, painters, are implemented using
procedural representations, which enables the language to
handle different basic drawing capabilities in a uniform way.  The
means of combination satisfy the closure property, which permits us to
easily build up complex designs.  Finally, all the tools for
abstracting procedures are available to us for abstracting means of
combination for painters.</p>

<p class="trans" lang="ja">
お絵描き言語は、手続きとデータを使った抽象化について私たちが今までに導入してきた重要な概念のいくつかを鍛えてくれる。
基本的なデータ抽象化、すなわちペインタは、手続き的表現を使って実装されており、そのことによって、この言語は、異なる基本的描画能力を、一律なやり方で扱うことができるようになっている。
結合手段は閉包特性を満たし、そのことによって、私たちは、複雑な設計を簡単に築き上げることができる。
最後に、手続きを抽象化するためのすべての手段は、私たちがペインタ用の結合手段を抽象化するために利用可能である。
</p>

<p class="orig" lang="en">
We have also obtained a glimpse of another crucial idea about
languages and program design.  This is the approach of <a name="%_idx_1978"></a><a name="%_idx_1980"></a><em>stratified
design</em>, the notion that a complex system should be structured as a
sequence of levels that are described using a sequence of languages.
Each level is constructed by combining parts that are regarded as
primitive at that level, and the parts constructed at each level are
used as primitives at the next level.  The language used at each level
of a stratified design has primitives, means of combination, and means
of abstraction appropriate to that level of detail.</p>

<p class="trans" lang="ja">
私たちはまた、言語とプログラム設計についての別の重要な概念も、垣間見てきた。
これは、<em>階層化された設計</em>という取り組み方——つまり、複雑なシステムは、言語の列を使って記述されるような諸水準の列として構築されるべきだ、という考え方——である。
各水準は、その水準で原始的と見なされる部品同士を結合することで構築され、各水準で構築される部品は、次の水準ではプリミティブとして使われる。
階層化された設計の各水準で使われる言語には、その水準の詳細さに対して適切な、プリミティブと結合手段と抽象化手段がある。
</p>

<p class="orig" lang="en">Stratified design pervades the engineering of complex systems.  For
example, in computer engineering, resistors and transistors are
combined (and described using a language of analog circuits) to
produce parts such as and-gates and or-gates, which form the
primitives of a language for digital-circuit design.<a name="call_footnote_Temp_225" href="#footnote_Temp_225"><sup><small>31</small></sup></a>
These parts are combined to build
processors, bus structures, and memory systems, which are in turn
combined to form computers, using languages appropriate to computer
architecture.  Computers are combined to form distributed systems,
using languages appropriate for describing network interconnections,
and so on.</p>

<p class="trans" lang="ja">
階層化された設計は、複雑なシステムの工学の全体に浸透している。
たとえば、計算機工学では、レジスタやトランジスタは、結合され (かつ、アナログ回路の言葉を用いて記述され)、ANDゲートやORゲートなどの部品を作り出し、これらの部品は、ディジタル回路設計用の言語のプリミティブを形成する<a href="#footnote_Temp_225"><sup><small>31</small></sup></a>。
これらの部品は、結合されて、プロセッサやバス構造やメモリシステムを構築し、今度はそれらが、コンピュータを形成するために、コンピュータ・アーキテクチャに適した言語を使って結合される。
コンピュータは、分散システムを形成するために、ネットワークの相互連結を記述するのに適した言語を用いて結合される……などなどである。
</p>

<p class="orig" lang="en">As a tiny example of stratification, our picture language uses
primitive elements (primitive painters) that are created using a
language that specifies points and lines to provide the lists of line
segments for <tt>segments-&gt;painter</tt>, or the
shading details for a painter like <tt>rogers</tt>.  The bulk of our
description of the picture language focused on combining these
primitives, using geometric combiners such as <tt>beside</tt> and <tt>below</tt>.  We also worked at a higher level, regarding <tt>beside</tt> and
<tt>below</tt> as primitives to be manipulated in a language whose
operations, such as <tt>square-of-four</tt>, capture common patterns of
combining geometric combiners.</p>

<p class="trans" lang="ja">
階層化のほんの小さな例として、私たちのお絵描き言語は、<tt>segments-&gt;painter</tt> に線分のリストを与えるために点と線を指定する言語を使って作成される原始的要素 (原始的ペインタ) を使うし、あるいは、<tt>rogers</tt> のようなペインタに濃淡付けの詳細を与えるために云々といった原始的要素 (原始的ペインタ) を使う。<!--要検討-->
お絵描き言語についての私たちの説明の大部分は、これらのプリミティブ同士を結合することに対して焦点を当てていたわけだが、そこでは、<tt>beside</tt> や <tt>below</tt> のような幾何的結合子を用いていた。
私たちは、より高い水準でも作業した——つまり、その言語の演算 (<tt>square-of-four</tt> など) が、幾何的結合子同士を結合する共通のパタンを捉える、といったような言語において、操作されるべきプリミティブだ、というふうに、<tt>beside</tt> や <tt>below</tt> を見なしたわけである。
</p>

<p class="orig" lang="en"><a name="%_idx_1982"></a>Stratified design helps make programs <em>robust</em>, that is, it makes
it likely that small changes in a specification will require
correspondingly small changes in the program.  For instance, suppose
we wanted to change the image based on <tt>wave</tt> shown in
figure <a href="#%_fig_2.9">2.9</a>.  We could work at the lowest level
to change the detailed appearance of the <tt>wave</tt> element; we could
work at the middle level to change the way <tt>corner-split</tt>
replicates the <tt>wave</tt>; we could work at the highest level to
change how <tt>square-limit</tt> arranges the four copies of the corner.
In general, each level of a stratified design provides a different
vocabulary for expressing the characteristics of the system, and a
different kind of ability to change it.</p>

<p class="trans" lang="ja">
階層化された設計は、プログラムを<em>頑健</em>にするのに役立つ。つまり、仕様における小さな変更は、それに対応するように小さな変更しか、プログラムにおいて必要としないだろう、という見込みが、階層化された設計をすれば、高いわけである。
たとえば、図<a href="#%_fig_2.9">2.9</a>に示した <tt>wave</tt> に基づく画像を変更したいとする。
もっとも低い水準では、<tt>wave</tt> 要素の詳細な外観を変更するように、作業できることだろう。中間の水準では、<tt>corner-split</tt> が <tt>wave</tt> を複製する方法を変更するように、作業できることだろう。もっとも高い水準では、角の四つの写しを <tt>square-limit</tt> がどう配置するのかを変更するように、作業できることだろう。
一般に、階層化された設計の各水準は、システムの特性を表すための異なる語彙を提供し、その特性を変更する異なる種類の能力を提供する。
</p>

<p class="orig" lang="en">
<a name="%_thm_2.52"></a>
<b>Exercise 2.52.</b>  Make changes to the square limit of <tt>wave</tt> shown in
figure <a href="#%_fig_2.9">2.9</a> by working at each of the levels
described above.  In particular:</p>

<p class="trans" lang="ja">
<b>練習問題2.52.</b> 図<a href="#%_fig_2.9">2.9</a>に示した、<tt>wave</tt> の四角い極限に、上記の諸水準の各々において作業をすることにより、変更を加えよ。
特に、
</p>

<ol class="orig" lang="en" style="list-style-type: lower-alpha">
<li>Add some segments to the primitive <tt>wave</tt> painter
of exercise  <a href="#%_thm_2.49">2.49</a> (to add a smile, for example).</li>
<li>Change the pattern constructed by <tt>corner-split</tt>
(for example, by using only one copy of the
<tt>up-split</tt> and <tt>right-split</tt> images instead of two).</li>
<li>Modify the version of <tt>square-limit</tt> that uses <tt>square-of-four</tt>
so as to assemble the corners in a different pattern.  (For example, you
might make the big Mr. Rogers look outward from each corner of the square.)
</li>
</ol>

<p class="exercise"><span class="ex_comment">
</span></p>

<ol class="trans" lang="ja" style="list-style-type: lower-alpha">
<li>練習問題<a href="#%_thm_2.49">2.49</a>の、原始的な <tt>wave</tt> ペインタに、いくつかの線分を追加せよ (たとえば、笑顔を追加するなど)。</li>
<li><tt>corner-split</tt> により構築されるパタンを変更せよ (たとえば、<tt>up-split</tt> と <tt>right-split</tt> の画像のうち、二つではなく、ただ一つの写しだけを、用いることによって)。</li>
<li><tt>square-limit</tt> の、<tt>square-of-four</tt> を使うバージョンを、四隅を別のパタンで組み立てるように、修正せよ (たとえば、大きなロジャースさんに正方形の各々の角から外へと視線を向けさせてもよいだろう)。</li>
</ol>

<p class="exercise"><span class="ex_comment">
</span></p>


<a name="footnotes"></a>
<hr>

<p class="orig" lang="en">
<a name="footnote_Temp_154" href="#call_footnote_Temp_154"><sup><small>6</small></sup></a> 
The use of the word <a name="%_idx_1536"></a>``closure'' here comes from abstract algebra,
where a set of elements is said to be closed under an operation if
applying the operation to elements in the set produces an element that
is again an element of the set.  The Lisp community
also (unfortunately) uses the word ``closure'' to describe a totally unrelated
concept: A closure is an implementation technique for representing
procedures with free variables.  We do not use the word ``closure'' in
this second sense in this book.
</p>

<p class="trans" lang="ja">
ここでの「閉包」という単語の使い方は、抽象代数に由来している。抽象代数では、もし、ある演算を集合内の要素同士に対して適用することで、またしてもその集合の要素であるような要素が作り出されるならば、要素の集合は、その演算に関して閉じている、と言われる。
Lisp界では、(不幸なことに) 「閉包」という単語を、まったく無関係の概念を記述するのにも使う——閉包とは、自由変数をともなう手続きを表現するための実装技法である、というように。
本書では、この2番目の意味では「閉包」という単語を使わない。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_155" href="#call_footnote_Temp_155"><sup><small>7</small></sup></a> The notion that a means of
<a name="%_idx_1542"></a>combination should satisfy closure is a straightforward idea.
Unfortunately, the data combiners provided in many popular programming
languages do not satisfy closure, or make closure cumbersome to
exploit.  In <a name="%_idx_1544"></a>Fortran or <a name="%_idx_1546"></a>Basic, one typically combines data elements by
assembling them into arrays -- but one cannot form arrays whose
elements are themselves arrays.  <a name="%_idx_1548"></a>Pascal and <a name="%_idx_1550"></a>C admit structures whose
elements are structures.  However, this requires that the programmer
manipulate pointers explicitly, and adhere to the restriction that
each field of a structure can contain only elements of a prespecified form.
Unlike
Lisp with its pairs, these languages have no built-in general-purpose
glue that makes it easy to manipulate compound data in a uniform way.
This limitation lies behind Alan <a name="%_idx_1552"></a>Perlis's comment in his foreword to
this book: ``In Pascal the plethora of declarable data structures
induces a specialization within functions that inhibits and penalizes
casual cooperation.  It is better to have 100 functions operate on one
data structure than to have 10 functions operate on 10 data
structures.''
</p>

<p class="trans" lang="ja">
結合の手段は閉包を満たすべきだ、という見解は、分かりやすい考え方だ。
あいにく、よく使われる多くのプログラミング言語で提供されているデータ結合子は、閉包を満たさないか、活用するには複雑で面倒な閉包を作り出す。
FortranまたはBasicにおいては、典型的には、データ要素を配列に組み立てることで、それらのデータ要素を結合する——しかし、要素自体が配列であるような配列は、作れない。
PascalとCは、要素が構造体であるような構造体を許している。
しかし、これには、プログラマが明示的にポインタを操作することが必要であり、かつ、構造体の各フィールドは予め指定された形式の要素のみを含むことができる、という制約をプログラマが遵守することも必要である。
対を使っているLispとは違って、これらの言語には、複合的データを一律な方法で操作するのを簡単にしてくれるような、組み込みの汎用的接着剤がない。
このような制限が、本書への序言の中のアラン・パーリスの「 Pascalでは、気軽な協調を妨げたり罰したりしてしまうような、関数内部での特殊化を、過度に多い宣言可能なデータ構造が誘発してしまう。一つのデータ構造に関して動作する百の関数がある方が、十のデータ構造に関して動作する十の関数があるより良いのである。」というコメントの背後にあるのだ。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_156" href="#call_footnote_Temp_156"><sup><small>8</small></sup></a> In this book, we use <em>list</em> to mean a chain of
pairs terminated by the end-of-list marker.  In contrast, the term
<a name="%_idx_1572"></a><a name="%_idx_1574"></a><em>list structure</em> refers to any data structure made out of pairs,
not just to lists.
</p>

<p class="trans" lang="ja">
本書では、リスト終了の標識によって終わる、対の連なりのことを意味するように、<em>リスト</em>という言葉を用いる。
対照的に、<em>リスト構造</em>という言葉は、対から作られた任意のデータ構造のことを指し、リストのみを指すわけではない。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_157" href="#call_footnote_Temp_157"><sup><small>9</small></sup></a> Since nested applications of <tt>car</tt> and <tt>cdr</tt>
are cumbersome to write, Lisp dialects provide abbreviations for
them -- for instance,</p>

<p class="trans" lang="ja">
<tt>car</tt> と <tt>cdr</tt> の入れ子になった適用は、書くのには複雑で面倒なので、そのための略語をLispの諸方言は提供している——たとえば以下のように。
</p>

<figure>
<a name="%_idx_1584"></a><a name="%_idx_1586"></a>
<img src="ch2-Z-G-14.gif" border="0">
</figure>

<p class="orig" lang="en">
The names of all such procedures start with <tt>c</tt> and end with <tt>r</tt>.  Each <tt>a</tt> between them stands for a <a name="%_idx_1588"></a><a name="%_idx_1590"></a><tt>car</tt> operation and
each <tt>d</tt> for a <tt>cdr</tt> operation, to be applied in the same order
in which they appear in the name.  The names <tt>car</tt> and <tt>cdr</tt>
persist because simple combinations like <tt>cadr</tt> are
pronounceable.
</p>

<p class="trans" lang="ja">
すべてのそういう手続きの名前は、<tt>c</tt> で始まり、<tt>r</tt> で終わる。
それらの間の各々の <tt>a</tt> は <tt>car</tt> 演算を意味し、各々の <tt>d</tt> は <tt>cdr</tt> 演算を意味する——そしてこれらの演算は、名前の中に現れるのと同じ順序で適用されるべきものである。
<tt>car</tt> と <tt>cdr</tt> という名前は残存し続ける。というのも、<tt>cadr</tt> のような単純な組み合わせが発音可能だからだ。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_158" href="#call_footnote_Temp_158"><sup><small>10</small></sup></a> It's remarkable how much energy in the
standardization of Lisp dialects has been dissipated in arguments that
are literally over nothing: Should <tt>nil</tt> be an ordinary name?
Should the value of <tt>nil</tt> be a symbol?  Should it be a list?
Should it be a pair?  <a name="%_idx_1598"></a>In Scheme, <tt>nil</tt> is an ordinary name,
which we use in this section as a variable whose value is
the end-of-list marker (just as <tt>true</tt> is an ordinary variable
that has a true value).  Other dialects of
Lisp, including Common Lisp, treat <tt>nil</tt> as a special symbol.  The
<a name="%_idx_1600"></a>authors of this book, who have endured too many language
standardization brawls, would like to avoid the entire issue.  Once we
have introduced quotation in section <a href="16_sec2_3.html#%_sec_2.3">2.3</a>, we will
denote the empty list as <tt>'()</tt> and dispense with the
variable <tt>nil</tt> entirely.
</p>

<p class="trans" lang="ja">
Lispの諸方言の標準化において、文字どおり無をめぐる議論に、どれほど多くのエネルギーが浪費されてきたか、ということには、驚くべきものがある。
<tt>nil</tt> は普通の名前であるべきか?
<tt>nil</tt> の値はシンボルであるべきか?
それはリストであるべきか?
それは対であるべきか?
Schemeでは、<tt>nil</tt> は普通の名前であり、その普通の名前を、私たちは本節で、値がリスト終了の標識であるような変数として、使っている (ちょうど、<tt>true</tt> が真値を持つ普通の変数であるのと同様に)。
Lispの他の方言——Common Lispを含む——は、<tt>nil</tt> を特殊なシンボルとして扱う。
本書の著者たち——言語標準化についてのあまりに多くの騒々しい口論に耐えてきた——は、論点を丸ごと避けたいと思っている。
一旦、私たちが<a href="16_sec2_3.html#%_sec_2.3">2.3</a>節で引用を導入すれば、私たちは、空リストを <tt>'()</tt> と表すことにし、<tt>nil</tt> という変数をまったくなしで済ませよう。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_164" href="#call_footnote_Temp_164"><sup><small>11</small></sup></a> To define <tt>f</tt> and <tt>g</tt> using
<a name="%_idx_1656"></a><tt>lambda</tt> we would write
</p>

<p class="trans" lang="ja">
<tt>lambda</tt> を使って <tt>f</tt> と <tt>g</tt> を定義するためには、私たちは、次のように書くことだろう。
</p>

<p class="lisp">(define f (lambda (x y . z) &lt;<em>body</em>&gt;))
(define g (lambda w &lt;<em>body</em>&gt;))
</p>

<p class="orig" lang="en"><a name="footnote_Temp_166" href="#call_footnote_Temp_166"><sup><small>12</small></sup></a> Scheme
standardly provides a <a name="%_idx_1664"></a><tt>map</tt> procedure that is more general
than the one described here.
This more general <tt>map</tt>
takes a procedure of <em>n</em> arguments, together with <em>n</em> lists, and
applies the procedure to all the first elements of
the lists, all the second elements of the lists, and so on,
returning a list of the results.  For example:
</p>

<p class="trans" lang="ja">
Schemeは、標準的には、ここで説明したものよりも一般的な <tt>map</tt> 手続きを提供している。
その、より一般的な <tt>map</tt> は、<em class="en">n</em> 引数の手続きを、<em class="en">n</em> 個のリストとともに取り、その手続きを、それらのリストの1番目の要素すべてに対して適用し、それらのリストの2番目の要素すべてに対して適用し、などとしていって、その結果のリストを返す。たとえば以下のように。
</p>

<p class="lisp">(map + (list 1 2 3) (list 40 50 60) (list 700 800 900))
<i>(741 852 963)</i>

(map (lambda (x y) (+ x (* 2 y)))
     (list 1 2 3)
     (list 4 5 6))
<i>(9 12 15)</i>
</p>

<p class="orig" lang="en"><a name="footnote_Temp_170" href="#call_footnote_Temp_170"><sup><small>13</small></sup></a> The order of the
first two clauses in the <tt>cond</tt> matters, since the empty list
satisfies <tt>null?</tt> and also is not a pair.
</p>

<p class="trans" lang="ja">
<tt>cond</tt> の中での最初の二つの節の順序は重要だ。というのも、空リストは <tt>null?</tt> を満たし、かつ、対でもないからだ。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_182" href="#call_footnote_Temp_182"><sup><small>14</small></sup></a> This is, in fact, precisely the <a name="%_idx_1746"></a><tt>fringe</tt> procedure from
exercise <a href="#%_thm_2.28">2.28</a>.  Here we've renamed it to emphasize that
it is part of a family of general sequence-manipulation procedures.
</p>

<p class="trans" lang="ja">
これは、実は、正確には、練習問題<a href="#%_thm_2.28">2.28</a>の <tt>fringe</tt> 手続きである。
ここでは、それが一群の一般的な列操作手続きの一部であることを強調するために、それを改名した。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_183" href="#call_footnote_Temp_183"><sup><small>15</small></sup></a> <a name="%_idx_1760"></a>Richard Waters (1979)
developed a program that automatically analyzes traditional <a name="%_idx_1762"></a>Fortran
programs, viewing them in terms of maps, filters, and accumulations.
He found that fully 90 percent of the code in the Fortran Scientific
Subroutine Package fits neatly into this paradigm.  One of the reasons
for the success of Lisp as a programming language is that lists
provide a standard medium for expressing ordered collections so that
they can be manipulated using higher-order operations.  The
programming language <a name="%_idx_1764"></a>APL owes much of its power and appeal to a
similar choice. In APL all data are represented as arrays, and there is a
universal and convenient set of generic operators for all sorts of
array operations.
</p>

<p class="trans" lang="ja">
リチャード・ウォーターズ (1979) は、伝統的なFortranプログラムを自動的に分析するプログラムを開発した——マップ、フィルタ、累積の観点から、伝統的なFortranプログラムを見たのだ。
Fortran科学サブルーチン・パッケージで書かれたコードの少なくとも90%が、このプログラムにきちんと適合する、ということに彼は気づいた。
プログラミング言語としてのLispの成功の一因は、高階演算を使って順序付きの集まりを操作できるように、リストが、順序付きの集まりを表現するための標準的手段を提供していることにある。
プログラミング言語のAPLの能力と魅力の大部分は、似たような選択のおかげである。
APLでは、すべてのデータが配列として表現され、あらゆる種類の配列演算のための、普遍的で便利な、一般的演算の一揃いがある。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_186" href="#call_footnote_Temp_186"><sup><small>16</small></sup></a> According to <a name="%_idx_1776"></a>Knuth (1981), this rule was formulated by
<a name="%_idx_1778"></a>W. G. Horner early in the nineteenth century, but the method was
actually used by Newton over a hundred years earlier.  Horner's rule
evaluates the polynomial using fewer additions and multiplications
than does the straightforward method of first computing <em>a</em><sub><em>n</em></sub> <em>x</em><sup><em>n</em></sup>,
then adding <em>a</em><sub><em>n</em>-1</sub><em>x</em><sup><em>n</em>-1</sup>, and so on.  In fact, it is possible to
prove that any algorithm for evaluating arbitrary polynomials must use
at least as many additions and multiplications as does Horner's rule,
and thus Horner's rule is an <a name="%_idx_1780"></a><a name="%_idx_1782"></a>optimal algorithm for polynomial
evaluation.  This was proved (for the number of additions) by
<a name="%_idx_1784"></a>A. M. Ostrowski in a 1954 paper that essentially founded the modern
study of optimal algorithms.  The analogous statement for
multiplications was proved by <a name="%_idx_1786"></a>V. Y. Pan in 1966.  The book by <a name="%_idx_1788"></a>Borodin
and <a name="%_idx_1790"></a>Munro (1975) provides an overview of these and other results about
optimal algorithms.
</p>

<p class="trans" lang="ja">
クヌース (1981) によれば、この法則は、W. G. ホーナによって19世紀に定式化されたが、この方法は、実際には100年以上も前にニュートンにより使われていた。
ホーナの法則は、最初に
<span class="math"><em class="en">a<sub>n</sub> x<sup>n</sup></em></span>
を計算し、それから
<span class="math"><em class="en">a<sub>n&minus;1</sub> x<sup>n&minus;1</sup></em></span>
を足し、などとしていく単純な方法よりも、少ない回数の加算・乗算を使って、多項式を評価するものである。
実際、任意の多項式を評価するためのいかなるアルゴリズムも、少なくとも、ホーナの法則と同じ回数の加算と乗算を使わなくてはならない、ということを証明することが可能であり、したがって、ホーナの法則は、多項式の評価のための最適なアルゴリズムである。
このことは、(加算の回数に関しては) A. M. オストロウスキにより、最適な諸アルゴリズムについての近代的研究を本質的に打ち立てた1954年の論文において、証明された。
乗算についての類似の陳述は、V. Y. パンにより、1966年に証明された。
ボロディンとマンロウによる著作 (1975年) は、最適な諸アルゴリズムについての、これらの成果とその他の成果の、概要を示してくれる。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_190" href="#call_footnote_Temp_190"><sup><small>17</small></sup></a> This definition uses the
extended version of <tt>map</tt> described in footnote <a href="#footnote_Temp_166">12</a>.
</p>

<p class="trans" lang="ja">
この定義では、脚注<a href="#footnote_Temp_166">12</a>で述べた拡張版の <tt>map</tt> を使う。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_194" href="#call_footnote_Temp_194"><sup><small>18</small></sup></a> This approach to nested mappings was shown
to us by <a name="%_idx_1820"></a>David Turner, whose languages <a name="%_idx_1822"></a>KRC and <a name="%_idx_1824"></a>Miranda provide elegant
formalisms for dealing with these constructs.  The examples in this
section (see also exercise <a href="#%_thm_2.42">2.42</a>) are adapted from Turner
1981.  In section <a href="24_sec3_5.html#%_sec_3.5.3">3.5.3</a>, we'll see how this
approach generalizes to infinite sequences.
</p>

<p class="trans" lang="ja">
入れ子になった写像に対するこの取り組み方は、デイヴィッド・ターナ——彼の言語であるKRCとMirandaは、これらの構築物を扱うための、洗練された形式を提供してくれる——によって、示された。
本節での例 (練習問題<a href="#%_thm_2.42">2.42</a>も参照) は、Turner 1981 から転用したものである。
<a href="24_sec3_5.html#%_sec_3.5.3">3.5.3</a>節では、この取り組み方がどのようにして無限列へと一般化するのかを見よう。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_195" href="#call_footnote_Temp_195"><sup><small>19</small></sup></a> We're
representing a pair here as a list of two elements rather than as a
Lisp pair.  Thus, the ``pair'' (<em>i</em>,<em>j</em>) is represented as <tt>(list i
j)</tt>, not <tt>(cons i j)</tt>.
</p>

<p class="trans" lang="ja">
ここでは、Lispの対として対を表すのではなく、むしろ、二つの要素のリストとして対を表している。
よって、
<span class="math">(<em class="en">i</em>, <em class="en">j</em>)</span>
という「対」は、
<tt>(list i j)</tt>
として表されるのであって、
<tt>(cons i j)</tt>
として表されるわけではない。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_196" href="#call_footnote_Temp_196"><sup><small>20</small></sup></a> The set <em>S</em> - <em>x</em> is the set of all elements
of <em>S</em>, excluding <em>x</em>.
</p>

<p class="trans" lang="ja">
<span class="math"><em class="en">S</em> &minus; <em class="en">x</em></span>
という集合は、<em class="en">x</em> を除外した、<em class="en">S</em> のすべての要素からなる集合である。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_197" href="#call_footnote_Temp_197"><sup><small>21</small></sup></a> <a name="%_idx_1834"></a><a name="%_idx_1836"></a><a name="%_idx_1838"></a>Semicolons in Scheme code are used to
introduce <em>comments</em>.  Everything from the semicolon to the end of
the line is ignored by the interpreter.  In this book we don't use
many comments; we try to make our programs self-documenting by using
descriptive names.
</p>

<p class="trans" lang="ja">
Schemeのコードにおけるセミコロンは、<em>コメント</em>を導入するのに使われる。
セミコロンから行末までのすべては、インタプリタに無視される。
本書では、私たちはあまり多くのコメントは使わない。
私たちは、記述的な名前を使うことで、プログラムを、自ら文書化するものたらしめようとしている。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_202" href="#call_footnote_Temp_202"><sup><small>22</small></sup></a> The picture language is based on the language
<a name="%_idx_1856"></a>Peter Henderson created to construct
images like <a name="%_idx_1858"></a>M.C. Escher's ``Square Limit'' woodcut (see Henderson 1982).
The woodcut incorporates a
repeated scaled pattern, similar to the arrangements drawn using
the <tt>square-limit</tt> procedure in this section.
</p>

<p class="trans" lang="ja">
このお絵描き言語は、M. C. エッシャーの「四角い極限」という木版画のような画像を構築するためにピーター・ヘンダーソンが創作した言語に基づいている (Henderson 1982 を参照)。
その木版画は、繰り返しの変倍されたパタンを組み入れており、本節の <tt>square-limit</tt> という手続きを使って描かれる配置と似ている。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_204" href="#call_footnote_Temp_204"><sup><small>23</small></sup></a> <a name="%_idx_1866"></a><a name="%_idx_1868"></a>William Barton Rogers (1804-1882) was the founder and first president
of MIT.  A geologist and talented teacher, he taught at William and
Mary College and at the University of Virginia.  In 1859 he moved to
Boston, where he had more time for research, worked on a plan
for establishing a ``polytechnic institute,'' and served as
Massachusetts's first State Inspector of Gas Meters.</p>
</p>

<p class="trans" lang="ja">
ウィリアム・バートン・ロジャース (1804〜1882) は、MITの創立者かつ初代学長だった。
地質学者であり有能な教師であった彼は、ウィリアム・アンド・メアリ大学およびヴァージニア大学で教鞭をとった。
1859年に彼はボストンに引っ越し、そこでは、より多くの時間を研究に費やし、「工業技術教育機関」を設立するための計画に取り組み、マサチューセッツ州の初代ガスメータ検査官を務めた。
</p>

<p class="orig" lang="en">When MIT was established in 1861, Rogers was elected its first
president.  Rogers espoused an ideal of ``useful learning'' that was
different from the university education of the time, with its
overemphasis on the classics, which, as he wrote, ``stand in the way of
the broader, higher and more practical instruction and discipline of
the natural and social sciences.''  This education was likewise to be
different from narrow trade-school education.  In Rogers's words:
</p>

<p class="trans" lang="ja">
MITが1861年に創立されたとき、ロジャースは、その初代学長に選出された。
ロジャースは、古典——彼が書いたように、「自然科学・社会科学の、より広く、より高く、より実践的な教育と訓練を妨げる」——の過度の強調をともなった当時の大学教育とは異なる、「有用な学習」という理想を奉じた。
この教育は、職業学校の限られた教育とも異なるべきものだった。
ロジャースの言によれば、
</p>

<blockquote class="orig" lang="en">The world-enforced distinction between the practical and the
scientific worker is utterly futile, and the whole experience of
modern times has demonstrated its utter worthlessness.
</blockquote>

<blockquote class="trans" lang="ja">
「現場の者と科学的労働者との間の、世界的に押し付けられている差異は、まったく無益なものであり、それがまったく無価値なことは、現代の経験すべてが実証してきた」。
</blockquote>

<p class="orig" lang="en">Rogers served as president of MIT until 1870, when he resigned due to
ill health.  In 1878 the second president of MIT, <a name="%_idx_1870"></a>John Runkle,
resigned under the pressure of a financial crisis brought on by the
Panic of 1873 and strain of fighting off attempts by Harvard to take
over MIT.  Rogers returned to hold the office of president until
1881.</p>

<p class="trans" lang="ja">
ロジャースはMITの学長を1870年まで務めた——その年に彼は、健康を害したので辞任したのである。
1878年には、MITの第二代学長であるジョン・ランクルが、1873年の経済恐慌によりもたらされた財政危機の重圧と、MITを乗っ取ろうとしてハーバードが力づくで闘う挑戦という悩みのせいで、辞任した。
ロジャースは復帰して、1881年まで学長の任に当たった。
</p>

<p class="orig" lang="en">Rogers collapsed and died while addressing MIT's graduating class at
the commencement exercises of 1882.  Runkle quoted Rogers's last
words in a memorial address delivered that same year:
</p>

<p class="trans" lang="ja">
ロジャースは、1882年の学位授与式における学位授与講義で講演している最中に倒れ、亡くなった。
ランクルは、同年に行われた記念講演において、ロジャースの最後の言葉を引用した。
</p>

<blockquote class="orig" lang="en">``As I stand here today and see what the Institute is, <tt>...</tt> I call
to mind the beginnings of science.  I remember one hundred and fifty
years ago Stephen Hales published a pamphlet on the subject of
illuminating gas, in which he stated that his researches had
demonstrated that 128 grains of bituminous coal -- ''
<a name="%_idx_1872"></a>
</blockquote>

<blockquote class="trans" lang="ja">
「本日ここに立って本学がどのようなものであるかを見るとき……私は、科学の始まりを思い起こす。
私は、150年前にスティーヴン・ヘイルズが、照明ガスの主題についての小冊子を出版したことを思い出す——その小冊子で彼が述べたていたこととは、彼の研究で立証されたところによれば、128グレイン (約8.3グラム) の瀝青質の石炭が……」
</blockquote>

<blockquote class="orig" lang="en">
``Bituminous coal,'' these were his last words on earth.  Here he bent
forward, as if consulting some notes on the table before him, then
slowly regaining an erect position, threw up his hands, and was
translated from the scene of his earthly labors and triumphs to ``the
tomorrow of death,'' where the mysteries of life are solved, and the
disembodied spirit finds unending satisfaction in contemplating the
new and still unfathomable mysteries of the infinite future.
</blockquote>

<blockquote class="trans" lang="ja">
「瀝青質の石炭が」という、これらの言葉が、彼のこの世で最後の言葉だった。
ここで彼は前向きに屈み込んで——まるで、前にある机の上の何らかの覚え書きを参照するかのように——そして、真っ直ぐの体勢をゆっくりと取り戻しながら、両手を振り上げ、彼のこの世での労苦と偉業の場面から、「死という明日」へと移された——そしてそこでは、生命の謎は解明されていて、肉体を離れた霊魂は、無限の未来の、新しくてまだ理解できない謎をじっくり考えることに対して限りなき満足を見出しているのだ。
</blockquote>

<p class="orig" lang="en">
In the words of  Francis A. Walker
<a name="%_idx_1874"></a>(MIT's third president):
</p>

<p class="trans" lang="ja">
フランシス・A・ウォーカー (MITの第3代学長) の言葉によれば、
</p>

<blockquote class="orig" lang="en">All his life he had borne himself most faithfully and heroically, and
he died as so good a knight would surely have wished, in harness, at
his post, and in the very part and act of public duty.
</blockquote>

<blockquote class="trans" lang="ja">
生涯を通じて彼は、とても誠実かつ勇敢に振る舞ってきたし、とてもすぐれた勲爵士なら確かに望んだであろう、という亡くなり方をした——仕事中に、自分の持ち場で、まさに自分の役割と公的義務の行動の中で。
</blockquote>

<p class="orig" lang="en"><a name="footnote_Temp_207" href="#call_footnote_Temp_207"><sup><small>24</small></sup></a> Equivalently, we could
write
</p>

<p class="trans" lang="ja">
等価に、次のようにも書けただろう。
</p>

<p class="lisp"><a name="%_idx_1902"></a>(define flipped-pairs
  (square-of-four identity flip-vert identity flip-vert))
</p>

<p class="orig" lang="en"><a name="footnote_Temp_208" href="#call_footnote_Temp_208"><sup><small>25</small></sup></a> <tt>Rotate180</tt>
rotates a painter by 180 degrees (see exercise <a href="#%_thm_2.50">2.50</a>).
Instead of <tt>rotate180</tt> we could say <tt>(compose flip-vert flip-horiz)</tt>, using
the <tt>compose</tt> procedure from exercise <a href="12_sec1_3.html#%_thm_1.42">1.42</a>.
</p>

<p class="trans" lang="ja">
<tt>rotate180</tt> は、ペインタを180度回転する (練習問題<a href="#%_thm_2.50">2.50</a>を参照)。
<tt>rotate180</tt> の代わりに、<tt>(compose flip-vert flip-horiz)</tt> と言うこともできただろう——練習問題<a href="12_sec1_3.html#%_thm_1.42">1.42</a>の <tt>compose</tt> という手続きを使えば。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_211" href="#call_footnote_Temp_211"><sup><small>26</small></sup></a> <tt>Frame-coord-map</tt> uses
the vector operations described in exercise <a href="#%_thm_2.46">2.46</a> below, which we
assume have been implemented using some representation for vectors.
Because of data abstraction, it doesn't matter what this vector
representation is, so long as the vector operations behave correctly.
</p>

<p class="trans" lang="ja">
<tt>frame-coord-map</tt> は、練習問題<a href="#%_thm_2.46">2.46</a>で後述するベクトル演算を使っており、私たちは、これらのベクトル演算が、ベクトルのための何らかの表現を用いて既に実装されている、と想定している。
データ抽象化のおかげで、このベクトル表現が何であるかは重要でない——ベクトル演算が正しく振る舞う限りは。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_215" href="#call_footnote_Temp_215"><sup><small>27</small></sup></a> <tt>Segments-&gt;painter</tt> uses the representation for line
segments described in exercise <a href="#%_thm_2.48">2.48</a> below.
It also uses the <tt>for-each</tt> procedure described in exercise <a href="#%_thm_2.23">2.23</a>.
</p>

<p class="trans" lang="ja">
<tt>segments-&gt;painter</tt> は、後述の練習問題<a href="#%_thm_2.48">2.48</a>で説明されている、線分のための表現を利用している。
また、練習問題<a href="#%_thm_2.23">2.23</a>で説明されている、<tt>for-each</tt> という手続きも、利用している。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_216" href="#call_footnote_Temp_216"><sup><small>28</small></sup></a> For example, the <tt>rogers</tt> painter of
figure <a href="#%_fig_2.11">2.11</a> was constructed from a gray-level image.
For each point in a given frame,
the <tt>rogers</tt> painter determines the point in the image that is mapped to it
under the frame coordinate map, and shades it
accordingly.  By allowing different types of painters, we are capitalizing on the
abstract data idea discussed in section <a href="14_sec2_1.html#%_sec_2.1.3">2.1.3</a>, where we
argued that a rational-number representation could be anything at all that
satisfies an appropriate condition.  Here we're using the fact that a
painter can be implemented in any way at all, so long as it draws
something in the designated frame.  Section <a href="14_sec2_1.html#%_sec_2.1.3">2.1.3</a> also
showed how pairs could be implemented as procedures.  Painters are our
second example of a procedural representation for data.
</p>

<p class="trans" lang="ja">
たとえば、図<a href="#%_fig_2.11">2.11</a>における <tt>rogers</tt> というペインタは、階調画像から構築された。
与えられた枠の中の各点に対して、<tt>rogers</tt> というペインタは、枠座標写像のもとで当該の点に写像されるような、画像内の点を判定し、それにしたがって当該の点に濃淡をつける。
異なる種類のペインタを許容することで、私たちは、<a href="14_sec2_1.html#%_sec_2.1.3">2.1.3</a>節——有理数の表現は、適切な条件を満たすものなら、とにかく何ででもあり得る、と論じた——で議論した、抽象的データの考え方を、利用しているわけだ。
ここで私たちは、指定された枠の中にペインタが何かを描く限りは、ペインタは、とにかくどんな方法でも実装できる、という事実を使っている。
<a href="14_sec2_1.html#%_sec_2.1.3">2.1.3</a>節でも、対がどのようにして手続きとして実装され得るのかを示した。
ペインタは、データの手続き的表現の第二の例なのである。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_220" href="#call_footnote_Temp_220"><sup><small>29</small></sup></a> <tt>Rotate90</tt> is a pure rotation only for square
frames, because it also stretches and shrinks the image to fit into
the rotated frame.
</p>

<p class="trans" lang="ja">
<tt>rotate90</tt> は、正方形の枠のためだけの単なる回転である。というのも、これは、回転された枠に合うように画像を伸縮させもするからだ。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_221" href="#call_footnote_Temp_221"><sup><small>30</small></sup></a> The diamond-shaped images in figures <a href="#%_fig_2.10">2.10</a>
and <a href="#%_fig_2.11">2.11</a> were created with <tt>squash-inwards</tt> applied to
<tt>wave</tt> and <tt>rogers</tt>.
</p>

<p class="trans" lang="ja">
図<a href="#%_fig_2.10">2.10</a>と図<a href="#%_fig_2.11">2.11</a>の中のダイヤ型の画像は、<tt>wave</tt> と <tt>rogers</tt> に <tt>squash-inwards</tt> を適用したものを用いて、作成された。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_225" href="#call_footnote_Temp_225"><sup><small>31</small></sup></a> Section <a href="22_sec3_3.html#%_sec_3.3.4">3.3.4</a> describes one such language.
</p>

<p class="trans" lang="ja">
<a href="22_sec3_3.html#%_sec_3.3.4">3.3.4</a>節では、そのような言語の一つを説明する。
</p>


</div>

</body>
</html>
