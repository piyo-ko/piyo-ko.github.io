<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<link rel="stylesheet" href="sicp.css" type="text/css">
	<base target="_top">
	<title>Structure and Interpretation of Computer Programs: SICPç§è¨³</title>
</head>

<body>

<div class="idx-bar">
<nav>
<a href="https://twitter.com/share" class="twitter-share-button" data-lang="ja">ãƒ„ã‚¤ãƒ¼ãƒˆ</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
<span class="status">æ¨æ•²å¾…ã¡</span>
[
<a href="00_cover.html">å…ˆé ­ã¸</a> |
<a href="14_sec2_1.html">å‰ã¸</a> |
<a href="16_sec2_3.html">æ¬¡ã¸</a> | 
<a href="04_toc.html#%_toc_start">ç›®æ¬¡</a> |
<a href="38_index.html#%_index_start">ç´¢å¼•</a>
] [<a href="99_about.html">ã“ã®å¯¾è¨³ç‰ˆã«ã¤ã„ã¦</a> | <a href="../index.html">ãƒ›ãƒ¼ãƒ </a>]
[
Â§<a href="#%_sec_2.2">2.2</a>
ğŸ¨<a href="#%_fig_2.2">2.2</a>
ğŸ¨<a href="#%_fig_2.3">2.3</a>
Â§<a href="#%_sec_2.2.1">2.2.1</a>
ğŸ¨<a href="#%_fig_2.4">2.4</a>
ğŸ“š<a href="#%_sec_Temp_159">&hellip;</a>
ğŸ“<a href="#%_thm_2.17">2.17</a>
ğŸ“<a href="#%_thm_2.18">2.18</a>
ğŸ“<a href="#%_thm_2.19">2.19</a>
ğŸ“<a href="#%_thm_2.20">2.20</a>
ğŸ“š<a href="#%_sec_Temp_165">&hellip;</a>
ğŸ“<a href="#%_thm_2.21">2.21</a>
ğŸ“<a href="#%_thm_2.22">2.22</a>
ğŸ“<a href="#%_thm_2.23">2.23</a>
Â§<a href="#%_sec_2.2.2">2.2.2</a>
ğŸ¨<a href="#%_fig_2.5">2.5</a>
ğŸ¨<a href="#%_fig_2.6">2.6</a>
ğŸ“<a href="#%_thm_2.24">2.24</a>
ğŸ“<a href="#%_thm_2.25">2.25</a>
ğŸ“<a href="#%_thm_2.26">2.26</a>
ğŸ“<a href="#%_thm_2.27">2.27</a>
ğŸ“<a href="#%_thm_2.28">2.28</a>
ğŸ“<a href="#%_thm_2.29">2.29</a>
ğŸ“š<a href="#%_sec_Temp_177">&hellip;</a>
ğŸ“<a href="#%_thm_2.30">2.30</a>
ğŸ“<a href="#%_thm_2.31">2.31</a>
ğŸ“<a href="#%_thm_2.32">2.32</a>
Â§<a href="#%_sec_2.2.3">2.2.3</a>
ğŸ¨<a href="#%_fig_2.7">2.7</a>
ğŸ“š<a href="#%_sec_Temp_181">&hellip;</a>
ğŸ“<a href="#%_thm_2.33">2.33</a>
ğŸ“<a href="#%_thm_2.34">2.34</a>
ğŸ“<a href="#%_thm_2.35">2.35</a>
ğŸ“<a href="#%_thm_2.36">2.36</a>
ğŸ“<a href="#%_thm_2.37">2.37</a>
ğŸ“<a href="#%_thm_2.38">2.38</a>
ğŸ“<a href="#%_thm_2.39">2.39</a>
ğŸ“š<a href="#%_sec_Temp_193">&hellip;</a>
ğŸ“<a href="#%_thm_2.40">2.40</a>
ğŸ“<a href="#%_thm_2.41">2.41</a>
ğŸ“<a href="#%_thm_2.42">2.42</a>
ğŸ¨<a href="#%_fig_2.8">2.8</a>
ğŸ“<a href="#%_thm_2.43">2.43</a>
Â§<a href="#%_sec_2.2.4">2.2.4</a>
ğŸ¨<a href="#%_fig_2.9">2.9</a>
ğŸ“š<a href="#%_sec_Temp_203">&hellip;</a>
ğŸ¨<a href="#%_fig_2.10">2.10</a>
ğŸ¨<a href="#%_fig_2.11">2.11</a>
ğŸ¨<a href="#%_fig_2.12">2.12</a>
ğŸ¨<a href="#%_fig_2.13">2.13</a>
ğŸ¨<a href="#%_fig_2.14">2.14</a>
ğŸ“<a href="#%_thm_2.44">2.44</a>
ğŸ“š<a href="#%_sec_Temp_206">&hellip;</a>
ğŸ“<a href="#%_thm_2.45">2.45</a>
ğŸ“š<a href="#%_sec_Temp_210">&hellip;</a>
ğŸ¨<a href="#%_fig_2.15">2.15</a>
ğŸ“<a href="#%_thm_2.46">2.46</a>
ğŸ“<a href="#%_thm_2.47">2.47</a>
ğŸ“š<a href="#%_sec_Temp_214">&hellip;</a>
ğŸ“<a href="#%_thm_2.48">2.48</a>
ğŸ“<a href="#%_thm_2.49">2.49</a>
ğŸ“š<a href="#%_sec_Temp_219">&hellip;</a>
ğŸ“<a href="#%_thm_2.50">2.50</a>
ğŸ“<a href="#%_thm_2.51">2.51</a>
ğŸ“š<a href="#%_sec_Temp_224">&hellip;</a>
ğŸ“<a href="#%_thm_2.52">2.52</a>
<a href="#footnotes">è„šæ³¨</a>
]
</nav>

</div>

<div class="main-txt">

<a name="%_sec_2.2"></a>
<h2 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_2.2">2.2  Hierarchical Data and the Closure Property</a></h2>
<h2 class="trans" lang="ja">2.2 éšå±¤çš„ãƒ‡ãƒ¼ã‚¿ã¨é–‰åŒ…ç‰¹æ€§</h2>

<p class="orig" lang="en">
As we have seen, pairs provide a primitive ``glue'' that we can use to
construct compound data objects.
Figure <a href="#%_fig_2.2">2.2</a> shows a standard way to
visualize a <a name="%_idx_1526"></a>pair -- in this case, the pair formed by <tt>(cons 1 2)</tt>.
In this representation, which is called <a name="%_idx_1528"></a><em>box-and-pointer
notation</em>, each object is shown as a <a name="%_idx_1530"></a><em>pointer</em> to a box.  The box
for a primitive object contains a representation of the object.  For
example, the box for a number contains a numeral.  The box for a pair
is actually a double box, the left part containing (a pointer to) the
<tt>car</tt> of the pair and the right part containing the <tt>cdr</tt>.</p>

<p class="trans" lang="ja">
ä»Šã¾ã§è¦‹ã¦ããŸã¨ãŠã‚Šã€å¯¾ã¯ã€è¤‡åˆçš„ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ§‹ç¯‰ãŸã‚ã«ä½¿ãˆã‚‹ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ãªã€Œæ¥ç€å‰¤ã€ã‚’æä¾›ã—ã¦ãã‚Œã‚‹ã€‚
å›³<a href="#%_fig_2.2">2.2</a>ã¯ã€å¯¾â€”â€”ã“ã®äº‹ä¾‹ã§ã¯ã€<tt>(cons 1 2)</tt> ã«ã‚ˆã‚Šå½¢æˆã•ã‚ŒãŸå¯¾â€”â€”ã‚’å›³åƒåŒ–ã™ã‚‹ãŸã‚ã®ã€æ¨™æº–çš„æ–¹æ³•ã‚’ç¤ºã—ã¦ã„ã‚‹ã€‚
ã“ã®è¡¨ç¾â€”â€”<em>ç®±ãƒ»ãƒã‚¤ãƒ³ã‚¿å¼ã®è¡¨è¨˜</em>ã¨å‘¼ã°ã‚Œã‚‹â€”â€”ã§ã¯ã€å„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ç®±ã¸ã®<em>ãƒã‚¤ãƒ³ã‚¿</em>ã¨ã—ã¦ç¤ºã•ã‚Œã‚‹ã€‚
ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç®±ã¯ã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®è¡¨ç¾ã‚’å«ã‚€ã€‚
ãŸã¨ãˆã°ã€æ•°ã®ç®±ã¯ã€æ•°å­—ã‚’å«ã‚€ã€‚
å¯¾ã®ç®±ã¯ã€å®Ÿéš›ã«ã¯äºŒé€£ç¶šã®ç®±ã§ã‚ã‚Šã€å·¦ã®éƒ¨åˆ†ã¯ãã®å¯¾ã® <tt>car</tt> (ã¸ã®ãƒã‚¤ãƒ³ã‚¿) ã‚’å«ã¿ã€å³ã®éƒ¨åˆ†ã¯ <tt>cdr</tt> ã‚’å«ã‚€ã€‚
</p>

<p class="orig" lang="en">
We have already seen that <tt>cons</tt> can be used to combine not
only numbers but pairs as well.  (You made use of this fact, or
should have, in doing exercises <a href="14_sec2_1.html#%_thm_2.2">2.2</a>
and <a href="14_sec2_1.html#%_thm_2.3">2.3</a>.)  As a consequence, pairs provide a universal
building block from which we can construct all sorts of data
structures.  Figure <a href="#%_fig_2.3">2.3</a> shows two ways
to use pairs to combine the numbers 1, 2, 3, and 4.</p>

<p class="trans" lang="ja">
<tt>cons</tt> ãŒã€æ•°ã‚’çµåˆã™ã‚‹ãŸã‚ã«ä½¿ãˆã‚‹ã ã‘ã§ãªãã€å¯¾ã‚’çµåˆã™ã‚‹ãŸã‚ã«ã‚‚åŒæ§˜ã«ä½¿ãˆã‚‹ã€ã¨ã„ã†ã“ã¨ã‚’ç§ãŸã¡ã¯æ—¢ã«è¦‹ãŸã€‚
(ç·´ç¿’å•é¡Œ<a href="14_sec2_1.html#%_thm_2.2">2.2</a>ã¨<a href="14_sec2_1.html#%_thm_2.3">2.3</a>ã‚’è§£ãã¨ãã«ã€å›ã¯ã“ã®äº‹å®Ÿã‚’åˆ©ç”¨ã—ãŸã€ã‚ã‚‹ã„ã¯ã€ã—ãŸã¯ãšã§ã‚ã‚‹ã€‚)
çµæœã¨ã—ã¦ã€å¯¾ã¯ã€ã‚ã‚‰ã‚†ã‚‹ç¨®é¡ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’æ§‹ç¯‰ã§ãã‚‹å…ƒã¨ãªã‚‹æ™®éçš„ãªåŸºæœ¬æ§‹æˆè¦ç´ ã‚’æä¾›ã™ã‚‹ã€‚
å›³<a href="#%_fig_2.3">2.3</a>ã¯ã€å¯¾ã‚’ä½¿ã£ã¦1ã€2ã€3ã€4ã¨ã„ã†æ•°ã‚’çµåˆã™ã‚‹ãŸã‚ã®äºŒã¤ã®æ–¹æ³•ã‚’ç¤ºã—ã¦ã„ã‚‹ã€‚
</p>

<figure>
<a name="%_fig_2.2"></a>
<img src="ch2-Z-G-11.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 2.2:</b>  Box-and-pointer representation of <tt>(cons 1 2)</tt>.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³2.2:</b> <tt>(cons 1 2)</tt> ã®ç®±ãƒ»ãƒã‚¤ãƒ³ã‚¿å¼ã®è¡¨ç¾</figcaption>
</figure>

<figure>
<a name="%_fig_2.3"></a>
<img src="ch2-Z-G-12.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 2.3:</b>  Two ways to combine 1, 2, 3, and 4 using pairs.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³2.3:</b> å¯¾ã‚’ä½¿ã£ã¦1ã€2ã€3ã€4ã‚’çµåˆã™ã‚‹ãŸã‚ã®äºŒã¤ã®æ–¹æ³•</figcaption>
</figure>

<p class="orig" lang="en">The ability to create pairs whose elements are pairs is the essence of
list structure's importance as a representational tool.  We refer to
this ability as the <a name="%_idx_1532"></a><a name="%_idx_1534"></a><em>closure property</em> of <tt>cons</tt>.  In general,
an operation for combining data objects satisfies the closure property
if the results of combining things with that operation can themselves
be combined using the same operation.<a name="call_footnote_Temp_154" href="#footnote_Temp_154"><sup><small>6</small></sup></a>
Closure is the key to power in
any means of combination because it permits us to create <a name="%_idx_1538"></a><a name="%_idx_1540"></a><em>hierarchical</em> structures -- structures made up of parts, which
themselves are made up of parts, and so on.</p>

<p class="trans" lang="ja">
è¦ç´ ãŒå¯¾ã§ã‚ã‚‹ã‚ˆã†ãªå¯¾ã‚’ä½œæˆã™ã‚‹èƒ½åŠ›ã¯ã€è¡¨ç¾ã®é“å…·ã¨ã—ã¦ã®ãƒªã‚¹ãƒˆæ§‹é€ ã®é‡è¦æ€§ã®æœ¬è³ªã§ã‚ã‚‹ã€‚
ã“ã®èƒ½åŠ›ã®ã“ã¨ã‚’ã€ç§ãŸã¡ã¯ã€<tt>cons</tt>ã®<em>é–‰åŒ…ç‰¹æ€§</em>ã¨å‘¼ã‚“ã§ã„ã‚‹ã€‚
ä¸€èˆ¬çš„ã«ã€ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆåŒå£«ã‚’çµåˆã™ã‚‹ãŸã‚ã®æ¼”ç®—ã¯ã€ã‚‚ã—ã€ãã®æ¼”ç®—ã«ã‚ˆã£ã¦ã‚‚ã®åŒå£«ã‚’çµåˆã—ãŸçµæœãŒã€ãã‚Œè‡ªä½“ã€ãã®åŒã˜æ¼”ç®—ã‚’ç”¨ã„ã¦çµåˆã§ãã‚‹ãªã‚‰ã°ã€é–‰åŒ…ç‰¹æ€§ã‚’æº€ãŸã™<a href="#footnote_Temp_154"><sup><small>6</small></sup></a>ã€‚
é–‰åŒ…ã¯ã€ã©ã®çµåˆæ‰‹æ®µã«ãŠã„ã¦ã‚‚ã€åŠ›ã«ã¤ãªãŒã‚‹éµã§ã‚ã‚‹ã€‚ãªãœãªã‚‰ã€é–‰åŒ…ã«ã‚ˆã£ã¦ã€ç§ãŸã¡ã¯ã€<em>éšå±¤çš„ãª</em>æ§‹é€ â€”â€”éƒ¨åˆ†ã‹ã‚‰ã§ãã‚ãŒã£ã¦ã„ã‚‹æ§‹é€ ã§ã‚ã£ã¦ã€ãã‚Œã‚‰ã®éƒ¨åˆ†è‡ªä½“ãŒéƒ¨åˆ†ã‹ã‚‰ã§ãã‚ãŒã£ã¦ã„ã¦ã€ã¨ã„ã£ãŸã‚‚ã®â€”â€”ã‚’ä½œã‚Œã‚‹ã‚ˆã†ã«ãªã‚‹ã‹ã‚‰ã ã€‚
</p>

<p class="orig" lang="en">From the outset of chapter 1, we've made essential use of closure in
dealing with procedures, because all but the very simplest programs
rely on the fact that the elements of a combination can themselves be
combinations.  In this section, we take up the consequences of closure
for compound data.  We describe some conventional techniques for using
pairs to represent sequences and trees, and we exhibit a graphics
language that illustrates closure in a vivid way.<a name="call_footnote_Temp_155" href="#footnote_Temp_155"><sup><small>7</small></sup></a></p>

<p class="trans" lang="ja">
1ç« ã®æœ€åˆã‹ã‚‰ã€ç§ãŸã¡ã¯ã€æ‰‹ç¶šãã‚’æ‰±ã†éš›ã«ã€æ—¢ã«é–‰åŒ…ã‚’æœ¬è³ªçš„ã«åˆ©ç”¨ã—ã¦ã„ãŸã€‚ã¨ã„ã†ã®ã‚‚ã€ã¾ã•ã«æœ€ã‚‚å˜ç´”ãªã‚‚ã®ä»¥å¤–ã®ã™ã¹ã¦ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€ã‚³ãƒ³ãƒ“ãƒãƒ¼ã‚·ãƒ§ãƒ³ã®è¦ç´ ã¯ãã‚Œè‡ªä½“ãŒã‚³ãƒ³ãƒ“ãƒãƒ¼ã‚·ãƒ§ãƒ³ã§ã‚ã‚Šå¾—ã‚‹ã€ã¨ã„ã†äº‹å®Ÿã«é ¼ã£ã¦ã„ã‚‹ã‹ã‚‰ã ã€‚
æœ¬ç¯€ã§ã¯ã€è¤‡åˆçš„ãƒ‡ãƒ¼ã‚¿ã«å¯¾ã™ã‚‹é–‰åŒ…ã®å½±éŸ¿ã‚’å–ã‚Šä¸Šã’ã‚‹ã€‚
å¯¾ã‚’ä½¿ã£ã¦åˆ—ã‚„æœ¨ã‚’è¡¨ç¾ã™ã‚‹ãŸã‚ã®ã„ãã¤ã‹ã®å¾“æ¥ã®æŠ€æ³•ã«ã¤ã„ã¦è¿°ã¹ã€ãã‚Œã‹ã‚‰ã€é®®ã‚„ã‹ãªæ–¹æ³•ã§é–‰åŒ…ã‚’å›³è§£ã™ã‚‹ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹è¨€èªã‚’ç¤ºãã†<a href="#footnote_Temp_155"><sup><small>7</small></sup></a>ã€‚
</p>

<a name="%_sec_2.2.1"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_2.2.1">2.2.1  Representing Sequences</a></h3>
<h3 class="trans" lang="ja">2.2.1 åˆ—ã‚’è¡¨ç¾ã™ã‚‹</h3>

<a name="%_fig_2.4"></a>
<figure>
<img src="ch2-Z-G-13.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 2.4:</b>  The sequence 1, 2, 3, 4 represented as a chain of pairs.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³2.4:</b> å¯¾ã®é€£ãªã‚Šã¨ã—ã¦è¡¨ç¾ã•ã‚ŒãŸã€1ã€2ã€3ã€4ã¨ã„ã†åˆ—</figcaption>
</figure>

<p class="orig" lang="en">One of the useful structures we can build with pairs is a <a name="%_idx_1554"></a><a name="%_idx_1556"></a><a name="%_idx_1558"></a><em>sequence</em> -- an ordered collection of data objects.  There are, of
course, many ways to represent sequences in terms of pairs.  One
particularly straightforward representation is illustrated in
figure <a href="#%_fig_2.4">2.4</a>, where the sequence 1, 2, 3, 4 is
represented as a chain of pairs.  The <tt>car</tt> of each pair is the
corresponding item in the chain, and the <tt>cdr</tt> of the pair is
the next pair in the chain.  The <tt>cdr</tt> of the final pair
signals the end of the sequence by pointing to a distinguished
value that is not a pair,
represented in box-and-pointer diagrams as a diagonal line
<a name="%_idx_1560"></a>and in programs as the value of the variable <a name="%_idx_1562"></a><a name="%_idx_1564"></a><tt>nil</tt>.
The entire sequence is constructed by nested <tt>cons</tt> operations:
</p>

<p class="trans" lang="ja">
å¯¾ã‚’ä½¿ã£ã¦æ§‹ç¯‰ã§ãã‚‹æœ‰ç”¨ãªæ§‹é€ ã®ã†ã¡ã®ä¸€ã¤ã¯ã€<em>åˆ—</em>â€”â€”ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é †åºä»˜ãã®é›†ã¾ã‚Šâ€”â€”ã§ã‚ã‚‹ã€‚
ã‚‚ã¡ã‚ã‚“ã€å¯¾ã‚’ä½¿ã£ã¦åˆ—ã‚’è¡¨ç¾ã™ã‚‹ã«ã¯ã€å¤šãã®æ–¹æ³•ãŒã‚ã‚‹ã€‚
ç‰¹ã«å˜ç´”ãªä¸€ã¤ã®è¡¨ç¾ãŒã€å›³<a href="#%_fig_2.4">2.4</a>ã«ç¤ºã•ã‚Œã¦ãŠã‚Šã€ã“ã“ã§ã¯ã€1ã€2ã€3ã€4ãŒå¯¾ã®é€£ãªã‚Šã¨ã—ã¦è¡¨ç¾ã•ã‚Œã¦ã„ã‚‹ã€‚
å„å¯¾ã® <tt>car</tt> ã¯ã€ãã®é€£ãªã‚Šã®ä¸­ã§å¯¾å¿œã™ã‚‹é …ç›®ã§ã‚ã‚Šã€ãã®å¯¾ã® <tt>cdr</tt> ã¯ã€ãã®é€£ãªã‚Šã®ä¸­ã®æ¬¡ã®å¯¾ã§ã‚ã‚‹ã€‚
æœ€å¾Œã®å¯¾ã® <tt>cdr</tt> ã¯ã€å¯¾ã§ã¯ãªã„éš›ç«‹ã£ãŸå€¤ã‚’æŒ‡ã™ã“ã¨ã§ã€åˆ—ã®çµ‚ã‚ã‚Šã‚’çŸ¥ã‚‰ã›ã¦ãŠã‚Šã€ã“ã‚Œã¯ã€ç®±ãƒ»ãƒã‚¤ãƒ³ã‚¿å¼ã®å›³ã«ãŠã„ã¦ã¯æ–œç·šã§è¡¨ç¾ã•ã‚Œã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ãŠã„ã¦ã¯ <tt>nil</tt> ã¨ã„ã†å¤‰æ•°ã§è¡¨ç¾ã•ã‚Œã‚‹ã€‚
åˆ—å…¨ä½“ã¯ã€å…¥ã‚Œå­ã«ãªã£ãŸ <tt>cons</tt> æ¼”ç®—ã«ã‚ˆã‚Šæ§‹ç¯‰ã•ã‚Œã‚‹ã€‚
</p>

<p class="lisp">(cons 1
      (cons 2
            (cons 3
                  (cons 4 nil))))
</p>

<p class="orig" lang="en">
Such a sequence of pairs, formed by nested <tt>cons</tt>es, is called a
<a name="%_idx_1566"></a><em>list</em>, and Scheme provides a
primitive called <a name="%_idx_1568"></a><a name="%_idx_1570"></a><tt>list</tt> to help in constructing lists.<a name="call_footnote_Temp_156" href="#footnote_Temp_156"><sup><small>8</small></sup></a>
The above sequence could be produced by <tt>(list 1 2 3 4)</tt>.  In
general,</p>

<p class="trans" lang="ja">
ã“ã®ã‚ˆã†ãªå¯¾ã‹ã‚‰ãªã‚‹åˆ—â€”â€”å…¥ã‚Œå­ã«ãªã£ãŸ <tt>cons</tt> ã«ã‚ˆã‚Šå½¢æˆã•ã‚Œã‚‹â€”â€”ã¯ã€<em>ãƒªã‚¹ãƒˆ</em>ã¨å‘¼ã°ã‚Œã€Schemeã¯ã€ãƒªã‚¹ãƒˆã‚’æ§‹ç¯‰ã™ã‚‹åŠ©ã‘ã¨ãªã‚‹ã‚ˆã†ã«ã€<tt>list</tt> ã¨å‘¼ã°ã‚Œã‚‹ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã‚’æä¾›ã—ã¦ã„ã‚‹<a href="#footnote_Temp_156"><sup><small>8</small></sup></a>ã€‚
ä¸Šè¨˜ã®åˆ—ã¯ã€<tt>(list 1 2 3 4)</tt> ã«ã‚ˆã‚Šä½œã‚Šå‡ºã•ã‚ŒãŸã‚‚ã®ã‹ã‚‚ã—ã‚Œãªã„ã€‚
ä¸€èˆ¬ã«ã€
</p>

<p class="lisp">(list &lt;<em>a<sub>1</sub></em>&gt; &lt;<em>a<sub>2</sub></em>&gt; <tt>...</tt> &lt;<em>a<sub><em>n</em></sub></em>&gt;)
</p>

<p class="orig" lang="en">is equivalent to</p>

<p class="trans" lang="ja">ã¯ã€ä»¥ä¸‹ã¨ç­‰ä¾¡ã§ã‚ã‚‹ã€‚</p>

<p class="lisp">(cons &lt;<em>a<sub>1</sub></em>&gt; (cons &lt;<em>a<sub>2</sub></em>&gt; (cons <tt>...</tt> (cons &lt;<em>a<sub><em>n</em></sub></em>&gt; nil) <tt>...</tt>)))
</p>

<p class="orig" lang="en">
Lisp systems conventionally print lists by printing the sequence of
<a name="%_idx_1576"></a>elements, enclosed in parentheses.  Thus, the data object in
figure <a href="#%_fig_2.4">2.4</a> is printed as <tt>(1 2 3 4)</tt>:</p>

<p class="trans" lang="ja">
Lispã‚·ã‚¹ãƒ†ãƒ ã¯ã€æ…£ç¿’çš„ã«ã€è¦ç´ ã®åˆ—ã‚’æ‹¬å¼§ã§æ‹¬ã£ã¦å°å­—ã™ã‚‹ã“ã¨ã§ã€ãƒªã‚¹ãƒˆã‚’å°å­—ã™ã‚‹ã€‚
ã‚ˆã£ã¦ã€å›³<a href="#%_fig_2.4">2.4</a>ã®ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€<tt>(1 2 3 4)</tt> ã®ã‚ˆã†ã«å°å­—ã•ã‚Œã‚‹ã€‚
</p>

<p class="lisp">(define one-through-four (list 1 2 3 4))

one-through-four
<i>(1 2 3 4)</i>
</p>

<p class="orig" lang="en">
Be careful not to confuse the expression <tt>(list 1 2 3 4)</tt> with the
list <tt>(1 2 3 4)</tt>, which is the result obtained when the expression
is evaluated.  Attempting to evaluate the expression <tt>(1 2 3 4)</tt> will
signal an error when the interpreter tries to apply the procedure <tt>1</tt> to arguments <tt>2</tt>, <tt>3</tt>, and <tt>4</tt>.</p>

<p class="trans" lang="ja">
<tt>(list 1 2 3 4)</tt> ã¨ã„ã†å¼ã¨ã€<tt>(1 2 3 4)</tt> ã¨ã„ã†ãƒªã‚¹ãƒˆâ€”â€”ãã®å¼ãŒè©•ä¾¡ã•ã‚ŒãŸã¨ãã«å¾—ã‚‰ã‚Œã‚‹çµæœâ€”â€”ã‚’ã€å–ã‚Šé•ãˆãªã„ã‚ˆã†ã«æ°—ã‚’ã¤ã‘ã‚ˆã†ã€‚
<tt>(1 2 3 4)</tt> ã¨ã„ã†å¼ã‚’è©•ä¾¡ã—ã‚ˆã†ã¨ã„ã†è©¦ã¿ã¯ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒ <tt>1</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’ <tt>2</tt> ã¨ <tt>3</tt> ã¨ <tt>4</tt> ã¨ã„ã†å¼•æ•°ã«é©ç”¨ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ãã«ã€ã‚¨ãƒ©ãƒ¼ã‚’çŸ¥ã‚‰ã›ã¦ãã‚‹ã ã‚ã†ã€‚
</p>

<p class="orig" lang="en">
We can think of <a name="%_idx_1578"></a><a name="%_idx_1580"></a><tt>car</tt> as selecting the first item in the list, and
of <a name="%_idx_1582"></a><tt>cdr</tt> as selecting the sublist consisting of all but the first
item.  Nested applications of <tt>car</tt> and <tt>cdr</tt> can be used to
extract the second, third, and subsequent items in the
list.<a name="call_footnote_Temp_157" href="#footnote_Temp_157"><sup><small>9</small></sup></a>
The constructor <a name="%_idx_1592"></a><tt>cons</tt> makes a list like the original one,
but with an additional item at the beginning.</p>

<p class="trans" lang="ja">
<tt>car</tt> ã¯ã€ãƒªã‚¹ãƒˆã®æœ€åˆã®é …ç›®ã‚’é¸æŠã™ã‚‹ã“ã¨ã ã¨è¦‹ãªã›ã‚‹ã—ã€<tt>cdr</tt> ã¯ã€æœ€åˆã®é …ç›®ä»¥å¤–ã®ã™ã¹ã¦ã‹ã‚‰ãªã‚‹éƒ¨åˆ†ãƒªã‚¹ãƒˆã‚’é¸æŠã™ã‚‹ã“ã¨ã ã¨è¦‹ãªã›ã‚‹ã€‚
<tt>car</tt> ã¨ <tt>cdr</tt> ã®ã€å…¥ã‚Œå­ã«ãªã£ãŸé©ç”¨ã¯ã€ãƒªã‚¹ãƒˆä¸­ã®ã€2ç•ªç›®ã€3ç•ªç›®ã€ãã—ã¦ãã®å¾Œã®é …ç›®ã‚’ã€å–ã‚Šå‡ºã™ã®ã«ä½¿ãˆã‚‹<a href="#footnote_Temp_157"><sup><small>9</small></sup></a>ã€‚
<tt>cons</tt> ã¨ã„ã†ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ã€å…ˆé ­ã«è¿½åŠ ã®é …ç›®ãŒã‚ã‚‹ä»¥å¤–ã¯å…ƒã®ãƒªã‚¹ãƒˆã¨åŒæ§˜ã®ãƒªã‚¹ãƒˆã‚’ä½œã‚‹ã€‚
</p>

<p class="lisp">(car one-through-four)
<i>1</i>

(cdr one-through-four)
<i>(2 3 4)</i>
(car (cdr one-through-four))
<i>2</i>

(cons 10 one-through-four)
<i>(10 1 2 3 4)</i>

(cons 5 one-through-four)
<i>(5 1 2 3 4)</i>
</p>

<p class="orig" lang="en">
The value of <tt>nil</tt>, used to terminate the chain of pairs, can be
thought of as a sequence of no elements, the <a name="%_idx_1594"></a><a name="%_idx_1596"></a><em>empty list</em>.  The
word <em>nil</em> is a contraction of the Latin word <em>nihil</em>, which
means ``nothing.''<a name="call_footnote_Temp_158" href="#footnote_Temp_158"><sup><small>10</small></sup></a></p>

<p class="trans" lang="ja">
<tt>nil</tt>â€”â€”å¯¾ã®é€£ãªã‚Šã‚’çµ‚ã‚ã‚‰ã›ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã‚‹â€”â€”ã®å€¤ã¯ã€è¦ç´ ã®ãªã„åˆ—ã€ã™ãªã‚ã¡ã€<em>ç©ºãƒªã‚¹ãƒˆ</em>ã ã¨è¦‹ãªã›ã‚‹ã€‚
<em>nil</em> ã¨ã„ã†è¨€è‘‰ã¯ã€ãƒ©ãƒ†ãƒ³èªã® <em>nihil</em> ã¨ã„ã†å˜èªâ€”â€”ã€Œç„¡ã€ã‚’æ„å‘³ã™ã‚‹â€”â€”ã®çŸ­ç¸®å½¢ã§ã‚ã‚‹<a href="#footnote_Temp_158"><sup><small>10</small></sup></a>ã€‚
</p>

<a name="%_sec_Temp_159"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_159">List operations</a></h4>
<h4 class="trans" lang="ja">ãƒªã‚¹ãƒˆæ¼”ç®—</h4>

<p class="orig" lang="en"><a name="%_idx_1602"></a><a name="%_idx_1604"></a>
The use of pairs to represent sequences of elements as lists is
accompanied by conventional programming techniques for manipulating
lists by successively <a name="%_idx_1606"></a><a name="%_idx_1608"></a>``<tt>cdr</tt>ing down'' the lists.  For example,
the procedure <a name="%_idx_1610"></a><tt>list-ref</tt> takes as arguments a list and a number
<em>n</em> and returns the <em>n</em>th item of the list.  It is customary to
number the elements of the list beginning with 0.  The method for
computing <tt>list-ref</tt> is the following:</p>

<p class="trans" lang="ja">
è¦ç´ ã®åˆ—ã‚’ãƒªã‚¹ãƒˆã¨ã—ã¦è¡¨ç¾ã™ã‚‹ã®ã«å¯¾ã‚’ä½¿ã†ã“ã¨ã¯ã€ãƒªã‚¹ãƒˆã‚’æ¬¡ã€…ã¨ã€Œ<tt>cdr</tt> ã—ã¦å°ã•ãã™ã‚‹ã€ã“ã¨ã§ãƒªã‚¹ãƒˆã‚’æ“ä½œã™ã‚‹ãŸã‚ã®ã€å¾“æ¥ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°æŠ€æ³•ã‚’ä¼´ã†ã€‚
ãŸã¨ãˆã°ã€</a><tt>list-ref</tt> ã¨ã„ã†æ‰‹ç¶šãã¯ã€ãƒªã‚¹ãƒˆã¨ <em class="en">n</em> ã¨ã„ã†æ•°ã‚’å¼•æ•°ã¨ã—ã¦å–ã‚Šã€ãã®ãƒªã‚¹ãƒˆã® <em class="en">n</em> ç•ªç›®ã®è¦ç´ ã‚’è¿”ã™ã€‚
ãƒªã‚¹ãƒˆã®è¦ç´ ã«ã¯ã€0ã‹ã‚‰å§‹ã¾ã‚‹ç•ªå·ã‚’ã¤ã‘ã‚‹ã®ãŒæ…£ä¾‹ã§ã‚ã‚‹ã€‚
<tt>list-ref</tt> ã‚’è¨ˆç®—ã™ã‚‹æ–¹æ³•ã¯ä»¥ä¸‹ã®ã¨ãŠã‚Šã ã€‚
</p>

<ul class="orig" lang="en">
<li>For <em>n</em> = 0, <tt>list-ref</tt> should return the <tt>car</tt> of the list.</li>
<li>Otherwise, <tt>list-ref</tt> should return  the (<em>n</em> - 1)st item of the
<tt>cdr</tt> of the list.</li>
</ul>

<ul class="trans" lang="ja">
<li><em class="en">n</em> = 0 ã®ã¨ãã€<tt>list-ref</tt> ã¯ã€ãã®ãƒªã‚¹ãƒˆã® <tt>car</tt> ã‚’è¿”ã™ã¹ãã§ã‚ã‚‹ã€‚</li>
<li>ãã‚Œä»¥å¤–ã®ã¨ãã€<tt>list-ref</tt> ã¯ã€ãã®ãƒªã‚¹ãƒˆã® <tt>cdr</tt> ã®ã€(<em class="en">n</em> &minus; 1) ç•ªç›®ã®é …ç›®ã‚’è¿”ã™ã¹ãã§ã‚ã‚‹ã€‚</li>
</ul>

<p class="lisp"><a name="%_idx_1612"></a>(define (list-ref items n)
  (if (= n 0)
      (car items)
      (list-ref (cdr items) (- n 1))))
(define squares (list 1 4 9 16 25))

(list-ref squares 3)
<i>16</i>
</p>

<p class="orig" lang="en">Often we <tt>cdr</tt> down the whole list.  To aid in this, Scheme includes
a primitive predicate <a name="%_idx_1614"></a><a name="%_idx_1616"></a><a name="%_idx_1618"></a><tt>null?</tt>, which tests whether its argument is
the empty list.  The procedure <a name="%_idx_1620"></a><a name="%_idx_1622"></a><tt>length</tt>, which
returns the number of items in a list, illustrates this typical
pattern of use:
</p>

<p class="trans" lang="ja">
ãƒªã‚¹ãƒˆå…¨ä½“ã‚’ <tt>cdr</tt> ã—ã¦ä¸‹ã‚‹ã“ã¨ã‚‚ã—ã°ã—ã°ã§ã‚ã‚‹ã€‚
ã“ã®ç‚¹ã‚’ä»˜ã‘åŠ ãˆã‚‹ãŸã‚ã«ã€Schemeã¯ã€<tt>null?</tt> ã¨ã„ã†åŸå§‹çš„è¿°èªâ€”â€”å¼•æ•°ãŒç©ºãƒªã‚¹ãƒˆã‹ã©ã†ã‹ã‚’ãƒ†ã‚¹ãƒˆã™ã‚‹â€”â€”ã‚’å«ã‚“ã§ã„ã‚‹ã€‚
<tt>length</tt>ã¨ã„ã†æ‰‹ç¶šãâ€”â€”ãƒªã‚¹ãƒˆå†…ã®é …ç›®ã®æ•°ã‚’è¿”ã™â€”â€”ã¯ã€ã“ã®å…¸å‹çš„ãªä½¿ç”¨ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç¤ºã™ã€‚
</p>

<p class="lisp"><a name="%_idx_1624"></a>(define (length items)
  (if (null? items)
      0
      (+ 1 (length (cdr items)))))
(define odds (list 1 3 5 7))

(length odds)
<i>4</i>
</p>

<p class="orig" lang="en">
The <tt>length</tt> procedure implements a simple recursive plan. The
reduction step is:</p>

<p class="trans" lang="ja">
<tt>length</tt> ã®æ‰‹ç¶šãã¯ã€å˜ç´”ãªå†å¸°çš„è¨ˆç”»ã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ã€‚
é‚„å…ƒã‚¹ãƒ†ãƒƒãƒ—ã¯ä»¥ä¸‹ã®ã¨ãŠã‚Šã ã€‚
</p>

<ul class="orig" lang="en">
<li>The <tt>length</tt> of any list is 1 plus the <tt>length</tt> of the
<tt>cdr</tt> of the list.</li>
</ul>

<ul class="trans" lang="ja">
<li>ã„ã‹ãªã‚‹ãƒªã‚¹ãƒˆã® <tt>length</tt> (é•·ã•) ã‚‚ã€1ã¨ã€ãã®ãƒªã‚¹ãƒˆã® <tt>cdr</tt> ã® <tt>length</tt> ã¨ã®å’Œã§ã‚ã‚‹ã€‚</li>
</ul>

<p class="orig" lang="en">This is applied successively until we reach the base case:</p>

<p class="trans" lang="ja">
ã“ã‚Œã¯ã€åŸºåº•ã®å ´åˆã«åˆ°é”ã™ã‚‹ã¾ã§ã€æ¬¡ã€…ã«é©ç”¨ã•ã‚Œã‚‹ã€‚
</p>

<ul class="orig" lang="en">
<li>The <tt>length</tt> of the empty list is 0.</li>
</ul>

<ul class="trans" lang="ja">
<li>ç©ºãƒªã‚¹ãƒˆã® <tt>length</tt> (é•·ã•) ã¯0ã§ã‚ã‚‹ã€‚</li>
</ul>

<p class="orig" lang="en">We could also compute <tt>length</tt> in an iterative style:
</p>

<p class="trans" lang="ja">
<tt>length</tt> ã‚’åå¾©çš„ãªæ§˜å¼ã§è¨ˆç®—ã™ã‚‹ã“ã¨ã‚‚ã§ãã‚‹ã ã‚ã†ã€‚
</p>

<p class="lisp"><a name="%_idx_1626"></a>(define (length items)
  (define (length-iter a count)
    (if (null? a)
        count
        (length-iter (cdr a) (+ 1 count))))
  (length-iter items 0))
</p>

<p class="orig" lang="en">Another conventional programming technique is to <a name="%_idx_1628"></a><a name="%_idx_1630"></a>``<tt>cons</tt> up'' an
answer list while <tt>cdr</tt>ing down a list, as in the procedure <a name="%_idx_1632"></a><a name="%_idx_1634"></a><tt>append</tt>, which takes two lists as arguments and combines their
elements to make a new list:
</p>

<p class="trans" lang="ja">
åˆ¥ã®å¾“æ¥ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°æŠ€æ³•ã¯ã€<tt>append</tt> ã¨ã„ã†æ‰‹ç¶šãâ€”â€”äºŒã¤ã®ãƒªã‚¹ãƒˆã‚’å¼•æ•°ã¨ã—ã¦å–ã‚Šã€ãã‚Œã‚‰ã®ãƒªã‚¹ãƒˆã®è¦ç´ ã‚’åˆã‚ã›ã¦æ–°ãŸãªãƒªã‚¹ãƒˆã‚’ä½œã‚‹â€”â€”ã«è¦‹ã‚‰ã‚Œã‚‹ã‚ˆã†ã«ã€ãƒªã‚¹ãƒˆã‚’ <tt>cdr</tt> ã—ã¦å°ã•ãã™ã‚‹ä¸€æ–¹ã§ã€ç­”ãˆã®ãƒªã‚¹ãƒˆã‚’ã€Œ<tt>cons</tt> ã—ã¦å¤§ããã™ã‚‹ã€ã“ã¨ã§ã‚ã‚‹ã€‚
</p>

<p class="lisp">(append squares odds)
<i>(1 4 9 16 25 1 3 5 7)</i>

(append odds squares)
<i>(1 3 5 7 1 4 9 16 25)</i>
</p>

<p class="orig" lang="en">
<tt>Append</tt> is also implemented using a recursive plan.  To <tt>append</tt>
lists <tt>list1</tt> and <tt>list2</tt>, do the following:</p>

<p class="trans" lang="ja">
<tt>append</tt> ã‚‚ã€å†å¸°çš„è¨ˆç”»ã‚’ä½¿ã£ã¦å®Ÿè£…ã•ã‚Œã‚‹ã€‚
<tt>list1</tt> ã¨ <tt>list2</tt> ã¨ã„ã†ãƒªã‚¹ãƒˆã‚’ <tt>append</tt> ã™ã‚‹ (ã¤ãªã’ã‚‹) ã«ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ã™ã‚‹ã€‚
</p>

<ul class="orig" lang="en">
<li>If <tt>list1</tt> is the empty list, then the result is just <tt>list2</tt>.</li>
<li>Otherwise, <tt>append</tt> the <tt>cdr</tt> of <tt>list1</tt> and 
<tt>list2</tt>, and <tt>cons</tt> the <tt>car</tt> of <tt>list1</tt> onto the result:</li>
</ul>

<ul class="trans" lang="ja">
<li>ã‚‚ã— <tt>list1</tt> ãŒç©ºãƒªã‚¹ãƒˆãªã‚‰ã€çµæœã¯ä¸åº¦ <tt>list2</tt> ã§ã‚ã‚‹ã€‚</li>
<li>ãã‚Œä»¥å¤–ã®å ´åˆã€<tt>list1</tt> ã® <tt>cdr</tt> ã¨ <tt>list2</tt> ã‚’ <tt>append</tt> ã—ã€ãã®çµæœã®ä¸Šã« <tt>list1</tt> ã® <tt>car</tt> ã‚’ <tt>cons</tt> ã—ã¦è¼‰ã›ã‚ˆã€‚</li>
</ul>

<p class="lisp"><a name="%_idx_1636"></a>(define (append list1 list2)
  (if (null? list1)
      list2
      (cons (car list1) (append (cdr list1) list2))))
</p>

<p class="orig" lang="en"><a name="%_thm_2.17"></a>
<b>Exercise 2.17.</b>  Define a procedure <a name="%_idx_1638"></a><a name="%_idx_1640"></a><tt>last-pair</tt> that returns the list that contains only
the last element of a given (nonempty) list:
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.17.</b> ä¸ãˆã‚‰ã‚ŒãŸ (éç©ºã®) ãƒªã‚¹ãƒˆã®æœ€å¾Œã®è¦ç´ ã®ã¿ã‚’å«ã‚€ãƒªã‚¹ãƒˆã‚’è¿”ã™ã‚ˆã†ãªã€<tt>last-pair</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’å®šç¾©ã›ã‚ˆã€‚
</p>

<p class="lisp">(last-pair (list 23 72 149 34))
<i>(34)</i>
</p>

<p class="exercise"><span class="ex_comment">; å¼•æ•°ãŒéç©ºã‹ã©ã†ã‹ã®ã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯ã¯ã—ã¦ã„ãªã„ã€‚</span>
(define (last-pair arg-list)
  (if (null? (cdr arg-list))
      arg-list
      (last-pair (cdr arg-list))))
</p>

<p class="orig" lang="en"><a name="%_thm_2.18"></a>
<b>Exercise 2.18.</b>  Define a procedure <a name="%_idx_1642"></a><a name="%_idx_1644"></a><tt>reverse</tt> that takes a list as argument and
returns a list of the same elements in reverse order:
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.18.</b> ãƒªã‚¹ãƒˆã‚’å¼•æ•°ã¨ã—ã¦ã¨ã‚Šã€é€†é †ã§åŒã˜è¦ç´ ã‚’æŒã¤ãƒªã‚¹ãƒˆã‚’è¿”ã™ã‚ˆã†ãªã€<tt>reverse</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’å®šç¾©ã›ã‚ˆã€‚
</p>

<p class="lisp">(reverse (list 1 4 9 16 25))
<i>(25 16 9 4 1)</i>
</p>

<p class="exercise"><span class="ex_comment">; ãŸã¨ãˆã°ã€</span>
(define (reverse arg-list)
  (if (null? arg-list)
      arg-list
      (append (reverse (cdr arg-list)) (list (car arg-list)))))
<span class="ex_comment">; ã¨ã‹ã€</span>
(define (reverse arg-list)
  (if (or (null? arg-list) (null? (cdr arg-list)))
      arg-list
      (append (reverse (cdr arg-list)) (list (car arg-list)))))
<span class="ex_comment">; ã¨ã‹ã§ã‚‚ã‚ˆã„ã‘ã‚Œã©ã€</span>
(define (reverse arg-list)
  (define (reverse-iter remaining-list working-reversed-list)
    (if (null? remaining-list)
         working-reversed-list
        (reverse-iter (cdr remaining-list) (cons (car remaining-list) working-reversed-list))))
  (reverse-iter arg-list '()))
<span class="ex_comment">; ã¨ã™ã‚‹ã®ãŒã‚·ãƒ³ãƒ—ãƒ«ã§ã‚ˆã„ã¨æ€ã†ã€‚
; ãªãŠã€Gauche ã ã¨ã€ç©ºãƒªã‚¹ãƒˆã¯ã‚¯ã‚ªãƒ¼ãƒˆã—ãªãã¦ã‚‚ã‚ˆã„ã¿ãŸã„ã€‚</span>
</p>

<p class="orig" lang="en"><a name="%_thm_2.19"></a>
<b>Exercise 2.19.</b>  Consider the <a name="%_idx_1646"></a>change-counting program of
section <a href="11_sec1_2.html#%_sec_1.2.2">1.2.2</a>.  It would be nice to be able to
easily change the currency used by the program, so that we could
compute the number of ways to change a British pound, for example.  As
the program is written, the knowledge of the currency is distributed
partly into the procedure <tt>first-denomination</tt> and partly into the
procedure <tt>count-change</tt> (which knows that there are five
kinds of U.S. coins).  It would be nicer to be able to
supply a list of coins to be used for making change.</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.19.</b> <a href="11_sec1_2.html#%_sec_1.2.2">1.2.2</a>ç¯€ã§ã®ã€ä¸¡æ›¿æ–¹æ³•ã‚’æ•°ãˆã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’è€ƒãˆã‚ˆã†ã€‚
ã‚ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ä½¿ã‚ã‚Œã‚‹é€šè²¨ã‚’ç°¡å˜ã«å¤‰æ›´ã§ããŸã‚‰ã€ç´ æ™´ã‚‰ã—ã„ã“ã¨ã ã‚ã†ã€‚ãã†ã™ã‚Œã°ã€ãŸã¨ãˆã°ã€è‹±å›½ãƒãƒ³ãƒ‰ã‚’ä¸¡æ›¿ã™ã‚‹æ–¹æ³•ã®æ•°ã‚’è¨ˆç®—ã§ãã‚‹ã ã‚ã†ã‹ã‚‰ã€‚
ã‚ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«æ›¸ã‹ã‚Œã¦ã„ã‚‹ã¨ãŠã‚Šã€é€šè²¨ã«ã¤ã„ã¦ã®çŸ¥è­˜ã¯ã€ä¸€éƒ¨ã¯ <tt>first-denomination</tt> ã¨ã„ã†æ‰‹ç¶šãã«æŒ¯ã‚Šåˆ†ã‘ã‚‰ã‚Œã¦ãŠã‚Šã€ä¸€éƒ¨ã¯ <tt>count-change</tt> ã¨ã„ã†æ‰‹ç¶šã (5ç¨®é¡ã®ç±³å›½ç¡¬è²¨ãŒã‚ã‚‹ã“ã¨ã‚’çŸ¥ã£ã¦ã„ã‚‹) ã«æŒ¯ã‚Šåˆ†ã‘ã‚‰ã‚Œã¦ã„ã‚‹ã€‚
ä¸¡æ›¿ã«ä½¿ã‚ã‚Œã‚‹ç¡¬è²¨ã®ãƒªã‚¹ãƒˆã‚’ä¾›çµ¦ã§ããŸã‚‰ã€ã‚‚ã£ã¨ç´ æ™´ã‚‰ã—ã„ã ã‚ã†ã€‚
</p>

<p class="orig" lang="en">We want to rewrite the procedure <tt>cc</tt> so that its
second argument is a list of the values of the
coins to use rather than an integer specifying which coins to use.  We
could then have lists that defined each kind of currency:
</p>

<p class="trans" lang="ja">
<tt>cc</tt> ã¨ã„ã†æ‰‹ç¶šãã®2ç•ªç›®ã®å¼•æ•°ãŒã€ã©ã®ç¡¬è²¨ã‚’ä½¿ã†ã¹ãã‹ã‚’æŒ‡å®šã™ã‚‹æ•´æ•°ã§ã¯ãªãã€ã‚€ã—ã‚ã€ä½¿ã†ã¹ãç¡¬è²¨ã®ä¾¡æ ¼ã®ãƒªã‚¹ãƒˆã¨ãªã‚‹ã‚ˆã†ã«ã€<tt>cc</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’æ›¸ãæ›ãˆãŸã„ã€‚
ã¾ãŸã€é€šè²¨ã®å„ç¨®é¡ã‚’å®šç¾©ã—ãŸãƒªã‚¹ãƒˆã‚’æŒã¤ã“ã¨ã‚‚ã§ãã‚‹ã ã‚ã†ã€‚
</p>

<p class="lisp">(define us-coins (list 50 25 10 5 1))
(define uk-coins (list 100 50 20 10 5 2 1 0.5))
</p>

<p class="orig" lang="en">
We could then call <tt>cc</tt> as follows:
</p>

<p class="trans" lang="ja">
ã™ã‚‹ã¨ã€<tt>cc</tt> ã‚’æ¬¡ã®ã‚ˆã†ã«å‘¼ã³å‡ºã›ã‚‹ã ã‚ã†ã€‚
</p>

<p class="lisp">(cc 100 us-coins)
<i>292</i>
</p>

<p class="orig" lang="en">
To do this will require changing the program <tt>cc</tt> somewhat.  It will
still have the same form, but it will access its second argument
differently, as follows:</p>

<p class="trans" lang="ja">
ã“ã®ã‚ˆã†ã«ã™ã‚‹ã«ã¯ã€ã‚ã‚‹ç¨‹åº¦ <tt>cc</tt> ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ã‚’è¦ã™ã‚‹ã€‚
<tt>cc</tt> ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€ä¾ç„¶ã¨ã—ã¦åŒã˜å½¢å¼ã‚’ä¿ã¤ã ã‚ã†ãŒã€2ç•ªç›®ã®å¼•æ•°ã«ã¯ã€ä»¥ä¸‹ã®ã¨ãŠã‚Šã€é•ã£ãŸæ–¹æ³•ã§ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã ã‚ã†ã€‚
</p>

<p class="lisp">(define (cc amount coin-values)
  (cond ((= amount 0) 1)
        ((or (&lt; amount 0) (no-more? coin-values)) 0)
        (else
         (+ (cc amount
                (except-first-denomination coin-values))
            (cc (- amount
                   (first-denomination coin-values))
                coin-values)))))
</p>

<p class="orig" lang="en">
Define the procedures <tt>first-denomination</tt>, <tt>except-first-denomination</tt>, and <tt>no-more?</tt> in terms of primitive
operations on list structures.  Does the order of the list <tt>coin-values</tt> affect the answer produced by <tt>cc</tt>?  Why or why not?
</p>

<p class="trans" lang="ja">
ãƒªã‚¹ãƒˆæ§‹é€ ã«é–¢ã™ã‚‹åŸå§‹çš„æ¼”ç®—ã‚’ç”¨ã„ã¦ã€<tt>first-denomination</tt> ã¨ <tt>except-first-denomination</tt> ã¨ <tt>no-more?</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’å®šç¾©ã›ã‚ˆã€‚
<tt>coin-values</tt> ã¨ã„ã†ãƒªã‚¹ãƒˆã§ã®é †åºã¯ã€<tt>cc</tt> ã«ã‚ˆã‚Šç”Ÿã¿å‡ºã•ã‚Œã‚‹ç­”ãˆã«å½±éŸ¿ã™ã‚‹ã‹?
ãªãœå½±éŸ¿ã™ã‚‹ã®ã‹ã€ã‚ã‚‹ã„ã¯ã€ãªãœå½±éŸ¿ã—ãªã„ã®ã‹?
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_2.20"></a>
<b>Exercise 2.20.</b>  <a name="%_idx_1648"></a><a name="%_idx_1650"></a><a name="%_idx_1652"></a><a name="%_idx_1654"></a>The procedures <tt>+</tt>, <tt>*</tt>, and <tt>list</tt> take arbitrary numbers
of arguments. One way to define such procedures is to use <tt>define</tt>
with <em>dotted-tail notation</em>.  In a procedure definition, a parameter
list that has a dot before the last parameter name indicates that, when the
procedure is called, the initial parameters (if any) will have as values
the initial arguments,
as usual, but the final parameter's value will be a <em>list</em> of
any remaining arguments.
For instance, given the definition
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.20.</b>  <tt>+</tt> ã‚„ <tt>*</tt> ã‚„ <tt>list</tt> ã¨ã„ã†æ‰‹ç¶šãã¯ã€ä»»æ„ã®å€‹æ•°ã®å¼•æ•°ã‚’ã¨ã‚‹ã€‚
ãã†ã„ã†æ‰‹ç¶šãã‚’å®šç¾©ã™ã‚‹ãŸã‚ã®ä¸€ã¤ã®æ–¹æ³•ã¯ã€<em>æœ«å°¾ã«ãƒ‰ãƒƒãƒˆãŒã¤ã„ãŸè¨˜æ³•</em>ã¨ã¨ã‚‚ã« <tt>define</tt> ã‚’ä½¿ã†ã“ã¨ã§ã‚ã‚‹ã€‚
æ‰‹ç¶šãå®šç¾©ã«ãŠã„ã¦ã¯ã€æœ€å¾Œã®ä»®å¼•æ•°åã®å‰ã«ãƒ‰ãƒƒãƒˆã‚’å«ã‚€ã‚ˆã†ãªä»®å¼•æ•°ãƒªã‚¹ãƒˆãŒã€æ‰‹ç¶šããŒå‘¼ã°ã‚Œã‚‹ã¨ãã«ã€(ã‚‚ã—ã‚ã‚Œã°) å…ˆé ­å´ã®ä»®å¼•æ•°ã¯é€šå¸¸ã©ãŠã‚Šã«å…ˆé ­å´ã®å®Ÿå¼•æ•°ã®å€¤ã‚’æŒã¤ä¸€æ–¹ã§ã€æœ€å¾Œã®ä»®å¼•æ•°ã®å€¤ã¯æ®‹ã‚Šã®ã™ã¹ã¦ã®å®Ÿå¼•æ•°ã® <em>ãƒªã‚¹ãƒˆ</em> ã¨ãªã‚‹ã€ã¨ã„ã†ã“ã¨ã‚’ç¤ºã™ã€‚
ãŸã¨ãˆã°ã€ä»¥ä¸‹ã®å®šç¾©ãŒä¸ãˆã‚‰ã‚Œã‚‹ã¨ã€
</p>

<p class="lisp">(define (f x y . z) <em>&lt;body&gt;</em>)
</p>

<p class="orig" lang="en">
the procedure <tt>f</tt> can be called with two or more arguments.
If we evaluate
</p>

<p class="trans" lang="ja">
<tt>f</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’ã€2å€‹ä»¥ä¸Šã®å®Ÿå¼•æ•°ã¨ã¨ã‚‚ã«å‘¼ã¶ã“ã¨ãŒã§ãã‚‹ã€‚
ã‚‚ã—ä»¥ä¸‹ã®ã‚‚ã®ã‚’è©•ä¾¡ã™ã‚‹ãªã‚‰ã€
</p>

<p class="lisp">(f 1 2 3 4 5 6)
</p>

<p class="orig" lang="en">
then in the body of <tt>f</tt>, <tt>x</tt> will be 1, <tt>y</tt> will be
2, and <tt>z</tt> will be the list <tt>(3 4 5 6)</tt>.
Given the definition
</p>

<p class="trans" lang="ja">
<tt>f</tt> ã®æœ¬ä½“ã«ãŠã„ã¦ <tt>x</tt> ã¯1ã¨ãªã‚Šã€<tt>y</tt> ã¯2ã¨ãªã‚Šã€<tt>z</tt> ã¯ <tt>(3 4 5 6)</tt> ã¨ã„ã†ãƒªã‚¹ãƒˆã«ãªã‚‹ã ã‚ã†ã€‚
ä»¥ä¸‹ã®å®šç¾©ãŒä¸ãˆã‚‰ã‚Œã‚‹ã¨ã€
</p>

<p class="lisp">(define (g . w) <em>&lt;body&gt;</em>)
</p>

<p class="orig" lang="en">
the procedure <tt>g</tt> can be called with zero or more arguments.
If we evaluate
</p>

<p class="trans" lang="ja">
<tt>g</tt>  ã¨ã„ã†æ‰‹ç¶šãã‚’ã€0å€‹ä»¥ä¸Šã®å®Ÿå¼•æ•°ã¨ã¨ã‚‚ã«å‘¼ã¶ã“ã¨ãŒã§ãã‚‹ã€‚
ã‚‚ã—ä»¥ä¸‹ã®ã‚‚ã®ã‚’è©•ä¾¡ã™ã‚‹ãªã‚‰ã€
</p>

<p class="lisp">(g 1 2 3 4 5 6)
</p>

<p class="orig" lang="en">
then in the body of <tt>g</tt>, <tt>w</tt> will be the
list <tt>(1 2 3 4 5 6)</tt>.<a name="call_footnote_Temp_164" href="#footnote_Temp_164"><sup><small>11</small></sup></a></p>

<p class="trans" lang="ja">
<tt>g</tt> ã®æœ¬ä½“ã«ãŠã„ã¦ã€<tt>w</tt> ã¯ <tt>(1 2 3 4 5 6)</tt> ã¨ã„ã†ãƒªã‚¹ãƒˆã«ãªã‚‹ã ã‚ã†<a href="#footnote_Temp_164"><sup><small>11</small></sup></a>ã€‚
</p>

<p class="orig" lang="en">Use this notation
to write a procedure <tt>same-parity</tt> that takes one or more integers
and returns a list of all the arguments that have the same even-odd
parity as the first argument.  For example,</p>

<p class="trans" lang="ja">
1å€‹ä»¥ä¸Šã®æ•´æ•°ã‚’å–ã‚Šã€1ç•ªç›®ã®å®Ÿå¼•æ•°ã¨åŒã˜å¶å¥‡æ€§ã‚’æŒã¤ã™ã¹ã¦ã®å®Ÿå¼•æ•°ã®ãƒªã‚¹ãƒˆã‚’è¿”ã™ã‚ˆã†ãªã€<tt>same-parity</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’ã€ã“ã®è¨˜æ³•ã‚’ä½¿ã£ã¦æ›¸ã‘ã€‚
</p>

<p class="lisp">(same-parity 1 2 3 4 5 6 7)
<i>(1 3 5 7)</i>

(same-parity 2 3 4 5 6 7)
<i>(2 4 6)</i>
</p>

<p class="exercise"><span class="ex_comment">; ã¨ã‚Šã‚ãˆãšã“ã‚“ãªæ„Ÿã˜?</span>
(define (same-parity ref-num . list-of-nums)
  (define (parity-check ref-parity same-parity-nums nums-to-be-checked)
     (cond
       ((null? nums-to-be-checked) same-parity-nums)
       ((= ref-parity (mod (car nums-to-be-checked) 2))
       (parity-check ref-parity (cons (car nums-to-be-checked) same-parity-nums) (cdr nums-to-be-checked)))
      (else (parity-check ref-parity same-parity-nums (cdr nums-to-be-checked)))))
  (cons ref-num (reverse (parity-check (mod ref-num 2) () list-of-nums))))</p>


<a name="%_sec_Temp_165"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_165">Mapping over lists</a></h4>
<h4 class="trans" lang="ja">ãƒªã‚¹ãƒˆå…¨ä½“ã«ã‚ãŸã‚‹å†™åƒ</h4>

<p class="orig" lang="en"><a name="%_idx_1658"></a><a name="%_idx_1660"></a>
One extremely useful operation is to apply some transformation
to each element in a list and generate the list of results.
For instance, the following procedure scales each number in a list by
a given factor:
</p>

<p class="trans" lang="ja">
éå¸¸ã«æœ‰ç”¨ãªä¸€ã¤ã®æ¼”ç®—ã¯ã€ãªã‚“ã‚‰ã‹ã®å¤‰æ›ã‚’ãƒªã‚¹ãƒˆå†…ã®å„è¦ç´ ã«é©ç”¨ã—ã¦ã€çµæœã®ãƒªã‚¹ãƒˆã‚’ç”Ÿæˆã™ã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚
ãŸã¨ãˆã°ã€ä»¥ä¸‹ã®æ‰‹ç¶šãã¯ã€ãƒªã‚¹ãƒˆå†…ã®ãã‚Œãã‚Œã®æ•°ã«ã€ä¸ãˆã‚‰ã‚ŒãŸå› å­ã‚’æ›ã‘ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_1662"></a>(define (scale-list items factor)
  (if (null? items)
      nil
      (cons (* (car items) factor)
            (scale-list (cdr items) factor))))
(scale-list (list 1 2 3 4 5) 10)
<i>(10 20 30 40 50)</i>
</p>

<p class="orig" lang="en">We can abstract this general idea and capture it as a common pattern
expressed as a higher-order procedure, just as in
section <a href="12_sec1_3.html#%_sec_1.3">1.3</a>.  The higher-order procedure
here is called <tt>map</tt>.  <tt>Map</tt> takes as arguments a procedure
of one argument
and a list, and returns a list of the results produced by
applying the procedure to each element in the list:<a name="call_footnote_Temp_166" href="#footnote_Temp_166"><sup><small>12</small></sup></a>
</p>

<p class="trans" lang="ja">
ç§ãŸã¡ã¯ã€ã“ã®ä¸€èˆ¬çš„ãªè€ƒãˆæ–¹ã‚’æŠ½è±¡åŒ–ã™ã‚‹ã“ã¨ãŒã§ãã€ãã‚Œã‚’ã€é«˜éšæ‰‹ç¶šãã¨ã—ã¦è¡¨ã•ã‚ŒãŸå…±é€šãƒ‘ã‚¿ãƒ³ã¨ã—ã¦æ‰ãˆã‚‹ã“ã¨ãŒã§ãã‚‹â€”â€”<a href="12_sec1_3.html#%_sec_1.3">1.3</a>ç¯€ã¨ã¡ã‚‡ã†ã©åŒæ§˜ã«ã€‚
ã“ã“ã§ã®é«˜éšæ‰‹ç¶šãã¯ã€<tt>map</tt> ã¨å‘¼ã°ã‚Œã‚‹ã€‚
<tt>map</tt> ã¯ã€1å¼•æ•°ã®æ‰‹ç¶šãã¨ãƒªã‚¹ãƒˆã¨ã‚’å¼•æ•°ã¨ã—ã¦å–ã‚Šã€ãã®æ‰‹ç¶šãã‚’ãã®ãƒªã‚¹ãƒˆå†…ã®å„è¦ç´ ã«é©ç”¨ã™ã‚‹ã“ã¨ã§ä½œã‚Šå‡ºã•ã‚Œã‚‹çµæœã®ãƒªã‚¹ãƒˆã‚’è¿”ã™<a href="#footnote_Temp_166"><sup><small>12</small></sup></a>ã€‚
</p>

<p class="lisp"><a name="%_idx_1666"></a>(define (map proc items)
  (if (null? items)
      nil
      (cons (proc (car items))
            (map proc (cdr items)))))
(map abs (list -10 2.5 -11.6 17))
<i>(10 2.5 11.6 17)</i>
(map (lambda (x) (* x x))
     (list 1 2 3 4))
<i>(1 4 9 16)</i>
</p>

<p class="orig" lang="en">
Now we can give a new definition of <tt>scale-list</tt> in terms of <tt>map</tt>:</p>

<p class="trans" lang="ja">
ä»Šã‚„ç§ãŸã¡ã¯ã€<tt>map</tt> ã‚’ä½¿ã£ã¦ã€<tt>scale-list</tt> ã®æ–°ã—ã„å®šç¾©ã‚’ä¸ãˆã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_1668"></a>(define (scale-list items factor)
  (map (lambda (x) (* x factor))
       items))
</p>

<p class="orig" lang="en"><tt>Map</tt> is an important construct, not only because it captures a
common pattern, but because it establishes a higher level of
abstraction in dealing with lists.  In the original definition of <tt>scale-list</tt>, the recursive structure of the program draws attention to
the element-by-element processing of the list.  Defining <tt>scale-list</tt> in terms of <tt>map</tt> suppresses that level of detail and
emphasizes that scaling transforms a list of elements to a list of
results.  The difference between the two definitions is not that the
computer is performing a different process (it isn't) but that we
think about the process differently.  In effect, <tt>map</tt> helps
establish an abstraction barrier that isolates the implementation of
procedures that transform lists from the details of how the
elements of the list are extracted and combined.  Like the barriers
shown in figure <a href="14_sec2_1.html#%_fig_2.1">2.1</a>, this abstraction gives
us the flexibility to change the low-level details of how sequences
are implemented, while preserving the conceptual framework of
operations that transform sequences to sequences.
Section <a href="#%_sec_2.2.3">2.2.3</a> expands on this use
of sequences as a framework for organizing programs.</p>

<p class="trans" lang="ja">
<tt>map</tt> ã¯ã€å…±é€šãƒ‘ã‚¿ãƒ³ã‚’æ‰ãˆã‚‹ã‹ã‚‰ã€ã¨ã„ã†ã ã‘ã§ãªãã€ãƒªã‚¹ãƒˆã‚’æ‰±ã†éš›ã«ã€ã‚ˆã‚Šé«˜ã„æ°´æº–ã®æŠ½è±¡æ¦‚å¿µã‚’ç¯‰ãä¸Šã’ã‚‹ã®ã§ã€é‡è¦ãªæ§‹æˆã§ã‚ã‚‹ã€‚
<tt>scale-list</tt> ã®å…ƒã®å®šç¾©ã§ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®å†å¸°çš„æ§‹é€ ã®ã›ã„ã§ã€ãƒªã‚¹ãƒˆã®è¦ç´ ã”ã¨ã®å‡¦ç†ã¸ã¨é–¢å¿ƒãŒå‘ã„ã¦ã—ã¾ã†ã€‚
<tt>map</tt> ã‚’ä½¿ã£ã¦ <tt>scale-list</tt> ã‚’å®šç¾©ã™ã‚‹ã“ã¨ã§ã€ãã®æ°´æº–ã®ç´°ç›®ã¯éš ã•ã‚Œã‚‹ã—ã€å¤‰å€ã«ã‚ˆã£ã¦è¦ç´ ã®ãƒªã‚¹ãƒˆãŒçµæœã®ãƒªã‚¹ãƒˆã¸ã¨å¤‰æ›ã¨ã‚Œã‚‹ã®ã ã€ã¨ã„ã†ã“ã¨ãŒå¼·èª¿ã•ã‚Œã‚‹ã€‚
äºŒã¤ã®å®šç¾©ã®é•ã„ã¯ã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãŒç•°ãªã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã‚’å®Ÿè¡Œã—ã¦ã„ã‚‹ (ãã†ã§ã¯ãªã„ã®ã ãŒ) ã¨ã„ã†ç‚¹ã§ã¯ãªãã€ç§ãŸã¡ãŒç•°ãªã‚‹ã‚„ã‚Šæ–¹ã§ãƒ—ãƒ­ã‚»ã‚¹ã«ã¤ã„ã¦è€ƒãˆã‚‹ã¨ã„ã†ç‚¹ã§ã‚ã‚‹ã€‚
å®Ÿéš›ã«ã¯ã€ãƒªã‚¹ãƒˆã®è¦ç´ ãŒã©ã®ã‚ˆã†ã«æŠ½å‡ºã•ã‚ŒãŸã‚Šçµåˆã•ã‚ŒãŸã‚Šã™ã‚‹ã®ã‹ã€ã¨ã„ã†è©³ç´°ã‹ã‚‰ã€ãƒªã‚¹ãƒˆã‚’å¤‰æ›ã™ã‚‹æ‰‹ç¶šãã®å®Ÿè£…ã‚’éš”é›¢ã™ã‚‹ã‚ˆã†ãªã€æŠ½è±¡åŒ–ã®é˜²å£ã‚’ç¯‰ãã®ã‚’ã€<tt>map</tt> ãŒåŠ©ã‘ã¦ãã‚Œã‚‹ã€‚
å›³<a href="14_sec2_1.html#%_fig_2.1">2.1</a>ã«ç¤ºã—ãŸé˜²å£ã¨åŒæ§˜ã€ã“ã®æŠ½è±¡åŒ–ã¯ã€åˆ—ã‚’åˆ—ã«å¤‰æ›ã™ã‚‹ã¨ã„ã†æ¼”ç®—ã®æ¦‚å¿µçš„æ çµ„ã¿ã‚’ä¿ã¡ã¤ã¤ã‚‚ã€ç§ãŸã¡ã«ã€åˆ—ãŒã©ã®ã‚ˆã†ã«å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ã‹ã¨ã„ã†ä½æ°´æº–ã®è©³ç´°ã‚’å¤‰æ›´ã™ã‚‹ãŸã‚ã®ã€èé€šæ€§ã‚’ä¸ãˆã¦ãã‚Œã‚‹ã€‚
<a href="#%_sec_2.2.3">2.2.3</a>ç¯€ã§ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’çµ„ç¹”åŒ–ã™ã‚‹ãŸã‚ã®æ çµ„ã¿ã¨ã—ã¦ã®ã€åˆ—ã®ã“ã®ã‚ˆã†ãªä½¿ç”¨ã«ã¤ã„ã¦ã€ã•ã‚‰ã«è©³ã—ãèª¬æ˜ã™ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="%_thm_2.21"></a>
<b>Exercise 2.21.</b>  The procedure <tt>square-list</tt> takes a list of
numbers as argument and returns a list of the squares of those
numbers.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.21.</b> <tt>square-list</tt> ã¨ã„ã†æ‰‹ç¶šãã¯ã€æ•°ã®ãƒªã‚¹ãƒˆã‚’å¼•æ•°ã¨ã—ã¦å–ã‚Šã€ãã‚Œã‚‰ã®æ•°ã®äºŒä¹—ã®ãƒªã‚¹ãƒˆã‚’è¿”ã™ã€‚
</p>

<p class="lisp">(square-list (list 1 2 3 4))
<i>(1 4 9 16)</i>
</p>

<p class="orig" lang="en">
Here are two different definitions of <tt>square-list</tt>.  Complete
both of them by filling in the missing expressions:
</p>

<p class="trans" lang="ja">
ã“ã“ã«ã€<tt>square-list</tt> ã®äºŒã¤ã®ç•°ãªã‚‹å®šç¾©ãŒã‚ã‚‹ã€‚
ãã‚Œã‚‰ã®ã©ã¡ã‚‰ã«ã¤ã„ã¦ã‚‚ã€æ¬ ã‘ã¦ã„ã‚‹å¼ã‚’åŸ‹ã‚ã‚‹ã“ã¨ã§ã€å®Œæˆã•ã›ã‚ˆã€‚
</p>

<p class="lisp">(define (square-list items)
  (if (null? items)
      nil
      (cons &lt;<em>??</em>&gt; &lt;<em>??</em>&gt;)))
(define (square-list items)
  (map &lt;<em>??</em>&gt; &lt;<em>??</em>&gt;))
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_2.22"></a>
<b>Exercise 2.22.</b>  Louis Reasoner tries to rewrite the first <tt>square-list</tt> procedure of
exercise <a href="#%_thm_2.21">2.21</a> so that it evolves an iterative
process:
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.22.</b> ãƒ«ã‚¤ã‚¹ãƒ»ãƒªãƒ¼ã‚ºãƒŠã¯ã€ç·´ç¿’å•é¡Œ<a href="#%_thm_2.21">2.21</a>ã®æœ€åˆã® <tt>square-list</tt> ã®æ‰‹ç¶šãã‚’ã€åå¾©çš„ãƒ—ãƒ­ã‚»ã‚¹ã‚’ç™ºé”ã•ã›ã‚‹ã‚ˆã†ã«ã€æ›¸ãç›´ãã†ã¨è©¦ã¿ã‚‹ã€‚
</p>

<p class="lisp">(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things) 
              (cons (square (car things))
                    answer))))
  (iter items nil))
</p>

<p class="orig" lang="en">
Unfortunately, defining <tt>square-list</tt> this way produces the answer
list in the reverse order of the one desired.  Why?</p>

<p class="trans" lang="ja">
ã‚ã„ã«ãã€ã“ã®æ–¹æ³•ã§ <tt>square-list</tt> ã‚’å®šç¾©ã™ã‚‹ã¨ã€æ‰€æœ›ã®é †åºã®é€†é †ã«ãªã£ãŸç­”ãˆã®ãƒªã‚¹ãƒˆãŒä½œã‚Šå‡ºã•ã‚Œã‚‹ã€‚
ãªãœã‹?
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">Louis then tries to fix his bug by interchanging the arguments to
<tt>cons</tt>:
</p>

<p class="trans" lang="ja">
ãƒ«ã‚¤ã‚¹ã¯ãã‚Œã‹ã‚‰ã€<tt>cons</tt> ã«ä¸ãˆã‚‹å¼•æ•°ã‚’å…¥ã‚Œæ›¿ãˆã‚‹ã“ã¨ã§ã€è‡ªåˆ†ã®ãƒã‚°ã‚’ç›´ãã†ã¨è©¦ã¿ã‚‹ã€‚
</p>

<p class="lisp">(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons answer
                    (square (car things))))))
  (iter items nil))
</p>

<p class="orig" lang="en">
This doesn't work either.  Explain.
</p>

<p class="trans" lang="ja">
ã“ã‚Œã‚‚ã†ã¾ãã„ã‹ãªã„ã€‚
èª¬æ˜ã›ã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_2.23"></a>
<b>Exercise 2.23.</b>  The procedure <a name="%_idx_1670"></a><tt>for-each</tt> is similar to <tt>map</tt>.  It takes as
arguments a procedure and a list of elements.  However, rather than
forming a list of the  results, <tt>for-each</tt> just applies the procedure
to each of the elements in turn, from left to right.  The values
returned by applying the procedure to the elements are not used at
all -- <tt>for-each</tt> is used with procedures that perform an action,
such as printing.  For example,</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.23.</b> 
<tt>for-each</tt> ã¨ã„ã†æ‰‹ç¶šãã¯ <tt>map</tt> ã«ä¼¼ã¦ã„ã‚‹ã€‚
ã“ã‚Œã¯ã€æ‰‹ç¶šãã¨ã€è¦ç´ ã®ãƒªã‚¹ãƒˆã¨ã‚’ã€å¼•æ•°ã¨ã—ã¦å–ã‚‹ã€‚
ã—ã‹ã—ã€<tt>for-each</tt> ã¯ã€çµæœã®ãƒªã‚¹ãƒˆã‚’å½¢æˆã™ã‚‹ã¨ã„ã†ã‚ˆã‚Šã¯ã‚€ã—ã‚ã€å˜ã«ã€ãã®æ‰‹ç¶šãã‚’é †ã€…ã«å·¦ã‹ã‚‰å³ã¸ã¨ã€è¦ç´ ã®å„ã€…ã¸ã¨é©ç”¨ã™ã‚‹ã ã‘ã§ã‚ã‚‹ã€‚
è¦ç´ ã«æ‰‹ç¶šãã‚’é©ç”¨ã™ã‚‹ã“ã¨ã§è¿”ã•ã‚Œã‚‹å€¤ã¯ã€ã¾ã£ãŸãä½¿ã‚ã‚Œãªã„â€”â€”<tt>for-each</tt> ã¯ã€å°å­—ãªã©ã®å‹•ä½œã‚’å®Ÿè¡Œã™ã‚‹æ‰‹ç¶šãã¨ã¨ã‚‚ã«ä½¿ã‚ã‚Œã‚‹ã€‚
ãŸã¨ãˆã°ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ã€‚
</p>

<p class="lisp">(for-each (lambda (x) (newline) (display x))
          (list 57 321 88))
<i>57</i>
<i>321</i>
<i>88</i>
</p>

<p class="orig" lang="en">
The value returned by the call to <tt>for-each</tt> (not illustrated above)
can be something arbitrary, such as true.  Give an
implementation of <tt>for-each</tt>.
</p>

<p class="trans" lang="ja">
<tt>for-each</tt> ã®å‘¼ã³å‡ºã—ã«ã‚ˆã‚Šè¿”ã•ã‚Œã‚‹å€¤ (ä¸Šè¨˜ã«ã¯ç¤ºã•ã‚Œã¦ã„ãªã„) ã¯ã€ä»»æ„ã®ä½•ã‹â€”â€”ãŸã¨ãˆã°çœŸãªã©â€”â€”ã§ã‚ã£ã¦ã‚ˆã„ã€‚
<tt>for-each</tt> ã®å®Ÿè£…ã‚’ä¸ãˆã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_2.2.2"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_2.2.2">2.2.2  Hierarchical Structures</a></h3>
<h3 class="trans" lang="ja">2.2.2 éšå±¤çš„æ§‹é€ </h3>

<p class="orig" lang="en">
<a name="%_idx_1672"></a><a name="%_idx_1674"></a><a name="%_idx_1676"></a><a name="%_idx_1678"></a>
The representation of sequences in terms of lists generalizes
naturally to represent sequences whose elements may
themselves be sequences.  For example, we can regard the object
<tt>((1 2) 3 4)</tt> constructed by
</p>

<p class="trans" lang="ja">
ãƒªã‚¹ãƒˆã‚’ä½¿ã£ãŸåˆ—ã®è¡¨ç¾ã¯ã€è¦ç´ è‡ªä½“ãŒåˆ—ã§ã‚ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã‚ˆã†ãªåˆ—ã‚’è¡¨ç¾ã™ã‚‹ã‚ˆã†ã«ã€è‡ªç„¶ã¨ä¸€èˆ¬åŒ–ã—ã¦ã‚†ãã€‚
ãŸã¨ãˆã°ã€ä»¥ä¸‹ã«ã‚ˆã‚Šæ§‹ç¯‰ã•ã‚ŒãŸ <tt>((1 2) 3 4)</tt> ã¨ã„ã†ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã€
</p>

<p class="lisp">(cons (list 1 2) (list 3 4))
</p>

<p class="orig" lang="en">
as a list of three items, the first of which is itself a list, <tt>(1 2)</tt>.  Indeed, this is suggested by the form in which the result is
printed by the interpreter.  Figure <a href="#%_fig_2.5">2.5</a> shows
the representation of this structure in terms of pairs.</p>

<p class="trans" lang="ja">
ä¸‰ã¤ã®é …ç›®ã®ãƒªã‚¹ãƒˆâ€”â€”ãã®ä¸‰ã¤ã®é …ç›®ã®ã†ã¡ã®ä¸€ã¤ç›®ã¯ã€ãã‚Œè‡ªä½“ãŒã€<tt>(1 2)</tt> ã¨ã„ã†ãƒªã‚¹ãƒˆã§ã‚ã‚‹â€”â€”ã¨è¦‹ãªã™ã“ã¨ãŒã§ãã‚‹ã€‚
å®Ÿéš›ã€ã“ã®ã“ã¨ã¯ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«ã‚ˆã‚ŠçµæœãŒå°å­—ã•ã‚Œã¦ã„ã‚‹ã€ãã®å½¢å¼ã‹ã‚‰ã€ç¤ºå”†ã•ã‚Œã‚‹ã€‚
å›³<a href="#%_fig_2.5">2.5</a>ã¯ã€å¯¾ã®è¦³ç‚¹ã‹ã‚‰ã“ã®æ§‹é€ ã®è¡¨ç¾ã‚’ç¤ºã—ã¦ã„ã‚‹ã€‚
</p>

<figure>
<a name="%_fig_2.5"></a>
<img src="ch2-Z-G-15.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 2.5:</b>  Structure formed by <tt>(cons (list 1 2) (list 3 4))</tt>.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³2.5:</b> <tt>(cons (list 1 2) (list 3 4))</tt> ã«ã‚ˆã‚Šå½¢æˆã•ã‚Œã‚‹æ§‹é€ </figcaption>
</figure>

<p class="orig" lang="en">Another way to think of sequences whose elements are sequences is as
<em>trees</em>.  The elements of the sequence are the branches of the
tree, and elements that are themselves sequences are subtrees.
Figure <a href="#%_fig_2.6">2.6</a> shows the structure in
figure <a href="#%_fig_2.5">2.5</a> viewed as a tree.</p>

<p class="trans" lang="ja">
è¦ç´ ãŒåˆ—ã§ã‚ã‚‹ã‚ˆã†ãªåˆ—ã‚’è€ƒãˆã‚‹ãŸã‚ã®åˆ¥ã®æ–¹æ³•ã¯ã€<em>æœ¨</em>ã¨ã—ã¦è€ƒãˆã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚
åˆ—ã®è¦ç´ ã¯ã€æœ¨ã®åˆ†æã§ã‚ã‚Šã€ãã‚Œè‡ªä½“ãŒåˆ—ã§ã‚ã‚‹ã‚ˆã†ãªè¦ç´ ã¯ã€éƒ¨åˆ†æœ¨ã§ã‚ã‚‹ã€‚
å›³ <a href="#%_fig_2.6">2.6</a>ã¯ã€æœ¨ã¨ã—ã¦è¦‹ãŸã€å›³<a href="#%_fig_2.5">2.5</a>ã®æ§‹é€ ã‚’ã€ç¤ºã—ã¦ã„ã‚‹ã€‚
</p>

<a name="%_fig_2.6"></a>
<figure>
<img src="ch2-Z-G-16.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 2.6:</b>  The list structure in figure <a href="#%_fig_2.5">2.5</a> viewed as a tree.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³2.6:</b> æœ¨ã¨ã—ã¦è¦‹ãŸã€å›³<a href="#%_fig_2.5">2.5</a>ã®ãƒªã‚¹ãƒˆæ§‹é€ </figcaption>
</figure>

<p class="orig" lang="en">
<a name="%_idx_1680"></a>Recursion is a natural tool for dealing with tree structures, since
we can often reduce operations on trees to operations on their
branches, which reduce in turn to operations on the branches of the
branches, and so on, until we reach the leaves of the tree.
As an example, compare the <tt>length</tt> procedure of
section <a href="#%_sec_2.2.1">2.2.1</a> with the <a name="%_idx_1682"></a><a name="%_idx_1684"></a><tt>count-leaves</tt> procedure, which
returns the total number of leaves of a tree:</p>

<p class="trans" lang="ja">
å†å¸°ã¯ã€æœ¨æ§‹é€ ã‚’æ‰±ã†ãŸã‚ã®è‡ªç„¶ãªæ‰‹æ®µã ã€‚ã¨ã„ã†ã®ã‚‚ã€ç§ãŸã¡ã¯ã€ã—ã°ã—ã°ã€æœ¨ã®è‘‰ã«åˆ°é”ã™ã‚‹ã¾ã§ã€æœ¨ã«å¯¾ã™ã‚‹æ¼”ç®—ã‚’ãã®åˆ†æã«å¯¾ã™ã‚‹æ¼”ç®—ã¸ã¨é‚„å…ƒã—ã€ãã—ã¦ã€ãã‚Œã‚’ä»Šåº¦ã¯åˆ†æã®åˆ†æã«å¯¾ã™ã‚‹æ¼”ç®—ã¸ã¨é‚„å…ƒã—ã€ã¨ã„ã†ãµã†ã«ã—ã¦ã„ãã“ã¨ãŒã§ãã‚‹ã‹ã‚‰ã ã€‚
ä¾‹ã¨ã—ã¦ã€<a href="#%_sec_2.2.1">2.2.1</a>ç¯€ã® <tt>length</tt> ã®æ‰‹ç¶šãã‚’ã€<tt>count-leaves</tt> ã¨ã„ã†æ‰‹ç¶šãâ€”â€”æœ¨ã®ä¸­ã®è‘‰ã®ç·æ•°ã‚’è¿”ã™â€”â€”ã¨æ¯”è¼ƒã›ã‚ˆã€‚
</p>

<p class="lisp">(define x (cons (list 1 2) (list 3 4)))

(length x)
<i>3</i>
(count-leaves x)
<i>4</i>

(list x x)
<i>(((1 2) 3 4) ((1 2) 3 4))</i>

(length (list x x))
<i>2</i>

(count-leaves (list x x))
<i>8</i>
</p>

<p class="orig" lang="en">
To implement <tt>count-leaves</tt>, recall the recursive plan for computing
<tt>length</tt>:</p>

<p class="trans" lang="ja">
<tt>count-leaves</tt> ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã«ã€<tt>length</tt> ã‚’è¨ˆç®—ã™ã‚‹ãŸã‚ã®å†å¸°çš„è¨ˆç”»ã‚’æ€ã„å‡ºãã†ã€‚
</p>

<ul class="orig" lang="en">
<li><tt>Length</tt> of a list <tt>x</tt> is 1 plus <tt>length</tt> of the
<tt>cdr</tt> of <tt>x</tt>.</li>
<li><tt>Length</tt> of the empty list is 0.</li>
</ul>

<ul class="trans" lang="ja">
<li><tt>x</tt> ãªã‚‹ãƒªã‚¹ãƒˆã® <tt>length</tt> (é•·ã•) ã¯ã€1ã¨ã€<tt>x</tt> ã® <tt>cdr</tt> ã® <tt>length</tt> ã¨ã®å’Œã§ã‚ã‚‹ã€‚</li>
<li>ç©ºãƒªã‚¹ãƒˆã® <tt>length</tt> ã¯0ã§ã‚ã‚‹ã€‚</li>
</ul>

<p class="orig" lang="en"><tt>Count-leaves</tt> is similar.  The value for the empty list is the same:</p>

<p class="trans" lang="ja">
<tt>count-leaves</tt> ã‚‚ä¼¼ãŸã‚ˆã†ãªã‚‚ã®ã ã€‚
ç©ºãƒªã‚¹ãƒˆã«å¯¾ã™ã‚‹å€¤ã¯åŒã˜ã§ã‚ã‚‹ã€‚
</p>

<ul class="orig" lang="en">
<li><tt>Count-leaves</tt> of the empty list is 0.</li>
</ul>

<ul class="trans" lang="ja">
<li>ç©ºãƒªã‚¹ãƒˆã® <tt>count-leaves</tt> ã¯0ã§ã‚ã‚‹ã€‚</li>
</ul>

<p class="orig" lang="en">But in the reduction step, where we strip off the <tt>car</tt> of the
list, we must take into account that the <tt>car</tt> may itself be a
tree whose leaves we need to count.  Thus, the appropriate reduction
step is</p>

<p class="trans" lang="ja">
ã—ã‹ã—ã€é‚„å…ƒã‚¹ãƒ†ãƒƒãƒ—â€”â€”ãƒªã‚¹ãƒˆã® <tt>car</tt> ã‚’å‰¥ãå–ã‚‹ã¨ã“ã‚â€”â€”ã§ã¯ã€<tt>car</tt> è‡ªä½“ãŒã€ãã®è‘‰ã‚’æ•°ãˆã‚‹å¿…è¦ãŒã‚ã‚‹ã‚ˆã†ãªæœ¨ã‹ã‚‚ã—ã‚Œãªã„ã€ã¨ã„ã†ã“ã¨ã‚’ã€è€ƒæ…®ã«å…¥ã‚Œã­ã°ãªã‚‰ãªã„ã€‚
ã‚ˆã£ã¦ã€é©åˆ‡ãªé‚„å…ƒã‚¹ãƒ†ãƒƒãƒ—ã¯ä»¥ä¸‹ã®ã¨ãŠã‚Šã§ã‚ã‚‹ã€‚
</p>

<ul class="orig" lang="en">
<li><tt>Count-leaves</tt> of a tree <tt>x</tt> is <tt>count-leaves</tt> of the <tt>car</tt> of <tt>x</tt> plus <tt>count-leaves</tt> of the
<tt>cdr</tt> of <tt>x</tt>.</li>
</ul>

<ul class="trans" lang="ja">
<li><tt>x</tt> ãªã‚‹æœ¨ã® <tt>count-leaves</tt> ã¯ã€<tt>x</tt> ã® <tt>car</tt> ã® <tt>count-leaves</tt> ã¨ã€<tt>x</tt> ã® <tt>cdr</tt> ã® <tt>count-leaves</tt> ã¨ã®å’Œã§ã‚ã‚‹ã€‚</li>
</ul>

<p class="orig" lang="en">Finally, by taking <tt>car</tt>s we reach
actual leaves, so we need another base case:</p>

<p class="trans" lang="ja">
æœ€å¾Œã«ã€<tt>car</tt> ã‚’å–ã‚‹ã“ã¨ã§å®Ÿéš›ã®è‘‰ã«åˆ°é”ã™ã‚‹ã®ã§ã€ã‚‚ã†ä¸€ã¤ã®åŸºåº•ã®å ´åˆãŒå¿…è¦ã ã€‚
</p>

<ul class="orig" lang="en">
<li><tt>Count-leaves</tt> of a leaf is 1.</li>
</ul>

<ul class="trans" lang="ja">
<li>è‘‰ã®<tt>count-leaves</tt> ã¯1ã§ã‚ã‚‹ã€‚</li>
</ul>

<p class="orig" lang="en">To aid
in writing recursive procedures on trees, Scheme provides the primitive
predicate <a name="%_idx_1686"></a><a name="%_idx_1688"></a><tt>pair?</tt>, which tests whether its argument is a pair.
Here is the complete procedure:<a name="call_footnote_Temp_170" href="#footnote_Temp_170"><sup><small>13</small></sup></a></p>

<p class="trans" lang="ja">
æœ¨ã«å¯¾ã™ã‚‹å†å¸°çš„æ‰‹ç¶šãã‚’æ›¸ãã®ã‚’æ”¯æ´ã™ã‚‹ãŸã‚ã«ã€Schemeã¯ã€<tt>pair?</tt> ã¨ã„ã†åŸå§‹çš„è¿°èªâ€”â€”å¼•æ•°ãŒå¯¾ã‹ã©ã†ã‹ã‚’ãƒ†ã‚¹ãƒˆã™ã‚‹â€”â€”ã‚’æä¾›ã—ã¦ã„ã‚‹ã€‚
ã“ã“ã«ã€å®Œå…¨ãªæ‰‹ç¶šããŒã‚ã‚‹<a href="#footnote_Temp_170"><sup><small>13</small></sup></a>ã€‚
</p>

<p class="lisp"><a name="%_idx_1690"></a>(define (count-leaves x)
  (cond ((null? x) 0)  
        ((not (pair? x)) 1)
        (else (+ (count-leaves (car x))
                 (count-leaves (cdr x))))))
</p>

<p class="orig" lang="en"><a name="%_thm_2.24"></a>
<b>Exercise 2.24.</b>  Suppose we evaluate the expression <tt>(list 1 (list 2 (list 3 4)))</tt>.
Give the result printed by the interpreter, the corresponding
box-and-pointer structure, and the interpretation of this as a tree
(as in figure <a href="#%_fig_2.6">2.6</a>).
<p></p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.24</b> <tt>(list 1 (list 2 (list 3 4)))</tt> ã¨ã„ã†å¼ã‚’è©•ä¾¡ã™ã‚‹ã‚‚ã®ã¨æƒ³å®šã›ã‚ˆã€‚
ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«ã‚ˆã‚Šå°å­—ã•ã‚Œã‚‹çµæœã¨ã€ãã‚Œã«å¯¾å¿œã™ã‚‹ç®±ãƒ»ãƒã‚¤ãƒ³ã‚¿å¼ã®æ§‹é€ ã¨ã€ã“ã‚Œã®æœ¨ã¨ã—ã¦ã®è§£é‡ˆ (å›³<a href="#%_fig_2.6">2.6</a>ã®ã‚ˆã†ãªã‚‚ã®) ã‚’ç¤ºã›ã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_2.25"></a>
<b>Exercise 2.25.</b>  Give combinations of <tt>car</tt>s and <tt>cdr</tt>s that will pick 7 from
each of the following lists:
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.25.</b> ä»¥ä¸‹ã®ãƒªã‚¹ãƒˆã®å„ã€…ã‹ã‚‰7ã‚’é¸ã³å‡ºã™ã‚ˆã†ãªã€<tt>car</tt> ã¨ <tt>cdr</tt> ã®çµ„ã¿åˆã‚ã›ã‚’ç¤ºã›ã€‚
</p>

<p class="lisp">(1 3 (5 7) 9)

((7))

(1 (2 (3 (4 (5 (6 7))))))
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_2.26"></a>
<b>Exercise 2.26.</b>  Suppose we define <tt>x</tt> and <tt>y</tt> to be two lists:
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.26.</b> <tt>x</tt> ã¨ <tt>y</tt> ã‚’ã€ä»¥ä¸‹ã®äºŒã¤ã®ãƒªã‚¹ãƒˆã ã¨å®šç¾©ã™ã‚‹ã‚‚ã®ã¨ã™ã‚‹ã€‚
</p>

<p class="lisp">(define x (list 1 2 3))
(define y (list 4 5 6))
</p>

<p class="orig" lang="en">
What result is printed by the interpreter in response to evaluating
each of the following expressions:
</p>

<p class="trans" lang="ja">
ä»¥ä¸‹ã®å¼ã®å„ã€…ã‚’è©•ä¾¡ã™ã‚‹ã®ã«å¿œã˜ã¦ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«ã‚ˆã‚Šå°å­—ã•ã‚Œã‚‹çµæœã¯ã€ã©ã®ã‚ˆã†ãªã‚‚ã®ã‹?
</p>

<p class="lisp">(append x y)

(cons x y)

(list x y)
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_2.27"></a>
<b>Exercise 2.27.</b>  Modify your <tt>reverse</tt> procedure of exercise <a href="#%_thm_2.18">2.18</a> to
produce a <a name="%_idx_1692"></a><a name="%_idx_1694"></a><tt>deep-reverse</tt> procedure that takes a list as argument
and returns as its value the list with its elements reversed and with
all sublists deep-reversed as well.  For example,
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.27.</b> ç·´ç¿’å•é¡Œ<a href="#%_thm_2.18">2.18</a>ã§å›ã®æ›¸ã„ãŸ <tt>reverse</tt> ã®æ‰‹ç¶šãã‚’ä¿®æ­£ã—ã¦ã€<tt>deep-reverse</tt> ã®æ‰‹ç¶šãã‚’ä½œã‚Šå‡ºã›ã€‚ã“ã®æ‰‹ç¶šãã¯ã€ãƒªã‚¹ãƒˆã‚’å¼•æ•°ã¨ã—ã¦å–ã‚‹ã€‚ãã—ã¦ã€è¦ç´ ãŒé€†é †ã«ãªã£ã¦ã„ã¦ã€ã™ã¹ã¦ã®éƒ¨åˆ†ãƒªã‚¹ãƒˆã‚‚å¥¥ã¾ã§é€†é †ã«ãªã£ã¦ã„ã‚‹ã‚ˆã†ãªãƒªã‚¹ãƒˆã‚’ã€å€¤ã¨ã—ã¦è¿”ã™ã€‚
ãŸã¨ãˆã°ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ã€‚
</p>

<p class="lisp">(define x (list (list 1 2) (list 3 4)))

x
<i>((1 2) (3 4))</i>

(reverse x)
<i>((3 4) (1 2))</i>

(deep-reverse x)
<i>((4 3) (2 1))</i>
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_2.28"></a>
<b>Exercise 2.28.</b>  Write a procedure <a name="%_idx_1696"></a><a name="%_idx_1698"></a><tt>fringe</tt> that takes as argument a tree
(represented as a list) and returns a list whose elements are all the
leaves of the tree arranged in left-to-right order.  For example,
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.28.</b> å¼•æ•°ã¨ã—ã¦æœ¨ (ãƒªã‚¹ãƒˆã¨ã—ã¦è¡¨ç¾ã•ã‚Œã¦ã„ã‚‹ã‚‚ã®) ã‚’å–ã‚Šã€ãã®æœ¨ã®ã™ã¹ã¦ã®è‘‰ã‚’å·¦ã‹ã‚‰å³ã¸å‘ã‹ã†é †åºã§ä¸¦ã¹ãŸã‚‚ã®ã‚’è¦ç´ ã¨ã™ã‚‹ãƒªã‚¹ãƒˆã‚’è¿”ã™ã€<tt>fringe</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’æ›¸ã‘ã€‚
ä¾‹ãˆã°ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚‹ã€‚
</p>

<p class="lisp">(define x (list (list 1 2) (list 3 4)))

(fringe x)
<i>(1 2 3 4)</i>

(fringe (list x x))
<i>(1 2 3 4 1 2 3 4)</i>
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_2.29"></a>
<b>Exercise 2.29.</b>  <a name="%_idx_1700"></a>A binary mobile consists of two branches, a left branch and a right
branch.  Each branch is a rod of a certain length, from which hangs
either a weight or another binary mobile.  We can represent a binary
mobile using compound data by constructing it from two branches (for
example, using <tt>list</tt>):</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.29.</b> äºŒåˆ†å¼ãƒ¢ãƒ“ãƒ¼ãƒ«ã¯äºŒã¤ã®åˆ†æâ€”â€”ã™ãªã‚ã¡ã€å·¦åˆ†æã¨å³åˆ†æâ€”â€”ã‹ã‚‰ãªã‚‹ã€‚
å„åˆ†æã¯ã€ã‚ã‚‹é•·ã•ã®æ£’ã§ã‚ã‚Šã€ãã“ã‹ã‚‰ã¯ã€éŒ˜ã‹ã€åˆ¥ã®äºŒåˆ†å¼ãƒ¢ãƒ“ãƒ¼ãƒ«ãŒã¶ã‚‰ä¸‹ãŒã‚‹ã€‚
äºŒã¤ã®åˆ†æã‹ã‚‰ (ãŸã¨ãˆã° <tt>list</tt> ã‚’ä½¿ã£ã¦) è¤‡åˆçš„ãƒ‡ãƒ¼ã‚¿ã‚’æ§‹ç¯‰ã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€ç§ãŸã¡ã¯ã€ãã®è¤‡åˆçš„ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ã£ã¦äºŒåˆ†å¼ãƒ¢ãƒ“ãƒ¼ãƒ«ã‚’è¡¨ç¾ã§ãã‚‹ã€‚
</p>

<p class="lisp">(define (make-mobile left right)
  (list left right))
</p>

<p class="orig" lang="en">
A branch is constructed from a <tt>length</tt> (which must be a number)
together with a <tt>structure</tt>, which may be either a number
(representing a simple weight) or another mobile:</p>

<p class="trans" lang="ja">
åˆ†æã¯ã€<tt>length</tt> (ã“ã‚Œã¯ã€æ•°ã§ãªãã¦ã¯ãªã‚‰ãªã„) ã¨ã€<tt>structure</tt>â€”â€”ã“ã‚Œã¯ã€æ•° (å˜ç´”ãªéŒ˜ã‚’è¡¨ã™) ã¾ãŸã¯ä»–ã®ãƒ¢ãƒ“ãƒ¼ãƒ«ã§ã‚ã‚Šå¾—ã‚‹â€”â€”ã‹ã‚‰ã€æ§‹ç¯‰ã•ã‚Œã‚‹ã€‚
</p>

<p class="lisp">(define (make-branch length structure)
  (list length structure))
</p>

<ol class="orig" lang="en" style="list-style-type: lower-alpha">
<li>Write the corresponding selectors <tt>left-branch</tt> and
<tt>right-branch</tt>, which return the branches of a mobile, and
<tt>branch-length</tt> and <tt>branch-structure</tt>, which return 
the components of a branch.</li>

<li>Using your selectors, define a procedure <tt>total-weight</tt> 
that returns the total weight of a mobile.</li>

<li>A mobile is said to be <a name="%_idx_1702"></a><em>balanced</em> if the torque applied
by its top-left branch is equal to that applied by its top-right
branch (that is, if the length of the left rod multiplied by the
weight hanging from that rod is equal to the corresponding product for
the right side) and if each of the submobiles hanging off its branches
is balanced. Design a predicate that tests whether a binary mobile is
balanced.</li>

<li>Suppose we change the representation of mobiles so that the
constructors are</li>
</ol>

<ol class="trans" lang="ja" style="list-style-type: lower-alpha">
<li>å¯¾å¿œã™ã‚‹ã‚»ãƒ¬ã‚¯ã‚¿ãŸã‚‹ã€<tt>left-branch</tt> ãŠã‚ˆã³ <tt>right-branch</tt>â€”â€”ãƒ¢ãƒ“ãƒ¼ãƒ«ã®åˆ†æã‚’è¿”ã™â€”â€”ã¨ã€<tt>branch-length</tt> ãŠã‚ˆã³ <tt>branch-structure</tt>â€”â€”åˆ†æã®æ§‹æˆè¦ç´ ã‚’è¿”ã™â€”â€”ã¨ã€ã‚’æ›¸ã‘ã€‚</li>
<li>å›ã®ã‚»ãƒ¬ã‚¯ã‚¿ã‚’ä½¿ã£ã¦ã€ãƒ¢ãƒ“ãƒ¼ãƒ«ã®ç·é‡é‡ã‚’è¿”ã™ã€<tt>total-weight</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’å®šç¾©ã›ã‚ˆã€‚</li>
<li>æ¬¡ã®å ´åˆã«ã€ãƒ¢ãƒ“ãƒ¼ãƒ«ã¯ã€<em>å¹³è¡¡</em>ã§ã‚ã‚‹ã¨è¨€ã‚ã‚Œã‚‹ã€‚ã™ãªã‚ã¡ã€ä¸€ç•ªä¸Šã®å·¦å´ã®åˆ†æã«ã‚ˆã‚ŠåŠ ãˆã‚‰ã‚Œã‚‹ãƒˆãƒ«ã‚¯ãŒã€ä¸€ç•ªä¸Šã®å³å´ã®åˆ†æã«ã‚ˆã‚ŠåŠ ãˆã‚‰ã‚Œã‚‹ãƒˆãƒ«ã‚¯ã¨ç­‰ã—ãã¦ (ã¤ã¾ã‚Šã€å·¦ã®æ£’ã®é•·ã•ã«ã€ãã®æ£’ã‹ã‚‰ã¶ã‚‰ä¸‹ãŒã£ã¦ã„ã‚‹é‡é‡ã‚’æ›ã‘ãŸã‚‚ã®ãŒã€å³å´ã®å¯¾å¿œã™ã‚‹ç©ã¨ç­‰ã—ãã¦)ã€ã‹ã¤ã€åˆ†æã‹ã‚‰ã¶ã‚‰ä¸‹ãŒã£ã¦ã„ã‚‹éƒ¨åˆ†ãƒ¢ãƒ“ãƒ¼ãƒ«ã®å„ã€…ãŒå¹³è¡¡ã§ã‚ã‚‹å ´åˆã ã€‚
äºŒåˆ†å¼ãƒ¢ãƒ“ãƒ¼ãƒ«ãŒå¹³è¡¡ã‹ã©ã†ã‹ã‚’ãƒ†ã‚¹ãƒˆã™ã‚‹è¿°èªã‚’è¨­è¨ˆã›ã‚ˆã€‚
</li>
<li>ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãŒä»¥ä¸‹ã®ã¨ãŠã‚Šã«ãªã‚‹ã‚ˆã†ã«ã€ãƒ¢ãƒ“ãƒ¼ãƒ«ã®è¡¨ç¾ã‚’å¤‰æ›´ã™ã‚‹ã‚‚ã®ã¨ã™ã‚‹ã€‚</li>
</ol>

<p class="lisp">(define (make-mobile left right)
  (cons left right))
(define (make-branch length structure)
  (cons length structure))
</p>

<p class="orig" lang="en">
How much do you need to change your programs to convert to the new
representation?</p>

<p class="trans" lang="ja">
æ–°ã—ã„è¡¨ç¾ã¸ã¨è»¢æ›ã™ã‚‹ãŸã‚ã«ã€å›ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ã©ã‚Œãã‚‰ã„å¤‰æ›´ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã‹?
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_Temp_177"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_177">Mapping over trees</a></h4>
<h4 class="trans" lang="ja">æœ¨å…¨ä½“ã«ã‚ãŸã‚‹å†™åƒ</h4>

<p class="orig" lang="en"><a name="%_idx_1704"></a><a name="%_idx_1706"></a>
Just as <tt>map</tt> is a powerful abstraction for dealing with sequences,
<tt>map</tt> together with recursion is a powerful abstraction for
dealing with trees.  For instance, the <tt>scale-tree</tt>
procedure, analogous to <tt>scale-list</tt> of
section <a href="#%_sec_2.2.1">2.2.1</a>, takes as arguments a numeric factor and a
tree whose leaves are numbers.  It returns a tree of the same shape,
where each number is multiplied by the factor.
The recursive plan for <tt>scale-tree</tt> is similar to the one for
<tt>count-leaves</tt>:
</p>

<p class="trans" lang="ja">
<tt>map</tt> ãŒã€åˆ—ã‚’æ‰±ã†ãŸã‚ã®å¼·åŠ›ãªæŠ½è±¡æ¦‚å¿µã§ã‚ã‚‹ã®ã¨ã¡ã‚‡ã†ã©åŒã˜ã‚ˆã†ã«ã€å†å¸°ã‚’ã¨ã‚‚ãªã† <tt>map</tt> ã¯ã€æœ¨ã‚’æ‰±ã†ãŸã‚ã®å¼·åŠ›ãªæŠ½è±¡æ¦‚å¿µã§ã‚ã‚‹ã€‚
ãŸã¨ãˆã°ã€<tt>scale-tree</tt> ã¨ã„ã†æ‰‹ç¶šãâ€”â€”<a href="#%_sec_2.2.1">2.2.1</a>ç¯€ã® <tt>scale-list</tt> ã«é¡ä¼¼ã—ã¦ã„ã‚‹â€”â€”ã¯ã€æ•°å€¤ã®å› å­ã¨ã€è‘‰ãŒæ•°ã§ã‚ã‚‹ã‚ˆã†ãªæœ¨ã‚’ã€å¼•æ•°ã¨ã—ã¦å–ã‚‹ã€‚
ã“ã‚Œã¯ã€åŒã˜å½¢ã®æœ¨ã‚’è¿”ã™ãŒã€ãã®æœ¨ã«ãŠã„ã¦ã¯ã€å„ã€…ã®æ•°ã¯ã€ä¸Šè¨˜ã®å› å­ã‚’æ›ã‘ãŸã‚‚ã®ã§ã‚ã‚‹ã€‚
<tt>scale-tree</tt> ã®ãŸã‚ã®å†å¸°çš„è¨ˆç”»ã¯ã€<tt>count-leaves</tt> ã®ãŸã‚ã®å†å¸°çš„è¨ˆç”»ã«ä¼¼ã¦ã„ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_1708"></a>(define (scale-tree tree factor)
  (cond ((null? tree) nil)
        ((not (pair? tree)) (* tree factor))
        (else (cons (scale-tree (car tree) factor)
                    (scale-tree (cdr tree) factor)))))
(scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7))
            10)
<i>(10 (20 (30 40) 50) (60 70))</i>
</p>

<p class="orig" lang="en">Another way to implement <tt>scale-tree</tt> is to regard the
tree as a sequence of sub-trees and use <tt>map</tt>.  We map
over the sequence, scaling each sub-tree in turn, and return the list
of results.  In the base case, where the tree is a leaf, we simply
multiply by the factor:
</p>

<p class="trans" lang="ja">
<tt>scale-tree</tt> ã‚’å®Ÿè£…ã™ã‚‹åˆ¥ã®æ–¹æ³•ã¯ã€æœ¨ã‚’éƒ¨åˆ†æœ¨ã®åˆ—ã¨ã¿ãªã—ã¦ã€<tt>map</tt> ã‚’ä½¿ã†ã“ã¨ã ã€‚
å„éƒ¨åˆ†æœ¨ã‚’é †ã«å¤‰å€ã—ãªãŒã‚‰ã€åˆ—ã®å…¨ä½“ã«ã‚ãŸã£ã¦å†™åƒã‚’è¡Œã„ã€ãã®çµæœã®ãƒªã‚¹ãƒˆã‚’è¿”ã™ã‚ã‘ã ã€‚
åŸºåº•ã®å ´åˆâ€”â€”æœ¨ãŒè‘‰ã§ã‚ã‚‹å ´åˆâ€”â€”ã§ã¯ã€å˜ç´”ã«å› å­ã‚’æ›ã‘ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_1710"></a>(define (scale-tree tree factor)
  (map (lambda (sub-tree)
         (if (pair? sub-tree)
             (scale-tree sub-tree factor)
             (* sub-tree factor)))
       tree))
</p>

<p class="orig" lang="en">
Many tree operations can be implemented by similar combinations of
sequence operations and recursion.</p>

<p class="trans" lang="ja">
æœ¨ã«ã¤ã„ã¦ã®å¤šãã®æ¼”ç®—ã¯ã€åˆ—ã«ã¤ã„ã¦ã®æ¼”ç®—ã¨å†å¸°ã¨ã®é¡ä¼¼ã®çµ„ã¿åˆã‚ã›ã«ã‚ˆã‚Šã€å®Ÿè£…ã§ãã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="%_thm_2.30"></a>
<b>Exercise 2.30.</b>  Define a procedure <tt>square-tree</tt> analogous to the <tt>square-list</tt>
procedure of exercise <a href="#%_thm_2.21">2.21</a>.  That is, <tt>square-list</tt> should behave as follows:
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.30.</b> ç·´ç¿’å•é¡Œ<a href="#%_thm_2.21">2.21</a>ã® <tt>square-list</tt> ã®æ‰‹ç¶šãã«é¡ä¼¼ã—ãŸã€<tt>square-tree</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’å®šç¾©ã›ã‚ˆã€‚ã¤ã¾ã‚Šã€<tt>square-tree</tt> ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«æŒ¯ã‚‹èˆã†ã¹ãã§ã‚ã‚‹ã€‚
<span class="note">(åŸæ–‡ã®ã€<tt>square-list</tt> should &hellip; ã¯èª¤è¨˜ã ã‚ã†ã€‚)</span>
</p>

<p class="lisp">(square-tree
 (list 1
       (list 2 (list 3 4) 5)
       (list 6 7)))
<i>(1 (4 (9 16) 25) (36 49))</i>
</p>

<p class="orig" lang="en">
Define <tt>square-tree</tt> both directly (i.e., without using any
higher-order procedures) and also by using <tt>map</tt> and recursion.
</p>

<p class="trans" lang="ja">
<tt>square-tree</tt> ã‚’ã€ç›´æ¥çš„ã« (ã¤ã¾ã‚Šã€é«˜éšæ‰‹ç¶šãã‚’ä½•ã‚‚ä½¿ã‚ãšã«) å®šç¾©ã™ã‚‹ã¨ã¨ã‚‚ã«ã€<tt>map</tt> ã¨å†å¸°ã‚’ä½¿ã£ã¦ã‚‚å®šç¾©ã›ã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_2.31"></a>
<b>Exercise 2.31.</b>  Abstract your answer to exercise <a href="#%_thm_2.30">2.30</a> to produce a
procedure <a name="%_idx_1712"></a><tt>tree-map</tt> with the property that <tt>square-tree</tt>
could be defined as
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.31.</b> <tt>square-tree</tt> ãŒä»¥ä¸‹ã®ã‚ˆã†ã«å®šç¾©ã§ããŸã§ã‚ã‚ã†ã€ã¨ã„ã†ç‰¹æ€§ã‚’æŒã£ãŸã€<tt>tree-map</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’ã€ç·´ç¿’å•é¡Œ<a href="#%_thm_2.30">2.30</a>ã«å¯¾ã™ã‚‹å›ã®ç­”ãˆã‚’æŠ½è±¡åŒ–ã—ã¦ä½œã‚Šå‡ºã›ã€‚
</p>

<p class="lisp">(define (square-tree tree) (tree-map square tree))
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_2.32"></a>
<b>Exercise 2.32.</b>  We can represent a <a name="%_idx_1714"></a>set as a list of distinct elements, and we can
represent the set of all subsets of the set as a list of lists.  For
example, if the set is <tt>(1 2 3)</tt>, then the set of all subsets is
<tt>(() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))</tt>.  Complete the
following definition of a procedure that generates the set of subsets
of a set and give a clear explanation of why it works:</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.32.</b> é›†åˆã¯ã€ç•°ãªã‚‹è¦ç´ ã®ãƒªã‚¹ãƒˆã¨ã—ã¦è¡¨ç¾ã™ã‚‹ã“ã¨ãŒã§ãã€ãã®é›†åˆã®ã™ã¹ã¦ã®éƒ¨åˆ†é›†åˆã®é›†åˆã¯ã€ãƒªã‚¹ãƒˆã®ãƒªã‚¹ãƒˆã¨ã—ã¦è¡¨ç¾ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
ãŸã¨ãˆã°ã€é›†åˆãŒ <tt>(1 2 3)</tt> ã®ã¨ãã€ã™ã¹ã¦ã®éƒ¨åˆ†é›†åˆã®é›†åˆã¯ã€
<tt>(() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))</tt>
ã§ã‚ã‚‹ã€‚
ã‚ã‚‹é›†åˆã®éƒ¨åˆ†é›†åˆã®é›†åˆã‚’ç”Ÿæˆã™ã‚‹æ‰‹ç¶šãã«ã¤ã„ã¦ã®ã€ä»¥ä¸‹ã®å®šç¾©ã‚’å®Œæˆã•ã›ã¦ã€ãªãœãã‚ŒãŒã†ã¾ãå‹•ãã®ã‹ã€æ˜ç¢ºã«èª¬æ˜ã›ã‚ˆã€‚
</p>

<p class="lisp"><a name="%_idx_1716"></a>(define (subsets s)
  (if (null? s)
      (list nil)
      (let ((rest (subsets (cdr s))))
        (append rest (map &lt;<em>??</em>&gt; rest)))))
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_2.2.3"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_2.2.3">2.2.3  Sequences as Conventional Interfaces</a></h3>
<h3 class="trans" lang="ja">2.2.3 å¾“æ¥ã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ã‚¤ã‚¹ã¨ã—ã¦ã®åˆ—</h3>

<p class="orig" lang="en">
<a name="%_idx_1718"></a><a name="%_idx_1720"></a>
In working with compound data, we've stressed how data abstraction
permits us to design programs without becoming enmeshed in the details
of data representations, and how abstraction preserves for us the
flexibility to experiment with alternative representations.  In this
section, we introduce another powerful design principle for working
with data structures -- the use of <em>conventional interfaces</em>.</p>

<p class="trans" lang="ja">
ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ã®ãŠã‹ã’ã§ã€ã©ã®ã‚ˆã†ã«ã—ã¦ã€ãƒ‡ãƒ¼ã‚¿è¡¨ç¾ã®è©³ç´°ã«æ¦ã‚æ•ã‚‰ã‚Œãšã«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’è¨­è¨ˆã§ãã‚‹ã‚ˆã†ã«ãªã‚‹ã‹ã€ã¨ã„ã†ã“ã¨ã€ãŠã‚ˆã³ã€æŠ½è±¡åŒ–ã®ãŠã‹ã’ã§ã€ã©ã®ã‚ˆã†ã«ã—ã¦ã€ä»£æ›¿è¡¨ç¾ã‚’ä½¿ã£ã¦å®Ÿé¨“ã™ã‚‹ãŸã‚ã®èé€šæ€§ãŒä¿ãŸã‚Œã‚‹ã‹ã€ã¨ã„ã†ã“ã¨ã‚’ã€ç§ãŸã¡ã¯ã€è¤‡åˆçš„ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ã£ã¦ä½œæ¥­ã™ã‚‹éš›ã«ã€å¼·èª¿ã—ã¦ããŸã€‚
æœ¬ç¯€ã§ã¯ã€ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’ä½¿ã£ã¦ä½œæ¥­ã™ã‚‹ãŸã‚ã®ã€ã‚‚ã†ä¸€ã¤ã®å¼·åŠ›ãªè¨­è¨ˆåŸç†â€”â€”ã¤ã¾ã‚Šã€<em>å¾“æ¥ã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ã‚¤ã‚¹</em>â€”â€”ã‚’å°å…¥ã™ã‚‹ã€‚
</p>

<p class="orig" lang="en">In section <a href="12_sec1_3.html#%_sec_1.3">1.3</a> we saw how program
abstractions, implemented as higher-order procedures, can capture
common patterns in programs that deal with numerical data.  Our
ability to formulate analogous operations for working with compound
data depends crucially on the style in which we manipulate our data
structures.  Consider, for example, the following procedure, analogous
to the <tt>count-leaves</tt> procedure of section <a href="#%_sec_2.2.2">2.2.2</a>, which
takes a tree as argument and computes the sum of the squares of the
leaves that are odd:</p>

<p class="trans" lang="ja">
ãƒ—ãƒ­ã‚°ãƒ©ãƒ æŠ½è±¡åŒ–â€”â€”é«˜éšæ‰‹ç¶šãã¨ã—ã¦å®Ÿè£…ã•ã‚Œã‚‹â€”â€”ãŒã€æ•°å€¤çš„ãƒ‡ãƒ¼ã‚¿ã‚’æ‰±ã†ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ä¸­ã®å…±é€šãƒ‘ã‚¿ãƒ³ã‚’ã€ã„ã‹ã«ã—ã¦æ•ã¾ãˆã‚‹ã“ã¨ãŒã§ãã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’ã€<a href="12_sec1_3.html#%_sec_1.3">1.3</a>ç¯€ã§è¦‹ãŸã€‚
è¤‡åˆçš„ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ã£ã¦ä½œæ¥­ã™ã‚‹ãŸã‚ã®é¡ä¼¼ã®æ¼”ç®—ã‚’å®šå¼åŒ–ã™ã‚‹èƒ½åŠ›ã¯ã€ç§ãŸã¡ãŒãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’æ“ä½œã™ã‚‹æµå„€ã«ã€éå¸¸ã«ä¾å­˜ã—ã¦ã„ã‚‹ã€‚
ãŸã¨ãˆã°ã€ä»¥ä¸‹ã®æ‰‹ç¶šãâ€”â€”<a href="#%_sec_2.2.2">2.2.2</a>ç¯€ã® <tt>count-leaves</tt> ã¨ã„ã†æ‰‹ç¶šãã«é¡ä¼¼ã—ã¦ã„ã‚‹â€”â€”ã‚’è€ƒãˆã‚ˆã†ã€‚ä»¥ä¸‹ã®æ‰‹ç¶šãã¯ã€å¼•æ•°ã¨ã—ã¦æœ¨ã‚’å–ã‚Šã€å¥‡æ•°ã§ã‚ã‚‹ã‚ˆã†ãªè‘‰ã®äºŒä¹—ã®å’Œã‚’è¨ˆç®—ã™ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_1722"></a>(define (sum-odd-squares tree)
  (cond ((null? tree) 0)  
        ((not (pair? tree))
         (if (odd? tree) (square tree) 0))
        (else (+ (sum-odd-squares (car tree))
                 (sum-odd-squares (cdr tree))))))
</p>

<p class="orig" lang="en">
On the surface, this procedure is very different from the following
one, which constructs a list of all the even Fibonacci numbers
 <em>F</em><em>i</em><em>b</em>(<em>k</em>), where <em>k</em> is less than or equal to a given integer <em>n</em>:</p>
 
<p class="trans" lang="ja">
è¡¨é¢ä¸Šã¯ã€ã“ã®æ‰‹ç¶šãã¯ã€ä»¥ä¸‹ã®æ‰‹ç¶šãâ€”â€”ã™ã¹ã¦ã®å¶æ•°ã®ãƒ•ã‚£ãƒœãƒŠãƒƒãƒæ•° 
<span class="math"><em class="en">Fib</em>(<em class="en">k</em>)</span> 
ã®ãƒªã‚¹ãƒˆã‚’æ§‹ç¯‰ã™ã‚‹â€”â€”ã¨ã¯å…¨ç„¶é•ã†ã€‚ãªãŠã“ã“ã§ã€<em class="en">k</em> ã¯ã€<em class="en">n</em> ã¨ã„ã†ä¸ãˆã‚‰ã‚ŒãŸæ•´æ•°ä»¥ä¸‹ã§ã‚ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_1724"></a>(define (even-fibs n)
  (define (next k)
    (if (&gt; k n)
        nil
        (let ((f (fib k)))
          (if (even? f)
              (cons f (next (+ k 1)))
              (next (+ k 1))))))
  (next 0))
</p>

<p class="orig" lang="en">
Despite the fact that these two procedures are structurally very
different, a more abstract description of the two computations reveals
a great deal of similarity.  The first program</p>

<p class="trans" lang="ja">
ã“ã‚Œã‚‰ã®äºŒã¤ã®æ‰‹ç¶šããŒæ§‹é€ ä¸Šã¯å…¨ç„¶é•ã†ã€ã¨ã„ã†äº‹å®Ÿã«ã‚‚ã‹ã‹ã‚ã‚‰ãšã€äºŒã¤ã®è¨ˆç®—ã«ã¤ã„ã¦ã®ã€ã‚ˆã‚ŠæŠ½è±¡çš„ãªèª¬æ˜ã«ã‚ˆã‚Šã€å¤šå¤§ãªã‚‹é¡ä¼¼æ€§ãŒæ˜ã‚‰ã‹ã«ã•ã‚Œã‚‹ã€‚
1ç•ªç›®ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€
</p>

<ul class="orig" lang="en">
<li>enumerates the leaves of a tree;</li>
<li>filters them, selecting the odd ones;</li>
<li>squares each of the selected ones; and</li>
<li>accumulates the results using <tt>+</tt>, starting with 0.</li>
</ul>

<ul class="trans" lang="ja">
<li>æœ¨ã®è‘‰ã‚’ä¸€ã¤ä¸€ã¤åˆ—æŒ™ã—ã€</li>
<li>ãã‚Œã‚‰ã‚’ãƒ•ã‚£ãƒ«ã‚¿ã«ã‹ã‘ã¦å–æ¨é¸æŠã—ã¦ã€å¥‡æ•°ã®ã‚‚ã®ã‚’é¸ã³ã€</li>
<li>é¸ã‚“ã ã‚‚ã®ã®ãã‚Œãã‚Œã‚’äºŒä¹—ã—ã€</li>
<li>0ã‹ã‚‰å§‹ã‚ã¦ã€<tt>+</tt> ã‚’ä½¿ã£ã¦çµæœã‚’ç´¯ç©ã™ã‚‹ã€‚</li>
</ul>

<p class="orig" lang="en">
The second program
</p>

<p class="trans" lang="ja">
2ç•ªç›®ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€
</p>

<ul class="orig" lang="en">
<li>enumerates the integers from 0 to <em>n</em>;</li>
<li>computes the Fibonacci number for each integer;</li>
<li>filters them, selecting the even ones; and</li>
<li>accumulates the results using <tt>cons</tt>,  starting with the
empty list.</li>
</ul>

<ul class="trans" lang="ja">
<li>0ã‹ã‚‰ <em class="en">n</em> ã¾ã§ã®æ•´æ•°ã‚’ä¸€ã¤ä¸€ã¤åˆ—æŒ™ã—ã€</li>
<li>å„æ•´æ•°ã«å¯¾ã—ã¦ãƒ•ã‚£ãƒœãƒŠãƒƒãƒæ•°ã‚’è¨ˆç®—ã—ã€</li>
<li>ãã‚Œã‚‰ã‚’ãƒ•ã‚£ãƒ«ã‚¿ã«ã‹ã‘ã¦å–æ¨é¸æŠã—ã¦ã€å¶æ•°ã®ã‚‚ã®ã‚’é¸ã³ã€</li>
<li>ç©ºãƒªã‚¹ãƒˆã‹ã‚‰å§‹ã‚ã¦ã€<tt>cons</tt> ã‚’ä½¿ã£ã¦çµæœã‚’ç´¯ç©ã™ã‚‹ã€‚</li>
</ul>

<p class="orig" lang="en"><a name="%_idx_1726"></a><a name="%_idx_1728"></a>A signal-processing engineer would find it natural to conceptualize
these processes in terms of signals flowing through a cascade of
stages, each of which implements part of the program plan, as shown in
figure <a href="#%_fig_2.7">2.7</a>.  In <tt>sum-odd-squares</tt>, we
begin with an <a name="%_idx_1730"></a><em>enumerator</em>, which generates a ``signal''
consisting of the leaves of a given tree.  This signal is passed
through a <a name="%_idx_1732"></a><em>filter</em>, which eliminates all but the odd elements.
The resulting signal is in turn passed through a <a name="%_idx_1734"></a><em>map</em>, which is a
``transducer'' that applies the <tt>square</tt> procedure to each
element.  The output of the map is then fed to an <a name="%_idx_1736"></a><em>accumulator</em>,
which combines the elements using <tt>+</tt>, starting from an initial 0.
The plan for <tt>even-fibs</tt> is analogous.</p>

<p class="trans" lang="ja">
ä¿¡å·å‡¦ç†ã®ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ãªã‚‰ã€ã“ã‚Œã‚‰ã®ãƒ—ãƒ­ã‚»ã‚¹ã‚’ã€æ¬¡ã€…ã¨ç”Ÿã˜ã‚‹æ®µéšã¨ã„ã†è¦³ç‚¹ã‹ã‚‰ã€æ¦‚å¿µåŒ–ã™ã‚‹ã“ã¨ãŒè‡ªç„¶ã ã¨æ€ã†ã ã‚ã†â€”â€”ãã‚Œã‚‰æ®µéšã®å„ã€…ã¯ã€å›³<a href="#%_fig_2.7">2.7</a>ã«ç¤ºã™ã‚ˆã†ã«ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ è¨ˆç”»ã®ä¸€éƒ¨ã‚’å®Ÿè£…ã™ã‚‹ã‚‚ã®ã§ã‚ã‚‹ã€‚
<tt>sum-odd-squares</tt>ã§ã¯ã€<em>åˆ—æŒ™å™¨</em>â€”â€”ä¸ãˆã‚‰ã‚ŒãŸæœ¨ã®è‘‰ã‹ã‚‰ãªã‚‹ã€Œä¿¡å·ã€ã‚’ç”Ÿæˆã™ã‚‹â€”â€”ã‹ã‚‰å§‹ã‚ã¦ã„ã‚‹ã€‚
ã“ã®ä¿¡å·ã¯ã€<em>ãƒ•ã‚£ãƒ«ã‚¿</em>â€”â€”å¥‡æ•°ã®è¦ç´ ä»¥å¤–ã®ã™ã¹ã¦ã‚’å‰Šé™¤ã™ã‚‹â€”â€”ã‚’ä»‹ã—ã¦ã€æ¸¡ã•ã‚Œã‚‹ã€‚
ãã®çµæœç”Ÿã˜ã‚‹ä¿¡å·ã¯ã€ä»Šåº¦ã¯ã€<em>ãƒãƒƒãƒ—</em>â€”â€”å„è¦ç´ ã«  <tt>square</tt> ã®æ‰‹ç¶šãã‚’é©ç”¨ã™ã‚‹ã€Œå¤‰æ›å™¨ã€ã§ã‚ã‚‹â€”â€”ã‚’ä»‹ã—ã¦ã€æ¸¡ã•ã‚Œã‚‹ã€‚
ãƒãƒƒãƒ—ã®å‡ºåŠ›ã¯ã€ãã‚Œã‹ã‚‰ã€<em>ç´¯ç©å™¨</em>â€”â€”æœ€åˆã®0ã‹ã‚‰å§‹ã‚ã¦ã€<tt>+</tt> ã‚’ä½¿ã£ã¦è¦ç´ ã‚’çµåˆã™ã‚‹â€”â€”ã¸ã¨æŠ•å…¥ã•ã‚Œã‚‹ã€‚
<tt>even-fibs</tt> ã«ã¤ã„ã¦ã®è¨ˆç”»ã‚‚é¡ä¼¼ã§ã‚ã‚‹ã€‚
</p>

<a name="%_fig_2.7"></a>
<figure>
<img src="ch2-Z-G-17.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 2.7:</b>  The signal-flow plans for the procedures <tt>sum-odd-squares</tt> (top) and <tt>even-fibs</tt> (bottom) reveal the
commonality between the two programs.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³2.7:</b> <tt>sum-odd-squares</tt> (ä¸Šæ®µ) ã¨ <tt>even-fibs</tt> (ä¸‹æ®µ) ã®æ‰‹ç¶šãã«ã¤ã„ã¦ã®ã€ä¿¡å·ã®æµã‚Œã‚’ç¤ºã™è¨ˆç”»å›³ãŒã€äºŒã¤ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®å…±é€šç‚¹ã‚’æ˜ã‚‰ã‹ã«ã™ã‚‹ã€‚</figcaption>
</figure>

<p class="orig" lang="en">Unfortunately, the two procedure definitions above fail to exhibit this
signal-flow structure.  For instance, if we examine the <tt>sum-odd-squares</tt> procedure, we find that the enumeration is
implemented partly by the <tt>null?</tt> and <tt>pair?</tt> tests and partly
by the tree-recursive structure of the procedure.  Similarly, the
accumulation is found partly in the tests and partly in the addition used
in the recursion.  In general, there are no distinct parts of either
procedure that correspond to the elements in the signal-flow
description.
Our two procedures decompose the computations in a different way,
spreading the enumeration over the program and mingling it with the
map, the filter, and the accumulation.  If we could organize our
programs to make the signal-flow structure manifest in the procedures
we write, this would increase the conceptual clarity of the resulting
code.</p>

<p class="trans" lang="ja">
ã‚ã„ã«ãã€ä¸Šè¨˜ã®äºŒã¤ã®æ‰‹ç¶šãå®šç¾©ã¯ã€ã“ã®ã‚ˆã†ãªä¿¡å·ã®æµã‚Œã®æ§‹é€ ã‚’ç¤ºã›ã¦ã„ãªã„ã€‚
ãŸã¨ãˆã°ã€<tt>sum-odd-squares</tt> ã®æ‰‹ç¶šãã‚’åŸå‘³ã™ã‚‹ã¨ã€åˆ—æŒ™ãŒã€éƒ¨åˆ†çš„ã«ã¯ã€<tt>null?</tt> ã¨ <tt>pair?</tt> ã®ãƒ†ã‚¹ãƒˆã«ã‚ˆã‚Šå®Ÿè£…ã•ã‚Œã¤ã¤ã€éƒ¨åˆ†çš„ã«ã¯ã€æ‰‹ç¶šãã«ãŠã‘ã‚‹ã€æœ¨ã«é–¢ã™ã‚‹å†å¸°çš„æ§‹é€ ã«ã‚ˆã‚Šå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ã€ã¨ã„ã†ã“ã¨ã«æ°—ã¥ãã€‚
åŒæ§˜ã«ã€ç´¯ç©ã¯ã€éƒ¨åˆ†çš„ã«ã¯ã€ã“ã‚Œã‚‰ã®ãƒ†ã‚¹ãƒˆã®ä¸­ã«è¦‹ã¤ã‹ã‚Šã€éƒ¨åˆ†çš„ã«ã¯ã€å†å¸°ã®ä¸­ã§ä½¿ã‚ã‚Œã‚‹åŠ ç®—ã®ä¸­ã«è¦‹ã¤ã‹ã‚‹ã€‚
å…¨èˆ¬çš„ã«ã€ã©ã¡ã‚‰ã®æ‰‹ç¶šãã«ã‚‚ã€ä¿¡å·ã®æµã‚Œã®èª¬æ˜ã®ä¸­ã®è¦ç´ ã«å¯¾å¿œã™ã‚‹ã‚ˆã†ãªã€æ˜ç­ãªéƒ¨åˆ†ã¯ãªã„ã€‚
ç§ãŸã¡ã®äºŒã¤ã®æ‰‹ç¶šãã¯ã€ç•°ãªã‚‹æ–¹æ³•ã§è¨ˆç®—ã‚’åˆ†è§£ã™ã‚‹â€”â€”åˆ—æŒ™ã‚’ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ å…¨ä½“ã«æ’’ãæ•£ã‚‰ã—ã¦ã€ãƒãƒƒãƒ—ã¨ãƒ•ã‚£ãƒ«ã‚¿ã¨ç´¯ç©ã«æ··ãœåˆã‚ã›ã‚‹ã®ã ã€‚
ã‚‚ã—ã€ç§ãŸã¡ã®æ›¸ãæ‰‹ç¶šãã«ãŠã„ã¦ã€ä¿¡å·ã®æµã‚Œã®æ§‹é€ ã‚’æ˜ç™½ã«ã™ã‚‹ã‚ˆã†ã«ã€ç§ãŸã¡ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ç³»çµ±ç«‹ã¦ã‚‹ã“ã¨ãŒã§ããŸãªã‚‰ã€ã“ã‚Œã«ã‚ˆã‚Šã€çµæœã¨ã—ã¦ç”Ÿã˜ã‚‹ã‚³ãƒ¼ãƒ‰ã®æ¦‚å¿µçš„ãªæ˜æ™°ã•ãŒå¢—ã—ã¦ã„ãŸã ã‚ã†ã€‚
</p>

<a name="%_sec_Temp_181"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_181">Sequence Operations</a></h4>
<h4 class="trans" lang="ja">åˆ—æ¼”ç®—</h4>

<p class="orig" lang="en">
<a name="%_idx_1738"></a>
The key to organizing programs so as to more clearly reflect the
signal-flow structure is to concentrate on the ``signals'' that flow
from one stage in the process to the next.  If we represent these
signals as lists, then we can use list operations to implement the
processing at each of the stages.  For instance, we can implement the
mapping stages of the signal-flow diagrams using the <tt>map</tt>
procedure from section <a href="#%_sec_2.2.1">2.2.1</a>:
</p>

<p class="trans" lang="ja">
ä¿¡å·ã®æµã‚Œã®æ§‹é€ ã‚’ã‚ˆã‚Šæ˜ç­ã«åæ˜ ã™ã‚‹ã‚ˆã†ã«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ç³»çµ±ç«‹ã¦ã‚‹ãŸã‚ã®éµã¯ã€ãƒ—ãƒ­ã‚»ã‚¹å†…ã®ä¸€ã¤ã®æ®µéšã‹ã‚‰æ¬¡ã®æ®µéšã¸ã¨æµã‚Œã‚‹ã€Œä¿¡å·ã€ã«é›†ä¸­ã™ã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚
ã‚‚ã—ã“ã‚Œã‚‰ã®ä¿¡å·ã‚’ãƒªã‚¹ãƒˆã¨ã—ã¦è¡¨ç¾ã™ã‚‹ãªã‚‰ã€å„æ®µéšã§ã®å‡¦ç†ã‚’å®Ÿè£…ã™ã‚‹ã®ã«ãƒªã‚¹ãƒˆæ¼”ç®—ã‚’ä½¿ã†ã“ã¨ãŒã§ãã‚‹ã€‚
ãŸã¨ãˆã°ã€ä¿¡å·ã®æµã‚Œã®å›³ã«ãŠã‘ã‚‹å†™åƒã®æ®µéšã‚’ã€<a href="#%_sec_2.2.1">2.2.1</a>ç¯€ã‹ã‚‰ã® <tt>map</tt> ã®æ‰‹ç¶šãã‚’ç”¨ã„ã¦ã€å®Ÿè£…ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
</p>

<p class="lisp">(map square (list 1 2 3 4 5))
<i>(1 4 9 16 25)</i>
</p>

<p class="orig" lang="en">Filtering a sequence to select only those elements that satisfy a
given predicate is accomplished by
</p>

<p class="trans" lang="ja">
ä¸ãˆã‚‰ã‚ŒãŸè¿°èªã‚’æº€ãŸã™ã‚ˆã†ãªè¦ç´ ã®ã¿ã‚’é¸ã¶ãŸã‚ã«åˆ—ã‚’ãƒ•ã‚£ãƒ«ã‚¿ã«ã‹ã‘ã‚‹ã“ã¨ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¦é”æˆã•ã‚Œã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_1740"></a>(define (filter predicate sequence)
  (cond ((null? sequence) nil)
        ((predicate (car sequence))
         (cons (car sequence)
               (filter predicate (cdr sequence))))
        (else (filter predicate (cdr sequence)))))
</p>

<p class="orig" lang="en">
For example,</p>

<p class="trans" lang="ja">
ãŸã¨ãˆã°ã€ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚
</p>

<p class="lisp">(filter odd? (list 1 2 3 4 5))
<i>(1 3 5)</i>
</p>


<p class="orig" lang="en">Accumulations can be implemented by</p>

<p class="trans" lang="ja">
ç´¯ç©ã¯ã€ä»¥ä¸‹ã«ã‚ˆã‚Šå®Ÿè£…ã§ãã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_1742"></a>(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))
(accumulate + 0 (list 1 2 3 4 5))
<i>15</i>
(accumulate * 1 (list 1 2 3 4 5))
<i>120</i>
(accumulate cons nil (list 1 2 3 4 5))
<i>(1 2 3 4 5)</i>
</p>

<p class="orig" lang="en">
All that remains to implement signal-flow diagrams is to enumerate the
sequence of elements to be processed.  For <tt>even-fibs</tt>, we need to
generate the sequence of
integers in a given range, which we can do as follows:</p>

<p class="trans" lang="ja">
ä¿¡å·ã®æµã‚Œã®å›³ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã«ã¾ã æ®‹ã£ã¦ã„ã‚‹ã‚‚ã®ã¯ã€å‡¦ç†ã™ã¹ãè¦ç´ ã®åˆ—ã‚’ä¸€ã¤ä¸€ã¤åˆ—æŒ™ã™ã‚‹ã“ã¨ã ã‘ã ã€‚
<tt>even-fibs</tt> ã«ã¤ã„ã¦ã¯ã€ä¸ãˆã‚‰ã‚ŒãŸç¯„å›²å†…ã®æ•´æ•°ã®åˆ—ã‚’ç”Ÿæˆã™ã‚‹å¿…è¦ãŒã‚ã‚‹ãŒã€ä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¦ã“ã‚Œã‚’è¡Œã†ã“ã¨ãŒå¯èƒ½ã ã€‚
</p>

<p class="lisp"><a name="%_idx_1744"></a>(define (enumerate-interval low high)
  (if (&gt; low high)
      nil
      (cons low (enumerate-interval (+ low 1) high))))
(enumerate-interval 2 7)
<i>(2 3 4 5 6 7)</i>
</p>

<p class="orig" lang="en">
To enumerate the leaves of a tree, we can use<a name="call_footnote_Temp_182" href="#footnote_Temp_182"><sup><small>14</small></sup></a></p>

<p class="trans" lang="ja">
æœ¨ã®è‘‰ã‚’åˆ—æŒ™ã™ã‚‹ãŸã‚ã«ã¯ã€ä»¥ä¸‹ã®ã‚‚ã®ã‚’åˆ©ç”¨ã§ãã‚‹<a href="#footnote_Temp_182"><sup><small>14</small></sup></a>ã€‚
</p>

<p class="lisp"><a name="%_idx_1748"></a><a name="%_idx_1750"></a>(define (enumerate-tree tree)
  (cond ((null? tree) nil)
        ((not (pair? tree)) (list tree))
        (else (append (enumerate-tree (car tree))
                      (enumerate-tree (cdr tree))))))
(enumerate-tree (list 1 (list 2 (list 3 4)) 5))
<i>(1 2 3 4 5)</i>
</p>

<p class="orig" lang="en">Now we can reformulate <tt>sum-odd-squares</tt> and <tt>even-fibs</tt> as in
the signal-flow diagrams.  For <tt>sum-odd-squares</tt>, we enumerate the
sequence of leaves of the tree, filter this to keep only the odd
numbers in the sequence, square each element, and sum the results:
</p>

<p class="trans" lang="ja">
ã•ã¦ä»Šã‚„ç§ãŸã¡ã¯ã€<tt>sum-odd-squares</tt> ã¨ <tt>even-fibs</tt> ã‚’ã€ä¿¡å·ã®æµã‚Œã®å›³ã«ã‚ã‚‹ã‚ˆã†ã«å†å®šå¼åŒ–ã§ãã‚‹ã€‚
<tt>sum-odd-squares</tt> ã«ã¤ã„ã¦ã¯ã€æœ¨ã®è‘‰ã®åˆ—ã‚’åˆ—æŒ™ã—ã€ã“ã‚Œã‚’ãƒ•ã‚£ãƒ«ã‚¿ã«ã‹ã‘ã¦å¥‡æ•°ã®ã¿ã‚’åˆ—ã®ä¸­ã«ä¿æŒã—ã€å„è¦ç´ ã‚’äºŒä¹—ã—ã€ãã®çµæœã‚’åˆè¨ˆã™ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_1752"></a>(define (sum-odd-squares tree)
  (accumulate +
              0
              (map square
                   (filter odd?
                           (enumerate-tree tree)))))
</p>

<p class="orig" lang="en">
For <tt>even-fibs</tt>, we enumerate the integers from 0 to <em>n</em>, generate
the Fibonacci number for each of these integers, filter the resulting
sequence to keep only the even elements, and accumulate the results
into a list:
</p>

<p class="trans" lang="ja">
<tt>even-fibs</tt> ã«ã¤ã„ã¦ã¯ã€0ã‹ã‚‰ <em class="en">n</em> ã¾ã§ã®æ•´æ•°ã‚’åˆ—æŒ™ã—ã€ã“ã‚Œã‚‰ã®æ•´æ•°ãã‚Œãã‚Œã«å¯¾ã—ã¦ãƒ•ã‚£ãƒœãƒŠãƒƒãƒæ•°ã‚’ç”Ÿæˆã—ã€ãã®çµæœç”Ÿã˜ã‚‹åˆ—ã‚’ãƒ•ã‚£ãƒ«ã‚¿ã«ã‹ã‘ã¦å¶æ•°ã®è¦ç´ ã®ã¿ã‚’ä¿æŒã—ã€ãã®çµæœã‚’ãƒªã‚¹ãƒˆã«ç´¯ç©ã™ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_1754"></a>(define (even-fibs n)
  (accumulate cons
              nil
              (filter even?
                      (map fib
                           (enumerate-interval 0 n)))))
</p>

<p class="orig" lang="en">
The value of expressing programs as sequence operations is that this
helps us make program designs that are modular, that is, designs that
are constructed by combining relatively independent pieces.  We can
encourage modular design by providing a library of standard components
together with a conventional interface for connecting the components
in flexible ways.</p>

<p class="trans" lang="ja">
åˆ—æ¼”ç®—ã¨ã—ã¦ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’è¡¨ç¾ã™ã‚‹ã“ã¨ã®ä¾¡å€¤ã¯ã€ã“ã†ã™ã‚‹ã“ã¨ãŒã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ€§ã®ã‚ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ è¨­è¨ˆå›³â€”â€”ã¤ã¾ã‚Šã€æ¯”è¼ƒçš„ç‹¬ç«‹ã—ãŸéƒ¨åˆ†åŒå£«ã‚’çµåˆã™ã‚‹ã“ã¨ã§æ§‹ç¯‰ã•ã‚Œã‚‹è¨­è¨ˆå›³â€”â€”ã‚’ä½œã‚‹ã†ãˆã§åŠ©ã‘ã¨ãªã‚‹ã€ã¨ã„ã†ç‚¹ã§ã‚ã‚‹ã€‚
æ¨™æº–çš„ãªæ§‹æˆè¦ç´ ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ã€æ§‹æˆè¦ç´ åŒå£«ã‚’æŸ”è»Ÿãªæ–¹æ³•ã§çµã³ã¤ã‘ã‚‹ãŸã‚ã®å¾“æ¥ã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ã‚¤ã‚¹ã¨ä¸€ç·’ã«ä¾›çµ¦ã™ã‚‹ã“ã¨ã§ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ€§ã®ã‚ã‚‹è¨­è¨ˆã‚’ä¿ƒé€²ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="%_idx_1756"></a><a name="%_idx_1758"></a>Modular construction is a powerful strategy for
controlling complexity in engineering design.  In real
signal-processing applications, for example, designers regularly build
systems by cascading elements selected from standardized families of
filters and transducers.  Similarly, sequence operations provide a
library of standard program elements that we can mix and match.  For
instance, we can reuse pieces from the <tt>sum-odd-squares</tt> and <tt>even-fibs</tt> procedures in a program that constructs a list of the
squares of the first <em>n</em> + 1 Fibonacci numbers:
</p>

<p class="trans" lang="ja">
ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ–¹å¼ã®æ§‹ç¯‰ã¯ã€å·¥å­¦çš„ãªè¨­è¨ˆã«ãŠã‘ã‚‹è¤‡é›‘ã•ã‚’æŠ‘åˆ¶ã™ã‚‹ãŸã‚ã®ã€å¼·åŠ›ãªæˆ¦ç•¥ã§ã‚ã‚‹ã€‚
ç¾å®Ÿã®ä¿¡å·å‡¦ç†ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ã¯ã€ãŸã¨ãˆã°ã€ã—ã°ã—ã°è¨­è¨ˆè€…ãŸã¡ã¯ã€ä¸€ç¾¤ã®æ¨™æº–åŒ–ã•ã‚ŒãŸãƒ•ã‚£ãƒ«ã‚¿ã¨å¤‰æ›å™¨ã®ä¸­ã‹ã‚‰é¸ã‚“ã è¦ç´ åŒå£«ã‚’é †ã€…ã«ã¤ãªãã“ã¨ã§ã€ã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰ã™ã‚‹ã€‚
åŒæ§˜ã«ã€åˆ—æ¼”ç®—ã¯ã€ç•°ãªã‚‹ã‚‚ã®åŒå£«ã‚’ã†ã¾ãçµ„ã¿åˆã‚ã›ã‚‰ã‚Œã‚‹ã‚ˆã†ãªæ¨™æº–çš„ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ è¦ç´ ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’æä¾›ã™ã‚‹ã€‚
ãŸã¨ãˆã°ã€æœ€åˆã® 
<span class="math"><em class="en">n</em> + 1</span> 
å€‹ã®ãƒ•ã‚£ãƒœãƒŠãƒƒãƒæ•°ã®äºŒä¹—ã®ãƒªã‚¹ãƒˆã‚’æ§‹ç¯‰ã™ã‚‹ã‚ˆã†ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ãŠã„ã¦ã€ç§ãŸã¡ã¯ã€<tt>sum-odd-squares</tt> ã¨ <tt>even-fibs</tt> ã®æ‰‹ç¶šãã®ä¸€éƒ¨åˆ†ã‚’ä½¿ã„ã¾ã‚ã›ã‚‹ã€‚
</p>

<p class="lisp">(define (list-fib-squares n)
  (accumulate cons
              nil
              (map square
                   (map fib
                        (enumerate-interval 0 n)))))
(list-fib-squares 10)
<i>(0 1 1 4 9 25 64 169 441 1156 3025)</i>
</p>

<p class="orig" lang="en" id="err03">
We can rearrange the pieces and use them in computing the product of
the odd integers in a sequence:</p>

<p class="trans" lang="ja">
ä¸Šè¨˜ã®ä¸€éƒ¨åˆ†ã‚’é…ç½®ã—ãªãŠã—ã¦ã€ãã‚Œã‚‰ã‚’ã€åˆ—ã®ä¸­ã®å¥‡æ•°ã®æ•´æ•°ã®ç©ã‚’è¨ˆç®—ã™ã‚‹ã®ã«ç”¨ã„ã‚‹ã“ã¨ã‚‚ã§ãã‚‹ã€‚
</p>

<p class="lisp">(define (product-of-squares-of-odd-elements sequence)
  (accumulate *
              1
              (map square
                   (filter odd? sequence))))
(product-of-squares-of-odd-elements (list 1 2 3 4 5))
<i>225</i>
</p>

<p class="orig" lang="en">We can also formulate conventional data-processing applications in
terms of sequence operations.  Suppose we have a sequence of personnel
records and we want to find the salary of the highest-paid programmer.
Assume that we have a selector <tt>salary</tt> that returns the salary of
a record, and a predicate <tt>programmer?</tt> that tests if a record is
for a programmer.  Then we can write</p>

<p class="trans" lang="ja">
å¾“æ¥ã®ãƒ‡ãƒ¼ã‚¿å‡¦ç†ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ã€åˆ—æ¼”ç®—ã®è¦³ç‚¹ã‹ã‚‰å®šå¼åŒ–ã™ã‚‹ã“ã¨ã‚‚ã§ãã‚‹ã€‚
äººäº‹è¨˜éŒ²ã®åˆ—ãŒã‚ã‚‹ã‚‚ã®ã¨ã—ã¦ã€ä¸€ç•ªé«˜çµ¦å–ã‚Šã®ãƒ—ãƒ­ã‚°ãƒ©ãƒã®çµ¦æ–™ã‚’è¦‹ã¤ã‘ãŸã„ã‚‚ã®ã¨ã—ã‚ˆã†ã€‚
è¨˜éŒ²ã®ã†ã¡ã®çµ¦æ–™ã‚’è¿”ã™ã€<tt>salary</tt> ã¨ã„ã†ã‚»ãƒ¬ã‚¯ã‚¿ã¨ã€è¨˜éŒ²ãŒãƒ—ãƒ­ã‚°ãƒ©ãƒã®ã‚‚ã®ã‹ã©ã†ã‹ã‚’ãƒ†ã‚¹ãƒˆã™ã‚‹ã€<tt>programmer?</tt> ã¨ã„ã†è¿°èªãŒã‚ã‚‹ã‚‚ã®ã¨æƒ³å®šã—ã‚ˆã†ã€‚
ã™ã‚‹ã¨ã€ä»¥ä¸‹ã®ã‚ˆã†ã«æ›¸ã‘ã‚‹ã€‚
</p>

<p class="lisp">(define (salary-of-highest-paid-programmer records)
  (accumulate max
              0
              (map salary
                   (filter programmer? records))))
</p>

<p class="orig" lang="en">
These examples give just a hint of the vast range of operations that
can be expressed as sequence operations.<a name="call_footnote_Temp_183" href="#footnote_Temp_183"><sup><small>15</small></sup></a></p>

<p class="trans" lang="ja">
ã“ã‚Œã‚‰ã®ä¾‹ã¯ã€åˆ—æ¼”ç®—ã¨ã—ã¦è¡¨ç¾ã§ãã‚‹ã€ã¨ã¦ã‚‚åºƒã„ç¯„å›²ã®æ¼”ç®—ã®ã†ã¡ã®ã€ã»ã‚“ã®ã‚ãšã‹ãªã‚‚ã®ã‚’ç¤ºã—ã¦ã„ã‚‹ã ã‘ã§ã‚ã‚‹<a href="#footnote_Temp_183"><sup><small>15</small></sup></a>ã€‚
</p>

<p class="orig" lang="en">Sequences, implemented here as lists, serve
as a conventional interface that permits us to combine processing
modules.  Additionally, when we uniformly represent structures as
sequences, we have localized the data-structure dependencies in our
programs to a small number of sequence operations.  By changing these,
we can experiment with alternative representations of sequences, while
leaving the overall design of our programs intact.  We will exploit
this capability in section <a href="24_sec3_5.html#%_sec_3.5">3.5</a>, when we generalize the
sequence-processing paradigm to admit infinite sequences.</p>

<p class="trans" lang="ja">
åˆ—â€”â€”ã“ã“ã§ã¯ãƒªã‚¹ãƒˆã¨ã—ã¦å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹â€”â€”ã¯ã€å‡¦ç†ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åŒå£«ã‚’çµåˆã™ã‚‹ã“ã¨ã‚’å¯èƒ½ã«ã—ã¦ãã‚Œã‚‹ã‚ˆã†ãªå¾“æ¥ã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ã‚¤ã‚¹ã¨ã—ã¦ã€æ©Ÿèƒ½ã™ã‚‹ã€‚
ã•ã‚‰ã«ã€è«¸æ§‹é€ ã‚’ä¸€æ§˜ã«åˆ—ã¨ã—ã¦è¡¨ç¾ã™ã‚‹å ´åˆã«ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ãŠã‘ã‚‹ãƒ‡ãƒ¼ã‚¿æ§‹é€ ä¾å­˜æ€§ã‚’ã€å°‘æ•°ã®åˆ—æ¼”ç®—ã ã‘ã«å±€é™ã—ãŸã€‚
ã“ã‚Œã‚‰ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ã§ã€ç§ãŸã¡ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®å…¨ä½“çš„ãªè¨­è¨ˆã¯å…ƒã®ã¾ã¾ã«ã—ã¦ãŠãã¤ã¤ã‚‚ã€åˆ—ã®ä»£æ›¿è¡¨ç¾ã‚’ä½¿ã£ã¦å®Ÿé¨“ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
ã“ã®èƒ½åŠ›ã¯ã€<a href="24_sec3_5.html#%_sec_3.5">3.5</a>ç¯€ã§åˆ—å‡¦ç†ã®ãƒãƒ©ãƒ€ã‚¤ãƒ ã‚’ä¸€èˆ¬åŒ–ã—ã¦ç„¡é™ã®åˆ—ã‚’èªã‚ã‚‹ã¨ãã«ã€æ´»ç”¨ã™ã‚‹ã“ã¨ã«ã—ã‚ˆã†ã€‚
</p>

<p class="orig" lang="en"><a name="%_thm_2.33"></a>
<b>Exercise 2.33.</b>  Fill in the missing expressions to complete the following definitions
of some basic list-manipulation operations as accumulations:</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.33.</b> æ¬ ã‘ã¦ã„ã‚‹å¼ã‚’åŸ‹ã‚ã¦ã€ç´¯ç©å‹•ä½œã¨ã—ã¦ã®ã€ã„ãã¤ã‹ã®åŸºæœ¬çš„ãªãƒªã‚¹ãƒˆæ“ä½œæ¼”ç®—ã«ã¤ã„ã¦ã®ã€ä»¥ä¸‹ã®å®šç¾©ã‚’å®Œæˆã•ã›ã‚ˆã€‚
</p>

<p class="lisp"><a name="%_idx_1766"></a>(define (map p sequence)
  (accumulate (lambda (x y) &lt;<em>??</em>&gt;) nil sequence))
<a name="%_idx_1768"></a>(define (append seq1 seq2)
  (accumulate cons &lt;<em>??</em>&gt; &lt;<em>??</em>&gt;))
<a name="%_idx_1770"></a>(define (length sequence)
  (accumulate &lt;<em>??</em>&gt; 0 sequence))
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_2.34"></a>
<b>Exercise 2.34.</b>  <a name="%_idx_1772"></a>Evaluating a polynomial in <em>x</em> at a given value of <em>x</em> can be
formulated as an accumulation.  We evaluate the polynomial</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.34</b> <em class="en">x</em> ã«ã¤ã„ã¦ã®å¤šé …å¼ã‚’ã€ä¸ãˆã‚‰ã‚ŒãŸ <em class="en">x</em> ã®å€¤ã«ãŠã„ã¦è©•ä¾¡ã™ã‚‹ã“ã¨ã¯ã€ç´¯ç©ã¨ã—ã¦å®šå¼åŒ–ã§ãã‚‹ã€‚ä»¥ä¸‹ã®å¼ã‚’è©•ä¾¡ã™ã‚‹ã®ã«ã€
</p>

<figure><img src="ch2-Z-G-18.gif" border="0"></figure>

<p class="orig" lang="en">
using a well-known algorithm called <a name="%_idx_1774"></a><em>Horner's rule</em>, which
structures the computation as
</p>

<p class="trans" lang="ja">
<em>ãƒ›ãƒ¼ãƒŠã®æ³•å‰‡</em>ã¨å‘¼ã°ã‚Œã‚‹å‘¨çŸ¥ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ â€”â€”è¨ˆç®—ã‚’ä»¥ä¸‹ã®ã‚ˆã†ã«çµ„ç¹”ç«‹ã¦ã‚‹â€”â€”ã‚’ä½¿ã†ã€‚
</p>

<figure><img src="ch2-Z-G-19.gif" border="0"></figure>

<p class="orig" lang="en">
In other words, we start with <em>a</em><sub><em>n</em></sub>, multiply by <em>x</em>, add <em>a</em><sub><em>n</em>-1</sub>,
multiply by <em>x</em>, and so on, until we reach <em>a</em><sub>0</sub>.<a name="call_footnote_Temp_186" href="#footnote_Temp_186"><sup><small>16</small></sup></a>
Fill in the following template to produce a procedure that evaluates a
polynomial using Horner's rule.
Assume that the coefficients of the
polynomial are arranged in a sequence, from <em>a</em><sub>0</sub> through <em>a</em><sub><em>n</em></sub>.</p>

<p class="trans" lang="ja">
æ›è¨€ã™ã‚Œã°ã€<em class="en">a<sub>n</sub></em> ã‹ã‚‰å§‹ã‚ã¦ã€<em class="en">x</em> ã‚’æ›ã‘ã€<em class="en">a</em><sub><em class="en">n</em>&minus;1</sub> ã‚’è¶³ã—ã€<em class="en">x</em> ã‚’æ›ã‘ã€ãªã©ã¨ã—ã¦ã„ã£ã¦ã€<em class="en">a</em><sub>0</sub> ã«åˆ°é”ã™ã‚‹ã¾ã§ç¶šã‘ã‚‹ã®ã <a href="#footnote_Temp_186"><sup><small>16</small></sup></a>ã€‚
ä»¥ä¸‹ã®é››å‹ã‚’åŸ‹ã‚ã¦ã€ãƒ›ãƒ¼ãƒŠã®æ³•å‰‡ã‚’ç”¨ã„ã¦å¤šé …å¼ã‚’è©•ä¾¡ã™ã‚‹ã‚ˆã†ãªæ‰‹ç¶šãã‚’ä½œã‚Šå‡ºã›ã€‚
å¤šé …å¼ã®ä¿‚æ•°ãŒã€ <em class="en">a</em><sub>0</sub> ã‹ã‚‰ <em class="en">a</em><sub><em class="en">n</em></sub> ã¾ã§ã®åˆ—ã®å½¢ã§ç”¨æ„ã•ã‚Œã¦ã„ã‚‹ã‚‚ã®ã¨ã›ã‚ˆã€‚
</p>

<p class="lisp">(define (horner-eval x coefficient-sequence)
  (accumulate (lambda (this-coeff higher-terms) &lt;<em>??</em>&gt;)
              0
              coefficient-sequence))
</p>

<p class="orig" lang="en">
For example, to compute 1 + 3<em>x</em> + 5<em>x</em><sup>3</sup> + <em>x</em><sup>5</sup> at <em>x</em> = 2 you would evaluate</p>

<p class="trans" lang="ja">
ãŸã¨ãˆã°ã€
<span class="math"><em class="en">x</em> = 2</span>
ã«ãŠã„ã¦
<span class="math">1 + 3<em class="en">x</em> + 5<em class="en">x</em><sup>3</sup> + <em class="en">x</em><sup>5</sup></span>
ã‚’è¨ˆç®—ã™ã‚‹ã«ã¯ã€ä»¥ä¸‹ã‚’è©•ä¾¡ã™ã‚‹ã€‚
</p>

<p class="lisp">(horner-eval 2 (list 1 3 0 5 0 1))
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_2.35"></a>
<b>Exercise 2.35.</b>  Redefine <tt>count-leaves</tt> from section <a href="#%_sec_2.2.2">2.2.2</a> as an
accumulation:</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.35.</b> ç¯€<a href="#%_sec_2.2.2">2.2.2</a>ã® <tt>count-leaves</tt> ã‚’ã€ç´¯ç©ã¨ã—ã¦å†å®šç¾©ã›ã‚ˆã€‚
</p>

<p class="lisp"><a name="%_idx_1792"></a>(define (count-leaves t)
  (accumulate &lt;<em>??</em>&gt; &lt;<em>??</em>&gt; (map &lt;<em>??</em>&gt; &lt;<em>??</em>&gt;)))
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_2.36"></a>
<b>Exercise 2.36.</b>  The procedure <tt>accumulate-n</tt> is similar to <tt>accumulate</tt> except
that it takes as its third argument a sequence of sequences, which are all
assumed to have the same number of elements.  It applies the
designated accumulation procedure to combine all the first elements of
the sequences, all the second elements of the sequences, and so on, and
returns a sequence of the results.  For instance, if <tt>s</tt> is a sequence
containing four sequences, <tt>((1 2 3) (4 5 6) (7 8 9) (10 11 12)),</tt>
then the value of <tt>(accumulate-n + 0 s)</tt> should be the sequence <tt>(22 26 30)</tt>.  Fill in the missing expressions
in the following definition of <tt>accumulate-n</tt>:</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.36.</b> <tt>accumulate-n</tt> ã¨ã„ã†æ‰‹ç¶šãã¯ã€åˆ—â€”â€”ã©ã®åˆ—ã‚‚åŒæ•°ã®è¦ç´ ã‚’æœ‰ã™ã‚‹ã‚‚ã®ã¨æƒ³å®šã•ã‚Œã¦ã„ã‚‹â€”â€”ã®åˆ—ã‚’ã€3ç•ªç›®ã®å¼•æ•°ã¨ã—ã¦å–ã‚‹ã“ã¨ä»¥å¤–ã¯ã€<tt>accumulate</tt> ã«ä¼¼ã¦ã„ã‚‹ã€‚
<tt>accumulate-n</tt> ã¨ã„ã†æ‰‹ç¶šãã¯ã€æŒ‡å®šã•ã‚ŒãŸç´¯ç©æ‰‹ç¶šãã‚’é©ç”¨ã—ã¦ã€ãã‚Œã‚‰ã®åˆ—ã®1ç•ªç›®ã®è¦ç´ ã™ã¹ã¦ã‚’çµåˆã—ã€ãã‚Œã‚‰ã®åˆ—ã®2ç•ªç›®ã®è¦ç´ ã™ã¹ã¦ã‚’çµåˆã—ã€ãªã©ã¨ã—ã¦ã„ãã€ãã—ã¦ã€ãã®çµæœã®åˆ—ã‚’è¿”ã™ã€‚
ãŸã¨ãˆã°ã€<tt>s</tt> ãŒã€å››ã¤ã®åˆ—ã‚’å«ã‚€ <tt>((1 2 3) (4 5 6) (7 8 9) (10 11 12))</tt> ã¨ã„ã†åˆ—ã§ã‚ã‚‹ã¨ãã€
<tt>(accumulate-n + 0 s)</tt>
ã®å€¤ã¯ã€
<tt>(22 26 30)</tt>
ã¨ã„ã†åˆ—ã«ãªã‚‹ã¹ãã§ã‚ã‚‹ã€‚
ä»¥ä¸‹ã® <tt>accumulate-n</tt> ã®å®šç¾©ä¸­ã®æ¬ ã‘ã¦ã„ã‚‹å¼ã‚’åŸ‹ã‚ã‚ˆã€‚
</p>

<p class="lisp"><a name="%_idx_1794"></a>(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      nil
      (cons (accumulate op init &lt;<em>??</em>&gt;)
            (accumulate-n op init &lt;<em>??</em>&gt;))))
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_2.37"></a>
<b>Exercise 2.37.</b>  <a name="%_idx_1796"></a><a name="%_idx_1798"></a><a name="%_idx_1800"></a>Suppose we represent vectors <em>v</em> = (<em>v</em><sub><em>i</em></sub>) as sequences of numbers, and
matrices <em>m</em> = (<em>m</em><sub><em>i</em><em>j</em></sub>) as sequences of vectors (the rows of the matrix).
For example, the matrix</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.37.</b> <span class="math"><em class="en">v</em> = (<em class="en">v</em><sub><em class="en">i</em></sub>)</span>
ãªã‚‹ãƒ™ã‚¯ãƒˆãƒ«ã‚’ã€æ•°ã®åˆ—ã¨ã—ã¦è¡¨ç¾ã™ã‚‹ã‚‚ã®ã¨ã—ã€
<span class="math"><em class="en">m</em> = (<em class="en">m<sub>ij</sub></em>)</span>
ãªã‚‹è¡Œåˆ—ã‚’ã€ãƒ™ã‚¯ãƒˆãƒ« (è¡Œåˆ—ã®è¡Œ) ã®åˆ—ã¨ã—ã¦è¡¨ç¾ã™ã‚‹ã‚‚ã®ã¨ã™ã‚‹ã€‚
ãŸã¨ãˆã°ã€ä»¥ä¸‹ã®è¡Œåˆ—ã¯ã€
</p>

<figure><div align=left><img src="ch2-Z-G-20.gif" border="0"></figure>

<p class="orig" lang="en">
is represented as the sequence <tt>((1 2 3 4) (4 5 6 6) (6 7 8 9))</tt>.
With this representation, we can use sequence operations to concisely
express the basic matrix and vector operations.  These operations
(which are described in any book on matrix algebra) are the following:</p>

<p class="trans" lang="ja">
<tt>((1 2 3 4) (4 5 6 6) (6 7 8 9))</tt>
ã¨ã„ã†åˆ—ã¨ã—ã¦è¡¨ç¾ã•ã‚Œã‚‹ã€‚
ã“ã®è¡¨ç¾ã‚’ä½¿ã†ã¨ã€åˆ—æ¼”ç®—ã‚’ç”¨ã„ã¦ã€åŸºæœ¬çš„ãªè¡Œåˆ—ã¨ãƒ™ã‚¯ãƒˆãƒ«ã®æ¼”ç®—ã‚’ç°¡æ½”ã«è¡¨ã™ã“ã¨ãŒã§ãã‚‹ã€‚
ã“ã‚Œã‚‰ã®æ¼”ç®— (è¡Œåˆ—ä»£æ•°ã«ã¤ã„ã¦ã®ã©ã‚“ãªæœ¬ã§ã‚‚èª¬æ˜ã•ã‚Œã¦ã„ã‚‹) ã¨ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ãªã‚‚ã®ã§ã‚ã‚‹ã€‚
</p>

<figure><img src="ch2-Z-G-21.gif" border="0"></figure>

<p class="orig" lang="en">We can define the dot product as<a name="call_footnote_Temp_190" href="#footnote_Temp_190"><sup><small>17</small></sup></a></p>

<p class="trans" lang="ja">
å†…ç©ã‚’æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã§ãã‚‹<a href="#footnote_Temp_190"><sup><small>17</small></sup></a>ã€‚
</p>

<p class="lisp"><a name="%_idx_1802"></a>(define (dot-product v w)
  (accumulate + 0 (map * v w)))
</p>

<p class="orig" lang="en">
Fill in the missing expressions in the following procedures for
computing the other matrix operations.  (The procedure <tt>accumulate-n</tt> is
defined in exercise <a href="#%_thm_2.36">2.36</a>.)</p>

<p class="trans" lang="ja">
æ®‹ã‚Šã®è¡Œåˆ—æ¼”ç®—ã‚’è¨ˆç®—ã™ã‚‹ãŸã‚ã®ã€ä»¥ä¸‹ã®æ‰‹ç¶šãã®ä¸­ã®ã€æ¬ ã‘ã¦ã„ã‚‹å¼ã‚’åŸ‹ã‚ã‚ˆã€‚
(<tt>accumulate-n</tt> ã¨ã„ã†æ‰‹ç¶šãã¯ã€ç·´ç¿’å•é¡Œ<a href="#%_thm_2.36">2.36</a>ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã€‚)
</p>

<p class="lisp"><a name="%_idx_1804"></a>(define (matrix-*-vector m v)
  (map &lt;<em>??</em>&gt; m))
<a name="%_idx_1806"></a>(define (transpose mat)
  (accumulate-n &lt;<em>??</em>&gt; &lt;<em>??</em>&gt; mat))
<a name="%_idx_1808"></a>(define (matrix-*-matrix m n)
  (let ((cols (transpose n)))
    (map &lt;<em>??</em>&gt; m)))
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_2.38"></a>
<b>Exercise 2.38.</b>  <a name="%_idx_1810"></a><a name="%_idx_1812"></a>The <tt>accumulate</tt> procedure is also known as <tt>fold-right</tt>,
because it combines the first element of the sequence with the result
of combining all the elements to the right.  There is also a <tt>fold-left</tt>, which is 
similar to <tt>fold-right</tt>, except
that it combines elements working in the opposite direction:</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.38.</b> <tt>accumulate</tt> ã®æ‰‹ç¶šãã¯ã€<tt>fold-right</tt> ã¨ã—ã¦ã‚‚çŸ¥ã‚‰ã‚Œã‚‹ã€‚ã¨ã„ã†ã®ã‚‚ã€ã“ã‚Œã¯ã€åˆ—ã®æœ€åˆã®è¦ç´ ã‚’ã€å³å´ã®ã™ã¹ã¦ã®è¦ç´ ã‚’çµåˆã—ãŸçµæœã«ã€çµåˆã™ã‚‹ã‹ã‚‰ã§ã‚ã‚‹ã€‚
<tt>fold-left</tt> ã‚‚ã‚ã£ã¦ã€ã“ã‚Œã¯ã€é€†æ–¹å‘ã«ã¯ãŸã‚‰ã„ã¦è¦ç´ ã‚’çµåˆã™ã‚‹ç‚¹ã‚’é™¤ã„ã¦ã¯ã€<tt>fold-right</tt> ã«ä¼¼ã¦ã„ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_1814"></a>(define (fold-left op initial sequence)
  (define (iter result rest)
    (if (null? rest)
        result
        (iter (op result (car rest))
              (cdr rest))))
  (iter initial sequence))
</p>

<p class="orig" lang="en">
What are the values of</p>

<p class="trans" lang="ja">
ä»¥ä¸‹ã®ã‚‚ã®ã®å€¤ã¯ã€ã©ã®ã‚ˆã†ãªã‚‚ã®ã ã‚ã†ã‹?
</p>

<p class="lisp">(fold-right / 1 (list 1 2 3))
(fold-left / 1 (list 1 2 3))
(fold-right list nil (list 1 2 3))
(fold-left list nil (list 1 2 3))
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
Give a property that <tt>op</tt> should satisfy to guarantee that <tt>fold-right</tt> and <tt>fold-left</tt> will produce the same values for any
sequence.
</p>

<p class="trans" lang="ja">
<tt>fold-right</tt> ã¨ <tt>fold-left</tt> ãŒä»»æ„ã®åˆ—ã«å¯¾ã—ã¦åŒã˜å€¤ã‚’ä½œã‚Šå‡ºã™ã ã‚ã†ã€ã¨ä¿è¨¼ã™ã‚‹ãŸã‚ã«ã€<tt>op</tt> ãŒæº€ãŸã™ã¹ãæ€§è³ªã‚’è¿°ã¹ã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_2.39"></a>
<b>Exercise 2.39.</b>  
Complete the following definitions of <tt>reverse</tt>
<a name="%_idx_1816"></a>(exercise <a href="#%_thm_2.18">2.18</a>) in terms of <tt>fold-right</tt> and <tt>fold-left</tt> from exercise <a href="#%_thm_2.38">2.38</a>:</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.39.</b> ç·´ç¿’å•é¡Œ<a href="#%_thm_2.38">2.38</a>ã® <tt>fold-right</tt> ã¨ <tt>fold-left</tt> ã‚’ç”¨ã„ãŸã€ä»¥ä¸‹ã® <tt>reverse</tt> (ç·´ç¿’å•é¡Œ<a href="#%_thm_2.18">2.18</a>) ã®å®šç¾©ã‚’ã€å®Œæˆã•ã›ã‚ˆã€‚
</p>

<p class="lisp">(define (reverse sequence)
  (fold-right (lambda (x y) &lt;<em>??</em>&gt;) nil sequence))
(define (reverse sequence)
  (fold-left (lambda (x y) &lt;<em>??</em>&gt;) nil sequence))
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_Temp_193"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_193">Nested Mappings</a></h4>
<h4 class="trans" lang="ja">å…¥ã‚Œå­ã«ãªã£ãŸå†™åƒ</h4>

<p class="orig" lang="en">
<a name="%_idx_1818"></a>
We can extend the sequence paradigm to include many
computations that are commonly expressed using nested loops.<a name="call_footnote_Temp_194" href="#footnote_Temp_194"><sup><small>18</small></sup></a>
Consider
this problem: Given a positive integer <em>n</em>, find all ordered pairs of
distinct positive integers <em>i</em> and <em>j</em>, where 1<u>&lt;</u> <em>j</em>&lt; <em>i</em><u>&lt;</u> <em>n</em>, such
that <em>i</em>  + <em>j</em> is prime.  For example, if <em>n</em> is 6, then the pairs are
the following:
</p>

<p class="trans" lang="ja">
ä¸€èˆ¬ã«ã¯ã€å…¥ã‚Œå­ã«ãªã£ãŸãƒ«ãƒ¼ãƒ—ã‚’ç”¨ã„ã¦è¡¨ã•ã‚Œã‚‹ã‚ˆã†ãªã€å¤šãã®è¨ˆç®—ã‚’å«ã‚€ã‚ˆã†ã«ã€åˆ—ãƒ‘ãƒ©ãƒ€ã‚¤ãƒ ã‚’æ‹¡å¼µã§ãã‚‹<a href="#footnote_Temp_194"><sup><small>18</small></sup></a>ã€‚
æ¬¡ã®å•é¡Œã‚’è€ƒãˆã‚ˆã†ã€‚
<em class="en">n</em> ã¨ã„ã†æ­£ã®æ•´æ•°ãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãã€
<span class="math">1 &le; <em class="en">j</em> &le; <em class="en">i</em> &le; <em class="en">n</em></span>
ã ã¨ã—ã¦ã€
<span class="math"><em class="en">i</em>  + <em class="en">j</em></span>
ãŒç´ æ•°ã¨ãªã‚‹ã‚ˆã†ãªã€ç›¸ç•°ãªã‚‹æ­£ã®æ•´æ•° <em class="en">i</em> ã¨ <em class="en">j</em> ã®ã€ã™ã¹ã¦ã®é †åºä»˜ãã®å¯¾ã‚’è¦‹ã¤ã‘å‡ºã›ã€‚
ãŸã¨ãˆã°ã€<em class="en">n</em> ãŒ6ã®ã¨ãã€ãã®ã‚ˆã†ãªå¯¾ã¨ã¯ã€ä»¥ä¸‹ã®ã¨ãŠã‚Šã®ã‚‚ã®ã§ã‚ã‚‹ã€‚
</p>

<figure><img src="ch2-Z-G-22.gif" border="0"></figure>

<p class="orig" lang="en">
A natural way to organize this computation is to generate the sequence
of all ordered pairs of positive integers less than or equal to <em>n</em>,
filter to select those pairs whose sum is prime, and
then, for each pair (<em>i</em>, <em>j</em>) that passes through the filter, produce the triple
(<em>i</em>,<em>j</em>,<em>i</em> + <em>j</em>).</p>

<p class="trans" lang="ja">
ã“ã®è¨ˆç®—ã‚’çµ„ç¹”ç«‹ã¦ã‚‹è‡ªç„¶ãªæ–¹æ³•ã¯ã€<em class="en">n</em> ä»¥ä¸‹ã®æ­£æ•´æ•°åŒå£«ã®ã™ã¹ã¦ã®é †åºä»˜ãã®å¯¾ã®åˆ—ã‚’ç”Ÿæˆã—ã€ãã®å¯¾ã®å’ŒãŒç´ æ•°ã§ã‚ã‚‹ã‚ˆã†ãªå¯¾ã‚’é¸æŠã™ã‚‹ã‚ˆã†ã«ãƒ•ã‚£ãƒ«ã‚¿ã«ã‹ã‘ã€ãã‚Œã‹ã‚‰ã€ãƒ•ã‚£ãƒ«ã‚¿ã‚’é€šéã—ãŸå„ã€…ã®å¯¾
<span class="math">(<em class="en">i</em>, <em class="en">j</em>)</span>
ã«å¯¾ã—ã¦ã€
<span class="math">(<em class="en">i</em>, <em class="en">j</em>, <em class="en">i</em> + <em class="en">j</em>)</span>
ã¨ã„ã†ä¸‰ã¤çµ„ã‚’ä½œã‚Šå‡ºã™ã“ã¨ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">Here is a way to generate the sequence of pairs: For each integer
<em>i</em><u>&lt;</u> <em>n</em>, enumerate the integers <em>j</em>&lt;<em>i</em>, and for each such <em>i</em> and <em>j</em>
generate the pair (<em>i</em>,<em>j</em>).  In terms of sequence operations, we map
along the sequence <tt>(enumerate-interval 1 n)</tt>.  For each <em>i</em> in
this sequence, we map along the sequence <tt>(enumerate-interval 1 (-
i 1))</tt>.  For each <em>j</em> in this latter sequence, we generate the pair
<tt>(list i j)</tt>.  This gives us a sequence of pairs for each <em>i</em>.
Combining all the sequences for all the <em>i</em> (by accumulating with <tt>append</tt>) produces the required sequence of pairs:<a name="call_footnote_Temp_195" href="#footnote_Temp_195"><sup><small>19</small></sup></a></p>

<p class="trans" lang="ja">
ã“ã“ã«ã€å¯¾ã®åˆ—ã‚’ç”Ÿæˆã™ã‚‹æ–¹æ³•ãŒã‚ã‚‹ã€‚
<span class="math"><em class="en">i</em> &le; <em class="en">n</em></span>
ãªã‚‹å„æ•´æ•° <em class="en">i</em> ã«å¯¾ã—ã¦ã€
<span class="math"><em class="en">j</em> &lt; <em class="en">i</em></span>
ãªã‚‹æ•´æ•° <em class="en">j</em> ã‚’åˆ—æŒ™ã—ã€
ãã®ã‚ˆã†ãªãã‚Œãã‚Œã® <em class="en">i</em> ã¨ <em class="en">j</em> ã«å¯¾ã—ã¦ã€
<span class="math">(<em class="en">i</em>, <em class="en">j</em>)</span>
ã¨ã„ã†å¯¾ã‚’ç”Ÿæˆã™ã‚‹ã®ã§ã‚ã‚‹ã€‚
åˆ—æ¼”ç®—ã®è¦³ç‚¹ã‹ã‚‰è¨€ã†ã¨ã€
<tt>(enumerate-interval 1 n)</tt>
ã¨ã„ã†åˆ—ã«æ²¿ã£ã¦å†™åƒã‚’è¡Œã†ã‚ã‘ã ã€‚
ã“ã®åˆ—ã®ä¸­ã®å„ <em class="en">i</em> ã«å¯¾ã—ã¦ã€
<tt>(enumerate-interval 1 (- i 1))</tt>
ã¨ã„ã†åˆ—ã«æ²¿ã£ã¦å†™åƒã‚’è¡Œã†ã€‚
ã“ã®å¾Œè€…ã®åˆ—ã®ä¸­ã®å„ <em class="en">j</em> ã«å¯¾ã—ã¦ã€
<tt>(list i j)</tt>
ã¨ã„ã†å¯¾ã‚’ç”Ÿæˆã™ã‚‹ã€‚
ã“ã‚Œã«ã‚ˆã‚Šã€å„ <em class="en">i</em> ã«å¯¾ã™ã‚‹å¯¾ã®åˆ—ãŒä¸ãˆã‚‰ã‚Œã‚‹ã€‚
ã™ã¹ã¦ã® <em class="en">i</em> ã«ã¤ã„ã¦ã®åˆ—ã‚’ã€(<tt>append</tt> ã‚’ç”¨ã„ã¦ç´¯ç©ã™ã‚‹ã“ã¨ã«ã‚ˆã‚Š) çµåˆã™ã‚‹ã¨ã€å¿…è¦ãªå¯¾ã®åˆ—ãŒã§ãã‚ãŒã‚‹<a href="#footnote_Temp_195"><sup><small>19</small></sup></a>ã€‚
</p>

<p class="lisp">(accumulate append
            nil
            (map (lambda (i)
                   (map (lambda (j) (list i j))
                        (enumerate-interval 1 (- i 1))))
                 (enumerate-interval 1 n)))
</p>

<p class="orig" lang="en">
The combination of mapping and accumulating with <tt>append</tt> is so common in this
sort of program that we will isolate it as a separate procedure:</p>

<p class="trans" lang="ja">
å†™åƒã¨ã€<tt>append</tt> ã‚’ä½¿ã£ãŸç´¯ç©ã¨ã®çµ„ã¿åˆã‚ã›ã¯ã€ã“ã®ç¨®ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã¯ã¨ã¦ã‚‚ä¸€èˆ¬çš„ãªã®ã§ã€ã“ã®çµ„ã¿åˆã‚ã›ã‚’å˜ç‹¬ã®æ‰‹ç¶šãã¨ã—ã¦åˆ†é›¢ã—ã‚ˆã†ã€‚
</p>

<p class="lisp"><a name="%_idx_1826"></a>(define (flatmap proc seq)
  (accumulate append nil (map proc seq)))
</p>

<p class="orig" lang="en">
Now filter this sequence of pairs to find those whose sum is prime. The
filter predicate is called for each element of the sequence; its
argument is a pair and it must extract the integers from the pair.
Thus, the predicate to apply to each element in the sequence is</p>

<p class="trans" lang="ja">
ã•ã¦ã€ã“ã®å¯¾ã®åˆ—ã‚’ãƒ•ã‚£ãƒ«ã‚¿ã«ã‹ã‘ã¦ã€å’ŒãŒç´ æ•°ã§ã‚ã‚‹ã‚ˆã†ãªå¯¾ã‚’è¦‹ã¤ã‘å‡ºãã†ã€‚
ãƒ•ã‚£ãƒ«ã‚¿è¿°èªã¯ã€åˆ—ã®å„è¦ç´ ã«å¯¾ã—ã¦å‘¼ã°ã‚Œã‚‹ã€‚ãã®å¼•æ•°ã¯å¯¾ã§ã‚ã‚Šã€ãƒ•ã‚£ãƒ«ã‚¿è¿°èªã¯ã€ãã®å¯¾ã‹ã‚‰æ•´æ•°ã‚’æŠ½å‡ºã—ãªãã¦ã¯ãªã‚‰ãªã„ã€‚
ã‚ˆã£ã¦ã€åˆ—ã®å„è¦ç´ ã«é©ç”¨ã™ã¹ãè¿°èªã¯ã€ä»¥ä¸‹ã®ã¨ãŠã‚Šã§ã‚ã‚‹ã€‚
</p>

<p class="lisp">(define (prime-sum? pair)
  (prime? (+ (car pair) (cadr pair))))
</p>

<p class="orig" lang="en">
Finally, generate the sequence of results by mapping over the filtered
pairs using the following procedure, which constructs a triple
consisting of the two elements of the pair along with their sum:</p>

<p class="trans" lang="ja">
æœ€å¾Œã«ã€ãƒ•ã‚£ãƒ«ã‚¿ã«ã‹ã‘ãŸå¾Œã®å¯¾ã®ã™ã¹ã¦ã«ã‚ãŸã£ã¦ã€ä»¥ä¸‹ã®æ‰‹ç¶šãâ€”â€”ãã®å¯¾ã®äºŒã¤ã®è¦ç´ ã¨ã€ãã‚Œã‚‰è¦ç´ åŒå£«ã®å’Œã‹ã‚‰ãªã‚‹ä¸‰ã¤çµ„ã‚’æ§‹ç¯‰ã™ã‚‹â€”â€”ã‚’ä½¿ã£ã¦å†™åƒã‚’è¡Œã†ã“ã¨ã«ã‚ˆã‚Šã€å¾—ã‚‰ã‚ŒãŸçµæœã®åˆ—ã‚’ã€ç”Ÿæˆã™ã‚‹ã€‚
</p>

<p class="lisp">(define (make-pair-sum pair)
  (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))
</p>

<p class="orig" lang="en">
Combining all these steps yields the complete procedure:</p>

<p class="trans" lang="ja">
ã“ã‚Œã‚‰ã™ã¹ã¦ã®ã‚¹ãƒ†ãƒƒãƒ—ã‚’çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ã§ã€å®Œå…¨ãªæ‰‹ç¶šããŒç”Ÿã¿å‡ºã•ã‚Œã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_1828"></a>(define (prime-sum-pairs n)
  (map make-pair-sum
       (filter prime-sum?
               (flatmap
                (lambda (i)
                  (map (lambda (j) (list i j))
                       (enumerate-interval 1 (- i 1))))
                (enumerate-interval 1 n)))))
</p>

<p class="orig" lang="en">Nested mappings are also useful for sequences other than those that
enumerate intervals.  Suppose we wish to generate all the <a name="%_idx_1830"></a><a name="%_idx_1832"></a>permutations
of a set <em>S</em>; that is, all the ways of ordering the items in
the set.  For instance, the permutations of {1,2,3} are
{1,2,3}, { 1,3,2}, {2,1,3}, { 2,3,1}, { 3,1,2}, and
{ 3,2,1}.  Here is a plan for generating the permutations of <em>S</em>:
For each item <em>x</em> in <em>S</em>, recursively generate the sequence of
permutations of <em>S</em> - <em>x</em>,<a name="call_footnote_Temp_196" href="#footnote_Temp_196"><sup><small>20</small></sup></a> and adjoin
<em>x</em> to the front of each one.  This yields, for each <em>x</em> in <em>S</em>, the sequence
of permutations of <em>S</em> that begin with <em>x</em>.  Combining these
sequences for all <em>x</em> gives all the permutations of <em>S</em>:<a name="call_footnote_Temp_197" href="#footnote_Temp_197"><sup><small>21</small></sup></a></p>

<p class="trans" lang="ja">
åŒºé–“ã§åˆ—æŒ™ã‚’è¡Œã†ã‚‚ã®ä»¥å¤–ã®åˆ—ã«ã¤ã„ã¦ã‚‚ã€å…¥ã‚Œå­ã«ãªã£ãŸå†™åƒã¯æœ‰ç”¨ã§ã‚ã‚‹ã€‚
<em class="en">S</em> ã¨ã„ã†é›†åˆã®ã™ã¹ã¦ã®é †åˆ—â€”â€”ã¤ã¾ã‚Šã€ã“ã®é›†åˆå†…ã®é …ç›®ã‚’é †åºä»˜ã‘ã¦ä¸¦ã¹ã‚‹ã™ã¹ã¦ã®æ–¹æ³•â€”â€”ã‚’ç”Ÿæˆã—ãŸã„ã®ã ã¨ã—ã‚ˆã†ã€‚
ãŸã¨ãˆã°ã€
<span class="math">{1,2,3}</span>
ã®é †åˆ—ã¯ã€
<span class="math">(1,2,3}</span> ã¨
<span class="math">{1,3,2}</span> ã¨
<span class="math">{2,1,3}</span> ã¨
<span class="math">{2,3,1}</span> ã¨
<span class="math">{3,1,2}</span> ã¨
<span class="math">{3,2,1}</span>
ã§ã‚ã‚‹ã€‚
ã“ã“ã«ã€<em class="en">S</em> ã®é †åˆ—ã‚’ç”Ÿæˆã™ã‚‹è¨ˆç”»ãŒã‚ã‚‹ã€‚
<em class="en">S</em> ã®ä¸­ã®å„è¦ç´  <em class="en">x</em> ã«å¯¾ã—ã¦ã€
<span class="math"><em class="en">S</em> &minus; <em class="en">x</em></span>
ã®é †åˆ—ã®åˆ—ã‚’å†å¸°çš„ã«ç”Ÿæˆã—<a href="#footnote_Temp_196"><sup><small>20</small></sup></a>ã€ãã®ãã‚Œãã‚Œã®å…ˆé ­ã« <em class="en">x</em> ã‚’é€£çµã™ã‚‹ã€‚
ã“ã‚Œã«ã‚ˆã‚Šã€<em class="en">S</em> ã®ä¸­ã®å„ <em class="en">x</em> ã«å¯¾ã—ã¦ã€<em class="en">x</em> ã‹ã‚‰å§‹ã¾ã‚‹ã‚ˆã†ãª <em class="en">S</em> ã®é †åˆ—ã®åˆ—ãŒç”Ÿã¿å‡ºã•ã‚Œã‚‹ã€‚
ã™ã¹ã¦ã® <em class="en">x</em> ã«ã¤ã„ã¦ã®ã“ã‚Œã‚‰ã®åˆ—ã‚’çµåˆã™ã‚‹ã“ã¨ã§ã€<em class="en">S</em> ã®ã™ã¹ã¦ã®é †åˆ—ãŒä¸ãˆã‚‰ã‚Œã‚‹<a href="#footnote_Temp_197"><sup><small>21</small></sup></a>ã€‚
</p>

<p class="lisp"><a name="%_idx_1840"></a>(define (permutations s)
  (if (null? s)                    <em>; empty set?</em>
      (list nil)                   <em>; sequence containing empty set</em>
      (flatmap (lambda (x)
                 (map (lambda (p) (cons x p))
                      (permutations (remove x s))))
               s)))
</p>

<p class="orig" lang="en">
Notice how this strategy reduces the problem of generating
permutations of <em>S</em> to the problem of generating the permutations of
sets with fewer elements than <em>S</em>.  In the terminal case, we work our
way down to the empty list, which represents a set of no elements.
For this, we generate <tt>(list nil)</tt>, which is a sequence with one
item, namely the set with no elements.  The <tt>remove</tt> procedure
used in <tt>permutations</tt> returns all the items in a given sequence
except for a given item.  This can be expressed as a simple filter:
</p>

<p class="trans" lang="ja">
ã©ã®ã‚ˆã†ã«ã—ã¦ã“ã®æˆ¦ç•¥ãŒã€<em class="en">S</em> ã®é †åˆ—ã‚’ç”Ÿæˆã™ã‚‹ã¨ã„ã†å•é¡Œã‚’ã€<em class="en">S</em> ã‚ˆã‚Šå°‘ãªã„è¦ç´ ã‹ã‚‰ãªã‚‹é›†åˆã®é †åˆ—ã‚’ç”Ÿæˆã™ã‚‹ã¨ã„ã†å•é¡Œã¸ã¨å¸°ç€ã•ã›ã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã«æ³¨æ„ã›ã‚ˆã€‚
çµ‚ç«¯ã¨ãªã‚‹å ´åˆã«ãŠã„ã¦ã€ãªã‚“ã¨ã‹ç©ºãƒªã‚¹ãƒˆâ€”â€”è¦ç´ ã‚’æŒãŸãªã„é›†åˆã‚’è¡¨ã™â€”â€”ã«ãŸã©ã‚Šã¤ãã€‚
ã“ã‚Œã®ãŸã‚ã«ã€<tt>(list nil)</tt>â€”â€”ä¸€ã¤ã®é …ç›®ã‚’æœ‰ã™ã‚‹åˆ—ã€ã™ãªã‚ã¡ã€è¦ç´ ã‚’æŒãŸãªã„é›†åˆâ€”â€”ã‚’ç”Ÿæˆã™ã‚‹ã€‚
<tt>permutations</tt> ã®ä¸­ã§ä½¿ã‚ã‚Œã¦ã„ã‚‹ <tt>remove</tt> ã¨ã„ã†æ‰‹ç¶šãã¯ã€ä¸ãˆã‚‰ã‚ŒãŸåˆ—ã®ä¸­ã®ã€ä¸ãˆã‚‰ã‚ŒãŸé …ç›®ä»¥å¤–ã®ã™ã¹ã¦ã®é …ç›®ã‚’è¿”ã™ã€‚
ã“ã‚Œã¯ã€å˜ç´”ãªãƒ•ã‚£ãƒ«ã‚¿ã¨ã—ã¦è¡¨ã›ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_1842"></a>(define (remove item sequence)
  (filter (lambda (x) (not (= x item)))
          sequence))
</p>

<p class="orig" lang="en"><a name="%_thm_2.40"></a>
<b>Exercise 2.40.</b>  Define a procedure <a name="%_idx_1844"></a><tt>unique-pairs</tt> that, given an integer <em>n</em>,
generates the sequence of pairs (<em>i</em>,<em>j</em>) with 1<u>&lt;</u> <em>j</em>&lt; <em>i</em><u>&lt;</u> <em>n</em>.  Use <tt>unique-pairs</tt> to simplify the definition of <tt>prime-sum-pairs</tt>
given above.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.40.</b> <em class="en">n</em> ã¨ã„ã†æ•´æ•°ãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãã«ã€
<span class="math">1 &le; <em class="en">j</em> &lt; <em class="en">i</em> &le; <em class="en">n</em></span>
ã‚’æº€ãŸã™ã‚ˆã†ãªã€
<span class="math">(<em class="en">i</em>,<em class="en">j</em>)</span>
ã¨ã„ã†å¯¾ã®åˆ—ã‚’ç”Ÿæˆã™ã‚‹ã€<tt>unique-pairs</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’ã€å®šç¾©ã›ã‚ˆã€‚
<tt>unique-pairs</tt> ã‚’ä½¿ã£ã¦ã€ä¸Šè¨˜ã® <tt>prime-sum-pairs</tt> ã®å®šç¾©ã‚’ç°¡å˜åŒ–ã›ã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_2.41"></a>
<b>Exercise 2.41.</b>  Write a procedure to find all ordered
triples of distinct positive integers <em>i</em>, <em>j</em>, and <em>k</em> less than or
equal to a given integer <em>n</em> that sum to a given integer <em>s</em>.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.41.</b> åˆè¨ˆãŒã€ä¸ãˆã‚‰ã‚ŒãŸ <em class="en">s</em> ã¨ã„ã†æ•´æ•°ã«ãªã‚‹ã‚ˆã†ãªã€<em class="en">i</em>ã€<em class="en">j</em>ã€<em class="en">k</em> ã¨ã„ã†ã€ç›¸ç•°ãªã‚‹ã€ä¸ãˆã‚‰ã‚ŒãŸ <em class="en">n</em> ã¨ã„ã†æ•´æ•°ä»¥ä¸‹ã®ã€æ­£ã®æ•´æ•°ã®ã€ã™ã¹ã¦ã®é †åºä»˜ãä¸‰ã¤çµ„ã‚’ã€è¦‹ã¤ã‘ã‚‹æ‰‹ç¶šãã‚’æ›¸ã‘ã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_2.42"></a>
<b>Exercise 2.42.</b>
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.42.</b> 
</p>

<figure>
<a name="%_fig_2.8"></a>
<img src="ch2-Z-G-23.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 2.8:</b>  A solution to the eight-queens puzzle.</figcaption>
<figcaption class="trans" lang="ja">ã‚¨ã‚¤ãƒˆã‚¯ã‚¤ãƒ¼ãƒ³å•é¡Œã®è§£</figcaption>
</figure>

<p class="orig" lang="en">
The <a name="%_idx_1846"></a><a name="%_idx_1848"></a><a name="%_idx_1850"></a>``eight-queens puzzle'' asks how to place eight queens on a
chessboard so that no queen is in check from any other (i.e., no two
queens are in the same row, column, or diagonal).  One possible
solution is shown in figure <a href="#%_fig_2.8">2.8</a>.  One way to solve the
puzzle is to work across the board, placing a queen in each column.
Once we have placed <em>k</em> - 1 queens, we must place the <em>k</em>th queen in a
position where it does not check any of the queens already on the
board.  We can formulate this approach recursively: Assume that we
have already generated the sequence of all possible ways to place
<em>k</em> - 1 queens in the first <em>k</em> - 1 columns of the board.  For each of
these ways, generate an extended set of positions by placing a queen
in each row of the <em>k</em>th column.  Now filter these, keeping only
the positions for which the queen in the <em>k</em>th column is safe with
respect to the other queens.  This produces the sequence of all ways
to place <em>k</em> queens in the first <em>k</em> columns.  By continuing this
process, we will produce not only one solution, but all solutions to
the puzzle.</p>

<p class="trans" lang="ja">
ã€Œã‚¨ã‚¤ãƒˆã‚¯ã‚¤ãƒ¼ãƒ³ãƒ»ãƒ‘ã‚ºãƒ«ã€ã¯ã€ä»–ã®ã„ãšã‚Œã‹ã®ã‚¯ã‚¤ãƒ¼ãƒ³ã‹ã‚‰ç‹æ‰‹ã‚’ã‹ã‘ã‚‰ã‚Œã¦ã„ã‚‹ã‚¯ã‚¤ãƒ¼ãƒ³ãŒãªã„ã‚ˆã†ã« (ã¤ã¾ã‚Šã€ã©ã®äºŒã¤ã®ã‚¯ã‚¤ãƒ¼ãƒ³ã‚‚ã€åŒã˜è¡Œã€åŒã˜åˆ—ã€ã¾ãŸã¯åŒã˜æ–œç·šä¸Šã«ã¯ãªã„ã‚ˆã†ã«)ã€å…«ã¤ã®ã‚¯ã‚¤ãƒ¼ãƒ³ã‚’ãƒã‚§ã‚¹ç›¤ä¸Šã«é…ç½®ã™ã‚‹æ–¹æ³•ã‚’å•ã†ã‚‚ã®ã§ã‚ã‚‹ã€‚
ä¸€ã¤ã®å¯èƒ½ãªè§£ãŒã€å›³<a href="#%_fig_2.8">2.8</a>ã«ç¤ºã•ã‚Œã¦ã„ã‚‹ã€‚
ã“ã®ãƒ‘ã‚ºãƒ«ã‚’è§£ããŸã‚ã®ä¸€ã¤ã®æ–¹æ³•ã¯ã€å„åˆ—ã«ã‚¯ã‚¤ãƒ¼ãƒ³ã‚’é…ç½®ã—ãªãŒã‚‰ã€ç›¤å…¨ä½“ã«ã‚ãŸã£ã¦ä½œæ¥­ã™ã‚‹ã“ã¨ã ã€‚
ä¸€æ—¦ã€<span class="math"><em class="en">k</em> &minus; 1</span> å€‹ã®ã‚¯ã‚¤ãƒ¼ãƒ³ã‚’é…ç½®ã—ãŸã‚‰ã€æ—¢ã«ç›¤ä¸Šã«ã‚ã‚‹ã©ã®ã‚¯ã‚¤ãƒ¼ãƒ³ã«ã‚‚ç‹æ‰‹ã‚’ã‹ã‘ãªã„ã‚ˆã†ãªä½ç½®ã«ã€<em class="en">k</em> ç•ªç›®ã®ã‚¯ã‚¤ãƒ¼ãƒ³ã‚’é…ç½®ã—ãªãã¦ã¯ãªã‚‰ãªã„ã€‚
ã“ã®å–ã‚Šçµ„ã¿æ–¹ã‚’ã€å†å¸°çš„ã«å®šå¼åŒ–ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
<span class="math"><em class="en">k</em> &minus; 1</span> å€‹ã®ã‚¯ã‚¤ãƒ¼ãƒ³ã‚’ã€ç›¤ã®æœ€åˆã®
<span class="math"><em class="en">k</em> &minus; 1</span> åˆ—ã«é…ç½®ã™ã‚‹ãŸã‚ã®ã€ã™ã¹ã¦ã®å¯èƒ½ãªæ–¹æ³•ã®åˆ—ã‚’ã€æ—¢ã«ç”Ÿæˆã—ã¦ã‚ã‚‹ã‚‚ã®ã¨ã™ã‚‹ã€‚
ã“ã‚Œã‚‰ã®æ–¹æ³•ã®å„ã€…ã«å¯¾ã—ã¦ã€<em class="en">k</em> ç•ªç›®ã®åˆ—ã®å„è¡Œã«ã‚¯ã‚¤ãƒ¼ãƒ³ã‚’é…ç½®ã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€ä½ç½®ã®ã€æ‹¡å¼µã•ã‚ŒãŸé›†åˆã‚’ç”Ÿæˆã—ã‚ˆã†ã€‚
ã•ã¦ã“ã“ã§ã€ã“ã‚Œã‚‰ã‚’ãƒ•ã‚£ãƒ«ã‚¿ã«ã‹ã‘ã€<em class="en">k</em> ç•ªç›®ã®åˆ—ã®ã‚¯ã‚¤ãƒ¼ãƒ³ãŒã€ä»–ã®æ®‹ã‚Šã®ã‚¯ã‚¤ãƒ¼ãƒ³ã«é–¢ã—ã¦å®‰å…¨ã§ã‚ã‚‹ã‚ˆã†ãªä½ç½®ã®ã¿ã‚’ã€ä¿ã¤ã‚ˆã†ã«ã—ã‚ˆã†ã€‚
ã“ã‚Œã«ã‚ˆã‚Šã€
<span class="math"><em class="en">k</em> &minus; 1</span> å€‹ã®ã‚¯ã‚¤ãƒ¼ãƒ³ã‚’ã€æœ€åˆã®
<span class="math"><em class="en">k</em> &minus; 1</span> åˆ—ã«é…ç½®ã™ã‚‹ãŸã‚ã®ã€ã™ã¹ã¦ã®æ–¹æ³•ã®åˆ—ãŒã€ä½œã‚Šå‡ºã•ã‚Œã‚‹ã€‚
ã“ã®ãƒ—ãƒ­ã‚»ã‚¹ã‚’ç¶šã‘ã‚‹ã“ã¨ã§ã€ä¸€ã¤ã®è§£ã ã‘ã§ãªãã€ã“ã®ãƒ‘ã‚ºãƒ«ã«å¯¾ã™ã‚‹ã™ã¹ã¦ã®è§£ãŒä½œã‚Šå‡ºã•ã‚Œã‚‹ã ã‚ã†ã€‚
</p>

<p class="orig" lang="en">
We implement this solution as a procedure <tt>queens</tt>, which returns
a sequence of all solutions to the problem of placing <em>n</em> queens on an
<em>n</em>&times; <em>n</em> chessboard.  <tt>Queens</tt> has an internal procedure <tt>queen-cols</tt> that returns the sequence of all ways to place queens in
the first <em>k</em> columns of the board.
</p>

<p class="trans" lang="ja">
ç§ãŸã¡ã¯ã€ã“ã®è§£æ³•ã‚’ <tt>queens</tt> ã¨ã„ã†æ‰‹ç¶šãã¨ã—ã¦å®Ÿè£…ã™ã‚‹â€”â€”ã“ã®æ‰‹ç¶šãã¯ã€
<span class="math"><em class="en">n</em>&times; <em class="en">n</em></span> ã®ãƒã‚§ã‚¹ç›¤ä¸Šã« <em class="en">n</em> å€‹ã®ã‚¯ã‚¤ãƒ¼ãƒ³ã‚’é…ç½®ã™ã‚‹ã¨ã„ã†å•é¡Œã«å¯¾ã™ã‚‹ã€ã™ã¹ã¦ã®è§£ã®åˆ—ã‚’è¿”ã™ã€‚
<tt>queens</tt> ã¯ã€ç›¤ã®æœ€åˆã® <em class="en">k</em> åˆ—ã«ã‚¯ã‚¤ãƒ¼ãƒ³ã‚’é…ç½®ã™ã‚‹ãŸã‚ã®ã™ã¹ã¦ã®æ–¹æ³•ã®åˆ—ã‚’è¿”ã™ã‚ˆã†ãªã€<tt>queen-cols</tt> ã¨ã„ã†å†…éƒ¨æ‰‹ç¶šãã‚’æœ‰ã™ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_1852"></a>(define (queens board-size)
  (define (queen-cols k)  
    (if (= k 0)
        (list empty-board)
        (filter
         (lambda (positions) (safe? k positions))
         (flatmap
          (lambda (rest-of-queens)
            (map (lambda (new-row)
                   (adjoin-position new-row k rest-of-queens))
                 (enumerate-interval 1 board-size)))
          (queen-cols (- k 1))))))
  (queen-cols board-size))
</p>

<p class="orig" lang="en">
In this procedure <tt>rest-of-queens</tt> is a way to place <em>k</em> - 1 queens
in the first <em>k</em> - 1 columns, and <tt>new-row</tt> is a proposed row in
which to place the queen for the <em>k</em>th column.  Complete the program
by implementing the representation for sets of board positions,
including the procedure <tt>adjoin-position</tt>, which adjoins a new row-column
position to a set of positions, and <tt>empty-board</tt>, which
represents an empty set of positions.  You must also write the
procedure <tt>safe?</tt>, which determines for a set of positions,
whether the queen in the <em>k</em>th column is safe with respect to the
others.  (Note that we need only check whether the new queen is
safe -- the other queens are already guaranteed safe with respect to
each other.)
</p>

<p class="trans" lang="ja">
ã“ã®æ‰‹ç¶šãã«ãŠã„ã¦ã€<tt>rest-of-queens</tt> ã¯ã€
<span class="math"><em class="en">k</em> &minus; 1</span> å€‹ã®ã‚¯ã‚¤ãƒ¼ãƒ³ã‚’ã€æœ€åˆã®
<span class="math"><em class="en">k</em> &minus; 1</span> åˆ—ã«é…ç½®ã™ã‚‹ãŸã‚ã®æ–¹æ³•ã§ã‚ã‚Šã€
<tt>new-row</tt> ã¯ã€<em class="en">k</em> ç•ªç›®ã®åˆ—ã®ã‚¯ã‚¤ãƒ¼ãƒ³ã‚’é…ç½®ã™ã¹ãã¨ã“ã‚ã¨ã—ã¦ææ¡ˆã•ã‚ŒãŸè¡Œã§ã‚ã‚‹ã€‚
<tt>adjoin-position</tt> ã¨ã„ã†æ‰‹ç¶šãâ€”â€”ä½ç½®ã®é›†åˆã«ã€æ–°ãŸãªè¡Œãƒ»åˆ—ã®ä½ç½®ã‚’æ¥åˆã™ã‚‹â€”â€”ã¨ã€<tt>empty-board</tt>â€”â€”ä½ç½®ã®ç©ºé›†åˆã‚’è¡¨ç¾ã™ã‚‹â€”â€”ã‚‚å«ã‚ã¦ã€ç›¤ä¸Šã®ä½ç½®ã®é›†åˆã®ãŸã‚ã®è¡¨ç¾ã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ã§ã€ã“ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’å®Œæˆã•ã›ã‚ˆã€‚
ã¾ãŸã€<tt>safe?</tt> ã¨ã„ã†æ‰‹ç¶šãâ€”â€”ä½ç½®ã®é›†åˆã«å¯¾ã—ã¦ã€<em class="en">k</em> ç•ªç›®ã®åˆ—ã®ã‚¯ã‚¤ãƒ¼ãƒ³ãŒã€æ®‹ã‚Šã®ã‚¯ã‚¤ãƒ¼ãƒ³ã«é–¢ã—ã¦å®‰å…¨ã‹ã©ã†ã‹ã‚’åˆ¤å®šã™ã‚‹â€”â€”ã‚‚ã€æ›¸ã‹ã­ã°ãªã‚‰ãªã„ã€‚
(æ–°ãŸãªã‚¯ã‚¤ãƒ¼ãƒ³ãŒå®‰å…¨ã‹ã©ã†ã‹ã€ã¨ã„ã†ã“ã¨ã ã‘ã‚’èª¿ã¹ã‚Œã°ã‚ˆã„â€”â€”ã¨ã„ã†ã®ã‚‚ã€æ®‹ã‚Šã®ã‚¯ã‚¤ãƒ¼ãƒ³ã¯ã€ãŠäº’ã„ã«é–¢ã—ã¦å®‰å…¨ã§ã‚ã‚‹ã“ã¨ãŒæ—¢ã«ä¿è¨¼ã•ã‚Œã¦ã„ã‚‹ã®ã§â€”â€”ã¨ã„ã†ã“ã¨ã«æ³¨æ„ã›ã‚ˆã€‚)
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_2.43"></a>
<b>Exercise 2.43.</b>  Louis Reasoner is having a terrible time doing exercise <a href="#%_thm_2.42">2.42</a>.  His
<tt>queens</tt> procedure seems to work, but it runs extremely slowly.
(Louis never does manage to wait long enough for it to solve even the
6&times; 6 case.)  When Louis asks Eva Lu Ator for help, she points
out that he has interchanged the order of the nested mappings in the
<tt>flatmap</tt>, writing it as</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.43.</b> ãƒ«ã‚¤ã‚¹ãƒ»ãƒªãƒ¼ã‚ºãƒŠã¯ã€ç·´ç¿’å•é¡Œ<a href="#%_thm_2.42">2.42</a>ã‚’è§£ãã®ã«ã€ã²ã©ã„ç›®ã«ã‚ã£ã¦ã„ã‚‹ã¨ã“ã‚ã§ã‚ã‚‹ã€‚
å½¼ã® <tt>queens</tt> ã®æ‰‹ç¶šãã¯ã€å‹•ãã¯ã™ã‚‹ã‚ˆã†ãªã®ã ãŒã€ã²ã©ãã®ã‚ã®ã‚ã¨å®Ÿè¡Œã•ã‚Œã‚‹ã®ã 
(ãƒ«ã‚¤ã‚¹ã¯ã€6&times;6 ã®å ´åˆã§ã•ãˆã€ã“ã®æ‰‹ç¶šããŒè§£ã‚’å‡ºã™ã®ã«ååˆ†ãªé•·ã•ã ã‘ã©ã†ã«ã‹å¾…ã£ã¦ã¿ã›ã‚‹ã€ã¨ã„ã†ã“ã¨ãŒæ±ºã—ã¦ãªã‹ã£ãŸ)ã€‚
ãƒ«ã‚¤ã‚¹ãŒã‚¨ãƒ´ã‚¡ãƒ»ãƒªãƒ¥ãƒ»ã‚¨ã‚¤ã‚¿ã«åŠ©ã‘ã‚’æ±‚ã‚ã‚‹ã¨ã€ã‚¨ãƒ´ã‚¡ã¯ã€<tt>flatmap</tt> ã«ãŠã‘ã‚‹å…¥ã‚Œå­ã®å†™åƒã®é †åºã‚’ã€ãƒ«ã‚¤ã‚¹ãŒå…¥ã‚Œæ›¿ãˆã¦ã€ä»¥ä¸‹ã®ã‚ˆã†ã«æ›¸ã„ãŸã®ã ã€ã¨æŒ‡æ‘˜ã™ã‚‹ã€‚
</p>

<p class="lisp">(flatmap
 (lambda (new-row)
   (map (lambda (rest-of-queens)
          (adjoin-position new-row k rest-of-queens))
        (queen-cols (- k 1))))
 (enumerate-interval 1 board-size))
</p>

<p class="orig" lang="en">
Explain why this interchange makes the program run slowly.  Estimate
how long it will take Louis's program to solve the eight-queens
puzzle, assuming that the program in exercise <a href="#%_thm_2.42">2.42</a> solves
the puzzle in time <em>T</em>.
</p>

<p class="trans" lang="ja">
ãªãœã“ã®å…¥ã‚Œæ›¿ãˆã®ã›ã„ã§ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®å®Ÿè¡ŒãŒé…ããªã‚‹ã®ã‹ã€èª¬æ˜ã›ã‚ˆã€‚
ãƒ«ã‚¤ã‚¹ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒã‚¨ã‚¤ãƒˆã‚¯ã‚¤ãƒ¼ãƒ³ãƒ»ãƒ‘ã‚ºãƒ«ã‚’è§£ãã®ã«ã€ã©ã‚Œãã‚‰ã„ã®æ™‚é–“ãŒã‹ã‹ã‚‹ã‹ã‚’ã€è¦‹ç©ã‚‚ã‚Œâ€”â€”ãŸã ã—ã€ç·´ç¿’å•é¡Œ<a href="#%_thm_2.42">2.42</a> ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€ã“ã®ãƒ‘ã‚ºãƒ«ã‚’ <em class="en">T</em> ãªã‚‹æ™‚é–“ã§è§£ãã‚‚ã®ã¨ã™ã‚‹ã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_2.2.4"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_2.2.4">2.2.4  Example: A Picture Language</a></h3>
<h3 class="trans" lang="ja">2.2.4 ä¾‹: ãŠçµµæãè¨€èª</h3>

<p class="orig" lang="en">
<a name="%_idx_1854"></a>
This section presents a simple language for drawing
pictures that illustrates the
power of data abstraction and closure,
and also exploits higher-order procedures in
an essential way.  The language
is designed to make it easy to experiment with patterns
such as the ones in figure <a href="#%_fig_2.9">2.9</a>, which are
composed of repeated elements that are shifted and scaled.<a name="call_footnote_Temp_202" href="#footnote_Temp_202"><sup><small>22</small></sup></a> In this language,
the data objects being combined
are represented as procedures rather than as list structure.
Just as <tt>cons</tt>, which satisfies the <a name="%_idx_1860"></a>closure property,
allowed us to easily build arbitrarily complicated
list structure, the operations in this language, which also
satisfy the closure property, allow us to easily build
arbitrarily complicated patterns.</p>

<p class="trans" lang="ja">
æœ¬ç¯€ã§ã¯ã€ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ã¨é–‰åŒ…ã®å¨åŠ›ã‚’ä¾‹ç¤ºã™ã‚‹ã€ãŠçµµæãç”¨ã®ç°¡å˜ãªè¨€èªã‚’æç¤ºã—ã€æœ¬è³ªçš„ãªã‚„ã‚Šæ–¹ã§é«˜éšæ‰‹ç¶šãã‚’åˆ©ç”¨ã™ã‚‹ã€‚
ãã®è¨€èªã¯ã€å›³<a href="#%_fig_2.9">2.9</a>ã«ã‚ã‚‹ã‚ˆã†ãªãƒ‘ã‚¿ãƒ³â€”â€”ç§»å‹•ã•ã‚ŒãŸã‚Šå¤‰å€ã•ã‚ŒãŸã‚Šã—ãŸç¹°ã‚Šè¿”ã—è¦ç´ ã‹ã‚‰ãªã‚‹â€”â€”ã‚’ä½¿ã£ã¦å®Ÿé¨“ã‚’è¡Œã†ã®ã‚’å®¹æ˜“ã«ã™ã‚‹ã‚ˆã†ã«ã€è¨­è¨ˆã•ã‚Œã¦ã„ã‚‹<a href="#footnote_Temp_202"><sup><small>22</small></sup></a>ã€‚
ã“ã®è¨€èªã§ã¯ã€çµåˆã•ã‚Œã¦ã„ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ãƒªã‚¹ãƒˆæ§‹é€ ã¨ã„ã†ã‚ˆã‚Šã‚€ã—ã‚æ‰‹ç¶šãã¨ã—ã¦è¡¨ç¾ã•ã‚Œã‚‹ã€‚
<tt>cons</tt>â€”â€”é–‰åŒ…ç‰¹æ€§ã‚’æº€ãŸã™â€”â€”ã®ãŠã‹ã’ã§ã€ä»»æ„ã«å…¥ã‚Šçµ„ã‚“ã ãƒªã‚¹ãƒˆæ§‹é€ ã‚’å®¹æ˜“ã«æ§‹ç¯‰ã§ãã‚‹ã‚ˆã†ã«ãªã£ãŸã®ã¨ã¡ã‚‡ã†ã©åŒã˜ã‚ˆã†ã«ã€ã“ã®è¨€èªã«ãŠã‘ã‚‹æ¼”ç®—â€”â€”ã“ã‚Œã‚‰ã‚‚é–‰åŒ…ç‰¹æ€§ã‚’æº€ãŸã™â€”â€”ã®ãŠã‹ã’ã§ã€ä»»æ„ã«å…¥ã‚Šçµ„ã‚“ã ãƒ‘ã‚¿ãƒ³ã‚’å®¹æ˜“ã«æ§‹ç¯‰ã§ãã‚‹ã€‚
</p>

<figure>
<a name="%_fig_2.9"></a>
<img src="ch2-Z-G-24.gif" border="0"> &nbsp;&nbsp;
<img src="ch2-Z-G-25.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 2.9:</b>  Designs generated with the picture language.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³2.9:</b> ãŠçµµæãè¨€èªã‚’ä½¿ã£ã¦ç”Ÿæˆã•ã‚ŒãŸå›³æŸ„</figcaption>
</figure>

<a name="%_sec_Temp_203"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_203">The picture language</a></h4>
<h4 class="trans" lang="ja">ãŠçµµæãè¨€èª</h4>

<p class="orig" lang="en">When we began our study of programming in
section <a href="10_sec1_1.html#%_sec_1.1">1.1</a>, we emphasized the
importance of describing a language by focusing on the language's
primitives, its means of combination, and its means of abstraction.
We'll follow that framework here.</p>

<p class="trans" lang="ja">
<a href="10_sec1_1.html#%_sec_1.1">1.1</a>ç¯€ã§ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®å‹‰å¼·ã‚’å§‹ã‚ãŸã¨ãã€ç§ãŸã¡ã¯ã€è¨€èªã®ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã¨ã€çµåˆã®æ‰‹æ®µã¨ã€æŠ½è±¡åŒ–ã®æ‰‹æ®µã¨ã«ç„¦ç‚¹ã‚’åˆã‚ã›ã¦è¨€èªã‚’è¨˜è¿°ã™ã‚‹ã“ã¨ã®é‡è¦æ€§ã‚’ã€å¼·èª¿ã—ãŸã€‚
ç§ãŸã¡ã¯ã€ã“ã“ã§ã‚‚ãã®æ çµ„ã¿ã«å¾“ãŠã†ã€‚
</p>

<p class="orig" lang="en">Part of the elegance of this picture language is that there is
only one kind of element, called a <a name="%_idx_1862"></a><em>painter</em>.  A painter
draws an image that is shifted and scaled to fit within a designated
<a name="%_idx_1864"></a>parallelogram-shaped frame.  For example, there's a primitive painter
we'll call <tt>wave</tt> that makes a crude line drawing, as
shown in figure <a href="#%_fig_2.10">2.10</a>.
The actual shape of the drawing depends on the frame -- all
four images in figure <a href="#%_fig_2.10">2.10</a> are produced by the same <tt>wave</tt> painter, but with respect to four different frames.  Painters
can be more elaborate than this:
The primitive
painter called <tt>rogers</tt> paints a picture of MIT's founder,
William Barton Rogers, as shown in figure <a href="#%_fig_2.11">2.11</a>.<a name="call_footnote_Temp_204" href="#footnote_Temp_204"><sup><small>23</small></sup></a>
The four images in figure <a href="#%_fig_2.11">2.11</a>
are drawn with respect to the same four frames
as the <tt>wave</tt> images in figure <a href="#%_fig_2.10">2.10</a>.</p>

<p class="trans" lang="ja">
ã“ã®ãŠçµµæãè¨€èªã®æ´—ç·´ã¶ã‚Šã®ä¸€ç«¯ã¯ã€ä¸€ç¨®é¡ã®è¦ç´ â€”â€”<em><ruby><rb>æç”»å­</rb><rp> (</rp><rt>ãƒšã‚¤ãƒ³ã‚¿</rt><rp>)</rp></em>ã¨å‘¼ã°ã‚Œã‚‹â€”â€”ã—ã‹ãªã„ã€ã¨ã„ã†ç‚¹ã«ã‚ã‚‹ã€‚
ãƒšã‚¤ãƒ³ã‚¿ã¯ã€æŒ‡å®šã•ã‚ŒãŸå¹³è¡Œå››è¾ºå½¢ã®æ ã®ä¸­ã«åˆã†ã‚ˆã†ã«ç§»å‹•ã•ã‚ŒãŸã‚Šå¤‰å€ã•ã‚ŒãŸã‚Šã™ã‚‹ç”»åƒã‚’æãã€‚
ãŸã¨ãˆã°ã€ç§ãŸã¡ãŒã“ã‚Œã‹ã‚‰ <tt>wave</tt> ã¨å‘¼ã¶ã‚‚ã®ã§ã€å›³<a href="#%_fig_2.10">2.10</a>ã«ç¤ºã™ã‚ˆã†ã«å¤§é›‘æŠŠãªç·šæã‚’è¡Œã†ã€åŸå§‹çš„ãªãƒšã‚¤ãƒ³ã‚¿ãŒã‚ã‚‹ã€‚
å®Ÿéš›ã®å›³é¢ã®å½¢ã¯ã€æ ã«ä¾å­˜ã™ã‚‹â€”â€”å›³<a href="#%_fig_2.10">2.10</a>ã®å››ã¤ã®ç”»åƒã¯ã™ã¹ã¦ã€åŒã˜ <tt>wave</tt> ãƒšã‚¤ãƒ³ã‚¿ã«ã‚ˆã‚Šä½œã‚Šå‡ºã•ã‚Œã‚‹ã‚‚ã®ã ãŒã€å››ã¤ã®ç•°ãªã‚‹æ ã«é–¢ã—ã¦ä½œã‚Šå‡ºã•ã‚Œã‚‹ã®ã§ã‚ã‚‹ã€‚
ãƒšã‚¤ãƒ³ã‚¿ã¯ã€ã“ã‚Œã‚ˆã‚Šã‚‚ã€ã‚‚ã£ã¨æ‰‹ã®è¾¼ã‚“ã ã‚‚ã®ã§ã‚ã‚Šå¾—ã‚‹ã€‚
<tt>rogers</tt> ã¨å‘¼ã°ã‚Œã‚‹åŸå§‹çš„ãƒšã‚¤ãƒ³ã‚¿ã¯ã€MITã®å‰µç«‹è€…ãŸã‚‹ã€ã‚¦ã‚£ãƒªã‚¢ãƒ ãƒ»ãƒãƒ¼ãƒˆãƒ³ãƒ»ãƒ­ã‚¸ãƒ£ãƒ¼ã‚¹ã®çµµã‚’ã€å›³<a href="#%_fig_2.11">2.11</a>ã«ç¤ºã™ã‚ˆã†ã«ã€æã<a href="#footnote_Temp_204"><sup><small>23</small></sup></a>ã€‚
å›³<a href="#%_fig_2.11">2.11</a>ã®å››ã¤ã®ç”»åƒã¯ã€å›³<a href="#%_fig_2.10">2.10</a>ã® <tt>wave</tt> ç”»åƒã®ã¨åŒã˜å››ã¤ã®æ ã«é–¢ã—ã¦ã€æã‹ã‚Œã¦ã„ã‚‹ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_1876"></a>To combine images,
we use various operations that construct new painters
from given painters.
For example, the <a name="%_idx_1878"></a><tt>beside</tt> operation takes two painters and produces a new,
compound painter that draws the first painter's image in the left half
of the frame and the second painter's image in the right half of the frame.
Similarly, <a name="%_idx_1880"></a><tt>below</tt> takes two painters and produces a compound
painter that draws the first painter's image below the second
painter's image.
Some operations transform a single painter to produce
a new painter.  For example, <a name="%_idx_1882"></a><tt>flip-vert</tt> takes a painter and
produces a painter that draws its image upside-down, and
<a name="%_idx_1884"></a><tt>flip-horiz</tt> produces a painter that draws the original
painter's image left-to-right reversed.</p>

<p class="trans" lang="ja">
ç”»åƒã‚’çµåˆã™ã‚‹ãŸã‚ã«ã€ç§ãŸã¡ã¯ã€ä¸ãˆã‚‰ã‚ŒãŸãƒšã‚¤ãƒ³ã‚¿ã‹ã‚‰æ–°ãŸãªãƒšã‚¤ãƒ³ã‚¿ã‚’æ§‹ç¯‰ã™ã‚‹æ§˜ã€…ãªæ¼”ç®—ã‚’ä½¿ã†ã€‚
ãŸã¨ãˆã°ã€<tt>beside</tt> æ¼”ç®—ã¯ã€äºŒã¤ã®ãƒšã‚¤ãƒ³ã‚¿ã‚’å–ã‚‹ã€‚ãã—ã¦ã€ä¸€ã¤ç›®ã®ãƒšã‚¤ãƒ³ã‚¿ã®ç”»åƒã‚’æ ã®å·¦åŠåˆ†ã«æãã¨ã¨ã‚‚ã«äºŒã¤ç›®ã®ãƒšã‚¤ãƒ³ã‚¿ã®ç”»åƒã‚’æ ã®å³åŠåˆ†ã«æãã‚ˆã†ãªã€æ–°ã—ã„è¤‡åˆãƒšã‚¤ãƒ³ã‚¿ã‚’ã€ä½œã‚Šå‡ºã™ã€‚
åŒæ§˜ã«ã€<tt>below</tt> ã¯ã€äºŒã¤ã®ãƒšã‚¤ãƒ³ã‚¿ã‚’å–ã‚‹ã€‚ãã—ã¦ã€ä¸€ã¤ç›®ã®ãƒšã‚¤ãƒ³ã‚¿ã®ç”»åƒã‚’äºŒã¤ç›®ã®ãƒšã‚¤ãƒ³ã‚¿ã®ç”»åƒã®ä¸‹ã«æãã‚ˆã†ãªè¤‡åˆãƒšã‚¤ãƒ³ã‚¿ã‚’ã€ä½œã‚Šå‡ºã™ã€‚
ã„ãã¤ã‹ã®æ¼”ç®—ã¯ã€å˜ä¸€ã®ãƒšã‚¤ãƒ³ã‚¿ã‚’å¤‰å½¢ã—ã¦ã€æ–°ãŸãªãƒšã‚¤ãƒ³ã‚¿ã‚’ä½œã‚Šå‡ºã™ã€‚
ãŸã¨ãˆã°ã€<tt>flip-vert</tt> ã¯ã€ãƒšã‚¤ãƒ³ã‚¿ã‚’å–ã‚Šã€ãã®ç”»åƒã‚’ä¸Šä¸‹ã•ã‹ã•ã¾ã«æãã‚ˆã†ãªãƒšã‚¤ãƒ³ã‚¿ã‚’ä½œã‚Šå‡ºã™ã—ã€<tt>flip-horiz</tt> ã¯ã€å…ƒã®ãƒšã‚¤ãƒ³ã‚¿ã®ç”»åƒã‚’å·¦å³é€†ã«æãã‚ˆã†ãªãƒšã‚¤ãƒ³ã‚¿ã‚’ä½œã‚Šå‡ºã™ã€‚
</p>

<figure>
<a name="%_fig_2.10"></a>
<table>
<tr>
	<td><img src="ch2-Z-G-26.gif" border="0"></td>
	<td>&nbsp;</td>
	<td><img src="ch2-Z-G-27.gif" border="0"></td>
</tr>
<tr>
	<td><img src="ch2-Z-G-28.gif" border="0"></td>
	<td>&nbsp;</td>
	<td><img src="ch2-Z-G-29.gif" border="0"></td>
</tr>
</table>
<figcaption class="orig" lang="en"><b>Figure 2.10:</b>  Images produced by the <tt>wave</tt> painter, with respect
to four different frames.  The frames, shown with dotted lines, are not
part of the images.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³2.10:</b> ç•°ãªã‚‹å››ã¤ã®æ ã«ã¤ã„ã¦ã€<tt>wave</tt> ãƒšã‚¤ãƒ³ã‚¿ã«ã‚ˆã‚Šä½œã‚Šå‡ºã•ã‚ŒãŸç”»åƒã€‚æ â€”â€”ç‚¹ç·šã§ç¤ºã•ã‚Œã¦ã„ã‚‹â€”â€”ã¯ã€ç”»åƒã®ä¸€éƒ¨ã§ã¯ãªã„ã€‚</figcaption>
</figure>

<figure>
<a name="%_fig_2.11"></a>
<table>
<tr>
	<td><img src="ch2-Z-G-30.gif" border="0"></td>
	<td>&nbsp;</td>
	<td><img src="ch2-Z-G-31.gif" border="0"></td>
<tr>
<tr>
	<td><img src="ch2-Z-G-32.gif" border="0"></td>
	<td>&nbsp;</td>
	<td><img src="ch2-Z-G-33.gif" border="0"></td>
</tr>
</table>
<figcaption class="orig" lang="en"><b>Figure 2.11:</b>  Images of William Barton Rogers, founder and first
president of MIT, painted with respect to the same four frames as in
figure <a href="#%_fig_2.10">2.10</a> (original image reprinted with the permission
of the MIT Museum).</figcaption>
<figcaption class="trans" lang="ja"><b>å›³2.11:</b> MITã®å‰µç«‹è€…ã‹ã¤åˆä»£å­¦é•·ã§ã‚ã‚‹ã‚¦ã‚£ãƒªã‚¢ãƒ ãƒ»ãƒãƒ¼ãƒˆãƒ³ãƒ»ãƒ­ã‚¸ãƒ£ãƒ¼ã‚¹ã®ç”»åƒâ€”â€”å›³<a href="#%_fig_2.10">2.10</a>ã¨åŒã˜å››ã¤ã®æ ã«ã¤ã„ã¦æã‹ã‚ŒãŸã‚‚ã® (ã‚‚ã¨ã®ç”»åƒã¯MITåšç‰©é¤¨ã®è¨±å¯ã®ã‚‚ã¨ã§å†ç‰ˆã•ã‚Œã¦ã„ã‚‹)</figcaption>
</figure>

<p class="orig" lang="en">
Figure <a href="#%_fig_2.12">2.12</a> shows the drawing of a painter called
<tt>wave4</tt> that is built up in two stages starting from <tt>wave</tt>:</p>

<p class="trans" lang="ja">
å›³<a href="#%_fig_2.12">2.12</a>ã¯ã€<tt>wave</tt> ã‹ã‚‰å§‹ã‚ã¦äºŒæ®µéšã§æ§‹ç¯‰ã•ã‚Œã‚‹ã€<tt>wave4</tt> ã¨å‘¼ã°ã‚Œã‚‹ãƒšã‚¤ãƒ³ã‚¿ã®ã€ç·šç”»ã‚’ç¤ºã™ã€‚
</p>

<p class="lisp">(define wave2 (beside wave (flip-vert wave)))
(define wave4 (below wave2 wave2))
</p>


<figure>
<a name="%_fig_2.12"></a>
<table>
<tr>
<td><img src="ch2-Z-G-34.gif" border="0"></td>
<td><img src="ch2-Z-G-35.gif" border="0"></td>
</tr>
<tr>
<td><tt>(define wave2
  (beside wave (flip-vert wave)))</tt></td>
<td><tt>(define wave4
  (below wave2 wave2))</tt></td>
</tr>
</table>
<figcaption class="orig" lang="en"><b>Figure 2.12:</b>  Creating a complex figure,
starting from the <tt>wave</tt> painter of figure <a href="#%_fig_2.10">2.10</a>.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³2.12:</b> å›³<a href="#%_fig_2.10">2.10</a>ã® <tt>wave</tt> ãƒšã‚¤ãƒ³ã‚¿ã‹ã‚‰å§‹ã‚ã¦ã€è¤‡é›‘ãªå›³å½¢ã‚’ä½œæˆã—ã¦ã„ã‚‹</figcaption>
</figure>

<p class="orig" lang="en"><a name="%_idx_1886"></a>In building up a complex image in this manner we are exploiting the
fact that painters are closed under the language's means of
combination.  The <tt>beside</tt> or <tt>below</tt> of two painters is
itself a painter; therefore, we can use it as an element in making
more complex painters.  As with building up list structure using <tt>cons</tt>, the closure of our data under the means of combination is
crucial to the ability to create complex structures while using only a
few operations.</p>

<p class="trans" lang="ja">
ã“ã®ã‚„ã‚Šæ–¹ã§è¤‡é›‘ãªç”»åƒã‚’æ§‹ç¯‰ã™ã‚‹éš›ã«ã€ç§ãŸã¡ã¯ã€ãƒšã‚¤ãƒ³ã‚¿ãŒè¨€èªã®çµåˆæ‰‹æ®µã®ã‚‚ã¨ã§é–‰ã˜ã¦ã„ã‚‹ã¨ã„ã†äº‹å®Ÿã‚’ã€åˆ©ç”¨ã—ã¦ã„ã‚‹ã€‚
äºŒã¤ã®ãƒšã‚¤ãƒ³ã‚¿ã® <tt>beside</tt> ã¾ãŸã¯ <tt>below</tt> ã¯ã€ãã‚Œè‡ªä½“ãŒãƒšã‚¤ãƒ³ã‚¿ã§ã‚ã‚‹ã€‚ã‚ˆã£ã¦ã€ãã‚Œã‚’ã€ã‚ˆã‚Šè¤‡é›‘ãªãƒšã‚¤ãƒ³ã‚¿ã‚’ä½œã‚‹éš›ã«ã€è¦ç´ ã¨ã—ã¦ä½¿ã†ã“ã¨ãŒã§ãã‚‹ã€‚
<tt>cons</tt> ã‚’ä½¿ã£ã¦ãƒªã‚¹ãƒˆæ§‹é€ ã‚’æ§‹ç¯‰ã™ã‚‹ã¨ãã¨åŒæ§˜ã«ã€çµåˆæ‰‹æ®µã®ã‚‚ã¨ã§ã®ç§ãŸã¡ã®ãƒ‡ãƒ¼ã‚¿ã®é–‰åŒ…ã¯ã€å°‘æ•°ã®æ¼”ç®—ã®ã¿ã‚’ä½¿ã„ã¤ã¤ã‚‚è¤‡é›‘ãªæ§‹é€ ã‚’ä½œæˆã™ã‚‹èƒ½åŠ›ã«ã¯ä¸å¯æ¬ ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
Once we can combine painters, we would like to be able to abstract
typical patterns of combining painters.
We will implement the painter operations as Scheme procedures.
This means that we don't need a special abstraction mechanism
in the picture language:
Since the means of combination
are ordinary Scheme procedures, we automatically have the capability
to do anything with painter operations that we can do with
procedures.
For example, we can abstract the pattern in <tt>wave4</tt> as</p>

<p class="trans" lang="ja">
ä¸€æ—¦ãƒšã‚¤ãƒ³ã‚¿åŒå£«ã‚’çµåˆã§ãã‚Œã°ã€ãƒšã‚¤ãƒ³ã‚¿åŒå£«ã‚’çµåˆã™ã‚‹å…¸å‹çš„ãƒ‘ã‚¿ãƒ³ã‚’æŠ½è±¡åŒ–ã—ãŸããªã‚‹ã ã‚ã†ã€‚
ç§ãŸã¡ã¯ã€ãƒšã‚¤ãƒ³ã‚¿æ¼”ç®—ã‚’ã€Schemeæ‰‹ç¶šãã¨ã—ã¦å®Ÿè£…ã—ã‚ˆã†ã€‚
ã“ã‚Œã¯ã€ãŠçµµæãè¨€èªã§ã®ç‰¹æ®ŠãªæŠ½è±¡åŒ–ã®ä»•çµ„ã¿ã‚’å¿…è¦ã¨ã—ãªã„ã€ã¨ã„ã†ã“ã¨ã‚’æ„å‘³ã™ã‚‹ã€‚
çµåˆæ‰‹æ®µã¯æ™®é€šã®Schemeã®æ‰‹ç¶šããªã®ã§ã€ç§ãŸã¡ã¯ã€è‡ªå‹•çš„ã«ã€æ‰‹ç¶šãã‚’ä½¿ã£ã¦è¡Œãˆã‚‹ã“ã¨ã¯ä½•ã§ã‚‚ãƒšã‚¤ãƒ³ã‚¿æ¼”ç®—ã‚’ä½¿ã£ã¦è¡Œãˆã‚‹èƒ½åŠ›ã‚’æŒã£ã¦ã„ã‚‹ã€‚
ãŸã¨ãˆã°ã€<tt>wave4</tt> ã®ä¸­ã®ãƒ‘ã‚¿ãƒ³ã‚’æ¬¡ã®ã‚ˆã†ã«æŠ½è±¡åŒ–ã§ãã‚‹ã—ã€
</p>

<p class="lisp"><a name="%_idx_1888"></a>(define (flipped-pairs painter)
  (let ((painter2 (beside painter (flip-vert painter))))
    (below painter2 painter2)))
</p>

<p class="orig" lang="en">
and define <tt>wave4</tt> as an instance of this pattern:</p>

<p class="trans" lang="ja">
ã“ã®ãƒ‘ã‚¿ãƒ³ã®<ruby><rb>ä¸€ä¾‹</rb><rp> (</rp><rt>ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹</rt><rp>) </rp></ruby>ã¨ã—ã¦ã€<tt>wave4</tt> ã‚’å®šç¾©ã§ãã‚‹ã€‚
</p>

<p class="lisp">(define wave4 (flipped-pairs wave))
</p>

<p class="orig" lang="en">We can also define recursive operations.
Here's one that makes painters split and branch
towards the right as shown in figures <a href="#%_fig_2.13">2.13</a>
and  <a href="#%_fig_2.14">2.14</a>:</p>

<p class="trans" lang="ja">
ç§ãŸã¡ã¯ã€å†å¸°çš„æ¼”ç®—ã‚‚å®šç¾©ã§ãã‚‹ã€‚
å›³<a href="#%_fig_2.13">2.13</a>ã¨<a href="#%_fig_2.14">2.14</a>ã«ç¤ºã™ã‚ˆã†ã«ã€å³ã¸å‘ã‹ã£ã¦ãƒšã‚¤ãƒ³ã‚¿ã‚’åˆ†è£‚ãƒ»æåˆ†ã‹ã‚Œã•ã›ã‚‹å†å¸°çš„æ¼”ç®—ãŒã€ã“ã“ã«ã‚ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_1890"></a>(define (right-split painter n)
  (if (= n 0)
      painter
      (let ((smaller (right-split painter (- n 1))))
        (beside painter (below smaller smaller)))))
</p>

<figure>
<a name="%_fig_2.13"></a>
<table>
<tr>
<td><img src="ch2-Z-G-36.gif" border="0"></td>
<td><img src="ch2-Z-G-37.gif" border="0"></td>
</tr>
<td><tt>     right-split</tt> <em>n</em></td>
<td><tt>     corner-split</tt> <em>n</em></td>
</tr>
</table>
<figcaption class="orig" lang="en"><b>Figure 2.13:</b>  Recursive plans for <tt>right-split</tt> and <tt>corner-split</tt>.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³2.13:</b> <tt>right-split</tt> ã¨ <tt>corner-split</tt> ã«ã¤ã„ã¦ã®å†å¸°çš„è¨ˆç”»</figcaption>
</figure>

<p class="orig" lang="en">We can produce balanced patterns by branching upwards
as well as towards the right (see exercise <a href="#%_thm_2.44">2.44</a>
and figures <a href="#%_fig_2.13">2.13</a> and  <a href="#%_fig_2.14">2.14</a>):
</p>

<p class="trans" lang="ja">
å³å‘ãã¨åŒæ§˜ã«ä¸Šå‘ãã«ã‚‚æåˆ†ã‹ã‚Œã™ã‚‹ã“ã¨ã§ã€é‡£ã‚Šåˆã„ã®å–ã‚ŒãŸãƒ‘ã‚¿ãƒ³ã‚’ä½œã‚Šå‡ºã›ã‚‹ (ç·´ç¿’å•é¡Œ<a href="#%_thm_2.44">2.44</a>ã€å›³<a href="#%_fig_2.13">2.13</a>ã€å›³<a href="#%_fig_2.14">2.14</a>ã‚’å‚ç…§)ã€‚
</p>

<p class="lisp"><a name="%_idx_1892"></a>(define (corner-split painter n)
  (if (= n 0)
      painter
      (let ((up (up-split painter (- n 1)))
            (right (right-split painter (- n 1))))
        (let ((top-left (beside up up))
              (bottom-right (below right right))
              (corner (corner-split painter (- n 1))))
          (beside (below painter top-left)
                  (below bottom-right corner))))))
</p>

<figure>
<a name="%_fig_2.14"></a>
<table>
<tr>
<td><img src="ch2-Z-G-38.gif" border="0"></td>
<td><img src="ch2-Z-G-39.gif" border="0"></td>
</tr>
<tr>
<td><tt>     (right-split wave 4)</tt></td>
<td><tt>     (right-split rogers 4)</tt></td>
</tr>
<tr>
<td><img src="ch2-Z-G-40.gif" border="0"></td>
<td><img src="ch2-Z-G-41.gif" border="0"></td>
</tr>
<tr>
<td><tt>    (corner-split wave 4)</tt></td>
<td><tt>    (corner-split rogers 4)</tt></td>
</tr>
</table>
<figcaption class="orig" lang="en"><b>Figure 2.14:</b>  The recursive operations <tt>right-split</tt> and <tt>corner-split</tt> applied to the painters <tt>wave</tt> and <tt>rogers</tt>.
Combining four <tt>corner-split</tt> figures produces
symmetric <tt>square-limit</tt> designs as shown
in figure <a href="#%_fig_2.9">2.9</a>.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³2.14:</b> <tt>wave</tt> ãŠã‚ˆã³ <tt>rogers</tt> ã¨ã„ã†ãƒšã‚¤ãƒ³ã‚¿ã«å¯¾ã—ã¦é©ç”¨ã•ã‚ŒãŸã€<tt>right-split</tt> ãŠã‚ˆã³ <tt>corner-split</tt> ã¨ã„ã†å†å¸°çš„æ¼”ç®—ã€‚
å››ã¤ã® <tt>corner-split</tt> ã®å›³ã‚’çµåˆã™ã‚‹ã“ã¨ã§ã€å›³<a href="#%_fig_2.9">2.9</a>ã«ç¤ºã—ãŸã‚ˆã†ãªã€å¯¾ç§°çš„ãª <tt>square-limit</tt> ã®å›³æŸ„ãŒä½œã‚Šå‡ºã•ã‚Œã‚‹ã€‚</figcaption>
</figure>

<p class="orig" lang="en">By placing four copies of a <tt>corner-split</tt>
appropriately, we obtain a pattern called <tt>square-limit</tt>, whose
application to <tt>wave</tt> and <tt>rogers</tt> is shown in
figure <a href="#%_fig_2.9">2.9</a>:</p>

<p class="trans" lang="ja">
<tt>corner-split</tt> ã®å››ã¤ã®å†™ã—ã‚’é©å®œé…ç½®ã™ã‚‹ã“ã¨ã§ã€<tt>square-limit</tt> ã¨å‘¼ã°ã‚Œã‚‹ãƒ‘ã‚¿ãƒ³ãŒå¾—ã‚‰ã‚Œã¦ã€ãã‚Œã‚’ <tt>wave</tt> ã¨ <tt>rogers</tt> ã«é©ç”¨ã—ãŸã‚‚ã®ã¯ã€å›³<a href="#%_fig_2.9">2.9</a>ã«ç¤ºã•ã‚Œã¦ã„ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_1894"></a>(define (square-limit painter n)
  (let ((quarter (corner-split painter n)))
    (let ((half (beside (flip-horiz quarter) quarter)))
      (below (flip-vert half) half))))
</p>

<p class="orig" lang="en"><a name="%_thm_2.44"></a>
<b>Exercise 2.44.</b>  Define the procedure <a name="%_idx_1896"></a><tt>up-split</tt> used by <tt>corner-split</tt>.
It is similar to <tt>right-split</tt>, except that it switches the
roles of <tt>below</tt> and <tt>beside</tt>.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.44.</b> <tt>corner-split</tt> ã§ä½¿ã‚ã‚Œã¦ã„ã‚‹ <tt>up-split</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’å®šç¾©ã›ã‚ˆã€‚
ãã‚Œã¯ã€<tt>below</tt> ã¨ <tt>beside</tt> ã®å½¹å‰²ã‚’äº¤æ›ã—ã¦ã„ã‚‹ã¨ã„ã†ç‚¹ã‚’é™¤ã„ã¦ã€<tt>right-split</tt> ã«ä¼¼ã¦ã„ã‚‹ã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_Temp_206"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_206">Higher-order operations</a></h4>
<h4 class="trans" lang="ja">é«˜éšæ¼”ç®—</h4>

<p class="orig" lang="en"><a name="%_idx_1898"></a>
In addition to abstracting patterns of combining painters, we can work
at a higher level, abstracting patterns of combining painter operations.
That is, we can view the painter operations as elements to manipulate
and can write means of combination for these elements -- procedures that
take painter operations as arguments and create new painter operations.</p>

<p class="trans" lang="ja">
ãƒšã‚¤ãƒ³ã‚¿åŒå£«ã‚’çµåˆã™ã‚‹ãƒ‘ã‚¿ãƒ³ã‚’æŠ½è±¡åŒ–ã™ã‚‹ã“ã¨ã ã‘ã§ãªãã€ç§ãŸã¡ã¯ã€ã‚ˆã‚Šé«˜ã„ãƒ¬ãƒ™ãƒ«ã§ä½œæ¥­ã™ã‚‹ã“ã¨ãŒã§ãã‚‹â€”â€”ãƒšã‚¤ãƒ³ã‚¿æ¼”ç®—åŒå£«ã‚’çµåˆã™ã‚‹ãƒ‘ã‚¿ãƒ³ã‚’æŠ½è±¡åŒ–ã™ã‚‹ã®ã ã€‚
ã¤ã¾ã‚Šã€ç§ãŸã¡ã¯ã€ãƒšã‚¤ãƒ³ã‚¿æ¼”ç®—ã‚’ã€æ“ä½œã™ã¹ãè¦ç´ ã¨è¦‹ãªã™ã“ã¨ãŒã§ãã‚‹ã—ã€ã“ã‚Œã‚‰ã®è¦ç´ åŒå£«ã®çµåˆæ‰‹æ®µâ€”â€”ãƒšã‚¤ãƒ³ã‚¿æ¼”ç®—ã‚’å¼•æ•°ã¨ã—ã¦å–ã‚Šã€æ–°ã—ã„ãƒšã‚¤ãƒ³ã‚¿æ¼”ç®—ã‚’ä½œæˆã™ã‚‹ã‚ˆã†ãªæ‰‹ç¶šãâ€”â€”ã‚’æ›¸ãã“ã¨ãŒã§ãã‚‹ã€‚
</p>

<p class="orig" lang="en">For example, <tt>flipped-pairs</tt> and <tt>square-limit</tt> each
arrange four copies of a painter's image in a square pattern; they differ
only in how they orient the copies.
One way to abstract this pattern of painter combination is with
the following procedure, which takes four one-argument painter operations
and produces a painter operation that transforms a given
painter with those four operations and arranges the results in a square.
<tt>Tl</tt>, <tt>tr</tt>, <tt>bl</tt>, and <tt>br</tt> are the
transformations to apply to the top left copy, the top right copy,
the bottom left copy, and the bottom right copy, respectively.
</p>

<p class="trans" lang="ja">
ãŸã¨ãˆã°ã€<tt>flipped-pairs</tt> ã¨ <tt>square-limit</tt> ã¯ã€å„ã€…ã€ãƒšã‚¤ãƒ³ã‚¿ã®ç”»åƒã®å››ã¤ã®å†™ã—ã‚’ã€å››è§’ã„ãƒ‘ã‚¿ãƒ³ã«é…ç½®ã™ã‚‹ã€‚ä¸¡è€…ã¯ã€ãã‚Œã‚‰ã®å†™ã—ã®å‘ãã‚’ã©ã†å®šã‚ã‚‹ã‹ã¨ã„ã†ç‚¹ã§ã®ã¿ã€ç•°ãªã‚‹ã€‚
ãƒšã‚¤ãƒ³ã‚¿çµåˆã®ã“ã®ãƒ‘ã‚¿ãƒ³ã‚’æŠ½è±¡åŒ–ã™ã‚‹ä¸€ã¤ã®æ–¹æ³•ã¯ã€ä»¥ä¸‹ã®æ‰‹ç¶šãã‚’ä½¿ã†ã“ã¨ã§ã‚ã‚‹ã€‚ä»¥ä¸‹ã®æ‰‹ç¶šãã¯ã€1å¼•æ•°ã®ãƒšã‚¤ãƒ³ã‚¿æ¼”ç®—ã‚’å››ã¤å–ã‚‹ã€‚ãã—ã¦ã€ä¸ãˆã‚‰ã‚ŒãŸãƒšã‚¤ãƒ³ã‚¿ã‚’ã€ãã‚Œã‚‰å››ã¤ã®æ¼”ç®—ã‚’ä½¿ã£ã¦å¤‰å½¢ã—ã¦ã€ãã®çµæœã‚’å››è§’å½¢ã®ä¸­ã«é…ç½®ã™ã‚‹ã€‚
<tt>tl</tt> ã¨ <tt>tr</tt> ã¨ <tt>bl</tt> ã¨ <tt>br</tt> ã¯ã€ãã‚Œãã‚Œã€å·¦ä¸Šã®å†™ã—ã€å³ä¸Šã®å†™ã—ã€å·¦ä¸‹ã®å†™ã—ã€å³ä¸‹ã®å†™ã—ã«å¯¾ã—ã¦ã€é©ç”¨ã™ã¹ãå¤‰å½¢ã§ã‚ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_1900"></a>(define (square-of-four tl tr bl br)
  (lambda (painter)
    (let ((top (beside (tl painter) (tr painter)))
          (bottom (beside (bl painter) (br painter))))
      (below bottom top))))
</p>

<p class="orig" lang="en">
Then <tt>flipped-pairs</tt> can be defined in terms
of <tt>square-of-four</tt> as follows:<a name="call_footnote_Temp_207" href="#footnote_Temp_207"><sup><small>24</small></sup></a>
</p>

<p class="trans" lang="ja">
ã™ã‚‹ã¨ã€<tt>square-of-four</tt> ã‚’ç”¨ã„ã¦ã€ä»¥ä¸‹ã®ã‚ˆã†ã« <tt>flipped-pairs</tt> ã‚’å®šç¾©ã§ãã¦<a href="#footnote_Temp_207"><sup><small>24</small></sup></a>ã€
</p>

<p class="lisp"><a name="%_idx_1904"></a>(define (flipped-pairs painter)
  (let ((combine4 (square-of-four identity flip-vert
                                  identity flip-vert)))
    (combine4 painter)))
</p>

<p class="orig" lang="en">
and <tt>square-limit</tt> can be expressed as<a name="call_footnote_Temp_208" href="#footnote_Temp_208"><sup><small>25</small></sup></a>
</p>

<p class="trans" lang="ja">
<tt>square-limit</tt> ã‚’æ¬¡ã®ã‚ˆã†ã«è¡¨ã›ã‚‹<a href="#footnote_Temp_208"><sup><small>25</small></sup></a>ã€‚
</p>

<p class="lisp"><a name="%_idx_1906"></a>(define (square-limit painter n)
  (let ((combine4 (square-of-four flip-horiz identity
                                  rotate180 flip-vert)))
    (combine4 (corner-split painter n))))
</p>

<p class="orig" lang="en"><a name="%_thm_2.45"></a>
<b>Exercise 2.45.</b>  <tt>Right-split</tt> and <tt>up-split</tt> can be expressed as
instances of a general splitting operation.
Define a procedure <a name="%_idx_1908"></a><tt>split</tt> with the property that evaluating</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.45.</b> <tt>right-split</tt> ã¨ <tt>up-split</tt> ã¯ã€ä¸€èˆ¬çš„ãªåˆ†å‰²æ¼”ç®—ã®ä¸€ä¾‹ã¨ã—ã¦è¡¨ã›ã‚‹ã€‚
æ¬¡ã®ã‚ˆã†ãªæ€§è³ªã‚’æŒã¤ã€<tt>split</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’å®šç¾©ã›ã‚ˆâ€”â€”ã™ãªã‚ã¡ã€ãã®æ€§è³ªã¨ã¯ã€ä»¥ä¸‹ã®ã‚‚ã®ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ã§ã€
</p>

<p class="lisp">(define right-split (split beside below))
(define up-split (split below beside))
</p>

<p class="orig" lang="en">
produces procedures <tt>right-split</tt> and <tt>up-split</tt> with the same
behaviors as the ones already defined.
</p>

<p class="trans" lang="ja">
å®šç¾©æ¸ˆã¿ã®ã‚‚ã®ã¨åŒã˜æŒ¯ã‚‹èˆã„ã‚’ã™ã‚‹ã‚ˆã†ãªã€<tt>right-split</tt> ã¨ <tt>up-split</tt> ã¨ã„ã†æ‰‹ç¶šããŒä½œã‚Šå‡ºã•ã‚Œã‚‹ã€ã¨ã„ã†æ€§è³ªã§ã‚ã‚‹ã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_Temp_210"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_210">Frames</a></h4>
<h4 class="trans" lang="ja">æ </h4>

<p class="orig" lang="en"><a name="%_idx_1910"></a>
Before we can show how to implement painters and their
means of combination, we must first consider
<a name="%_idx_1912"></a>frames.  A frame can be described by three vectors -- an origin vector
and two edge vectors.  The origin vector specifies the offset of the
frame's origin from some absolute origin in the plane, and the edge
vectors specify the offsets of the frame's corners from its origin.
If the edges are perpendicular, the frame will be rectangular.
Otherwise the frame will be a more general parallelogram.</p>

<p class="trans" lang="ja">
ãƒšã‚¤ãƒ³ã‚¿ã®å®Ÿè£…ã®ä»•æ–¹ã¨ã€ãƒšã‚¤ãƒ³ã‚¿åŒå£«ã®çµåˆã®æ‰‹æ®µã¨ã‚’ç§ãŸã¡ãŒç¤ºã›ã‚‹å‰ã«ã€ç§ãŸã¡ã¯ã¾ãšã€æ ã«ã¤ã„ã¦è€ƒãˆã­ã°ãªã‚‰ãªã„ã€‚
æ ã¯ã€ä¸‰ã¤ã®ãƒ™ã‚¯ãƒˆãƒ«â€”â€”åŸç‚¹ãƒ™ã‚¯ãƒˆãƒ«ã¨ã€äºŒã¤ã®è¾ºãƒ™ã‚¯ãƒˆãƒ«â€”â€”ã§è¨˜è¿°ã§ãã‚‹ã€‚
åŸç‚¹ãƒ™ã‚¯ãƒˆãƒ«ã¯ã€å¹³é¢å†…ã®ä½•ã‚‰ã‹ã®çµ¶å¯¾çš„åŸç‚¹ã‹ã‚‰ã®ã€æ ã®åŸç‚¹ã®ãšã‚Œã‚’æŒ‡å®šã—ã€è¾ºãƒ™ã‚¯ãƒˆãƒ«ã¯ã€æ ã®åŸç‚¹ã‹ã‚‰ã®ã€æ ã®è§’ã®ãšã‚Œã‚’æŒ‡å®šã™ã‚‹ã€‚
ã‚‚ã—ã€ãã‚Œã‚‰ã®è¾ºåŒå£«ãŒç›´è§’ã‚’ãªã—ã¦ã„ã‚‹ãªã‚‰ã€ãã®æ ã¯ã€é•·æ–¹å½¢ã«ãªã‚‹ã ã‚ã†ã€‚
ãã‚Œä»¥å¤–ã®å ´åˆã¯ã€ãã®æ ã¯ã€ã‚ˆã‚Šä¸€èˆ¬çš„ãªå¹³è¡Œå››è¾ºå½¢ã«ãªã‚‹ã ã‚ã†ã€‚
</p>

<p class="orig" lang="en">Figure <a href="#%_fig_2.15">2.15</a> shows a frame and its associated vectors.  In
accordance with data abstraction, we need not be
specific yet about how frames are represented, other than to say that
there is a constructor <a name="%_idx_1914"></a><tt>make-frame</tt>, which takes three vectors and
produces a frame, and three corresponding selectors <a name="%_idx_1916"></a><tt>origin-frame</tt>, <a name="%_idx_1918"></a><tt>edge1-frame</tt>, and <a name="%_idx_1920"></a><tt>edge2-frame</tt> (see
exercise <a href="#%_thm_2.47">2.47</a>).</p>

<p class="trans" lang="ja">
å›³<a href="#%_fig_2.15">2.15</a>ã¯ã€æ ã¨ã€ãã®æ ã«é–¢é€£ã¥ã‘ã‚‰ã‚ŒãŸãƒ™ã‚¯ãƒˆãƒ«ã‚’ã€ç¤ºã—ã¦ã„ã‚‹ã€‚
ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ã«ã—ãŸãŒã†ã¨ã€ç§ãŸã¡ã¯ã€æ ãŒã©ã®ã‚ˆã†ã«è¡¨ç¾ã•ã‚Œã‚‹ã®ã‹ã¨ã„ã†ã“ã¨ã«ã¤ã„ã¦ã¯ã€<tt>make-frame</tt> ã¨ã„ã†ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿â€”â€”ä¸‰ã¤ã®ãƒ™ã‚¯ãƒˆãƒ«ã‚’å–ã£ã¦æ ã‚’ä½œã‚Šå‡ºã™â€”â€”ã¨ã€ä¸‰ã¤ã®å¯¾å¿œã™ã‚‹ã‚»ãƒ¬ã‚¯ã‚¿ãŸã‚‹ <tt>origin-frame</tt> ã¨ <tt>edge1-frame</tt> ã¨ <tt>edge2-frame</tt> ã¨ãŒå­˜åœ¨ã™ã‚‹ã€ã¨è¿°ã¹ã‚‹ã“ã¨ã‚’é™¤ã„ã¦ã€ã¾ã æ˜ç¢ºã«è¨€ã†å¿…è¦ã¯ãªã„ (ç·´ç¿’å•é¡Œ<a href="#%_thm_2.47">2.47</a>ã‚’å‚ç…§)ã€‚
</p>

<a name="%_fig_2.15"></a>
<figure>
<img src="ch2-Z-G-42.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 2.15:</b>  A frame is described by three vectors -- an
origin and two edges.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³2.15:</b> æ ã¯ã€ä¸‰ã¤ã®ãƒ™ã‚¯ãƒˆãƒ«â€”â€”åŸç‚¹ã¨äºŒã¤ã®è¾ºâ€”â€”ã«ã‚ˆã‚Šè¨˜è¿°ã•ã‚Œã‚‹ã€‚</figcaption>
</figure>

<p class="orig" lang="en"><a name="%_idx_1922"></a>We will use coordinates in the unit square (0<u>&lt;</u> <em>x</em>,<em>y</em><u>&lt;</u> 1)
to specify images.
With each frame, we associate a <a name="%_idx_1924"></a><em>frame coordinate map</em>, which
will be used to shift and scale images to fit the frame.  The map
transforms the unit square into the frame by
mapping the vector <strong><em>v</em></strong> = (<em>x</em>,<em>y</em>) to the vector sum</p>

<p class="trans" lang="ja">
ç”»åƒã‚’æŒ‡å®šã™ã‚‹ã®ã«ã€å˜ä½æ­£æ–¹å½¢
<span class="math">(0 &le; <em class="en">x</em>,<em class="en">y</em> &le; 1)</span>
å†…ã®åº§æ¨™ã‚’ä½¿ãŠã†ã€‚
ãã‚Œãã‚Œã®æ ã«ã€ç§ãŸã¡ã¯ã€<em>æ åº§æ¨™å†™åƒ</em>â€”â€”ãã®æ ã«åˆã†ã‚ˆã†ã«ç”»åƒã‚’ç§»å‹•ã—ãŸã‚Šå¤‰å€ã—ãŸã‚Šã™ã‚‹ã®ã«ä½¿ã‚ã‚Œã‚‹ã ã‚ã†â€”â€”ã‚’å¯¾å¿œã¥ã‘ã‚‹ã€‚
ãã®å†™åƒã¯ã€
<span class="math"><strong><em class="en">v</em></strong> = (<em class="en">x</em>,<em class="en">y</em>)</span>
ã¨ã„ã†ãƒ™ã‚¯ãƒˆãƒ«ã‚’ã€ä»¥ä¸‹ã®ãƒ™ã‚¯ãƒˆãƒ«å’Œã«å†™åƒã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€å˜ä½æ­£æ–¹å½¢ã‚’æ ã¸ã¨å¤‰å½¢ã™ã‚‹ã€‚
</p>

<figure><img src="ch2-Z-G-43.gif" border="0"></figure>

<p class="orig" lang="en">
For example, (0,0) is mapped to the origin of the frame, (1,1) to
the vertex diagonally opposite the origin, and (0.5,0.5) to the
center of the frame.  We can create a frame's coordinate map with the
following procedure:<a name="call_footnote_Temp_211" href="#footnote_Temp_211"><sup><small>26</small></sup></a></p>

<p class="trans" lang="ja">
ãŸã¨ãˆã°ã€
<span class="math">(0, 0)</span> ã¯ã€æ ã®åŸç‚¹ã«å†™åƒã•ã‚Œã€
<span class="math">(1, 1)</span> ã¯ã€å¯¾è§’ç·šä¸Šã§åŸç‚¹ã¨é€†å´ã®é ‚ç‚¹ã«å†™åƒã•ã‚Œã€
<span class="math">(0.5, 0.5)</span> ã¯ã€æ ã®ä¸­å¿ƒã«å†™åƒã•ã‚Œã‚‹ã€‚
ç§ãŸã¡ã¯ã€ä»¥ä¸‹ã®æ‰‹ç¶šãã‚’ä½¿ã£ã¦ã€æ ã®åº§æ¨™å†™åƒã‚’ä½œã‚Œã‚‹<a href="#footnote_Temp_211"><sup><small>26</small></sup></a>ã€‚
</p>

<p class="lisp"><a name="%_idx_1926"></a>(define (frame-coord-map frame)
  (lambda (v)
    (add-vect
     (origin-frame frame)
     (add-vect (scale-vect (xcor-vect v)
                           (edge1-frame frame))
               (scale-vect (ycor-vect v)
                           (edge2-frame frame))))))
</p>

<p class="orig" lang="en">
Observe that applying <tt>frame-coord-map</tt> to a frame returns
a procedure that, given a vector, returns a vector.
If the argument vector is in the unit square, the result vector
will be in the frame.  For example,</p>

<p class="trans" lang="ja">
<tt>frame-coord-map</tt> ã‚’æ ã«é©ç”¨ã™ã‚‹ã“ã¨ã§ã€ãƒ™ã‚¯ãƒˆãƒ«ãŒä¸ãˆã‚‰ã‚Œã‚‹ã¨ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¿”ã™ã‚ˆã†ãªæ‰‹ç¶šããŒè¿”ã•ã‚Œã‚‹ã€ã¨ã„ã†ã“ã¨ã«æ°—ã¥ã„ã¦ã»ã—ã„ã€‚
ã‚‚ã—å¼•æ•°ã®ãƒ™ã‚¯ãƒˆãƒ«ãŒå˜ä½æ­£æ–¹å½¢ã®ä¸­ã«ã‚ã‚Œã°ã€çµæœã®ãƒ™ã‚¯ãƒˆãƒ«ã¯æ ã®ä¸­ã«ã‚ã‚‹ã ã‚ã†ã€‚
ãŸã¨ãˆã°ã€ä»¥ä¸‹ã®ã‚‚ã®ã¯ã€
</p>

<p class="lisp">((frame-coord-map a-frame) (make-vect 0 0))
</p>

<p class="orig" lang="en">
returns the same vector as
</p>

<p class="trans" lang="ja">
ä»¥ä¸‹ã®ã‚‚ã®ã¨åŒã˜ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¿”ã™ã€‚
</p>

<p class="lisp">(origin-frame a-frame)
</p>

<p class="orig" lang="en"><a name="%_thm_2.46"></a>
<b>Exercise 2.46.</b>  <a name="%_idx_1928"></a><a name="%_idx_1930"></a>A two-dimensional vector <strong>v</strong> running from the origin to a point
can be represented as a pair
consisting of an <em>x</em>-coordinate and a <em>y</em>-coordinate.  Implement a data
abstraction for vectors by giving a constructor <a name="%_idx_1932"></a><tt>make-vect</tt> and
corresponding selectors <a name="%_idx_1934"></a><tt>xcor-vect</tt> and <a name="%_idx_1936"></a><tt>ycor-vect</tt>.  In
terms of your selectors and constructor, implement procedures <a name="%_idx_1938"></a><tt>add-vect</tt>, <a name="%_idx_1940"></a><tt>sub-vect</tt>, and <a name="%_idx_1942"></a><tt>scale-vect</tt> that perform
the operations vector addition, vector subtraction, and multiplying a
vector by a scalar:</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.46.</b> åŸç‚¹ã‹ã‚‰ã‚ã‚‹ç‚¹ã¾ã§ã®äºŒæ¬¡å…ƒãƒ™ã‚¯ãƒˆãƒ« <strong>v</strong> ã¯ã€<em class="en">x</em> åº§æ¨™ã¨ <em class="en">y</em> åº§æ¨™ã‹ã‚‰ãªã‚‹å¯¾ã¨ã—ã¦è¡¨ç¾ã§ãã‚‹ã€‚
ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§ã‚ã‚‹ <tt>make-vect</tt> ã¨ã€å¯¾å¿œã™ã‚‹ã‚»ãƒ¬ã‚¯ã‚¿ã§ã‚ã‚‹ <tt>xcor-vect</tt> ãŠã‚ˆã³ <tt>ycor-vect</tt> ã‚’ä¸ãˆã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€ãƒ™ã‚¯ãƒˆãƒ«ç”¨ã®ãƒ‡ãƒ¼ã‚¿æŠ½è±¡ã‚’å®Ÿè£…ã›ã‚ˆã€‚
ãƒ™ã‚¯ãƒˆãƒ«åŠ ç®—ã¨ã€ãƒ™ã‚¯ãƒˆãƒ«æ¸›ç®—ã¨ã€ãƒ™ã‚¯ãƒˆãƒ«ã‚’ã‚¹ã‚«ãƒ©å€ã™ã‚‹ä¹—ç®—ã€ã¨ã„ã†æ¼”ç®—ã‚’è¡Œã†ã‚ˆã†ãªã€<tt>add-vect</tt> ã¨ <tt>sub-vect</tt> ã¨ <tt>scale-vect</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’ã€å›ã®ã‚»ãƒ¬ã‚¯ã‚¿ã¨ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’ä½¿ã£ã¦å®Ÿè£…ã›ã‚ˆã€‚
</p>

<figure><img src="ch2-Z-G-44.gif" border="0"></figure>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_2.47"></a>
<b>Exercise 2.47.</b>  Here are two possible constructors for frames:</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.47.</b> æ ã®ãŸã‚ã®å¯èƒ½ãªã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãŒã€ã“ã“ã«äºŒã¤ã‚ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_1944"></a>(define (make-frame origin edge1 edge2)
  (list origin edge1 edge2))

(define (make-frame origin edge1 edge2)
  (cons origin (cons edge1 edge2)))
</p>

<p class="orig" lang="en">
For each constructor supply the appropriate selectors to produce an
implementation for frames.
</p>

<p class="trans" lang="ja">
å„ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«å¯¾ã—ã¦ã€æ ã®å®Ÿè£…ã‚’ä½œã‚Šå‡ºã™ãŸã‚ã®é©åˆ‡ãªã‚»ãƒ¬ã‚¯ã‚¿ã‚’æä¾›ã›ã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_Temp_214"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_214">Painters</a></h4>
<h4 class="trans" lang="ja">ãƒšã‚¤ãƒ³ã‚¿</h4>

<p class="orig" lang="en"><a name="%_idx_1946"></a>
A painter is represented as a procedure that, given a frame
as argument, draws a particular image shifted and scaled to fit the frame.
That is to say, if <tt>p</tt> is a painter and <tt>f</tt> is a frame, then we
produce <tt>p</tt>'s image in <tt>f</tt> by calling <tt>p</tt> with <tt>f</tt> as
argument.</p>

<p class="trans" lang="ja">
æ ãŒå¼•æ•°ã¨ã—ã¦ä¸ãˆã‚‰ã‚ŒãŸã¨ãã«ã€ãã®æ ã«åˆã†ã‚ˆã†ã«ç§»å‹•ãƒ»å¤‰å€ã•ã‚ŒãŸç‰¹å®šã®ç”»åƒã‚’æãã‚ˆã†ãªæ‰‹ç¶šãã¨ã—ã¦ã€ãƒšã‚¤ãƒ³ã‚¿ã¯è¡¨ç¾ã•ã‚Œã‚‹ã€‚
ã¤ã¾ã‚Šã€ã‚‚ã— <tt>p</tt> ãŒãƒšã‚¤ãƒ³ã‚¿ã§ã‚ã‚Š <tt>f</tt> ãŒæ ã§ã‚ã‚‹ãªã‚‰ã°ã€ç§ãŸã¡ã¯ã€<tt>f</tt> ã‚’å¼•æ•°ã¨ã—ã¦ <tt>p</tt> ã‚’å‘¼ã¶ã“ã¨ã§ã€<tt>f</tt> ã®ä¸­ã« <tt>p</tt> ã®ç”»åƒã‚’ä½œã‚Šå‡ºã™ã€‚
</p>

<p class="orig" lang="en">The details of how primitive painters are implemented depend on the
particular characteristics of the graphics system and the type of
image to be drawn.  For instance, suppose we have a procedure <a name="%_idx_1948"></a><tt>draw-line</tt> that draws a line on the screen between two specified
points.  Then we can create painters for line drawings, such as the
<tt>wave</tt> painter in figure <a href="#%_fig_2.10">2.10</a>, from lists of line
segments as follows:<a name="call_footnote_Temp_215" href="#footnote_Temp_215"><sup><small>27</small></sup></a>
</p>

<p class="trans" lang="ja">
åŸå§‹çš„ãªãƒšã‚¤ãƒ³ã‚¿ãŒã©ã†å®Ÿè£…ã•ã‚Œã‚‹ã®ã‹ã¨ã„ã†è©³ç´°ã¯ã€ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ»ã‚·ã‚¹ãƒ†ãƒ ã®ç‰¹å®šã®æ€§è³ªã¨ã€æã‹ã‚Œã‚‹ã¹ãç”»åƒã®ç¨®é¡ã«ã€ä¾å­˜ã™ã‚‹ã€‚
ãŸã¨ãˆã°ã€ç”»é¢ä¸Šã§ã€æŒ‡å®šã•ã‚ŒãŸäºŒã¤ã®ç‚¹ã®é–“ã«ç·šã‚’å¼•ãã‚ˆã†ãªã€<tt>draw-line</tt> ã¨ã„ã†æ‰‹ç¶šããŒã‚ã‚‹ã¨ã—ã‚ˆã†ã€‚
ã™ã‚‹ã¨ã€å›³<a href="#%_fig_2.10">2.10</a>ã«ãŠã‘ã‚‹ <tt>wave</tt> ãƒšã‚¤ãƒ³ã‚¿ã®ã‚ˆã†ãªã€ç·šæç”¨ã®ãƒšã‚¤ãƒ³ã‚¿ã‚’ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ç·šåˆ†ã®ãƒªã‚¹ãƒˆã‹ã‚‰ä½œæˆã™ã‚‹ã“ã¨ãŒã§ãã‚‹<a href="#footnote_Temp_215"><sup><small>27</small></sup></a>ã€‚
</p>

<p class="lisp"><a name="%_idx_1950"></a>(define (segments-&gt;painter segment-list)
  (lambda (frame)
    (for-each
     (lambda (segment)
       (draw-line
        ((frame-coord-map frame) (start-segment segment))
        ((frame-coord-map frame) (end-segment segment))))
     segment-list)))
</p>

<p class="orig" lang="en">
The segments are given using coordinates with respect to the unit
square.  For each segment in the list, the painter transforms the
segment endpoints with the frame coordinate map and draws a line
between the transformed points.</p>

<p class="trans" lang="ja">
ç·šåˆ†ã¯ã€å˜ä½æ­£æ–¹å½¢ã«å¯¾ã™ã‚‹åº§æ¨™ã‚’ç”¨ã„ã¦ã€ä¸ãˆã‚‰ã‚Œã‚‹ã€‚
ãƒªã‚¹ãƒˆä¸­ã®å„ç·šåˆ†ã«å¯¾ã—ã¦ã€ãƒšã‚¤ãƒ³ã‚¿ã¯ã€æ åº§æ¨™å†™åƒã‚’ä½¿ã£ã¦ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã®ä¸¡ç«¯ç‚¹ã‚’å¤‰æ›ã—ã€å¤‰æ›ã—ãŸç‚¹åŒå£«ã®é–“ã«ç·šã‚’å¼•ãã€‚
</p>

<p class="orig" lang="en">Representing painters as procedures erects a powerful abstraction
barrier in the picture language.  We can create and intermix
all sorts of primitive painters, based on a variety of graphics
capabilities. The details of their implementation do not matter.  Any
procedure can serve as a painter, provided that it takes a frame as
argument and draws something scaled to fit the frame.<a name="call_footnote_Temp_216" href="#footnote_Temp_216"><sup><small>28</small></sup></a></p>

<p class="trans" lang="ja">
ãƒšã‚¤ãƒ³ã‚¿ã‚’æ‰‹ç¶šãã¨ã—ã¦è¡¨ã™ã“ã¨ã§ã€ãŠçµµæãè¨€èªã«ã¯ã€å¼·åŠ›ãªæŠ½è±¡åŒ–ã®é˜²å£ãŒæ‰“ã¡ç«‹ã¦ã‚‰ã‚Œã‚‹ã€‚
æ§˜ã€…ãªã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹æ€§èƒ½ã«åŸºã¥ã„ã¦ã€ç§ãŸã¡ã¯ã€ã‚ã‚‰ã‚†ã‚‹ç¨®é¡ã®åŸå§‹çš„ãƒšã‚¤ãƒ³ã‚¿ã‚’ä½œæˆã§ãã‚‹ã—ã€æ··ãœåˆã‚ã›ã‚‰ã‚Œã‚‹ã€‚
ãã‚Œã‚‰æ§˜ã€…ãªã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹æ€§èƒ½ã®å®Ÿè£…ã®è©³ç´°ã¯ã€é‡è¦ã§ã¯ãªã„ã€‚
ä»»æ„ã®æ‰‹ç¶šãã¯ã€ãƒšã‚¤ãƒ³ã‚¿ã¨ã—ã¦æ©Ÿèƒ½ã§ãã‚‹â€”â€”å¼•æ•°ã¨ã—ã¦æ ã‚’å–ã‚Šã€ãã®æ ã«åˆã†ã‚ˆã†ã«å¤‰å€ã—ãŸä½•ã‹ã‚’æãé™ã‚Šã¯<a href="#footnote_Temp_216"><sup><small>28</small></sup></a>ã€‚
</p>

<p class="orig" lang="en">
<a name="%_thm_2.48"></a>
<b>Exercise 2.48.</b>  <a name="%_idx_1952"></a>A directed line segment in the
plane can be represented as a pair of vectors -- the
vector running from the origin to the start-point of the segment, and
the vector running from the origin to the end-point of the segment.
Use your vector representation from exercise <a href="#%_thm_2.46">2.46</a> to
define a representation for segments with a constructor <a name="%_idx_1954"></a><tt>make-segment</tt> and selectors <a name="%_idx_1956"></a><tt>start-segment</tt> and <a name="%_idx_1958"></a><tt>end-segment</tt>.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.48.</b> å¹³é¢ä¸Šã®æœ‰å‘ç·šåˆ†ã¯ã€ãƒ™ã‚¯ãƒˆãƒ«â€”â€”åŸç‚¹ã‹ã‚‰ç·šåˆ†ã®å§‹ç‚¹ã¾ã§ã®ãƒ™ã‚¯ãƒˆãƒ«ã¨ã€åŸç‚¹ã‹ã‚‰ç·šåˆ†ã®çµ‚ç‚¹ã¾ã§ã®ãƒ™ã‚¯ãƒˆãƒ«â€”â€”ã®å¯¾ã¨ã—ã¦è¡¨ã›ã‚‹ã€‚
<tt>make-segment</tt> ã¨ã„ã†ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¨ã€<tt>start-segment</tt> ãŠã‚ˆã³ <tt>end-segment</tt> ã¨ã„ã†ã‚»ãƒ¬ã‚¯ã‚¿ã‚’æœ‰ã™ã‚‹ã‚ˆã†ãªã€ç·šåˆ†ç”¨ã®è¡¨ç¾ã‚’ã€ç·´ç¿’å•é¡Œ<a href="#%_thm_2.46">2.46</a>ã§ã®å›ã®ãƒ™ã‚¯ãƒˆãƒ«è¡¨ç¾ã‚’ä½¿ã£ã¦ã€å®šç¾©ã›ã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_2.49"></a>
<b>Exercise 2.49.</b>  Use <tt>segments-&gt;painter</tt> to define the following primitive painters:</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.49.</b> <tt>segments-&gt;painter</tt> ã‚’ç”¨ã„ã¦ã€ä»¥ä¸‹ã®åŸå§‹çš„ãƒšã‚¤ãƒ³ã‚¿ã‚’å®šç¾©ã›ã‚ˆã€‚
</p>

<ol class="orig" lang="en" style="list-style-type: lower-alpha">
<li>The painter that draws the outline of the designated frame.</li>
<li>The painter that draws an ``X'' by connecting opposite corners of
the frame.</li>
<li>The painter that draws a diamond shape by connecting the midpoints of
the sides of the frame.</li>
<li>The <tt>wave</tt> painter.</li>
</ol>

<ol class="trans" lang="ja" style="list-style-type: lower-alpha">
<li>æŒ‡å®šã•ã‚ŒãŸæ ã®è¼ªéƒ­ã‚’æããƒšã‚¤ãƒ³ã‚¿ã€‚</li>
<li>æ ã®ã€å‘ã‹ã„åˆã†è§’åŒå£«ã‚’çµã¶ã“ã¨ã§ã€ŒXã€ã‚’æããƒšã‚¤ãƒ³ã‚¿ã€‚</li>
<li>æ ã®è¾ºã®ä¸­ç‚¹åŒå£«ã‚’çµã¶ã“ã¨ã§ãƒ€ã‚¤ãƒ¤å½¢ã‚’æããƒšã‚¤ãƒ³ã‚¿ã€‚</li>
<li><tt>wave</tt> ãƒšã‚¤ãƒ³ã‚¿ã€‚</li>
</ol>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_Temp_219"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_219">Transforming and combining painters</a></h4>
<h4 class="trans" lang="ja">ãƒšã‚¤ãƒ³ã‚¿ã‚’å¤‰å½¢ã—çµåˆã™ã‚‹</h4>

<p class="orig" lang="en"><a name="%_idx_1960"></a>
An operation on painters (such as <tt>flip-vert</tt> or <tt>beside</tt>)
works by creating a painter that invokes the original painters
with respect to frames derived from the argument frame.
Thus, for example, <tt>flip-vert</tt> doesn't have to know how a painter
works in order to flip it -- it just has to know how to turn a frame
upside down:
The flipped painter just uses the original painter,
but in the inverted frame.</p>

<p class="trans" lang="ja">
ãƒšã‚¤ãƒ³ã‚¿ã«å¯¾ã™ã‚‹ (<tt>flip-vert</tt> ã‚ã‚‹ã„ã¯ <tt>beside</tt> ã®ã‚ˆã†ãª) æ¼”ç®—ã¯ã€å¼•æ•°ã®æ ã‹ã‚‰å°å‡ºã•ã‚Œã‚‹æ ã«å¯¾ã—ã¦å…ƒã®ãƒšã‚¤ãƒ³ã‚¿ã‚’å‘¼ã³å‡ºã™ã‚ˆã†ãªãƒšã‚¤ãƒ³ã‚¿ã‚’ä½œæˆã™ã‚‹ã“ã¨ã§ã€å‹•ä½œã™ã‚‹ã€‚
ã‚ˆã£ã¦ã€ãŸã¨ãˆã° <tt>flip-vert</tt> ã¯ã€ãƒšã‚¤ãƒ³ã‚¿ãŒè‡ªèº«ã‚’ã²ã£ãã‚Šè¿”ã™ãŸã‚ã«ã©ã®ã‚ˆã†ã«å‹•ä½œã™ã‚‹ã®ã‹ã«ã¤ã„ã¦ã€çŸ¥ã‚‰ãªãã¦ã‚ˆã„
â€”â€”ãŸã ã€æ ã‚’ã©ã†ã‚„ã£ã¦ä¸Šä¸‹ã•ã‹ã•ã¾ã«ã™ã‚‹ã®ã‹ã•ãˆã€çŸ¥ã£ã¦ã„ã‚Œã°ã‚ˆã„ã®ã§ã‚ã‚‹ã€‚
ã²ã£ãã‚Šè¿”ã•ã‚ŒãŸãƒšã‚¤ãƒ³ã‚¿ã¯ã€å˜ã«å…ƒã®ãƒšã‚¤ãƒ³ã‚¿ã‚’ä½¿ã†ã ã‘ã§ã‚ã‚‹â€”â€”ãŸã ã—ã€è£è¿”ã—ã«ãªã£ãŸæ ã®ä¸­ã§ã€ã§ã¯ã‚ã‚‹ãŒã€‚</p>

<p class="orig" lang="en">Painter operations are based on
the procedure <tt>transform-painter</tt>, which takes as arguments a painter and
information on how to transform a frame and
produces a new painter.  The transformed painter, when called on a frame,
transforms the frame and
calls the original painter on the transformed frame.
The arguments to <tt>transform-painter</tt> are points (represented as vectors)
that specify the corners of the new frame:
When mapped into
the frame, the first point specifies the new frame's origin
and the other two specify the ends of its edge vectors.
Thus, arguments within the
unit square specify a frame contained within the original frame.</p>

<p class="trans" lang="ja">
ãƒšã‚¤ãƒ³ã‚¿æ¼”ç®—ã¯ã€<tt>transform-painter</tt> ã¨ã„ã†æ‰‹ç¶šãã«åŸºã¥ã„ã¦ã„ã¦ã€ã“ã®æ‰‹ç¶šãã¯ã€å¼•æ•°ã¨ã—ã¦ã€ãƒšã‚¤ãƒ³ã‚¿ã¨ã€æ ã‚’ã©ã†å¤‰å½¢ã™ã‚‹ã®ã‹ã«ã¤ã„ã¦ã®æƒ…å ±ã‚’å–ã‚Šã€æ–°ãŸãªãƒšã‚¤ãƒ³ã‚¿ã‚’ä½œã‚Šå‡ºã™ã€‚
å¤‰å½¢ã•ã‚ŒãŸãƒšã‚¤ãƒ³ã‚¿ã¯ã€ã‚ã‚‹æ ã«ã¤ã„ã¦å‘¼ã°ã‚Œã‚‹ã¨ã€ãã®æ ã‚’å¤‰å½¢ã—ã€å¤‰å½¢ã—ãŸæ ã«ã¤ã„ã¦å…ƒã®ãƒšã‚¤ãƒ³ã‚¿ã‚’å‘¼ã³å‡ºã™ã€‚
<tt>transform-painter</tt> ã«å¯¾ã™ã‚‹å¼•æ•°ã¯ã€æ–°ãŸãªæ ã®è§’ã‚’æŒ‡å®šã™ã‚‹ç‚¹ (ãƒ™ã‚¯ãƒˆãƒ«ã¨ã—ã¦è¡¨ã•ã‚Œã¦ã„ã‚‹) ã§ã‚ã‚‹ã€‚
ã¤ã¾ã‚Šã€ãã®æ ã®ä¸­ã«å†™åƒã•ã‚ŒãŸã¨ãã«ã€1ç•ªç›®ã®ç‚¹ã¯æ–°ãŸãªæ ã®åŸç‚¹ã‚’æŒ‡å®šã—ã€æ®‹ã‚Šã®äºŒã¤ã¯æ–°ãŸãªæ ã®è¾ºãƒ™ã‚¯ãƒˆãƒ«ã®ç«¯ã‚’æŒ‡å®šã™ã‚‹ã€‚
ã‚ˆã£ã¦ã€å˜ä½æ­£æ–¹å½¢ã®ä¸­ã«åã¾ã‚‹å¼•æ•°ã¯ã€å…ƒã®æ ã®ä¸­ã«å«ã¾ã‚Œã‚‹æ ã‚’æŒ‡å®šã™ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_1962"></a>(define (transform-painter painter origin corner1 corner2)
  (lambda (frame)
    (let ((m (frame-coord-map frame)))
      (let ((new-origin (m origin)))
        (painter
         (make-frame new-origin
                     (sub-vect (m corner1) new-origin)
                     (sub-vect (m corner2) new-origin)))))))
</p>

<p class="orig" lang="en">Here's how to flip painter images vertically:</p>

<p class="trans" lang="ja">
ã“ã“ã«ã€ãƒšã‚¤ãƒ³ã‚¿ç”»åƒã‚’ç¸¦ã«ã²ã£ãã‚Šè¿”ã™æ–¹æ³•ã‚’ç¤ºã™ã€‚
</p>

<p class="lisp"><a name="%_idx_1964"></a>(define (flip-vert painter)
  (transform-painter painter
                     (make-vect 0.0 1.0)   <em>; new <tt>origin</tt></em>
                     (make-vect 1.0 1.0)   <em>; new end of <tt>edge1</tt></em>
                     (make-vect 0.0 0.0))) <em>; new end of <tt>edge2</tt></em>
</p>

<p class="orig" lang="en">
Using <tt>transform-painter</tt>, we can easily define new transformations.
For example, we can define a painter that shrinks its image to the
upper-right quarter of the frame it is given:</p>

<p class="trans" lang="ja">
<tt>transform-painter</tt> ã‚’ä½¿ã†ã¨ã€æ–°ã—ã„å¤‰å½¢ã‚’ç°¡å˜ã«å®šç¾©ã§ãã‚‹ã€‚
ãŸã¨ãˆã°ã€è‡ªåˆ†ã®ç”»åƒã‚’ã€è‡ªåˆ†ã«ä¸ãˆã‚‰ã‚ŒãŸæ ã®å³ä¸Šã®å››åˆ†ã®ä¸€ã¸ã¨ç¸®ã‚ã‚‹ã‚ˆã†ãªãƒšã‚¤ãƒ³ã‚¿ã‚’ã€å®šç¾©ã§ãã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_1966"></a>(define (shrink-to-upper-right painter)
  (transform-painter painter
                     (make-vect 0.5 0.5)
                     (make-vect 1.0 0.5)
                     (make-vect 0.5 1.0)))
</p>

<p class="orig" lang="en">
Other transformations rotate images counterclockwise by 90 degrees<a name="call_footnote_Temp_220" href="#footnote_Temp_220"><sup><small>29</small></sup></a></p>

<p class="trans" lang="ja">
ä»–ã®å¤‰å½¢ã¯ã€åæ™‚è¨ˆå›ã‚Šã«90åº¦ã€ç”»åƒã‚’å›è»¢ã™ã‚‹<a href="#footnote_Temp_220"><sup><small>29</small></sup></a>ã‹ã€
</p>

<p class="lisp"><a name="%_idx_1968"></a>(define (rotate90 painter)
  (transform-painter painter
                     (make-vect 1.0 0.0)
                     (make-vect 1.0 1.0)
                     (make-vect 0.0 0.0)))
</p>

<p class="orig" lang="en">
or squash images towards the center of the frame:<a name="call_footnote_Temp_221" href="#footnote_Temp_221"><sup><small>30</small></sup></a></p>

<p class="trans" lang="ja">
ã‚ã‚‹ã„ã¯ã€æ ã®ä¸­å¿ƒã«å‘ã‘ã¦ç”»åƒã‚’æŠ¼ã—è¾¼ã‚€<a href="#footnote_Temp_221"><sup><small>30</small></sup></a>ã€‚
</p>

<p class="lisp"><a name="%_idx_1970"></a>(define (squash-inwards painter)
  (transform-painter painter
                     (make-vect 0.0 0.0)
                     (make-vect 0.65 0.35)
                     (make-vect 0.35 0.65)))
</p>

<p class="orig" lang="en">Frame transformation is also the key to
defining means of combining two or more painters.
The <tt>beside</tt> procedure,
for example, takes two painters, transforms them
to paint in the left and right halves of an argument frame respectively,
and produces a new, compound painter.
When the compound painter is given a frame, it
calls the first transformed painter to paint in the left half of
the frame and calls the second transformed painter to paint in the
right half of the frame:</p>

<p class="trans" lang="ja">
æ ã®å¤‰å½¢ã¯ã€äºŒã¤ä»¥ä¸Šã®ãƒšã‚¤ãƒ³ã‚¿ã‚’çµåˆã™ã‚‹æ‰‹æ®µã‚’å®šç¾©ã™ã‚‹éµã§ã‚‚ã‚ã‚‹ã€‚
ãŸã¨ãˆã°ã€<tt>beside</tt> ã¨ã„ã†æ‰‹ç¶šãã¯ã€äºŒã¤ã®ãƒšã‚¤ãƒ³ã‚¿ã‚’å–ã‚Šã€ãã‚Œã‚‰ã‚’å¤‰å½¢ã—ã¦ã€å¼•æ•°ã®æ ã®å·¦åŠåˆ†ã¨å³åŠåˆ†ã‚’ãã‚Œãã‚Œæç”»ã—ã€æ–°ãŸãªè¤‡åˆãƒšã‚¤ãƒ³ã‚¿ã‚’ä½œã‚Šå‡ºã™ã€‚
ãã®è¤‡åˆãƒšã‚¤ãƒ³ã‚¿ã«æ ãŒä¸ãˆã‚‰ã‚Œã‚‹ã¨ã€ãã®è¤‡åˆãƒšã‚¤ãƒ³ã‚¿ã¯ã€å¤‰å½¢ã•ã‚ŒãŸ1ç•ªç›®ã®ãƒšã‚¤ãƒ³ã‚¿ã‚’å‘¼ã³å‡ºã—ã¦æ ã®å·¦åŠåˆ†ã‚’æç”»ã—ã€å¤‰å½¢ã•ã‚ŒãŸ2ç•ªç›®ã®ãƒšã‚¤ãƒ³ã‚¿ã‚’å‘¼ã³å‡ºã—ã¦æ ã®å³åŠåˆ†ã‚’æç”»ã™ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_1972"></a>(define (beside painter1 painter2)
  (let ((split-point (make-vect 0.5 0.0)))
    (let ((paint-left
           (transform-painter painter1
                              (make-vect 0.0 0.0)
                              split-point
                              (make-vect 0.0 1.0)))
          (paint-right
           (transform-painter painter2
                              split-point
                              (make-vect 1.0 0.0)
                              (make-vect 0.5 1.0))))
      (lambda (frame)
        (paint-left frame)
        (paint-right frame)))))
</p>

<p class="orig" lang="en">Observe how the painter data abstraction, and in particular the
representation of painters as procedures, makes <tt>beside</tt> easy to
implement.  The <tt>beside</tt> procedure need not know anything
about the details of the component painters other than that each
painter will draw something in its designated frame.</p>

<p class="trans" lang="ja">
ãƒšã‚¤ãƒ³ã‚¿ã®ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–â€”â€”ã¨ã‚Šã‚ã‘ã€æ‰‹ç¶šãã¨ã—ã¦ã®ãƒšã‚¤ãƒ³ã‚¿ã®è¡¨ç¾â€”â€”ãŒã€ã„ã‹ã« <tt>beside</tt> ã‚’å®Ÿè£…ã—ã‚„ã™ãã—ã¦ã„ã‚‹ã‹ã«ã€æ°—ã¥ã„ã¦ã»ã—ã„ã€‚
 <tt>beside</tt> ã®æ‰‹ç¶šãã¯ã€æ§‹æˆè¦ç´ ã®ãƒšã‚¤ãƒ³ã‚¿ã®è©³ç´°ã«ã¤ã„ã¦ã¯ã€å„ãƒšã‚¤ãƒ³ã‚¿ãŒå½“è©²ãƒšã‚¤ãƒ³ã‚¿ã«æŒ‡å®šã•ã‚ŒãŸæ ã®ä¸­ã«ä½•ã‹ã‚’æãã ã‚ã†ã€ã¨ã„ã†ã“ã¨ä»¥å¤–ã¯ã€ä½•ã‚‚çŸ¥ã‚‹å¿…è¦ãŒãªã„ã€‚
</p>

<p class="orig" lang="en"><a name="%_thm_2.50"></a>
<b>Exercise 2.50.</b>  Define the transformation <a name="%_idx_1974"></a><tt>flip-horiz</tt>, which flips
painters horizontally, and transformations that rotate
painters counterclockwise by 180 degrees and 270 degrees.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.50.</b> <tt>flip-horiz</tt> ã¨ã„ã†å¤‰å½¢â€”â€”ãƒšã‚¤ãƒ³ã‚¿ã‚’æ°´å¹³æ–¹å‘ã«ã²ã£ãã‚Šè¿”ã™â€”â€”ã¨ã€ãƒšã‚¤ãƒ³ã‚¿ã‚’åæ™‚è¨ˆå›ã‚Šã«180åº¦ãŠã‚ˆã³270åº¦å›è»¢ã™ã‚‹å¤‰å½¢ã‚’ã€å®šç¾©ã›ã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_2.51"></a>
<b>Exercise 2.51.</b>  Define the <a name="%_idx_1976"></a><tt>below</tt> operation for painters.  <tt>Below</tt> takes two
painters as arguments.  The resulting painter, given a frame,
draws with the first painter in the
bottom of the frame and with the second painter in the top.  Define <tt>below</tt> in two different ways -- first by writing a procedure that is
analogous to the <tt>beside</tt> procedure given above, and
again in terms of <tt>beside</tt> and suitable
rotation operations (from exercise <a href="#%_thm_2.50">2.50</a>).
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.51.</b> ãƒšã‚¤ãƒ³ã‚¿ç”¨ã® <tt>below</tt> ã¨ã„ã†æ¼”ç®—ã‚’å®šç¾©ã›ã‚ˆã€‚
<tt>below</tt> ã¯ã€äºŒã¤ã®ãƒšã‚¤ãƒ³ã‚¿ã‚’å¼•æ•°ã¨ã—ã¦å–ã‚‹ã€‚
çµæœã¨ã—ã¦ç”Ÿã˜ã‚‹ãƒšã‚¤ãƒ³ã‚¿ã¯ã€æ ã‚’ä¸ãˆã‚‰ã‚Œã‚‹ã¨ã€ãã®æ ã®ä¸‹å´ã«1ç•ªç›®ã®ãƒšã‚¤ãƒ³ã‚¿ã‚’ä½¿ã£ã¦æç”»ã—ã€ä¸Šå´ã«2ç•ªç›®ã®ãƒšã‚¤ãƒ³ã‚¿ã‚’ä½¿ã£ã¦æç”»ã™ã‚‹ã€‚
<tt>below</tt> ã‚’ã€äºŒã¤ã®ç•°ãªã‚‹æ–¹æ³•ã§å®šç¾©ã›ã‚ˆâ€”â€”ã¾ãšã¯ã€ä¸Šè¨˜ã® <tt>beside</tt> ã®æ‰‹ç¶šãã«é¡ä¼¼ã®æ‰‹ç¶šãã‚’æ›¸ãã“ã¨ã«ã‚ˆã£ã¦ã€ãã—ã¦ã€ã‚‚ã†ä¸€åº¦ã¯ã€<tt>beside</tt> ã¨ã€(ç·´ç¿’å•é¡Œ<a href="#%_thm_2.50">2.50</a>ã®) é©åˆ‡ãªå›è»¢ã¨ã‚’ç”¨ã„ã¦ã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_Temp_224"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_224">Levels of language for robust design</a></h4>
<h4 class="trans" lang="ja">é ‘å¥ãªè¨­è¨ˆã®ãŸã‚ã®è¨€èªã®è«¸æ°´æº–</h4>

<p class="orig" lang="en">The picture language exercises some of the critical ideas
we've introduced about abstraction with procedures and data.  The
fundamental data abstractions, painters, are implemented using
procedural representations, which enables the language to
handle different basic drawing capabilities in a uniform way.  The
means of combination satisfy the closure property, which permits us to
easily build up complex designs.  Finally, all the tools for
abstracting procedures are available to us for abstracting means of
combination for painters.</p>

<p class="trans" lang="ja">
ãŠçµµæãè¨€èªã¯ã€æ‰‹ç¶šãã¨ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ã£ãŸæŠ½è±¡åŒ–ã«ã¤ã„ã¦ç§ãŸã¡ãŒä»Šã¾ã§ã«å°å…¥ã—ã¦ããŸé‡è¦ãªæ¦‚å¿µã®ã„ãã¤ã‹ã‚’é›ãˆã¦ãã‚Œã‚‹ã€‚
åŸºæœ¬çš„ãªãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ã€ã™ãªã‚ã¡ãƒšã‚¤ãƒ³ã‚¿ã¯ã€æ‰‹ç¶šãçš„è¡¨ç¾ã‚’ä½¿ã£ã¦å®Ÿè£…ã•ã‚Œã¦ãŠã‚Šã€ãã®ã“ã¨ã«ã‚ˆã£ã¦ã€ã“ã®è¨€èªã¯ã€ç•°ãªã‚‹åŸºæœ¬çš„æç”»èƒ½åŠ›ã‚’ã€ä¸€å¾‹ãªã‚„ã‚Šæ–¹ã§æ‰±ã†ã“ã¨ãŒã§ãã‚‹ã‚ˆã†ã«ãªã£ã¦ã„ã‚‹ã€‚
çµåˆæ‰‹æ®µã¯é–‰åŒ…ç‰¹æ€§ã‚’æº€ãŸã—ã€ãã®ã“ã¨ã«ã‚ˆã£ã¦ã€ç§ãŸã¡ã¯ã€è¤‡é›‘ãªè¨­è¨ˆã‚’ç°¡å˜ã«ç¯‰ãä¸Šã’ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
æœ€å¾Œã«ã€æ‰‹ç¶šãã‚’æŠ½è±¡åŒ–ã™ã‚‹ãŸã‚ã®ã™ã¹ã¦ã®æ‰‹æ®µã¯ã€ç§ãŸã¡ãŒãƒšã‚¤ãƒ³ã‚¿ç”¨ã®çµåˆæ‰‹æ®µã‚’æŠ½è±¡åŒ–ã™ã‚‹ãŸã‚ã«åˆ©ç”¨å¯èƒ½ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
We have also obtained a glimpse of another crucial idea about
languages and program design.  This is the approach of <a name="%_idx_1978"></a><a name="%_idx_1980"></a><em>stratified
design</em>, the notion that a complex system should be structured as a
sequence of levels that are described using a sequence of languages.
Each level is constructed by combining parts that are regarded as
primitive at that level, and the parts constructed at each level are
used as primitives at the next level.  The language used at each level
of a stratified design has primitives, means of combination, and means
of abstraction appropriate to that level of detail.</p>

<p class="trans" lang="ja">
ç§ãŸã¡ã¯ã¾ãŸã€è¨€èªã¨ãƒ—ãƒ­ã‚°ãƒ©ãƒ è¨­è¨ˆã«ã¤ã„ã¦ã®åˆ¥ã®é‡è¦ãªæ¦‚å¿µã‚‚ã€å£é–“è¦‹ã¦ããŸã€‚
ã“ã‚Œã¯ã€<em>éšå±¤åŒ–ã•ã‚ŒãŸè¨­è¨ˆ</em>ã¨ã„ã†å–ã‚Šçµ„ã¿æ–¹â€”â€”ã¤ã¾ã‚Šã€è¤‡é›‘ãªã‚·ã‚¹ãƒ†ãƒ ã¯ã€è¨€èªã®åˆ—ã‚’ä½¿ã£ã¦è¨˜è¿°ã•ã‚Œã‚‹ã‚ˆã†ãªè«¸æ°´æº–ã®åˆ—ã¨ã—ã¦æ§‹ç¯‰ã•ã‚Œã‚‹ã¹ãã ã€ã¨ã„ã†è€ƒãˆæ–¹â€”â€”ã§ã‚ã‚‹ã€‚
å„æ°´æº–ã¯ã€ãã®æ°´æº–ã§åŸå§‹çš„ã¨è¦‹ãªã•ã‚Œã‚‹éƒ¨å“åŒå£«ã‚’çµåˆã™ã‚‹ã“ã¨ã§æ§‹ç¯‰ã•ã‚Œã€å„æ°´æº–ã§æ§‹ç¯‰ã•ã‚Œã‚‹éƒ¨å“ã¯ã€æ¬¡ã®æ°´æº–ã§ã¯ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã¨ã—ã¦ä½¿ã‚ã‚Œã‚‹ã€‚
éšå±¤åŒ–ã•ã‚ŒãŸè¨­è¨ˆã®å„æ°´æº–ã§ä½¿ã‚ã‚Œã‚‹è¨€èªã«ã¯ã€ãã®æ°´æº–ã®è©³ç´°ã•ã«å¯¾ã—ã¦é©åˆ‡ãªã€ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã¨çµåˆæ‰‹æ®µã¨æŠ½è±¡åŒ–æ‰‹æ®µãŒã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">Stratified design pervades the engineering of complex systems.  For
example, in computer engineering, resistors and transistors are
combined (and described using a language of analog circuits) to
produce parts such as and-gates and or-gates, which form the
primitives of a language for digital-circuit design.<a name="call_footnote_Temp_225" href="#footnote_Temp_225"><sup><small>31</small></sup></a>
These parts are combined to build
processors, bus structures, and memory systems, which are in turn
combined to form computers, using languages appropriate to computer
architecture.  Computers are combined to form distributed systems,
using languages appropriate for describing network interconnections,
and so on.</p>

<p class="trans" lang="ja">
éšå±¤åŒ–ã•ã‚ŒãŸè¨­è¨ˆã¯ã€è¤‡é›‘ãªã‚·ã‚¹ãƒ†ãƒ ã®å·¥å­¦ã®å…¨ä½“ã«æµ¸é€ã—ã¦ã„ã‚‹ã€‚
ãŸã¨ãˆã°ã€è¨ˆç®—æ©Ÿå·¥å­¦ã§ã¯ã€ãƒ¬ã‚¸ã‚¹ã‚¿ã‚„ãƒˆãƒ©ãƒ³ã‚¸ã‚¹ã‚¿ã¯ã€çµåˆã•ã‚Œ (ã‹ã¤ã€ã‚¢ãƒŠãƒ­ã‚°å›è·¯ã®è¨€è‘‰ã‚’ç”¨ã„ã¦è¨˜è¿°ã•ã‚Œ)ã€ANDã‚²ãƒ¼ãƒˆã‚„ORã‚²ãƒ¼ãƒˆãªã©ã®éƒ¨å“ã‚’ä½œã‚Šå‡ºã—ã€ã“ã‚Œã‚‰ã®éƒ¨å“ã¯ã€ãƒ‡ã‚£ã‚¸ã‚¿ãƒ«å›è·¯è¨­è¨ˆç”¨ã®è¨€èªã®ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã‚’å½¢æˆã™ã‚‹<a href="#footnote_Temp_225"><sup><small>31</small></sup></a>ã€‚
ã“ã‚Œã‚‰ã®éƒ¨å“ã¯ã€çµåˆã•ã‚Œã¦ã€ãƒ—ãƒ­ã‚»ãƒƒã‚µã‚„ãƒã‚¹æ§‹é€ ã‚„ãƒ¡ãƒ¢ãƒªã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰ã—ã€ä»Šåº¦ã¯ãã‚Œã‚‰ãŒã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã‚’å½¢æˆã™ã‚‹ãŸã‚ã«ã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ»ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã«é©ã—ãŸè¨€èªã‚’ä½¿ã£ã¦çµåˆã•ã‚Œã‚‹ã€‚
ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã¯ã€åˆ†æ•£ã‚·ã‚¹ãƒ†ãƒ ã‚’å½¢æˆã™ã‚‹ãŸã‚ã«ã€ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã®ç›¸äº’é€£çµã‚’è¨˜è¿°ã™ã‚‹ã®ã«é©ã—ãŸè¨€èªã‚’ç”¨ã„ã¦çµåˆã•ã‚Œã‚‹â€¦â€¦ãªã©ãªã©ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">As a tiny example of stratification, our picture language uses
primitive elements (primitive painters) that are created using a
language that specifies points and lines to provide the lists of line
segments for <tt>segments-&gt;painter</tt>, or the
shading details for a painter like <tt>rogers</tt>.  The bulk of our
description of the picture language focused on combining these
primitives, using geometric combiners such as <tt>beside</tt> and <tt>below</tt>.  We also worked at a higher level, regarding <tt>beside</tt> and
<tt>below</tt> as primitives to be manipulated in a language whose
operations, such as <tt>square-of-four</tt>, capture common patterns of
combining geometric combiners.</p>

<p class="trans" lang="ja">
éšå±¤åŒ–ã®ã»ã‚“ã®å°ã•ãªä¾‹ã¨ã—ã¦ã€ç§ãŸã¡ã®ãŠçµµæãè¨€èªã¯ã€<tt>segments-&gt;painter</tt> ã«ç·šåˆ†ã®ãƒªã‚¹ãƒˆã‚’ä¸ãˆã‚‹ãŸã‚ã«ç‚¹ã¨ç·šã‚’æŒ‡å®šã™ã‚‹è¨€èªã‚’ä½¿ã£ã¦ä½œæˆã•ã‚Œã‚‹åŸå§‹çš„è¦ç´  (åŸå§‹çš„ãƒšã‚¤ãƒ³ã‚¿) ã‚’ä½¿ã†ã—ã€ã‚ã‚‹ã„ã¯ã€<tt>rogers</tt> ã®ã‚ˆã†ãªãƒšã‚¤ãƒ³ã‚¿ã«æ¿ƒæ·¡ä»˜ã‘ã®è©³ç´°ã‚’ä¸ãˆã‚‹ãŸã‚ã«äº‘ã€…ã¨ã„ã£ãŸåŸå§‹çš„è¦ç´  (åŸå§‹çš„ãƒšã‚¤ãƒ³ã‚¿) ã‚’ä½¿ã†ã€‚<!--è¦æ¤œè¨-->
ãŠçµµæãè¨€èªã«ã¤ã„ã¦ã®ç§ãŸã¡ã®èª¬æ˜ã®å¤§éƒ¨åˆ†ã¯ã€ã“ã‚Œã‚‰ã®ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–åŒå£«ã‚’çµåˆã™ã‚‹ã“ã¨ã«å¯¾ã—ã¦ç„¦ç‚¹ã‚’å½“ã¦ã¦ã„ãŸã‚ã‘ã ãŒã€ãã“ã§ã¯ã€<tt>beside</tt> ã‚„ <tt>below</tt> ã®ã‚ˆã†ãªå¹¾ä½•çš„çµåˆå­ã‚’ç”¨ã„ã¦ã„ãŸã€‚
ç§ãŸã¡ã¯ã€ã‚ˆã‚Šé«˜ã„æ°´æº–ã§ã‚‚ä½œæ¥­ã—ãŸâ€”â€”ã¤ã¾ã‚Šã€ãã®è¨€èªã®æ¼”ç®— (<tt>square-of-four</tt> ãªã©) ãŒã€å¹¾ä½•çš„çµåˆå­åŒå£«ã‚’çµåˆã™ã‚‹å…±é€šã®ãƒ‘ã‚¿ãƒ³ã‚’æ‰ãˆã‚‹ã€ã¨ã„ã£ãŸã‚ˆã†ãªè¨€èªã«ãŠã„ã¦ã€æ“ä½œã•ã‚Œã‚‹ã¹ããƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã ã€ã¨ã„ã†ãµã†ã«ã€<tt>beside</tt> ã‚„ <tt>below</tt> ã‚’è¦‹ãªã—ãŸã‚ã‘ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="%_idx_1982"></a>Stratified design helps make programs <em>robust</em>, that is, it makes
it likely that small changes in a specification will require
correspondingly small changes in the program.  For instance, suppose
we wanted to change the image based on <tt>wave</tt> shown in
figure <a href="#%_fig_2.9">2.9</a>.  We could work at the lowest level
to change the detailed appearance of the <tt>wave</tt> element; we could
work at the middle level to change the way <tt>corner-split</tt>
replicates the <tt>wave</tt>; we could work at the highest level to
change how <tt>square-limit</tt> arranges the four copies of the corner.
In general, each level of a stratified design provides a different
vocabulary for expressing the characteristics of the system, and a
different kind of ability to change it.</p>

<p class="trans" lang="ja">
éšå±¤åŒ–ã•ã‚ŒãŸè¨­è¨ˆã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’<em>é ‘å¥</em>ã«ã™ã‚‹ã®ã«å½¹ç«‹ã¤ã€‚ã¤ã¾ã‚Šã€ä»•æ§˜ã«ãŠã‘ã‚‹å°ã•ãªå¤‰æ›´ã¯ã€ãã‚Œã«å¯¾å¿œã™ã‚‹ã‚ˆã†ã«å°ã•ãªå¤‰æ›´ã—ã‹ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ãŠã„ã¦å¿…è¦ã¨ã—ãªã„ã ã‚ã†ã€ã¨ã„ã†è¦‹è¾¼ã¿ãŒã€éšå±¤åŒ–ã•ã‚ŒãŸè¨­è¨ˆã‚’ã™ã‚Œã°ã€é«˜ã„ã‚ã‘ã§ã‚ã‚‹ã€‚
ãŸã¨ãˆã°ã€å›³<a href="#%_fig_2.9">2.9</a>ã«ç¤ºã—ãŸ <tt>wave</tt> ã«åŸºã¥ãç”»åƒã‚’å¤‰æ›´ã—ãŸã„ã¨ã™ã‚‹ã€‚
ã‚‚ã£ã¨ã‚‚ä½ã„æ°´æº–ã§ã¯ã€<tt>wave</tt> è¦ç´ ã®è©³ç´°ãªå¤–è¦³ã‚’å¤‰æ›´ã™ã‚‹ã‚ˆã†ã«ã€ä½œæ¥­ã§ãã‚‹ã“ã¨ã ã‚ã†ã€‚ä¸­é–“ã®æ°´æº–ã§ã¯ã€<tt>corner-split</tt> ãŒ <tt>wave</tt> ã‚’è¤‡è£½ã™ã‚‹æ–¹æ³•ã‚’å¤‰æ›´ã™ã‚‹ã‚ˆã†ã«ã€ä½œæ¥­ã§ãã‚‹ã“ã¨ã ã‚ã†ã€‚ã‚‚ã£ã¨ã‚‚é«˜ã„æ°´æº–ã§ã¯ã€è§’ã®å››ã¤ã®å†™ã—ã‚’ <tt>square-limit</tt> ãŒã©ã†é…ç½®ã™ã‚‹ã®ã‹ã‚’å¤‰æ›´ã™ã‚‹ã‚ˆã†ã«ã€ä½œæ¥­ã§ãã‚‹ã“ã¨ã ã‚ã†ã€‚
ä¸€èˆ¬ã«ã€éšå±¤åŒ–ã•ã‚ŒãŸè¨­è¨ˆã®å„æ°´æº–ã¯ã€ã‚·ã‚¹ãƒ†ãƒ ã®ç‰¹æ€§ã‚’è¡¨ã™ãŸã‚ã®ç•°ãªã‚‹èªå½™ã‚’æä¾›ã—ã€ãã®ç‰¹æ€§ã‚’å¤‰æ›´ã™ã‚‹ç•°ãªã‚‹ç¨®é¡ã®èƒ½åŠ›ã‚’æä¾›ã™ã‚‹ã€‚
</p>

<p class="orig" lang="en">
<a name="%_thm_2.52"></a>
<b>Exercise 2.52.</b>  Make changes to the square limit of <tt>wave</tt> shown in
figure <a href="#%_fig_2.9">2.9</a> by working at each of the levels
described above.  In particular:</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.52.</b> å›³<a href="#%_fig_2.9">2.9</a>ã«ç¤ºã—ãŸã€<tt>wave</tt> ã®å››è§’ã„æ¥µé™ã«ã€ä¸Šè¨˜ã®è«¸æ°´æº–ã®å„ã€…ã«ãŠã„ã¦ä½œæ¥­ã‚’ã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€å¤‰æ›´ã‚’åŠ ãˆã‚ˆã€‚
ç‰¹ã«ã€
</p>

<ol class="orig" lang="en" style="list-style-type: lower-alpha">
<li>Add some segments to the primitive <tt>wave</tt> painter
of exercise  <a href="#%_thm_2.49">2.49</a> (to add a smile, for example).</li>
<li>Change the pattern constructed by <tt>corner-split</tt>
(for example, by using only one copy of the
<tt>up-split</tt> and <tt>right-split</tt> images instead of two).</li>
<li>Modify the version of <tt>square-limit</tt> that uses <tt>square-of-four</tt>
so as to assemble the corners in a different pattern.  (For example, you
might make the big Mr. Rogers look outward from each corner of the square.)
</li>
</ol>

<p class="exercise"><span class="ex_comment">
</span></p>

<ol class="trans" lang="ja" style="list-style-type: lower-alpha">
<li>ç·´ç¿’å•é¡Œ<a href="#%_thm_2.49">2.49</a>ã®ã€åŸå§‹çš„ãª <tt>wave</tt> ãƒšã‚¤ãƒ³ã‚¿ã«ã€ã„ãã¤ã‹ã®ç·šåˆ†ã‚’è¿½åŠ ã›ã‚ˆ (ãŸã¨ãˆã°ã€ç¬‘é¡”ã‚’è¿½åŠ ã™ã‚‹ãªã©)ã€‚</li>
<li><tt>corner-split</tt> ã«ã‚ˆã‚Šæ§‹ç¯‰ã•ã‚Œã‚‹ãƒ‘ã‚¿ãƒ³ã‚’å¤‰æ›´ã›ã‚ˆ (ãŸã¨ãˆã°ã€<tt>up-split</tt> ã¨ <tt>right-split</tt> ã®ç”»åƒã®ã†ã¡ã€äºŒã¤ã§ã¯ãªãã€ãŸã ä¸€ã¤ã®å†™ã—ã ã‘ã‚’ã€ç”¨ã„ã‚‹ã“ã¨ã«ã‚ˆã£ã¦)ã€‚</li>
<li><tt>square-limit</tt> ã®ã€<tt>square-of-four</tt> ã‚’ä½¿ã†ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ã€å››éš…ã‚’åˆ¥ã®ãƒ‘ã‚¿ãƒ³ã§çµ„ã¿ç«‹ã¦ã‚‹ã‚ˆã†ã«ã€ä¿®æ­£ã›ã‚ˆ (ãŸã¨ãˆã°ã€å¤§ããªãƒ­ã‚¸ãƒ£ãƒ¼ã‚¹ã•ã‚“ã«æ­£æ–¹å½¢ã®å„ã€…ã®è§’ã‹ã‚‰å¤–ã¸ã¨è¦–ç·šã‚’å‘ã‘ã•ã›ã¦ã‚‚ã‚ˆã„ã ã‚ã†)ã€‚</li>
</ol>

<p class="exercise"><span class="ex_comment">
</span></p>


<a name="footnotes"></a>
<hr>

<p class="orig" lang="en">
<a name="footnote_Temp_154" href="#call_footnote_Temp_154"><sup><small>6</small></sup></a> 
The use of the word <a name="%_idx_1536"></a>``closure'' here comes from abstract algebra,
where a set of elements is said to be closed under an operation if
applying the operation to elements in the set produces an element that
is again an element of the set.  The Lisp community
also (unfortunately) uses the word ``closure'' to describe a totally unrelated
concept: A closure is an implementation technique for representing
procedures with free variables.  We do not use the word ``closure'' in
this second sense in this book.
</p>

<p class="trans" lang="ja">
ã“ã“ã§ã®ã€Œé–‰åŒ…ã€ã¨ã„ã†å˜èªã®ä½¿ã„æ–¹ã¯ã€æŠ½è±¡ä»£æ•°ã«ç”±æ¥ã—ã¦ã„ã‚‹ã€‚æŠ½è±¡ä»£æ•°ã§ã¯ã€ã‚‚ã—ã€ã‚ã‚‹æ¼”ç®—ã‚’é›†åˆå†…ã®è¦ç´ åŒå£«ã«å¯¾ã—ã¦é©ç”¨ã™ã‚‹ã“ã¨ã§ã€ã¾ãŸã—ã¦ã‚‚ãã®é›†åˆã®è¦ç´ ã§ã‚ã‚‹ã‚ˆã†ãªè¦ç´ ãŒä½œã‚Šå‡ºã•ã‚Œã‚‹ãªã‚‰ã°ã€è¦ç´ ã®é›†åˆã¯ã€ãã®æ¼”ç®—ã«é–¢ã—ã¦é–‰ã˜ã¦ã„ã‚‹ã€ã¨è¨€ã‚ã‚Œã‚‹ã€‚
Lispç•Œã§ã¯ã€(ä¸å¹¸ãªã“ã¨ã«) ã€Œé–‰åŒ…ã€ã¨ã„ã†å˜èªã‚’ã€ã¾ã£ãŸãç„¡é–¢ä¿‚ã®æ¦‚å¿µã‚’è¨˜è¿°ã™ã‚‹ã®ã«ã‚‚ä½¿ã†â€”â€”é–‰åŒ…ã¨ã¯ã€è‡ªç”±å¤‰æ•°ã‚’ã¨ã‚‚ãªã†æ‰‹ç¶šãã‚’è¡¨ç¾ã™ã‚‹ãŸã‚ã®å®Ÿè£…æŠ€æ³•ã§ã‚ã‚‹ã€ã¨ã„ã†ã‚ˆã†ã«ã€‚
æœ¬æ›¸ã§ã¯ã€ã“ã®2ç•ªç›®ã®æ„å‘³ã§ã¯ã€Œé–‰åŒ…ã€ã¨ã„ã†å˜èªã‚’ä½¿ã‚ãªã„ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_155" href="#call_footnote_Temp_155"><sup><small>7</small></sup></a> The notion that a means of
<a name="%_idx_1542"></a>combination should satisfy closure is a straightforward idea.
Unfortunately, the data combiners provided in many popular programming
languages do not satisfy closure, or make closure cumbersome to
exploit.  In <a name="%_idx_1544"></a>Fortran or <a name="%_idx_1546"></a>Basic, one typically combines data elements by
assembling them into arrays -- but one cannot form arrays whose
elements are themselves arrays.  <a name="%_idx_1548"></a>Pascal and <a name="%_idx_1550"></a>C admit structures whose
elements are structures.  However, this requires that the programmer
manipulate pointers explicitly, and adhere to the restriction that
each field of a structure can contain only elements of a prespecified form.
Unlike
Lisp with its pairs, these languages have no built-in general-purpose
glue that makes it easy to manipulate compound data in a uniform way.
This limitation lies behind Alan <a name="%_idx_1552"></a>Perlis's comment in his foreword to
this book: ``In Pascal the plethora of declarable data structures
induces a specialization within functions that inhibits and penalizes
casual cooperation.  It is better to have 100 functions operate on one
data structure than to have 10 functions operate on 10 data
structures.''
</p>

<p class="trans" lang="ja">
çµåˆã®æ‰‹æ®µã¯é–‰åŒ…ã‚’æº€ãŸã™ã¹ãã ã€ã¨ã„ã†è¦‹è§£ã¯ã€åˆ†ã‹ã‚Šã‚„ã™ã„è€ƒãˆæ–¹ã ã€‚
ã‚ã„ã«ãã€ã‚ˆãä½¿ã‚ã‚Œã‚‹å¤šãã®ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã§æä¾›ã•ã‚Œã¦ã„ã‚‹ãƒ‡ãƒ¼ã‚¿çµåˆå­ã¯ã€é–‰åŒ…ã‚’æº€ãŸã•ãªã„ã‹ã€æ´»ç”¨ã™ã‚‹ã«ã¯è¤‡é›‘ã§é¢å€’ãªé–‰åŒ…ã‚’ä½œã‚Šå‡ºã™ã€‚
Fortranã¾ãŸã¯Basicã«ãŠã„ã¦ã¯ã€å…¸å‹çš„ã«ã¯ã€ãƒ‡ãƒ¼ã‚¿è¦ç´ ã‚’é…åˆ—ã«çµ„ã¿ç«‹ã¦ã‚‹ã“ã¨ã§ã€ãã‚Œã‚‰ã®ãƒ‡ãƒ¼ã‚¿è¦ç´ ã‚’çµåˆã™ã‚‹â€”â€”ã—ã‹ã—ã€è¦ç´ è‡ªä½“ãŒé…åˆ—ã§ã‚ã‚‹ã‚ˆã†ãªé…åˆ—ã¯ã€ä½œã‚Œãªã„ã€‚
Pascalã¨Cã¯ã€è¦ç´ ãŒæ§‹é€ ä½“ã§ã‚ã‚‹ã‚ˆã†ãªæ§‹é€ ä½“ã‚’è¨±ã—ã¦ã„ã‚‹ã€‚
ã—ã‹ã—ã€ã“ã‚Œã«ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒãŒæ˜ç¤ºçš„ã«ãƒã‚¤ãƒ³ã‚¿ã‚’æ“ä½œã™ã‚‹ã“ã¨ãŒå¿…è¦ã§ã‚ã‚Šã€ã‹ã¤ã€æ§‹é€ ä½“ã®å„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯äºˆã‚æŒ‡å®šã•ã‚ŒãŸå½¢å¼ã®è¦ç´ ã®ã¿ã‚’å«ã‚€ã“ã¨ãŒã§ãã‚‹ã€ã¨ã„ã†åˆ¶ç´„ã‚’ãƒ—ãƒ­ã‚°ãƒ©ãƒãŒéµå®ˆã™ã‚‹ã“ã¨ã‚‚å¿…è¦ã§ã‚ã‚‹ã€‚
å¯¾ã‚’ä½¿ã£ã¦ã„ã‚‹Lispã¨ã¯é•ã£ã¦ã€ã“ã‚Œã‚‰ã®è¨€èªã«ã¯ã€è¤‡åˆçš„ãƒ‡ãƒ¼ã‚¿ã‚’ä¸€å¾‹ãªæ–¹æ³•ã§æ“ä½œã™ã‚‹ã®ã‚’ç°¡å˜ã«ã—ã¦ãã‚Œã‚‹ã‚ˆã†ãªã€çµ„ã¿è¾¼ã¿ã®æ±ç”¨çš„æ¥ç€å‰¤ãŒãªã„ã€‚
ã“ã®ã‚ˆã†ãªåˆ¶é™ãŒã€æœ¬æ›¸ã¸ã®åºè¨€ã®ä¸­ã®ã‚¢ãƒ©ãƒ³ãƒ»ãƒ‘ãƒ¼ãƒªã‚¹ã®ã€Œ Pascalã§ã¯ã€æ°—è»½ãªå”èª¿ã‚’å¦¨ã’ãŸã‚Šç½°ã—ãŸã‚Šã—ã¦ã—ã¾ã†ã‚ˆã†ãªã€é–¢æ•°å†…éƒ¨ã§ã®ç‰¹æ®ŠåŒ–ã‚’ã€éåº¦ã«å¤šã„å®£è¨€å¯èƒ½ãªãƒ‡ãƒ¼ã‚¿æ§‹é€ ãŒèª˜ç™ºã—ã¦ã—ã¾ã†ã€‚ä¸€ã¤ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã«é–¢ã—ã¦å‹•ä½œã™ã‚‹ç™¾ã®é–¢æ•°ãŒã‚ã‚‹æ–¹ãŒã€åã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã«é–¢ã—ã¦å‹•ä½œã™ã‚‹åã®é–¢æ•°ãŒã‚ã‚‹ã‚ˆã‚Šè‰¯ã„ã®ã§ã‚ã‚‹ã€‚ã€ã¨ã„ã†ã‚³ãƒ¡ãƒ³ãƒˆã®èƒŒå¾Œã«ã‚ã‚‹ã®ã ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_156" href="#call_footnote_Temp_156"><sup><small>8</small></sup></a> In this book, we use <em>list</em> to mean a chain of
pairs terminated by the end-of-list marker.  In contrast, the term
<a name="%_idx_1572"></a><a name="%_idx_1574"></a><em>list structure</em> refers to any data structure made out of pairs,
not just to lists.
</p>

<p class="trans" lang="ja">
æœ¬æ›¸ã§ã¯ã€ãƒªã‚¹ãƒˆçµ‚äº†ã®æ¨™è­˜ã«ã‚ˆã£ã¦çµ‚ã‚ã‚‹ã€å¯¾ã®é€£ãªã‚Šã®ã“ã¨ã‚’æ„å‘³ã™ã‚‹ã‚ˆã†ã«ã€<em>ãƒªã‚¹ãƒˆ</em>ã¨ã„ã†è¨€è‘‰ã‚’ç”¨ã„ã‚‹ã€‚
å¯¾ç…§çš„ã«ã€<em>ãƒªã‚¹ãƒˆæ§‹é€ </em>ã¨ã„ã†è¨€è‘‰ã¯ã€å¯¾ã‹ã‚‰ä½œã‚‰ã‚ŒãŸä»»æ„ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã®ã“ã¨ã‚’æŒ‡ã—ã€ãƒªã‚¹ãƒˆã®ã¿ã‚’æŒ‡ã™ã‚ã‘ã§ã¯ãªã„ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_157" href="#call_footnote_Temp_157"><sup><small>9</small></sup></a> Since nested applications of <tt>car</tt> and <tt>cdr</tt>
are cumbersome to write, Lisp dialects provide abbreviations for
them -- for instance,</p>

<p class="trans" lang="ja">
<tt>car</tt> ã¨ <tt>cdr</tt> ã®å…¥ã‚Œå­ã«ãªã£ãŸé©ç”¨ã¯ã€æ›¸ãã®ã«ã¯è¤‡é›‘ã§é¢å€’ãªã®ã§ã€ãã®ãŸã‚ã®ç•¥èªã‚’Lispã®è«¸æ–¹è¨€ã¯æä¾›ã—ã¦ã„ã‚‹â€”â€”ãŸã¨ãˆã°ä»¥ä¸‹ã®ã‚ˆã†ã«ã€‚
</p>

<figure>
<a name="%_idx_1584"></a><a name="%_idx_1586"></a>
<img src="ch2-Z-G-14.gif" border="0">
</figure>

<p class="orig" lang="en">
The names of all such procedures start with <tt>c</tt> and end with <tt>r</tt>.  Each <tt>a</tt> between them stands for a <a name="%_idx_1588"></a><a name="%_idx_1590"></a><tt>car</tt> operation and
each <tt>d</tt> for a <tt>cdr</tt> operation, to be applied in the same order
in which they appear in the name.  The names <tt>car</tt> and <tt>cdr</tt>
persist because simple combinations like <tt>cadr</tt> are
pronounceable.
</p>

<p class="trans" lang="ja">
ã™ã¹ã¦ã®ãã†ã„ã†æ‰‹ç¶šãã®åå‰ã¯ã€<tt>c</tt> ã§å§‹ã¾ã‚Šã€<tt>r</tt> ã§çµ‚ã‚ã‚‹ã€‚
ãã‚Œã‚‰ã®é–“ã®å„ã€…ã® <tt>a</tt> ã¯ <tt>car</tt> æ¼”ç®—ã‚’æ„å‘³ã—ã€å„ã€…ã® <tt>d</tt> ã¯ <tt>cdr</tt> æ¼”ç®—ã‚’æ„å‘³ã™ã‚‹â€”â€”ãã—ã¦ã“ã‚Œã‚‰ã®æ¼”ç®—ã¯ã€åå‰ã®ä¸­ã«ç¾ã‚Œã‚‹ã®ã¨åŒã˜é †åºã§é©ç”¨ã•ã‚Œã‚‹ã¹ãã‚‚ã®ã§ã‚ã‚‹ã€‚
<tt>car</tt> ã¨ <tt>cdr</tt> ã¨ã„ã†åå‰ã¯æ®‹å­˜ã—ç¶šã‘ã‚‹ã€‚ã¨ã„ã†ã®ã‚‚ã€<tt>cadr</tt> ã®ã‚ˆã†ãªå˜ç´”ãªçµ„ã¿åˆã‚ã›ãŒç™ºéŸ³å¯èƒ½ã ã‹ã‚‰ã ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_158" href="#call_footnote_Temp_158"><sup><small>10</small></sup></a> It's remarkable how much energy in the
standardization of Lisp dialects has been dissipated in arguments that
are literally over nothing: Should <tt>nil</tt> be an ordinary name?
Should the value of <tt>nil</tt> be a symbol?  Should it be a list?
Should it be a pair?  <a name="%_idx_1598"></a>In Scheme, <tt>nil</tt> is an ordinary name,
which we use in this section as a variable whose value is
the end-of-list marker (just as <tt>true</tt> is an ordinary variable
that has a true value).  Other dialects of
Lisp, including Common Lisp, treat <tt>nil</tt> as a special symbol.  The
<a name="%_idx_1600"></a>authors of this book, who have endured too many language
standardization brawls, would like to avoid the entire issue.  Once we
have introduced quotation in section <a href="16_sec2_3.html#%_sec_2.3">2.3</a>, we will
denote the empty list as <tt>'()</tt> and dispense with the
variable <tt>nil</tt> entirely.
</p>

<p class="trans" lang="ja">
Lispã®è«¸æ–¹è¨€ã®æ¨™æº–åŒ–ã«ãŠã„ã¦ã€æ–‡å­—ã©ãŠã‚Šç„¡ã‚’ã‚ãã‚‹è­°è«–ã«ã€ã©ã‚Œã»ã©å¤šãã®ã‚¨ãƒãƒ«ã‚®ãƒ¼ãŒæµªè²»ã•ã‚Œã¦ããŸã‹ã€ã¨ã„ã†ã“ã¨ã«ã¯ã€é©šãã¹ãã‚‚ã®ãŒã‚ã‚‹ã€‚
<tt>nil</tt> ã¯æ™®é€šã®åå‰ã§ã‚ã‚‹ã¹ãã‹?
<tt>nil</tt> ã®å€¤ã¯ã‚·ãƒ³ãƒœãƒ«ã§ã‚ã‚‹ã¹ãã‹?
ãã‚Œã¯ãƒªã‚¹ãƒˆã§ã‚ã‚‹ã¹ãã‹?
ãã‚Œã¯å¯¾ã§ã‚ã‚‹ã¹ãã‹?
Schemeã§ã¯ã€<tt>nil</tt> ã¯æ™®é€šã®åå‰ã§ã‚ã‚Šã€ãã®æ™®é€šã®åå‰ã‚’ã€ç§ãŸã¡ã¯æœ¬ç¯€ã§ã€å€¤ãŒãƒªã‚¹ãƒˆçµ‚äº†ã®æ¨™è­˜ã§ã‚ã‚‹ã‚ˆã†ãªå¤‰æ•°ã¨ã—ã¦ã€ä½¿ã£ã¦ã„ã‚‹ (ã¡ã‚‡ã†ã©ã€<tt>true</tt> ãŒçœŸå€¤ã‚’æŒã¤æ™®é€šã®å¤‰æ•°ã§ã‚ã‚‹ã®ã¨åŒæ§˜ã«)ã€‚
Lispã®ä»–ã®æ–¹è¨€â€”â€”Common Lispã‚’å«ã‚€â€”â€”ã¯ã€<tt>nil</tt> ã‚’ç‰¹æ®Šãªã‚·ãƒ³ãƒœãƒ«ã¨ã—ã¦æ‰±ã†ã€‚
æœ¬æ›¸ã®è‘—è€…ãŸã¡â€”â€”è¨€èªæ¨™æº–åŒ–ã«ã¤ã„ã¦ã®ã‚ã¾ã‚Šã«å¤šãã®é¨’ã€…ã—ã„å£è«–ã«è€ãˆã¦ããŸâ€”â€”ã¯ã€è«–ç‚¹ã‚’ä¸¸ã”ã¨é¿ã‘ãŸã„ã¨æ€ã£ã¦ã„ã‚‹ã€‚
ä¸€æ—¦ã€ç§ãŸã¡ãŒ<a href="16_sec2_3.html#%_sec_2.3">2.3</a>ç¯€ã§å¼•ç”¨ã‚’å°å…¥ã™ã‚Œã°ã€ç§ãŸã¡ã¯ã€ç©ºãƒªã‚¹ãƒˆã‚’ <tt>'()</tt> ã¨è¡¨ã™ã“ã¨ã«ã—ã€<tt>nil</tt> ã¨ã„ã†å¤‰æ•°ã‚’ã¾ã£ãŸããªã—ã§æ¸ˆã¾ã›ã‚ˆã†ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_164" href="#call_footnote_Temp_164"><sup><small>11</small></sup></a> To define <tt>f</tt> and <tt>g</tt> using
<a name="%_idx_1656"></a><tt>lambda</tt> we would write
</p>

<p class="trans" lang="ja">
<tt>lambda</tt> ã‚’ä½¿ã£ã¦ <tt>f</tt> ã¨ <tt>g</tt> ã‚’å®šç¾©ã™ã‚‹ãŸã‚ã«ã¯ã€ç§ãŸã¡ã¯ã€æ¬¡ã®ã‚ˆã†ã«æ›¸ãã“ã¨ã ã‚ã†ã€‚
</p>

<p class="lisp">(define f (lambda (x y . z) &lt;<em>body</em>&gt;))
(define g (lambda w &lt;<em>body</em>&gt;))
</p>

<p class="orig" lang="en"><a name="footnote_Temp_166" href="#call_footnote_Temp_166"><sup><small>12</small></sup></a> Scheme
standardly provides a <a name="%_idx_1664"></a><tt>map</tt> procedure that is more general
than the one described here.
This more general <tt>map</tt>
takes a procedure of <em>n</em> arguments, together with <em>n</em> lists, and
applies the procedure to all the first elements of
the lists, all the second elements of the lists, and so on,
returning a list of the results.  For example:
</p>

<p class="trans" lang="ja">
Schemeã¯ã€æ¨™æº–çš„ã«ã¯ã€ã“ã“ã§èª¬æ˜ã—ãŸã‚‚ã®ã‚ˆã‚Šã‚‚ä¸€èˆ¬çš„ãª <tt>map</tt> æ‰‹ç¶šãã‚’æä¾›ã—ã¦ã„ã‚‹ã€‚
ãã®ã€ã‚ˆã‚Šä¸€èˆ¬çš„ãª <tt>map</tt> ã¯ã€<em class="en">n</em> å¼•æ•°ã®æ‰‹ç¶šãã‚’ã€<em class="en">n</em> å€‹ã®ãƒªã‚¹ãƒˆã¨ã¨ã‚‚ã«å–ã‚Šã€ãã®æ‰‹ç¶šãã‚’ã€ãã‚Œã‚‰ã®ãƒªã‚¹ãƒˆã®1ç•ªç›®ã®è¦ç´ ã™ã¹ã¦ã«å¯¾ã—ã¦é©ç”¨ã—ã€ãã‚Œã‚‰ã®ãƒªã‚¹ãƒˆã®2ç•ªç›®ã®è¦ç´ ã™ã¹ã¦ã«å¯¾ã—ã¦é©ç”¨ã—ã€ãªã©ã¨ã—ã¦ã„ã£ã¦ã€ãã®çµæœã®ãƒªã‚¹ãƒˆã‚’è¿”ã™ã€‚ãŸã¨ãˆã°ä»¥ä¸‹ã®ã‚ˆã†ã«ã€‚
</p>

<p class="lisp">(map + (list 1 2 3) (list 40 50 60) (list 700 800 900))
<i>(741 852 963)</i>

(map (lambda (x y) (+ x (* 2 y)))
     (list 1 2 3)
     (list 4 5 6))
<i>(9 12 15)</i>
</p>

<p class="orig" lang="en"><a name="footnote_Temp_170" href="#call_footnote_Temp_170"><sup><small>13</small></sup></a> The order of the
first two clauses in the <tt>cond</tt> matters, since the empty list
satisfies <tt>null?</tt> and also is not a pair.
</p>

<p class="trans" lang="ja">
<tt>cond</tt> ã®ä¸­ã§ã®æœ€åˆã®äºŒã¤ã®ç¯€ã®é †åºã¯é‡è¦ã ã€‚ã¨ã„ã†ã®ã‚‚ã€ç©ºãƒªã‚¹ãƒˆã¯ <tt>null?</tt> ã‚’æº€ãŸã—ã€ã‹ã¤ã€å¯¾ã§ã‚‚ãªã„ã‹ã‚‰ã ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_182" href="#call_footnote_Temp_182"><sup><small>14</small></sup></a> This is, in fact, precisely the <a name="%_idx_1746"></a><tt>fringe</tt> procedure from
exercise <a href="#%_thm_2.28">2.28</a>.  Here we've renamed it to emphasize that
it is part of a family of general sequence-manipulation procedures.
</p>

<p class="trans" lang="ja">
ã“ã‚Œã¯ã€å®Ÿã¯ã€æ­£ç¢ºã«ã¯ã€ç·´ç¿’å•é¡Œ<a href="#%_thm_2.28">2.28</a>ã® <tt>fringe</tt> æ‰‹ç¶šãã§ã‚ã‚‹ã€‚
ã“ã“ã§ã¯ã€ãã‚ŒãŒä¸€ç¾¤ã®ä¸€èˆ¬çš„ãªåˆ—æ“ä½œæ‰‹ç¶šãã®ä¸€éƒ¨ã§ã‚ã‚‹ã“ã¨ã‚’å¼·èª¿ã™ã‚‹ãŸã‚ã«ã€ãã‚Œã‚’æ”¹åã—ãŸã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_183" href="#call_footnote_Temp_183"><sup><small>15</small></sup></a> <a name="%_idx_1760"></a>Richard Waters (1979)
developed a program that automatically analyzes traditional <a name="%_idx_1762"></a>Fortran
programs, viewing them in terms of maps, filters, and accumulations.
He found that fully 90 percent of the code in the Fortran Scientific
Subroutine Package fits neatly into this paradigm.  One of the reasons
for the success of Lisp as a programming language is that lists
provide a standard medium for expressing ordered collections so that
they can be manipulated using higher-order operations.  The
programming language <a name="%_idx_1764"></a>APL owes much of its power and appeal to a
similar choice. In APL all data are represented as arrays, and there is a
universal and convenient set of generic operators for all sorts of
array operations.
</p>

<p class="trans" lang="ja">
ãƒªãƒãƒ£ãƒ¼ãƒ‰ãƒ»ã‚¦ã‚©ãƒ¼ã‚¿ãƒ¼ã‚º (1979) ã¯ã€ä¼çµ±çš„ãªFortranãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’è‡ªå‹•çš„ã«åˆ†æã™ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’é–‹ç™ºã—ãŸâ€”â€”ãƒãƒƒãƒ—ã€ãƒ•ã‚£ãƒ«ã‚¿ã€ç´¯ç©ã®è¦³ç‚¹ã‹ã‚‰ã€ä¼çµ±çš„ãªFortranãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’è¦‹ãŸã®ã ã€‚
Fortranç§‘å­¦ã‚µãƒ–ãƒ«ãƒ¼ãƒãƒ³ãƒ»ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã§æ›¸ã‹ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã®å°‘ãªãã¨ã‚‚90%ãŒã€ã“ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ãã¡ã‚“ã¨é©åˆã™ã‚‹ã€ã¨ã„ã†ã“ã¨ã«å½¼ã¯æ°—ã¥ã„ãŸã€‚
ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã¨ã—ã¦ã®Lispã®æˆåŠŸã®ä¸€å› ã¯ã€é«˜éšæ¼”ç®—ã‚’ä½¿ã£ã¦é †åºä»˜ãã®é›†ã¾ã‚Šã‚’æ“ä½œã§ãã‚‹ã‚ˆã†ã«ã€ãƒªã‚¹ãƒˆãŒã€é †åºä»˜ãã®é›†ã¾ã‚Šã‚’è¡¨ç¾ã™ã‚‹ãŸã‚ã®æ¨™æº–çš„æ‰‹æ®µã‚’æä¾›ã—ã¦ã„ã‚‹ã“ã¨ã«ã‚ã‚‹ã€‚
ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã®APLã®èƒ½åŠ›ã¨é­…åŠ›ã®å¤§éƒ¨åˆ†ã¯ã€ä¼¼ãŸã‚ˆã†ãªé¸æŠã®ãŠã‹ã’ã§ã‚ã‚‹ã€‚
APLã§ã¯ã€ã™ã¹ã¦ã®ãƒ‡ãƒ¼ã‚¿ãŒé…åˆ—ã¨ã—ã¦è¡¨ç¾ã•ã‚Œã€ã‚ã‚‰ã‚†ã‚‹ç¨®é¡ã®é…åˆ—æ¼”ç®—ã®ãŸã‚ã®ã€æ™®éçš„ã§ä¾¿åˆ©ãªã€ä¸€èˆ¬çš„æ¼”ç®—ã®ä¸€æƒã„ãŒã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_186" href="#call_footnote_Temp_186"><sup><small>16</small></sup></a> According to <a name="%_idx_1776"></a>Knuth (1981), this rule was formulated by
<a name="%_idx_1778"></a>W. G. Horner early in the nineteenth century, but the method was
actually used by Newton over a hundred years earlier.  Horner's rule
evaluates the polynomial using fewer additions and multiplications
than does the straightforward method of first computing <em>a</em><sub><em>n</em></sub> <em>x</em><sup><em>n</em></sup>,
then adding <em>a</em><sub><em>n</em>-1</sub><em>x</em><sup><em>n</em>-1</sup>, and so on.  In fact, it is possible to
prove that any algorithm for evaluating arbitrary polynomials must use
at least as many additions and multiplications as does Horner's rule,
and thus Horner's rule is an <a name="%_idx_1780"></a><a name="%_idx_1782"></a>optimal algorithm for polynomial
evaluation.  This was proved (for the number of additions) by
<a name="%_idx_1784"></a>A. M. Ostrowski in a 1954 paper that essentially founded the modern
study of optimal algorithms.  The analogous statement for
multiplications was proved by <a name="%_idx_1786"></a>V. Y. Pan in 1966.  The book by <a name="%_idx_1788"></a>Borodin
and <a name="%_idx_1790"></a>Munro (1975) provides an overview of these and other results about
optimal algorithms.
</p>

<p class="trans" lang="ja">
ã‚¯ãƒŒãƒ¼ã‚¹ (1981) ã«ã‚ˆã‚Œã°ã€ã“ã®æ³•å‰‡ã¯ã€W. G. ãƒ›ãƒ¼ãƒŠã«ã‚ˆã£ã¦19ä¸–ç´€ã«å®šå¼åŒ–ã•ã‚ŒãŸãŒã€ã“ã®æ–¹æ³•ã¯ã€å®Ÿéš›ã«ã¯100å¹´ä»¥ä¸Šã‚‚å‰ã«ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒ³ã«ã‚ˆã‚Šä½¿ã‚ã‚Œã¦ã„ãŸã€‚
ãƒ›ãƒ¼ãƒŠã®æ³•å‰‡ã¯ã€æœ€åˆã«
<span class="math"><em class="en">a<sub>n</sub> x<sup>n</sup></em></span>
ã‚’è¨ˆç®—ã—ã€ãã‚Œã‹ã‚‰
<span class="math"><em class="en">a<sub>n&minus;1</sub> x<sup>n&minus;1</sup></em></span>
ã‚’è¶³ã—ã€ãªã©ã¨ã—ã¦ã„ãå˜ç´”ãªæ–¹æ³•ã‚ˆã‚Šã‚‚ã€å°‘ãªã„å›æ•°ã®åŠ ç®—ãƒ»ä¹—ç®—ã‚’ä½¿ã£ã¦ã€å¤šé …å¼ã‚’è©•ä¾¡ã™ã‚‹ã‚‚ã®ã§ã‚ã‚‹ã€‚
å®Ÿéš›ã€ä»»æ„ã®å¤šé …å¼ã‚’è©•ä¾¡ã™ã‚‹ãŸã‚ã®ã„ã‹ãªã‚‹ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚‚ã€å°‘ãªãã¨ã‚‚ã€ãƒ›ãƒ¼ãƒŠã®æ³•å‰‡ã¨åŒã˜å›æ•°ã®åŠ ç®—ã¨ä¹—ç®—ã‚’ä½¿ã‚ãªãã¦ã¯ãªã‚‰ãªã„ã€ã¨ã„ã†ã“ã¨ã‚’è¨¼æ˜ã™ã‚‹ã“ã¨ãŒå¯èƒ½ã§ã‚ã‚Šã€ã—ãŸãŒã£ã¦ã€ãƒ›ãƒ¼ãƒŠã®æ³•å‰‡ã¯ã€å¤šé …å¼ã®è©•ä¾¡ã®ãŸã‚ã®æœ€é©ãªã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã§ã‚ã‚‹ã€‚
ã“ã®ã“ã¨ã¯ã€(åŠ ç®—ã®å›æ•°ã«é–¢ã—ã¦ã¯) A. M. ã‚ªã‚¹ãƒˆãƒ­ã‚¦ã‚¹ã‚­ã«ã‚ˆã‚Šã€æœ€é©ãªè«¸ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã«ã¤ã„ã¦ã®è¿‘ä»£çš„ç ”ç©¶ã‚’æœ¬è³ªçš„ã«æ‰“ã¡ç«‹ã¦ãŸ1954å¹´ã®è«–æ–‡ã«ãŠã„ã¦ã€è¨¼æ˜ã•ã‚ŒãŸã€‚
ä¹—ç®—ã«ã¤ã„ã¦ã®é¡ä¼¼ã®é™³è¿°ã¯ã€V. Y. ãƒ‘ãƒ³ã«ã‚ˆã‚Šã€1966å¹´ã«è¨¼æ˜ã•ã‚ŒãŸã€‚
ãƒœãƒ­ãƒ‡ã‚£ãƒ³ã¨ãƒãƒ³ãƒ­ã‚¦ã«ã‚ˆã‚‹è‘—ä½œ (1975å¹´) ã¯ã€æœ€é©ãªè«¸ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã«ã¤ã„ã¦ã®ã€ã“ã‚Œã‚‰ã®æˆæœã¨ãã®ä»–ã®æˆæœã®ã€æ¦‚è¦ã‚’ç¤ºã—ã¦ãã‚Œã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_190" href="#call_footnote_Temp_190"><sup><small>17</small></sup></a> This definition uses the
extended version of <tt>map</tt> described in footnote <a href="#footnote_Temp_166">12</a>.
</p>

<p class="trans" lang="ja">
ã“ã®å®šç¾©ã§ã¯ã€è„šæ³¨<a href="#footnote_Temp_166">12</a>ã§è¿°ã¹ãŸæ‹¡å¼µç‰ˆã® <tt>map</tt> ã‚’ä½¿ã†ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_194" href="#call_footnote_Temp_194"><sup><small>18</small></sup></a> This approach to nested mappings was shown
to us by <a name="%_idx_1820"></a>David Turner, whose languages <a name="%_idx_1822"></a>KRC and <a name="%_idx_1824"></a>Miranda provide elegant
formalisms for dealing with these constructs.  The examples in this
section (see also exercise <a href="#%_thm_2.42">2.42</a>) are adapted from Turner
1981.  In section <a href="24_sec3_5.html#%_sec_3.5.3">3.5.3</a>, we'll see how this
approach generalizes to infinite sequences.
</p>

<p class="trans" lang="ja">
å…¥ã‚Œå­ã«ãªã£ãŸå†™åƒã«å¯¾ã™ã‚‹ã“ã®å–ã‚Šçµ„ã¿æ–¹ã¯ã€ãƒ‡ã‚¤ãƒ´ã‚£ãƒƒãƒ‰ãƒ»ã‚¿ãƒ¼ãƒŠâ€”â€”å½¼ã®è¨€èªã§ã‚ã‚‹KRCã¨Mirandaã¯ã€ã“ã‚Œã‚‰ã®æ§‹ç¯‰ç‰©ã‚’æ‰±ã†ãŸã‚ã®ã€æ´—ç·´ã•ã‚ŒãŸå½¢å¼ã‚’æä¾›ã—ã¦ãã‚Œã‚‹â€”â€”ã«ã‚ˆã£ã¦ã€ç¤ºã•ã‚ŒãŸã€‚
æœ¬ç¯€ã§ã®ä¾‹ (ç·´ç¿’å•é¡Œ<a href="#%_thm_2.42">2.42</a>ã‚‚å‚ç…§) ã¯ã€Turner 1981 ã‹ã‚‰è»¢ç”¨ã—ãŸã‚‚ã®ã§ã‚ã‚‹ã€‚
<a href="24_sec3_5.html#%_sec_3.5.3">3.5.3</a>ç¯€ã§ã¯ã€ã“ã®å–ã‚Šçµ„ã¿æ–¹ãŒã©ã®ã‚ˆã†ã«ã—ã¦ç„¡é™åˆ—ã¸ã¨ä¸€èˆ¬åŒ–ã™ã‚‹ã®ã‹ã‚’è¦‹ã‚ˆã†ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_195" href="#call_footnote_Temp_195"><sup><small>19</small></sup></a> We're
representing a pair here as a list of two elements rather than as a
Lisp pair.  Thus, the ``pair'' (<em>i</em>,<em>j</em>) is represented as <tt>(list i
j)</tt>, not <tt>(cons i j)</tt>.
</p>

<p class="trans" lang="ja">
ã“ã“ã§ã¯ã€Lispã®å¯¾ã¨ã—ã¦å¯¾ã‚’è¡¨ã™ã®ã§ã¯ãªãã€ã‚€ã—ã‚ã€äºŒã¤ã®è¦ç´ ã®ãƒªã‚¹ãƒˆã¨ã—ã¦å¯¾ã‚’è¡¨ã—ã¦ã„ã‚‹ã€‚
ã‚ˆã£ã¦ã€
<span class="math">(<em class="en">i</em>, <em class="en">j</em>)</span>
ã¨ã„ã†ã€Œå¯¾ã€ã¯ã€
<tt>(list i j)</tt>
ã¨ã—ã¦è¡¨ã•ã‚Œã‚‹ã®ã§ã‚ã£ã¦ã€
<tt>(cons i j)</tt>
ã¨ã—ã¦è¡¨ã•ã‚Œã‚‹ã‚ã‘ã§ã¯ãªã„ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_196" href="#call_footnote_Temp_196"><sup><small>20</small></sup></a> The set <em>S</em> - <em>x</em> is the set of all elements
of <em>S</em>, excluding <em>x</em>.
</p>

<p class="trans" lang="ja">
<span class="math"><em class="en">S</em> &minus; <em class="en">x</em></span>
ã¨ã„ã†é›†åˆã¯ã€<em class="en">x</em> ã‚’é™¤å¤–ã—ãŸã€<em class="en">S</em> ã®ã™ã¹ã¦ã®è¦ç´ ã‹ã‚‰ãªã‚‹é›†åˆã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_197" href="#call_footnote_Temp_197"><sup><small>21</small></sup></a> <a name="%_idx_1834"></a><a name="%_idx_1836"></a><a name="%_idx_1838"></a>Semicolons in Scheme code are used to
introduce <em>comments</em>.  Everything from the semicolon to the end of
the line is ignored by the interpreter.  In this book we don't use
many comments; we try to make our programs self-documenting by using
descriptive names.
</p>

<p class="trans" lang="ja">
Schemeã®ã‚³ãƒ¼ãƒ‰ã«ãŠã‘ã‚‹ã‚»ãƒŸã‚³ãƒ­ãƒ³ã¯ã€<em>ã‚³ãƒ¡ãƒ³ãƒˆ</em>ã‚’å°å…¥ã™ã‚‹ã®ã«ä½¿ã‚ã‚Œã‚‹ã€‚
ã‚»ãƒŸã‚³ãƒ­ãƒ³ã‹ã‚‰è¡Œæœ«ã¾ã§ã®ã™ã¹ã¦ã¯ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«ç„¡è¦–ã•ã‚Œã‚‹ã€‚
æœ¬æ›¸ã§ã¯ã€ç§ãŸã¡ã¯ã‚ã¾ã‚Šå¤šãã®ã‚³ãƒ¡ãƒ³ãƒˆã¯ä½¿ã‚ãªã„ã€‚
ç§ãŸã¡ã¯ã€è¨˜è¿°çš„ãªåå‰ã‚’ä½¿ã†ã“ã¨ã§ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ã€è‡ªã‚‰æ–‡æ›¸åŒ–ã™ã‚‹ã‚‚ã®ãŸã‚‰ã—ã‚ã‚ˆã†ã¨ã—ã¦ã„ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_202" href="#call_footnote_Temp_202"><sup><small>22</small></sup></a> The picture language is based on the language
<a name="%_idx_1856"></a>Peter Henderson created to construct
images like <a name="%_idx_1858"></a>M.C. Escher's ``Square Limit'' woodcut (see Henderson 1982).
The woodcut incorporates a
repeated scaled pattern, similar to the arrangements drawn using
the <tt>square-limit</tt> procedure in this section.
</p>

<p class="trans" lang="ja">
ã“ã®ãŠçµµæãè¨€èªã¯ã€M. C. ã‚¨ãƒƒã‚·ãƒ£ãƒ¼ã®ã€Œå››è§’ã„æ¥µé™ã€ã¨ã„ã†æœ¨ç‰ˆç”»ã®ã‚ˆã†ãªç”»åƒã‚’æ§‹ç¯‰ã™ã‚‹ãŸã‚ã«ãƒ”ãƒ¼ã‚¿ãƒ¼ãƒ»ãƒ˜ãƒ³ãƒ€ãƒ¼ã‚½ãƒ³ãŒå‰µä½œã—ãŸè¨€èªã«åŸºã¥ã„ã¦ã„ã‚‹ (Henderson 1982 ã‚’å‚ç…§)ã€‚
ãã®æœ¨ç‰ˆç”»ã¯ã€ç¹°ã‚Šè¿”ã—ã®å¤‰å€ã•ã‚ŒãŸãƒ‘ã‚¿ãƒ³ã‚’çµ„ã¿å…¥ã‚Œã¦ãŠã‚Šã€æœ¬ç¯€ã® <tt>square-limit</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’ä½¿ã£ã¦æã‹ã‚Œã‚‹é…ç½®ã¨ä¼¼ã¦ã„ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_204" href="#call_footnote_Temp_204"><sup><small>23</small></sup></a> <a name="%_idx_1866"></a><a name="%_idx_1868"></a>William Barton Rogers (1804-1882) was the founder and first president
of MIT.  A geologist and talented teacher, he taught at William and
Mary College and at the University of Virginia.  In 1859 he moved to
Boston, where he had more time for research, worked on a plan
for establishing a ``polytechnic institute,'' and served as
Massachusetts's first State Inspector of Gas Meters.</p>
</p>

<p class="trans" lang="ja">
ã‚¦ã‚£ãƒªã‚¢ãƒ ãƒ»ãƒãƒ¼ãƒˆãƒ³ãƒ»ãƒ­ã‚¸ãƒ£ãƒ¼ã‚¹ (1804ã€œ1882) ã¯ã€MITã®å‰µç«‹è€…ã‹ã¤åˆä»£å­¦é•·ã ã£ãŸã€‚
åœ°è³ªå­¦è€…ã§ã‚ã‚Šæœ‰èƒ½ãªæ•™å¸«ã§ã‚ã£ãŸå½¼ã¯ã€ã‚¦ã‚£ãƒªã‚¢ãƒ ãƒ»ã‚¢ãƒ³ãƒ‰ãƒ»ãƒ¡ã‚¢ãƒªå¤§å­¦ãŠã‚ˆã³ãƒ´ã‚¡ãƒ¼ã‚¸ãƒ‹ã‚¢å¤§å­¦ã§æ•™é­ã‚’ã¨ã£ãŸã€‚
1859å¹´ã«å½¼ã¯ãƒœã‚¹ãƒˆãƒ³ã«å¼•ã£è¶Šã—ã€ãã“ã§ã¯ã€ã‚ˆã‚Šå¤šãã®æ™‚é–“ã‚’ç ”ç©¶ã«è²»ã‚„ã—ã€ã€Œå·¥æ¥­æŠ€è¡“æ•™è‚²æ©Ÿé–¢ã€ã‚’è¨­ç«‹ã™ã‚‹ãŸã‚ã®è¨ˆç”»ã«å–ã‚Šçµ„ã¿ã€ãƒã‚µãƒãƒ¥ãƒ¼ã‚»ãƒƒãƒ„å·ã®åˆä»£ã‚¬ã‚¹ãƒ¡ãƒ¼ã‚¿æ¤œæŸ»å®˜ã‚’å‹™ã‚ãŸã€‚
</p>

<p class="orig" lang="en">When MIT was established in 1861, Rogers was elected its first
president.  Rogers espoused an ideal of ``useful learning'' that was
different from the university education of the time, with its
overemphasis on the classics, which, as he wrote, ``stand in the way of
the broader, higher and more practical instruction and discipline of
the natural and social sciences.''  This education was likewise to be
different from narrow trade-school education.  In Rogers's words:
</p>

<p class="trans" lang="ja">
MITãŒ1861å¹´ã«å‰µç«‹ã•ã‚ŒãŸã¨ãã€ãƒ­ã‚¸ãƒ£ãƒ¼ã‚¹ã¯ã€ãã®åˆä»£å­¦é•·ã«é¸å‡ºã•ã‚ŒãŸã€‚
ãƒ­ã‚¸ãƒ£ãƒ¼ã‚¹ã¯ã€å¤å…¸â€”â€”å½¼ãŒæ›¸ã„ãŸã‚ˆã†ã«ã€ã€Œè‡ªç„¶ç§‘å­¦ãƒ»ç¤¾ä¼šç§‘å­¦ã®ã€ã‚ˆã‚Šåºƒãã€ã‚ˆã‚Šé«˜ãã€ã‚ˆã‚Šå®Ÿè·µçš„ãªæ•™è‚²ã¨è¨“ç·´ã‚’å¦¨ã’ã‚‹ã€â€”â€”ã®éåº¦ã®å¼·èª¿ã‚’ã¨ã‚‚ãªã£ãŸå½“æ™‚ã®å¤§å­¦æ•™è‚²ã¨ã¯ç•°ãªã‚‹ã€ã€Œæœ‰ç”¨ãªå­¦ç¿’ã€ã¨ã„ã†ç†æƒ³ã‚’å¥‰ã˜ãŸã€‚
ã“ã®æ•™è‚²ã¯ã€è·æ¥­å­¦æ ¡ã®é™ã‚‰ã‚ŒãŸæ•™è‚²ã¨ã‚‚ç•°ãªã‚‹ã¹ãã‚‚ã®ã ã£ãŸã€‚
ãƒ­ã‚¸ãƒ£ãƒ¼ã‚¹ã®è¨€ã«ã‚ˆã‚Œã°ã€
</p>

<blockquote class="orig" lang="en">The world-enforced distinction between the practical and the
scientific worker is utterly futile, and the whole experience of
modern times has demonstrated its utter worthlessness.
</blockquote>

<blockquote class="trans" lang="ja">
ã€Œç¾å ´ã®è€…ã¨ç§‘å­¦çš„åŠ´åƒè€…ã¨ã®é–“ã®ã€ä¸–ç•Œçš„ã«æŠ¼ã—ä»˜ã‘ã‚‰ã‚Œã¦ã„ã‚‹å·®ç•°ã¯ã€ã¾ã£ãŸãç„¡ç›Šãªã‚‚ã®ã§ã‚ã‚Šã€ãã‚ŒãŒã¾ã£ãŸãç„¡ä¾¡å€¤ãªã“ã¨ã¯ã€ç¾ä»£ã®çµŒé¨“ã™ã¹ã¦ãŒå®Ÿè¨¼ã—ã¦ããŸã€ã€‚
</blockquote>

<p class="orig" lang="en">Rogers served as president of MIT until 1870, when he resigned due to
ill health.  In 1878 the second president of MIT, <a name="%_idx_1870"></a>John Runkle,
resigned under the pressure of a financial crisis brought on by the
Panic of 1873 and strain of fighting off attempts by Harvard to take
over MIT.  Rogers returned to hold the office of president until
1881.</p>

<p class="trans" lang="ja">
ãƒ­ã‚¸ãƒ£ãƒ¼ã‚¹ã¯MITã®å­¦é•·ã‚’1870å¹´ã¾ã§å‹™ã‚ãŸâ€”â€”ãã®å¹´ã«å½¼ã¯ã€å¥åº·ã‚’å®³ã—ãŸã®ã§è¾ä»»ã—ãŸã®ã§ã‚ã‚‹ã€‚
1878å¹´ã«ã¯ã€MITã®ç¬¬äºŒä»£å­¦é•·ã§ã‚ã‚‹ã‚¸ãƒ§ãƒ³ãƒ»ãƒ©ãƒ³ã‚¯ãƒ«ãŒã€1873å¹´ã®çµŒæ¸ˆææ…Œã«ã‚ˆã‚Šã‚‚ãŸã‚‰ã•ã‚ŒãŸè²¡æ”¿å±æ©Ÿã®é‡åœ§ã¨ã€MITã‚’ä¹—ã£å–ã‚ã†ã¨ã—ã¦ãƒãƒ¼ãƒãƒ¼ãƒ‰ãŒåŠ›ã¥ãã§é—˜ã†æŒ‘æˆ¦ã¨ã„ã†æ‚©ã¿ã®ã›ã„ã§ã€è¾ä»»ã—ãŸã€‚
ãƒ­ã‚¸ãƒ£ãƒ¼ã‚¹ã¯å¾©å¸°ã—ã¦ã€1881å¹´ã¾ã§å­¦é•·ã®ä»»ã«å½“ãŸã£ãŸã€‚
</p>

<p class="orig" lang="en">Rogers collapsed and died while addressing MIT's graduating class at
the commencement exercises of 1882.  Runkle quoted Rogers's last
words in a memorial address delivered that same year:
</p>

<p class="trans" lang="ja">
ãƒ­ã‚¸ãƒ£ãƒ¼ã‚¹ã¯ã€1882å¹´ã®å­¦ä½æˆä¸å¼ã«ãŠã‘ã‚‹å­¦ä½æˆä¸è¬›ç¾©ã§è¬›æ¼”ã—ã¦ã„ã‚‹æœ€ä¸­ã«å€’ã‚Œã€äº¡ããªã£ãŸã€‚
ãƒ©ãƒ³ã‚¯ãƒ«ã¯ã€åŒå¹´ã«è¡Œã‚ã‚ŒãŸè¨˜å¿µè¬›æ¼”ã«ãŠã„ã¦ã€ãƒ­ã‚¸ãƒ£ãƒ¼ã‚¹ã®æœ€å¾Œã®è¨€è‘‰ã‚’å¼•ç”¨ã—ãŸã€‚
</p>

<blockquote class="orig" lang="en">``As I stand here today and see what the Institute is, <tt>...</tt> I call
to mind the beginnings of science.  I remember one hundred and fifty
years ago Stephen Hales published a pamphlet on the subject of
illuminating gas, in which he stated that his researches had
demonstrated that 128 grains of bituminous coal -- ''
<a name="%_idx_1872"></a>
</blockquote>

<blockquote class="trans" lang="ja">
ã€Œæœ¬æ—¥ã“ã“ã«ç«‹ã£ã¦æœ¬å­¦ãŒã©ã®ã‚ˆã†ãªã‚‚ã®ã§ã‚ã‚‹ã‹ã‚’è¦‹ã‚‹ã¨ãâ€¦â€¦ç§ã¯ã€ç§‘å­¦ã®å§‹ã¾ã‚Šã‚’æ€ã„èµ·ã“ã™ã€‚
ç§ã¯ã€150å¹´å‰ã«ã‚¹ãƒ†ã‚£ãƒ¼ãƒ´ãƒ³ãƒ»ãƒ˜ã‚¤ãƒ«ã‚ºãŒã€ç…§æ˜ã‚¬ã‚¹ã®ä¸»é¡Œã«ã¤ã„ã¦ã®å°å†Šå­ã‚’å‡ºç‰ˆã—ãŸã“ã¨ã‚’æ€ã„å‡ºã™â€”â€”ãã®å°å†Šå­ã§å½¼ãŒè¿°ã¹ãŸã¦ã„ãŸã“ã¨ã¨ã¯ã€å½¼ã®ç ”ç©¶ã§ç«‹è¨¼ã•ã‚ŒãŸã¨ã“ã‚ã«ã‚ˆã‚Œã°ã€128ã‚°ãƒ¬ã‚¤ãƒ³ (ç´„8.3ã‚°ãƒ©ãƒ ) ã®ç€é’è³ªã®çŸ³ç‚­ãŒâ€¦â€¦ã€
</blockquote>

<blockquote class="orig" lang="en">
``Bituminous coal,'' these were his last words on earth.  Here he bent
forward, as if consulting some notes on the table before him, then
slowly regaining an erect position, threw up his hands, and was
translated from the scene of his earthly labors and triumphs to ``the
tomorrow of death,'' where the mysteries of life are solved, and the
disembodied spirit finds unending satisfaction in contemplating the
new and still unfathomable mysteries of the infinite future.
</blockquote>

<blockquote class="trans" lang="ja">
ã€Œç€é’è³ªã®çŸ³ç‚­ãŒã€ã¨ã„ã†ã€ã“ã‚Œã‚‰ã®è¨€è‘‰ãŒã€å½¼ã®ã“ã®ä¸–ã§æœ€å¾Œã®è¨€è‘‰ã ã£ãŸã€‚
ã“ã“ã§å½¼ã¯å‰å‘ãã«å±ˆã¿è¾¼ã‚“ã§â€”â€”ã¾ã‚‹ã§ã€å‰ã«ã‚ã‚‹æœºã®ä¸Šã®ä½•ã‚‰ã‹ã®è¦šãˆæ›¸ãã‚’å‚ç…§ã™ã‚‹ã‹ã®ã‚ˆã†ã«â€”â€”ãã—ã¦ã€çœŸã£ç›´ãã®ä½“å‹¢ã‚’ã‚†ã£ãã‚Šã¨å–ã‚Šæˆ»ã—ãªãŒã‚‰ã€ä¸¡æ‰‹ã‚’æŒ¯ã‚Šä¸Šã’ã€å½¼ã®ã“ã®ä¸–ã§ã®åŠ´è‹¦ã¨å‰æ¥­ã®å ´é¢ã‹ã‚‰ã€ã€Œæ­»ã¨ã„ã†æ˜æ—¥ã€ã¸ã¨ç§»ã•ã‚ŒãŸâ€”â€”ãã—ã¦ãã“ã§ã¯ã€ç”Ÿå‘½ã®è¬ã¯è§£æ˜ã•ã‚Œã¦ã„ã¦ã€è‚‰ä½“ã‚’é›¢ã‚ŒãŸéœŠé­‚ã¯ã€ç„¡é™ã®æœªæ¥ã®ã€æ–°ã—ãã¦ã¾ã ç†è§£ã§ããªã„è¬ã‚’ã˜ã£ãã‚Šè€ƒãˆã‚‹ã“ã¨ã«å¯¾ã—ã¦é™ã‚Šãªãæº€è¶³ã‚’è¦‹å‡ºã—ã¦ã„ã‚‹ã®ã ã€‚
</blockquote>

<p class="orig" lang="en">
In the words of  Francis A. Walker
<a name="%_idx_1874"></a>(MIT's third president):
</p>

<p class="trans" lang="ja">
ãƒ•ãƒ©ãƒ³ã‚·ã‚¹ãƒ»Aãƒ»ã‚¦ã‚©ãƒ¼ã‚«ãƒ¼ (MITã®ç¬¬3ä»£å­¦é•·) ã®è¨€è‘‰ã«ã‚ˆã‚Œã°ã€
</p>

<blockquote class="orig" lang="en">All his life he had borne himself most faithfully and heroically, and
he died as so good a knight would surely have wished, in harness, at
his post, and in the very part and act of public duty.
</blockquote>

<blockquote class="trans" lang="ja">
ç”Ÿæ¶¯ã‚’é€šã˜ã¦å½¼ã¯ã€ã¨ã¦ã‚‚èª å®Ÿã‹ã¤å‹‡æ•¢ã«æŒ¯ã‚‹èˆã£ã¦ããŸã—ã€ã¨ã¦ã‚‚ã™ãã‚ŒãŸå‹²çˆµå£«ãªã‚‰ç¢ºã‹ã«æœ›ã‚“ã ã§ã‚ã‚ã†ã€ã¨ã„ã†äº¡ããªã‚Šæ–¹ã‚’ã—ãŸâ€”â€”ä»•äº‹ä¸­ã«ã€è‡ªåˆ†ã®æŒã¡å ´ã§ã€ã¾ã•ã«è‡ªåˆ†ã®å½¹å‰²ã¨å…¬çš„ç¾©å‹™ã®è¡Œå‹•ã®ä¸­ã§ã€‚
</blockquote>

<p class="orig" lang="en"><a name="footnote_Temp_207" href="#call_footnote_Temp_207"><sup><small>24</small></sup></a> Equivalently, we could
write
</p>

<p class="trans" lang="ja">
ç­‰ä¾¡ã«ã€æ¬¡ã®ã‚ˆã†ã«ã‚‚æ›¸ã‘ãŸã ã‚ã†ã€‚
</p>

<p class="lisp"><a name="%_idx_1902"></a>(define flipped-pairs
  (square-of-four identity flip-vert identity flip-vert))
</p>

<p class="orig" lang="en"><a name="footnote_Temp_208" href="#call_footnote_Temp_208"><sup><small>25</small></sup></a> <tt>Rotate180</tt>
rotates a painter by 180 degrees (see exercise <a href="#%_thm_2.50">2.50</a>).
Instead of <tt>rotate180</tt> we could say <tt>(compose flip-vert flip-horiz)</tt>, using
the <tt>compose</tt> procedure from exercise <a href="12_sec1_3.html#%_thm_1.42">1.42</a>.
</p>

<p class="trans" lang="ja">
<tt>rotate180</tt> ã¯ã€ãƒšã‚¤ãƒ³ã‚¿ã‚’180åº¦å›è»¢ã™ã‚‹ (ç·´ç¿’å•é¡Œ<a href="#%_thm_2.50">2.50</a>ã‚’å‚ç…§)ã€‚
<tt>rotate180</tt> ã®ä»£ã‚ã‚Šã«ã€<tt>(compose flip-vert flip-horiz)</tt> ã¨è¨€ã†ã“ã¨ã‚‚ã§ããŸã ã‚ã†â€”â€”ç·´ç¿’å•é¡Œ<a href="12_sec1_3.html#%_thm_1.42">1.42</a>ã® <tt>compose</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’ä½¿ãˆã°ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_211" href="#call_footnote_Temp_211"><sup><small>26</small></sup></a> <tt>Frame-coord-map</tt> uses
the vector operations described in exercise <a href="#%_thm_2.46">2.46</a> below, which we
assume have been implemented using some representation for vectors.
Because of data abstraction, it doesn't matter what this vector
representation is, so long as the vector operations behave correctly.
</p>

<p class="trans" lang="ja">
<tt>frame-coord-map</tt> ã¯ã€ç·´ç¿’å•é¡Œ<a href="#%_thm_2.46">2.46</a>ã§å¾Œè¿°ã™ã‚‹ãƒ™ã‚¯ãƒˆãƒ«æ¼”ç®—ã‚’ä½¿ã£ã¦ãŠã‚Šã€ç§ãŸã¡ã¯ã€ã“ã‚Œã‚‰ã®ãƒ™ã‚¯ãƒˆãƒ«æ¼”ç®—ãŒã€ãƒ™ã‚¯ãƒˆãƒ«ã®ãŸã‚ã®ä½•ã‚‰ã‹ã®è¡¨ç¾ã‚’ç”¨ã„ã¦æ—¢ã«å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ã€ã¨æƒ³å®šã—ã¦ã„ã‚‹ã€‚
ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ã®ãŠã‹ã’ã§ã€ã“ã®ãƒ™ã‚¯ãƒˆãƒ«è¡¨ç¾ãŒä½•ã§ã‚ã‚‹ã‹ã¯é‡è¦ã§ãªã„â€”â€”ãƒ™ã‚¯ãƒˆãƒ«æ¼”ç®—ãŒæ­£ã—ãæŒ¯ã‚‹èˆã†é™ã‚Šã¯ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_215" href="#call_footnote_Temp_215"><sup><small>27</small></sup></a> <tt>Segments-&gt;painter</tt> uses the representation for line
segments described in exercise <a href="#%_thm_2.48">2.48</a> below.
It also uses the <tt>for-each</tt> procedure described in exercise <a href="#%_thm_2.23">2.23</a>.
</p>

<p class="trans" lang="ja">
<tt>segments-&gt;painter</tt> ã¯ã€å¾Œè¿°ã®ç·´ç¿’å•é¡Œ<a href="#%_thm_2.48">2.48</a>ã§èª¬æ˜ã•ã‚Œã¦ã„ã‚‹ã€ç·šåˆ†ã®ãŸã‚ã®è¡¨ç¾ã‚’åˆ©ç”¨ã—ã¦ã„ã‚‹ã€‚
ã¾ãŸã€ç·´ç¿’å•é¡Œ<a href="#%_thm_2.23">2.23</a>ã§èª¬æ˜ã•ã‚Œã¦ã„ã‚‹ã€<tt>for-each</tt> ã¨ã„ã†æ‰‹ç¶šãã‚‚ã€åˆ©ç”¨ã—ã¦ã„ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_216" href="#call_footnote_Temp_216"><sup><small>28</small></sup></a> For example, the <tt>rogers</tt> painter of
figure <a href="#%_fig_2.11">2.11</a> was constructed from a gray-level image.
For each point in a given frame,
the <tt>rogers</tt> painter determines the point in the image that is mapped to it
under the frame coordinate map, and shades it
accordingly.  By allowing different types of painters, we are capitalizing on the
abstract data idea discussed in section <a href="14_sec2_1.html#%_sec_2.1.3">2.1.3</a>, where we
argued that a rational-number representation could be anything at all that
satisfies an appropriate condition.  Here we're using the fact that a
painter can be implemented in any way at all, so long as it draws
something in the designated frame.  Section <a href="14_sec2_1.html#%_sec_2.1.3">2.1.3</a> also
showed how pairs could be implemented as procedures.  Painters are our
second example of a procedural representation for data.
</p>

<p class="trans" lang="ja">
ãŸã¨ãˆã°ã€å›³<a href="#%_fig_2.11">2.11</a>ã«ãŠã‘ã‚‹ <tt>rogers</tt> ã¨ã„ã†ãƒšã‚¤ãƒ³ã‚¿ã¯ã€éšèª¿ç”»åƒã‹ã‚‰æ§‹ç¯‰ã•ã‚ŒãŸã€‚
ä¸ãˆã‚‰ã‚ŒãŸæ ã®ä¸­ã®å„ç‚¹ã«å¯¾ã—ã¦ã€<tt>rogers</tt> ã¨ã„ã†ãƒšã‚¤ãƒ³ã‚¿ã¯ã€æ åº§æ¨™å†™åƒã®ã‚‚ã¨ã§å½“è©²ã®ç‚¹ã«å†™åƒã•ã‚Œã‚‹ã‚ˆã†ãªã€ç”»åƒå†…ã®ç‚¹ã‚’åˆ¤å®šã—ã€ãã‚Œã«ã—ãŸãŒã£ã¦å½“è©²ã®ç‚¹ã«æ¿ƒæ·¡ã‚’ã¤ã‘ã‚‹ã€‚
ç•°ãªã‚‹ç¨®é¡ã®ãƒšã‚¤ãƒ³ã‚¿ã‚’è¨±å®¹ã™ã‚‹ã“ã¨ã§ã€ç§ãŸã¡ã¯ã€<a href="14_sec2_1.html#%_sec_2.1.3">2.1.3</a>ç¯€â€”â€”æœ‰ç†æ•°ã®è¡¨ç¾ã¯ã€é©åˆ‡ãªæ¡ä»¶ã‚’æº€ãŸã™ã‚‚ã®ãªã‚‰ã€ã¨ã«ã‹ãä½•ã§ã§ã‚‚ã‚ã‚Šå¾—ã‚‹ã€ã¨è«–ã˜ãŸâ€”â€”ã§è­°è«–ã—ãŸã€æŠ½è±¡çš„ãƒ‡ãƒ¼ã‚¿ã®è€ƒãˆæ–¹ã‚’ã€åˆ©ç”¨ã—ã¦ã„ã‚‹ã‚ã‘ã ã€‚
ã“ã“ã§ç§ãŸã¡ã¯ã€æŒ‡å®šã•ã‚ŒãŸæ ã®ä¸­ã«ãƒšã‚¤ãƒ³ã‚¿ãŒä½•ã‹ã‚’æãé™ã‚Šã¯ã€ãƒšã‚¤ãƒ³ã‚¿ã¯ã€ã¨ã«ã‹ãã©ã‚“ãªæ–¹æ³•ã§ã‚‚å®Ÿè£…ã§ãã‚‹ã€ã¨ã„ã†äº‹å®Ÿã‚’ä½¿ã£ã¦ã„ã‚‹ã€‚
<a href="14_sec2_1.html#%_sec_2.1.3">2.1.3</a>ç¯€ã§ã‚‚ã€å¯¾ãŒã©ã®ã‚ˆã†ã«ã—ã¦æ‰‹ç¶šãã¨ã—ã¦å®Ÿè£…ã•ã‚Œå¾—ã‚‹ã®ã‹ã‚’ç¤ºã—ãŸã€‚
ãƒšã‚¤ãƒ³ã‚¿ã¯ã€ãƒ‡ãƒ¼ã‚¿ã®æ‰‹ç¶šãçš„è¡¨ç¾ã®ç¬¬äºŒã®ä¾‹ãªã®ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_220" href="#call_footnote_Temp_220"><sup><small>29</small></sup></a> <tt>Rotate90</tt> is a pure rotation only for square
frames, because it also stretches and shrinks the image to fit into
the rotated frame.
</p>

<p class="trans" lang="ja">
<tt>rotate90</tt> ã¯ã€æ­£æ–¹å½¢ã®æ ã®ãŸã‚ã ã‘ã®å˜ãªã‚‹å›è»¢ã§ã‚ã‚‹ã€‚ã¨ã„ã†ã®ã‚‚ã€ã“ã‚Œã¯ã€å›è»¢ã•ã‚ŒãŸæ ã«åˆã†ã‚ˆã†ã«ç”»åƒã‚’ä¼¸ç¸®ã•ã›ã‚‚ã™ã‚‹ã‹ã‚‰ã ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_221" href="#call_footnote_Temp_221"><sup><small>30</small></sup></a> The diamond-shaped images in figures <a href="#%_fig_2.10">2.10</a>
and <a href="#%_fig_2.11">2.11</a> were created with <tt>squash-inwards</tt> applied to
<tt>wave</tt> and <tt>rogers</tt>.
</p>

<p class="trans" lang="ja">
å›³<a href="#%_fig_2.10">2.10</a>ã¨å›³<a href="#%_fig_2.11">2.11</a>ã®ä¸­ã®ãƒ€ã‚¤ãƒ¤å‹ã®ç”»åƒã¯ã€<tt>wave</tt> ã¨ <tt>rogers</tt> ã« <tt>squash-inwards</tt> ã‚’é©ç”¨ã—ãŸã‚‚ã®ã‚’ç”¨ã„ã¦ã€ä½œæˆã•ã‚ŒãŸã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_225" href="#call_footnote_Temp_225"><sup><small>31</small></sup></a> Section <a href="22_sec3_3.html#%_sec_3.3.4">3.3.4</a> describes one such language.
</p>

<p class="trans" lang="ja">
<a href="22_sec3_3.html#%_sec_3.3.4">3.3.4</a>ç¯€ã§ã¯ã€ãã®ã‚ˆã†ãªè¨€èªã®ä¸€ã¤ã‚’èª¬æ˜ã™ã‚‹ã€‚
</p>


</div>

</body>
</html>
