<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="sicp.css" type="text/css">
<base target="_top">
<title>SICPç§è¨³: 5.4 æ˜ç¤ºçš„åˆ¶å¾¡æ–¹å¼ã®è©•ä¾¡å™¨</title>
<link rel="canonical" href="https://piyo-ko.github.io/SICP/34_sec5_4.html" />
</head>
<body>

<div class="idx-bar">
<nav>
<a href="https://twitter.com/share" class="twitter-share-button" data-lang="ja">ãƒ„ã‚¤ãƒ¼ãƒˆ</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
<span class="status">ç¿»è¨³ä¸­</span>
[
<a href="00_cover.html">å…ˆé ­ã¸</a> |
<a href="33_sec5_3.html">å‰ã¸</a> |
<a href="35_sec5_5.html">æ¬¡ã¸</a> |
<a href="04_toc.html#%_toc_start">ç›®æ¬¡</a> |
<a href="38_index.html#%_index_start">ç´¢å¼•</a>
] [<a href="99_about.html">ã“ã®å¯¾è¨³ç‰ˆã«ã¤ã„ã¦</a> | <a href="../index.html">ãƒ›ãƒ¼ãƒ </a>]
[
Â§<a href="#%_sec_5.4">5.4</a>
ğŸ“š<a href="#%_sec_Temp_766">&hellip;</a>
ğŸ¨<a href="#%_fig_5.16">5.16</a>
Â§<a href="#%_sec_5.4.1">5.4.1</a>
ğŸ“š<a href="#%_sec_Temp_768">&hellip;</a>
ğŸ“š<a href="#%_sec_Temp_769">&hellip;</a>
ğŸ“š<a href="#%_sec_Temp_774">&hellip;</a>
Â§<a href="#%_sec_5.4.2">5.4.2</a>
ğŸ“š<a href="#%_sec_Temp_775">&hellip;</a>
Â§<a href="#%_sec_5.4.3">5.4.3</a>
ğŸ“š<a href="#%_sec_Temp_779">&hellip;</a>
ğŸ“<a href="#%_thm_5.23">5.23</a>
ğŸ“<a href="#%_thm_5.24">5.24</a>
ğŸ“<a href="#%_thm_5.25">5.25</a>
Â§<a href="#%_sec_5.4.4">5.4.4</a>
ğŸ“š<a href="#%_sec_Temp_787">&hellip;</a>
ğŸ“<a href="#%_thm_5.26">5.26</a>
ğŸ“<a href="#%_thm_5.27">5.27</a>
ğŸ“<a href="#%_thm_5.28">5.28</a>
ğŸ“<a href="#%_thm_5.29">5.29</a>
ğŸ“<a href="#%_thm_5.30">5.30</a>
<a href="#footnotes">è„šæ³¨</a>
]</nav>
</div>

<div class="main-txt">
<a name="%_sec_5.4"></a>
<h2 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_5.4">5.4  The Explicit-Control Evaluator</a></h2>
<h2 class="trans" lang="ja">5.4 æ˜ç¤ºçš„åˆ¶å¾¡æ–¹å¼ã®è©•ä¾¡å™¨</h2>

<p class="orig" lang="en">
<a name="%_idx_5996"></a>
In section <a href="31_sec5_1.html#%_sec_5.1">5.1</a> we saw how to
transform simple Scheme programs into descriptions of register
machines.  We will now perform this transformation on a more complex
program, the metacircular evaluator of
sections <a href="26_sec4_1.html#%_sec_4.1.1">4.1.1</a>-<a href="26_sec4_1.html#%_sec_4.1.4">4.1.4</a>,
which shows how
the behavior of a Scheme interpreter can be described in terms of the
procedures <tt>eval</tt> and <tt>apply</tt>.
The <em>explicit-control
evaluator</em> that we develop in this section shows how the underlying
procedure-calling and argument-passing mechanisms used in the
evaluation process can be described in terms of operations on
registers and stacks.  In addition, the explicit-control evaluator can
serve as an implementation of a Scheme interpreter, written in a
language that is very similar to the native machine language of
conventional computers.  The evaluator can be executed by the
register-machine simulator of section <a href="32_sec5_2.html#%_sec_5.2">5.2</a>.
Alternatively, it can be used as a starting point for building a
machine-language implementation of a Scheme evaluator, or even a
<a name="%_idx_5998"></a><a name="%_idx_6000"></a><a name="%_idx_6002"></a>special-purpose machine for evaluating Scheme expressions.
Figure <a href="#%_fig_5.16">5.16</a> shows such a hardware implementation: a
silicon chip that acts as an evaluator for Scheme.  The chip designers
started with the data-path and controller specifications for a
register machine similar to the evaluator described in this section
and used design automation programs to construct the
integrated-circuit layout.<a name="call_footnote_Temp_765" href="#footnote_Temp_765"><sup><small>19</small></sup></a></p>

<p class="trans" lang="ja">
<a href="31_sec5_1.html#%_sec_5.1">5.1</a>ç¯€ã§ã¯ã€ã©ã®ã‚ˆã†ã«ã—ã¦å˜ç´”ãª Scheme ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ»ãƒã‚·ãƒ³ã®è¨˜è¿°ã¸ã¨å¤‰æ›ã™ã‚‹ã®ã‹ã‚’è¦‹ãŸã€‚
ã“ã“ã§ã¯ã€ã“ã®å¤‰æ›ã‚’ã€ã‚ˆã‚Šè¤‡é›‘ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã€ã™ãªã‚ã¡ã€<a href="26_sec4_1.html#%_sec_4.1.1">4.1.1</a>ç¯€ã‹ã‚‰<a href="26_sec4_1.html#%_sec_4.1.4">4.1.4</a>ç¯€ã¾ã§ã®ãƒ¡ã‚¿å¾ªç’°çš„ãªè©•ä¾¡å™¨â€”â€”ã“ã‚Œã¯ã€ã©ã®ã‚ˆã†ã«ã—ãŸã‚‰ Scheme ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã®æŒ¯ã‚‹èˆã„ã‚’ <tt>eval</tt> ãŠã‚ˆã³ <tt>apply</tt> ã¨ã„ã†æ‰‹ç¶šãã®è¦³ç‚¹ã‹ã‚‰è¨˜è¿°ã§ãã‚‹ã®ã‹ã€ã‚’ç¤ºã—ã¦ã„ã‚‹â€”â€”ã«ã¤ã„ã¦ã€å®Ÿè¡Œã—ã‚ˆã†ã€‚
è©•ä¾¡ãƒ—ãƒ­ã‚»ã‚¹ã«ãŠã„ã¦ä½¿ã‚ã‚Œã¦ãŠã‚Šã€æ ¹åº•ã«æ¨ªãŸã‚ã£ã¦ã„ã‚‹ã€æ‰‹ç¶šãå‘¼ã³å‡ºã—ãŠã‚ˆã³å¼•æ•°æ¸¡ã—ã®ä»•çµ„ã¿ã‚’ã€ã©ã®ã‚ˆã†ã«ã—ãŸã‚‰ãƒ¬ã‚¸ã‚¹ã‚¿ãŠã‚ˆã³ã‚¹ã‚¿ãƒƒã‚¯ã«å¯¾ã™ã‚‹æ¼”ç®—ã‚’ç”¨ã„ã¦è¨˜è¿°ã§ãã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’ã€æœ¬ç¯€ã§é–‹ç™ºã™ã‚‹<em>æ˜ç¤ºçš„åˆ¶å¾¡æ–¹å¼ã®è©•ä¾¡å™¨</em>ãŒç¤ºã—ã¦ã„ã‚‹ã€‚
ã•ã‚‰ã«ã€æ˜ç¤ºçš„åˆ¶å¾¡æ–¹å¼ã®è©•ä¾¡å™¨ã¯ã€Scheme ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã®å®Ÿè£…â€”â€”å¾“æ¥ã®ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã®ãƒã‚¤ãƒ†ã‚£ãƒ–ãƒ»ãƒã‚·ãƒ³è¨€èªã«ã‚ˆãä¼¼ãŸè¨€èªã§æ›¸ã‹ã‚ŒãŸã‚‚ã®â€”â€”ã¨ã—ã¦ã‚‚æ©Ÿèƒ½ã™ã‚‹ã€‚
ãã®è©•ä¾¡å™¨ã¯ã€<a href="32_sec5_2.html#%_sec_5.2">5.2</a>ç¯€ã®ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ»ãƒã‚·ãƒ³ãƒ»ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã«ã‚ˆã£ã¦å®Ÿè¡Œã§ãã‚‹ã€‚
ã‚ã‚‹ã„ã¯ã€ãã®è©•ä¾¡å™¨ã¯ã€Scheme è©•ä¾¡å™¨ã®ãƒã‚·ãƒ³è¨€èªã§ã®å®Ÿè£…ã‚’æ§‹ç¯‰ã™ã‚‹ãŸã‚ã®é–‹å§‹ç‚¹ã¨ã—ã¦ä½¿ã†ã“ã¨ã‚‚ã§ãã‚‹ã—ã€ã¾ãŸã¯ã€Scheme å¼ã‚’è©•ä¾¡ã™ã‚‹ãŸã‚ã®å°‚ç”¨ãƒã‚·ãƒ³ã¨ã—ã¦ã•ãˆä½¿ãˆã‚‹ã®ã ã€‚
å›³<a href="#%_fig_5.16">5.16</a>ã¯ã€ãã†ã—ãŸãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢å®Ÿè£…â€”â€”ã¤ã¾ã‚Šã€Scheme ç”¨ã®è©•ä¾¡å™¨ã¨ã—ã¦æŒ¯ã‚‹èˆã†ã‚·ãƒªã‚³ãƒ³ãƒ»ãƒãƒƒãƒ—â€”â€”ã‚’ç¤ºã—ã¦ã„ã‚‹ã€‚
ãƒãƒƒãƒ—è¨­è¨ˆè€…ã¯ã€æœ¬ç¯€ã§èª¬æ˜ã™ã‚‹è©•ä¾¡å™¨ã«ä¼¼ãŸãƒ¬ã‚¸ã‚¹ã‚¿ãƒ»ãƒã‚·ãƒ³ã«ã¤ã„ã¦ã®ã€ãƒ‡ãƒ¼ã‚¿çµŒè·¯ã¨ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ã®ä»•æ§˜ã‹ã‚‰é–‹å§‹ã—ã¦ã€è¨­è¨ˆè‡ªå‹•åŒ–ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ç”¨ã„ã¦é›†ç©å›è·¯ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚’æ§‹ç¯‰ã—ãŸ<a href="#footnote_Temp_765"><sup><small>19</small></sup></a>ã€‚
</p>

<a name="%_sec_Temp_766"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_766">Registers and operations</a></h4>
<h4 class="trans" lang="ja">ãƒ¬ã‚¸ã‚¹ã‚¿ã¨æ¼”ç®—</h4>

<p class="orig" lang="en">
<a name="%_idx_6006"></a>
<a name="%_idx_6008"></a>In designing the explicit-control evaluator, we must specify the
operations to be used in our register machine.  We described the
metacircular evaluator in terms of abstract syntax, using procedures
such as <tt>quoted?</tt> and <tt>make-procedure</tt>.  In implementing the
register machine, we could expand these procedures into sequences of
elementary list-structure memory operations, and implement these
operations on our register machine.  However, this would make our
evaluator very long, obscuring the basic structure with
details.  To clarify the presentation, we will include as primitive
operations of the register machine the syntax procedures given in
section <a href="26_sec4_1.html#%_sec_4.1.2">4.1.2</a> and the procedures for
representing environments and other run-time data given in
sections <a href="26_sec4_1.html#%_sec_4.1.3">4.1.3</a> and <a href="26_sec4_1.html#%_sec_4.1.4">4.1.4</a>.
In order to completely specify an evaluator that could be programmed
in a low-level machine language or implemented in hardware, we would
replace these operations by more elementary operations, using the
list-structure implementation we described in
section <a href="33_sec5_3.html#%_sec_5.3">5.3</a>.</p>

<p class="trans" lang="ja">
æ˜ç¤ºçš„åˆ¶å¾¡æ–¹å¼ã®è©•ä¾¡å™¨ã‚’è¨­è¨ˆã™ã‚‹éš›ã«ã¯ã€è‡ªåˆ†ã®ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ»ãƒã‚·ãƒ³ã§ä½¿ã‚ã‚Œã‚‹ã“ã¨ã«ãªã‚‹æ¼”ç®—å­ã‚’æŒ‡å®šã›ã­ã°ãªã‚‰ãªã„ã€‚
ç§ãŸã¡ã¯ã€<tt>quoted?</tt> ã‚„ <tt>make-procedure</tt> ã®ã‚ˆã†ãªæ‰‹ç¶šãã‚’ä½¿ã£ã¦ã€æŠ½è±¡çš„æ–‡æ³•ã®è¦³ç‚¹ã‹ã‚‰ãƒ¡ã‚¿å¾ªç’°çš„ãªè©•ä¾¡å™¨ã‚’èª¬æ˜ã—ãŸã€‚
ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ»ãƒã‚·ãƒ³ã‚’å®Ÿè£…ã™ã‚‹éš›ã«ã¯ã€ã“ã‚Œã‚‰ã®æ‰‹ç¶šãã‚’ã€åŸºç¤çš„ãªã€ãƒªã‚¹ãƒˆæ§‹é€ ã«ã¤ã„ã¦ã®ãƒ¡ãƒ¢ãƒªæ“ä½œã®ä¸¦ã³ã¸ã¨æ‹¡å¼µã™ã‚‹ã“ã¨ã€ãã—ã¦ã€è‡ªåˆ†ã®ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ»ãƒã‚·ãƒ³ä¸Šã«ã“ã‚Œã‚‰ã®æ“ä½œã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ãŒã€ã§ãã‚‹ã ã‚ã†ã€‚
ã—ã‹ã—ã€ã“ã‚Œã¯ã€åŸºæœ¬çš„æ§‹é€ ã‚’ç´°éƒ¨ã§è¦†ã„éš ã—ã¦ã—ã¾ã„ã€ç§ãŸã¡ã®ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ»ãƒã‚·ãƒ³ã‚’ã¨ã¦ã‚‚é•·å¤§ã«ã—ã¦ã—ã¾ã†ã ã‚ã†ã€‚
æç¤ºã®ä»•æ–¹ã‚’æ˜ç¢ºåŒ–ã™ã‚‹ãŸã‚ã«ã€ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ»ãƒã‚·ãƒ³ã®åŸå§‹çš„æ¼”ç®—ã¨ã—ã¦ã€<a href="26_sec4_1.html#%_sec_4.1.2">4.1.2</a>ç¯€ã§ç¤ºã•ã‚ŒãŸæ–‡æ³•æ‰‹ç¶šãã¨ã€<a href="26_sec4_1.html#%_sec_4.1.3">4.1.3</a>ç¯€ãŠã‚ˆã³<a href="26_sec4_1.html#%_sec_4.1.4">4.1.4</a>ç¯€ã§ç¤ºã•ã‚ŒãŸã€ç’°å¢ƒã‚„ãã®ä»–ã®å®Ÿè¡Œæ™‚ã®ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ç¾ã™ã‚‹ãŸã‚ã®æ‰‹ç¶šãã¨ã‚’ã€å«ã‚ã‚‹ã“ã¨ã«ã—ã‚ˆã†ã€‚
ä½æ°´æº–ã®ãƒã‚·ãƒ³è¨€èªã§ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã•ã‚Œå¾—ã‚‹ã‚ˆã†ãªã€ã‚ã‚‹ã„ã¯ã€ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ã§å®Ÿè£…ã•ã‚Œå¾—ã‚‹ã‚ˆã†ãªã€è©•ä¾¡å™¨ã®æ˜ç´°ã‚’å®Œå…¨ã«æŒ‡å®šã™ã‚‹ãŸã‚ã«ã€ç§ãŸã¡ã¯ã€ã“ã‚Œã‚‰ã®æ¼”ç®—ã‚’â€”â€”<a href="33_sec5_3.html#%_sec_5.3">5.3</a>ç¯€ã§èª¬æ˜ã—ãŸã€ãƒªã‚¹ãƒˆæ§‹é€ ã®å®Ÿè£…ã‚’ç”¨ã„ã¦â€”â€”ã‚ˆã‚ŠåŸºç¤çš„ãªæ¼”ç®—ã§ç½®ãæ›ãˆã‚ˆã†ã€‚
</p>

<figure>
<a name="%_fig_5.16"></a>
<img src="chip.jpg" border="0" height=310>
<figcaption class="orig" lang="en"><b>Figure 5.16:</b>  A silicon-chip implementation of an evaluator for
Scheme.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³5.16.:</b> Scheme ç”¨ã®è©•ä¾¡å™¨ã®ã€ã‚·ãƒªã‚³ãƒ³ãƒ»ãƒãƒƒãƒ—ã§ã®å®Ÿè£…</figcaption>
</figure>
<a name="%_idx_6010"></a><a name="%_idx_6012"></a><a name="%_idx_6014"></a>

<a name="%_idx_6016"></a><a name="%_idx_6018"></a><a name="%_idx_6020"></a><a name="%_idx_6022"></a><a name="%_idx_6024"></a><a name="%_idx_6026"></a><a name="%_idx_6028"></a><a name="%_idx_6030"></a>

<p class="orig" lang="en">
Our Scheme evaluator register machine includes a stack and seven
registers: <tt>exp</tt>, <tt>env</tt>, <tt>val</tt>, <tt>continue</tt>, <tt>proc</tt>,
<tt>argl</tt>, and <tt>unev</tt>.  <tt>Exp</tt> is used to hold the expression
to be evaluated, and <tt>env</tt> contains the environment in which the
evaluation is to be performed.  At the end of an evaluation, <tt>val</tt>
contains the value obtained by evaluating the expression in the
designated environment.  The <tt>continue</tt> register is used to
implement recursion, as explained in
section <a href="31_sec5_1.html#%_sec_5.1.4">5.1.4</a>.  (The evaluator needs to call
itself recursively, since evaluating an expression requires evaluating
its subexpressions.)  The registers <tt>proc</tt>, <tt>argl</tt>, and <tt>unev</tt> are used in evaluating combinations.</p>

<p class="trans" lang="ja">
ç§ãŸã¡ã® Scheme è©•ä¾¡å™¨ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ»ãƒã‚·ãƒ³ã¯ã€ã‚¹ã‚¿ãƒƒã‚¯ã¨ã€ä¸ƒã¤ã®ãƒ¬ã‚¸ã‚¹ã‚¿â€”â€”ã™ãªã‚ã¡ã€<tt>exp</tt> ã¨ã€<tt>env</tt> ã¨ã€<tt>val</tt> ã¨ã€<tt>continue</tt> ã¨ã€<tt>proc</tt> ã¨ã€<tt>argl</tt> ã¨ã€<tt>unev</tt> â€”â€”ã¨ã‚’å«ã‚€ã€‚
<tt>exp</tt> ã¯ã€è©•ä¾¡ã™ã¹ãå¼ã‚’ä¿æŒã™ã‚‹ã®ã«ä½¿ã‚ã‚Œã€<tt>env</tt> ã¯ã€è©•ä¾¡ãŒè¡Œã‚ã‚Œã‚‹ã¹ãç’°å¢ƒã‚’å«ã‚€ã€‚
è©•ä¾¡ã®çµ‚äº†æ™‚ã«ãŠã„ã¦ã€<tt>val</tt> ã¯ã€æŒ‡å®šã•ã‚ŒãŸç’°å¢ƒã§å¼ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ã§å¾—ã‚‰ã‚ŒãŸå€¤ã‚’å«ã‚€ã€‚
<tt>continue</tt> ãƒ¬ã‚¸ã‚¹ã‚¿ã¯ã€<a href="31_sec5_1.html#%_sec_5.1.4">5.1.4</a>ç¯€ã§èª¬æ˜ã—ãŸã‚ˆã†ã«ã—ã¦å†å¸°ã‚’å®Ÿè£…ã™ã‚‹ã®ã«ä½¿ã‚ã‚Œã‚‹
(å¼ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ã¯ã€ãã®å¼ã®éƒ¨åˆ†å¼ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ã‚’è¦ã™ã‚‹ãŸã‚ã€è©•ä¾¡å™¨ã¯ã€è‡ªåˆ†è‡ªèº«ã‚’å†å¸°çš„ã«å‘¼ã³å‡ºã™å¿…è¦ãŒã‚ã‚‹)ã€‚
<tt>proc</tt> ã¨ <tt>argl</tt> ã¨ <tt>unev</tt> ã¨ã„ã†ãƒ¬ã‚¸ã‚¹ã‚¿ã¯ã€ã‚³ãƒ³ãƒ“ãƒãƒ¼ã‚·ãƒ§ãƒ³ã‚’è©•ä¾¡ã™ã‚‹éš›ã«ä½¿ã‚ã‚Œã‚‹ã€‚
</p>

<p class="orig" lang="en">
We will not provide a data-path diagram to show how the registers and
operations of the evaluator are connected, nor will we give the
complete list of machine operations.  These are implicit in the
evaluator's controller, which will be presented in detail.</p>

<p class="trans" lang="ja">
ãƒ¬ã‚¸ã‚¹ã‚¿ã¨ã€è©•ä¾¡å™¨ã®æ¼”ç®—ã¨ãŒã€ã©ã®ã‚ˆã†ã«ã—ã¦çµã³ã¤ã‘ã‚‰ã‚Œã¦ã„ã‚‹ã®ã‹ã‚’ç¤ºã™ãƒ‡ãƒ¼ã‚¿çµŒè·¯å›³ã‚’ã€ç§ãŸã¡ã¯æä¾›ã—ãªã„ã“ã¨ã«ã™ã‚‹ã—ã€ãƒã‚·ãƒ³æ¼”ç®—ã®å®Œå…¨ãªãƒªã‚¹ãƒˆã‚‚ç¤ºã•ãªã„ã“ã¨ã«ã—ã‚ˆã†ã€‚
ã“ã‚Œã‚‰ã¯ã€è©•ä¾¡å™¨ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©â€”â€”ã“ã‚Œã¯è©³ã—ãæç¤ºã—ã‚ˆã†â€”â€”ã®ä¸­ã§ã€æš—é»™çš„ã§ã‚ã‚‹ã€‚
</p>

<a name="%_sec_5.4.1"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_5.4.1">5.4.1  The Core of the Explicit-Control Evaluator</a></h3>
<h3 class="trans" lang="ja">5.4.1 æ˜ç¤ºçš„åˆ¶å¾¡æ–¹å¼ã®è©•ä¾¡å™¨ã®æ ¸</h3>

<p class="orig" lang="en"><a name="%_idx_6032"></a>
The central element in the evaluator is the sequence of instructions
beginning at <tt>eval-dispatch</tt>.  This corresponds to the <tt>eval</tt>
procedure of the metacircular evaluator described in
section <a href="26_sec4_1.html#%_sec_4.1.1">4.1.1</a>.  When the controller starts at <tt>eval-dispatch</tt>, it evaluates the expression specified by <tt>exp</tt> in
the environment specified by <tt>env</tt>.  When evaluation is complete,
the controller will go to the entry point stored in <tt>continue</tt>, and the
<tt>val</tt> register will hold the value of the expression.  As with the
metacircular <tt>eval</tt>, the structure of <tt>eval-dispatch</tt> is a
case analysis on the syntactic type of the expression to be
evaluated.<a name="call_footnote_Temp_767" href="#footnote_Temp_767"><sup><small>20</small></sup></a></p>

<p class="trans" lang="ja">
è©•ä¾¡å™¨ã«ãŠã‘ã‚‹ä¸­å¿ƒçš„è¦ç´ ã¯ã€<tt>eval-dispatch</tt> ã§å§‹ã¾ã‚‹ä¸€é€£ã®å‘½ä»¤ã§ã‚ã‚‹ã€‚
ã“ã‚Œã¯ã€<a href="26_sec4_1.html#%_sec_4.1.1">4.1.1</a>ç¯€ã§èª¬æ˜ã—ãŸãƒ¡ã‚¿å¾ªç’°çš„ãªè©•ä¾¡å™¨ã® <tt>eval</tt> æ‰‹ç¶šãã«å¯¾å¿œã™ã‚‹ã€‚
ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ã¯ã€<tt>eval-dispatch</tt> ã‹ã‚‰é–‹å§‹ã™ã‚‹éš›ã«ã€<tt>exp</tt> ã«ã‚ˆã‚ŠæŒ‡å®šã•ã‚ŒãŸå¼ã‚’ã€<tt>env</tt> ã«ã‚ˆã‚ŠæŒ‡å®šã•ã‚ŒãŸç’°å¢ƒå†…ã§ã€è©•ä¾¡ã™ã‚‹ã€‚
è©•ä¾¡ãŒå®Œäº†ã™ã‚‹ã¨ã€ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ã¯ã€<tt>continue</tt> ã«è¨˜æ†¶ã•ã‚ŒãŸã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒã‚¤ãƒ³ãƒˆã¸è¡Œãã ã‚ã†ã—ã€<tt>val</tt> ãƒ¬ã‚¸ã‚¹ã‚¿ã¯ã€ãã®å¼ã®å€¤ã‚’ä¿æŒã—ã¦ã„ã‚‹ã ã‚ã†ã€‚
ãƒ¡ã‚¿å¾ªç’°çš„ãª <tt>eval</tt> ã¨åŒæ§˜ã«ã€<tt>eval-dispatch</tt> ã®æ§‹é€ ã¯ã€è©•ä¾¡ã™ã¹ãå¼ã®æ–‡æ³•çš„ãªç¨®é¡ã«åŸºã¥ãå ´åˆåˆ†ã‘åˆ†æã§ã‚ã‚‹<a href="#footnote_Temp_767"><sup><small>20</small></sup></a>ã€‚
</p>

<p class="lisp"><a name="%_idx_6034"></a>eval-dispatch
  (test (op self-evaluating?) (reg exp))
  (branch (label ev-self-eval))
  (test (op variable?) (reg exp))
  (branch (label ev-variable))
  (test (op quoted?) (reg exp))
  (branch (label ev-quoted))
  (test (op assignment?) (reg exp))
  (branch (label ev-assignment))
  (test (op definition?) (reg exp))
  (branch (label ev-definition))
  (test (op if?) (reg exp))
  (branch (label ev-if))
  (test (op lambda?) (reg exp))
  (branch (label ev-lambda))
  (test (op begin?) (reg exp))
  (branch (label ev-begin))
  (test (op application?) (reg exp))
  (branch (label ev-application))
  (goto (label unknown-expression-type))
</p>

<a name="%_sec_Temp_768"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_768">Evaluating simple expressions</a></h4>
<h4 class="trans" lang="ja">å˜ç´”ãªå¼ã‚’è©•ä¾¡ã™ã‚‹</h4>

<p class="orig" lang="en">
<a name="%_idx_6036"></a>
Numbers and strings (which are self-evaluating),
variables, quotations, and <tt>lambda</tt> expressions have no
subexpressions to be evaluated.  For these, the evaluator simply
places the correct value in the <tt>val</tt> register and continues
execution at the entry point specified by <tt>continue</tt>.  Evaluation
of simple expressions is performed by the following controller code:</p>

<p class="trans" lang="ja">
æ•°ãŠã‚ˆã³æ–‡å­—åˆ— (ã“ã‚Œã‚‰ã¯è‡ªå·±è©•ä¾¡çš„ã§ã‚ã‚‹) ã¨ã€å¤‰æ•°ã¨ã€å¼•ç”¨ã¨ã€<tt>lambda</tt> å¼ã«ã¯ã€è©•ä¾¡ã™ã¹ãéƒ¨åˆ†å¼ãŒãªã„ã€‚
ã“ã‚Œã‚‰ã«ã¤ã„ã¦è©•ä¾¡å™¨ã¯ã€å˜ã«ã€<tt>val</tt> ãƒ¬ã‚¸ã‚¹ã‚¿ã«æ­£ã—ã„å€¤ã‚’ç½®ã„ã¦ã€<tt>continue</tt> ã«ã‚ˆã‚ŠæŒ‡å®šã•ã‚ŒãŸã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒã‚¤ãƒ³ãƒˆã§å®Ÿè¡Œã‚’ç¶šã‘ã‚‹ã ã‘ã§ã‚ã‚‹ã€‚
å˜ç´”ãªå¼ã®è©•ä¾¡ã¯ã€ä»¥ä¸‹ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ»ã‚³ãƒ¼ãƒ‰ã«ã‚ˆã£ã¦å®Ÿè¡Œã•ã‚Œã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_6038"></a>ev-self-eval
  (assign val (reg exp))
  (goto (reg continue))
<a name="%_idx_6040"></a>ev-variable
  (assign val (op lookup-variable-value) (reg exp) (reg env))
  (goto (reg continue))
<a name="%_idx_6042"></a>ev-quoted
  (assign val (op text-of-quotation) (reg exp))
  (goto (reg continue))
<a name="%_idx_6044"></a>ev-lambda
  (assign unev (op lambda-parameters) (reg exp))
  (assign exp (op lambda-body) (reg exp))
  (assign val (op make-procedure)
              (reg unev) (reg exp) (reg env))
  (goto (reg continue))
</p>

<p class="orig" lang="en">Observe how <tt>ev-lambda</tt> uses the <tt>unev</tt> and <tt>exp</tt>
registers to hold the parameters and body of the lambda expression so
that they can be passed to the <tt>make-procedure</tt> operation, along
with the environment in <tt>env</tt>.</p>

<p class="trans" lang="ja">
ã©ã®ã‚ˆã†ã«ã—ã¦ <tt>ev-lambda</tt> ãŒã€ãƒ©ãƒ ãƒ€å¼ã®ä»®å¼•æ•°ã¨æœ¬ä½“ã‚’ <tt>env</tt> å†…ã®ç’°å¢ƒã¨ã¨ã‚‚ã« <tt>make-procedure</tt> æ¼”ç®—ã¸ã¨å—ã‘æ¸¡ã›ã‚‹ã‚ˆã†ã«ã€<tt>unev</tt> ãƒ¬ã‚¸ã‚¹ã‚¿ã¨ <tt>exp</tt> ãƒ¬ã‚¸ã‚¹ã‚¿ã‚’ä½¿ã£ã¦ãƒ©ãƒ ãƒ€å¼ã®ä»®å¼•æ•°ã¨æœ¬ä½“ã¨ã‚’ä¿æŒã™ã‚‹ã®ã‹ã‚’ã€ã‚ˆãè¦‹ã¦ã»ã—ã„ã€‚
</p>

<a name="%_sec_Temp_769"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_769">Evaluating procedure applications</a></h4>
<h4 class="trans" lang="ja">æ‰‹ç¶šãé©ç”¨ã‚’è©•ä¾¡ã™ã‚‹</h4>


<p class="orig" lang="en">
<a name="%_idx_6046"></a><a name="%_idx_6048"></a>
A procedure application is specified by a combination containing an
operator and operands.  The operator is a subexpression whose value is
a procedure, and the operands are subexpressions whose values are the
arguments to which the procedure should be applied.  The metacircular
<tt>eval</tt> handles applications by calling itself recursively to
evaluate each element of the combination, and then passing the results
to <tt>apply</tt>, which performs the actual procedure application.  The
explicit-control evaluator does the same thing; these recursive calls
are implemented by <tt>goto</tt> instructions, together with <a name="%_idx_6050"></a>use of the
stack to save registers that will be restored after the recursive call
returns.  Before each call we will be careful to identify which
registers must be saved (because their values will be needed
later).<a name="call_footnote_Temp_770" href="#footnote_Temp_770"><sup><small>21</small></sup></a></p>

<p class="trans" lang="ja">
æ‰‹ç¶šãé©ç”¨ã¯ã€æ¼”ç®—å­ã¨ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã¨ã‚’å«ã‚€ã‚³ãƒ³ãƒ“ãƒãƒ¼ã‚·ãƒ§ãƒ³ã«ã‚ˆã‚Šã€æŒ‡å®šã•ã‚Œã‚‹ã€‚
æ¼”ç®—å­ã¯ã€ãã®å€¤ãŒæ‰‹ç¶šãã¨ãªã‚‹ã‚ˆã†ãªéƒ¨åˆ†å¼ã§ã‚ã‚Šã€ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã¯ã€ãã®å€¤ãŒã€å½“è©²æ‰‹ç¶šãã‚’é©ç”¨ã™ã¹ãå®Ÿå¼•æ•°ã¨ãªã‚‹ã‚ˆã†ãªéƒ¨åˆ†å¼ã§ã‚ã‚‹ã€‚
ãƒ¡ã‚¿å¾ªç’°çš„ãª <tt>eval</tt> ã¯ã€ã‚³ãƒ³ãƒ“ãƒãƒ¼ã‚·ãƒ§ãƒ³ã®å„è¦ç´ ã‚’è©•ä¾¡ã™ã‚‹ãŸã‚ã«è‡ªåˆ†è‡ªèº«ã‚’å†å¸°çš„ã«å‘¼ã³å‡ºã—ã€ãã‚Œã‹ã‚‰ã€ãã®çµæœã‚’ <tt>apply</tt> â€”â€”å®Ÿéš›ã®æ‰‹ç¶šãé©ç”¨ã‚’å®Ÿè¡Œã™ã‚‹â€”â€”ã«æ¸¡ã™ã“ã¨ã§ã€é©ç”¨ã‚’æ‰±ã†ã€‚
æ˜ç¤ºçš„åˆ¶å¾¡æ–¹å¼ã®è©•ä¾¡å™¨ã¯ã€åŒã˜ã“ã¨ã‚’è¡Œã†ã€‚ã¤ã¾ã‚Šã€ã“ã‚Œã‚‰ã®å†å¸°çš„ãªå‘¼ã³å‡ºã—ã¯ã€å†å¸°çš„ãªå‘¼ã³å‡ºã—ãŒæˆ»ã£ãŸå¾Œã§å¾©æ—§ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ãƒ¬ã‚¸ã‚¹ã‚¿ã‚’é€€é¿ã™ã‚‹ãŸã‚ã®ã‚¹ã‚¿ãƒƒã‚¯ã®ä½¿ç”¨ã¨ã‚ã‚ã›ãŸã€<tt>goto</tt> å‘½ä»¤ã«ã‚ˆã£ã¦ã€å®Ÿè£…ã•ã‚Œã‚‹ã®ã§ã‚ã‚‹ã€‚
ãã‚Œãã‚Œã®å‘¼ã³å‡ºã—ã®å‰ã«ã€ç§ãŸã¡ã¯ã€ã©ã®ãƒ¬ã‚¸ã‚¹ã‚¿ãŒ (ãã®ãƒ¬ã‚¸ã‚¹ã‚¿ã®å€¤ãŒå¾Œã«å¿…è¦ã¨ã•ã‚Œã‚‹ã ã‚ã†ã‹ã‚‰) é€€é¿ã•ã‚Œãªãã¦ã¯ãªã‚‰ãªã„ã®ã‹ã‚’çªãæ­¢ã‚ã‚‹ã¹ãã€æ°—ã‚’ã¤ã‘ã‚‹ã“ã¨ã«ã—ã‚ˆã†<a href="#footnote_Temp_770"><sup><small>21</small></sup></a>ã€‚
</p>

<p class="orig" lang="en">
We begin the evaluation of an application by evaluating the operator
to produce a procedure, which will later be applied to the evaluated
operands.  To evaluate the operator, we move it to the <tt>exp</tt>
register and go to <tt>eval-dispatch</tt>.  The environment in the <tt>env</tt> register is already the correct one in which to evaluate the
operator.  However, we save <tt>env</tt> because we will need it later to
evaluate the operands.  We also extract the operands into <tt>unev</tt>
and save this on the stack.  We set up <tt>continue</tt> so that <tt>eval-dispatch</tt> will resume at <tt>ev-appl-did-operator</tt> after the
operator has been evaluated.  First, however, we save the old value of
<tt>continue</tt>, which tells the controller where to continue after the
application.</p>

<p class="trans" lang="ja">
æ¼”ç®—å­ã‚’è©•ä¾¡ã—ã¦ã€æ‰‹ç¶šãâ€”â€”å¾Œã«ã€è©•ä¾¡ã•ã‚ŒãŸã‚ªãƒšãƒ©ãƒ³ãƒ‰ã«é©ç”¨ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹â€”â€”ã‚’ä½œã‚Šå‡ºã™ã“ã¨ã‹ã‚‰ã€é©ç”¨ã®è©•ä¾¡ã‚’å§‹ã‚ã‚‹ã€‚
æ¼”ç®—å­ã‚’è©•ä¾¡ã™ã‚‹ã«ã¯ã€ãã®æ¼”ç®—å­ã‚’ <tt>exp</tt> ãƒ¬ã‚¸ã‚¹ã‚¿ã«ç§»å‹•ã—ã€<tt>eval-dispatch</tt> ã¸è¡Œãã€‚
<tt>env</tt> ãƒ¬ã‚¸ã‚¹ã‚¿å†…ã®ç’°å¢ƒã¯ã€æ—¢ã«ã€ãã®ä¸­ã§ãã®æ¼”ç®—å­ã‚’è©•ä¾¡ã™ã¹ãæ­£ã—ã„ã‚‚ã®ã¨ãªã£ã¦ã„ã‚‹ã€‚
ã—ã‹ã—ã€ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã‚’è©•ä¾¡ã™ã‚‹ãŸã‚ã«å¾Œã§å¿…è¦ã«ãªã‚‹ã ã‚ã†ã‹ã‚‰ã€<tt>env</tt> ã‚’é€€é¿ã™ã‚‹ã€‚
ã¾ãŸã€<tt>unev</tt> ã¸ã¨ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã‚’æŠ½å‡ºã—ã¦ã€ã“ã‚Œã‚’ã‚¹ã‚¿ãƒƒã‚¯ä¸Šã«é€€é¿ã™ã‚‹ã€‚
æ¼”ç®—å­ãŒè©•ä¾¡ã•ã‚Œçµ‚ã‚ã£ãŸã‚‰ <tt>ev-appl-did-operator</tt> ã« <tt>eval-dispatch</tt> ãŒå¾©æ—§ã•ã‚Œã‚‹ã‚ˆã†ã«ã€<tt>continue</tt> ã‚’è¨­å®šã™ã‚‹ã€‚
ã—ã‹ã—ã€ã¾ãšã¯ã€<tt>continue</tt> ã®å¤ã„å€¤â€”â€”é©ç”¨å¾Œã«ç¶šè¡Œã™ã¹ãå ´æ‰€ã‚’ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ã«æ•™ãˆã¦ãã‚Œã‚‹â€”â€”ã‚’é€€é¿ã™ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_6056"></a>ev-application
  (save continue)
  (save env)
  (assign unev (op operands) (reg exp))
  (save unev)
  (assign exp (op operator) (reg exp))
  (assign continue (label ev-appl-did-operator))
  (goto (label eval-dispatch))
</p>

<p class="orig" lang="en">
<a name="%_idx_6058"></a>Upon returning from evaluating the operator subexpression, we proceed
to evaluate the operands of the combination and to accumulate the
resulting arguments in a list, held in <tt>argl</tt>.  First we restore
the unevaluated operands and the environment.  We initialize <tt>argl</tt> to an empty list.  Then we assign to the <tt>proc</tt> register the
procedure that was produced by evaluating the operator.  If there are
no operands, we go directly to <tt>apply-dispatch</tt>.  Otherwise we
save <tt>proc</tt> on the stack and start the argument-evaluation
loop:<a name="call_footnote_Temp_771" href="#footnote_Temp_771"><sup><small>22</small></sup></a></p>

<p class="trans" lang="ja">
æ¼”ç®—å­ã®éƒ¨åˆ†å¼ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ã‹ã‚‰æˆ»ã£ãŸã‚‰ã€ã‚³ãƒ³ãƒ“ãƒãƒ¼ã‚·ãƒ§ãƒ³ã®ã†ã¡ã®ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ã€ãã—ã¦ã€çµæœã¨ã—ã¦å¾—ã‚‰ã‚Œã‚‹å®Ÿå¼•æ•°ã‚’ã€<tt>argl</tt> å†…ã«ä¿æŒã•ã‚Œã‚‹ãƒªã‚¹ãƒˆã®ä¸­ã«è“„ç©ã™ã‚‹ã“ã¨ã«ã€å–ã‚Šæ›ã‹ã‚‹ã€‚
ã¾ãšã€æœªè©•ä¾¡ã®ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã¨ã€ç’°å¢ƒã¨ã‚’å¾©æ—§ã™ã‚‹ã€‚
<tt>argl</tt> ã‚’ç©ºãƒªã‚¹ãƒˆã«åˆæœŸåŒ–ã™ã‚‹ã€‚
ãã‚Œã‹ã‚‰ã€æ¼”ç®—å­ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ã§ä½œã‚Šå‡ºã•ã‚ŒãŸæ‰‹ç¶šãã‚’ã€<tt>proc</tt> ãƒ¬ã‚¸ã‚¹ã‚¿ã«å‰²ã‚Šå½“ã¦ã‚‹ã€‚
ã‚‚ã—ã€ã‚ªãƒšãƒ©ãƒ³ãƒ‰ãŒãªã‘ã‚Œã°ã€ã™ãã« <tt>apply-dispatch</tt> ã¸è¡Œãã€‚
ãã‚Œä»¥å¤–ã®å ´åˆã¯ã€<tt>proc</tt> ã‚’ã‚¹ã‚¿ãƒƒã‚¯ä¸Šã«é€€é¿ã—ã¦ã€å¼•æ•°è©•ä¾¡ã®ãƒ«ãƒ¼ãƒ—ã‚’é–‹å§‹ã™ã‚‹<a href="#footnote_Temp_771"><sup><small>22</small></sup></a>ã€‚
</p>

<p class="lisp">ev-appl-did-operator
  (restore unev)                  <em>; the operands</em>
  (restore env)
  (assign argl (op empty-arglist))
  (assign proc (reg val))         <em>; the operator</em>
  (test (op no-operands?) (reg unev))
  (branch (label apply-dispatch))
  (save proc)
</p>

<p class="orig" lang="en">
Each cycle of the argument-evaluation loop evaluates an operand
from the list in <tt>unev</tt> and accumulates the result into <tt>argl</tt>.
To evaluate an operand, we place it in the <tt>exp</tt> register
and go to <tt>eval-dispatch</tt>, after setting <tt>continue</tt> so that
execution will resume with the argument-accumulation phase.  But first
we save the arguments accumulated so far (held in <tt>argl</tt>), the
environment (held in <tt>env</tt>), and the remaining operands to be evaluated
(held in <tt>unev</tt>).  A special case is made for the evaluation of the
last operand, which is handled at <tt>ev-appl-last-arg</tt>.</p>

<p class="trans" lang="ja">
å¼•æ•°è©•ä¾¡ã®ãƒ«ãƒ¼ãƒ—ã®ãã‚Œãã‚Œã®ä¸€å·¡ã‚Šã¯ã€<tt>unev</tt> å†…ã®ãƒªã‚¹ãƒˆã®ä¸€ã¤ã®ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã‚’è©•ä¾¡ã—ã€ãã®çµæœã‚’ <tt>argl</tt> ã«è“„ç©ã™ã‚‹ã€‚
ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã‚’è©•ä¾¡ã™ã‚‹ã«ã¯ã€ãã®ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã‚’ <tt>exp</tt> ãƒ¬ã‚¸ã‚¹ã‚¿ã«å…¥ã‚Œã¦ã€<tt>eval-dispatch</tt> ã¸è¡Œãâ€”â€”ãŸã ã—ã€å¼•æ•°ã‚’è“„ç©ã™ã‚‹æ®µéšã§å®Ÿè¡ŒãŒå†é–‹ã™ã‚‹ã‚ˆã†ã« <tt>continue</tt> ã‚’è¨­å®šã—ã¦ã‹ã‚‰ã ãŒã€‚
ã—ã‹ã—ã€ã¾ãšã¯ã€ä»Šã¾ã§è“„ç©ã•ã‚Œã¦ããŸå¼•æ•° (<tt>argl</tt> ã«ä¿æŒã•ã‚Œã¦ã„ã‚‹) ã¨ã€ç’°å¢ƒ (<tt>env</tt> ã«ä¿æŒã•ã‚Œã¦ã„ã‚‹) ã¨ã€è©•ä¾¡ã™ã¹ãæ®‹ã‚Šã®ã‚ªãƒšãƒ©ãƒ³ãƒ‰ (<tt>unev</tt> ã«ä¿æŒã•ã‚Œã¦ã„ã‚‹) ã¨ã‚’ã€é€€é¿ã™ã‚‹ã€‚
æœ€å¾Œã®ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã®è©•ä¾¡â€”â€” <tt>ev-appl-last-arg</tt> ã§æ‰±ã‚ã‚Œã‚‹â€”â€”ã«ã¤ã„ã¦ã¯ã€ç‰¹åˆ¥ãªå ´åˆãŒè¨­ã‘ã‚‰ã‚Œã¦ã„ã‚‹ã€‚
</p>

<p class="lisp">ev-appl-operand-loop
  (save argl)
  (assign exp (op first-operand) (reg unev))
  (test (op last-operand?) (reg unev))
  (branch (label ev-appl-last-arg))
  (save env)
  (save unev)
  (assign continue (label ev-appl-accumulate-arg))
  (goto (label eval-dispatch))
</p>

<p class="orig" lang="en">
When an operand has been evaluated, the value is accumulated into the
list held in <tt>argl</tt>.  The operand is then removed from the list of
unevaluated operands in <tt>unev</tt>, and the argument-evaluation continues.</p>

<p class="trans" lang="ja">
ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã‚’è©•ä¾¡ã—çµ‚ãˆãŸã‚‰ã€ãã®å€¤ã‚’ã€<tt>argl</tt> å†…ã«ä¿æŒã•ã‚Œã¦ã„ã‚‹ãƒªã‚¹ãƒˆã«è“„ç©ã™ã‚‹ã€‚
ãã‚Œã‹ã‚‰ã€ãã®ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã‚’ <tt>unev</tt> å†…ã®æœªè©•ä¾¡ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã®ãƒªã‚¹ãƒˆã‹ã‚‰å–ã‚Šé™¤ã„ã¦ã€å¼•æ•°è©•ä¾¡ãŒç¶šè¡Œã™ã‚‹ã€‚
</p>

<p class="lisp">ev-appl-accumulate-arg
  (restore unev)
  (restore env)
  (restore argl)
  (assign argl (op adjoin-arg) (reg val) (reg argl))
  (assign unev (op rest-operands) (reg unev))
  (goto (label ev-appl-operand-loop))
</p>

<p class="orig" lang="en">
Evaluation of the last argument is handled differently.  There is no
need to save the environment or the list of unevaluated operands
before going to <tt>eval-dispatch</tt>,
since they will not be required after the last operand is evaluated.
Thus, we return from the evaluation to a special entry point <tt>ev-appl-accum-last-arg</tt>, which restores the argument list, accumulates
the new argument, restores the saved procedure, and goes off to
perform the application.<a name="call_footnote_Temp_772" href="#footnote_Temp_772"><sup><small>23</small></sup></a></p>

<p class="trans" lang="ja">
æœ€å¾Œã®å¼•æ•°ã®è©•ä¾¡ã¯ã€ç•°ãªã‚‹æ–¹æ³•ã§å–ã‚Šæ‰±ã‚ã‚Œã‚‹ã€‚
ç’°å¢ƒã‚‚ã€æœªè©•ä¾¡ã®ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã®ãƒªã‚¹ãƒˆã‚‚ã€<tt>eval-dispatch</tt> ã¸è¡Œãå‰ã«é€€é¿ã™ã‚‹å¿…è¦ãŒãªã„ã€‚ãªãœãªã‚‰ã€ãã‚Œã‚‰ã¯ã€æœ€å¾Œã®ã‚ªãƒšãƒ©ãƒ³ãƒ‰ãŒè©•ä¾¡ã•ã‚ŒãŸå¾Œã«ã¯å¿…è¦ã¨ã•ã‚Œãªã„<!--ã§ã‚ã‚ã†-->ã‹ã‚‰ã ã€‚
ã‚ˆã£ã¦ã€è©•ä¾¡ã‹ã‚‰ã€<tt>ev-appl-accum-last-arg</tt> ã¨ã„ã†ç‰¹åˆ¥ãªã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒã‚¤ãƒ³ãƒˆã¸ã¨æˆ»ã‚‹ã®ã ãŒã€ã“ã‚Œã¯ã€å¼•æ•°ãƒªã‚¹ãƒˆã‚’å¾©æ—§ã—ã€æ–°ãŸãªå¼•æ•°ã‚’è“„ç©ã—ã€é€€é¿ã•ã‚ŒãŸæ‰‹ç¶šãã‚’å¾©æ—§ã—ã€é©ç”¨ã‚’å®Ÿè¡Œã™ã‚‹ãŸã‚ã«å‡ºç™ºã™ã‚‹ã‚‚ã®ã§ã‚ã‚‹<a href="#footnote_Temp_772"><sup><small>23</small></sup></a>ã€‚
</p>

<p class="lisp">ev-appl-last-arg
  (assign continue (label ev-appl-accum-last-arg))
  (goto (label eval-dispatch))
ev-appl-accum-last-arg
  (restore argl)
  (assign argl (op adjoin-arg) (reg val) (reg argl))
  (restore proc)
  (goto (label apply-dispatch))
</p>

<p class="orig" lang="en">
<a name="%_idx_6070"></a>The details of the argument-evaluation loop determine the order in
which the interpreter evaluates the operands of a combination (e.g.,
left to right or right to left -- see
exercise <a href="20_sec3_1.html#%_thm_3.8">3.8</a>).  This order is not determined
by the metacircular evaluator, which inherits its control structure
from the underlying Scheme in which it is implemented.<a name="call_footnote_Temp_773" href="#footnote_Temp_773"><sup><small>24</small></sup></a> Because the <tt>first-operand</tt>
selector (used in <tt>ev-appl-operand-loop</tt> to extract successive operands
from <tt>unev</tt>) is implemented as <tt>car</tt> and the <tt>rest-operands</tt> selector is implemented as <tt>cdr</tt>, the
explicit-control evaluator will evaluate the operands of a combination
in left-to-right order.</p>

<p class="trans" lang="ja">
å¼•æ•°è©•ä¾¡ãƒ«ãƒ¼ãƒ—ã®è©³ç´°ãŒã€ã‚³ãƒ³ãƒ“ãƒãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã‚’ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒè©•ä¾¡ã™ã‚‹é †åº (ãŸã¨ãˆã°ã€å·¦ã‹ã‚‰å³ã¸ã€ã‚ã‚‹ã„ã¯ã€å³ã‹ã‚‰å·¦ã¸â€”â€”ç·´ç¿’å•é¡Œ<a href="20_sec3_1.html#%_thm_3.8">3.8</a>ã‚’å‚ç…§) ã‚’å®šã‚ã‚‹ã€‚
ã“ã®é †åºã¯ã€ãƒ¡ã‚¿å¾ªç’°çš„ãªè©•ä¾¡å™¨â€”â€”ã“ã®ãƒ¡ã‚¿å¾ªç’°çš„ãªè©•ä¾¡å™¨ã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ã€æ ¹åº•ã«ã‚ã‚‹ Scheme ã‹ã‚‰ã€ãƒ¡ã‚¿å¾ªç’°çš„ãªè©•ä¾¡å™¨è‡ªèº«ã®åˆ¶å¾¡æ§‹é€ ã‚’å—ã‘ç¶™ã„ã§ã„ã‚‹â€”â€”ã«ã‚ˆã£ã¦ã¯ã€å®šã¾ã‚‰ãªã„<a href="#footnote_Temp_773"><sup><small>24</small></sup></a>ã€‚
<tt>first-operand</tt> ã‚»ãƒ¬ã‚¯ã‚¿ (<tt>ev-appl-operand-loop</tt> ã«ãŠã„ã¦ã€é€£ç¶šã™ã‚‹ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã‚’ <tt>unev</tt> ã‹ã‚‰æŠ½å‡ºã™ã‚‹ã®ã«ä½¿ã‚ã‚Œã‚‹) ãŒ <tt>car</tt> ã¨ã—ã¦å®Ÿè£…ã•ã‚Œã€ã‹ã¤ã€<tt>rest-operands</tt> ã‚»ãƒ¬ã‚¯ã‚¿ãŒ <tt>cdr</tt> ã¨ã—ã¦å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ã®ã§ã€æ˜ç¤ºçš„åˆ¶å¾¡æ–¹å¼ã®è©•ä¾¡å™¨ã¯ã€ã‚³ãƒ³ãƒ“ãƒãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã‚’ã€å·¦ã‹ã‚‰å³ã¸ã®é †åºã§è©•ä¾¡ã™ã‚‹ã ã‚ã†ã€‚
</p>

<a name="%_sec_Temp_774"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_774">Procedure application</a></h4>
<h4 class="trans" lang="ja">æ‰‹ç¶šãé©ç”¨</h4>

<p class="orig" lang="en">
The entry point <tt>apply-dispatch</tt> corresponds to the <tt>apply</tt>
procedure of the metacircular evaluator.  By the time we get to <tt>apply-dispatch</tt>, the <tt>proc</tt> register contains the procedure to
apply and <tt>argl</tt> contains the list of evaluated arguments to which
it must be applied.  The saved value of <tt>continue</tt> (originally
passed to <tt>eval-dispatch</tt> and saved at <tt>ev-application</tt>),
which tells where to return with the result of the procedure
application, is on the stack.  When the application is complete, the
controller transfers to the entry point specified by the saved <tt>continue</tt>, with the result of the application in <tt>val</tt>.  As with
the metacircular <tt>apply</tt>, there are two cases to consider.  Either
the procedure to be applied is a primitive or it is a compound
procedure.</p>

<p class="trans" lang="ja">
<tt>apply-dispatch</tt> ã¨ã„ã†ã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒã‚¤ãƒ³ãƒˆã¯ã€ãƒ¡ã‚¿å¾ªç’°çš„ãªè©•ä¾¡å™¨ã® <tt>apply</tt> æ‰‹ç¶šãã«å¯¾å¿œã™ã‚‹ã€‚
<tt>apply-dispatch</tt> ã‚’è¡Œã†ã‚ˆã†ã«ãªã‚‹ã¾ã§ã«ã¯ã€é©ç”¨ã™ã¹ãæ‰‹ç¶šãã‚’ <tt>proc</tt> ãƒ¬ã‚¸ã‚¹ã‚¿ãŒå«ã‚“ã§ãŠã‚Šã€ãã®æ‰‹ç¶šãã‚’é©ç”¨ã›ã­ã°ãªã‚‰ãªã„è©•ä¾¡æ¸ˆã¿ã®å¼•æ•°ã®ãƒªã‚¹ãƒˆã‚’ <tt>argl</tt> ãƒ¬ã‚¸ã‚¹ã‚¿ãŒå«ã‚“ã§ã„ã‚‹ã€‚
<tt>continue</tt> ã®é€€é¿æ¸ˆã¿ã®å€¤ (ã‚‚ã¨ã‚‚ã¨ã¯ <tt>eval-dispatch</tt> ã«æ¸¡ã•ã‚Œã¦ã€<tt>ev-application</tt> ã«ãŠã„ã¦é€€é¿ã•ã‚ŒãŸ) â€”â€”æ‰‹ç¶šãé©ç”¨ã®çµæœã¨ã¨ã‚‚ã«æˆ»ã‚‹ã¹ãå ´æ‰€ã‚’æ•™ãˆã¦ãã‚Œã‚‹â€”â€”ã¯ã€ã‚¹ã‚¿ãƒƒã‚¯ä¸Šã«ã‚ã‚‹ã€‚
é©ç”¨ãŒå®Œäº†ã™ã‚‹ã¨ã€ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ã¯ã€é€€é¿æ¸ˆã¿ã® <tt>continue</tt> ã«ã‚ˆã‚ŠæŒ‡å®šã•ã‚Œã¦ã„ã‚‹ã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒã‚¤ãƒ³ãƒˆã¸ã¨ã€<tt>val</tt> ã®ä¸­ã«ã‚ã‚‹é©ç”¨ã®çµæœã¨ä¸€ç·’ã«ç§»ã‚‹ã€‚
ãƒ¡ã‚¿å¾ªç’°çš„ãª <tt>apply</tt> ã«ãŠã‘ã‚‹ã®ã¨åŒæ§˜ã«ã€è€ƒãˆã‚‹ã¹ãäºŒã¤ã®å ´åˆãŒã‚ã‚‹ã€‚
é©ç”¨ã™ã¹ãæ‰‹ç¶šããŒã€åŸå§‹çš„ãªã®ã‹ã€ãã‚Œã¨ã‚‚ã€è¤‡åˆçš„æ‰‹ç¶šããªã®ã‹ã€ã¨ã„ã†ã“ã¨ã§ã‚ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_6072"></a>apply-dispatch
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-apply))
  (test (op compound-procedure?) (reg proc))  
  (branch (label compound-apply))
  (goto (label unknown-procedure-type))
</p>

<p class="orig" lang="en">
<a name="%_idx_6074"></a>We assume that each primitive is implemented so as to obtain its
arguments from <tt>argl</tt> and place its result in <tt>val</tt>.  To
specify how the machine handles primitives, we would have to provide a
sequence of controller instructions to implement each primitive and
arrange for <tt>primitive-apply</tt> to dispatch to the
instructions for the primitive identified by the
contents of <tt>proc</tt>.  Since we are interested in the structure of
the evaluation process rather than the details of the primitives, we
will instead just use an <tt>apply-primitive-procedure</tt> operation
that applies the procedure in <tt>proc</tt> to the arguments in <tt>argl</tt>.  For the purpose of simulating the evaluator with the simulator
of section <a href="32_sec5_2.html#%_sec_5.2">5.2</a> we use the procedure <tt>apply-primitive-procedure</tt>, which calls on the underlying Scheme
system to perform the application, just as we did for the metacircular
evaluator in section <a href="26_sec4_1.html#%_sec_4.1.4">4.1.4</a>.  After computing the
value of the primitive application, we restore <tt>continue</tt> and go
to the designated entry point.</p>

<p class="trans" lang="ja">
å„ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã¯ã€å¼•æ•°ã‚’ <tt>argl</tt> ã‹ã‚‰å–å¾—ã—ã¦çµæœã‚’ <tt>val</tt> ã«å…¥ã‚Œã‚‹ã‚ˆã†ã«å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ã‚‚ã®ã¨ã™ã‚‹ã€‚
ãƒã‚·ãƒ³ãŒãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã‚’æ‰±ã†æ–¹æ³•ã‚’æŒ‡å®šã™ã‚‹ãŸã‚ã«ã€ç§ãŸã¡ã¯ã€å„ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã®ä¸€é€£ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©å‘½ä»¤ã‚’æä¾›ã›ã­ã°ãªã‚‰ãªã„ã ã‚ã†ã—ã€<tt>proc</tt> ã®å†…å®¹ã«ã‚ˆã£ã¦è­˜åˆ¥ã•ã‚Œã‚‹ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ç”¨ã®å‘½ä»¤ã¸ã¨æŒ¯ã‚Šåˆ†ã‘ã‚‹ãŸã‚ã® <tt>primitive-apply</tt> ã‚’æ‰‹é…ã›ã­ã°ãªã‚‰ãªã„ã ã‚ã†ã€‚
ç§ãŸã¡ã¯ã€ãã®ä»£ã‚ã‚Šã«ã€ãŸã ã€<tt>argl</tt> å†…ã®å¼•æ•°ã« <tt>proc</tt> å†…ã®æ‰‹ç¶šãã‚’é©ç”¨ã™ã‚‹ <tt>apply-primitive-procedure</tt> æ¼”ç®—ã‚’ä½¿ã†ã“ã¨ã«ã—ã‚ˆã†ã€‚ã¨ã„ã†ã®ã‚‚ã€ç§ãŸã¡ã¯ã€ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã®è©³ç´°ã§ã¯ãªãã€ã‚€ã—ã‚è©•ä¾¡éç¨‹ã®æ§‹é€ ã«èˆˆå‘³ãŒã‚ã‚‹ãŸã‚ã§ã‚ã‚‹ã€‚
<a href="32_sec5_2.html#%_sec_5.2">5.2</a>ç¯€ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã‚’ä½¿ã£ã¦è©•ä¾¡å™¨ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã™ã‚‹ç›®çš„ã®ãŸã‚ã«ã€ç§ãŸã¡ã¯ <tt>apply-primitive-procedure</tt> ã‚’ä½¿ã†ãŒã€ã“ã‚Œã¯ã€<a href="26_sec4_1.html#%_sec_4.1.4">4.1.4</a>ç¯€ã§ãƒ¡ã‚¿å¾ªç’°çš„è©•ä¾¡å™¨ã«ã¤ã„ã¦ç§ãŸã¡ãŒè¡Œã£ãŸã®ã¨ã¡ã‚‡ã†ã©åŒã˜ã‚ˆã†ã«ã€æ ¹åº•ã«ã‚ã‚‹ Scheme ã‚·ã‚¹ãƒ†ãƒ ã«å¯¾ã—ã¦é©ç”¨ã‚’å®Ÿè¡Œã™ã‚‹ã‚ˆã†ã«æ±‚ã‚ã‚‹ã‚‚ã®ã§ã‚ã‚‹ã€‚
ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–é©ç”¨ã®å€¤ã‚’è¨ˆç®—ã—ãŸå¾Œã€<tt>continue</tt> ã‚’å¾©æ—§ã—ã€æŒ‡å®šã•ã‚ŒãŸã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒã‚¤ãƒ³ãƒˆã¸ã¨è¡Œãã€‚
</p>

<p class="lisp"><a name="%_idx_6076"></a>primitive-apply
  (assign val (op apply-primitive-procedure)
              (reg proc)
              (reg argl))
  (restore continue)
  (goto (reg continue))
</p>

<p class="orig" lang="en">
<a name="%_idx_6078"></a>To apply a compound procedure, we proceed just as with the
metacircular evaluator.  We construct a frame that binds the
procedure's parameters to the arguments, use this frame to
extend the environment carried by the procedure, and evaluate in this
extended environment the sequence of expressions that forms the body
of the procedure.  <tt>Ev-sequence</tt>, described below in
section <a href="#%_sec_5.4.2">5.4.2</a>, handles the evaluation
of the sequence.</p>

<p class="trans" lang="ja">
è¤‡åˆçš„æ‰‹ç¶šãã‚’é©ç”¨ã™ã‚‹ã«ã¯ã€ãƒ¡ã‚¿å¾ªç’°çš„ãªè©•ä¾¡å™¨ã®å ´åˆã¨ã¡ã‚‡ã†ã©åŒã˜ã‚ˆã†ã«é€²ã‚€ã€‚
æ‰‹ç¶šãã®ä»®å¼•æ•°ã‚’å®Ÿå¼•æ•°ã«æŸç¸›ã™ã‚‹ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’æ§‹ç¯‰ã—ã€ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ç”¨ã„ã¦ã€æ‰‹ç¶šãã«ã‚ˆã‚Šä¼ãˆã‚‰ã‚ŒãŸç’°å¢ƒã‚’æ‹¡å¼µã—ã€ã“ã®æ‹¡å¼µã•ã‚ŒãŸç’°å¢ƒã«ãŠã„ã¦ã€æ‰‹ç¶šãã®æœ¬ä½“ã‚’å½¢æˆã™ã‚‹å¼ã®é€£ãªã‚Šã‚’è©•ä¾¡ã™ã‚‹ã€‚
<tt>ev-sequence</tt> â€”â€”å¾Œè¿°ã®<a href="#%_sec_5.4.2">5.4.2</a>ç¯€ã§èª¬æ˜ã™ã‚‹â€”â€”ãŒã€ãã®é€£ãªã‚Šã®è©•ä¾¡ã‚’å–ã‚Šæ‰±ã†ã€‚
</p>

<p class="lisp"><a name="%_idx_6080"></a>compound-apply
  (assign unev (op procedure-parameters) (reg proc))
  (assign env (op procedure-environment) (reg proc))
  (assign env (op extend-environment)
              (reg unev) (reg argl) (reg env))
  (assign unev (op procedure-body) (reg proc))
  (goto (label ev-sequence))
</p>

<p class="orig" lang="en">
<tt>Compound-apply</tt> is the only place in the interpreter where the
<tt>env</tt> register is ever assigned a new value.  Just as in the
metacircular evaluator, the new environment is constructed from the
environment carried by the procedure, together with the argument list
and the corresponding list of variables to be bound.</p>

<p class="trans" lang="ja">
<tt>compound-apply</tt> ã¯ã€<tt>env</tt> ãƒ¬ã‚¸ã‚¹ã‚¿ãŒæ–°ãŸãªå€¤ã‚’å‰²ã‚Šå½“ã¦ã‚‰ã‚Œã‚‹ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿å†…ã«ãŠã‘ã‚‹æ­£ã«å”¯ä¸€ã®å ´æ‰€ã§ã‚ã‚‹ã€‚
ãƒ¡ã‚¿å¾ªç’°çš„ãªè©•ä¾¡å™¨ã«ãŠã‘ã‚‹ã®ã¨ã¡ã‚‡ã†ã©åŒã˜ã‚ˆã†ã«ã€æ–°ãŸãªç’°å¢ƒã¯ã€æ‰‹ç¶šãã«ã‚ˆã‚Šä¼ãˆã‚‰ã‚ŒãŸç’°å¢ƒâ€”â€”ãã‚Œã¨ã€å®Ÿå¼•æ•°ãƒªã‚¹ãƒˆã€ãŠã‚ˆã³ã€æŸç¸›ã•ã‚Œã‚‹ã¹ãå¤‰æ•°ã‹ã‚‰ãªã‚‹ã€ãã‚Œã«å¯¾å¿œã™ã‚‹ãƒªã‚¹ãƒˆâ€”â€”ã‹ã‚‰ã€æ§‹ç¯‰ã•ã‚Œã‚‹ã€‚
</p>

<a name="%_sec_5.4.2"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_5.4.2">5.4.2  Sequence Evaluation and Tail Recursion</a></h3>
<h3 class="trans" lang="ja">5.4.2 åˆ—ã®è©•ä¾¡ã¨æœ«å°¾å†å¸°</h3>

<p class="orig" lang="en"><a name="%_idx_6082"></a>
The portion of the explicit-control evaluator at <tt>ev-sequence</tt> is
analogous to the metacircular evaluator's <tt>eval-sequence</tt> procedure.  It
handles sequences of expressions in procedure bodies or in explicit
<tt>begin</tt> expressions.</p>

<p class="trans" lang="ja">
æ˜ç¤ºçš„åˆ¶å¾¡æ–¹å¼ã®è©•ä¾¡å™¨ã®ã€<tt>ev-sequence</tt> ã®éƒ¨åˆ†ã¯ã€ãƒ¡ã‚¿å¾ªç’°çš„ãªè©•ä¾¡å™¨ã® <tt>eval-sequence</tt> æ‰‹ç¶šãã«ä¼¼ã¦ã„ã‚‹ã€‚
ã“ã®éƒ¨åˆ†ã¯ã€æ‰‹ç¶šãæœ¬ä½“ã®ä¸­ã¾ãŸã¯æ˜ç¤ºçš„ãª <tt>begin</tt> å¼ã®ä¸­ã®ã€ä¸€é€£ã®å¼ã‚’å–ã‚Šæ‰±ã†ã€‚
</p>

<p class="orig" lang="en">
Explicit <tt>begin</tt> expressions are evaluated by placing the sequence
of expressions to be evaluated in <tt>unev</tt>, saving <tt>continue</tt> on the
stack, and jumping to <tt>ev-sequence</tt>.
</p>

<p class="trans" lang="ja">
æ˜ç¤ºçš„ãª <tt>begin</tt> å¼ã¯ã€è©•ä¾¡ã™ã¹ãä¸€é€£ã®å¼ã‚’ <tt>unev</tt> ã«å…¥ã‚Œã€<tt>continue</tt> ã‚’ã‚¹ã‚¿ãƒƒã‚¯ä¸Šã«é€€é¿ã—ã€<tt>ev-sequence</tt> ã¸ã‚¸ãƒ£ãƒ³ãƒ—ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€è©•ä¾¡ã•ã‚Œã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_6084"></a>ev-begin
  (assign unev (op begin-actions) (reg exp))
  (save continue)
  (goto (label ev-sequence))
</p>

<p class="orig" lang="en">The implicit sequences in procedure bodies are handled by jumping to
<tt>ev-sequence</tt> from <tt>compound-apply</tt>, at which point <tt>continue</tt> is already on the stack, having been saved at
<tt>ev-application</tt>.</p>

<p class="trans" lang="ja">
æ‰‹ç¶šãæœ¬ä½“ã®ä¸­ã®æš—é»™çš„ãª<ruby><rb>ä¸¦ã³</rb><rp> (</rp><rt>ã‚·ãƒ¼ã‚±ãƒ³ã‚¹</rt><rp>) </rp></ruby>ã¯ã€<tt>compound-apply</tt> ã‹ã‚‰ <tt>ev-sequence</tt> ã¸ã‚¸ãƒ£ãƒ³ãƒ—ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦å–ã‚Šæ‰±ã‚ã‚Œã‚‹ã®ã ãŒã€ã“ã®æ™‚ç‚¹ã§æ—¢ã« <tt>continue</tt> ã¯ã‚¹ã‚¿ãƒƒã‚¯ä¸Šã«ã‚ã‚Šã€ã¨ã„ã†ã®ã‚‚ã€<tt>ev-application</tt> ã§é€€é¿ã•ã‚ŒãŸãŸã‚ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
The entries at <tt>ev-sequence</tt>
and <tt>ev-sequence-continue</tt> form a loop that
successively evaluates each expression in a sequence.  The list of
unevaluated expressions is kept in <tt>unev</tt>.  Before evaluating each
expression, we check to see if there are additional expressions to be
evaluated in the sequence.  If so, we save the rest of the unevaluated
expressions (held in <tt>unev</tt>) and the environment in which these
must be evaluated (held in <tt>env</tt>) and call <tt>eval-dispatch</tt> to
evaluate the expression.  The two saved registers are restored upon
the return from this evaluation, at <tt>ev-sequence-continue</tt>.</p>

<p class="trans" lang="ja">
<tt>ev-sequence</tt> ã¨ <tt>ev-sequence-continue</tt> ã«ã‚ã‚‹ã‚¨ãƒ³ãƒˆãƒªãŒã€ä¸¦ã³ã®ä¸­ã®ãã‚Œãã‚Œã®å¼ã‚’æ¬¡ã€…ã¨è©•ä¾¡ã™ã‚‹ãƒ«ãƒ¼ãƒ—ã‚’å½¢æˆã™ã‚‹ã€‚
æœªè©•ä¾¡ã®å¼ã®ãƒªã‚¹ãƒˆã¯ã€<tt>unev</tt> ã«ä¿æŒã•ã‚Œã‚‹ã€‚
ãã‚Œãã‚Œã®å¼ã‚’è©•ä¾¡ã™ã‚‹å‰ã«ã€è©•ä¾¡ã™ã¹ãæ›´ãªã‚‹å¼ãŒä¸¦ã³ã®ä¸­ã«ã‚ã‚‹ã‹å¦ã‹ã‚’èª¿ã¹ã‚‹ã€‚
ã‚‚ã—ã‚ã‚Œã°ã€(<tt>unev</tt> ã«ä¿æŒã•ã‚Œã¦ã„ã‚‹) æœªè©•ä¾¡ã®å¼ã®ã†ã¡æ®‹ã‚Šã®ã‚‚ã®ã¨ã€ã“ã‚Œã‚‰ã‚’è©•ä¾¡ã›ã­ã°ãªã‚‰ãªã„ç’°å¢ƒ (<tt>env</tt> ã«ä¿æŒã•ã‚Œã¦ã„ã‚‹) ã¨ã‚’é€€é¿ã—ã€ãã®å¼ã‚’è©•ä¾¡ã™ã‚‹ãŸã‚ã« <tt>eval-dispatch</tt> ã‚’å‘¼ã³å‡ºã™ã€‚
é€€é¿ã•ã‚ŒãŸäºŒã¤ã®ãƒ¬ã‚¸ã‚¹ã‚¿ã¯ã€ã“ã®è©•ä¾¡ã‹ã‚‰æˆ»ã£ãŸã¨ãã«ã€<tt>ev-sequence-continue</tt> ã«ãŠã„ã¦å¾©æ—§ã•ã‚Œã‚‹ã€‚
</p>

<p class="orig" lang="en">
The final expression in the sequence is handled differently, at the
entry point <tt>ev-sequence-last-exp</tt>.  Since there are no more
expressions to be evaluated after this one, we need not save <tt>unev</tt> or <tt>env</tt> before going to <tt>eval-dispatch</tt>.  The value of
the whole sequence is the value of the last expression, so after the
evaluation of the last expression there is nothing left to do except
continue at the entry point currently held on the stack (which was saved
by <tt>ev-application</tt> or <tt>ev-begin</tt>.)
Rather than setting up <tt>continue</tt> to arrange for <tt>eval-dispatch</tt> to return here and then restoring <tt>continue</tt> from
the stack and continuing at that entry point, we restore <tt>continue</tt> from
the stack before going to <tt>eval-dispatch</tt>, so that <tt>eval-dispatch</tt> will continue at that entry point after evaluating the
expression.</p>

<p class="trans" lang="ja">
ä¸¦ã³ã®ä¸­ã§æœ€å¾Œã®å¼ã¯ã€<tt>ev-sequence-last-exp</tt> ã¨ã„ã†ã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒã‚¤ãƒ³ãƒˆã«ãŠã„ã¦ã€ç•°ãªã‚‹æ–¹æ³•ã§æ‰±ã‚ã‚Œã‚‹ã€‚
ã“ã®å¼ã®å¾Œã«ã¯ã€è©•ä¾¡ã™ã¹ãå¼ãŒã‚‚ã†ä½•ã‚‚ãªã„ã®ã§ã€<tt>unev</tt> ã‚‚ <tt>env</tt> ã‚‚ã€<tt>eval-dispatch</tt> ã«è¡Œãå‰ã«é€€é¿ã—ã¦ãŠãå¿…è¦ãŒãªã„ã€‚
ä¸¦ã³å…¨ä½“ã®å€¤ã¯æœ€å¾Œã®å¼ã®å€¤ã§ã‚ã‚Šã€ã‚ˆã£ã¦ã€æœ€å¾Œã®å¼ã®è©•ä¾¡ã®å¾Œã«ã¯ã€ç¾åœ¨ã‚¹ã‚¿ãƒƒã‚¯ä¸Šã«ä¿æŒã•ã‚Œã¦ã„ã‚‹ã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒã‚¤ãƒ³ãƒˆ (<tt>ev-application</tt> ã¾ãŸã¯ <tt>ev-begin</tt> ã«ã‚ˆã‚Šé€€é¿ã•ã‚ŒãŸã‚‚ã®) <!--ã«ãŠã„ã¦-->ã‹ã‚‰ç¶šè¡Œã™ã‚‹ã“ã¨ä»¥å¤–ã¯ã€ã‚„ã‚‹ã“ã¨ã¯ä½•ã‚‚æ®‹ã£ã¦ã„ãªã„ã€‚
<tt>eval-dispatch</tt> ãŒã“ã“ã«æˆ»ã£ã¦æ¥ã‚‹ã‚ˆã†ã«æ‰‹ç­ˆã‚’æ•´ãˆã‚‹ã¹ã <tt>continue</tt> ã‚’è¨­å®šã—ã¦ãŠã„ã¦ã€ãã®å¾Œã§ã€ã‚¹ã‚¿ãƒƒã‚¯ã‹ã‚‰ <tt>continue</tt> ã‚’å¾©æ—§ã—ã¦ã€ãã®ã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒã‚¤ãƒ³ãƒˆ<!--ã«ãŠã„ã¦-->ã‹ã‚‰ç¶šè¡Œã™ã‚‹ã®ã§ã¯ãªãã€ã‚€ã—ã‚ã€<tt>eval-dispatch</tt> ã¸è¡Œãå‰ã«ã‚¹ã‚¿ãƒƒã‚¯ã‹ã‚‰ <tt>continue</tt> ã‚’å¾©æ—§ã™ã‚‹ã€‚ãã®çµæœã€<tt>eval-dispatch</tt> ã¯ã€ãã® <span class="note">(æœ€å¾Œã®)</span> å¼ã‚’è©•ä¾¡ã—ãŸå¾Œã§ã€ãã®ã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒã‚¤ãƒ³ãƒˆ<!--ã«ãŠã„ã¦-->ã‹ã‚‰ç¶šè¡Œã™ã‚‹ã ã‚ã†ã€‚
</p>

<p class="lisp"><a name="%_idx_6086"></a>ev-sequence
  (assign exp (op first-exp) (reg unev))
  (test (op last-exp?) (reg unev))
  (branch (label ev-sequence-last-exp))
  (save unev)
  (save env)
  (assign continue (label ev-sequence-continue))
  (goto (label eval-dispatch))
ev-sequence-continue
  (restore env)
  (restore unev)
  (assign unev (op rest-exps) (reg unev))
  (goto (label ev-sequence))
ev-sequence-last-exp
  (restore continue)
  (goto (label eval-dispatch))
</p>

<a name="%_sec_Temp_775"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_775">Tail recursion</a></h4>
<h4 class="trans" lang="ja">æœ«å°¾å†å¸°</h4>

<p class="orig" lang="en">
<a name="%_idx_6088"></a><a name="%_idx_6090"></a>
In chapter 1 we said that the process described by a procedure such as</p>

<p class="trans" lang="ja">
1ç« ã§ç§ãŸã¡ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ãªæ‰‹ç¶šãã«ã‚ˆã‚Šè¨˜è¿°ã•ã‚Œã‚‹ãƒ—ãƒ­ã‚»ã‚¹ãŒ
</p>

<p class="lisp">(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x)
                 x)))
</p>

<p class="orig" lang="en">is an iterative process.  Even though the procedure is syntactically
recursive (defined in terms of itself), it is not logically necessary
for an evaluator to save information in passing from one call to <tt>sqrt-iter</tt> to the next.<a name="call_footnote_Temp_776" href="#footnote_Temp_776"><sup><small>25</small></sup></a> An evaluator that can
execute a procedure such as <tt>sqrt-iter</tt> without requiring
increasing storage as the procedure continues to call itself is called
a <a name="%_idx_6092"></a><em>tail-recursive</em> evaluator.  <a name="%_idx_6094"></a><a name="%_idx_6096"></a>The metacircular implementation of
the evaluator in chapter 4 does not specify whether the evaluator is
tail-recursive, because that evaluator inherits its mechanism for
saving state from the underlying Scheme.  With the explicit-control
evaluator, however, we can trace through the evaluation process to see
when procedure calls cause a net accumulation of information on the
stack.</p>

<p class="trans" lang="ja">
åå¾©çš„ãªãƒ—ãƒ­ã‚»ã‚¹ã§ã‚ã‚‹ã€ã¨è¨€ã£ãŸã€‚
ãŸã¨ãˆæ–‡æ³•ä¸Šã¯ã“ã®æ‰‹ç¶šããŒå†å¸°çš„ã§ã‚ã£ã¦ã‚‚ (ã“ã®æ‰‹ç¶šãè‡ªèº«ã‚’ç”¨ã„ã¦å®šç¾©ã•ã‚Œã¦ã„ã¦ã‚‚)ã€<tt>sqrt-iter</tt> ã«å¯¾ã™ã‚‹ä¸€ã¤ã®å‘¼ã³å‡ºã—ã‹ã‚‰æ¬¡ã®å‘¼ã³å‡ºã—ã¸ã®æ¨ç§»ã®éš›ã«è©•ä¾¡å™¨ãŒæƒ…å ±ã‚’é€€é¿ã™ã‚‹ã“ã¨ã¯ã€è«–ç†çš„ã«å¿…è¦ãªè¨³ã§ã¯ãªã„<a href="#footnote_Temp_776"><sup><small>25</small></sup></a>ã€‚
æ‰‹ç¶šããŒè‡ªåˆ†è‡ªèº«ã‚’å‘¼ã³å‡ºã—ç¶šã‘ã‚‹ã®ã«é€£ã‚Œã¦ã®ã€å¢—ãˆã‚†ãè¨˜æ†¶ã‚’å¿…è¦ã¨ã™ã‚‹ã“ã¨ãªã—ã«ã€<tt>sqrt-iter</tt> ã®ã‚ˆã†ãªæ‰‹ç¶šãã‚’å®Ÿè¡Œã§ãã‚‹è©•ä¾¡å™¨ã¯ã€<em>æœ«å°¾å†å¸°çš„ãª</em>è©•ä¾¡å™¨ã¨å‘¼ã°ã‚Œã‚‹ã€‚
4ç« ã«ãŠã‘ã‚‹ã€è©•ä¾¡å™¨ã®ãƒ¡ã‚¿å¾ªç’°çš„å®Ÿè£…ã¯ã€è©•ä¾¡å™¨ãŒæœ«å°¾å†å¸°çš„ã‹å¦ã‹ã‚’è¦å®šã—ã¦ã„ãªã„ã€‚ãªãœãªã‚‰ã€ãã®è©•ä¾¡å™¨ã¯ã€çŠ¶æ…‹ã‚’ä¿å­˜ã™ã‚‹ãŸã‚ã®ä»•çµ„ã¿ã‚’ã€æ ¹åº•ã«ã‚ã‚‹ Scheme ã‹ã‚‰å—ã‘ç¶™ã„ã§ã„ã‚‹ã‹ã‚‰ã ã€‚
ã—ã‹ã—ã€æ˜ç¤ºçš„åˆ¶å¾¡æ–¹å¼ã®è©•ä¾¡å™¨ã‚’ä½¿ã†ã¨ã€ç§ãŸã¡ã¯ã€æ‰‹ç¶šãå‘¼ã³å‡ºã—ãŒã‚¹ã‚¿ãƒƒã‚¯ä¸Šã®æƒ…å ±ã®æ­£å‘³ã®è“„ç©ã‚’ã„ã¤å¼•ãèµ·ã“ã™ã®ã‹ã‚’è¦‹ã‚‹ãŸã‚ã«ã€è©•ä¾¡éç¨‹ã‚’é€šã˜ã¦ãƒˆãƒ¬ãƒ¼ã‚¹ã‚’è¡Œã†ã“ã¨ãŒã§ãã‚‹ã®ã ã€‚
</p>

<p class="orig" lang="en">
Our evaluator is tail-recursive, because in order to evaluate the final
expression of a sequence we transfer directly to <tt>eval-dispatch</tt> without
saving any information on the stack.  Hence, evaluating the final expression
in a sequence -- even if it is a procedure call (as in <tt>sqrt-iter</tt>, where
the <tt>if</tt> expression, which is the last expression in the procedure body,
reduces to a call to <tt>sqrt-iter</tt>) -- will not cause any information to be
accumulated on the stack.<a name="call_footnote_Temp_777" href="#footnote_Temp_777"><sup><small>26</small></sup></a></p>

<p class="trans" lang="ja">
ç§ãŸã¡ã®è©•ä¾¡å™¨ã¯æœ«å°¾å†å¸°çš„ã§ã‚ã‚‹ã€‚ãªãœãªã‚‰ã€ä¸¦ã³ã®ä¸­ã§æœ€å¾Œã®å¼ã‚’è©•ä¾¡ã™ã‚‹ãŸã‚ã«ã€ä½•ã®æƒ…å ±ã‚‚ã‚¹ã‚¿ãƒƒã‚¯ã«é€€é¿ã™ã‚‹ã“ã¨ãªãã€ç›´æ¥ã€<tt>eval-dispatch</tt> ã¸ç§»ã‚‹ã‹ã‚‰ã§ã‚ã‚‹ã€‚
ã‚†ãˆã«ã€ä¸¦ã³ã®ä¸­ã§æœ€å¾Œã®å¼ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ã¯ã€ãŸã¨ãˆãã‚ŒãŒ (<tt>sqrt-iter</tt> â€”â€”ãã“ã§ã¯ <tt>if</tt> å¼ãŒæ‰‹ç¶šãæœ¬ä½“ã®ä¸­ã§æœ€å¾Œã®å¼ã§ã‚ã‚‹è¨³ã ãŒã€ãã® <tt>if</tt> å¼ãŒ <tt>sqrt-iter</tt> ã«å¯¾ã™ã‚‹å‘¼ã³å‡ºã—ã¸ã¨å¸°ç€ã—ã¦ã„ã‚‹â€”â€”ã«ãŠã‘ã‚‹ã®ã¨åŒæ§˜ã«) æ‰‹ç¶šãå‘¼ã³å‡ºã—ã§ã‚ã‚ã†ã¨ã‚‚ã€ä½•ã‚‰ã‹ã®æƒ…å ±ã‚’ã‚¹ã‚¿ãƒƒã‚¯ä¸Šã«è“„ç©ã•ã›ã‚‹åŸå› ã¨ãªã‚‹ã“ã¨ã¯ãªã„ã ã‚ã†<a href="#footnote_Temp_777"><sup><small>26</small></sup></a>ã€‚
</p>

<p class="orig" lang="en">
If we did not think to take advantage of the fact that it was
unnecessary to save information in this case, we might have
implemented <tt>eval-sequence</tt> by treating all the expressions in a
sequence in the same way -- saving the registers, evaluating the expression,
returning to restore the registers, and repeating this until all the
expressions have been evaluated:<a name="call_footnote_Temp_778" href="#footnote_Temp_778"><sup><small>27</small></sup></a></p>

<p class="trans" lang="ja">
ã“ã®å ´åˆã«ã¯æƒ…å ±ã‚’é€€é¿ã™ã‚‹ã“ã¨ãŒä¸è¦ãªã®ã ã€ã¨ã„ã†äº‹å®Ÿã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ã‚’ã€ã‚‚ã—æ€ã„ã¤ã‹ãªã‹ã£ãŸãªã‚‰ã°ã€ä¸¦ã³ã®ä¸­ã®ã™ã¹ã¦ã®å¼ã‚’åŒã˜æ–¹æ³•ã§æ‰±ã†â€”â€”ãƒ¬ã‚¸ã‚¹ã‚¿ã‚’é€€é¿ã—ã€å¼ã‚’è©•ä¾¡ã—ã€æˆ»ã£ã¦ãƒ¬ã‚¸ã‚¹ã‚¿ã‚’å¾©æ—§ã—ã€ã™ã¹ã¦ã®å¼ãŒè©•ä¾¡æ¸ˆã¿ã«ãªã‚‹ã¾ã§ã€ã“ã‚Œã‚’ç¹°ã‚Šè¿”ã™â€”â€”ã“ã¨ã«ã‚ˆã£ã¦ <tt>eval-sequence</tt> ã‚’å®Ÿè£…ã—ã¦ã„ãŸã‹ã‚‚ã—ã‚Œãªã„<a href="#footnote_Temp_778"><sup><small>27</small></sup></a>ã€‚
</p>

<p class="lisp"><a name="%_idx_6100"></a>ev-sequence
  (test (op no-more-exps?) (reg unev))
  (branch (label ev-sequence-end))
  (assign exp (op first-exp) (reg unev))
  (save unev)
  (save env)
  (assign continue (label ev-sequence-continue))
  (goto (label eval-dispatch))
ev-sequence-continue
  (restore env)
  (restore unev)
  (assign unev (op rest-exps) (reg unev))
  (goto (label ev-sequence))
ev-sequence-end
  (restore continue)
  (goto (reg continue))
</p>

<p class="orig" lang="en">
This may seem like a minor change to our previous code for evaluation
of a sequence:  The only difference is that we go through the
save-restore cycle for the last expression in a sequence as well as
for the
others.  The interpreter will still give the same value for
any expression.  But this change is fatal to the tail-recursive
implementation, because we must now return after evaluating the final
expression in a sequence in order to undo the (useless) register
saves.  These extra saves will accumulate during a nest of procedure
calls.  Consequently, processes such as <tt>sqrt-iter</tt> will require
space proportional to the number of iterations rather than requiring
constant space.  This difference can be significant.  For example,
<a name="%_idx_6102"></a>with tail recursion, an infinite loop can be expressed using only the
procedure-call mechanism:</p>

<p class="trans" lang="ja">
ã“ã‚Œã¯ã€ä¸¦ã³ã®è©•ä¾¡ã«ã¤ã„ã¦ã®ä»¥å‰ã®ã‚³ãƒ¼ãƒ‰ã«å¯¾ã™ã‚‹ã€ã¡ã‚‡ã£ã¨ã—ãŸå¤‰æ›´ã®ã‚ˆã†ã«è¦‹ãˆã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚å”¯ä¸€ã®é•ã„ã¯ã€ä¸¦ã³ã®ä¸­ã®æœ€å¾Œã®å¼ã«ã¤ã„ã¦ã‚‚ã€æ®‹ã‚Šã®å¼ã«ã¤ã„ã¦ã¨åŒæ§˜ã«ã€é€€é¿ãƒ»å¾©æ—§ã®ã‚µã‚¤ã‚¯ãƒ«ã‚’çµŒã‚‹ã€ã¨ã„ã†ç‚¹ãªã®ã ã€‚
ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã¯ã€ä¾ç„¶ã¨ã—ã¦ã€ã„ã‹ãªã‚‹å¼ã«ã¤ã„ã¦ã‚‚ã€åŒã˜å€¤ã‚’ä¸ãˆã‚‹ã“ã¨ã ã‚ã†ã€‚
ã—ã‹ã—ã€ã“ã®å¤‰æ›´ã¯ã€æœ«å°¾å†å¸°çš„ãªå®Ÿè£…ã«å¯¾ã—ã¦ã¯è‡´å‘½çš„ã§ã‚ã‚‹ã€‚ã¨ã„ã†ã®ã‚‚ã€ä»Šã‚„ã€ä¸¦ã³ã®ä¸­ã®æœ€å¾Œã®å¼ã‚’è©•ä¾¡ã—ãŸå¾Œã«ã€(ç„¡ç”¨ãª) ãƒ¬ã‚¸ã‚¹ã‚¿é€€é¿ã‚’å¸³æ¶ˆã—ã«ã™ã‚‹ãŸã‚ã«ã€æˆ»ã‚ŠãŒå¿…é ˆã§ã‚ã‚‹ã‹ã‚‰ã ã€‚
ã“ã‚Œã‚‰ã®ä½™è¨ˆãªé€€é¿ã¯ã€æ‰‹ç¶šãå‘¼ã³å‡ºã—ã®å…¥ã‚Œå­ã®é–“ã«ã€è“„ç©ã—ã¦ã‚†ãã ã‚ã†ã€‚
ãã®çµæœã€<tt>sqrt-iter</tt> ã®ã‚ˆã†ãªãƒ—ãƒ­ã‚»ã‚¹ã¯ã€ä¸€å®šã®ç©ºé–“ã‚’å¿…è¦ã¨ã™ã‚‹ã®ã§ã¯ãªãã€ã‚€ã—ã‚ã€åå¾©ã®å›æ•°ã«æ¯”ä¾‹ã—ãŸç©ºé–“ã‚’å¿…è¦ã¨ã™ã‚‹ã ã‚ã†ã€‚
ãŸã¨ãˆã°ã€æœ«å°¾å†å¸°ã‚’ä½¿ãˆã°ã€æ‰‹ç¶šãå‘¼ã³å‡ºã—ã®ä»•çµ„ã¿ã‚’ä½¿ã†ã ã‘ã§ã€ç„¡é™ãƒ«ãƒ¼ãƒ—ã‚’è¡¨ç¾ã§ãã‚‹ã€‚
</p>

<p class="lisp">(define (count n)
  (newline)
  (display n)
  (count (+ n 1)))
</p>

<p class="orig" lang="en">Without tail recursion, such a procedure would eventually run out of
stack space, and expressing a true iteration would require some
control mechanism other than procedure call.</p>

<p class="trans" lang="ja">
æœ«å°¾å†å¸°ã‚’ä½¿ã‚ãªã„ã¨ã€ãã†ã—ãŸæ‰‹ç¶šãã¯ã€é‚ã«ã¯ã‚¹ã‚¿ãƒƒã‚¯ç©ºé–“ã‚’ä½¿ã„æœãŸã—ã¦ã—ã¾ã†ã ã‚ã†ã—ã€ã¾ãŸã€çœŸã®åå¾©ã‚’è¡¨ã™ã“ã¨ã«ã¯ã€æ‰‹ç¶šãå‘¼ã³å‡ºã—ä»¥å¤–ã®ä½•ã‚‰ã‹ã®åˆ¶å¾¡ã®ä»•çµ„ã¿ãŒå¿…è¦ã¨ãªã‚‹ã ã‚ã†ã€‚
</p>

<a name="%_sec_5.4.3"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_5.4.3">5.4.3  Conditionals, Assignments, and Definitions</a></h3>
<h3 class="trans" lang="ja">5.4.3 æ¡ä»¶å¼ã¨<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã¨å®šç¾©</h3>

<p class="orig" lang="en"><a name="%_idx_6104"></a>As with the metacircular evaluator, special forms are handled by
selectively evaluating fragments of the expression.  For an <tt>if</tt>
expression, we must evaluate the predicate and decide, based on the
value of predicate, whether to evaluate the consequent or the
alternative.</p>

<p class="trans" lang="ja">
ãƒ¡ã‚¿å¾ªç’°çš„ãªè©•ä¾¡å™¨ã®ã¨ãã¨åŒæ§˜ã«ã€å¼ã®æ–­ç‰‡ã‚’é¸æŠçš„ã«è©•ä¾¡ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€ç‰¹æ®Šå½¢å¼ã‚’å–ã‚Šæ‰±ã†ã€‚
<tt>if</tt> å¼ã«ã¤ã„ã¦ã¯ã€è¿°èªã‚’è©•ä¾¡ã—ã¦ã€è¿°èªã®å€¤ã«åŸºã¥ã„ã¦ã€å¸°çµå¼ã‚’è©•ä¾¡ã™ã¹ãã‹ä»£æ›¿å¼ã‚’è©•ä¾¡ã™ã¹ãã‹ã‚’æ±ºã‚ã­ã°ãªã‚‰ãªã„ã€‚
</p>

<p class="orig" lang="en">
Before evaluating the predicate, we save the <tt>if</tt> expression
itself so that we can later extract the consequent or alternative.  We
also save the environment, which we will need later in order to
evaluate the consequent or the alternative, and we save <tt>continue</tt>, which we will need later in order to return to the
evaluation of the expression that is waiting for the value of the <tt>if</tt>.</p>

<p class="trans" lang="ja">
è¿°èªã‚’è©•ä¾¡ã™ã‚‹å‰ã«ã€å¾Œã§å¸°çµå¼ã¾ãŸã¯ä»£æ›¿å¼ã‚’æŠ½å‡ºã§ãã‚‹ã‚ˆã†ã« <tt>if</tt> å¼è‡ªä½“ã‚’é€€é¿ã™ã‚‹ã€‚
ã¾ãŸã€ç’°å¢ƒâ€”â€”å¸°çµå¼ã¾ãŸã¯ä»£æ›¿å¼ã‚’è©•ä¾¡ã™ã‚‹ãŸã‚ã«ã€å¾Œã§å¿…è¦ã¨ãªã‚‹ã ã‚ã†â€”â€”ã‚‚é€€é¿ã—ã€<tt>continue</tt> â€”â€” <tt>if</tt> ã®å€¤ã‚’å¾…ã£ã¦ã„ã‚‹å¼ã®è©•ä¾¡ã¸ã¨æˆ»ã‚‹ãŸã‚ã«ã€å¾Œã§å¿…è¦ã¨ãªã‚‹ã ã‚ã†â€”â€”ã‚‚é€€é¿ã™ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_6106"></a>ev-if
  (save exp)                    <em>; save expression for later</em>
  (save env)
  (save continue)
  (assign continue (label ev-if-decide))
  (assign exp (op if-predicate) (reg exp))
  (goto (label eval-dispatch))  <em>; evaluate the predicate</em>
</p>

<p class="orig" lang="en">
When we return from evaluating the predicate, we test whether it was
true or false and, depending on the result, place either the
consequent or the alternative in <tt>exp</tt> before going to <tt>eval-dispatch</tt>.  Notice that restoring <tt>env</tt> and <tt>continue</tt>
here sets up <tt>eval-dispatch</tt> to have the correct environment and
to continue at the right place to receive the value of the <tt>if</tt>
expression. </p>

<p class="trans" lang="ja">
è¿°èªã®è©•ä¾¡ã‹ã‚‰æˆ»ã£ãŸã‚‰ã€ãã‚ŒãŒçœŸã ã£ãŸã®ã‹å½ã ã£ãŸã®ã‹ã‚’æ¤œæŸ»ã—ã€ãã®çµæœã«ã‚ˆã£ã¦ã€<tt>eval-dispatch</tt> ã«è¡Œãå‰ã«ã€å¸°çµå¼ã‹ä»£æ›¿å¼ã®ã„ãšã‚Œã‹ã‚’ <tt>exp</tt> ã«å…¥ã‚Œã‚‹ã€‚
<tt>env</tt> ã¨ <tt>continue</tt> ã‚’ã“ã“ã§å¾©æ—§ã™ã‚‹ã“ã¨ã§ã€<tt>eval-dispatch</tt> ã¯ã€æ­£ã—ã„ç’°å¢ƒã‚’æœ‰ã™ã‚‹ã‚ˆã†ã«ã€ã‹ã¤ã€<tt>if</tt> å¼ã®å€¤ã‚’å—ã‘å–ã‚‹ãŸã‚ã®æ­£ã—ã„å ´æ‰€ã§ç¶šè¡Œã™ã‚‹ã‚ˆã†ã«ã€è¨­å®šã•ã‚Œã‚‹ã®ã ã€ã¨ã„ã†ã“ã¨ã«æ³¨æ„ã—ã¦ã»ã—ã„ã€‚
</p>

<p class="lisp">ev-if-decide
  (restore continue)
  (restore env)
  (restore exp)
  (test (op true?) (reg val))
  (branch (label ev-if-consequent))

ev-if-alternative
  (assign exp (op if-alternative) (reg exp))
  (goto (label eval-dispatch))
ev-if-consequent
  (assign exp (op if-consequent) (reg exp))
  (goto (label eval-dispatch))
</p>

<a name="%_sec_Temp_779"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_779">Assignments and definitions</a></h4>
<h4 class="trans" lang="ja"><ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã¨å®šç¾©</h4>

<p class="orig" lang="en">
<a name="%_idx_6108"></a>Assignments are handled by <tt>ev-assignment</tt>, which is reached from
<tt>eval-dispatch</tt> with the assignment expression in <tt>exp</tt>.  The code at <tt>ev-assignment</tt> first evaluates the value part of the expression and
then installs the new value in the environment.  <tt>Set-variable-value!</tt> is assumed to be available as a machine
operation.</p>

<p class="trans" lang="ja">
<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã¯ã€<tt>ev-assignment</tt> â€”â€”ã“ã“ã«ã¯ã€<tt>exp</tt> ã®ä¸­ã®<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>å¼ã‚’ã¨ã‚‚ãªã£ã¦ã€<tt>eval-dispatch</tt> ã‹ã‚‰åˆ°é”ã™ã‚‹â€”â€”ã«ã‚ˆã‚Šã€æ‰±ã‚ã‚Œã‚‹ã€‚
<tt>ev-assignment</tt> ã«ãŠã‘ã‚‹ã‚³ãƒ¼ãƒ‰ã¯ã€ã¾ãšã€å¼ã®ã†ã¡ã®å€¤ã®éƒ¨åˆ†ã‚’è©•ä¾¡ã—ã€ãã‚Œã‹ã‚‰ã€æ–°ãŸãªå€¤ã‚’ç’°å¢ƒã«å–ã‚Šè¾¼ã‚€ã€‚
<tt>set-variable-value!</tt> ã¯ã€ãƒã‚·ãƒ³æ¼”ç®—ã¨ã—ã¦åˆ©ç”¨å¯èƒ½ã§ã‚ã‚‹ã‚‚ã®ã¨ã™ã‚‹ã€‚
</p>


<p class="lisp"><a name="%_idx_6110"></a>ev-assignment
  (assign unev (op assignment-variable) (reg exp))
  (save unev)                   <em>; save variable for later</em>
  (assign exp (op assignment-value) (reg exp))
  (save env)
  (save continue)
  (assign continue (label ev-assignment-1))
  (goto (label eval-dispatch))  <em>; evaluate the assignment value</em>
ev-assignment-1
  (restore continue)
  (restore env)
  (restore unev)
  (perform
   (op set-variable-value!) (reg unev) (reg val) (reg env))
  (assign val (const ok))
  (goto (reg continue))
</p>

<p class="orig" lang="en">
<a name="%_idx_6112"></a>Definitions are handled in a similar way:</p>

<p class="trans" lang="ja">
å®šç¾©ã¯ã€ä¼¼ãŸæ–¹æ³•ã§æ‰±ã‚ã‚Œã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_6114"></a>ev-definition
  (assign unev (op definition-variable) (reg exp))
  (save unev)                   <em>; save variable for later</em>
  (assign exp (op definition-value) (reg exp))
  (save env)
  (save continue)
  (assign continue (label ev-definition-1))
  (goto (label eval-dispatch))  <em>; evaluate the definition value</em>
ev-definition-1
  (restore continue)
  (restore env)
  (restore unev)
  (perform
   (op define-variable!) (reg unev) (reg val) (reg env))
  (assign val (const ok))
  (goto (reg continue))
</p>

<p class="orig" lang="en">
<a name="%_thm_5.23"></a>
<b>Exercise 5.23.</b>  <a name="%_idx_6116"></a><a name="%_idx_6118"></a><a name="%_idx_6120"></a>Extend the evaluator to handle derived expressions such as <tt>cond</tt>,
<tt>let</tt>, and so on (section <a href="26_sec4_1.html#%_sec_4.1.2">4.1.2</a>).
You may ``cheat'' and assume that the syntax
transformers such as <tt>cond-&gt;if</tt> are available as machine
operations.<a name="call_footnote_Temp_781" href="#footnote_Temp_781"><sup><small>28</small></sup></a>
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ5.23.</b> <tt>cond</tt> ã‚„ <tt>let</tt> ãªã©ã®ã‚ˆã†ãªæ´¾ç”Ÿå¼ (<a href="26_sec4_1.html#%_sec_4.1.2">4.1.2</a>ç¯€) ã‚’æ‰±ã†ã‚ˆã†ã«ã€è©•ä¾¡å™¨ã‚’æ‹¡å¼µã›ã‚ˆã€‚
å›ã¯ã€ã€Œã”ã¾ã‹ã—ã€ã‚’ã—ã¦ã€<tt>cond-&gt;if</tt> ã®ã‚ˆã†ãªæ–‡æ³•å¤‰æ›å™¨ãŒãƒã‚·ãƒ³æ¼”ç®—ã¨ã—ã¦åˆ©ç”¨å¯èƒ½ãªã®ã ã¨æƒ³å®šã—ã¦ã‚‚ã€æ§‹ã‚ãªã„<a name="call_footnote_Temp_781" href="#footnote_Temp_781"><sup><small>28</small></sup></a>ã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.24"></a>
<b>Exercise 5.24.</b>  <a name="%_idx_6122"></a>Implement <tt>cond</tt> as a new basic special form without
reducing it to <tt>if</tt>.  You will have to construct a loop that tests
the predicates of successive <tt>cond</tt> clauses until you find one
that is true, and then use <tt>ev-sequence</tt> to evaluate the actions
of the clause.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ5.24.</b> <tt>cond</tt> ã‚’ <tt>if</tt> ã¸ã¨å¸°ç€ã•ã›ã‚‹ã“ã¨ãªã—ã«ã€æ–°ãŸãªåŸºæœ¬çš„ç‰¹æ®Šå½¢å¼ã¨ã—ã¦ <tt>cond</tt> ã‚’å®Ÿè£…ã›ã‚ˆã€‚
é€£ç¶šã™ã‚‹ <tt>cond</tt> ç¯€ã®è¿°èªã‚’ã€çœŸã§ã‚ã‚‹ã‚‚ã®ã‚’è¦‹ã¤ã‘ã‚‹ã¾ã§æ¤œæŸ»ã™ã‚‹ãƒ«ãƒ¼ãƒ—ã‚’ã€æ§‹ç¯‰ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã ã‚ã†ã—ã€ãã‚Œã‹ã‚‰ã€<tt>ev-sequence</tt> ã‚’ç”¨ã„ã¦ã€ãã®ç¯€ã®å‹•ä½œã‚’è©•ä¾¡ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã ã‚ã†ã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.25"></a>
<b>Exercise 5.25.</b>  <a name="%_idx_6124"></a><a name="%_idx_6126"></a>Modify the evaluator so that it uses normal-order evaluation,
based on the lazy evaluator of section <a href="27_sec4_2.html#%_sec_4.2">4.2</a>.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ5.25.</b> <a href="27_sec4_2.html#%_sec_4.2">4.2</a>ç¯€ã®é…å»¶è©•ä¾¡å™¨ã«åŸºã¥ã„ã¦ã€æ­£è¦é †ã®è©•ä¾¡ã‚’ç”¨ã„ã‚‹ã‚ˆã†ã«è©•ä¾¡å™¨ã‚’æ”¹ä¿®ã›ã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_5.4.4"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_5.4.4">5.4.4  Running the Evaluator</a></h3>
<h3 class="trans" lang="ja">5.4.4 è©•ä¾¡å™¨ã‚’å‹•ã‹ã™</h3>
<p class="extra" id="translating">**ã“ã“ã‹ã‚‰</p>

<p class="orig" lang="en"><a name="%_idx_6128"></a>
<a name="%_idx_6130"></a><a name="%_idx_6132"></a>With the implementation of the explicit-control evaluator we come to
the end of a development, begun in chapter 1, in which we have
explored successively more precise models of the evaluation process.
We started with the relatively informal substitution model, then
extended this in chapter 3 to the environment model, which enabled us
to deal with state and change.  In the metacircular evaluator of
chapter 4, we used Scheme itself as a language for making more explicit
the environment structure constructed during evaluation of an
expression.  Now, with register machines, we have taken a close look
at the evaluator's mechanisms for storage management,
argument passing, and control.  At
each new level of description, we have had to raise issues and resolve
ambiguities that were not apparent at the previous, less precise
treatment of evaluation.  To understand the behavior of the
explicit-control evaluator, we can simulate it and monitor its
performance.</p>

<p class="trans" lang="ja">
</p>

<p class="orig" lang="en">
<a name="%_idx_6134"></a><a name="%_idx_6136"></a>We will install a driver loop in our evaluator machine.  This plays
the role of the <tt>driver-loop</tt> procedure of
section <a href="26_sec4_1.html#%_sec_4.1.4">4.1.4</a>.  The evaluator will repeatedly print a
prompt, read an expression, evaluate the expression by going to <tt>eval-dispatch</tt>, and print the result.  The following instructions form
the beginning of the explicit-control evaluator's controller
sequence:<a name="call_footnote_Temp_784" href="#footnote_Temp_784"><sup><small>29</small></sup></a></p>

<p class="trans" lang="ja">
</p>

<p class="lisp"><a name="%_idx_6142"></a><a name="%_idx_6144"></a>read-eval-print-loop
  (perform (op initialize-stack))
  (perform
   (op prompt-for-input) (const &quot;;;; EC-Eval input:&quot;))
  (assign exp (op read))
  (assign env (op get-global-environment))
  (assign continue (label print-result))
  (goto (label eval-dispatch))
<a name="%_idx_6146"></a>print-result
  (perform
   (op announce-output) (const &quot;;;; EC-Eval value:&quot;))
  (perform (op user-print) (reg val))
  (goto (label read-eval-print-loop))
</p>

<p class="orig" lang="en">
<a name="%_idx_6148"></a><a name="%_idx_6150"></a>When we encounter an error in a procedure (such as the ``unknown
procedure type error'' indicated at <tt>apply-dispatch</tt>), we print an
error message and return to the driver loop.<a name="call_footnote_Temp_785" href="#footnote_Temp_785"><sup><small>30</small></sup></a></p>

<p class="trans" lang="ja">
</p>

<p class="lisp"><a name="%_idx_6152"></a>unknown-expression-type
  (assign val (const unknown-expression-type-error))
  (goto (label signal-error))
<a name="%_idx_6154"></a>unknown-procedure-type
  (restore continue)    <em>; clean up stack (from <tt>apply-dispatch</tt>)</em>
  (assign val (const unknown-procedure-type-error))
  (goto (label signal-error))
<a name="%_idx_6156"></a>signal-error
  (perform (op user-print) (reg val))
  (goto (label read-eval-print-loop))
</p>

<p class="orig" lang="en">
For the purposes of the simulation, we initialize the stack each time
through the driver loop, since it might not be empty after an error
(such as an undefined variable) interrupts an evaluation.<a name="call_footnote_Temp_786" href="#footnote_Temp_786"><sup><small>31</small></sup></a></p>

<p class="trans" lang="ja">
</p>

<p class="orig" lang="en">
<a name="%_idx_6158"></a>If we combine all the code fragments presented in sections
<a href="#%_sec_5.4.1">5.4.1</a>-<a href="#%_sec_5.4.4">5.4.4</a>, we can create an
evaluator machine model that we can run using the register-machine simulator
of section <a href="32_sec5_2.html#%_sec_5.2">5.2</a>.</p>

<p class="trans" lang="ja">
</p>

<p class="lisp">(define eceval
  (make-machine
   '(exp env val proc argl continue unev)
   eceval-operations
  '(
    read-eval-print-loop
      &lt;<em>entire machine controller as given above</em>&gt;
   )))
</p>

<p class="orig" lang="en">We must define Scheme procedures to simulate the
operations used as primitives by the evaluator.  These are
the same procedures we used for the metacircular evaluator in
section <a href="26_sec4_1.html#%_sec_4.1">4.1</a>, together with the few additional ones
defined in footnotes throughout section <a href="#%_sec_5.4">5.4</a>.</p>

<p class="trans" lang="ja">
</p>

<p class="lisp">(define eceval-operations
  (list (list 'self-evaluating? self-evaluating)
        <em>&lt;complete list of operations for eceval machine&gt;</em>))
</p>


<p class="orig" lang="en">
Finally, we can initialize the global environment and run the evaluator:</p>

<p class="trans" lang="ja">
</p>

<p class="lisp">(define the-global-environment (setup-environment))

(start eceval)
<i>;;; EC-Eval input:</i>
(define (append x y)
  (if (null? x)
      y
      (cons (car x)
            (append (cdr x) y))))
<i>;;; EC-Eval value:</i>
<i>ok</i>
<i>;;; EC-Eval input:</i>
(append '(a b c) '(d e f))
<i>;;; EC-Eval value:</i>
<i>(a b c d e f)</i>
</p>

<p class="orig" lang="en">
Of course, evaluating expressions in this way will take much longer
than if we had directly typed them into Scheme, because of the
multiple levels of simulation involved.  Our expressions are evaluated
by the explicit-control-evaluator machine, which is being simulated by
a Scheme program, which is itself being evaluated by the Scheme
interpreter.</p>

<p class="trans" lang="ja">
</p>

<a name="%_sec_Temp_787"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_787">Monitoring the performance of the evaluator</a></h4>
<h4 class="trans" lang="ja">è©•ä¾¡å™¨ã®æ€§èƒ½ã‚’ç›£è¦–ã™ã‚‹</h4>

<p class="orig" lang="en">
<a name="%_idx_6160"></a>
<a name="%_idx_6162"></a>Simulation can be a powerful tool to guide the implementation of
evaluators.  Simulations make it easy not only to explore variations
of the register-machine design but also to monitor the performance of
the simulated evaluator.  For example, one important factor in
performance is how efficiently the evaluator uses the stack.  We can
observe the number of stack operations required to evaluate various
expressions by defining the evaluator register machine with the
version of the simulator that collects statistics on stack use
(section <a href="32_sec5_2.html#%_sec_5.2.4">5.2.4</a>), and adding an instruction at the
evaluator's <tt>print-result</tt> entry point to print the
statistics:</p>

<p class="trans" lang="ja">
</p>

<p class="lisp"><a name="%_idx_6164"></a>print-result
  (perform (op print-stack-statistics))<em>; added instruction</em>
  (perform
   (op announce-output) (const &quot;;;; EC-Eval value:&quot;))
  <tt>...</tt> <em>; same as before</em>
</p>

<p class="orig" lang="en">Interactions with the evaluator now look like this:</p>

<p class="trans" lang="ja">
</p>

<p class="lisp"><i>;;; EC-Eval input:</i>
(define (factorial n)
  (if (= n 1)
      1
      (* (factorial (- n 1)) n)))
<i>(total-pushes = 3 maximum-depth = 3)</i>
<i>;;; EC-Eval value:</i>
<i>ok</i>
<i>;;; EC-Eval input:</i>
(factorial 5)
<i>(total-pushes = 144 maximum-depth = 28)</i>
<i>;;; EC-Eval value:</i>
<i>120</i>
</p>

<p class="orig" lang="en">Note that the driver loop of the evaluator reinitializes the stack
at the start of
each interaction, so that the statistics printed will refer only to
stack operations used to evaluate the previous expression.</p>

<p class="trans" lang="ja">
</p>

<p class="orig" lang="en">
<a name="%_thm_5.26"></a>
<b>Exercise 5.26.</b>  <a name="%_idx_6166"></a><a name="%_idx_6168"></a><a name="%_idx_6170"></a>Use the monitored stack to explore the tail-recursive property of the
evaluator (section <a href="#%_sec_5.4.2">5.4.2</a>).  Start the
evaluator and define the iterative <tt>factorial</tt> procedure from
section <a href="11_sec1_2.html#%_sec_1.2.1">1.2.1</a>:</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ5..</b> 
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="lisp">(define (factorial n)
  (define (iter product counter)
    (if (&gt; counter n)
        product
        (iter (* counter product)
              (+ counter 1))))
  (iter 1 1))
</p>

<p class="orig" lang="en">Run the procedure with some small values of <em>n</em>.  Record the maximum
stack depth and the number of pushes required to compute <em>n</em>! for each of
these values.</p>

<p class="trans" lang="ja">
</p>

<ol class="orig alph" lang="en">
<li>You will find that the maximum depth required to evaluate <em>n</em>! is
independent of <em>n</em>.  What is that depth?</li>

<li>Determine from your data a formula in terms of <em>n</em> for the total
number of push operations used in evaluating <em>n</em>! for any <em>n</em> <u>&gt;</u> 1.
Note that the number of operations used is a linear function of <em>n</em>
and is thus determined by two constants.</li>
</ol>


<ol class="trans alph" lang="ja">
<li></li>
<li></li>
</ol>

<p class="orig" lang="en">
<a name="%_thm_5.27"></a>
<b>Exercise 5.27.</b>  <a name="%_idx_6172"></a>For comparison with exercise <a href="#%_thm_5.26">5.26</a>, explore the
behavior of the following procedure for computing factorials
recursively:</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ5..</b> 
</p>

<p class="lisp">(define (factorial n)
  (if (= n 1)
      1
      (* (factorial (- n 1)) n)))
</p>

<p class="orig" lang="en">By running this procedure with the monitored stack, determine, as a
function of <em>n</em>, the maximum depth of the stack and the total number
of pushes used in evaluating <em>n</em>! for <em>n</em> <u>&gt;</u> 1.  (Again, these functions
will be linear.)  Summarize your experiments by filling in the
following table with the appropriate expressions in terms of <em>n</em>:</p>

<p class="trans" lang="ja">
</p>


<div class="orig" lang="en">
<table class="expl">
<tr><td></td><td>Maximum depth </td><td>Number of pushes</td></tr>
<tr><td>Recursive factorial </td><td></td><td></td></tr>
<tr><td>Iterative factorial </td><td></td><td></td></tr>
</table>
</div>
<br>

<div class="trans" lang="ja">
<table class="expl">
<tr><td></td><td>æœ€å¤§ã®æ·±ã•</td><td>ãƒ—ãƒƒã‚·ãƒ¥æ•°</td></tr>
<tr><td>å†å¸°çš„ãªéšä¹—</td><td></td><td></td></tr>
<tr><td>åå¾©çš„ãªéšä¹—</td><td></td><td></td></tr>
</table>

</div>

<p class="orig" lang="en">
The maximum depth is a measure of the amount of space used by the
evaluator in carrying out the computation, and the number of pushes
correlates well with the time required.
</p>

<p class="trans" lang="ja">
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.28"></a>
<b>Exercise 5.28.</b>  <a name="%_idx_6174"></a><a name="%_idx_6176"></a>Modify the definition of the evaluator by changing
<tt>eval-sequence</tt> as described in
section <a href="#%_sec_5.4.2">5.4.2</a> so that the evaluator is no
longer tail-recursive.  Rerun your experiments from
exercises <a href="#%_thm_5.26">5.26</a> and <a href="#%_thm_5.27">5.27</a> to demonstrate
that both versions of the <tt>factorial</tt> procedure now require space
that grows linearly with their input.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ5..</b> 
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.29"></a>
<b>Exercise 5.29.</b>  <a name="%_idx_6178"></a>Monitor the stack operations in the tree-recursive Fibonacci computation:</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ5..</b> 
</p>

<p class="lisp"><a name="%_idx_6180"></a>(define (fib n)
  (if (&lt; n 2)
      n
      (+ (fib (- n 1)) (fib (- n 2)))))
</p>

<ol class="orig alph" lang="en">
<li>Give a formula in terms of <em>n</em> for the maximum depth of the stack
required to compute  <em>F</em><em>i</em><em>b</em>(<em>n</em>) for <em>n</em> <u>&gt;</u> 2.  Hint: In
section <a href="11_sec1_2.html#%_sec_1.2.2">1.2.2</a> we argued that the space used by this
process grows linearly with <em>n</em>.</li>

<li>Give a formula for the total number of pushes used to compute
 <em>F</em><em>i</em><em>b</em>(<em>n</em>) for <em>n</em> <u>&gt;</u> 2.  You should find that the number of
pushes (which correlates well with the time used) grows exponentially
with <em>n</em>.  Hint: Let <em>S</em>(<em>n</em>) be the number of pushes used in computing
 <em>F</em><em>i</em><em>b</em>(<em>n</em>).  You should be able to argue that there is a formula
that expresses <em>S</em>(<em>n</em>) in terms of <em>S</em>(<em>n</em> - 1), <em>S</em>(<em>n</em> - 2), and some fixed
``overhead'' constant <em>k</em> that is independent of <em>n</em>.  Give the
formula, and say what <em>k</em> is.  Then show that <em>S</em>(<em>n</em>) can be expressed
as <em>a</em>  <em>F</em><em>i</em><em>b</em>(<em>n</em> + 1)  +  <em>b</em> and give the values of <em>a</em> and <em>b</em>.</li>
</ol>


<ol class="trans alph" lang="ja">
<li></li>
<li></li>
</ol>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.30"></a>
<b>Exercise 5.30.</b>  <a name="%_idx_6182"></a><a name="%_idx_6184"></a>Our evaluator currently catches and signals only two kinds of
errors -- unknown expression types and unknown procedure types.  Other
errors will take us out of the evaluator read-eval-print loop.  When
we run the evaluator using the register-machine simulator, these
errors are caught by the underlying Scheme system.  This is analogous
to the computer crashing when a user program makes an
error.<a name="call_footnote_Temp_793" href="#footnote_Temp_793"><sup><small>32</small></sup></a>  It is a large project to make a real
error system work, but it is well worth the effort to understand what
is involved here.</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ5..</b> 
</p>

<ol class="orig alph" lang="en">
<li>Errors that occur in the evaluation process, such as an attempt to
access an unbound variable, could be caught by changing the lookup
operation to make it return a distinguished condition code, which cannot
be a possible value of any user variable.  The evaluator can test
for this condition code and then do what is necessary to go to <tt>signal-error</tt>.  Find all of the places in the evaluator where such a
change is necessary and fix them.  This is lots of work.</li>

<li>Much worse is the problem of handling errors that are signaled by
applying primitive procedures, such as an attempt to divide by zero or
an attempt to extract the <tt>car</tt> of a symbol.  In a professionally
written high-quality system, each primitive application is checked for
safety as part of the primitive.  For example, every call to <tt>car</tt>
could first check that the argument is a pair.  If the argument is not
a pair, the application would return a distinguished condition code to
the evaluator, which would then report the failure.  We could arrange
for this in our register-machine simulator by making each primitive
procedure
check for applicability and returning an appropriate distinguished
condition code on failure. Then the <tt>primitive-apply</tt> code in the
evaluator can check for the condition code and go to <tt>signal-error</tt> if necessary.  Build this structure and make it work.
This is a major project.</li>
</ol>


<ol class="trans alph" lang="ja">
<li></li>
<li></li>
</ol>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="footnotes"></a>
<hr>

<p class="orig" lang="en"><a name="footnote_Temp_765" href="#call_footnote_Temp_765"><sup><small>19</small></sup></a> See Batali et al. 1982 for more
<a name="%_idx_6004"></a>information on the chip and the method by which it was designed.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_765"><sup><small>19</small></sup></a> 
å½“è©²ãƒãƒƒãƒ—ã¨ã€ãã‚Œã‚’è¨­è¨ˆã—ãŸæ‰‹æ³•ã«ã¤ã„ã¦ã®ã€ã‚ˆã‚Šè©³ã—ã„æƒ…å ±ã¯ã€Batali et al. 1982 ã‚’å‚ç…§ã®ã“ã¨ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_767" href="#call_footnote_Temp_767"><sup><small>20</small></sup></a> In our controller, the dispatch is written as a
sequence of <tt>test</tt> and <tt>branch</tt> instructions.  Alternatively,
it could have been written in a data-directed style (and in a real
system it probably would have been) to avoid the need to perform
sequential tests and to facilitate the definition of new expression
types.  A machine designed to run Lisp would probably include a <tt>dispatch-on-type</tt> instruction that would efficiently execute such
data-directed dispatches.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_767"><sup><small>20</small></sup></a>
ç§ãŸã¡ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ã§ã¯ã€<tt>test</tt> å‘½ä»¤ã¨ <tt>branch</tt> å‘½ä»¤ã®åˆ—ã¨ã—ã¦ã€<ruby><rb>æŒ¯ã‚Šåˆ†ã‘</rb><rp> (</rp><rt>ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒ</rt><rp>) </rp></ruby>ãŒæ›¸ã‹ã‚Œã¦ã„ã‚‹ã€‚
ãã†ã™ã‚‹ä»£ã‚ã‚Šã«ã€é€æ¬¡çš„ãªæ¤œæŸ»ã‚’å®Ÿè¡Œã™ã‚‹å¿…è¦æ€§ã‚’é¿ã‘ã‚‹ãŸã‚ã«ã€ã¾ãŸã€æ–°ãŸãªå¼ã®ç¨®é¡ã®å®šç¾©ã‚’å®¹æ˜“ã«ã™ã‚‹ãŸã‚ã«ã€ãƒ‡ãƒ¼ã‚¿æŒ‡å‘çš„ãªæ§˜å¼ã§æŒ¯ã‚Šåˆ†ã‘ã‚’æ›¸ãã“ã¨ã‚‚ã§ããŸã ã‚ã† (ã—ã€ç¾å®Ÿã®ã‚·ã‚¹ãƒ†ãƒ ã«ãŠã„ã¦ã¯ã€ãŠãã‚‰ããã®ã‚ˆã†ã«æ›¸ã‹ã‚ŒãŸã§ã‚ã‚ã†)ã€‚ <span class="note">(æ‹¬å¼§å†…ã®è¨³ã—æ–¹ãŒã‚„ã‚„ä¸å®‰)</span>
Lisp ã‚’å®Ÿè¡Œã™ã‚‹ã‚ˆã†ã«è¨­è¨ˆã•ã‚ŒãŸãƒã‚·ãƒ³ã¯ã€ãã®ã‚ˆã†ãªãƒ‡ãƒ¼ã‚¿æŒ‡å‘çš„ãªæŒ¯ã‚Šåˆ†ã‘ã‚’åŠ¹ç‡ã‚ˆãå®Ÿè¡Œã™ã‚‹ã§ã‚ã‚ã† <tt>dispatch-on-type</tt> å‘½ä»¤ã‚’ã€ãŠãã‚‰ãã¯å«ã‚€ã§ã‚ã‚ã†ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_770" href="#call_footnote_Temp_770"><sup><small>21</small></sup></a> This is an important but subtle point in translating
algorithms from a procedural language, such as Lisp, to a
register-machine language.  As an alternative to saving only what is
needed, we could save all the registers (except <tt>val</tt>) before each
recursive call. This is called a <a name="%_idx_6052"></a><a name="%_idx_6054"></a><em>framed-stack</em> discipline.  This
would work but might save more registers than necessary; this could be
an important consideration in a system where stack operations are
expensive.  Saving registers whose contents will not be needed later
may also hold onto useless data that could otherwise be
garbage-collected, freeing space to be reused.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_770"><sup><small>21</small></sup></a>
ã“ã‚Œã¯ã€Lisp ã®ã‚ˆã†ãªæ‰‹ç¶šãçš„è¨€èªã‹ã‚‰ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ»ãƒã‚·ãƒ³è¨€èªã¸ã¨ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’å¤‰æ›ã™ã‚‹éš›ã®ã€é‡è¦ã ãŒå¾®å¦™ãªç‚¹ã§ã‚ã‚‹ã€‚
å¿…è¦ã¨ã•ã‚Œã‚‹ã‚‚ã®ã ã‘ã‚’é€€é¿ã™ã‚‹ã“ã¨ã«å¯¾ã™ã‚‹ä»£æ›¿æ¡ˆã¨ã—ã¦ã€ç§ãŸã¡ã¯ã€ãã‚Œãã‚Œã®å†å¸°çš„ãªå‘¼ã³å‡ºã—ã®å‰ã«ã€(<tt>val</tt> ä»¥å¤–ã®) ã™ã¹ã¦ã®ãƒ¬ã‚¸ã‚¹ã‚¿ã‚’é€€é¿ã™ã‚‹ã“ã¨ã‚‚ã§ãã‚ˆã†ã€‚
ã“ã‚Œã¯ã€<em>ãƒ•ãƒ¬ãƒ¼ãƒ ä»˜ãã‚¹ã‚¿ãƒƒã‚¯</em> è¦å¾‹ã¨å‘¼ã°ã‚Œã‚‹ã€‚
ã“ã‚Œã¯ã†ã¾ãè¡Œãã ã‚ã†ãŒã€å¿…è¦ä»¥ä¸Šã«å¤šãã®ãƒ¬ã‚¸ã‚¹ã‚¿ã‚’é€€é¿ã™ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚ã“ã‚Œã¯ã€ã‚¹ã‚¿ãƒƒã‚¯æ¼”ç®—ãŒé«˜ãã¤ãã‚·ã‚¹ãƒ†ãƒ ã§ã¯ã€é‡è¦ãªè«–ç‚¹ã§ã‚ã‚‹ã€‚
ä¸­èº«ãŒå¾Œã«å¿…è¦ã¨ã•ã‚Œãªã„ã‚ˆã†ãªãƒ¬ã‚¸ã‚¹ã‚¿ã‚’é€€é¿ã™ã‚‹ã“ã¨ã¯ã€ä»–ã®å ´åˆã§ã‚ã‚Œã°ã‚¬ãƒ¼ãƒ™ã‚¸ãƒ»ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³â€”â€”å†åˆ©ç”¨ã™ã¹ãç©ºé–“ã‚’è§£æ”¾ã™ã‚‹â€”â€”ãŒãªã•ã‚Œå¾—ã‚‹ã ã‚ã†ç„¡ç”¨ãªãƒ‡ãƒ¼ã‚¿ã‚’ã€ä¿ç®¡ã—ã¦ãŠãã“ã¨ã«ãªã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã®ã ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_771" href="#call_footnote_Temp_771"><sup><small>22</small></sup></a> We add to the evaluator data-structure procedures in
section <a href="26_sec4_1.html#%_sec_4.1.3">4.1.3</a> the following two procedures
for manipulating argument lists:</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_771"><sup><small>22</small></sup></a>
<a href="26_sec4_1.html#%_sec_4.1.3">4.1.3</a>ç¯€ã§ç§ãŸã¡ã¯ã€å¼•æ•°ãƒªã‚¹ãƒˆã‚’æ“ä½œã™ã‚‹ãŸã‚ã®ä»¥ä¸‹ã®äºŒã¤ã®æ‰‹ç¶šãã‚’ã€è©•ä¾¡å™¨ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ æ‰‹ç¶šãã«è¿½åŠ ã—ã¦ã„ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_6060"></a>(define (empty-arglist) '())

<a name="%_idx_6062"></a>(define (adjoin-arg arg arglist)
  (append arglist (list arg)))
</p>

<p class="orig" lang="en">We also use an additional syntax procedure to test for the
last operand in a combination:</p>

<p class="trans" lang="ja">
ã‚³ãƒ³ãƒ“ãƒãƒ¼ã‚·ãƒ§ãƒ³å†…ã®æœ€å¾Œã®ã‚ªãƒšãƒ©ãƒ³ãƒ‰ãªã®ã‹ã‚’æ¤œæŸ»ã™ã‚‹ãŸã‚ã®ä»˜åŠ çš„ãªæ–‡æ³•æ‰‹ç¶šãã‚‚ã€ç§ãŸã¡ã¯åˆ©ç”¨ã—ã¦ã„ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_6064"></a>(define (last-operand? ops)
  (null? (cdr ops)))
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_772" href="#call_footnote_Temp_772"><sup><small>23</small></sup></a> The optimization of treating the last operand
<a name="%_idx_6066"></a>specially is known as <i>evlis tail recursion</i> (see <a name="%_idx_6068"></a>Wand 1980).
We could be somewhat more efficient
in the argument evaluation loop if we made evaluation of the first
operand a special case too.  This would permit us to postpone
initializing <tt>argl</tt> until after evaluating the first operand, so
as to avoid saving <tt>argl</tt> in this case.  The compiler in
section <a href="35_sec5_5.html#%_sec_5.5">5.5</a> performs this optimization.  (Compare
the <tt>construct-arglist</tt> procedure of
section <a href="35_sec5_5.html#%_sec_5.5.3">5.5.3</a>.)</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_772"><sup><small>23</small></sup></a>
æœ€å¾Œã®ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã®å–ã‚Šæ‰±ã„ã®æœ€é©åŒ–ã¯ã€å…·ä½“çš„ã«ã¯ã€<em>evlis ã®æœ«å°¾å†å¸°</em> ã¨ã—ã¦çŸ¥ã‚‰ã‚Œã¦ã„ã‚‹ (Wand 1980 ã‚’å‚ç…§)ã€‚
æœ€åˆã®ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã®è©•ä¾¡ã‚‚ç‰¹åˆ¥ãªå ´åˆã«ã—ã¦ã„ãŸãªã‚‰ã°ã€å¼•æ•°è©•ä¾¡ãƒ«ãƒ¼ãƒ—ã‚’ã€å¤šå°‘ã¯ã‚ˆã‚ŠåŠ¹ç‡çš„ã«ã™ã‚‹ã“ã¨ãŒã§ããŸã ã‚ã†ã€‚
ã“ã‚Œã«ã‚ˆã£ã¦ã€ç§ãŸã¡ã¯ã€æœ€åˆã®ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã®è©•ä¾¡å¾Œã¾ã§ã€<tt>argl</tt> ã®åˆæœŸåŒ–ã‚’å»¶æœŸã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã ã‚ã†ã—ã€ã™ã‚‹ã¨ã€ã“ã®å ´åˆã« <tt>argl</tt> ã‚’é€€é¿ã™ã‚‹ã“ã¨ã‚’é¿ã‘ã‚‰ã‚Œã‚‹ã‚ˆã†ã«ãªã‚‹ã€‚
<a href="35_sec5_5.html#%_sec_5.5">5.5</a>ç¯€ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯ã€ã“ã®æœ€é©åŒ–ã‚’è¡Œã† (<a href="35_sec5_5.html#%_sec_5.5.3">5.5.3</a>ç¯€ã® <tt>construct-arglist</tt> æ‰‹ç¶šãã‚’æ¯”è¼ƒã›ã‚ˆ)ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_773" href="#call_footnote_Temp_773"><sup><small>24</small></sup></a> The
order of operand evaluation in the metacircular evaluator is
determined by the order of evaluation of the arguments to <tt>cons</tt>
in the procedure <tt>list-of-values</tt> of section <a href="26_sec4_1.html#%_sec_4.1.1">4.1.1</a>
(see exercise <a href="26_sec4_1.html#%_thm_4.1">4.1</a>).</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_773"><sup><small>24</small></sup></a>
ãƒ¡ã‚¿å¾ªç’°çš„ãªè©•ä¾¡å™¨ã«ãŠã‘ã‚‹ã‚ªãƒšãƒ©ãƒ³ãƒ‰è©•ä¾¡ã®é †åºã¯ã€<a href="26_sec4_1.html#%_sec_4.1.1">4.1.1</a>ç¯€ã® <tt>list-of-values</tt> ã¨ã„ã†æ‰‹ç¶šãã«ãŠã‘ã‚‹ã€<tt>cons</tt> ã«å¯¾ã™ã‚‹å¼•æ•°ã®è©•ä¾¡ã®é †åºã«ã‚ˆã£ã¦ã€å®šã¾ã‚‹
(ç·´ç¿’å•é¡Œ<a href="26_sec4_1.html#%_thm_4.1">4.1</a>ã‚’å‚ç…§)ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_776" href="#call_footnote_Temp_776"><sup><small>25</small></sup></a> We saw in
section <a href="31_sec5_1.html#%_sec_5.1">5.1</a> how to implement such a
process with a register machine that had no stack; the state of the
process was stored in a fixed set of registers.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_776"><sup><small>25</small></sup></a>
ãã†ã—ãŸãƒ—ãƒ­ã‚»ã‚¹ã‚’ã€ã‚¹ã‚¿ãƒƒã‚¯ã®ãªã„ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ»ãƒã‚·ãƒ³ã‚’ç”¨ã„ã¦ã©ã®ã‚ˆã†ã«å®Ÿè£…ã™ã‚‹ã®ã‹ã¨ã„ã†ã“ã¨ã‚’ã€<a href="31_sec5_1.html#%_sec_5.1">5.1</a>ç¯€ã§è¦‹ãŸã€‚ã¤ã¾ã‚Šã€ãƒ—ãƒ­ã‚»ã‚¹ã®çŠ¶æ…‹ã¯ã€æ‰€å®šã®ä¸€æƒã„ã®ãƒ¬ã‚¸ã‚¹ã‚¿ã«è¨˜æ†¶ã•ã‚ŒãŸè¨³ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_777" href="#call_footnote_Temp_777"><sup><small>26</small></sup></a> This implementation of tail recursion in
<tt>ev-sequence</tt> is one variety of a well-known optimization technique used
by many compilers.  In compiling a procedure that ends with a procedure call,
one can replace the call by a jump to the called procedure's entry point.
Building this strategy into the interpreter, as we have done in this section,
provides the optimization uniformly throughout the language.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_777"><sup><small>26</small></sup></a>
<tt>ev-sequence</tt> ã«ãŠã‘ã‚‹æœ«å°¾å†å¸°ã®ã“ã®å®Ÿè£…ã¯ã€å¤šãã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã«ã‚ˆã‚Šä½¿ã‚ã‚Œã¦ã„ã‚‹å‘¨çŸ¥ã®æœ€é©åŒ–æŠ€æ³•ã®ã†ã¡ã®ä¸€å¤‰ç¨®ã§ã‚ã‚‹ã€‚
æ‰‹ç¶šãå‘¼ã³å‡ºã—ã§çµ‚ã‚ã‚‹æ‰‹ç¶šãã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹éš›ã«ã¯ã€ãã®å‘¼ã³å‡ºã—ã‚’ã€å‘¼ã³å‡ºã•ã‚ŒãŸæ‰‹ç¶šãã®ã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒã‚¤ãƒ³ãƒˆã¸ã®ã‚¸ãƒ£ãƒ³ãƒ—ã§ç½®ãæ›ãˆã‚‰ã‚Œã‚‹ã€‚
æœ¬ç¯€ã§ç§ãŸã¡ãŒè¡Œã£ãŸã‚ˆã†ã«ã€ã“ã®æˆ¦ç•¥ã‚’ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã®ä¸­ã«çµ„ã¿è¾¼ã‚€ã“ã¨ã§ã€è¨€èªã®å…¨ä½“ã‚’é€šã˜ã¦ä¸€æ§˜ã«æœ€é©åŒ–ãŒã‚‚ãŸã‚‰ã•ã‚Œã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_778" href="#call_footnote_Temp_778"><sup><small>27</small></sup></a> We can define <tt>no-more-exps?</tt> as follows:</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_778"><sup><small>27</small></sup></a>
<tt>no-more-exps?</tt> ã‚’ä»¥ä¸‹ã®ã‚ˆã†ã«å®šç¾©ã§ãã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_6098"></a>(define (no-more-exps? seq) (null? seq))
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_781" href="#call_footnote_Temp_781"><sup><small>28</small></sup></a> This isn't really cheating.  In an actual
implementation built from scratch, we would use our explicit-control
evaluator to interpret a Scheme program that performs source-level
transformations like <tt>cond-&gt;if</tt> in a syntax phase that runs before
execution.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_781"><sup><small>28</small></sup></a>
ã“ã‚Œã¯ã€æœ¬å½“ã¯ã€ã”ã¾ã‹ã—ã‚’ã™ã‚‹ã“ã¨ã§ã¯ãªã„ã€‚
ä½•ã‚‚ãªã„ã¨ã“ã‚ã‹ã‚‰æ§‹ç¯‰ã•ã‚Œã‚‹å®Ÿéš›ã®å®Ÿè£…ã«ãŠã„ã¦ã€ç§ãŸã¡ã¯ã€è‡ªåˆ†ãŸã¡ã®æ˜ç¤ºçš„åˆ¶å¾¡æ–¹å¼ã®è©•ä¾¡å™¨ã‚’ä½¿ã£ã¦ã€å®Ÿè¡Œã®å‰ã«å‹•ãæ–‡æ³•æ®µéšã«ãŠã„ã¦ <tt>cond-&gt;if</tt> ã®ã‚ˆã†ãªã‚½ãƒ¼ã‚¹ãƒ»ãƒ¬ãƒ™ãƒ«ã®å¤‰æ›ã‚’è¡Œã† Scheme ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ã€è§£é‡ˆã™ã‚‹ã ã‚ã†ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_784" href="#call_footnote_Temp_784"><sup><small>29</small></sup></a> We assume here that <tt>read</tt> and the
various printing operations are
available as primitive machine operations, which is useful for our
simulation, but completely unrealistic in practice.  These
are actually extremely complex operations.  In practice, they would be
implemented using low-level input-output operations
such as transferring single characters to and from a device.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_784"><sup><small>29</small></sup></a>
</p>

<p class="orig" lang="en">
To support the <tt>get-global-environment</tt> operation we define</p>

<p class="trans" lang="ja">
</p>

<p class="lisp"><a name="%_idx_6138"></a>(define the-global-environment (setup-environment))

<a name="%_idx_6140"></a>(define (get-global-environment)
  the-global-environment)
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_785" href="#call_footnote_Temp_785"><sup><small>30</small></sup></a> There are other
errors that we would like the interpreter to handle, but these are not
so simple.  See exercise <a href="#%_thm_5.30">5.30</a>.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_785"><sup><small>30</small></sup></a>
</p>

<p class="orig" lang="en"><a name="footnote_Temp_786" href="#call_footnote_Temp_786"><sup><small>31</small></sup></a> We
could perform the stack initialization only after errors, but doing it in
the driver loop will be convenient for monitoring the evaluator's
performance, as described below.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_786"><sup><small>31</small></sup></a>
</p>

<p class="orig" lang="en"><a name="footnote_Temp_793" href="#call_footnote_Temp_793"><sup><small>32</small></sup></a> Regrettably, this is the normal state of affairs in
<a name="%_idx_6186"></a>conventional compiler-based language systems such as C.  
<a name="%_idx_6188"></a><a name="%_idx_6190"></a><a name="%_idx_6192"></a>In UNIX<sup> <em>T</em><em>M</em></sup> the system ``dumps core,'' and in 
DOS/Windows<sup> <em>T</em><em>M</em></sup> it becomes catatonic.
The Macintosh<sup> <em>T</em><em>M</em></sup> displays a
picture of an exploding bomb and offers you the opportunity to reboot
the computer -- if you're lucky.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_793"><sup><small>32</small></sup></a>
</p>

</div>
</body>
</html>
