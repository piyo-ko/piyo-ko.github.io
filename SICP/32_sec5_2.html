<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="sicp.css" type="text/css">
<base target="_top">
<title>SICP私訳: 5.2 レジスタ・マシンのシミュレータ</title>
<link rel="canonical" href="https://piyo-ko.github.io/SICP/32_sec5_2.html" />
</head>
<body>

<div class="idx-bar">
<nav>
<a href="https://twitter.com/share" class="twitter-share-button" data-lang="ja">ツイート</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
<span class="status">推敲待ち</span>
[
<a href="00_cover.html">先頭へ</a> |
<a href="31_sec5_1.html">前へ</a> |
<a href="33_sec5_3.html">次へ</a> |
<a href="04_toc.html#%_toc_start">目次</a> |
<a href="38_index.html#%_index_start">索引</a>
] [<a href="99_about.html">この対訳版について</a> | <a href="../index.html">ホーム</a>]
[
§<a href="#%_sec_5.2">5.2</a>
📝<a href="#%_thm_5.7">5.7</a>
§<a href="#%_sec_5.2.1">5.2.1</a>
📚<a href="#%_sec_Temp_724">&hellip;</a>
📚<a href="#%_sec_Temp_725">&hellip;</a>
📚<a href="#%_sec_Temp_726">&hellip;</a>
🎨<a href="#%_fig_5.13">5.13</a>
§<a href="#%_sec_5.2.2">5.2.2</a>
📝<a href="#%_thm_5.8">5.8</a>
§<a href="#%_sec_5.2.3">5.2.3</a>
📚<a href="#%_sec_Temp_729">&hellip;</a>
📚<a href="#%_sec_Temp_730">&hellip;</a>
📚<a href="#%_sec_Temp_731">&hellip;</a>
📚<a href="#%_sec_Temp_732">&hellip;</a>
📝<a href="#%_thm_5.9">5.9</a>
📝<a href="#%_thm_5.10">5.10</a>
📝<a href="#%_thm_5.11">5.11</a>
📝<a href="#%_thm_5.12">5.12</a>
📝<a href="#%_thm_5.13">5.13</a>
§<a href="#%_sec_5.2.4">5.2.4</a>
📝<a href="#%_thm_5.14">5.14</a>
📝<a href="#%_thm_5.15">5.15</a>
📝<a href="#%_thm_5.16">5.16</a>
📝<a href="#%_thm_5.17">5.17</a>
📝<a href="#%_thm_5.18">5.18</a>
📝<a href="#%_thm_5.19">5.19</a>
<a href="#footnotes">脚注</a>
]</nav>
</div>

<div class="main-txt">


<a name="%_sec_5.2"></a>
<h2 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_5.2">5.2  A Register-Machine Simulator</a></h2>
<h2 class="trans" lang="ja">5.2 レジスタ・マシンのシミュレータ</h2>

<p class="orig" lang="en">
<a name="%_idx_5622"></a><a name="%_idx_5624"></a>
In order to gain a good understanding of the design of register
machines, we must test the machines we design to see if they perform
as expected.  One way to test a design is to hand-simulate the
operation of the controller, as in exercise <a href="31_sec5_1.html#%_thm_5.5">5.5</a>.  But this is
extremely tedious for all but the simplest machines.  In this section
we construct a simulator for machines described in the
register-machine language.  The simulator is a Scheme program with
four interface procedures.  The first uses a description of a register
machine to construct a model of the machine (a data structure whose
parts correspond to the parts of the machine to be simulated), and the
other three allow us to simulate the machine by manipulating the
model:</p>

<p class="trans" lang="ja">
レジスタ・マシンの設計について良い理解を得るためには、自分の設計するマシンを検査して、そのマシンが期待通りに機能するかどうかを見なくてはならない。
設計を検査するための一つの方法は、練習問題<a href="31_sec5_1.html#%_thm_5.5">5.5</a>でのように、コントローラの演算を手作業でシミュレートすることである。
しかし、これは、最も単純なマシン以外のすべてにとって、極めてうんざりすることだ。
本節では、レジスタ・マシン言語で記述されたマシンについての、シミュレータを構築する。
そのシミュレータは、四つのインタフェイス手続きをともなう Scheme プログラムだ。
第一のものは、レジスタ・マシンの記述を使って、そのマシンのモデル (その部品が、シミュレートすべきマシンの部品に対応するような、データ構造である) を構築する。残りの三つは、そのモデルを操作することによって私たちがそのマシンをシミュレートできるようにしてくれる。
</p>

<dl class="orig" lang="en">
<dt><a name="%_idx_5626"></a><tt>(make-machine &lt;<em>register-names</em>&gt; &lt;<em>operations</em>&gt; &lt;<em>controller</em>&gt;)</tt></dt>
<dd>
constructs and returns a model of the machine with the given
registers, operations, and controller.</dd>

<dt><a name="%_idx_5628"></a><tt>(set-register-contents! &lt;<em>machine-model</em>&gt; &lt;<em>register-name</em>&gt; &lt;<em>value</em>&gt;)</tt>
</dt>
<dd>stores a value in a simulated register in the given
machine.</dd>

<dt><a name="%_idx_5630"></a><tt>(get-register-contents &lt;<em>machine-model</em>&gt; &lt;<em>register-name</em>&gt;)</tt>
</dt>
<dd>returns the contents of a simulated register in the given machine.</dd>

<dt><a name="%_idx_5632"></a><tt>(start &lt;<em>machine-model</em>&gt;)</tt>
</dt>
<dd>simulates the execution of the given
machine, starting from the beginning of the controller sequence and
stopping when it reaches the end of the sequence.</dd>
</dl>

<dl class="trans" lang="ja">
<dt><tt>(make-machine &lt;<em class="en">register-names</em>&gt; &lt;<em class="en">operations</em>&gt; &lt;<em class="en">controller</em>&gt;)</tt></dt>
<dd>は、与えられたレジスタと演算とコントローラをともなうマシンの、モデルを構築して返す。</dd>

<dt><tt>(set-register-contents! &lt;<em class="en">machine-model</em>&gt; &lt;<em class="en">register-name</em>&gt; &lt;<em class="en">value</em>&gt;)</tt></dt>
<dd>は、与えられたマシン内のシミュレートされているレジスタに、値を格納する。</dd>

<dt><tt>(get-register-contents &lt;<em class="en">machine-model</em>&gt; &lt;<em class="en">register-name</em>&gt;)</tt></dt>
<dd>は、与えられたマシン内のシミュレートされているレジスタの中身を返す。</dd>

<dt><tt>(start &lt;<em class="en">machine-model</em>&gt;)</tt></dt>
<dd>は、与えられたマシンの実行をシミュレートし、その際、コントローラ列の最初から始めて、列の終わりに達したら停止する。</dd>

</dl>

<p class="orig" lang="en">
As an example of how these procedures are used, we can define
<tt>gcd-machine</tt> to be a model of the GCD machine
of section <a href="31_sec5_1.html#%_sec_5.1.1">5.1.1</a> as follows:</p>

<p class="trans" lang="ja">
これらの手続きがどのように使われるのか、という例として、私たちは、<a href="31_sec5_1.html#%_sec_5.1.1">5.1.1</a>節の GCD マシンのモデルとなるように、<tt>gcd-machine</tt> を以下のとおり定義できる。
</p>

<p class="lisp"><a name="%_idx_5634"></a>(define gcd-machine
  (make-machine
   '(a b t)
   (list (list 'rem remainder) (list '= =))
   '(test-b
       (test (op =) (reg b) (const 0))
       (branch (label gcd-done))
       (assign t (op rem) (reg a) (reg b))
       (assign a (reg b))
       (assign b (reg t))
       (goto (label test-b))
     gcd-done)))
</p>

<p class="orig" lang="en">The first argument to <tt>make-machine</tt> is a list of register names.
The next argument is a table (a list of two-element lists) that pairs
each operation name with a Scheme procedure that implements the operation
(that is, produces the same output value given the same input values).
The last argument specifies the controller as a list of labels and
machine instructions, as in section <a href="31_sec5_1.html#%_sec_5.1">5.1</a>.</p>

<p class="trans" lang="ja">
<tt>make-machine</tt> に対する最初の引数は、レジスタ名のリストである。
次の引数は、各演算名を、当該演算を実装する (つまり、同じ入力値を与えられると同じ出力値を生み出す) Scheme 手続きと対にするような、<ruby><rb>表</rb><rp> (</rp><rt>テーブル</rt><rp>) </rp></ruby> (2要素リストのリスト) である。
最後の引数は、<a href="31_sec5_1.html#%_sec_5.1">5.1</a>節でのように、ラベルとマシン命令とのリストとして、コントローラの明細を規定する。
</p>

<p class="orig" lang="en">
To compute GCDs with this machine, we set the
input registers, start the machine, and examine the result when the
simulation terminates:
</p>

<p class="trans" lang="ja">
このマシンで GCD を計算するには、入力レジスタを設定し、マシンを始動させ、シミュレーションが終了したときに結果を検討する。
</p>

<p class="lisp">(set-register-contents! gcd-machine 'a 206)
<i>done</i>
(set-register-contents! gcd-machine 'b 40)
<i>done</i>
(start gcd-machine)
<i>done</i>
(get-register-contents gcd-machine 'a)
<i>2</i>
</p>

<p class="orig" lang="en">This computation will run much more slowly than a <tt>gcd</tt> procedure
written in Scheme, because we will simulate low-level machine
instructions, such as <tt>assign</tt>, by much more complex operations.</p>

<p class="trans" lang="ja">
この計算は、Scheme で書かれた <tt>gcd</tt> 手続きよりも、ずっとゆっくり動作するだろう。なぜなら、 <tt>assign</tt> などの低水準のマシン命令を、もっとずっと複雑な演算によってシミュレートすることになるからだ。
</p>

<p class="orig" lang="en">
<a name="%_thm_5.7"></a>
<b>Exercise 5.7.</b>  Use the simulator to test the machines you designed in
exercise <a href="31_sec5_1.html#%_thm_5.4">5.4</a>.
</p>

<p class="trans" lang="ja">
<b>練習問題5.7.</b> 君が<a href="31_sec5_1.html#%_thm_5.4">5.4</a>節で設計したマシンを、シミュレータを用いて検査せよ。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_5.2.1"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_5.2.1">5.2.1  The Machine Model</a></h3>
<h3 class="trans" lang="ja">5.2.1 マシン・モデル</h3>


<p class="orig" lang="en">The machine model generated by <tt>make-machine</tt> is represented as a
procedure with local state using the message-passing techniques
developed in chapter 3.  To build this model, <tt>make-machine</tt>
begins by calling the procedure <tt>make-new-machine</tt> to construct
the parts of the machine model that are common to all register
machines.  This basic machine model constructed by <tt>make-new-machine</tt> is essentially a container for some registers and a
stack, together with an execution mechanism that processes the controller
instructions one by one.</p>

<p class="trans" lang="ja">
<tt>make-machine</tt> により生成されるマシン・モデルは、3章で開発したメッセージ<ruby><rb>渡し</rb><rp> (</rp><rt>パッシング</rt><rp>) </rp></ruby>の技法を用いる、局所状態つきの手続きとして、表現される。
このモデルを構築するために、<tt>make-machine</tt> は、<tt>make-new-machine</tt> という手続きを呼び出して、すべてのレジスタ・マシンに共通なマシン・モデルの部品を構築することから始める。
<tt>make-new-machine</tt> により構築される、この基本的マシン・モデルは、本質的には、コントローラ命令を一つずつ処理する実行機構を備えた、いくつかのレジスタと一つのスタックのための<ruby><rb>容れ物</rb><rp> (</rp><rt>コンテナ</rt><rp>) </rp></ruby>である。
</p>

<p class="orig" lang="en">
<tt>Make-machine</tt> then extends this basic model (by sending it
messages) to include the registers, operations, and controller of the
particular machine being defined.  First it allocates a register in
the new machine for each of the supplied register names and installs
the designated operations in the machine.  Then it uses an <a name="%_idx_5636"></a><em>assembler</em> (described below in section <a href="#%_sec_5.2.2">5.2.2</a>) to
transform the controller list into instructions for the new machine
and installs these as the machine's instruction sequence.  <tt>Make-machine</tt> returns as its value the modified machine model.</p>

<p class="trans" lang="ja">
<tt>make-machine</tt> は、それから、レジスタや、演算や、定義中の特定のマシンのコントローラを含むように、(この基本的モデルにメッセージを送ることによって) この基本的モデルを拡張する。
まず、与えられたレジスタ名の各々に対して、新規マシン内のレジスタを割り当て、指定された演算をマシンにインストールする。
それから、<em>アセンブラ</em> (以下の<a href="#%_sec_5.2.2">5.2.2</a>節において説明する) を用いて、コントローラ・リストを新規マシン用の命令群へと変換し、これらの命令を当該マシンの命令列としてインストールする。
<tt>make-machine</tt> は、その値として、改変されたマシン・モデルを返す。
</p>

<p class="lisp"><a name="%_idx_5638"></a>(define (make-machine register-names ops controller-text)
  (let ((machine (make-new-machine)))
    (for-each (lambda (register-name)
                ((machine 'allocate-register) register-name))
              register-names)
    ((machine 'install-operations) ops)    
    ((machine 'install-instruction-sequence)
     (assemble controller-text machine))
    machine))
</p>

<a name="%_sec_Temp_724"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_724">Registers</a></h4>
<h4 class="trans" lang="ja">レジスタ</h4>

<p class="orig" lang="en">
<a name="%_idx_5640"></a>
We will represent a register as a procedure with local state, as in
chapter 3.  The procedure <tt>make-register</tt> creates a register that
holds a value that can be accessed or changed:</p>

<p class="trans" lang="ja">
3章でのような局所状態つきの手続きとして、レジスタを表そう。
<tt>make-register</tt> という手続きは、アクセスしたり、あるいは変更したりすることが可能な値を保持するレジスタを、作成する。
</p>

<p class="lisp"><a name="%_idx_5642"></a>(define (make-register name)
  (let ((contents '*unassigned*))
    (define (dispatch message)
      (cond ((eq? message 'get) contents)
            ((eq? message 'set)
             (lambda (value) (set! contents value)))
            (else
             (error &quot;Unknown request -- REGISTER&quot; message))))
    dispatch))
</p>

<p class="orig" lang="en">The following procedures are used to access registers:</p>

<p class="trans" lang="ja">
レジスタにアクセスするのには、以下の手続きが使われる。
</p>

<p class="lisp"><a name="%_idx_5644"></a>(define (get-contents register)
  (register 'get))

<a name="%_idx_5646"></a>(define (set-contents! register value)
  ((register 'set) value))
</p>

<a name="%_sec_Temp_725"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_725">The stack</a></h4>
<h4 class="trans" lang="ja">スタック</h4>

<p class="orig" lang="en">
<a name="%_idx_5648"></a>
We can also represent a stack as a procedure with local state.  The
procedure <tt>make-stack</tt> creates a stack whose local state consists
of a list of the items on the stack.  A stack accepts requests to <tt>push</tt> an item onto the stack, to <tt>pop</tt> the top item off the stack
and return it, and to <tt>initialize</tt> the stack to empty.</p>

<p class="trans" lang="ja">
スタックも、局所状態つきの手続きとして表せる。
<tt>make-stack</tt> という手続きは、局所状態が当該スタック上の<ruby><rb>項目</rb><rp> (</rp><rt>アイテム</rt><rp>) </rp></ruby>のリストからできているようなスタックを、作成する。
スタックは、当該スタック上に項目を <ruby><rb><tt>push</tt> する</rb><rp> (</rp><rt>つむ</rt><rp>) </rp></ruby>よう求める要求や、当該スタックから先頭項目を <ruby><rb><tt>pop</tt> し</rb><rp> (</rp><rt>とりだし</rt><rp>) </rp></ruby>てその先頭項目を返すよう求める要求や、スタックを空に <ruby><rb><tt>initialize</tt></rb><rp> (</rp><rt>初期化</rt><rp>) </rp></ruby> するよう求める要求を、受け入れる。
</p>

<p class="lisp"><a name="%_idx_5650"></a>(define (make-stack)
  (let ((s '()))
    (define (push x)
      (set! s (cons x s)))
    (define (pop)
      (if (null? s)
          (error &quot;Empty stack -- POP&quot;)
          (let ((top (car s)))
            (set! s (cdr s))
            top)))
    (define (initialize)
      (set! s '())
      'done)
    (define (dispatch message)
      (cond ((eq? message 'push) push)
            ((eq? message 'pop) (pop))
            ((eq? message 'initialize) (initialize))
            (else (error &quot;Unknown request -- STACK&quot;
                         message))))
    dispatch))
</p>

<p class="orig" lang="en">The following procedures are used to access stacks:</p>

<p class="trans" lang="ja">
スタックにアクセスするのには、以下の手続きが使われる。
</p>

<p class="lisp"><a name="%_idx_5652"></a>(define (pop stack)
  (stack 'pop))

<a name="%_idx_5654"></a>(define (push stack value)
  ((stack 'push) value))
</p>

<a name="%_sec_Temp_726"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_726">The basic machine</a></h4>
<h4 class="trans" lang="ja">基本マシン</h4>

<p class="orig" lang="en">
The <tt>make-new-machine</tt> procedure, shown in
figure <a href="#%_fig_5.13">5.13</a>, constructs an object whose local
state consists of a stack, an initially empty instruction sequence, a
list of operations that initially contains an operation to <a name="%_idx_5656"></a>initialize
the stack, and a <a name="%_idx_5658"></a><em>register table</em> that initially contains two
<a name="%_idx_5660"></a><a name="%_idx_5662"></a>registers, named <tt>flag</tt> and <tt>pc</tt> <a name="%_idx_5664"></a>(for ``program counter'').
The internal procedure <tt>allocate-register</tt> adds new entries to the
register table, and the internal procedure <tt>lookup-register</tt> looks
up registers in the table.</p>

<p class="trans" lang="ja">
スタックと、最初は空の命令列と、スタックを初期化する演算を最初は含んでいる演算リストと、<tt>flag</tt> および <tt>pc</tt> (「プログラム・カウンタ」の意) という名の二つのレジスタを最初は含んでいる<em>レジスタ表</em>と、からなる局所状態のオブジェクトを、図<a href="#%_fig_5.13">5.13</a>に示す <tt>make-new-machine</tt> の手続きは構築する。
<tt>allocate-register</tt> という内部手続きは、レジスタ表に新たなエントリを追加し、<tt>lookup-register</tt> という内部手続きは、その表でレジスタを調べる。
</p>

<p class="orig" lang="en">
The <tt>flag</tt> register is used to control branching in the simulated
machine.  <tt>Test</tt> instructions set the contents of <tt>flag</tt> to
the result of the test (true or false).  <tt>Branch</tt> instructions
decide whether or not to branch by examining the contents of <tt>flag</tt>.</p>

<p class="trans" lang="ja">
<tt>flag</tt> レジスタは、シミュレートされるマシンにおける分岐を制御するのに使われる。
<tt>test</tt> 命令は、<tt>flag</tt> の中身を、当該<ruby><rb>検査</rb><rp> (</rp><rt>テスト</rt><rp>) </rp></ruby>の結果 (真または偽) に設定する。
<tt>branch</tt> 命令は、<tt>flag</tt> の中身を調べることによって、分岐すべきかどうかを決定する。
</p>

<p class="orig" lang="en">
The <tt>pc</tt> register determines the sequencing of instructions as
the machine runs.  This sequencing is implemented by the internal
procedure <tt>execute</tt>.
In the simulation model, each machine instruction is a data structure
that includes a procedure of no arguments, called the <a name="%_idx_5666"></a><a name="%_idx_5668"></a><em>instruction
execution procedure</em>, such that calling this procedure simulates
executing the instruction.  As the simulation runs, <tt>pc</tt> points to
the place in the instruction sequence beginning with the next
instruction to be executed.  <a name="%_idx_5670"></a><tt>Execute</tt> gets that instruction,
executes it by calling the instruction execution procedure, and
repeats this cycle until there are no more instructions to execute
(i.e., until <tt>pc</tt> points to the end of the instruction sequence).</p>

<p class="trans" lang="ja">
<tt>pc</tt> レジスタは、マシンが動作する際、命令の排列を定める。
この排列は、<tt>execute</tt> という内部手続きにより実装される。
シミュレーション・モデルにおいて、各マシン命令は、引数なしの手続き——<em>命令実行手続き</em>と呼ばれる——を含むデータ構造であって、その結果、この手続きの呼び出しにより、命令の実行がシミュレートされる。
シミュレーションが動作する間、<tt>pc</tt> は、実行すべき次の命令から始まる命令列の中の場所を指す。
<tt>execute</tt> は、その命令を取得して、命令実行手続きを呼び出すことで当該命令を実行し、実行すべき命令がもうなくなるまで (つまり、<tt>pc</tt> が命令列の最後を指すまで) この一巡りを繰り返す。
</p>

<figure>
<a name="%_fig_5.13"></a>
<p class="infig-lisp"><a name="%_idx_5672"></a>(define (make-new-machine)
  (let ((pc (make-register 'pc))
        (flag (make-register 'flag))
        (stack (make-stack))
        (the-instruction-sequence '()))
    (let ((the-ops
           (list (list 'initialize-stack
                       (lambda () (stack 'initialize)))))
          (register-table
           (list (list 'pc pc) (list 'flag flag))))
      (define (allocate-register name)
        (if (assoc name register-table)
            (error &quot;Multiply defined register: &quot; name)
            (set! register-table
                  (cons (list name (make-register name))
                        register-table)))
        'register-allocated)
      (define (lookup-register name)
        (let ((val (assoc name register-table)))
          (if val
              (cadr val)
              (error &quot;Unknown register:&quot; name))))
      (define (execute)
        (let ((insts (get-contents pc)))
          (if (null? insts)
              'done
              (begin
                ((instruction-execution-proc (car insts)))
                (execute)))))
      (define (dispatch message)
        (cond ((eq? message 'start)
               (set-contents! pc the-instruction-sequence)
               (execute))
              ((eq? message 'install-instruction-sequence)
               (lambda (seq) (set! the-instruction-sequence seq)))
              ((eq? message 'allocate-register) allocate-register)
              ((eq? message 'get-register) lookup-register)
              ((eq? message 'install-operations)
               (lambda (ops) (set! the-ops (append the-ops ops))))
              ((eq? message 'stack) stack)
              ((eq? message 'operations) the-ops)
              (else (error &quot;Unknown request -- MACHINE&quot; message))))
      dispatch)))
</p>
<figcaption class="orig" lang="en"><b>Figure 5.13:</b>  The <tt>make-new-machine</tt> procedure, which implements
the basic machine model.</figcaption>
<figcaption class="trans" lang="ja"><b>図5.13.:</b> <tt>make-new-machine</tt> 手続き——基本的マシン・モデルを実装するもの</figcaption>
</figure>

<p class="orig" lang="en">
As part of its operation, each instruction execution procedure
modifies <tt>pc</tt> to indicate the next instruction to be executed.
<tt>Branch</tt> and <tt>goto</tt> instructions change <tt>pc</tt> to point to
the new destination.  All other instructions simply advance <tt>pc</tt>,
making it point to the next instruction in the sequence.  Observe that
each call to <tt>execute</tt> calls <tt>execute</tt> again, but this does
not produce an infinite loop because running the instruction execution
procedure changes the contents of <tt>pc</tt>.</p>

<p class="trans" lang="ja">
自身の演算の一部として、各命令実行手続きは、実行すべき次の命令を示すように <tt>pc</tt> を変更する。
<tt>branch</tt> 命令と <tt>goto</tt> 命令は、新たな行き先を示すように <tt>pc</tt> を変更する。
他のすべての命令は、単純に <tt>pc</tt> を進め、<tt>pc</tt> に列の中の次の命令を 示させる。
<tt>execute</tt> に対する各呼び出しが再度 <tt>execute</tt> を呼び出すけれども、命令実行手続きが <tt>pc</tt> の中身を変更するので、この呼び出しは無限ループを生み出したりはしない、ということに気づいてほしい。
</p>

<p class="orig" lang="en">
<tt>Make-new-machine</tt> returns a
<tt>dispatch</tt> procedure that implements message-passing
access to the internal state.  Notice that starting the machine is
accomplished by setting <tt>pc</tt> to the beginning of the instruction
sequence and calling <tt>execute</tt>.</p>

<p class="trans" lang="ja">
<tt>make-new-machine</tt> は、メッセージ渡しによる内部状態へのアクセスを実装している <tt>dispatch</tt> 手続きを返す。
<tt>pc</tt> を命令列の先頭に設定して <tt>execute</tt> を呼び出すことによって、マシンを始動させることが達成されるのだ、ということに注意してほしい。
</p>

<p class="orig" lang="en">
For convenience, we provide an alternate procedural interface to a
machine's <tt>start</tt> operation,
as well as procedures to set and examine register contents,
as specified at the beginning of section <a href="#%_sec_5.2">5.2</a>:</p>

<p class="trans" lang="ja">
<a href="#%_sec_5.2">5.2</a>節の先頭で規定されているような、レジスタの中身を設定したり調べたりする手続きだけでなく、マシンの <tt>start</tt> 演算に対しても、便宜上、別の手続き的インタフェイスを提供する。
</p>

<p class="lisp"><a name="%_idx_5674"></a>(define (start machine)
  (machine 'start))
<a name="%_idx_5676"></a>(define (get-register-contents machine register-name)
  (get-contents (get-register machine register-name)))
<a name="%_idx_5678"></a>(define (set-register-contents! machine register-name value)
  (set-contents! (get-register machine register-name) value)
  'done)
</p>

<p class="orig" lang="en">These procedures (and many procedures in sections <a href="#%_sec_5.2.2">5.2.2</a>
and <a href="#%_sec_5.2.3">5.2.3</a>) use the following to look up the register with a
given name in a given machine:
</p>


<p class="trans" lang="ja">
これらの手続き (および、<a href="#%_sec_5.2.2">5.2.2</a>節と<a href="#%_sec_5.2.3">5.2.3</a>節の多くの手続き) は、与えられたマシンにおける、与えられた名前のレジスタを調べるために、以下のものを使う。
</p>

<p class="lisp"><a name="%_idx_5680"></a>(define (get-register machine reg-name)
  ((machine 'get-register) reg-name))
</p>

<a name="%_sec_5.2.2"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_5.2.2">5.2.2  The Assembler</a></h3>
<h3 class="trans" lang="ja">5.2.2 アセンブラ</h3>

<p class="orig" lang="en"><a name="%_idx_5682"></a>
The assembler transforms the sequence of controller expressions for a
machine into a corresponding list of machine instructions, each with
its execution procedure.  Overall, the assembler is much like the
evaluators we studied in chapter 4 -- there is an input language (in
this case, the register-machine language) and we must perform an
appropriate action for each type of expression in the language.</p>

<p class="trans" lang="ja">
アセンブラは、あるマシンについての一連のコントローラ式を、対応するマシン命令のリスト——マシン命令の各々は自分の実行手続きをともなっている——に変換する。
全体として、アセンブラは、4章で研究した評価器にとても似ている——つまり、入力言語 (目下の場合はレジスタ・マシン言語) があり、当該言語における式の各種類について適切な動作を実行せねばならないのだ。
</p>

<p class="orig" lang="en">
<a name="%_idx_5684"></a>The technique of producing an execution procedure for each instruction
is just what we used in section <a href="26_sec4_1.html#%_sec_4.1.7">4.1.7</a> to speed
up the evaluator by separating analysis from runtime execution.  As we
saw in chapter 4, much useful analysis of Scheme expressions could be
performed without knowing the actual values of variables.  Here,
analogously, much useful analysis of register-machine-language
expressions can be performed without knowing the actual contents of
machine registers.  For example, we can replace references to
registers by pointers to the register objects, and we can
replace references to labels by pointers to the place in the
instruction sequence that the label designates.</p>

<p class="trans" lang="ja">
各命令について実行手続きを生み出す技法は、まさにちょうど、実行時の実行から解析を分離することによって評価器を高速化するために<a href="26_sec4_1.html#%_sec_4.1.7">4.1.7</a>節で使ったものである。
4章で見たとおり、変数の実際の値を知ることなしに、Scheme式についての多くの有用な解析を実行し得る。
ここでは、似たようにして、マシン・レジスタの実際の中身を知ることなしに、レジスタ・マシン言語の式についての多くの有用な解析を実行できる。
たとえば、レジスタへの参照を、レジスタ・オブジェクトへのポインタで置き換えられるし、ラベルへの参照を、そのラベルが指定する、命令列中の場所へのポインタで置き換えられる。
</p>

<p class="orig" lang="en">
Before it can generate the instruction execution procedures, the
assembler must know what all the labels refer to, so it begins by
scanning the controller text to separate the labels from the
instructions.  As it scans the text, it constructs both a list of
instructions and a table that associates each label with a pointer
into that list.  Then the assembler augments the instruction list by
inserting the execution procedure for each instruction.</p>

<p class="trans" lang="ja">
命令実行手続きを生成するまでに、アセンブラは、すべてのラベルが何を参照しているのかを知らねばならず、それゆえに、アセンブラは、命令からラベルを分離するためにコントローラ・テキストを走査することから始める。
アセンブラは、テキストを走査するにつれて、命令のリストと、各ラベルをそのリスト内へのポインタと関連づける表の、双方を構築する。
それから、アセンブラは、各命令について実行手続きを挿入することによって命令リストを拡張する。
</p>

<p class="orig" lang="en">
The <tt>assemble</tt> procedure is the main entry to the assembler.
It takes the controller text and the machine model as arguments and
returns the instruction sequence to be stored in the model.
<tt>Assemble</tt> calls <tt>extract-labels</tt> to build the initial instruction list
and label table from the supplied controller text.  The second argument
to <tt>extract-labels</tt> is a procedure to be called to process these results:
This procedure uses <tt>update-insts!</tt> to generate the instruction execution
procedures and insert them into the instruction list,
and returns the modified list.
</p>

<p class="trans" lang="ja">
<tt>assemble</tt> 手続きは、アセンブラへの主たる入り口である。
これは、コントローラ・テキストとマシン・モデルを引数としてとり、そのモデル内に格納すべき命令列を返す。
<tt>assemble</tt> は、供給されたコントローラ・テキストから初期命令リストとラベル表を構築するために、<tt>extract-labels</tt> を呼び出す。
<tt>extract-labels</tt> への第2引数は、これらの結果を処理するために呼ばれるべき手続きである。
この手続きは、<tt>update-insts!</tt> を用いて、命令実行手続きを生成してそれらを命令リストに挿入し、変更したリストを返す。
</p>

<p class="lisp"><a name="%_idx_5686"></a>(define (assemble controller-text machine)
  (extract-labels controller-text
    (lambda (insts labels)
      (update-insts! insts labels machine)
      insts)))
</p>

<p class="orig" lang="en">
<tt>Extract-labels</tt>
takes as arguments a list <tt>text</tt> (the sequence of controller
instruction expressions) and a <tt>receive</tt> procedure.  <tt>Receive</tt>
will be called with two values: (1) a list <tt>insts</tt> of instruction
data structures, each containing an instruction from <tt>text</tt>; and
(2) a table called <tt>labels</tt>, which associates each label from <tt>text</tt>
with the position in the list <tt>insts</tt> that the label designates.</p>

<p class="trans" lang="ja">
<tt>extract-labels</tt> は、引数として、<tt>text</tt> というリスト (コントローラ命令式の列) と <tt>receive</tt> という手続きをとる。
<tt>receive</tt> は、二つの値——つまり、
(1) <tt>insts</tt> という、命令データ構造のリストであって、各命令データ構造が <tt>text</tt> からの命令を含んでいるものと、
(2) <tt>labels</tt> と呼ばれる表であって、<tt>text</tt> からの各ラベルを、<tt>insts</tt> というリスト内での当該ラベルが指定する位置と、関連づけているもの
——とともに、呼び出されるだろう。
</p>

<p class="lisp"><a name="%_idx_5688"></a>(define (extract-labels text receive)
  (if (null? text)
      (receive '() '())
      (extract-labels (cdr text)
       (lambda (insts labels)
         (let ((next-inst (car text)))
           (if (symbol? next-inst)
               (receive insts
                        (cons (make-label-entry next-inst
                                                insts)
                              labels))
               (receive (cons (make-instruction next-inst)
                              insts)
                        labels)))))))
</p>

<p class="orig" lang="en"><tt>Extract-labels</tt> works by sequentially scanning the elements of
the <tt>text</tt> and accumulating the <tt>insts</tt> and the <tt>labels</tt>.
If an element is a symbol (and thus a label) an appropriate entry is
added to the <tt>labels</tt> table.  Otherwise the element is accumulated
onto the <tt>insts</tt> list.<a name="call_footnote_Temp_727" href="#footnote_Temp_727"><sup><small>4</small></sup></a></p>

<p class="trans" lang="ja">
<tt>extract-labels</tt> は、<tt>text</tt> の要素を順に走査して <tt>insts</tt> と <tt>labels</tt> を蓄積することによって、機能する。
もし、要素が記号である (したがってラベルである) ならば、適宜のエントリが <tt>labels</tt> の表に追加される。
それ以外の場合は、その要素が <tt>insts</tt> のリスト上に蓄積される<a href="#footnote_Temp_727"><sup><small>4</small></sup></a>。
</p>

<p class="orig" lang="en">
<tt>Update-insts!</tt> modifies the instruction list, which initially
contains only the text of the instructions, to include the
corresponding execution procedures:</p>

<p class="trans" lang="ja">
<tt>update-insts!</tt> は、命令リスト——最初は命令のテキストのみを含む——を、対応する実行手続きを含むように変更する。
</p>

<p class="lisp"><a name="%_idx_5702"></a>(define (update-insts! insts labels machine)
  (let ((pc (get-register machine 'pc))
        (flag (get-register machine 'flag))
        (stack (machine 'stack))
        (ops (machine 'operations)))
    (for-each
     (lambda (inst)
       (set-instruction-execution-proc! 
        inst
        (make-execution-procedure
         (instruction-text inst) labels machine
         pc flag stack ops)))
     insts)))
</p>

<p class="orig" lang="en">
The machine instruction data structure simply pairs the
instruction text with the corresponding execution procedure.
The execution procedure is not yet available when <tt>extract-labels</tt>
constructs the instruction, and is inserted later by <tt>update-insts!</tt>.
</p>

<p class="trans" lang="ja">
マシン命令データ構造は、単純に、命令テキストを、対応する実行手続きと対にしている。
実行手続きは、<tt>extract-labels</tt> が命令を構築するときにはまだ利用可能ではなく、後で <tt>update-insts!</tt> によって挿入される。
</p>

<p class="lisp"><a name="%_idx_5704"></a>(define (make-instruction text)
  (cons text '()))
<a name="%_idx_5706"></a>(define (instruction-text inst)
  (car inst))
<a name="%_idx_5708"></a>(define (instruction-execution-proc inst)
  (cdr inst))
<a name="%_idx_5710"></a>(define (set-instruction-execution-proc! inst proc)
  (set-cdr! inst proc))
</p>

<p class="orig" lang="en">The instruction text is not used by our simulator, but it is handy to keep
around for debugging (see exercise <a href="#%_thm_5.16">5.16</a>).</p>

<p class="trans" lang="ja">
命令テキストは、私たちのシミュレータによっては使われないが、そのままにしておくのがデバッグのためには便利である (練習問題<a href="#%_thm_5.16">5.16</a>を参照)。
</p>

<p class="orig" lang="en">
Elements of the label table are pairs:
</p>

<p class="trans" lang="ja">
ラベル表の要素は対である。
</p>

<p class="lisp"><a name="%_idx_5712"></a>(define (make-label-entry label-name insts)
  (cons label-name insts))
</p>

<p class="orig" lang="en">Entries will be looked up in the table with
</p>

<p class="trans" lang="ja">
以下により、表内においてエントリが調べられるだろう。
</p>

<p class="lisp"><a name="%_idx_5714"></a>(define (lookup-label labels label-name)
  (let ((val (assoc label-name labels)))
    (if val
        (cdr val)
        (error &quot;Undefined label -- ASSEMBLE&quot; label-name))))
</p>

<p class="orig" lang="en">
<a name="%_thm_5.8"></a>
<b>Exercise 5.8.</b>  The following register-machine code is ambiguous, because the label
<tt>here</tt> is defined more than once:
</p>

<p class="trans" lang="ja">
<b>練習問題5.8.</b> 以下のレジスタ・マシン・コードは、<tt>here</tt> というラベルが一度ならず定義されているため、曖昧である。
</p>

<p class="lisp">start
  (goto (label here))
here
  (assign a (const 3))
  (goto (label there))
here
  (assign a (const 4))
  (goto (label there))
there
</p>

<p class="orig" lang="en">With the simulator as written, what will the contents of register <tt>a</tt>
be when control reaches <tt>there</tt>?  Modify the <tt>extract-labels</tt>
procedure so that the assembler will signal an error if the same label
name is used to indicate two different locations.
</p>

<p class="trans" lang="ja">
書いてあるようなシミュレータを使うと、制御が <tt>there</tt> に到達したときに、<tt>a</tt> というレジスタの中身はどうなるだろうか?
同じラベル名が二つの異なる場所を示すのに使われていたら、アセンブラがエラーの合図をよこすように、<tt>extract-labels</tt> 手続きを修正せよ。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_5.2.3"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_5.2.3">5.2.3  Generating Execution Procedures for Instructions</a></h3>
<h3 class="trans" lang="ja">5.2.3 命令用の実行手続きを生成する</h3>

<p class="orig" lang="en"><a name="%_idx_5716"></a>
The assembler calls <tt>make-execution-procedure</tt> to
generate the execution procedure for an instruction.
Like the <tt>analyze</tt> procedure in the evaluator of
section <a href="26_sec4_1.html#%_sec_4.1.7">4.1.7</a>, this dispatches on the type of
instruction to generate the appropriate execution procedure.
</p>

<p class="trans" lang="ja">
アセンブラは、命令用の実行手続きを生成するために、<tt>make-execution-procedure</tt> を呼び出す。
<a href="26_sec4_1.html#%_sec_4.1.7">4.1.7</a>節の評価器における <tt>analyze</tt> 手続きと同様に、これは、適切な実行手続きを生成するために、命令の種類に基づいて<ruby><rb>振り分け</rb><rp> (</rp><rt>ディスパッチ</rt><rp>) </rp></ruby>を行う。
</p>

<p class="lisp"><a name="%_idx_5718"></a>(define (make-execution-procedure inst labels machine
                                  pc flag stack ops)
  (cond ((eq? (car inst) 'assign)
         (make-assign inst machine labels ops pc))
        ((eq? (car inst) 'test)
         (make-test inst machine labels ops flag pc))
        ((eq? (car inst) 'branch)
         (make-branch inst machine labels flag pc))
        ((eq? (car inst) 'goto)
         (make-goto inst machine labels pc))
        ((eq? (car inst) 'save)
         (make-save inst machine stack pc))
        ((eq? (car inst) 'restore)
         (make-restore inst machine stack pc))
        ((eq? (car inst) 'perform)
         (make-perform inst machine labels ops pc))
        (else (error &quot;Unknown instruction type -- ASSEMBLE&quot;
                     inst))))
</p>

<p class="orig" lang="en">
For each type of instruction in the register-machine language, there
is a generator that builds an appropriate execution procedure.  The
details of these procedures determine both the syntax and meaning of
the individual instructions in the register-machine language.
We use data abstraction to isolate the detailed syntax of
register-machine expressions from the general execution mechanism, as
we did for evaluators in section <a href="26_sec4_1.html#%_sec_4.1.2">4.1.2</a>,
by using syntax procedures to extract and classify the parts of an instruction.</p>

<p class="trans" lang="ja">
レジスタ・マシン言語における命令の各種類について、適切な実行手続きを構築する生成器がある。
これらの手続きの詳細は、レジスタ・マシン言語における個々の命令の、<ruby><rb>文法</rb><rp> (</rp><rt>シンタックス</rt><rp>) </rp></ruby>と意味の両方を、定める。
私たちは、データ抽象化を用いて、<a href="26_sec4_1.html#%_sec_4.1.2">4.1.2</a>節で評価器のためにそうしたのとちょうど同じように、命令の諸部分を抽出・分類するための文法手続きを用いることにより、レジスタ・マシンの式の詳細な文法を一般的な実行の仕組みから分離する。
<!-- レジスタ・マシンの式の詳細な文法を一般的な実行の仕組みから分離するために、私たちは、<a href="26_sec4_1.html#%_sec_4.1.2">4.1.2</a>節で評価器のためにそうしたのとちょうど同じように、命令の諸部分を抽出・分類するための文法手続きを用いることにより、データ抽象化を用いる。
 -->
</p>

<a name="%_sec_Temp_729"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_729"><tt>Assign</tt> instructions</a></h4>
<h4 class="trans" lang="ja"><tt>assign</tt> 命令</h4>

<p class="orig" lang="en">
<a name="%_idx_5720"></a>
The <tt>make-assign</tt> procedure handles <tt>assign</tt> instructions:
</p>


<p class="trans" lang="ja">
<tt>make-assign</tt> 手続きは、<tt>assign</tt> 命令を扱う。
</p>

<p class="lisp"><a name="%_idx_5722"></a>(define (make-assign inst machine labels operations pc)
  (let ((target
         (get-register machine (assign-reg-name inst)))
        (value-exp (assign-value-exp inst)))
    (let ((value-proc
           (if (operation-exp? value-exp)
               (make-operation-exp
                value-exp machine labels operations)
               (make-primitive-exp
                (car value-exp) machine labels))))
      (lambda ()                <em>; execution procedure for <tt>assign</tt></em>
        (set-contents! target (value-proc))
        (advance-pc pc)))))
</p>

<p class="orig" lang="en"><tt>Make-assign</tt> extracts the target register name (the
second element of the instruction) and the value expression
(the rest of the list that forms the instruction)
from the <tt>assign</tt> instruction using the selectors
</p>

<p class="trans" lang="ja">
<tt>make-assign</tt> は、目的のレジスタ (命令の2番目の要素) と、値の式 (当該命令を形成しているリストの残り) を、セレクタを用いて <tt>assign</tt> から抽出する。
</p>

<p class="lisp"><a name="%_idx_5724"></a>(define (assign-reg-name assign-instruction)
  (cadr assign-instruction))
<a name="%_idx_5726"></a>(define (assign-value-exp assign-instruction)
  (cddr assign-instruction))
</p>

<p class="orig" lang="en">The register name is looked up with <tt>get-register</tt> to produce the
target register object.  The value expression is passed to <tt>make-operation-exp</tt> if the value is the result of an operation, and to
<tt>make-primitive-exp</tt> otherwise.  These procedures (shown below)
parse the value expression and produce an execution procedure for the
value.  This is a procedure of no arguments, called <a name="%_idx_5728"></a><tt>value-proc</tt>,
which will be evaluated during the simulation to produce the actual
value to be assigned to the register.  Notice that the work of looking
up the register name and parsing the value expression is performed
just once, at assembly time, not every time the instruction is
simulated.  This saving of work is the reason we use execution
<a name="%_idx_5730"></a>procedures, and corresponds directly to the saving in work we obtained
by separating program analysis from execution in the evaluator of
section <a href="26_sec4_1.html#%_sec_4.1.7">4.1.7</a>.</p>

<p class="trans" lang="ja">
目的のレジスタ・オブジェクトを作り出すために、<tt>get-register</tt> を使ってレジスタ名を調べる。
値の式は、もしその値が演算の結果なら、<tt>make-operation-exp</tt> へと渡され、それ以外の場合は、<tt>make-primitive-exp</tt> へと渡される。
これらの手続き (以下に示してある) は、値の式を構文解析して、その値についての実行手続きを作り出す。
これは、引数なしの手続きで、<tt>value-proc</tt> と呼ばれるのだが、シミュレーションの間に評価されて、レジスタに割り当てられるべき実際の値を生み出すことになるだろう。
レジスタ名を調べて値の式を構文解析するという作業が、ただ一度だけ——つまり、アセンブルするときに——行われるのであって、命令がシミュレートされるたびに行われるのではない、ということに注意してほしい。
こうした作業の節約は、私たちが実行手続きを使う理由である。また、<a href="26_sec4_1.html#%_sec_4.1.7">4.1.7</a>節の評価器において、実行からプログラム分析を分離することで得た、作業上の節約に、直接的に対応している。
</p>

<p class="orig" lang="en">
The result returned by <tt>make-assign</tt> is the execution
procedure for the <tt>assign</tt> instruction.  When this procedure is
called (by the machine model's <tt>execute</tt> procedure),
it sets the contents of the target register to the result
obtained by executing <tt>value-proc</tt>.  Then it advances
the <tt>pc</tt> to the next instruction by running the procedure
</p>


<p class="trans" lang="ja">
<tt>make-assign</tt> により返される結果は、<tt>assign</tt> 命令に対する実行手続きである。
この手続きは、(マシン・モデルの <tt>execute</tt> 手続きによって) 呼び出されると、目的のレジスタの中身を、<tt>value-proc</tt> を実行することで得られた結果に設定する。
それから、この手続きは、以下の手続きを実行することによって、<tt>pc</tt> を次の命令へと進める。
</p>

<p class="lisp"><a name="%_idx_5732"></a>(define (advance-pc pc)
  (set-contents! pc (cdr (get-contents pc))))
</p>

<p class="orig" lang="en"><tt>Advance-pc</tt> is the normal termination for all instructions except
<tt>branch</tt> and <tt>goto</tt>.</p>

<p class="trans" lang="ja">
<tt>advance-pc</tt> は、<tt>branch</tt> と <tt>goto</tt> を除くすべての命令に対する、正常な終了である。
</p>

<a name="%_sec_Temp_730"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_730"><tt>Test</tt>, <tt>branch</tt>, and <tt>goto</tt> instructions</a></h4>
<h4 class="trans" lang="ja"><tt>test</tt> 命令と <tt>branch</tt> 命令と <tt>goto</tt> 命令</h4>

<p class="orig" lang="en">
<a name="%_idx_5734"></a><tt>Make-test</tt> handles <tt>test</tt> instructions in a similar way.  It
extracts the expression that specifies the condition to be tested and
generates an execution procedure for it.  At simulation time, the
procedure for the condition is called, the result is assigned to the
<tt>flag</tt> register, and the <tt>pc</tt> is advanced:
</p>

<p class="trans" lang="ja">
<tt>make-test</tt> は <tt>test</tt> 命令を類似の方法で扱う。
<tt>make-test</tt> は、検査すべき条件を指定する式を抽出し、その式に対する実行手続きを生成する。
シミュレーションのときには、その条件に対する手続きが呼ばれ、結果が <tt>flag</tt> レジスタに割り当てられ、<tt>pc</tt> が進められる。
</p>

<p class="lisp"><a name="%_idx_5736"></a>(define (make-test inst machine labels operations flag pc)
  (let ((condition (test-condition inst)))
    (if (operation-exp? condition)
        (let ((condition-proc
               (make-operation-exp
                condition machine labels operations)))
          (lambda ()
            (set-contents! flag (condition-proc))
            (advance-pc pc)))
        (error &quot;Bad TEST instruction -- ASSEMBLE&quot; inst))))
<a name="%_idx_5738"></a>(define (test-condition test-instruction)
  (cdr test-instruction))
</p>

<p class="orig" lang="en">
<a name="%_idx_5740"></a>The execution procedure for a <tt>branch</tt> instruction checks the
contents of the <tt>flag</tt> register and either sets the contents of
the <tt>pc</tt> to the branch destination (if the branch is taken) or
else just advances the <tt>pc</tt> (if the branch is not taken).  Notice
that the indicated destination in a <tt>branch</tt> instruction must be a
label, and the <tt>make-branch</tt> procedure enforces this.  Notice
also that the label is looked up at assembly time, not each time the
<tt>branch</tt> instruction is simulated.</p>

<p class="trans" lang="ja">
<tt>branch</tt> 命令に対する実行手続きは、<tt>flag</tt> レジスタの中身を調べ、(分岐が行われる場合に) <tt>pc</tt> の中身を分岐先に設定するか、または、(分岐が行われない場合に) ただ単に <tt>pc</tt> を進める。
<tt>branch</tt> 命令において示される行き先がラベルでなくてはならないことと、<tt>make-branch</tt> 手続きがこのことを遵守させることに、注意してほしい。
また、そのラベルはアセンブルを行うときに調べられるのであって、<tt>branch</tt> 命令がシミュレートされるたびに調べられるのではない、ということにも注意してほしい。
</p>

<p class="lisp"><a name="%_idx_5742"></a>(define (make-branch inst machine labels flag pc)
  (let ((dest (branch-dest inst)))
    (if (label-exp? dest)
        (let ((insts
               (lookup-label labels (label-exp-label dest))))
          (lambda ()
            (if (get-contents flag)
                (set-contents! pc insts)
                (advance-pc pc))))
        (error &quot;Bad BRANCH instruction -- ASSEMBLE&quot; inst))))
<a name="%_idx_5744"></a>(define (branch-dest branch-instruction)
  (cadr branch-instruction))
</p>

<p class="orig" lang="en">
<a name="%_idx_5746"></a>A <tt>goto</tt> instruction is similar to a branch, except that the
destination may be specified either as a label or as a register, and
there is no condition to check -- the <tt>pc</tt> is always set to the
new destination.
</p>


<p class="trans" lang="ja">
<tt>goto</tt> 命令は、行き先がラベルかレジスタのいずれかとして指定され得るという点と、検査すべき条件が存在しない——つまり、<tt>pc</tt> が常に新たな行き先に設定される——という点を除いて、分岐と同様である。
</p>

<p class="lisp"><a name="%_idx_5748"></a>(define (make-goto inst machine labels pc)
  (let ((dest (goto-dest inst)))
    (cond ((label-exp? dest)
           (let ((insts
                  (lookup-label labels
                                (label-exp-label dest))))
             (lambda () (set-contents! pc insts))))
          ((register-exp? dest)
           (let ((reg
                  (get-register machine
                                (register-exp-reg dest))))
             (lambda ()
               (set-contents! pc (get-contents reg)))))
          (else (error &quot;Bad GOTO instruction -- ASSEMBLE&quot;
                       inst)))))
<a name="%_idx_5750"></a>(define (goto-dest goto-instruction)
  (cadr goto-instruction))
</p>

<a name="%_sec_Temp_731"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_731">Other instructions</a></h4>
<h4 class="trans" lang="ja">その他の命令</h4>

<p class="orig" lang="en">
The stack instructions <tt>save</tt> and <tt>restore</tt> simply use the
stack with the designated register and advance the <tt>pc</tt>:
</p>

<p class="trans" lang="ja">
<tt>save</tt> および <tt>restore</tt> というスタック命令は、単純に、指定されたレジスタとともにスタックを用い、<tt>pc</tt> を進める。
</p>

<p class="lisp"><a name="%_idx_5752"></a><a name="%_idx_5754"></a>(define (make-save inst machine stack pc)
  (let ((reg (get-register machine
                           (stack-inst-reg-name inst))))
    (lambda ()
      (push stack (get-contents reg))
      (advance-pc pc))))
<a name="%_idx_5756"></a><a name="%_idx_5758"></a>(define (make-restore inst machine stack pc)
  (let ((reg (get-register machine
                           (stack-inst-reg-name inst))))
    (lambda ()
      (set-contents! reg (pop stack))    
      (advance-pc pc))))
<a name="%_idx_5760"></a>(define (stack-inst-reg-name stack-instruction)
  (cadr stack-instruction))
</p>

<p class="orig" lang="en">
<a name="%_idx_5762"></a>The final instruction type, handled by <tt>make-perform</tt>, generates
an execution procedure for the action to be performed.  At simulation
time, the action procedure is executed and the <tt>pc</tt> advanced.
</p>


<p class="trans" lang="ja">
最後の命令タイプは、<tt>make-perform</tt> により扱われるものなのだが、これは、行われるべき動作についての実行手続きを生成する。
シミュレーションのときには、動作手続きが実行され、<tt>pc</tt> が進められる。
</p>

<p class="lisp"><a name="%_idx_5764"></a>(define (make-perform inst machine labels operations pc)
  (let ((action (perform-action inst)))
    (if (operation-exp? action)
        (let ((action-proc
               (make-operation-exp
                action machine labels operations)))
          (lambda ()
            (action-proc)
            (advance-pc pc)))
        (error &quot;Bad PERFORM instruction -- ASSEMBLE&quot; inst))))
<a name="%_idx_5766"></a>(define (perform-action inst) (cdr inst))
</p>

<a name="%_sec_Temp_732"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_732">Execution procedures for subexpressions</a></h4>
<h4 class="trans" lang="ja">部分式についての実行手続き</h4>

<p class="orig" lang="en">
<a name="%_idx_5768"></a><a name="%_idx_5770"></a><a name="%_idx_5772"></a>The value of a <tt>reg</tt>, <tt>label</tt>, or <tt>const</tt> expression
may be needed for assignment to a register (<tt>make-assign</tt>) or for input to
an operation (<tt>make-operation-exp</tt>, below).  The following procedure
generates execution procedures to produce values for these expressions
during the simulation:
</p>

<p class="trans" lang="ja">
<tt>reg</tt> 式、<tt>label</tt> 式、または <tt>const</tt> 式の値が、レジスタへの割り当てのために (<tt>make-assign</tt>)、または、演算への入力のために (以下の <tt>make-operation-exp</tt>)、必要とされることがある。
これらの式についての値を、シミュレーションの間に生み出すための実行手続きを、以下の手続きが生成する。
</p>

<p class="lisp"><a name="%_idx_5774"></a>(define (make-primitive-exp exp machine labels)
  (cond ((constant-exp? exp)
         (let ((c (constant-exp-value exp)))
           (lambda () c)))
        ((label-exp? exp)
         (let ((insts
                (lookup-label labels
                              (label-exp-label exp))))
           (lambda () insts)))
        ((register-exp? exp)
         (let ((r (get-register machine
                                (register-exp-reg exp))))
           (lambda () (get-contents r))))
        (else
         (error &quot;Unknown expression type -- ASSEMBLE&quot; exp))))
</p>

<p class="orig" lang="en">The syntax of <tt>reg</tt>, <tt>label</tt>, and <tt>const</tt> expressions
is determined by
</p>


<p class="trans" lang="ja">
<tt>reg</tt> 式と <tt>label</tt> 式と <tt>const</tt> 式の文法は、以下により定められる。
</p>

<p class="lisp"><a name="%_idx_5776"></a>(define (register-exp? exp) (tagged-list? exp 'reg))
<a name="%_idx_5778"></a>(define (register-exp-reg exp) (cadr exp))
<a name="%_idx_5780"></a>(define (constant-exp? exp) (tagged-list? exp 'const))
<a name="%_idx_5782"></a>(define (constant-exp-value exp) (cadr exp))
<a name="%_idx_5784"></a>(define (label-exp? exp) (tagged-list? exp 'label))
<a name="%_idx_5786"></a>(define (label-exp-label exp) (cadr exp))
</p>

<p class="orig" lang="en">
<a name="%_idx_5788"></a><tt>Assign</tt>, <tt>perform</tt>, and <tt>test</tt> instructions
may include the application of a machine operation (specified by
an <tt>op</tt> expression) to some operands (specified by <tt>reg</tt>
and <tt>const</tt> expressions).
The following procedure produces an execution procedure
for an ``operation expression'' -- a list containing the operation and
operand expressions from the instruction:
</p>

<p class="trans" lang="ja">
<tt>assign</tt> 命令と <tt>perform</tt> 命令と <tt>test</tt> 命令は、(<tt>op</tt> 式により指定される) マシン演算の、(<tt>reg</tt> 式や <tt>const</tt> 式により指定される) 何らかのオペランドへの適用を、含むことがある。
以下の手続きは、「演算式」用の実行手続き——命令からの、演算とオペランド式とを含むリスト——を作り出す。
</p>

<p class="lisp"><a name="%_idx_5790"></a>(define (make-operation-exp exp machine labels operations)
  (let ((op (lookup-prim (operation-exp-op exp) operations))
        (aprocs
         (map (lambda (e)
                (make-primitive-exp e machine labels))
              (operation-exp-operands exp))))
    (lambda ()
      (apply op (map (lambda (p) (p)) aprocs)))))
</p>

<p class="orig" lang="en">The syntax of operation expressions is determined by
</p>

<p class="trans" lang="ja">
演算式の文法は、以下により定められる。
</p>

<p class="lisp"><a name="%_idx_5792"></a>(define (operation-exp? exp)
  (and (pair? exp) (tagged-list? (car exp) 'op)))
<a name="%_idx_5794"></a>(define (operation-exp-op operation-exp)
  (cadr (car operation-exp)))
<a name="%_idx_5796"></a>(define (operation-exp-operands operation-exp)
  (cdr operation-exp))
</p>

<p class="orig" lang="en">Observe that the treatment of operation expressions is very much like
the treatment of procedure applications by the <tt>analyze-application</tt> procedure in the evaluator of
section <a href="26_sec4_1.html#%_sec_4.1.7">4.1.7</a> in that we generate an execution
procedure for each operand.  At simulation time, we call the
operand procedures and apply the Scheme procedure that simulates
the operation to the resulting values.
The simulation procedure is found by looking up the operation name in
the operation table for the machine:
</p>

<p class="trans" lang="ja">
各オペランドについて実行手続きを生成する、という点において、演算式の扱いは、<a href="26_sec4_1.html#%_sec_4.1.7">4.1.7</a>節の評価器における <tt>analyze-application</tt> 手続きによる手続き適用の扱いと、非常によく似ている。
シミュレーションのときには、オペランド手続きを呼び出し、そして、その結果として生じる値に、当該演算をシミュレートするScheme手続きを適用する。
シミュレーション手続きは、当該マシン用の演算表において演算名を調べることによって、見つかる。
</p>

<p class="lisp"><a name="%_idx_5798"></a>(define (lookup-prim symbol operations)
  (let ((val (assoc symbol operations)))
    (if val
        (cadr val)
        (error &quot;Unknown operation -- ASSEMBLE&quot; symbol))))
</p>

<p class="orig" lang="en">
<a name="%_thm_5.9"></a>
<b>Exercise 5.9.</b>  The treatment of machine operations above permits them to operate
on labels as well as on constants and the contents of registers.
Modify the expression-processing procedures to enforce the condition
that operations can be used only with registers and constants.
</p>

<p class="trans" lang="ja">
<b>練習問題5.9.</b> 上記のマシン演算の取り扱いによって、これらマシン演算が定数やレジスタの中身に対して動作するのと同様に、ラベルに対しても動作することが可能となる。
レジスタおよび定数とだけ演算を使える、という条件を強制するように、式を処理する手続きを改変せよ。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.10"></a>
<b>Exercise 5.10.</b>  Design a new syntax for register-machine instructions and modify the
simulator to use your new syntax.  Can you implement your new
syntax without changing any part of the simulator except the
syntax procedures in this section?
</p>

<p class="trans" lang="ja">
<b>練習問題5.10.</b> レジスタ・マシン命令のための新たな文法を設計し、君の新たな文法を使うようにシミュレータを改変せよ。
本節の文法手続き以外はシミュレータのどの部分も変更しないで、君の新たな文法を実装することができるかい?
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.11"></a>
<b>Exercise 5.11.</b>  <a name="%_idx_5800"></a><a name="%_idx_5802"></a>When we introduced <tt>save</tt> and <tt>restore</tt> in
section <a href="31_sec5_1.html#%_sec_5.1.4">5.1.4</a>, we didn't specify what would happen
if you tried to restore a register that was not the last one saved, as
in the sequence</p>

<p class="trans" lang="ja">
<b>練習問題5.11.</b> 以下のような並びにおける、退避された最後のレジスタではないレジスタを復元しようとした場合に、何が起こるだろうかということを、私たちは、<a href="31_sec5_1.html#%_sec_5.1.4">5.1.4</a>節で <tt>save</tt> と <tt>restore</tt> を導入したときには規定しなかった。
</p>

<p class="lisp">(save y)
(save x)
(restore y)
</p>

<p class="orig" lang="en">There are several reasonable possibilities for the meaning of <tt>restore</tt>:</p>

<p class="trans" lang="ja">
<tt>restore</tt> の意味については、筋の通った可能性がいくつかある。
</p>

<ol class="orig alph" lang="en">
<li><tt>(restore y)</tt> puts into <tt>y</tt> the last value saved on the
stack, regardless of what register that value came from.  This is the
way our simulator behaves.  Show how to take advantage of this
behavior to eliminate one instruction from the Fibonacci machine of
section <a href="31_sec5_1.html#%_sec_5.1.4">5.1.4</a> (figure <a href="31_sec5_1.html#%_fig_5.12">5.12</a>).</li>

<li><tt>(restore y)</tt> puts into <tt>y</tt> the last value saved on the
stack, but only if that value was saved from <tt>y</tt>; otherwise, it
signals an error.  Modify the simulator to behave this way.  You will
have to change <tt>save</tt> to put the register name on the stack along
with the value.</li>

<li><tt>(restore y)</tt> puts into <tt>y</tt> the last value saved from <tt>y</tt> regardless of what other registers were saved after <tt>y</tt> and not
restored.  Modify the simulator to behave this way.  You will have to
associate a separate stack with each register.  You should make the
<tt>initialize-stack</tt> operation initialize all the register stacks.</li>
</ol>

<ol class="trans alph" lang="ja">
<li><tt>(restore y)</tt> は、スタック上に退避された最後の値を、その値がどのレジスタに由来するかによらず、とにかく <tt>y</tt> に入れる。
これは、私たちのシミュレータの振る舞い方である。
この振る舞いを利用して <a href="31_sec5_1.html#%_sec_5.1.4">5.1.4</a>節 (図<a href="31_sec5_1.html#%_fig_5.12">5.12</a>) のフィボナッチ・マシンから命令を一つ削除する方法を示せ。</li>
<li><tt>(restore y)</tt> は、スタック上に退避された最後の値を <tt>y</tt> に入れるのだが、それは、その値が <tt>y</tt> から退避された場合のみであり、それ以外の場合には、エラーを知らせる。
このように振る舞うように、シミュレータを改変せよ。
君は、値とともにレジスタ名をスタック上に置くように <tt>save</tt> を変更しなくてはならないだろう。</li>
<li><tt>(restore y)</tt> は、他のどのレジスタが <tt>y</tt> の後に退避され、かつ、復元されていないのか、ということによらず、<tt>y</tt> から退避された最後の値を <tt>y</tt> に入れる。
このように振る舞うように、シミュレータを改変せよ。
君は、別々のスタックを各レジスタと関連づけなくてはならないだろう。
君は、<tt>initialize-stack</tt> 演算に、すべてのレジスタ・スタックを初期化させるべきである。</li>
</ol>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.12"></a>
<b>Exercise 5.12.</b>  The simulator can be used to help determine the data paths required
for implementing a machine with a given controller.  Extend
the assembler to store the following information in the machine model:
</p>

<p class="trans" lang="ja">
<b>練習問題5.12.</b> 与えられたコントローラを有するマシンを実装するために必要とされるデータ経路を決定するのを手助けするために、シミュレータが使える。
マシン・モデル内に以下の情報を格納するよう、アセンブラを拡張せよ。
</p>

<ul class="orig" lang="en">
<li>a list of all instructions, with duplicates removed, sorted by
instruction type (<tt>assign</tt>, <tt>goto</tt>, and so on);</li>

<li>a list (without duplicates) of the registers used to hold entry
points (these are the registers referenced by <tt>goto</tt>
instructions);</li>

<li>a list (without duplicates) of the registers that are <tt>save</tt>d
or <tt>restore</tt>d;</li>

<li>for each register, a list (without duplicates) of the sources from
which it is assigned (for example, the sources for register <tt>val</tt>
in the factorial machine of figure <a href="31_sec5_1.html#%_fig_5.11">5.11</a> are
<tt>(const 1)</tt> and <tt>((op *) (reg n) (reg val))</tt>).</li>
</ul>

<ul class="trans" lang="ja">
<li>すべての命令のリスト——ただし重複を除いたもの——であって、命令種別 (<tt>assign</tt> や <tt>goto</tt> など) によりソートされたもの。</li>
<li>エントリ・ポイントを保持するのに使われるレジスタ (これらは <tt>goto</tt> 命令により参照されるレジスタである) の (重複なしの) リスト。</li>
<li><tt>save</tt> または <tt>restore</tt> されるレジスタの (重複なしの) リスト。</li>
<li>各レジスタについての、当該レジスタの割り当て元たる源の (重複なしの) リスト (たとえば、図<a href="31_sec5_1.html#%_fig_5.11">5.11</a>の階乗マシンでの <tt>val</tt> というレジスタについての源は、
<tt>(const 1)</tt> と 
<tt>((op *) (reg n) (reg val))</tt>
である)。</li>
</ul>

<p class="orig" lang="en">Extend the
message-passing interface to the machine to provide access to this new
information.  To test your analyzer, define the Fibonacci machine from
figure <a href="31_sec5_1.html#%_fig_5.12">5.12</a> and examine the lists you constructed.
</p>

<p class="trans" lang="ja">
この新たな情報へのアクセスを提供するように、マシンに対するメッセージ渡しインタフェイスを拡張せよ。
君の解析器を検査するために、図<a href="31_sec5_1.html#%_fig_5.12">5.12</a>のフィボナッチ・マシンを定義して、君が構築したリストを検討せよ。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.13"></a>
<b>Exercise 5.13.</b>  Modify the simulator so that it uses the controller sequence to
determine what registers the machine has rather than requiring a list
of registers as an argument to <tt>make-machine</tt>.  Instead of
pre-allocating the registers in <tt>make-machine</tt>, you can allocate
them one at a time when they are first seen during assembly of the
instructions.
</p>

<p class="trans" lang="ja">
<b>練習問題5.13.</b> <tt>make-machine</tt> に対する引数としてレジスタのリストを要求するのではなく、むしろ、マシンにどういうレジスタがあるかを判定するためにシミュレータがコントローラ列を用いるように、シミュレータを改変せよ。
<tt>make-machine</tt> においてレジスタを予め割り当てる代わりに、君は、命令をアセンブルする間に、レジスタが最初に見受けられたときに、レジスタを一度に一つずつ割り当てることができる。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_5.2.4"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_5.2.4">5.2.4  Monitoring Machine Performance</a></h3>
<h3 class="trans" lang="ja">5.2.4 マシン性能を監視する</h3>

<p class="orig" lang="en"><a name="%_idx_5804"></a>
<a name="%_idx_5806"></a>Simulation is useful not only for verifying the correctness of a
proposed machine design but also for measuring the machine's
performance.  For example, we can install in our simulation program a
``meter'' that measures the number of stack operations used in a
computation.  To do this, we modify our simulated stack to keep track
of the number of times registers are saved on the stack and the
maximum depth reached by the stack, and add a message to the stack's
interface that prints the statistics, as shown below.
We also add an operation to the basic machine model to print the
stack statistics, by initializing <tt>the-ops</tt> in <tt>make-new-machine</tt> to
</p>

<p class="trans" lang="ja">
提案されたマシン設計の正しさを検証するためだけでなく、マシンの性能を計測するためにも、シミュレーションは有用である。
たとえば、計算の際に使われるスタック演算の数を計測する「<ruby><rb>計器</rb><rp> (</rp><rt>メータ</rt><rp>) </rp></ruby>」を、私たちのシミュレーション・プログラムの中に仕込むことができる。
これを行うために、私たちは、シミュレートされるスタックを、レジスタがスタック上に退避される回数と、スタックが到達する最大深さとを把握するように、改変する。そして、後に示すように、統計量を印字するスタックのインタフェイスに対するメッセージを追加する。<!--係り受けについて要・見直し-->
また、スタックの統計量を印字するために、<tt>make-new-machine</tt> 内の <tt>the-ops</tt> を以下のように初期化することにより、基本的マシン・モデルに演算を追加する。
</p>

<p class="lisp"><a name="%_idx_5808"></a><a name="%_idx_5810"></a>(list (list 'initialize-stack
            (lambda () (stack 'initialize)))
      (list 'print-stack-statistics
            (lambda () (stack 'print-statistics))))
</p>

<p class="orig" lang="en">Here is the new version of <tt>make-stack</tt>:
</p>

<p class="trans" lang="ja">
ここに <tt>make-stack</tt> の新バージョンを示す。
</p>

<p class="lisp"><a name="%_idx_5812"></a>(define (make-stack)
  (let ((s '())
        (number-pushes 0)
        (max-depth 0)
        (current-depth 0))
    (define (push x)
      (set! s (cons x s))
      (set! number-pushes (+ 1 number-pushes))
      (set! current-depth (+ 1 current-depth))
      (set! max-depth (max current-depth max-depth)))
    (define (pop)
      (if (null? s)
          (error &quot;Empty stack -- POP&quot;)
          (let ((top (car s)))
            (set! s (cdr s))
            (set! current-depth (- current-depth 1))
            top)))    
    (define (initialize)
      (set! s '())
      (set! number-pushes 0)
      (set! max-depth 0)
      (set! current-depth 0)
      'done)
    (define (print-statistics)
      (newline)
      (display (list 'total-pushes  '= number-pushes
                     'maximum-depth '= max-depth)))
    (define (dispatch message)
      (cond ((eq? message 'push) push)
            ((eq? message 'pop) (pop))
            ((eq? message 'initialize) (initialize))
            ((eq? message 'print-statistics)
             (print-statistics))
            (else
             (error &quot;Unknown request -- STACK&quot; message))))
    dispatch))
</p>

<p class="orig" lang="en">
Exercises <a href="#%_thm_5.15">5.15</a> through <a href="#%_thm_5.19">5.19</a>
describe other useful monitoring and debugging features that can be
added to the register-machine simulator.</p>

<p class="trans" lang="ja">
練習問題<a href="#%_thm_5.15">5.15</a>から練習問題<a href="#%_thm_5.19">5.19</a>では、レジスタ・マシン・シミュレータに追加可能な、その他の有用な監視機能およびデバッグ機能を記述している。
</p>

<p class="orig" lang="en">
<a name="%_thm_5.14"></a>
<b>Exercise 5.14.</b>  <a name="%_idx_5814"></a>Measure the number of pushes and the maximum stack depth required to
compute <em>n</em>! for various small values of <em>n</em> using the factorial
machine shown in figure <a href="31_sec5_1.html#%_fig_5.11">5.11</a>.  From your data
determine formulas in terms of <em>n</em> for the total number of push
operations and the maximum stack depth used in computing <em>n</em>! for any
<em>n</em> &gt; 1. Note that each of these is a linear function of <em>n</em> and is
thus determined by two constants.  In order to get the statistics
printed, you will have to augment the factorial machine with instructions to
initialize the stack and print the statistics.
You may want to also modify the
machine so that it repeatedly reads a value for <em>n</em>, computes the
factorial, and prints the result (as we did for the GCD machine in
figure <a href="31_sec5_1.html#%_fig_5.4">5.4</a>), so that you will not have to repeatedly
invoke <tt>get-register-contents</tt>, <tt>set-register-contents!</tt>, and
<tt>start</tt>.
</p>

<p class="trans" lang="ja">
<b>練習問題5.14.</b> 図<a href="31_sec5_1.html#%_fig_5.11">5.11</a>に示す階乗マシンを使って <em class="en">n</em> の様々な小さな値について <em class="en">n</em>! を計算するのに必要な、プッシュ回数と最大スタック深さを、計測せよ。
任意の
<span class="math"><em class="en">n</em> &gt; 1</span>
について、<em class="en">n</em>! を計算する際に使われるプッシュ演算の総数と最大スタック深さについての、<em class="en">n</em> を使った式を、君のデータから定めよ。
これら<span class="note"> (プッシュ演算の総数と最大スタック深さ) </span>の各々は、<em class="en">n</em> の線形関数であり、したがって、二つの定数により定まるのだ、ということに注意せよ。
印字される統計量を得るために、君は、スタックを初期化する命令や統計量を印字する命令で階乗マシンを拡張しなくてはならないだろう。
君は、マシンが <em class="en">n</em> の値を繰り返し読んではその階乗を計算して結果を印刷するように (図<a href="31_sec5_1.html#%_fig_5.4">5.4</a>で GCD マシンについて私たちが行ったのとちょうど同じように)、マシンを改変したい、とも思うかもしれないし、するとその結果、君は、<tt>get-register-contents</tt> と <tt>set-register-contents!</tt> と <tt>start</tt> を繰り返し呼び出さなくてもよくなるだろう。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.15"></a>
<b>Exercise 5.15.</b>  Add <a name="%_idx_5816"></a><em>instruction counting</em> to the register machine simulation.
That is, have the machine model keep track of the number of
instructions executed.  Extend the machine model's interface to accept
a new message that prints the value of the instruction count and
resets the count to zero.
</p>

<p class="trans" lang="ja">
<b>練習問題5.15.</b> レジスタ・マシン・シミュレーションに、<em>命令計数</em>を追加せよ。
つまり、実行された命令の数を、マシン・モデルに把握させよ。
命令カウントの値を印字してカウントをゼロにリセットするような、新たなメッセージを受け入れるように、マシン・モデルのインタフェイスを拡張せよ。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.16"></a>
<b>Exercise 5.16.</b>  Augment the simulator to provide for <a name="%_idx_5818"></a><a name="%_idx_5820"></a><em>instruction tracing</em>.
That is, before each instruction is executed, the simulator should print
the text of the instruction.  Make the machine model accept <tt>trace-on</tt> and
<tt>trace-off</tt> messages to turn tracing on and off.
</p>

<p class="trans" lang="ja">
<b>練習問題5.16.</b> <em>命令追跡</em>に備えるように、シミュレータを拡張せよ。
つまり、各命令を実行する前に、シミュレータは、その命令のテキストを印字すべきである。
追跡をオンにしたりオフにしたりするための <tt>trace-on</tt> メッセージと <tt>trace-off</tt> メッセージを、マシン・モデルに受け付けさせよ。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.17"></a>
<b>Exercise 5.17.</b>  Extend the instruction tracing of
exercise <a href="#%_thm_5.16">5.16</a> so that before
printing an instruction, the simulator prints any labels that
immediately precede that instruction in the controller sequence.  Be
careful to do this in a way that does not interfere with instruction
counting (exercise <a href="#%_thm_5.15">5.15</a>).
You will have to make the simulator retain the necessary label information.
</p>

<p class="trans" lang="ja">
<b>練習問題5.17.</b> シミュレータが、命令を印字する前に、コントローラ列においてその命令の直前にある任意のラベルを印字するように、練習問題<a href="#%_thm_5.16">5.16</a>の命令追跡を拡張せよ。
命令計数 (練習問題<a href="#%_thm_5.15">5.15</a>) を妨害しないような方法でこれを行うように、気をつけよ。
君は、必要なラベル情報をシミュレータに記憶させておかねばならなくなるだろう。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.18"></a>
<b>Exercise 5.18.</b>  <a name="%_idx_5822"></a><a name="%_idx_5824"></a>Modify the <tt>make-register</tt> procedure of
section <a href="#%_sec_5.2.1">5.2.1</a> so that registers can be traced.
Registers should accept messages that turn tracing on and off.  When a
register is traced, assigning a value to the register should print the
name of the register, the old contents of the register, and the new
contents being assigned.  Extend the interface to the machine model
to permit you to turn tracing on and off for designated machine registers.
</p>

<p class="trans" lang="ja">
<b>練習問題5.18.</b> レジスタを追跡できるように、<a href="#%_sec_5.2.1">5.2.1</a>節の <tt>make-register</tt> 手続きを改変せよ。
レジスタは、追跡をオンにしたりオフにしたりするメッセージを受け付けるべきである。
レジスタが追跡される場合、そのレジスタに値を割り当てることで、そのレジスタの名前と、そのレジスタの古い中身と、割り当て中の新たな値とを印字することになるべきである。
指定されたマシン・レジスタについて、君が追跡をオンにしたりオフにしたりできるように、マシン・モデルに対するインタフェイスを拡張せよ。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.19"></a>
<b>Exercise 5.19.</b>  Alyssa P. Hacker wants a <a name="%_idx_5826"></a><em>breakpoint</em> feature in the simulator to
help her debug her machine designs.  You have been hired to install
this feature for her.  She wants to be able to specify a place in the
controller sequence where the simulator will stop and allow her to
examine the state of the machine.  You are to implement a procedure</p>

<p class="trans" lang="ja">
<b>練習問題5.19.</b> アリッサ・P・ハッカは、自分のマシン設計を自分がデバッグするのを手助けするための、シミュレータにおける<em>ブレイクポイント</em>機能を欲しがっている。
君は、彼女のためにこの機能をインストールするよう、雇われたところだ。
シミュレータが停止することになる、コントローラ列内における場所を指定できること、そして、自分がマシンの状態を調べられることを、彼女は望んでいる。
君は、以下の手続きを実装するつもりである。
</p>

<p class="lisp">(set-breakpoint &lt;<em>machine</em>&gt; &lt;<em>label</em>&gt; &lt;<em>n</em>&gt;)
</p>

<p class="orig" lang="en">that sets a breakpoint just before the <em>n</em>th instruction after the
given label.  For example,</p>

<p class="trans" lang="ja">
なおこれは、与えられたラベルの後の <em class="en">n</em> 番目の命令の直前にブレイクポイントを設定するものである。
たとえば、
</p>

<p class="lisp">(set-breakpoint gcd-machine 'test-b 4)
</p>

<p class="orig" lang="en">installs a breakpoint in <tt>gcd-machine</tt> just before the
assignment to register <tt>a</tt>.  When the simulator reaches the
breakpoint it should print the label and the offset of the breakpoint
and stop executing instructions.  Alyssa can then use <tt>get-register-contents</tt> and <tt>set-register-contents!</tt> to manipulate
the state of the simulated machine.  She should then be able to
continue execution by saying</p>

<p class="trans" lang="ja">
は、<tt>gcd-machine</tt> におけるブレイクポイントを、<tt>a</tt> というレジスタへの割り当ての直前に、設置する。
シミュレータは、ブレイクポイントに到達すると、ラベルと、ブレイクポイントのオフセットとを印字し、命令を実行するのをやめる。
すると、アリッサは、<tt>get-register-contents</tt> と <tt>set-register-contents!</tt> を用いて、シミュレートされているマシンの状態を操作できる。
その後、彼女は、以下のように述べることで実行を続けることが可能であるべきである。
</p>

<p class="lisp">(proceed-machine &lt;<em>machine</em>&gt;)
</p>

<p class="orig" lang="en">She should also be able to remove a specific breakpoint by means of</p>

<p class="trans" lang="ja">
彼女は、以下の手段により、特定のブレイクポイントを取り除くこともできるべきだし、
</p>

<p class="lisp">(cancel-breakpoint &lt;<em>machine</em>&gt; &lt;<em>label</em>&gt; &lt;<em>n</em>&gt;)
</p>

<p class="orig" lang="en">or to remove all breakpoints by means of</p>

<p class="trans" lang="ja">
あるいは、以下の手段により、すべてのブレイクポイントを取り除くこともできるべきである。
</p>

<p class="lisp">(cancel-all-breakpoints &lt;<em>machine</em>&gt;)
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="footnotes"></a>
<hr>

<p class="orig" lang="en"><a name="footnote_Temp_727" href="#call_footnote_Temp_727"><sup><small>4</small></sup></a> <a name="%_idx_5690"></a>Using the <tt>receive</tt> procedure here is a way to get <tt>extract-labels</tt> to effectively return two values -- <tt>labels</tt> and
<tt>insts</tt> -- without explicitly making a compound data structure to
hold them.  An alternative implementation, which returns an explicit
pair of values, is
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_727"><sup><small>4</small></sup></a>
ここで <tt>receive</tt> 手続きを使うことは、二つの値—— <tt>labels</tt> と <tt>insts</tt> ——を保持するための複合データ構造を明示的に作ることなしに、<tt>extract-labels</tt> に実質的にこれら二つの値を返させるための方法である。
別の実装——値の明示的な対を返す——は、以下のとおりであり、
</p>

<p class="lisp"><a name="%_idx_5692"></a>(define (extract-labels text)
  (if (null? text)
      (cons '() '())
      (let ((result (extract-labels (cdr text))))
        (let ((insts (car result)) (labels (cdr result)))
          (let ((next-inst (car text)))
            (if (symbol? next-inst)
                (cons insts
                      (cons (make-label-entry next-inst insts) labels))
                (cons (cons (make-instruction next-inst) insts)
                      labels)))))))
</p>

<p class="orig" lang="en">which would be called by <tt>assemble</tt> as follows:
</p>

<p class="trans" lang="ja">
これは、以下のようにして <tt>assemble</tt> により呼び出されるだろう。
</p>

<p class="lisp"><a name="%_idx_5694"></a>(define (assemble controller-text machine)
  (let ((result (extract-labels controller-text)))
    (let ((insts (car result)) (labels (cdr result)))
      (update-insts! insts labels machine)
      insts)))
</p>

<p class="orig" lang="en"><a name="%_idx_5696"></a><a name="%_idx_5698"></a><a name="%_idx_5700"></a>You can consider our use of <tt>receive</tt> as demonstrating an elegant
way to return multiple values, or simply an excuse to show off a
programming trick.  An argument like <tt>receive</tt> that is the next
procedure to be invoked is called a ``continuation.''  Recall that we
also used continuations to implement the backtracking control
structure in the <tt>amb</tt> evaluator in section <a href="28_sec4_3.html#%_sec_4.3.3">4.3.3</a>.</p>

<p class="trans" lang="ja">
君は、私たちの <tt>receive</tt> の使用法を、複数の値を返すための洗練された方法を実証するものだと見なすこともできるし、あるいは、単にプログラミングの秘訣をひけらかすための口実だと見なすこともできる。
呼び出されるべき次の手続きである、<tt>receive</tt> のような引数は、「<ruby><rb>継続</rb><rp> (</rp><rt>コンティニュエーション</rt><rp>) </rp></ruby>」と呼ばれる。
<a href="28_sec4_3.html#%_sec_4.3.3">4.3.3</a>節で、<tt>amb</tt> 評価器におけるバックトラッキング制御構造を実装するためにも継続を使ったことを思い出してほしい。
</p>

</div>
</body>
</html>
