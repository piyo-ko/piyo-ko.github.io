<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="sicp.css" type="text/css">
<base target="_top">
<title>SICPç§è¨³: 5.2 ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ»ãƒã‚·ãƒ³ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿</title>
<link rel="canonical" href="https://piyo-ko.github.io/SICP/32_sec5_2.html" />
</head>
<body>

<div class="idx-bar">
<nav>
<a href="https://twitter.com/share" class="twitter-share-button" data-lang="ja">ãƒ„ã‚¤ãƒ¼ãƒˆ</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
<span class="status">æ¨æ•²å¾…ã¡</span>
[
<a href="00_cover.html">å…ˆé ­ã¸</a> |
<a href="31_sec5_1.html">å‰ã¸</a> |
<a href="33_sec5_3.html">æ¬¡ã¸</a> |
<a href="04_toc.html#%_toc_start">ç›®æ¬¡</a> |
<a href="38_index.html#%_index_start">ç´¢å¼•</a>
] [<a href="99_about.html">ã“ã®å¯¾è¨³ç‰ˆã«ã¤ã„ã¦</a> | <a href="../index.html">ãƒ›ãƒ¼ãƒ </a>]
[
Â§<a href="#%_sec_5.2">5.2</a>
ğŸ“<a href="#%_thm_5.7">5.7</a>
Â§<a href="#%_sec_5.2.1">5.2.1</a>
ğŸ“š<a href="#%_sec_Temp_724">&hellip;</a>
ğŸ“š<a href="#%_sec_Temp_725">&hellip;</a>
ğŸ“š<a href="#%_sec_Temp_726">&hellip;</a>
ğŸ¨<a href="#%_fig_5.13">5.13</a>
Â§<a href="#%_sec_5.2.2">5.2.2</a>
ğŸ“<a href="#%_thm_5.8">5.8</a>
Â§<a href="#%_sec_5.2.3">5.2.3</a>
ğŸ“š<a href="#%_sec_Temp_729">&hellip;</a>
ğŸ“š<a href="#%_sec_Temp_730">&hellip;</a>
ğŸ“š<a href="#%_sec_Temp_731">&hellip;</a>
ğŸ“š<a href="#%_sec_Temp_732">&hellip;</a>
ğŸ“<a href="#%_thm_5.9">5.9</a>
ğŸ“<a href="#%_thm_5.10">5.10</a>
ğŸ“<a href="#%_thm_5.11">5.11</a>
ğŸ“<a href="#%_thm_5.12">5.12</a>
ğŸ“<a href="#%_thm_5.13">5.13</a>
Â§<a href="#%_sec_5.2.4">5.2.4</a>
ğŸ“<a href="#%_thm_5.14">5.14</a>
ğŸ“<a href="#%_thm_5.15">5.15</a>
ğŸ“<a href="#%_thm_5.16">5.16</a>
ğŸ“<a href="#%_thm_5.17">5.17</a>
ğŸ“<a href="#%_thm_5.18">5.18</a>
ğŸ“<a href="#%_thm_5.19">5.19</a>
<a href="#footnotes">è„šæ³¨</a>
]</nav>
</div>

<div class="main-txt">


<a name="%_sec_5.2"></a>
<h2 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_5.2">5.2  A Register-Machine Simulator</a></h2>
<h2 class="trans" lang="ja">5.2 ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ»ãƒã‚·ãƒ³ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿</h2>

<p class="orig" lang="en">
<a name="%_idx_5622"></a><a name="%_idx_5624"></a>
In order to gain a good understanding of the design of register
machines, we must test the machines we design to see if they perform
as expected.  One way to test a design is to hand-simulate the
operation of the controller, as in exercise <a href="31_sec5_1.html#%_thm_5.5">5.5</a>.  But this is
extremely tedious for all but the simplest machines.  In this section
we construct a simulator for machines described in the
register-machine language.  The simulator is a Scheme program with
four interface procedures.  The first uses a description of a register
machine to construct a model of the machine (a data structure whose
parts correspond to the parts of the machine to be simulated), and the
other three allow us to simulate the machine by manipulating the
model:</p>

<p class="trans" lang="ja">
ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ»ãƒã‚·ãƒ³ã®è¨­è¨ˆã«ã¤ã„ã¦è‰¯ã„ç†è§£ã‚’å¾—ã‚‹ãŸã‚ã«ã¯ã€è‡ªåˆ†ã®è¨­è¨ˆã™ã‚‹ãƒã‚·ãƒ³ã‚’æ¤œæŸ»ã—ã¦ã€ãã®ãƒã‚·ãƒ³ãŒæœŸå¾…é€šã‚Šã«æ©Ÿèƒ½ã™ã‚‹ã‹ã©ã†ã‹ã‚’è¦‹ãªãã¦ã¯ãªã‚‰ãªã„ã€‚
è¨­è¨ˆã‚’æ¤œæŸ»ã™ã‚‹ãŸã‚ã®ä¸€ã¤ã®æ–¹æ³•ã¯ã€ç·´ç¿’å•é¡Œ<a href="31_sec5_1.html#%_thm_5.5">5.5</a>ã§ã®ã‚ˆã†ã«ã€ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ã®æ¼”ç®—ã‚’æ‰‹ä½œæ¥­ã§ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã™ã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚
ã—ã‹ã—ã€ã“ã‚Œã¯ã€æœ€ã‚‚å˜ç´”ãªãƒã‚·ãƒ³ä»¥å¤–ã®ã™ã¹ã¦ã«ã¨ã£ã¦ã€æ¥µã‚ã¦ã†ã‚“ã–ã‚Šã™ã‚‹ã“ã¨ã ã€‚
æœ¬ç¯€ã§ã¯ã€ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ»ãƒã‚·ãƒ³è¨€èªã§è¨˜è¿°ã•ã‚ŒãŸãƒã‚·ãƒ³ã«ã¤ã„ã¦ã®ã€ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã‚’æ§‹ç¯‰ã™ã‚‹ã€‚
ãã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã¯ã€å››ã¤ã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ã‚¤ã‚¹æ‰‹ç¶šãã‚’ã¨ã‚‚ãªã† Scheme ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã ã€‚
ç¬¬ä¸€ã®ã‚‚ã®ã¯ã€ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ»ãƒã‚·ãƒ³ã®è¨˜è¿°ã‚’ä½¿ã£ã¦ã€ãã®ãƒã‚·ãƒ³ã®ãƒ¢ãƒ‡ãƒ« (ãã®éƒ¨å“ãŒã€ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã™ã¹ããƒã‚·ãƒ³ã®éƒ¨å“ã«å¯¾å¿œã™ã‚‹ã‚ˆã†ãªã€ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã§ã‚ã‚‹) ã‚’æ§‹ç¯‰ã™ã‚‹ã€‚æ®‹ã‚Šã®ä¸‰ã¤ã¯ã€ãã®ãƒ¢ãƒ‡ãƒ«ã‚’æ“ä½œã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ç§ãŸã¡ãŒãã®ãƒã‚·ãƒ³ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã§ãã‚‹ã‚ˆã†ã«ã—ã¦ãã‚Œã‚‹ã€‚
</p>

<dl class="orig" lang="en">
<dt><a name="%_idx_5626"></a><tt>(make-machine &lt;<em>register-names</em>&gt; &lt;<em>operations</em>&gt; &lt;<em>controller</em>&gt;)</tt></dt>
<dd>
constructs and returns a model of the machine with the given
registers, operations, and controller.</dd>

<dt><a name="%_idx_5628"></a><tt>(set-register-contents! &lt;<em>machine-model</em>&gt; &lt;<em>register-name</em>&gt; &lt;<em>value</em>&gt;)</tt>
</dt>
<dd>stores a value in a simulated register in the given
machine.</dd>

<dt><a name="%_idx_5630"></a><tt>(get-register-contents &lt;<em>machine-model</em>&gt; &lt;<em>register-name</em>&gt;)</tt>
</dt>
<dd>returns the contents of a simulated register in the given machine.</dd>

<dt><a name="%_idx_5632"></a><tt>(start &lt;<em>machine-model</em>&gt;)</tt>
</dt>
<dd>simulates the execution of the given
machine, starting from the beginning of the controller sequence and
stopping when it reaches the end of the sequence.</dd>
</dl>

<dl class="trans" lang="ja">
<dt><tt>(make-machine &lt;<em class="en">register-names</em>&gt; &lt;<em class="en">operations</em>&gt; &lt;<em class="en">controller</em>&gt;)</tt></dt>
<dd>ã¯ã€ä¸ãˆã‚‰ã‚ŒãŸãƒ¬ã‚¸ã‚¹ã‚¿ã¨æ¼”ç®—ã¨ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ã‚’ã¨ã‚‚ãªã†ãƒã‚·ãƒ³ã®ã€ãƒ¢ãƒ‡ãƒ«ã‚’æ§‹ç¯‰ã—ã¦è¿”ã™ã€‚</dd>

<dt><tt>(set-register-contents! &lt;<em class="en">machine-model</em>&gt; &lt;<em class="en">register-name</em>&gt; &lt;<em class="en">value</em>&gt;)</tt></dt>
<dd>ã¯ã€ä¸ãˆã‚‰ã‚ŒãŸãƒã‚·ãƒ³å†…ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ãƒ¬ã‚¸ã‚¹ã‚¿ã«ã€å€¤ã‚’æ ¼ç´ã™ã‚‹ã€‚</dd>

<dt><tt>(get-register-contents &lt;<em class="en">machine-model</em>&gt; &lt;<em class="en">register-name</em>&gt;)</tt></dt>
<dd>ã¯ã€ä¸ãˆã‚‰ã‚ŒãŸãƒã‚·ãƒ³å†…ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ãƒ¬ã‚¸ã‚¹ã‚¿ã®ä¸­èº«ã‚’è¿”ã™ã€‚</dd>

<dt><tt>(start &lt;<em class="en">machine-model</em>&gt;)</tt></dt>
<dd>ã¯ã€ä¸ãˆã‚‰ã‚ŒãŸãƒã‚·ãƒ³ã®å®Ÿè¡Œã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã—ã€ãã®éš›ã€ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©åˆ—ã®æœ€åˆã‹ã‚‰å§‹ã‚ã¦ã€åˆ—ã®çµ‚ã‚ã‚Šã«é”ã—ãŸã‚‰åœæ­¢ã™ã‚‹ã€‚</dd>

</dl>

<p class="orig" lang="en">
As an example of how these procedures are used, we can define
<tt>gcd-machine</tt> to be a model of the GCD machine
of section <a href="31_sec5_1.html#%_sec_5.1.1">5.1.1</a> as follows:</p>

<p class="trans" lang="ja">
ã“ã‚Œã‚‰ã®æ‰‹ç¶šããŒã©ã®ã‚ˆã†ã«ä½¿ã‚ã‚Œã‚‹ã®ã‹ã€ã¨ã„ã†ä¾‹ã¨ã—ã¦ã€ç§ãŸã¡ã¯ã€<a href="31_sec5_1.html#%_sec_5.1.1">5.1.1</a>ç¯€ã® GCD ãƒã‚·ãƒ³ã®ãƒ¢ãƒ‡ãƒ«ã¨ãªã‚‹ã‚ˆã†ã«ã€<tt>gcd-machine</tt> ã‚’ä»¥ä¸‹ã®ã¨ãŠã‚Šå®šç¾©ã§ãã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_5634"></a>(define gcd-machine
  (make-machine
   '(a b t)
   (list (list 'rem remainder) (list '= =))
   '(test-b
       (test (op =) (reg b) (const 0))
       (branch (label gcd-done))
       (assign t (op rem) (reg a) (reg b))
       (assign a (reg b))
       (assign b (reg t))
       (goto (label test-b))
     gcd-done)))
</p>

<p class="orig" lang="en">The first argument to <tt>make-machine</tt> is a list of register names.
The next argument is a table (a list of two-element lists) that pairs
each operation name with a Scheme procedure that implements the operation
(that is, produces the same output value given the same input values).
The last argument specifies the controller as a list of labels and
machine instructions, as in section <a href="31_sec5_1.html#%_sec_5.1">5.1</a>.</p>

<p class="trans" lang="ja">
<tt>make-machine</tt> ã«å¯¾ã™ã‚‹æœ€åˆã®å¼•æ•°ã¯ã€ãƒ¬ã‚¸ã‚¹ã‚¿åã®ãƒªã‚¹ãƒˆã§ã‚ã‚‹ã€‚
æ¬¡ã®å¼•æ•°ã¯ã€å„æ¼”ç®—åã‚’ã€å½“è©²æ¼”ç®—ã‚’å®Ÿè£…ã™ã‚‹ (ã¤ã¾ã‚Šã€åŒã˜å…¥åŠ›å€¤ã‚’ä¸ãˆã‚‰ã‚Œã‚‹ã¨åŒã˜å‡ºåŠ›å€¤ã‚’ç”Ÿã¿å‡ºã™) Scheme æ‰‹ç¶šãã¨å¯¾ã«ã™ã‚‹ã‚ˆã†ãªã€<ruby><rb>è¡¨</rb><rp> (</rp><rt>ãƒ†ãƒ¼ãƒ–ãƒ«</rt><rp>) </rp></ruby> (2è¦ç´ ãƒªã‚¹ãƒˆã®ãƒªã‚¹ãƒˆ) ã§ã‚ã‚‹ã€‚
æœ€å¾Œã®å¼•æ•°ã¯ã€<a href="31_sec5_1.html#%_sec_5.1">5.1</a>ç¯€ã§ã®ã‚ˆã†ã«ã€ãƒ©ãƒ™ãƒ«ã¨ãƒã‚·ãƒ³å‘½ä»¤ã¨ã®ãƒªã‚¹ãƒˆã¨ã—ã¦ã€ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ã®æ˜ç´°ã‚’è¦å®šã™ã‚‹ã€‚
</p>

<p class="orig" lang="en">
To compute GCDs with this machine, we set the
input registers, start the machine, and examine the result when the
simulation terminates:
</p>

<p class="trans" lang="ja">
ã“ã®ãƒã‚·ãƒ³ã§ GCD ã‚’è¨ˆç®—ã™ã‚‹ã«ã¯ã€å…¥åŠ›ãƒ¬ã‚¸ã‚¹ã‚¿ã‚’è¨­å®šã—ã€ãƒã‚·ãƒ³ã‚’å§‹å‹•ã•ã›ã€ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãŒçµ‚äº†ã—ãŸã¨ãã«çµæœã‚’æ¤œè¨ã™ã‚‹ã€‚
</p>

<p class="lisp">(set-register-contents! gcd-machine 'a 206)
<i>done</i>
(set-register-contents! gcd-machine 'b 40)
<i>done</i>
(start gcd-machine)
<i>done</i>
(get-register-contents gcd-machine 'a)
<i>2</i>
</p>

<p class="orig" lang="en">This computation will run much more slowly than a <tt>gcd</tt> procedure
written in Scheme, because we will simulate low-level machine
instructions, such as <tt>assign</tt>, by much more complex operations.</p>

<p class="trans" lang="ja">
ã“ã®è¨ˆç®—ã¯ã€Scheme ã§æ›¸ã‹ã‚ŒãŸ <tt>gcd</tt> æ‰‹ç¶šãã‚ˆã‚Šã‚‚ã€ãšã£ã¨ã‚†ã£ãã‚Šå‹•ä½œã™ã‚‹ã ã‚ã†ã€‚ãªãœãªã‚‰ã€ <tt>assign</tt> ãªã©ã®ä½æ°´æº–ã®ãƒã‚·ãƒ³å‘½ä»¤ã‚’ã€ã‚‚ã£ã¨ãšã£ã¨è¤‡é›‘ãªæ¼”ç®—ã«ã‚ˆã£ã¦ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã™ã‚‹ã“ã¨ã«ãªã‚‹ã‹ã‚‰ã ã€‚
</p>

<p class="orig" lang="en">
<a name="%_thm_5.7"></a>
<b>Exercise 5.7.</b>  Use the simulator to test the machines you designed in
exercise <a href="31_sec5_1.html#%_thm_5.4">5.4</a>.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ5.7.</b> å›ãŒ<a href="31_sec5_1.html#%_thm_5.4">5.4</a>ç¯€ã§è¨­è¨ˆã—ãŸãƒã‚·ãƒ³ã‚’ã€ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã‚’ç”¨ã„ã¦æ¤œæŸ»ã›ã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_5.2.1"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_5.2.1">5.2.1  The Machine Model</a></h3>
<h3 class="trans" lang="ja">5.2.1 ãƒã‚·ãƒ³ãƒ»ãƒ¢ãƒ‡ãƒ«</h3>


<p class="orig" lang="en">The machine model generated by <tt>make-machine</tt> is represented as a
procedure with local state using the message-passing techniques
developed in chapter 3.  To build this model, <tt>make-machine</tt>
begins by calling the procedure <tt>make-new-machine</tt> to construct
the parts of the machine model that are common to all register
machines.  This basic machine model constructed by <tt>make-new-machine</tt> is essentially a container for some registers and a
stack, together with an execution mechanism that processes the controller
instructions one by one.</p>

<p class="trans" lang="ja">
<tt>make-machine</tt> ã«ã‚ˆã‚Šç”Ÿæˆã•ã‚Œã‚‹ãƒã‚·ãƒ³ãƒ»ãƒ¢ãƒ‡ãƒ«ã¯ã€3ç« ã§é–‹ç™ºã—ãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸<ruby><rb>æ¸¡ã—</rb><rp> (</rp><rt>ãƒ‘ãƒƒã‚·ãƒ³ã‚°</rt><rp>) </rp></ruby>ã®æŠ€æ³•ã‚’ç”¨ã„ã‚‹ã€å±€æ‰€çŠ¶æ…‹ã¤ãã®æ‰‹ç¶šãã¨ã—ã¦ã€è¡¨ç¾ã•ã‚Œã‚‹ã€‚
ã“ã®ãƒ¢ãƒ‡ãƒ«ã‚’æ§‹ç¯‰ã™ã‚‹ãŸã‚ã«ã€<tt>make-machine</tt> ã¯ã€<tt>make-new-machine</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’å‘¼ã³å‡ºã—ã¦ã€ã™ã¹ã¦ã®ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ»ãƒã‚·ãƒ³ã«å…±é€šãªãƒã‚·ãƒ³ãƒ»ãƒ¢ãƒ‡ãƒ«ã®éƒ¨å“ã‚’æ§‹ç¯‰ã™ã‚‹ã“ã¨ã‹ã‚‰å§‹ã‚ã‚‹ã€‚
<tt>make-new-machine</tt> ã«ã‚ˆã‚Šæ§‹ç¯‰ã•ã‚Œã‚‹ã€ã“ã®åŸºæœ¬çš„ãƒã‚·ãƒ³ãƒ»ãƒ¢ãƒ‡ãƒ«ã¯ã€æœ¬è³ªçš„ã«ã¯ã€ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©å‘½ä»¤ã‚’ä¸€ã¤ãšã¤å‡¦ç†ã™ã‚‹å®Ÿè¡Œæ©Ÿæ§‹ã‚’å‚™ãˆãŸã€ã„ãã¤ã‹ã®ãƒ¬ã‚¸ã‚¹ã‚¿ã¨ä¸€ã¤ã®ã‚¹ã‚¿ãƒƒã‚¯ã®ãŸã‚ã®<ruby><rb>å®¹ã‚Œç‰©</rb><rp> (</rp><rt>ã‚³ãƒ³ãƒ†ãƒŠ</rt><rp>) </rp></ruby>ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
<tt>Make-machine</tt> then extends this basic model (by sending it
messages) to include the registers, operations, and controller of the
particular machine being defined.  First it allocates a register in
the new machine for each of the supplied register names and installs
the designated operations in the machine.  Then it uses an <a name="%_idx_5636"></a><em>assembler</em> (described below in section <a href="#%_sec_5.2.2">5.2.2</a>) to
transform the controller list into instructions for the new machine
and installs these as the machine's instruction sequence.  <tt>Make-machine</tt> returns as its value the modified machine model.</p>

<p class="trans" lang="ja">
<tt>make-machine</tt> ã¯ã€ãã‚Œã‹ã‚‰ã€ãƒ¬ã‚¸ã‚¹ã‚¿ã‚„ã€æ¼”ç®—ã‚„ã€å®šç¾©ä¸­ã®ç‰¹å®šã®ãƒã‚·ãƒ³ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ã‚’å«ã‚€ã‚ˆã†ã«ã€(ã“ã®åŸºæœ¬çš„ãƒ¢ãƒ‡ãƒ«ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ã‚‹ã“ã¨ã«ã‚ˆã£ã¦) ã“ã®åŸºæœ¬çš„ãƒ¢ãƒ‡ãƒ«ã‚’æ‹¡å¼µã™ã‚‹ã€‚
ã¾ãšã€ä¸ãˆã‚‰ã‚ŒãŸãƒ¬ã‚¸ã‚¹ã‚¿åã®å„ã€…ã«å¯¾ã—ã¦ã€æ–°è¦ãƒã‚·ãƒ³å†…ã®ãƒ¬ã‚¸ã‚¹ã‚¿ã‚’å‰²ã‚Šå½“ã¦ã€æŒ‡å®šã•ã‚ŒãŸæ¼”ç®—ã‚’ãƒã‚·ãƒ³ã«ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã™ã‚‹ã€‚
ãã‚Œã‹ã‚‰ã€<em>ã‚¢ã‚»ãƒ³ãƒ–ãƒ©</em> (ä»¥ä¸‹ã®<a href="#%_sec_5.2.2">5.2.2</a>ç¯€ã«ãŠã„ã¦èª¬æ˜ã™ã‚‹) ã‚’ç”¨ã„ã¦ã€ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ»ãƒªã‚¹ãƒˆã‚’æ–°è¦ãƒã‚·ãƒ³ç”¨ã®å‘½ä»¤ç¾¤ã¸ã¨å¤‰æ›ã—ã€ã“ã‚Œã‚‰ã®å‘½ä»¤ã‚’å½“è©²ãƒã‚·ãƒ³ã®å‘½ä»¤åˆ—ã¨ã—ã¦ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã™ã‚‹ã€‚
<tt>make-machine</tt> ã¯ã€ãã®å€¤ã¨ã—ã¦ã€æ”¹å¤‰ã•ã‚ŒãŸãƒã‚·ãƒ³ãƒ»ãƒ¢ãƒ‡ãƒ«ã‚’è¿”ã™ã€‚
</p>

<p class="lisp"><a name="%_idx_5638"></a>(define (make-machine register-names ops controller-text)
  (let ((machine (make-new-machine)))
    (for-each (lambda (register-name)
                ((machine 'allocate-register) register-name))
              register-names)
    ((machine 'install-operations) ops)    
    ((machine 'install-instruction-sequence)
     (assemble controller-text machine))
    machine))
</p>

<a name="%_sec_Temp_724"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_724">Registers</a></h4>
<h4 class="trans" lang="ja">ãƒ¬ã‚¸ã‚¹ã‚¿</h4>

<p class="orig" lang="en">
<a name="%_idx_5640"></a>
We will represent a register as a procedure with local state, as in
chapter 3.  The procedure <tt>make-register</tt> creates a register that
holds a value that can be accessed or changed:</p>

<p class="trans" lang="ja">
3ç« ã§ã®ã‚ˆã†ãªå±€æ‰€çŠ¶æ…‹ã¤ãã®æ‰‹ç¶šãã¨ã—ã¦ã€ãƒ¬ã‚¸ã‚¹ã‚¿ã‚’è¡¨ãã†ã€‚
<tt>make-register</tt> ã¨ã„ã†æ‰‹ç¶šãã¯ã€ã‚¢ã‚¯ã‚»ã‚¹ã—ãŸã‚Šã€ã‚ã‚‹ã„ã¯å¤‰æ›´ã—ãŸã‚Šã™ã‚‹ã“ã¨ãŒå¯èƒ½ãªå€¤ã‚’ä¿æŒã™ã‚‹ãƒ¬ã‚¸ã‚¹ã‚¿ã‚’ã€ä½œæˆã™ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_5642"></a>(define (make-register name)
  (let ((contents '*unassigned*))
    (define (dispatch message)
      (cond ((eq? message 'get) contents)
            ((eq? message 'set)
             (lambda (value) (set! contents value)))
            (else
             (error &quot;Unknown request -- REGISTER&quot; message))))
    dispatch))
</p>

<p class="orig" lang="en">The following procedures are used to access registers:</p>

<p class="trans" lang="ja">
ãƒ¬ã‚¸ã‚¹ã‚¿ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã®ã«ã¯ã€ä»¥ä¸‹ã®æ‰‹ç¶šããŒä½¿ã‚ã‚Œã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_5644"></a>(define (get-contents register)
  (register 'get))

<a name="%_idx_5646"></a>(define (set-contents! register value)
  ((register 'set) value))
</p>

<a name="%_sec_Temp_725"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_725">The stack</a></h4>
<h4 class="trans" lang="ja">ã‚¹ã‚¿ãƒƒã‚¯</h4>

<p class="orig" lang="en">
<a name="%_idx_5648"></a>
We can also represent a stack as a procedure with local state.  The
procedure <tt>make-stack</tt> creates a stack whose local state consists
of a list of the items on the stack.  A stack accepts requests to <tt>push</tt> an item onto the stack, to <tt>pop</tt> the top item off the stack
and return it, and to <tt>initialize</tt> the stack to empty.</p>

<p class="trans" lang="ja">
ã‚¹ã‚¿ãƒƒã‚¯ã‚‚ã€å±€æ‰€çŠ¶æ…‹ã¤ãã®æ‰‹ç¶šãã¨ã—ã¦è¡¨ã›ã‚‹ã€‚
<tt>make-stack</tt> ã¨ã„ã†æ‰‹ç¶šãã¯ã€å±€æ‰€çŠ¶æ…‹ãŒå½“è©²ã‚¹ã‚¿ãƒƒã‚¯ä¸Šã®<ruby><rb>é …ç›®</rb><rp> (</rp><rt>ã‚¢ã‚¤ãƒ†ãƒ </rt><rp>) </rp></ruby>ã®ãƒªã‚¹ãƒˆã‹ã‚‰ã§ãã¦ã„ã‚‹ã‚ˆã†ãªã‚¹ã‚¿ãƒƒã‚¯ã‚’ã€ä½œæˆã™ã‚‹ã€‚
ã‚¹ã‚¿ãƒƒã‚¯ã¯ã€å½“è©²ã‚¹ã‚¿ãƒƒã‚¯ä¸Šã«é …ç›®ã‚’ <ruby><rb><tt>push</tt> ã™ã‚‹</rb><rp> (</rp><rt>ã¤ã‚€</rt><rp>) </rp></ruby>ã‚ˆã†æ±‚ã‚ã‚‹è¦æ±‚ã‚„ã€å½“è©²ã‚¹ã‚¿ãƒƒã‚¯ã‹ã‚‰å…ˆé ­é …ç›®ã‚’ <ruby><rb><tt>pop</tt> ã—</rb><rp> (</rp><rt>ã¨ã‚Šã ã—</rt><rp>) </rp></ruby>ã¦ãã®å…ˆé ­é …ç›®ã‚’è¿”ã™ã‚ˆã†æ±‚ã‚ã‚‹è¦æ±‚ã‚„ã€ã‚¹ã‚¿ãƒƒã‚¯ã‚’ç©ºã« <ruby><rb><tt>initialize</tt></rb><rp> (</rp><rt>åˆæœŸåŒ–</rt><rp>) </rp></ruby> ã™ã‚‹ã‚ˆã†æ±‚ã‚ã‚‹è¦æ±‚ã‚’ã€å—ã‘å…¥ã‚Œã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_5650"></a>(define (make-stack)
  (let ((s '()))
    (define (push x)
      (set! s (cons x s)))
    (define (pop)
      (if (null? s)
          (error &quot;Empty stack -- POP&quot;)
          (let ((top (car s)))
            (set! s (cdr s))
            top)))
    (define (initialize)
      (set! s '())
      'done)
    (define (dispatch message)
      (cond ((eq? message 'push) push)
            ((eq? message 'pop) (pop))
            ((eq? message 'initialize) (initialize))
            (else (error &quot;Unknown request -- STACK&quot;
                         message))))
    dispatch))
</p>

<p class="orig" lang="en">The following procedures are used to access stacks:</p>

<p class="trans" lang="ja">
ã‚¹ã‚¿ãƒƒã‚¯ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã®ã«ã¯ã€ä»¥ä¸‹ã®æ‰‹ç¶šããŒä½¿ã‚ã‚Œã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_5652"></a>(define (pop stack)
  (stack 'pop))

<a name="%_idx_5654"></a>(define (push stack value)
  ((stack 'push) value))
</p>

<a name="%_sec_Temp_726"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_726">The basic machine</a></h4>
<h4 class="trans" lang="ja">åŸºæœ¬ãƒã‚·ãƒ³</h4>

<p class="orig" lang="en">
The <tt>make-new-machine</tt> procedure, shown in
figure <a href="#%_fig_5.13">5.13</a>, constructs an object whose local
state consists of a stack, an initially empty instruction sequence, a
list of operations that initially contains an operation to <a name="%_idx_5656"></a>initialize
the stack, and a <a name="%_idx_5658"></a><em>register table</em> that initially contains two
<a name="%_idx_5660"></a><a name="%_idx_5662"></a>registers, named <tt>flag</tt> and <tt>pc</tt> <a name="%_idx_5664"></a>(for ``program counter'').
The internal procedure <tt>allocate-register</tt> adds new entries to the
register table, and the internal procedure <tt>lookup-register</tt> looks
up registers in the table.</p>

<p class="trans" lang="ja">
ã‚¹ã‚¿ãƒƒã‚¯ã¨ã€æœ€åˆã¯ç©ºã®å‘½ä»¤åˆ—ã¨ã€ã‚¹ã‚¿ãƒƒã‚¯ã‚’åˆæœŸåŒ–ã™ã‚‹æ¼”ç®—ã‚’æœ€åˆã¯å«ã‚“ã§ã„ã‚‹æ¼”ç®—ãƒªã‚¹ãƒˆã¨ã€<tt>flag</tt> ãŠã‚ˆã³ <tt>pc</tt> (ã€Œãƒ—ãƒ­ã‚°ãƒ©ãƒ ãƒ»ã‚«ã‚¦ãƒ³ã‚¿ã€ã®æ„) ã¨ã„ã†åã®äºŒã¤ã®ãƒ¬ã‚¸ã‚¹ã‚¿ã‚’æœ€åˆã¯å«ã‚“ã§ã„ã‚‹<em>ãƒ¬ã‚¸ã‚¹ã‚¿è¡¨</em>ã¨ã€ã‹ã‚‰ãªã‚‹å±€æ‰€çŠ¶æ…‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã€å›³<a href="#%_fig_5.13">5.13</a>ã«ç¤ºã™ <tt>make-new-machine</tt> ã®æ‰‹ç¶šãã¯æ§‹ç¯‰ã™ã‚‹ã€‚
<tt>allocate-register</tt> ã¨ã„ã†å†…éƒ¨æ‰‹ç¶šãã¯ã€ãƒ¬ã‚¸ã‚¹ã‚¿è¡¨ã«æ–°ãŸãªã‚¨ãƒ³ãƒˆãƒªã‚’è¿½åŠ ã—ã€<tt>lookup-register</tt> ã¨ã„ã†å†…éƒ¨æ‰‹ç¶šãã¯ã€ãã®è¡¨ã§ãƒ¬ã‚¸ã‚¹ã‚¿ã‚’èª¿ã¹ã‚‹ã€‚
</p>

<p class="orig" lang="en">
The <tt>flag</tt> register is used to control branching in the simulated
machine.  <tt>Test</tt> instructions set the contents of <tt>flag</tt> to
the result of the test (true or false).  <tt>Branch</tt> instructions
decide whether or not to branch by examining the contents of <tt>flag</tt>.</p>

<p class="trans" lang="ja">
<tt>flag</tt> ãƒ¬ã‚¸ã‚¹ã‚¿ã¯ã€ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã•ã‚Œã‚‹ãƒã‚·ãƒ³ã«ãŠã‘ã‚‹åˆ†å²ã‚’åˆ¶å¾¡ã™ã‚‹ã®ã«ä½¿ã‚ã‚Œã‚‹ã€‚
<tt>test</tt> å‘½ä»¤ã¯ã€<tt>flag</tt> ã®ä¸­èº«ã‚’ã€å½“è©²<ruby><rb>æ¤œæŸ»</rb><rp> (</rp><rt>ãƒ†ã‚¹ãƒˆ</rt><rp>) </rp></ruby>ã®çµæœ (çœŸã¾ãŸã¯å½) ã«è¨­å®šã™ã‚‹ã€‚
<tt>branch</tt> å‘½ä»¤ã¯ã€<tt>flag</tt> ã®ä¸­èº«ã‚’èª¿ã¹ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€åˆ†å²ã™ã¹ãã‹ã©ã†ã‹ã‚’æ±ºå®šã™ã‚‹ã€‚
</p>

<p class="orig" lang="en">
The <tt>pc</tt> register determines the sequencing of instructions as
the machine runs.  This sequencing is implemented by the internal
procedure <tt>execute</tt>.
In the simulation model, each machine instruction is a data structure
that includes a procedure of no arguments, called the <a name="%_idx_5666"></a><a name="%_idx_5668"></a><em>instruction
execution procedure</em>, such that calling this procedure simulates
executing the instruction.  As the simulation runs, <tt>pc</tt> points to
the place in the instruction sequence beginning with the next
instruction to be executed.  <a name="%_idx_5670"></a><tt>Execute</tt> gets that instruction,
executes it by calling the instruction execution procedure, and
repeats this cycle until there are no more instructions to execute
(i.e., until <tt>pc</tt> points to the end of the instruction sequence).</p>

<p class="trans" lang="ja">
<tt>pc</tt> ãƒ¬ã‚¸ã‚¹ã‚¿ã¯ã€ãƒã‚·ãƒ³ãŒå‹•ä½œã™ã‚‹éš›ã€å‘½ä»¤ã®æ’åˆ—ã‚’å®šã‚ã‚‹ã€‚
ã“ã®æ’åˆ—ã¯ã€<tt>execute</tt> ã¨ã„ã†å†…éƒ¨æ‰‹ç¶šãã«ã‚ˆã‚Šå®Ÿè£…ã•ã‚Œã‚‹ã€‚
ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ»ãƒ¢ãƒ‡ãƒ«ã«ãŠã„ã¦ã€å„ãƒã‚·ãƒ³å‘½ä»¤ã¯ã€å¼•æ•°ãªã—ã®æ‰‹ç¶šãâ€”â€”<em>å‘½ä»¤å®Ÿè¡Œæ‰‹ç¶šã</em>ã¨å‘¼ã°ã‚Œã‚‹â€”â€”ã‚’å«ã‚€ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã§ã‚ã£ã¦ã€ãã®çµæœã€ã“ã®æ‰‹ç¶šãã®å‘¼ã³å‡ºã—ã«ã‚ˆã‚Šã€å‘½ä»¤ã®å®Ÿè¡ŒãŒã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã•ã‚Œã‚‹ã€‚
ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãŒå‹•ä½œã™ã‚‹é–“ã€<tt>pc</tt> ã¯ã€å®Ÿè¡Œã™ã¹ãæ¬¡ã®å‘½ä»¤ã‹ã‚‰å§‹ã¾ã‚‹å‘½ä»¤åˆ—ã®ä¸­ã®å ´æ‰€ã‚’æŒ‡ã™ã€‚
<tt>execute</tt> ã¯ã€ãã®å‘½ä»¤ã‚’å–å¾—ã—ã¦ã€å‘½ä»¤å®Ÿè¡Œæ‰‹ç¶šãã‚’å‘¼ã³å‡ºã™ã“ã¨ã§å½“è©²å‘½ä»¤ã‚’å®Ÿè¡Œã—ã€å®Ÿè¡Œã™ã¹ãå‘½ä»¤ãŒã‚‚ã†ãªããªã‚‹ã¾ã§ (ã¤ã¾ã‚Šã€<tt>pc</tt> ãŒå‘½ä»¤åˆ—ã®æœ€å¾Œã‚’æŒ‡ã™ã¾ã§) ã“ã®ä¸€å·¡ã‚Šã‚’ç¹°ã‚Šè¿”ã™ã€‚
</p>

<figure>
<a name="%_fig_5.13"></a>
<p class="infig-lisp"><a name="%_idx_5672"></a>(define (make-new-machine)
  (let ((pc (make-register 'pc))
        (flag (make-register 'flag))
        (stack (make-stack))
        (the-instruction-sequence '()))
    (let ((the-ops
           (list (list 'initialize-stack
                       (lambda () (stack 'initialize)))))
          (register-table
           (list (list 'pc pc) (list 'flag flag))))
      (define (allocate-register name)
        (if (assoc name register-table)
            (error &quot;Multiply defined register: &quot; name)
            (set! register-table
                  (cons (list name (make-register name))
                        register-table)))
        'register-allocated)
      (define (lookup-register name)
        (let ((val (assoc name register-table)))
          (if val
              (cadr val)
              (error &quot;Unknown register:&quot; name))))
      (define (execute)
        (let ((insts (get-contents pc)))
          (if (null? insts)
              'done
              (begin
                ((instruction-execution-proc (car insts)))
                (execute)))))
      (define (dispatch message)
        (cond ((eq? message 'start)
               (set-contents! pc the-instruction-sequence)
               (execute))
              ((eq? message 'install-instruction-sequence)
               (lambda (seq) (set! the-instruction-sequence seq)))
              ((eq? message 'allocate-register) allocate-register)
              ((eq? message 'get-register) lookup-register)
              ((eq? message 'install-operations)
               (lambda (ops) (set! the-ops (append the-ops ops))))
              ((eq? message 'stack) stack)
              ((eq? message 'operations) the-ops)
              (else (error &quot;Unknown request -- MACHINE&quot; message))))
      dispatch)))
</p>
<figcaption class="orig" lang="en"><b>Figure 5.13:</b>  The <tt>make-new-machine</tt> procedure, which implements
the basic machine model.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³5.13.:</b> <tt>make-new-machine</tt> æ‰‹ç¶šãâ€”â€”åŸºæœ¬çš„ãƒã‚·ãƒ³ãƒ»ãƒ¢ãƒ‡ãƒ«ã‚’å®Ÿè£…ã™ã‚‹ã‚‚ã®</figcaption>
</figure>

<p class="orig" lang="en">
As part of its operation, each instruction execution procedure
modifies <tt>pc</tt> to indicate the next instruction to be executed.
<tt>Branch</tt> and <tt>goto</tt> instructions change <tt>pc</tt> to point to
the new destination.  All other instructions simply advance <tt>pc</tt>,
making it point to the next instruction in the sequence.  Observe that
each call to <tt>execute</tt> calls <tt>execute</tt> again, but this does
not produce an infinite loop because running the instruction execution
procedure changes the contents of <tt>pc</tt>.</p>

<p class="trans" lang="ja">
è‡ªèº«ã®æ¼”ç®—ã®ä¸€éƒ¨ã¨ã—ã¦ã€å„å‘½ä»¤å®Ÿè¡Œæ‰‹ç¶šãã¯ã€å®Ÿè¡Œã™ã¹ãæ¬¡ã®å‘½ä»¤ã‚’ç¤ºã™ã‚ˆã†ã« <tt>pc</tt> ã‚’å¤‰æ›´ã™ã‚‹ã€‚
<tt>branch</tt> å‘½ä»¤ã¨ <tt>goto</tt> å‘½ä»¤ã¯ã€æ–°ãŸãªè¡Œãå…ˆã‚’ç¤ºã™ã‚ˆã†ã« <tt>pc</tt> ã‚’å¤‰æ›´ã™ã‚‹ã€‚
ä»–ã®ã™ã¹ã¦ã®å‘½ä»¤ã¯ã€å˜ç´”ã« <tt>pc</tt> ã‚’é€²ã‚ã€<tt>pc</tt> ã«åˆ—ã®ä¸­ã®æ¬¡ã®å‘½ä»¤ã‚’ ç¤ºã•ã›ã‚‹ã€‚
<tt>execute</tt> ã«å¯¾ã™ã‚‹å„å‘¼ã³å‡ºã—ãŒå†åº¦ <tt>execute</tt> ã‚’å‘¼ã³å‡ºã™ã‘ã‚Œã©ã‚‚ã€å‘½ä»¤å®Ÿè¡Œæ‰‹ç¶šããŒ <tt>pc</tt> ã®ä¸­èº«ã‚’å¤‰æ›´ã™ã‚‹ã®ã§ã€ã“ã®å‘¼ã³å‡ºã—ã¯ç„¡é™ãƒ«ãƒ¼ãƒ—ã‚’ç”Ÿã¿å‡ºã—ãŸã‚Šã¯ã—ãªã„ã€ã¨ã„ã†ã“ã¨ã«æ°—ã¥ã„ã¦ã»ã—ã„ã€‚
</p>

<p class="orig" lang="en">
<tt>Make-new-machine</tt> returns a
<tt>dispatch</tt> procedure that implements message-passing
access to the internal state.  Notice that starting the machine is
accomplished by setting <tt>pc</tt> to the beginning of the instruction
sequence and calling <tt>execute</tt>.</p>

<p class="trans" lang="ja">
<tt>make-new-machine</tt> ã¯ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ¸¡ã—ã«ã‚ˆã‚‹å†…éƒ¨çŠ¶æ…‹ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ <tt>dispatch</tt> æ‰‹ç¶šãã‚’è¿”ã™ã€‚
<tt>pc</tt> ã‚’å‘½ä»¤åˆ—ã®å…ˆé ­ã«è¨­å®šã—ã¦ <tt>execute</tt> ã‚’å‘¼ã³å‡ºã™ã“ã¨ã«ã‚ˆã£ã¦ã€ãƒã‚·ãƒ³ã‚’å§‹å‹•ã•ã›ã‚‹ã“ã¨ãŒé”æˆã•ã‚Œã‚‹ã®ã ã€ã¨ã„ã†ã“ã¨ã«æ³¨æ„ã—ã¦ã»ã—ã„ã€‚
</p>

<p class="orig" lang="en">
For convenience, we provide an alternate procedural interface to a
machine's <tt>start</tt> operation,
as well as procedures to set and examine register contents,
as specified at the beginning of section <a href="#%_sec_5.2">5.2</a>:</p>

<p class="trans" lang="ja">
<a href="#%_sec_5.2">5.2</a>ç¯€ã®å…ˆé ­ã§è¦å®šã•ã‚Œã¦ã„ã‚‹ã‚ˆã†ãªã€ãƒ¬ã‚¸ã‚¹ã‚¿ã®ä¸­èº«ã‚’è¨­å®šã—ãŸã‚Šèª¿ã¹ãŸã‚Šã™ã‚‹æ‰‹ç¶šãã ã‘ã§ãªãã€ãƒã‚·ãƒ³ã® <tt>start</tt> æ¼”ç®—ã«å¯¾ã—ã¦ã‚‚ã€ä¾¿å®œä¸Šã€åˆ¥ã®æ‰‹ç¶šãçš„ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ã‚¤ã‚¹ã‚’æä¾›ã™ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_5674"></a>(define (start machine)
  (machine 'start))
<a name="%_idx_5676"></a>(define (get-register-contents machine register-name)
  (get-contents (get-register machine register-name)))
<a name="%_idx_5678"></a>(define (set-register-contents! machine register-name value)
  (set-contents! (get-register machine register-name) value)
  'done)
</p>

<p class="orig" lang="en">These procedures (and many procedures in sections <a href="#%_sec_5.2.2">5.2.2</a>
and <a href="#%_sec_5.2.3">5.2.3</a>) use the following to look up the register with a
given name in a given machine:
</p>


<p class="trans" lang="ja">
ã“ã‚Œã‚‰ã®æ‰‹ç¶šã (ãŠã‚ˆã³ã€<a href="#%_sec_5.2.2">5.2.2</a>ç¯€ã¨<a href="#%_sec_5.2.3">5.2.3</a>ç¯€ã®å¤šãã®æ‰‹ç¶šã) ã¯ã€ä¸ãˆã‚‰ã‚ŒãŸãƒã‚·ãƒ³ã«ãŠã‘ã‚‹ã€ä¸ãˆã‚‰ã‚ŒãŸåå‰ã®ãƒ¬ã‚¸ã‚¹ã‚¿ã‚’èª¿ã¹ã‚‹ãŸã‚ã«ã€ä»¥ä¸‹ã®ã‚‚ã®ã‚’ä½¿ã†ã€‚
</p>

<p class="lisp"><a name="%_idx_5680"></a>(define (get-register machine reg-name)
  ((machine 'get-register) reg-name))
</p>

<a name="%_sec_5.2.2"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_5.2.2">5.2.2  The Assembler</a></h3>
<h3 class="trans" lang="ja">5.2.2 ã‚¢ã‚»ãƒ³ãƒ–ãƒ©</h3>

<p class="orig" lang="en"><a name="%_idx_5682"></a>
The assembler transforms the sequence of controller expressions for a
machine into a corresponding list of machine instructions, each with
its execution procedure.  Overall, the assembler is much like the
evaluators we studied in chapter 4 -- there is an input language (in
this case, the register-machine language) and we must perform an
appropriate action for each type of expression in the language.</p>

<p class="trans" lang="ja">
ã‚¢ã‚»ãƒ³ãƒ–ãƒ©ã¯ã€ã‚ã‚‹ãƒã‚·ãƒ³ã«ã¤ã„ã¦ã®ä¸€é€£ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©å¼ã‚’ã€å¯¾å¿œã™ã‚‹ãƒã‚·ãƒ³å‘½ä»¤ã®ãƒªã‚¹ãƒˆâ€”â€”ãƒã‚·ãƒ³å‘½ä»¤ã®å„ã€…ã¯è‡ªåˆ†ã®å®Ÿè¡Œæ‰‹ç¶šãã‚’ã¨ã‚‚ãªã£ã¦ã„ã‚‹â€”â€”ã«å¤‰æ›ã™ã‚‹ã€‚
å…¨ä½“ã¨ã—ã¦ã€ã‚¢ã‚»ãƒ³ãƒ–ãƒ©ã¯ã€4ç« ã§ç ”ç©¶ã—ãŸè©•ä¾¡å™¨ã«ã¨ã¦ã‚‚ä¼¼ã¦ã„ã‚‹â€”â€”ã¤ã¾ã‚Šã€å…¥åŠ›è¨€èª (ç›®ä¸‹ã®å ´åˆã¯ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ»ãƒã‚·ãƒ³è¨€èª) ãŒã‚ã‚Šã€å½“è©²è¨€èªã«ãŠã‘ã‚‹å¼ã®å„ç¨®é¡ã«ã¤ã„ã¦é©åˆ‡ãªå‹•ä½œã‚’å®Ÿè¡Œã›ã­ã°ãªã‚‰ãªã„ã®ã ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_5684"></a>The technique of producing an execution procedure for each instruction
is just what we used in section <a href="26_sec4_1.html#%_sec_4.1.7">4.1.7</a> to speed
up the evaluator by separating analysis from runtime execution.  As we
saw in chapter 4, much useful analysis of Scheme expressions could be
performed without knowing the actual values of variables.  Here,
analogously, much useful analysis of register-machine-language
expressions can be performed without knowing the actual contents of
machine registers.  For example, we can replace references to
registers by pointers to the register objects, and we can
replace references to labels by pointers to the place in the
instruction sequence that the label designates.</p>

<p class="trans" lang="ja">
å„å‘½ä»¤ã«ã¤ã„ã¦å®Ÿè¡Œæ‰‹ç¶šãã‚’ç”Ÿã¿å‡ºã™æŠ€æ³•ã¯ã€ã¾ã•ã«ã¡ã‚‡ã†ã©ã€å®Ÿè¡Œæ™‚ã®å®Ÿè¡Œã‹ã‚‰è§£æã‚’åˆ†é›¢ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦è©•ä¾¡å™¨ã‚’é«˜é€ŸåŒ–ã™ã‚‹ãŸã‚ã«<a href="26_sec4_1.html#%_sec_4.1.7">4.1.7</a>ç¯€ã§ä½¿ã£ãŸã‚‚ã®ã§ã‚ã‚‹ã€‚
4ç« ã§è¦‹ãŸã¨ãŠã‚Šã€å¤‰æ•°ã®å®Ÿéš›ã®å€¤ã‚’çŸ¥ã‚‹ã“ã¨ãªã—ã«ã€Schemeå¼ã«ã¤ã„ã¦ã®å¤šãã®æœ‰ç”¨ãªè§£æã‚’å®Ÿè¡Œã—å¾—ã‚‹ã€‚
ã“ã“ã§ã¯ã€ä¼¼ãŸã‚ˆã†ã«ã—ã¦ã€ãƒã‚·ãƒ³ãƒ»ãƒ¬ã‚¸ã‚¹ã‚¿ã®å®Ÿéš›ã®ä¸­èº«ã‚’çŸ¥ã‚‹ã“ã¨ãªã—ã«ã€ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ»ãƒã‚·ãƒ³è¨€èªã®å¼ã«ã¤ã„ã¦ã®å¤šãã®æœ‰ç”¨ãªè§£æã‚’å®Ÿè¡Œã§ãã‚‹ã€‚
ãŸã¨ãˆã°ã€ãƒ¬ã‚¸ã‚¹ã‚¿ã¸ã®å‚ç…§ã‚’ã€ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ»ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã§ç½®ãæ›ãˆã‚‰ã‚Œã‚‹ã—ã€ãƒ©ãƒ™ãƒ«ã¸ã®å‚ç…§ã‚’ã€ãã®ãƒ©ãƒ™ãƒ«ãŒæŒ‡å®šã™ã‚‹ã€å‘½ä»¤åˆ—ä¸­ã®å ´æ‰€ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã§ç½®ãæ›ãˆã‚‰ã‚Œã‚‹ã€‚
</p>

<p class="orig" lang="en">
Before it can generate the instruction execution procedures, the
assembler must know what all the labels refer to, so it begins by
scanning the controller text to separate the labels from the
instructions.  As it scans the text, it constructs both a list of
instructions and a table that associates each label with a pointer
into that list.  Then the assembler augments the instruction list by
inserting the execution procedure for each instruction.</p>

<p class="trans" lang="ja">
å‘½ä»¤å®Ÿè¡Œæ‰‹ç¶šãã‚’ç”Ÿæˆã™ã‚‹ã¾ã§ã«ã€ã‚¢ã‚»ãƒ³ãƒ–ãƒ©ã¯ã€ã™ã¹ã¦ã®ãƒ©ãƒ™ãƒ«ãŒä½•ã‚’å‚ç…§ã—ã¦ã„ã‚‹ã®ã‹ã‚’çŸ¥ã‚‰ã­ã°ãªã‚‰ãšã€ãã‚Œã‚†ãˆã«ã€ã‚¢ã‚»ãƒ³ãƒ–ãƒ©ã¯ã€å‘½ä»¤ã‹ã‚‰ãƒ©ãƒ™ãƒ«ã‚’åˆ†é›¢ã™ã‚‹ãŸã‚ã«ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ»ãƒ†ã‚­ã‚¹ãƒˆã‚’èµ°æŸ»ã™ã‚‹ã“ã¨ã‹ã‚‰å§‹ã‚ã‚‹ã€‚
ã‚¢ã‚»ãƒ³ãƒ–ãƒ©ã¯ã€ãƒ†ã‚­ã‚¹ãƒˆã‚’èµ°æŸ»ã™ã‚‹ã«ã¤ã‚Œã¦ã€å‘½ä»¤ã®ãƒªã‚¹ãƒˆã¨ã€å„ãƒ©ãƒ™ãƒ«ã‚’ãã®ãƒªã‚¹ãƒˆå†…ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã¨é–¢é€£ã¥ã‘ã‚‹è¡¨ã®ã€åŒæ–¹ã‚’æ§‹ç¯‰ã™ã‚‹ã€‚
ãã‚Œã‹ã‚‰ã€ã‚¢ã‚»ãƒ³ãƒ–ãƒ©ã¯ã€å„å‘½ä»¤ã«ã¤ã„ã¦å®Ÿè¡Œæ‰‹ç¶šãã‚’æŒ¿å…¥ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦å‘½ä»¤ãƒªã‚¹ãƒˆã‚’æ‹¡å¼µã™ã‚‹ã€‚
</p>

<p class="orig" lang="en">
The <tt>assemble</tt> procedure is the main entry to the assembler.
It takes the controller text and the machine model as arguments and
returns the instruction sequence to be stored in the model.
<tt>Assemble</tt> calls <tt>extract-labels</tt> to build the initial instruction list
and label table from the supplied controller text.  The second argument
to <tt>extract-labels</tt> is a procedure to be called to process these results:
This procedure uses <tt>update-insts!</tt> to generate the instruction execution
procedures and insert them into the instruction list,
and returns the modified list.
</p>

<p class="trans" lang="ja">
<tt>assemble</tt> æ‰‹ç¶šãã¯ã€ã‚¢ã‚»ãƒ³ãƒ–ãƒ©ã¸ã®ä¸»ãŸã‚‹å…¥ã‚Šå£ã§ã‚ã‚‹ã€‚
ã“ã‚Œã¯ã€ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ»ãƒ†ã‚­ã‚¹ãƒˆã¨ãƒã‚·ãƒ³ãƒ»ãƒ¢ãƒ‡ãƒ«ã‚’å¼•æ•°ã¨ã—ã¦ã¨ã‚Šã€ãã®ãƒ¢ãƒ‡ãƒ«å†…ã«æ ¼ç´ã™ã¹ãå‘½ä»¤åˆ—ã‚’è¿”ã™ã€‚
<tt>assemble</tt> ã¯ã€ä¾›çµ¦ã•ã‚ŒãŸã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ»ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰åˆæœŸå‘½ä»¤ãƒªã‚¹ãƒˆã¨ãƒ©ãƒ™ãƒ«è¡¨ã‚’æ§‹ç¯‰ã™ã‚‹ãŸã‚ã«ã€<tt>extract-labels</tt> ã‚’å‘¼ã³å‡ºã™ã€‚
<tt>extract-labels</tt> ã¸ã®ç¬¬2å¼•æ•°ã¯ã€ã“ã‚Œã‚‰ã®çµæœã‚’å‡¦ç†ã™ã‚‹ãŸã‚ã«å‘¼ã°ã‚Œã‚‹ã¹ãæ‰‹ç¶šãã§ã‚ã‚‹ã€‚
ã“ã®æ‰‹ç¶šãã¯ã€<tt>update-insts!</tt> ã‚’ç”¨ã„ã¦ã€å‘½ä»¤å®Ÿè¡Œæ‰‹ç¶šãã‚’ç”Ÿæˆã—ã¦ãã‚Œã‚‰ã‚’å‘½ä»¤ãƒªã‚¹ãƒˆã«æŒ¿å…¥ã—ã€å¤‰æ›´ã—ãŸãƒªã‚¹ãƒˆã‚’è¿”ã™ã€‚
</p>

<p class="lisp"><a name="%_idx_5686"></a>(define (assemble controller-text machine)
  (extract-labels controller-text
    (lambda (insts labels)
      (update-insts! insts labels machine)
      insts)))
</p>

<p class="orig" lang="en">
<tt>Extract-labels</tt>
takes as arguments a list <tt>text</tt> (the sequence of controller
instruction expressions) and a <tt>receive</tt> procedure.  <tt>Receive</tt>
will be called with two values: (1) a list <tt>insts</tt> of instruction
data structures, each containing an instruction from <tt>text</tt>; and
(2) a table called <tt>labels</tt>, which associates each label from <tt>text</tt>
with the position in the list <tt>insts</tt> that the label designates.</p>

<p class="trans" lang="ja">
<tt>extract-labels</tt> ã¯ã€å¼•æ•°ã¨ã—ã¦ã€<tt>text</tt> ã¨ã„ã†ãƒªã‚¹ãƒˆ (ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©å‘½ä»¤å¼ã®åˆ—) ã¨ <tt>receive</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’ã¨ã‚‹ã€‚
<tt>receive</tt> ã¯ã€äºŒã¤ã®å€¤â€”â€”ã¤ã¾ã‚Šã€
(1) <tt>insts</tt> ã¨ã„ã†ã€å‘½ä»¤ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã®ãƒªã‚¹ãƒˆã§ã‚ã£ã¦ã€å„å‘½ä»¤ãƒ‡ãƒ¼ã‚¿æ§‹é€ ãŒ <tt>text</tt> ã‹ã‚‰ã®å‘½ä»¤ã‚’å«ã‚“ã§ã„ã‚‹ã‚‚ã®ã¨ã€
(2) <tt>labels</tt> ã¨å‘¼ã°ã‚Œã‚‹è¡¨ã§ã‚ã£ã¦ã€<tt>text</tt> ã‹ã‚‰ã®å„ãƒ©ãƒ™ãƒ«ã‚’ã€<tt>insts</tt> ã¨ã„ã†ãƒªã‚¹ãƒˆå†…ã§ã®å½“è©²ãƒ©ãƒ™ãƒ«ãŒæŒ‡å®šã™ã‚‹ä½ç½®ã¨ã€é–¢é€£ã¥ã‘ã¦ã„ã‚‹ã‚‚ã®
â€”â€”ã¨ã¨ã‚‚ã«ã€å‘¼ã³å‡ºã•ã‚Œã‚‹ã ã‚ã†ã€‚
</p>

<p class="lisp"><a name="%_idx_5688"></a>(define (extract-labels text receive)
  (if (null? text)
      (receive '() '())
      (extract-labels (cdr text)
       (lambda (insts labels)
         (let ((next-inst (car text)))
           (if (symbol? next-inst)
               (receive insts
                        (cons (make-label-entry next-inst
                                                insts)
                              labels))
               (receive (cons (make-instruction next-inst)
                              insts)
                        labels)))))))
</p>

<p class="orig" lang="en"><tt>Extract-labels</tt> works by sequentially scanning the elements of
the <tt>text</tt> and accumulating the <tt>insts</tt> and the <tt>labels</tt>.
If an element is a symbol (and thus a label) an appropriate entry is
added to the <tt>labels</tt> table.  Otherwise the element is accumulated
onto the <tt>insts</tt> list.<a name="call_footnote_Temp_727" href="#footnote_Temp_727"><sup><small>4</small></sup></a></p>

<p class="trans" lang="ja">
<tt>extract-labels</tt> ã¯ã€<tt>text</tt> ã®è¦ç´ ã‚’é †ã«èµ°æŸ»ã—ã¦ <tt>insts</tt> ã¨ <tt>labels</tt> ã‚’è“„ç©ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€æ©Ÿèƒ½ã™ã‚‹ã€‚
ã‚‚ã—ã€è¦ç´ ãŒè¨˜å·ã§ã‚ã‚‹ (ã—ãŸãŒã£ã¦ãƒ©ãƒ™ãƒ«ã§ã‚ã‚‹) ãªã‚‰ã°ã€é©å®œã®ã‚¨ãƒ³ãƒˆãƒªãŒ <tt>labels</tt> ã®è¡¨ã«è¿½åŠ ã•ã‚Œã‚‹ã€‚
ãã‚Œä»¥å¤–ã®å ´åˆã¯ã€ãã®è¦ç´ ãŒ <tt>insts</tt> ã®ãƒªã‚¹ãƒˆä¸Šã«è“„ç©ã•ã‚Œã‚‹<a href="#footnote_Temp_727"><sup><small>4</small></sup></a>ã€‚
</p>

<p class="orig" lang="en">
<tt>Update-insts!</tt> modifies the instruction list, which initially
contains only the text of the instructions, to include the
corresponding execution procedures:</p>

<p class="trans" lang="ja">
<tt>update-insts!</tt> ã¯ã€å‘½ä»¤ãƒªã‚¹ãƒˆâ€”â€”æœ€åˆã¯å‘½ä»¤ã®ãƒ†ã‚­ã‚¹ãƒˆã®ã¿ã‚’å«ã‚€â€”â€”ã‚’ã€å¯¾å¿œã™ã‚‹å®Ÿè¡Œæ‰‹ç¶šãã‚’å«ã‚€ã‚ˆã†ã«å¤‰æ›´ã™ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_5702"></a>(define (update-insts! insts labels machine)
  (let ((pc (get-register machine 'pc))
        (flag (get-register machine 'flag))
        (stack (machine 'stack))
        (ops (machine 'operations)))
    (for-each
     (lambda (inst)
       (set-instruction-execution-proc! 
        inst
        (make-execution-procedure
         (instruction-text inst) labels machine
         pc flag stack ops)))
     insts)))
</p>

<p class="orig" lang="en">
The machine instruction data structure simply pairs the
instruction text with the corresponding execution procedure.
The execution procedure is not yet available when <tt>extract-labels</tt>
constructs the instruction, and is inserted later by <tt>update-insts!</tt>.
</p>

<p class="trans" lang="ja">
ãƒã‚·ãƒ³å‘½ä»¤ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã¯ã€å˜ç´”ã«ã€å‘½ä»¤ãƒ†ã‚­ã‚¹ãƒˆã‚’ã€å¯¾å¿œã™ã‚‹å®Ÿè¡Œæ‰‹ç¶šãã¨å¯¾ã«ã—ã¦ã„ã‚‹ã€‚
å®Ÿè¡Œæ‰‹ç¶šãã¯ã€<tt>extract-labels</tt> ãŒå‘½ä»¤ã‚’æ§‹ç¯‰ã™ã‚‹ã¨ãã«ã¯ã¾ã åˆ©ç”¨å¯èƒ½ã§ã¯ãªãã€å¾Œã§ <tt>update-insts!</tt> ã«ã‚ˆã£ã¦æŒ¿å…¥ã•ã‚Œã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_5704"></a>(define (make-instruction text)
  (cons text '()))
<a name="%_idx_5706"></a>(define (instruction-text inst)
  (car inst))
<a name="%_idx_5708"></a>(define (instruction-execution-proc inst)
  (cdr inst))
<a name="%_idx_5710"></a>(define (set-instruction-execution-proc! inst proc)
  (set-cdr! inst proc))
</p>

<p class="orig" lang="en">The instruction text is not used by our simulator, but it is handy to keep
around for debugging (see exercise <a href="#%_thm_5.16">5.16</a>).</p>

<p class="trans" lang="ja">
å‘½ä»¤ãƒ†ã‚­ã‚¹ãƒˆã¯ã€ç§ãŸã¡ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã«ã‚ˆã£ã¦ã¯ä½¿ã‚ã‚Œãªã„ãŒã€ãã®ã¾ã¾ã«ã—ã¦ãŠãã®ãŒãƒ‡ãƒãƒƒã‚°ã®ãŸã‚ã«ã¯ä¾¿åˆ©ã§ã‚ã‚‹ (ç·´ç¿’å•é¡Œ<a href="#%_thm_5.16">5.16</a>ã‚’å‚ç…§)ã€‚
</p>

<p class="orig" lang="en">
Elements of the label table are pairs:
</p>

<p class="trans" lang="ja">
ãƒ©ãƒ™ãƒ«è¡¨ã®è¦ç´ ã¯å¯¾ã§ã‚ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_5712"></a>(define (make-label-entry label-name insts)
  (cons label-name insts))
</p>

<p class="orig" lang="en">Entries will be looked up in the table with
</p>

<p class="trans" lang="ja">
ä»¥ä¸‹ã«ã‚ˆã‚Šã€è¡¨å†…ã«ãŠã„ã¦ã‚¨ãƒ³ãƒˆãƒªãŒèª¿ã¹ã‚‰ã‚Œã‚‹ã ã‚ã†ã€‚
</p>

<p class="lisp"><a name="%_idx_5714"></a>(define (lookup-label labels label-name)
  (let ((val (assoc label-name labels)))
    (if val
        (cdr val)
        (error &quot;Undefined label -- ASSEMBLE&quot; label-name))))
</p>

<p class="orig" lang="en">
<a name="%_thm_5.8"></a>
<b>Exercise 5.8.</b>  The following register-machine code is ambiguous, because the label
<tt>here</tt> is defined more than once:
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ5.8.</b> ä»¥ä¸‹ã®ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ»ãƒã‚·ãƒ³ãƒ»ã‚³ãƒ¼ãƒ‰ã¯ã€<tt>here</tt> ã¨ã„ã†ãƒ©ãƒ™ãƒ«ãŒä¸€åº¦ãªã‚‰ãšå®šç¾©ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€æ›–æ˜§ã§ã‚ã‚‹ã€‚
</p>

<p class="lisp">start
  (goto (label here))
here
  (assign a (const 3))
  (goto (label there))
here
  (assign a (const 4))
  (goto (label there))
there
</p>

<p class="orig" lang="en">With the simulator as written, what will the contents of register <tt>a</tt>
be when control reaches <tt>there</tt>?  Modify the <tt>extract-labels</tt>
procedure so that the assembler will signal an error if the same label
name is used to indicate two different locations.
</p>

<p class="trans" lang="ja">
æ›¸ã„ã¦ã‚ã‚‹ã‚ˆã†ãªã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã‚’ä½¿ã†ã¨ã€åˆ¶å¾¡ãŒ <tt>there</tt> ã«åˆ°é”ã—ãŸã¨ãã«ã€<tt>a</tt> ã¨ã„ã†ãƒ¬ã‚¸ã‚¹ã‚¿ã®ä¸­èº«ã¯ã©ã†ãªã‚‹ã ã‚ã†ã‹?
åŒã˜ãƒ©ãƒ™ãƒ«åãŒäºŒã¤ã®ç•°ãªã‚‹å ´æ‰€ã‚’ç¤ºã™ã®ã«ä½¿ã‚ã‚Œã¦ã„ãŸã‚‰ã€ã‚¢ã‚»ãƒ³ãƒ–ãƒ©ãŒã‚¨ãƒ©ãƒ¼ã®åˆå›³ã‚’ã‚ˆã“ã™ã‚ˆã†ã«ã€<tt>extract-labels</tt> æ‰‹ç¶šãã‚’ä¿®æ­£ã›ã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_5.2.3"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_5.2.3">5.2.3  Generating Execution Procedures for Instructions</a></h3>
<h3 class="trans" lang="ja">5.2.3 å‘½ä»¤ç”¨ã®å®Ÿè¡Œæ‰‹ç¶šãã‚’ç”Ÿæˆã™ã‚‹</h3>

<p class="orig" lang="en"><a name="%_idx_5716"></a>
The assembler calls <tt>make-execution-procedure</tt> to
generate the execution procedure for an instruction.
Like the <tt>analyze</tt> procedure in the evaluator of
section <a href="26_sec4_1.html#%_sec_4.1.7">4.1.7</a>, this dispatches on the type of
instruction to generate the appropriate execution procedure.
</p>

<p class="trans" lang="ja">
ã‚¢ã‚»ãƒ³ãƒ–ãƒ©ã¯ã€å‘½ä»¤ç”¨ã®å®Ÿè¡Œæ‰‹ç¶šãã‚’ç”Ÿæˆã™ã‚‹ãŸã‚ã«ã€<tt>make-execution-procedure</tt> ã‚’å‘¼ã³å‡ºã™ã€‚
<a href="26_sec4_1.html#%_sec_4.1.7">4.1.7</a>ç¯€ã®è©•ä¾¡å™¨ã«ãŠã‘ã‚‹ <tt>analyze</tt> æ‰‹ç¶šãã¨åŒæ§˜ã«ã€ã“ã‚Œã¯ã€é©åˆ‡ãªå®Ÿè¡Œæ‰‹ç¶šãã‚’ç”Ÿæˆã™ã‚‹ãŸã‚ã«ã€å‘½ä»¤ã®ç¨®é¡ã«åŸºã¥ã„ã¦<ruby><rb>æŒ¯ã‚Šåˆ†ã‘</rb><rp> (</rp><rt>ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒ</rt><rp>) </rp></ruby>ã‚’è¡Œã†ã€‚
</p>

<p class="lisp"><a name="%_idx_5718"></a>(define (make-execution-procedure inst labels machine
                                  pc flag stack ops)
  (cond ((eq? (car inst) 'assign)
         (make-assign inst machine labels ops pc))
        ((eq? (car inst) 'test)
         (make-test inst machine labels ops flag pc))
        ((eq? (car inst) 'branch)
         (make-branch inst machine labels flag pc))
        ((eq? (car inst) 'goto)
         (make-goto inst machine labels pc))
        ((eq? (car inst) 'save)
         (make-save inst machine stack pc))
        ((eq? (car inst) 'restore)
         (make-restore inst machine stack pc))
        ((eq? (car inst) 'perform)
         (make-perform inst machine labels ops pc))
        (else (error &quot;Unknown instruction type -- ASSEMBLE&quot;
                     inst))))
</p>

<p class="orig" lang="en">
For each type of instruction in the register-machine language, there
is a generator that builds an appropriate execution procedure.  The
details of these procedures determine both the syntax and meaning of
the individual instructions in the register-machine language.
We use data abstraction to isolate the detailed syntax of
register-machine expressions from the general execution mechanism, as
we did for evaluators in section <a href="26_sec4_1.html#%_sec_4.1.2">4.1.2</a>,
by using syntax procedures to extract and classify the parts of an instruction.</p>

<p class="trans" lang="ja">
ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ»ãƒã‚·ãƒ³è¨€èªã«ãŠã‘ã‚‹å‘½ä»¤ã®å„ç¨®é¡ã«ã¤ã„ã¦ã€é©åˆ‡ãªå®Ÿè¡Œæ‰‹ç¶šãã‚’æ§‹ç¯‰ã™ã‚‹ç”Ÿæˆå™¨ãŒã‚ã‚‹ã€‚
ã“ã‚Œã‚‰ã®æ‰‹ç¶šãã®è©³ç´°ã¯ã€ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ»ãƒã‚·ãƒ³è¨€èªã«ãŠã‘ã‚‹å€‹ã€…ã®å‘½ä»¤ã®ã€<ruby><rb>æ–‡æ³•</rb><rp> (</rp><rt>ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹</rt><rp>) </rp></ruby>ã¨æ„å‘³ã®ä¸¡æ–¹ã‚’ã€å®šã‚ã‚‹ã€‚
ç§ãŸã¡ã¯ã€ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ã‚’ç”¨ã„ã¦ã€<a href="26_sec4_1.html#%_sec_4.1.2">4.1.2</a>ç¯€ã§è©•ä¾¡å™¨ã®ãŸã‚ã«ãã†ã—ãŸã®ã¨ã¡ã‚‡ã†ã©åŒã˜ã‚ˆã†ã«ã€å‘½ä»¤ã®è«¸éƒ¨åˆ†ã‚’æŠ½å‡ºãƒ»åˆ†é¡ã™ã‚‹ãŸã‚ã®æ–‡æ³•æ‰‹ç¶šãã‚’ç”¨ã„ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ»ãƒã‚·ãƒ³ã®å¼ã®è©³ç´°ãªæ–‡æ³•ã‚’ä¸€èˆ¬çš„ãªå®Ÿè¡Œã®ä»•çµ„ã¿ã‹ã‚‰åˆ†é›¢ã™ã‚‹ã€‚
<!-- ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ»ãƒã‚·ãƒ³ã®å¼ã®è©³ç´°ãªæ–‡æ³•ã‚’ä¸€èˆ¬çš„ãªå®Ÿè¡Œã®ä»•çµ„ã¿ã‹ã‚‰åˆ†é›¢ã™ã‚‹ãŸã‚ã«ã€ç§ãŸã¡ã¯ã€<a href="26_sec4_1.html#%_sec_4.1.2">4.1.2</a>ç¯€ã§è©•ä¾¡å™¨ã®ãŸã‚ã«ãã†ã—ãŸã®ã¨ã¡ã‚‡ã†ã©åŒã˜ã‚ˆã†ã«ã€å‘½ä»¤ã®è«¸éƒ¨åˆ†ã‚’æŠ½å‡ºãƒ»åˆ†é¡ã™ã‚‹ãŸã‚ã®æ–‡æ³•æ‰‹ç¶šãã‚’ç”¨ã„ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ã‚’ç”¨ã„ã‚‹ã€‚
 -->
</p>

<a name="%_sec_Temp_729"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_729"><tt>Assign</tt> instructions</a></h4>
<h4 class="trans" lang="ja"><tt>assign</tt> å‘½ä»¤</h4>

<p class="orig" lang="en">
<a name="%_idx_5720"></a>
The <tt>make-assign</tt> procedure handles <tt>assign</tt> instructions:
</p>


<p class="trans" lang="ja">
<tt>make-assign</tt> æ‰‹ç¶šãã¯ã€<tt>assign</tt> å‘½ä»¤ã‚’æ‰±ã†ã€‚
</p>

<p class="lisp"><a name="%_idx_5722"></a>(define (make-assign inst machine labels operations pc)
  (let ((target
         (get-register machine (assign-reg-name inst)))
        (value-exp (assign-value-exp inst)))
    (let ((value-proc
           (if (operation-exp? value-exp)
               (make-operation-exp
                value-exp machine labels operations)
               (make-primitive-exp
                (car value-exp) machine labels))))
      (lambda ()                <em>; execution procedure for <tt>assign</tt></em>
        (set-contents! target (value-proc))
        (advance-pc pc)))))
</p>

<p class="orig" lang="en"><tt>Make-assign</tt> extracts the target register name (the
second element of the instruction) and the value expression
(the rest of the list that forms the instruction)
from the <tt>assign</tt> instruction using the selectors
</p>

<p class="trans" lang="ja">
<tt>make-assign</tt> ã¯ã€ç›®çš„ã®ãƒ¬ã‚¸ã‚¹ã‚¿ (å‘½ä»¤ã®2ç•ªç›®ã®è¦ç´ ) ã¨ã€å€¤ã®å¼ (å½“è©²å‘½ä»¤ã‚’å½¢æˆã—ã¦ã„ã‚‹ãƒªã‚¹ãƒˆã®æ®‹ã‚Š) ã‚’ã€ã‚»ãƒ¬ã‚¯ã‚¿ã‚’ç”¨ã„ã¦ <tt>assign</tt> ã‹ã‚‰æŠ½å‡ºã™ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_5724"></a>(define (assign-reg-name assign-instruction)
  (cadr assign-instruction))
<a name="%_idx_5726"></a>(define (assign-value-exp assign-instruction)
  (cddr assign-instruction))
</p>

<p class="orig" lang="en">The register name is looked up with <tt>get-register</tt> to produce the
target register object.  The value expression is passed to <tt>make-operation-exp</tt> if the value is the result of an operation, and to
<tt>make-primitive-exp</tt> otherwise.  These procedures (shown below)
parse the value expression and produce an execution procedure for the
value.  This is a procedure of no arguments, called <a name="%_idx_5728"></a><tt>value-proc</tt>,
which will be evaluated during the simulation to produce the actual
value to be assigned to the register.  Notice that the work of looking
up the register name and parsing the value expression is performed
just once, at assembly time, not every time the instruction is
simulated.  This saving of work is the reason we use execution
<a name="%_idx_5730"></a>procedures, and corresponds directly to the saving in work we obtained
by separating program analysis from execution in the evaluator of
section <a href="26_sec4_1.html#%_sec_4.1.7">4.1.7</a>.</p>

<p class="trans" lang="ja">
ç›®çš„ã®ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ»ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œã‚Šå‡ºã™ãŸã‚ã«ã€<tt>get-register</tt> ã‚’ä½¿ã£ã¦ãƒ¬ã‚¸ã‚¹ã‚¿åã‚’èª¿ã¹ã‚‹ã€‚
å€¤ã®å¼ã¯ã€ã‚‚ã—ãã®å€¤ãŒæ¼”ç®—ã®çµæœãªã‚‰ã€<tt>make-operation-exp</tt> ã¸ã¨æ¸¡ã•ã‚Œã€ãã‚Œä»¥å¤–ã®å ´åˆã¯ã€<tt>make-primitive-exp</tt> ã¸ã¨æ¸¡ã•ã‚Œã‚‹ã€‚
ã“ã‚Œã‚‰ã®æ‰‹ç¶šã (ä»¥ä¸‹ã«ç¤ºã—ã¦ã‚ã‚‹) ã¯ã€å€¤ã®å¼ã‚’æ§‹æ–‡è§£æã—ã¦ã€ãã®å€¤ã«ã¤ã„ã¦ã®å®Ÿè¡Œæ‰‹ç¶šãã‚’ä½œã‚Šå‡ºã™ã€‚
ã“ã‚Œã¯ã€å¼•æ•°ãªã—ã®æ‰‹ç¶šãã§ã€<tt>value-proc</tt> ã¨å‘¼ã°ã‚Œã‚‹ã®ã ãŒã€ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®é–“ã«è©•ä¾¡ã•ã‚Œã¦ã€ãƒ¬ã‚¸ã‚¹ã‚¿ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚Œã‚‹ã¹ãå®Ÿéš›ã®å€¤ã‚’ç”Ÿã¿å‡ºã™ã“ã¨ã«ãªã‚‹ã ã‚ã†ã€‚
ãƒ¬ã‚¸ã‚¹ã‚¿åã‚’èª¿ã¹ã¦å€¤ã®å¼ã‚’æ§‹æ–‡è§£æã™ã‚‹ã¨ã„ã†ä½œæ¥­ãŒã€ãŸã ä¸€åº¦ã ã‘â€”â€”ã¤ã¾ã‚Šã€ã‚¢ã‚»ãƒ³ãƒ–ãƒ«ã™ã‚‹ã¨ãã«â€”â€”è¡Œã‚ã‚Œã‚‹ã®ã§ã‚ã£ã¦ã€å‘½ä»¤ãŒã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã•ã‚Œã‚‹ãŸã³ã«è¡Œã‚ã‚Œã‚‹ã®ã§ã¯ãªã„ã€ã¨ã„ã†ã“ã¨ã«æ³¨æ„ã—ã¦ã»ã—ã„ã€‚
ã“ã†ã—ãŸä½œæ¥­ã®ç¯€ç´„ã¯ã€ç§ãŸã¡ãŒå®Ÿè¡Œæ‰‹ç¶šãã‚’ä½¿ã†ç†ç”±ã§ã‚ã‚‹ã€‚ã¾ãŸã€<a href="26_sec4_1.html#%_sec_4.1.7">4.1.7</a>ç¯€ã®è©•ä¾¡å™¨ã«ãŠã„ã¦ã€å®Ÿè¡Œã‹ã‚‰ãƒ—ãƒ­ã‚°ãƒ©ãƒ åˆ†æã‚’åˆ†é›¢ã™ã‚‹ã“ã¨ã§å¾—ãŸã€ä½œæ¥­ä¸Šã®ç¯€ç´„ã«ã€ç›´æ¥çš„ã«å¯¾å¿œã—ã¦ã„ã‚‹ã€‚
</p>

<p class="orig" lang="en">
The result returned by <tt>make-assign</tt> is the execution
procedure for the <tt>assign</tt> instruction.  When this procedure is
called (by the machine model's <tt>execute</tt> procedure),
it sets the contents of the target register to the result
obtained by executing <tt>value-proc</tt>.  Then it advances
the <tt>pc</tt> to the next instruction by running the procedure
</p>


<p class="trans" lang="ja">
<tt>make-assign</tt> ã«ã‚ˆã‚Šè¿”ã•ã‚Œã‚‹çµæœã¯ã€<tt>assign</tt> å‘½ä»¤ã«å¯¾ã™ã‚‹å®Ÿè¡Œæ‰‹ç¶šãã§ã‚ã‚‹ã€‚
ã“ã®æ‰‹ç¶šãã¯ã€(ãƒã‚·ãƒ³ãƒ»ãƒ¢ãƒ‡ãƒ«ã® <tt>execute</tt> æ‰‹ç¶šãã«ã‚ˆã£ã¦) å‘¼ã³å‡ºã•ã‚Œã‚‹ã¨ã€ç›®çš„ã®ãƒ¬ã‚¸ã‚¹ã‚¿ã®ä¸­èº«ã‚’ã€<tt>value-proc</tt> ã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ã§å¾—ã‚‰ã‚ŒãŸçµæœã«è¨­å®šã™ã‚‹ã€‚
ãã‚Œã‹ã‚‰ã€ã“ã®æ‰‹ç¶šãã¯ã€ä»¥ä¸‹ã®æ‰‹ç¶šãã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€<tt>pc</tt> ã‚’æ¬¡ã®å‘½ä»¤ã¸ã¨é€²ã‚ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_5732"></a>(define (advance-pc pc)
  (set-contents! pc (cdr (get-contents pc))))
</p>

<p class="orig" lang="en"><tt>Advance-pc</tt> is the normal termination for all instructions except
<tt>branch</tt> and <tt>goto</tt>.</p>

<p class="trans" lang="ja">
<tt>advance-pc</tt> ã¯ã€<tt>branch</tt> ã¨ <tt>goto</tt> ã‚’é™¤ãã™ã¹ã¦ã®å‘½ä»¤ã«å¯¾ã™ã‚‹ã€æ­£å¸¸ãªçµ‚äº†ã§ã‚ã‚‹ã€‚
</p>

<a name="%_sec_Temp_730"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_730"><tt>Test</tt>, <tt>branch</tt>, and <tt>goto</tt> instructions</a></h4>
<h4 class="trans" lang="ja"><tt>test</tt> å‘½ä»¤ã¨ <tt>branch</tt> å‘½ä»¤ã¨ <tt>goto</tt> å‘½ä»¤</h4>

<p class="orig" lang="en">
<a name="%_idx_5734"></a><tt>Make-test</tt> handles <tt>test</tt> instructions in a similar way.  It
extracts the expression that specifies the condition to be tested and
generates an execution procedure for it.  At simulation time, the
procedure for the condition is called, the result is assigned to the
<tt>flag</tt> register, and the <tt>pc</tt> is advanced:
</p>

<p class="trans" lang="ja">
<tt>make-test</tt> ã¯ <tt>test</tt> å‘½ä»¤ã‚’é¡ä¼¼ã®æ–¹æ³•ã§æ‰±ã†ã€‚
<tt>make-test</tt> ã¯ã€æ¤œæŸ»ã™ã¹ãæ¡ä»¶ã‚’æŒ‡å®šã™ã‚‹å¼ã‚’æŠ½å‡ºã—ã€ãã®å¼ã«å¯¾ã™ã‚‹å®Ÿè¡Œæ‰‹ç¶šãã‚’ç”Ÿæˆã™ã‚‹ã€‚
ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®ã¨ãã«ã¯ã€ãã®æ¡ä»¶ã«å¯¾ã™ã‚‹æ‰‹ç¶šããŒå‘¼ã°ã‚Œã€çµæœãŒ <tt>flag</tt> ãƒ¬ã‚¸ã‚¹ã‚¿ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚Œã€<tt>pc</tt> ãŒé€²ã‚ã‚‰ã‚Œã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_5736"></a>(define (make-test inst machine labels operations flag pc)
  (let ((condition (test-condition inst)))
    (if (operation-exp? condition)
        (let ((condition-proc
               (make-operation-exp
                condition machine labels operations)))
          (lambda ()
            (set-contents! flag (condition-proc))
            (advance-pc pc)))
        (error &quot;Bad TEST instruction -- ASSEMBLE&quot; inst))))
<a name="%_idx_5738"></a>(define (test-condition test-instruction)
  (cdr test-instruction))
</p>

<p class="orig" lang="en">
<a name="%_idx_5740"></a>The execution procedure for a <tt>branch</tt> instruction checks the
contents of the <tt>flag</tt> register and either sets the contents of
the <tt>pc</tt> to the branch destination (if the branch is taken) or
else just advances the <tt>pc</tt> (if the branch is not taken).  Notice
that the indicated destination in a <tt>branch</tt> instruction must be a
label, and the <tt>make-branch</tt> procedure enforces this.  Notice
also that the label is looked up at assembly time, not each time the
<tt>branch</tt> instruction is simulated.</p>

<p class="trans" lang="ja">
<tt>branch</tt> å‘½ä»¤ã«å¯¾ã™ã‚‹å®Ÿè¡Œæ‰‹ç¶šãã¯ã€<tt>flag</tt> ãƒ¬ã‚¸ã‚¹ã‚¿ã®ä¸­èº«ã‚’èª¿ã¹ã€(åˆ†å²ãŒè¡Œã‚ã‚Œã‚‹å ´åˆã«) <tt>pc</tt> ã®ä¸­èº«ã‚’åˆ†å²å…ˆã«è¨­å®šã™ã‚‹ã‹ã€ã¾ãŸã¯ã€(åˆ†å²ãŒè¡Œã‚ã‚Œãªã„å ´åˆã«) ãŸã å˜ã« <tt>pc</tt> ã‚’é€²ã‚ã‚‹ã€‚
<tt>branch</tt> å‘½ä»¤ã«ãŠã„ã¦ç¤ºã•ã‚Œã‚‹è¡Œãå…ˆãŒãƒ©ãƒ™ãƒ«ã§ãªãã¦ã¯ãªã‚‰ãªã„ã“ã¨ã¨ã€<tt>make-branch</tt> æ‰‹ç¶šããŒã“ã®ã“ã¨ã‚’éµå®ˆã•ã›ã‚‹ã“ã¨ã«ã€æ³¨æ„ã—ã¦ã»ã—ã„ã€‚
ã¾ãŸã€ãã®ãƒ©ãƒ™ãƒ«ã¯ã‚¢ã‚»ãƒ³ãƒ–ãƒ«ã‚’è¡Œã†ã¨ãã«èª¿ã¹ã‚‰ã‚Œã‚‹ã®ã§ã‚ã£ã¦ã€<tt>branch</tt> å‘½ä»¤ãŒã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã•ã‚Œã‚‹ãŸã³ã«èª¿ã¹ã‚‰ã‚Œã‚‹ã®ã§ã¯ãªã„ã€ã¨ã„ã†ã“ã¨ã«ã‚‚æ³¨æ„ã—ã¦ã»ã—ã„ã€‚
</p>

<p class="lisp"><a name="%_idx_5742"></a>(define (make-branch inst machine labels flag pc)
  (let ((dest (branch-dest inst)))
    (if (label-exp? dest)
        (let ((insts
               (lookup-label labels (label-exp-label dest))))
          (lambda ()
            (if (get-contents flag)
                (set-contents! pc insts)
                (advance-pc pc))))
        (error &quot;Bad BRANCH instruction -- ASSEMBLE&quot; inst))))
<a name="%_idx_5744"></a>(define (branch-dest branch-instruction)
  (cadr branch-instruction))
</p>

<p class="orig" lang="en">
<a name="%_idx_5746"></a>A <tt>goto</tt> instruction is similar to a branch, except that the
destination may be specified either as a label or as a register, and
there is no condition to check -- the <tt>pc</tt> is always set to the
new destination.
</p>


<p class="trans" lang="ja">
<tt>goto</tt> å‘½ä»¤ã¯ã€è¡Œãå…ˆãŒãƒ©ãƒ™ãƒ«ã‹ãƒ¬ã‚¸ã‚¹ã‚¿ã®ã„ãšã‚Œã‹ã¨ã—ã¦æŒ‡å®šã•ã‚Œå¾—ã‚‹ã¨ã„ã†ç‚¹ã¨ã€æ¤œæŸ»ã™ã¹ãæ¡ä»¶ãŒå­˜åœ¨ã—ãªã„â€”â€”ã¤ã¾ã‚Šã€<tt>pc</tt> ãŒå¸¸ã«æ–°ãŸãªè¡Œãå…ˆã«è¨­å®šã•ã‚Œã‚‹â€”â€”ã¨ã„ã†ç‚¹ã‚’é™¤ã„ã¦ã€åˆ†å²ã¨åŒæ§˜ã§ã‚ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_5748"></a>(define (make-goto inst machine labels pc)
  (let ((dest (goto-dest inst)))
    (cond ((label-exp? dest)
           (let ((insts
                  (lookup-label labels
                                (label-exp-label dest))))
             (lambda () (set-contents! pc insts))))
          ((register-exp? dest)
           (let ((reg
                  (get-register machine
                                (register-exp-reg dest))))
             (lambda ()
               (set-contents! pc (get-contents reg)))))
          (else (error &quot;Bad GOTO instruction -- ASSEMBLE&quot;
                       inst)))))
<a name="%_idx_5750"></a>(define (goto-dest goto-instruction)
  (cadr goto-instruction))
</p>

<a name="%_sec_Temp_731"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_731">Other instructions</a></h4>
<h4 class="trans" lang="ja">ãã®ä»–ã®å‘½ä»¤</h4>

<p class="orig" lang="en">
The stack instructions <tt>save</tt> and <tt>restore</tt> simply use the
stack with the designated register and advance the <tt>pc</tt>:
</p>

<p class="trans" lang="ja">
<tt>save</tt> ãŠã‚ˆã³ <tt>restore</tt> ã¨ã„ã†ã‚¹ã‚¿ãƒƒã‚¯å‘½ä»¤ã¯ã€å˜ç´”ã«ã€æŒ‡å®šã•ã‚ŒãŸãƒ¬ã‚¸ã‚¹ã‚¿ã¨ã¨ã‚‚ã«ã‚¹ã‚¿ãƒƒã‚¯ã‚’ç”¨ã„ã€<tt>pc</tt> ã‚’é€²ã‚ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_5752"></a><a name="%_idx_5754"></a>(define (make-save inst machine stack pc)
  (let ((reg (get-register machine
                           (stack-inst-reg-name inst))))
    (lambda ()
      (push stack (get-contents reg))
      (advance-pc pc))))
<a name="%_idx_5756"></a><a name="%_idx_5758"></a>(define (make-restore inst machine stack pc)
  (let ((reg (get-register machine
                           (stack-inst-reg-name inst))))
    (lambda ()
      (set-contents! reg (pop stack))    
      (advance-pc pc))))
<a name="%_idx_5760"></a>(define (stack-inst-reg-name stack-instruction)
  (cadr stack-instruction))
</p>

<p class="orig" lang="en">
<a name="%_idx_5762"></a>The final instruction type, handled by <tt>make-perform</tt>, generates
an execution procedure for the action to be performed.  At simulation
time, the action procedure is executed and the <tt>pc</tt> advanced.
</p>


<p class="trans" lang="ja">
æœ€å¾Œã®å‘½ä»¤ã‚¿ã‚¤ãƒ—ã¯ã€<tt>make-perform</tt> ã«ã‚ˆã‚Šæ‰±ã‚ã‚Œã‚‹ã‚‚ã®ãªã®ã ãŒã€ã“ã‚Œã¯ã€è¡Œã‚ã‚Œã‚‹ã¹ãå‹•ä½œã«ã¤ã„ã¦ã®å®Ÿè¡Œæ‰‹ç¶šãã‚’ç”Ÿæˆã™ã‚‹ã€‚
ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®ã¨ãã«ã¯ã€å‹•ä½œæ‰‹ç¶šããŒå®Ÿè¡Œã•ã‚Œã€<tt>pc</tt> ãŒé€²ã‚ã‚‰ã‚Œã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_5764"></a>(define (make-perform inst machine labels operations pc)
  (let ((action (perform-action inst)))
    (if (operation-exp? action)
        (let ((action-proc
               (make-operation-exp
                action machine labels operations)))
          (lambda ()
            (action-proc)
            (advance-pc pc)))
        (error &quot;Bad PERFORM instruction -- ASSEMBLE&quot; inst))))
<a name="%_idx_5766"></a>(define (perform-action inst) (cdr inst))
</p>

<a name="%_sec_Temp_732"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_732">Execution procedures for subexpressions</a></h4>
<h4 class="trans" lang="ja">éƒ¨åˆ†å¼ã«ã¤ã„ã¦ã®å®Ÿè¡Œæ‰‹ç¶šã</h4>

<p class="orig" lang="en">
<a name="%_idx_5768"></a><a name="%_idx_5770"></a><a name="%_idx_5772"></a>The value of a <tt>reg</tt>, <tt>label</tt>, or <tt>const</tt> expression
may be needed for assignment to a register (<tt>make-assign</tt>) or for input to
an operation (<tt>make-operation-exp</tt>, below).  The following procedure
generates execution procedures to produce values for these expressions
during the simulation:
</p>

<p class="trans" lang="ja">
<tt>reg</tt> å¼ã€<tt>label</tt> å¼ã€ã¾ãŸã¯ <tt>const</tt> å¼ã®å€¤ãŒã€ãƒ¬ã‚¸ã‚¹ã‚¿ã¸ã®å‰²ã‚Šå½“ã¦ã®ãŸã‚ã« (<tt>make-assign</tt>)ã€ã¾ãŸã¯ã€æ¼”ç®—ã¸ã®å…¥åŠ›ã®ãŸã‚ã« (ä»¥ä¸‹ã® <tt>make-operation-exp</tt>)ã€å¿…è¦ã¨ã•ã‚Œã‚‹ã“ã¨ãŒã‚ã‚‹ã€‚
ã“ã‚Œã‚‰ã®å¼ã«ã¤ã„ã¦ã®å€¤ã‚’ã€ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®é–“ã«ç”Ÿã¿å‡ºã™ãŸã‚ã®å®Ÿè¡Œæ‰‹ç¶šãã‚’ã€ä»¥ä¸‹ã®æ‰‹ç¶šããŒç”Ÿæˆã™ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_5774"></a>(define (make-primitive-exp exp machine labels)
  (cond ((constant-exp? exp)
         (let ((c (constant-exp-value exp)))
           (lambda () c)))
        ((label-exp? exp)
         (let ((insts
                (lookup-label labels
                              (label-exp-label exp))))
           (lambda () insts)))
        ((register-exp? exp)
         (let ((r (get-register machine
                                (register-exp-reg exp))))
           (lambda () (get-contents r))))
        (else
         (error &quot;Unknown expression type -- ASSEMBLE&quot; exp))))
</p>

<p class="orig" lang="en">The syntax of <tt>reg</tt>, <tt>label</tt>, and <tt>const</tt> expressions
is determined by
</p>


<p class="trans" lang="ja">
<tt>reg</tt> å¼ã¨ <tt>label</tt> å¼ã¨ <tt>const</tt> å¼ã®æ–‡æ³•ã¯ã€ä»¥ä¸‹ã«ã‚ˆã‚Šå®šã‚ã‚‰ã‚Œã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_5776"></a>(define (register-exp? exp) (tagged-list? exp 'reg))
<a name="%_idx_5778"></a>(define (register-exp-reg exp) (cadr exp))
<a name="%_idx_5780"></a>(define (constant-exp? exp) (tagged-list? exp 'const))
<a name="%_idx_5782"></a>(define (constant-exp-value exp) (cadr exp))
<a name="%_idx_5784"></a>(define (label-exp? exp) (tagged-list? exp 'label))
<a name="%_idx_5786"></a>(define (label-exp-label exp) (cadr exp))
</p>

<p class="orig" lang="en">
<a name="%_idx_5788"></a><tt>Assign</tt>, <tt>perform</tt>, and <tt>test</tt> instructions
may include the application of a machine operation (specified by
an <tt>op</tt> expression) to some operands (specified by <tt>reg</tt>
and <tt>const</tt> expressions).
The following procedure produces an execution procedure
for an ``operation expression'' -- a list containing the operation and
operand expressions from the instruction:
</p>

<p class="trans" lang="ja">
<tt>assign</tt> å‘½ä»¤ã¨ <tt>perform</tt> å‘½ä»¤ã¨ <tt>test</tt> å‘½ä»¤ã¯ã€(<tt>op</tt> å¼ã«ã‚ˆã‚ŠæŒ‡å®šã•ã‚Œã‚‹) ãƒã‚·ãƒ³æ¼”ç®—ã®ã€(<tt>reg</tt> å¼ã‚„ <tt>const</tt> å¼ã«ã‚ˆã‚ŠæŒ‡å®šã•ã‚Œã‚‹) ä½•ã‚‰ã‹ã®ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã¸ã®é©ç”¨ã‚’ã€å«ã‚€ã“ã¨ãŒã‚ã‚‹ã€‚
ä»¥ä¸‹ã®æ‰‹ç¶šãã¯ã€ã€Œæ¼”ç®—å¼ã€ç”¨ã®å®Ÿè¡Œæ‰‹ç¶šãâ€”â€”å‘½ä»¤ã‹ã‚‰ã®ã€æ¼”ç®—ã¨ã‚ªãƒšãƒ©ãƒ³ãƒ‰å¼ã¨ã‚’å«ã‚€ãƒªã‚¹ãƒˆâ€”â€”ã‚’ä½œã‚Šå‡ºã™ã€‚
</p>

<p class="lisp"><a name="%_idx_5790"></a>(define (make-operation-exp exp machine labels operations)
  (let ((op (lookup-prim (operation-exp-op exp) operations))
        (aprocs
         (map (lambda (e)
                (make-primitive-exp e machine labels))
              (operation-exp-operands exp))))
    (lambda ()
      (apply op (map (lambda (p) (p)) aprocs)))))
</p>

<p class="orig" lang="en">The syntax of operation expressions is determined by
</p>

<p class="trans" lang="ja">
æ¼”ç®—å¼ã®æ–‡æ³•ã¯ã€ä»¥ä¸‹ã«ã‚ˆã‚Šå®šã‚ã‚‰ã‚Œã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_5792"></a>(define (operation-exp? exp)
  (and (pair? exp) (tagged-list? (car exp) 'op)))
<a name="%_idx_5794"></a>(define (operation-exp-op operation-exp)
  (cadr (car operation-exp)))
<a name="%_idx_5796"></a>(define (operation-exp-operands operation-exp)
  (cdr operation-exp))
</p>

<p class="orig" lang="en">Observe that the treatment of operation expressions is very much like
the treatment of procedure applications by the <tt>analyze-application</tt> procedure in the evaluator of
section <a href="26_sec4_1.html#%_sec_4.1.7">4.1.7</a> in that we generate an execution
procedure for each operand.  At simulation time, we call the
operand procedures and apply the Scheme procedure that simulates
the operation to the resulting values.
The simulation procedure is found by looking up the operation name in
the operation table for the machine:
</p>

<p class="trans" lang="ja">
å„ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã«ã¤ã„ã¦å®Ÿè¡Œæ‰‹ç¶šãã‚’ç”Ÿæˆã™ã‚‹ã€ã¨ã„ã†ç‚¹ã«ãŠã„ã¦ã€æ¼”ç®—å¼ã®æ‰±ã„ã¯ã€<a href="26_sec4_1.html#%_sec_4.1.7">4.1.7</a>ç¯€ã®è©•ä¾¡å™¨ã«ãŠã‘ã‚‹ <tt>analyze-application</tt> æ‰‹ç¶šãã«ã‚ˆã‚‹æ‰‹ç¶šãé©ç”¨ã®æ‰±ã„ã¨ã€éå¸¸ã«ã‚ˆãä¼¼ã¦ã„ã‚‹ã€‚
ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®ã¨ãã«ã¯ã€ã‚ªãƒšãƒ©ãƒ³ãƒ‰æ‰‹ç¶šãã‚’å‘¼ã³å‡ºã—ã€ãã—ã¦ã€ãã®çµæœã¨ã—ã¦ç”Ÿã˜ã‚‹å€¤ã«ã€å½“è©²æ¼”ç®—ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã™ã‚‹Schemeæ‰‹ç¶šãã‚’é©ç”¨ã™ã‚‹ã€‚
ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ‰‹ç¶šãã¯ã€å½“è©²ãƒã‚·ãƒ³ç”¨ã®æ¼”ç®—è¡¨ã«ãŠã„ã¦æ¼”ç®—åã‚’èª¿ã¹ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€è¦‹ã¤ã‹ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_5798"></a>(define (lookup-prim symbol operations)
  (let ((val (assoc symbol operations)))
    (if val
        (cadr val)
        (error &quot;Unknown operation -- ASSEMBLE&quot; symbol))))
</p>

<p class="orig" lang="en">
<a name="%_thm_5.9"></a>
<b>Exercise 5.9.</b>  The treatment of machine operations above permits them to operate
on labels as well as on constants and the contents of registers.
Modify the expression-processing procedures to enforce the condition
that operations can be used only with registers and constants.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ5.9.</b> ä¸Šè¨˜ã®ãƒã‚·ãƒ³æ¼”ç®—ã®å–ã‚Šæ‰±ã„ã«ã‚ˆã£ã¦ã€ã“ã‚Œã‚‰ãƒã‚·ãƒ³æ¼”ç®—ãŒå®šæ•°ã‚„ãƒ¬ã‚¸ã‚¹ã‚¿ã®ä¸­èº«ã«å¯¾ã—ã¦å‹•ä½œã™ã‚‹ã®ã¨åŒæ§˜ã«ã€ãƒ©ãƒ™ãƒ«ã«å¯¾ã—ã¦ã‚‚å‹•ä½œã™ã‚‹ã“ã¨ãŒå¯èƒ½ã¨ãªã‚‹ã€‚
ãƒ¬ã‚¸ã‚¹ã‚¿ãŠã‚ˆã³å®šæ•°ã¨ã ã‘æ¼”ç®—ã‚’ä½¿ãˆã‚‹ã€ã¨ã„ã†æ¡ä»¶ã‚’å¼·åˆ¶ã™ã‚‹ã‚ˆã†ã«ã€å¼ã‚’å‡¦ç†ã™ã‚‹æ‰‹ç¶šãã‚’æ”¹å¤‰ã›ã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.10"></a>
<b>Exercise 5.10.</b>  Design a new syntax for register-machine instructions and modify the
simulator to use your new syntax.  Can you implement your new
syntax without changing any part of the simulator except the
syntax procedures in this section?
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ5.10.</b> ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ»ãƒã‚·ãƒ³å‘½ä»¤ã®ãŸã‚ã®æ–°ãŸãªæ–‡æ³•ã‚’è¨­è¨ˆã—ã€å›ã®æ–°ãŸãªæ–‡æ³•ã‚’ä½¿ã†ã‚ˆã†ã«ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã‚’æ”¹å¤‰ã›ã‚ˆã€‚
æœ¬ç¯€ã®æ–‡æ³•æ‰‹ç¶šãä»¥å¤–ã¯ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã®ã©ã®éƒ¨åˆ†ã‚‚å¤‰æ›´ã—ãªã„ã§ã€å›ã®æ–°ãŸãªæ–‡æ³•ã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã‹ã„?
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.11"></a>
<b>Exercise 5.11.</b>  <a name="%_idx_5800"></a><a name="%_idx_5802"></a>When we introduced <tt>save</tt> and <tt>restore</tt> in
section <a href="31_sec5_1.html#%_sec_5.1.4">5.1.4</a>, we didn't specify what would happen
if you tried to restore a register that was not the last one saved, as
in the sequence</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ5.11.</b> ä»¥ä¸‹ã®ã‚ˆã†ãªä¸¦ã³ã«ãŠã‘ã‚‹ã€é€€é¿ã•ã‚ŒãŸæœ€å¾Œã®ãƒ¬ã‚¸ã‚¹ã‚¿ã§ã¯ãªã„ãƒ¬ã‚¸ã‚¹ã‚¿ã‚’å¾©å…ƒã—ã‚ˆã†ã¨ã—ãŸå ´åˆã«ã€ä½•ãŒèµ·ã“ã‚‹ã ã‚ã†ã‹ã¨ã„ã†ã“ã¨ã‚’ã€ç§ãŸã¡ã¯ã€<a href="31_sec5_1.html#%_sec_5.1.4">5.1.4</a>ç¯€ã§ <tt>save</tt> ã¨ <tt>restore</tt> ã‚’å°å…¥ã—ãŸã¨ãã«ã¯è¦å®šã—ãªã‹ã£ãŸã€‚
</p>

<p class="lisp">(save y)
(save x)
(restore y)
</p>

<p class="orig" lang="en">There are several reasonable possibilities for the meaning of <tt>restore</tt>:</p>

<p class="trans" lang="ja">
<tt>restore</tt> ã®æ„å‘³ã«ã¤ã„ã¦ã¯ã€ç­‹ã®é€šã£ãŸå¯èƒ½æ€§ãŒã„ãã¤ã‹ã‚ã‚‹ã€‚
</p>

<ol class="orig alph" lang="en">
<li><tt>(restore y)</tt> puts into <tt>y</tt> the last value saved on the
stack, regardless of what register that value came from.  This is the
way our simulator behaves.  Show how to take advantage of this
behavior to eliminate one instruction from the Fibonacci machine of
section <a href="31_sec5_1.html#%_sec_5.1.4">5.1.4</a> (figure <a href="31_sec5_1.html#%_fig_5.12">5.12</a>).</li>

<li><tt>(restore y)</tt> puts into <tt>y</tt> the last value saved on the
stack, but only if that value was saved from <tt>y</tt>; otherwise, it
signals an error.  Modify the simulator to behave this way.  You will
have to change <tt>save</tt> to put the register name on the stack along
with the value.</li>

<li><tt>(restore y)</tt> puts into <tt>y</tt> the last value saved from <tt>y</tt> regardless of what other registers were saved after <tt>y</tt> and not
restored.  Modify the simulator to behave this way.  You will have to
associate a separate stack with each register.  You should make the
<tt>initialize-stack</tt> operation initialize all the register stacks.</li>
</ol>

<ol class="trans alph" lang="ja">
<li><tt>(restore y)</tt> ã¯ã€ã‚¹ã‚¿ãƒƒã‚¯ä¸Šã«é€€é¿ã•ã‚ŒãŸæœ€å¾Œã®å€¤ã‚’ã€ãã®å€¤ãŒã©ã®ãƒ¬ã‚¸ã‚¹ã‚¿ã«ç”±æ¥ã™ã‚‹ã‹ã«ã‚ˆã‚‰ãšã€ã¨ã«ã‹ã <tt>y</tt> ã«å…¥ã‚Œã‚‹ã€‚
ã“ã‚Œã¯ã€ç§ãŸã¡ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã®æŒ¯ã‚‹èˆã„æ–¹ã§ã‚ã‚‹ã€‚
ã“ã®æŒ¯ã‚‹èˆã„ã‚’åˆ©ç”¨ã—ã¦ <a href="31_sec5_1.html#%_sec_5.1.4">5.1.4</a>ç¯€ (å›³<a href="31_sec5_1.html#%_fig_5.12">5.12</a>) ã®ãƒ•ã‚£ãƒœãƒŠãƒƒãƒãƒ»ãƒã‚·ãƒ³ã‹ã‚‰å‘½ä»¤ã‚’ä¸€ã¤å‰Šé™¤ã™ã‚‹æ–¹æ³•ã‚’ç¤ºã›ã€‚</li>
<li><tt>(restore y)</tt> ã¯ã€ã‚¹ã‚¿ãƒƒã‚¯ä¸Šã«é€€é¿ã•ã‚ŒãŸæœ€å¾Œã®å€¤ã‚’ <tt>y</tt> ã«å…¥ã‚Œã‚‹ã®ã ãŒã€ãã‚Œã¯ã€ãã®å€¤ãŒ <tt>y</tt> ã‹ã‚‰é€€é¿ã•ã‚ŒãŸå ´åˆã®ã¿ã§ã‚ã‚Šã€ãã‚Œä»¥å¤–ã®å ´åˆã«ã¯ã€ã‚¨ãƒ©ãƒ¼ã‚’çŸ¥ã‚‰ã›ã‚‹ã€‚
ã“ã®ã‚ˆã†ã«æŒ¯ã‚‹èˆã†ã‚ˆã†ã«ã€ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã‚’æ”¹å¤‰ã›ã‚ˆã€‚
å›ã¯ã€å€¤ã¨ã¨ã‚‚ã«ãƒ¬ã‚¸ã‚¹ã‚¿åã‚’ã‚¹ã‚¿ãƒƒã‚¯ä¸Šã«ç½®ãã‚ˆã†ã« <tt>save</tt> ã‚’å¤‰æ›´ã—ãªãã¦ã¯ãªã‚‰ãªã„ã ã‚ã†ã€‚</li>
<li><tt>(restore y)</tt> ã¯ã€ä»–ã®ã©ã®ãƒ¬ã‚¸ã‚¹ã‚¿ãŒ <tt>y</tt> ã®å¾Œã«é€€é¿ã•ã‚Œã€ã‹ã¤ã€å¾©å…ƒã•ã‚Œã¦ã„ãªã„ã®ã‹ã€ã¨ã„ã†ã“ã¨ã«ã‚ˆã‚‰ãšã€<tt>y</tt> ã‹ã‚‰é€€é¿ã•ã‚ŒãŸæœ€å¾Œã®å€¤ã‚’ <tt>y</tt> ã«å…¥ã‚Œã‚‹ã€‚
ã“ã®ã‚ˆã†ã«æŒ¯ã‚‹èˆã†ã‚ˆã†ã«ã€ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã‚’æ”¹å¤‰ã›ã‚ˆã€‚
å›ã¯ã€åˆ¥ã€…ã®ã‚¹ã‚¿ãƒƒã‚¯ã‚’å„ãƒ¬ã‚¸ã‚¹ã‚¿ã¨é–¢é€£ã¥ã‘ãªãã¦ã¯ãªã‚‰ãªã„ã ã‚ã†ã€‚
å›ã¯ã€<tt>initialize-stack</tt> æ¼”ç®—ã«ã€ã™ã¹ã¦ã®ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ»ã‚¹ã‚¿ãƒƒã‚¯ã‚’åˆæœŸåŒ–ã•ã›ã‚‹ã¹ãã§ã‚ã‚‹ã€‚</li>
</ol>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.12"></a>
<b>Exercise 5.12.</b>  The simulator can be used to help determine the data paths required
for implementing a machine with a given controller.  Extend
the assembler to store the following information in the machine model:
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ5.12.</b> ä¸ãˆã‚‰ã‚ŒãŸã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ã‚’æœ‰ã™ã‚‹ãƒã‚·ãƒ³ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã«å¿…è¦ã¨ã•ã‚Œã‚‹ãƒ‡ãƒ¼ã‚¿çµŒè·¯ã‚’æ±ºå®šã™ã‚‹ã®ã‚’æ‰‹åŠ©ã‘ã™ã‚‹ãŸã‚ã«ã€ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãŒä½¿ãˆã‚‹ã€‚
ãƒã‚·ãƒ³ãƒ»ãƒ¢ãƒ‡ãƒ«å†…ã«ä»¥ä¸‹ã®æƒ…å ±ã‚’æ ¼ç´ã™ã‚‹ã‚ˆã†ã€ã‚¢ã‚»ãƒ³ãƒ–ãƒ©ã‚’æ‹¡å¼µã›ã‚ˆã€‚
</p>

<ul class="orig" lang="en">
<li>a list of all instructions, with duplicates removed, sorted by
instruction type (<tt>assign</tt>, <tt>goto</tt>, and so on);</li>

<li>a list (without duplicates) of the registers used to hold entry
points (these are the registers referenced by <tt>goto</tt>
instructions);</li>

<li>a list (without duplicates) of the registers that are <tt>save</tt>d
or <tt>restore</tt>d;</li>

<li>for each register, a list (without duplicates) of the sources from
which it is assigned (for example, the sources for register <tt>val</tt>
in the factorial machine of figure <a href="31_sec5_1.html#%_fig_5.11">5.11</a> are
<tt>(const 1)</tt> and <tt>((op *) (reg n) (reg val))</tt>).</li>
</ul>

<ul class="trans" lang="ja">
<li>ã™ã¹ã¦ã®å‘½ä»¤ã®ãƒªã‚¹ãƒˆâ€”â€”ãŸã ã—é‡è¤‡ã‚’é™¤ã„ãŸã‚‚ã®â€”â€”ã§ã‚ã£ã¦ã€å‘½ä»¤ç¨®åˆ¥ (<tt>assign</tt> ã‚„ <tt>goto</tt> ãªã©) ã«ã‚ˆã‚Šã‚½ãƒ¼ãƒˆã•ã‚ŒãŸã‚‚ã®ã€‚</li>
<li>ã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒã‚¤ãƒ³ãƒˆã‚’ä¿æŒã™ã‚‹ã®ã«ä½¿ã‚ã‚Œã‚‹ãƒ¬ã‚¸ã‚¹ã‚¿ (ã“ã‚Œã‚‰ã¯ <tt>goto</tt> å‘½ä»¤ã«ã‚ˆã‚Šå‚ç…§ã•ã‚Œã‚‹ãƒ¬ã‚¸ã‚¹ã‚¿ã§ã‚ã‚‹) ã® (é‡è¤‡ãªã—ã®) ãƒªã‚¹ãƒˆã€‚</li>
<li><tt>save</tt> ã¾ãŸã¯ <tt>restore</tt> ã•ã‚Œã‚‹ãƒ¬ã‚¸ã‚¹ã‚¿ã® (é‡è¤‡ãªã—ã®) ãƒªã‚¹ãƒˆã€‚</li>
<li>å„ãƒ¬ã‚¸ã‚¹ã‚¿ã«ã¤ã„ã¦ã®ã€å½“è©²ãƒ¬ã‚¸ã‚¹ã‚¿ã®å‰²ã‚Šå½“ã¦å…ƒãŸã‚‹æºã® (é‡è¤‡ãªã—ã®) ãƒªã‚¹ãƒˆ (ãŸã¨ãˆã°ã€å›³<a href="31_sec5_1.html#%_fig_5.11">5.11</a>ã®éšä¹—ãƒã‚·ãƒ³ã§ã® <tt>val</tt> ã¨ã„ã†ãƒ¬ã‚¸ã‚¹ã‚¿ã«ã¤ã„ã¦ã®æºã¯ã€
<tt>(const 1)</tt> ã¨ 
<tt>((op *) (reg n) (reg val))</tt>
ã§ã‚ã‚‹)ã€‚</li>
</ul>

<p class="orig" lang="en">Extend the
message-passing interface to the machine to provide access to this new
information.  To test your analyzer, define the Fibonacci machine from
figure <a href="31_sec5_1.html#%_fig_5.12">5.12</a> and examine the lists you constructed.
</p>

<p class="trans" lang="ja">
ã“ã®æ–°ãŸãªæƒ…å ±ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã‚’æä¾›ã™ã‚‹ã‚ˆã†ã«ã€ãƒã‚·ãƒ³ã«å¯¾ã™ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ¸¡ã—ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ã‚¤ã‚¹ã‚’æ‹¡å¼µã›ã‚ˆã€‚
å›ã®è§£æå™¨ã‚’æ¤œæŸ»ã™ã‚‹ãŸã‚ã«ã€å›³<a href="31_sec5_1.html#%_fig_5.12">5.12</a>ã®ãƒ•ã‚£ãƒœãƒŠãƒƒãƒãƒ»ãƒã‚·ãƒ³ã‚’å®šç¾©ã—ã¦ã€å›ãŒæ§‹ç¯‰ã—ãŸãƒªã‚¹ãƒˆã‚’æ¤œè¨ã›ã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.13"></a>
<b>Exercise 5.13.</b>  Modify the simulator so that it uses the controller sequence to
determine what registers the machine has rather than requiring a list
of registers as an argument to <tt>make-machine</tt>.  Instead of
pre-allocating the registers in <tt>make-machine</tt>, you can allocate
them one at a time when they are first seen during assembly of the
instructions.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ5.13.</b> <tt>make-machine</tt> ã«å¯¾ã™ã‚‹å¼•æ•°ã¨ã—ã¦ãƒ¬ã‚¸ã‚¹ã‚¿ã®ãƒªã‚¹ãƒˆã‚’è¦æ±‚ã™ã‚‹ã®ã§ã¯ãªãã€ã‚€ã—ã‚ã€ãƒã‚·ãƒ³ã«ã©ã†ã„ã†ãƒ¬ã‚¸ã‚¹ã‚¿ãŒã‚ã‚‹ã‹ã‚’åˆ¤å®šã™ã‚‹ãŸã‚ã«ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãŒã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©åˆ—ã‚’ç”¨ã„ã‚‹ã‚ˆã†ã«ã€ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã‚’æ”¹å¤‰ã›ã‚ˆã€‚
<tt>make-machine</tt> ã«ãŠã„ã¦ãƒ¬ã‚¸ã‚¹ã‚¿ã‚’äºˆã‚å‰²ã‚Šå½“ã¦ã‚‹ä»£ã‚ã‚Šã«ã€å›ã¯ã€å‘½ä»¤ã‚’ã‚¢ã‚»ãƒ³ãƒ–ãƒ«ã™ã‚‹é–“ã«ã€ãƒ¬ã‚¸ã‚¹ã‚¿ãŒæœ€åˆã«è¦‹å—ã‘ã‚‰ã‚ŒãŸã¨ãã«ã€ãƒ¬ã‚¸ã‚¹ã‚¿ã‚’ä¸€åº¦ã«ä¸€ã¤ãšã¤å‰²ã‚Šå½“ã¦ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_5.2.4"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_5.2.4">5.2.4  Monitoring Machine Performance</a></h3>
<h3 class="trans" lang="ja">5.2.4 ãƒã‚·ãƒ³æ€§èƒ½ã‚’ç›£è¦–ã™ã‚‹</h3>

<p class="orig" lang="en"><a name="%_idx_5804"></a>
<a name="%_idx_5806"></a>Simulation is useful not only for verifying the correctness of a
proposed machine design but also for measuring the machine's
performance.  For example, we can install in our simulation program a
``meter'' that measures the number of stack operations used in a
computation.  To do this, we modify our simulated stack to keep track
of the number of times registers are saved on the stack and the
maximum depth reached by the stack, and add a message to the stack's
interface that prints the statistics, as shown below.
We also add an operation to the basic machine model to print the
stack statistics, by initializing <tt>the-ops</tt> in <tt>make-new-machine</tt> to
</p>

<p class="trans" lang="ja">
ææ¡ˆã•ã‚ŒãŸãƒã‚·ãƒ³è¨­è¨ˆã®æ­£ã—ã•ã‚’æ¤œè¨¼ã™ã‚‹ãŸã‚ã ã‘ã§ãªãã€ãƒã‚·ãƒ³ã®æ€§èƒ½ã‚’è¨ˆæ¸¬ã™ã‚‹ãŸã‚ã«ã‚‚ã€ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã¯æœ‰ç”¨ã§ã‚ã‚‹ã€‚
ãŸã¨ãˆã°ã€è¨ˆç®—ã®éš›ã«ä½¿ã‚ã‚Œã‚‹ã‚¹ã‚¿ãƒƒã‚¯æ¼”ç®—ã®æ•°ã‚’è¨ˆæ¸¬ã™ã‚‹ã€Œ<ruby><rb>è¨ˆå™¨</rb><rp> (</rp><rt>ãƒ¡ãƒ¼ã‚¿</rt><rp>) </rp></ruby>ã€ã‚’ã€ç§ãŸã¡ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ»ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ä¸­ã«ä»•è¾¼ã‚€ã“ã¨ãŒã§ãã‚‹ã€‚
ã“ã‚Œã‚’è¡Œã†ãŸã‚ã«ã€ç§ãŸã¡ã¯ã€ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã•ã‚Œã‚‹ã‚¹ã‚¿ãƒƒã‚¯ã‚’ã€ãƒ¬ã‚¸ã‚¹ã‚¿ãŒã‚¹ã‚¿ãƒƒã‚¯ä¸Šã«é€€é¿ã•ã‚Œã‚‹å›æ•°ã¨ã€ã‚¹ã‚¿ãƒƒã‚¯ãŒåˆ°é”ã™ã‚‹æœ€å¤§æ·±ã•ã¨ã‚’æŠŠæ¡ã™ã‚‹ã‚ˆã†ã«ã€æ”¹å¤‰ã™ã‚‹ã€‚ãã—ã¦ã€å¾Œã«ç¤ºã™ã‚ˆã†ã«ã€çµ±è¨ˆé‡ã‚’å°å­—ã™ã‚‹ã‚¹ã‚¿ãƒƒã‚¯ã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ã‚¤ã‚¹ã«å¯¾ã™ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿½åŠ ã™ã‚‹ã€‚<!--ä¿‚ã‚Šå—ã‘ã«ã¤ã„ã¦è¦ãƒ»è¦‹ç›´ã—-->
ã¾ãŸã€ã‚¹ã‚¿ãƒƒã‚¯ã®çµ±è¨ˆé‡ã‚’å°å­—ã™ã‚‹ãŸã‚ã«ã€<tt>make-new-machine</tt> å†…ã® <tt>the-ops</tt> ã‚’ä»¥ä¸‹ã®ã‚ˆã†ã«åˆæœŸåŒ–ã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€åŸºæœ¬çš„ãƒã‚·ãƒ³ãƒ»ãƒ¢ãƒ‡ãƒ«ã«æ¼”ç®—ã‚’è¿½åŠ ã™ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_5808"></a><a name="%_idx_5810"></a>(list (list 'initialize-stack
            (lambda () (stack 'initialize)))
      (list 'print-stack-statistics
            (lambda () (stack 'print-statistics))))
</p>

<p class="orig" lang="en">Here is the new version of <tt>make-stack</tt>:
</p>

<p class="trans" lang="ja">
ã“ã“ã« <tt>make-stack</tt> ã®æ–°ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ç¤ºã™ã€‚
</p>

<p class="lisp"><a name="%_idx_5812"></a>(define (make-stack)
  (let ((s '())
        (number-pushes 0)
        (max-depth 0)
        (current-depth 0))
    (define (push x)
      (set! s (cons x s))
      (set! number-pushes (+ 1 number-pushes))
      (set! current-depth (+ 1 current-depth))
      (set! max-depth (max current-depth max-depth)))
    (define (pop)
      (if (null? s)
          (error &quot;Empty stack -- POP&quot;)
          (let ((top (car s)))
            (set! s (cdr s))
            (set! current-depth (- current-depth 1))
            top)))    
    (define (initialize)
      (set! s '())
      (set! number-pushes 0)
      (set! max-depth 0)
      (set! current-depth 0)
      'done)
    (define (print-statistics)
      (newline)
      (display (list 'total-pushes  '= number-pushes
                     'maximum-depth '= max-depth)))
    (define (dispatch message)
      (cond ((eq? message 'push) push)
            ((eq? message 'pop) (pop))
            ((eq? message 'initialize) (initialize))
            ((eq? message 'print-statistics)
             (print-statistics))
            (else
             (error &quot;Unknown request -- STACK&quot; message))))
    dispatch))
</p>

<p class="orig" lang="en">
Exercises <a href="#%_thm_5.15">5.15</a> through <a href="#%_thm_5.19">5.19</a>
describe other useful monitoring and debugging features that can be
added to the register-machine simulator.</p>

<p class="trans" lang="ja">
ç·´ç¿’å•é¡Œ<a href="#%_thm_5.15">5.15</a>ã‹ã‚‰ç·´ç¿’å•é¡Œ<a href="#%_thm_5.19">5.19</a>ã§ã¯ã€ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ»ãƒã‚·ãƒ³ãƒ»ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã«è¿½åŠ å¯èƒ½ãªã€ãã®ä»–ã®æœ‰ç”¨ãªç›£è¦–æ©Ÿèƒ½ãŠã‚ˆã³ãƒ‡ãƒãƒƒã‚°æ©Ÿèƒ½ã‚’è¨˜è¿°ã—ã¦ã„ã‚‹ã€‚
</p>

<p class="orig" lang="en">
<a name="%_thm_5.14"></a>
<b>Exercise 5.14.</b>  <a name="%_idx_5814"></a>Measure the number of pushes and the maximum stack depth required to
compute <em>n</em>! for various small values of <em>n</em> using the factorial
machine shown in figure <a href="31_sec5_1.html#%_fig_5.11">5.11</a>.  From your data
determine formulas in terms of <em>n</em> for the total number of push
operations and the maximum stack depth used in computing <em>n</em>! for any
<em>n</em> &gt; 1. Note that each of these is a linear function of <em>n</em> and is
thus determined by two constants.  In order to get the statistics
printed, you will have to augment the factorial machine with instructions to
initialize the stack and print the statistics.
You may want to also modify the
machine so that it repeatedly reads a value for <em>n</em>, computes the
factorial, and prints the result (as we did for the GCD machine in
figure <a href="31_sec5_1.html#%_fig_5.4">5.4</a>), so that you will not have to repeatedly
invoke <tt>get-register-contents</tt>, <tt>set-register-contents!</tt>, and
<tt>start</tt>.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ5.14.</b> å›³<a href="31_sec5_1.html#%_fig_5.11">5.11</a>ã«ç¤ºã™éšä¹—ãƒã‚·ãƒ³ã‚’ä½¿ã£ã¦ <em class="en">n</em> ã®æ§˜ã€…ãªå°ã•ãªå€¤ã«ã¤ã„ã¦ <em class="en">n</em>! ã‚’è¨ˆç®—ã™ã‚‹ã®ã«å¿…è¦ãªã€ãƒ—ãƒƒã‚·ãƒ¥å›æ•°ã¨æœ€å¤§ã‚¹ã‚¿ãƒƒã‚¯æ·±ã•ã‚’ã€è¨ˆæ¸¬ã›ã‚ˆã€‚
ä»»æ„ã®
<span class="math"><em class="en">n</em> &gt; 1</span>
ã«ã¤ã„ã¦ã€<em class="en">n</em>! ã‚’è¨ˆç®—ã™ã‚‹éš›ã«ä½¿ã‚ã‚Œã‚‹ãƒ—ãƒƒã‚·ãƒ¥æ¼”ç®—ã®ç·æ•°ã¨æœ€å¤§ã‚¹ã‚¿ãƒƒã‚¯æ·±ã•ã«ã¤ã„ã¦ã®ã€<em class="en">n</em> ã‚’ä½¿ã£ãŸå¼ã‚’ã€å›ã®ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å®šã‚ã‚ˆã€‚
ã“ã‚Œã‚‰<span class="note"> (ãƒ—ãƒƒã‚·ãƒ¥æ¼”ç®—ã®ç·æ•°ã¨æœ€å¤§ã‚¹ã‚¿ãƒƒã‚¯æ·±ã•) </span>ã®å„ã€…ã¯ã€<em class="en">n</em> ã®ç·šå½¢é–¢æ•°ã§ã‚ã‚Šã€ã—ãŸãŒã£ã¦ã€äºŒã¤ã®å®šæ•°ã«ã‚ˆã‚Šå®šã¾ã‚‹ã®ã ã€ã¨ã„ã†ã“ã¨ã«æ³¨æ„ã›ã‚ˆã€‚
å°å­—ã•ã‚Œã‚‹çµ±è¨ˆé‡ã‚’å¾—ã‚‹ãŸã‚ã«ã€å›ã¯ã€ã‚¹ã‚¿ãƒƒã‚¯ã‚’åˆæœŸåŒ–ã™ã‚‹å‘½ä»¤ã‚„çµ±è¨ˆé‡ã‚’å°å­—ã™ã‚‹å‘½ä»¤ã§éšä¹—ãƒã‚·ãƒ³ã‚’æ‹¡å¼µã—ãªãã¦ã¯ãªã‚‰ãªã„ã ã‚ã†ã€‚
å›ã¯ã€ãƒã‚·ãƒ³ãŒ <em class="en">n</em> ã®å€¤ã‚’ç¹°ã‚Šè¿”ã—èª­ã‚“ã§ã¯ãã®éšä¹—ã‚’è¨ˆç®—ã—ã¦çµæœã‚’å°åˆ·ã™ã‚‹ã‚ˆã†ã« (å›³<a href="31_sec5_1.html#%_fig_5.4">5.4</a>ã§ GCD ãƒã‚·ãƒ³ã«ã¤ã„ã¦ç§ãŸã¡ãŒè¡Œã£ãŸã®ã¨ã¡ã‚‡ã†ã©åŒã˜ã‚ˆã†ã«)ã€ãƒã‚·ãƒ³ã‚’æ”¹å¤‰ã—ãŸã„ã€ã¨ã‚‚æ€ã†ã‹ã‚‚ã—ã‚Œãªã„ã—ã€ã™ã‚‹ã¨ãã®çµæœã€å›ã¯ã€<tt>get-register-contents</tt> ã¨ <tt>set-register-contents!</tt> ã¨ <tt>start</tt> ã‚’ç¹°ã‚Šè¿”ã—å‘¼ã³å‡ºã•ãªãã¦ã‚‚ã‚ˆããªã‚‹ã ã‚ã†ã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.15"></a>
<b>Exercise 5.15.</b>  Add <a name="%_idx_5816"></a><em>instruction counting</em> to the register machine simulation.
That is, have the machine model keep track of the number of
instructions executed.  Extend the machine model's interface to accept
a new message that prints the value of the instruction count and
resets the count to zero.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ5.15.</b> ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ»ãƒã‚·ãƒ³ãƒ»ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã«ã€<em>å‘½ä»¤è¨ˆæ•°</em>ã‚’è¿½åŠ ã›ã‚ˆã€‚
ã¤ã¾ã‚Šã€å®Ÿè¡Œã•ã‚ŒãŸå‘½ä»¤ã®æ•°ã‚’ã€ãƒã‚·ãƒ³ãƒ»ãƒ¢ãƒ‡ãƒ«ã«æŠŠæ¡ã•ã›ã‚ˆã€‚
å‘½ä»¤ã‚«ã‚¦ãƒ³ãƒˆã®å€¤ã‚’å°å­—ã—ã¦ã‚«ã‚¦ãƒ³ãƒˆã‚’ã‚¼ãƒ­ã«ãƒªã‚»ãƒƒãƒˆã™ã‚‹ã‚ˆã†ãªã€æ–°ãŸãªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å—ã‘å…¥ã‚Œã‚‹ã‚ˆã†ã«ã€ãƒã‚·ãƒ³ãƒ»ãƒ¢ãƒ‡ãƒ«ã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ã‚¤ã‚¹ã‚’æ‹¡å¼µã›ã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.16"></a>
<b>Exercise 5.16.</b>  Augment the simulator to provide for <a name="%_idx_5818"></a><a name="%_idx_5820"></a><em>instruction tracing</em>.
That is, before each instruction is executed, the simulator should print
the text of the instruction.  Make the machine model accept <tt>trace-on</tt> and
<tt>trace-off</tt> messages to turn tracing on and off.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ5.16.</b> <em>å‘½ä»¤è¿½è·¡</em>ã«å‚™ãˆã‚‹ã‚ˆã†ã«ã€ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã‚’æ‹¡å¼µã›ã‚ˆã€‚
ã¤ã¾ã‚Šã€å„å‘½ä»¤ã‚’å®Ÿè¡Œã™ã‚‹å‰ã«ã€ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã¯ã€ãã®å‘½ä»¤ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’å°å­—ã™ã¹ãã§ã‚ã‚‹ã€‚
è¿½è·¡ã‚’ã‚ªãƒ³ã«ã—ãŸã‚Šã‚ªãƒ•ã«ã—ãŸã‚Šã™ã‚‹ãŸã‚ã® <tt>trace-on</tt> ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨ <tt>trace-off</tt> ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ã€ãƒã‚·ãƒ³ãƒ»ãƒ¢ãƒ‡ãƒ«ã«å—ã‘ä»˜ã‘ã•ã›ã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.17"></a>
<b>Exercise 5.17.</b>  Extend the instruction tracing of
exercise <a href="#%_thm_5.16">5.16</a> so that before
printing an instruction, the simulator prints any labels that
immediately precede that instruction in the controller sequence.  Be
careful to do this in a way that does not interfere with instruction
counting (exercise <a href="#%_thm_5.15">5.15</a>).
You will have to make the simulator retain the necessary label information.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ5.17.</b> ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãŒã€å‘½ä»¤ã‚’å°å­—ã™ã‚‹å‰ã«ã€ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©åˆ—ã«ãŠã„ã¦ãã®å‘½ä»¤ã®ç›´å‰ã«ã‚ã‚‹ä»»æ„ã®ãƒ©ãƒ™ãƒ«ã‚’å°å­—ã™ã‚‹ã‚ˆã†ã«ã€ç·´ç¿’å•é¡Œ<a href="#%_thm_5.16">5.16</a>ã®å‘½ä»¤è¿½è·¡ã‚’æ‹¡å¼µã›ã‚ˆã€‚
å‘½ä»¤è¨ˆæ•° (ç·´ç¿’å•é¡Œ<a href="#%_thm_5.15">5.15</a>) ã‚’å¦¨å®³ã—ãªã„ã‚ˆã†ãªæ–¹æ³•ã§ã“ã‚Œã‚’è¡Œã†ã‚ˆã†ã«ã€æ°—ã‚’ã¤ã‘ã‚ˆã€‚
å›ã¯ã€å¿…è¦ãªãƒ©ãƒ™ãƒ«æƒ…å ±ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã«è¨˜æ†¶ã•ã›ã¦ãŠã‹ã­ã°ãªã‚‰ãªããªã‚‹ã ã‚ã†ã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.18"></a>
<b>Exercise 5.18.</b>  <a name="%_idx_5822"></a><a name="%_idx_5824"></a>Modify the <tt>make-register</tt> procedure of
section <a href="#%_sec_5.2.1">5.2.1</a> so that registers can be traced.
Registers should accept messages that turn tracing on and off.  When a
register is traced, assigning a value to the register should print the
name of the register, the old contents of the register, and the new
contents being assigned.  Extend the interface to the machine model
to permit you to turn tracing on and off for designated machine registers.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ5.18.</b> ãƒ¬ã‚¸ã‚¹ã‚¿ã‚’è¿½è·¡ã§ãã‚‹ã‚ˆã†ã«ã€<a href="#%_sec_5.2.1">5.2.1</a>ç¯€ã® <tt>make-register</tt> æ‰‹ç¶šãã‚’æ”¹å¤‰ã›ã‚ˆã€‚
ãƒ¬ã‚¸ã‚¹ã‚¿ã¯ã€è¿½è·¡ã‚’ã‚ªãƒ³ã«ã—ãŸã‚Šã‚ªãƒ•ã«ã—ãŸã‚Šã™ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å—ã‘ä»˜ã‘ã‚‹ã¹ãã§ã‚ã‚‹ã€‚
ãƒ¬ã‚¸ã‚¹ã‚¿ãŒè¿½è·¡ã•ã‚Œã‚‹å ´åˆã€ãã®ãƒ¬ã‚¸ã‚¹ã‚¿ã«å€¤ã‚’å‰²ã‚Šå½“ã¦ã‚‹ã“ã¨ã§ã€ãã®ãƒ¬ã‚¸ã‚¹ã‚¿ã®åå‰ã¨ã€ãã®ãƒ¬ã‚¸ã‚¹ã‚¿ã®å¤ã„ä¸­èº«ã¨ã€å‰²ã‚Šå½“ã¦ä¸­ã®æ–°ãŸãªå€¤ã¨ã‚’å°å­—ã™ã‚‹ã“ã¨ã«ãªã‚‹ã¹ãã§ã‚ã‚‹ã€‚
æŒ‡å®šã•ã‚ŒãŸãƒã‚·ãƒ³ãƒ»ãƒ¬ã‚¸ã‚¹ã‚¿ã«ã¤ã„ã¦ã€å›ãŒè¿½è·¡ã‚’ã‚ªãƒ³ã«ã—ãŸã‚Šã‚ªãƒ•ã«ã—ãŸã‚Šã§ãã‚‹ã‚ˆã†ã«ã€ãƒã‚·ãƒ³ãƒ»ãƒ¢ãƒ‡ãƒ«ã«å¯¾ã™ã‚‹ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ã‚¤ã‚¹ã‚’æ‹¡å¼µã›ã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.19"></a>
<b>Exercise 5.19.</b>  Alyssa P. Hacker wants a <a name="%_idx_5826"></a><em>breakpoint</em> feature in the simulator to
help her debug her machine designs.  You have been hired to install
this feature for her.  She wants to be able to specify a place in the
controller sequence where the simulator will stop and allow her to
examine the state of the machine.  You are to implement a procedure</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ5.19.</b> ã‚¢ãƒªãƒƒã‚µãƒ»Pãƒ»ãƒãƒƒã‚«ã¯ã€è‡ªåˆ†ã®ãƒã‚·ãƒ³è¨­è¨ˆã‚’è‡ªåˆ†ãŒãƒ‡ãƒãƒƒã‚°ã™ã‚‹ã®ã‚’æ‰‹åŠ©ã‘ã™ã‚‹ãŸã‚ã®ã€ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã«ãŠã‘ã‚‹<em>ãƒ–ãƒ¬ã‚¤ã‚¯ãƒã‚¤ãƒ³ãƒˆ</em>æ©Ÿèƒ½ã‚’æ¬²ã—ãŒã£ã¦ã„ã‚‹ã€‚
å›ã¯ã€å½¼å¥³ã®ãŸã‚ã«ã“ã®æ©Ÿèƒ½ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã™ã‚‹ã‚ˆã†ã€é›‡ã‚ã‚ŒãŸã¨ã“ã‚ã ã€‚
ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãŒåœæ­¢ã™ã‚‹ã“ã¨ã«ãªã‚‹ã€ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©åˆ—å†…ã«ãŠã‘ã‚‹å ´æ‰€ã‚’æŒ‡å®šã§ãã‚‹ã“ã¨ã€ãã—ã¦ã€è‡ªåˆ†ãŒãƒã‚·ãƒ³ã®çŠ¶æ…‹ã‚’èª¿ã¹ã‚‰ã‚Œã‚‹ã“ã¨ã‚’ã€å½¼å¥³ã¯æœ›ã‚“ã§ã„ã‚‹ã€‚
å›ã¯ã€ä»¥ä¸‹ã®æ‰‹ç¶šãã‚’å®Ÿè£…ã™ã‚‹ã¤ã‚‚ã‚Šã§ã‚ã‚‹ã€‚
</p>

<p class="lisp">(set-breakpoint &lt;<em>machine</em>&gt; &lt;<em>label</em>&gt; &lt;<em>n</em>&gt;)
</p>

<p class="orig" lang="en">that sets a breakpoint just before the <em>n</em>th instruction after the
given label.  For example,</p>

<p class="trans" lang="ja">
ãªãŠã“ã‚Œã¯ã€ä¸ãˆã‚‰ã‚ŒãŸãƒ©ãƒ™ãƒ«ã®å¾Œã® <em class="en">n</em> ç•ªç›®ã®å‘½ä»¤ã®ç›´å‰ã«ãƒ–ãƒ¬ã‚¤ã‚¯ãƒã‚¤ãƒ³ãƒˆã‚’è¨­å®šã™ã‚‹ã‚‚ã®ã§ã‚ã‚‹ã€‚
ãŸã¨ãˆã°ã€
</p>

<p class="lisp">(set-breakpoint gcd-machine 'test-b 4)
</p>

<p class="orig" lang="en">installs a breakpoint in <tt>gcd-machine</tt> just before the
assignment to register <tt>a</tt>.  When the simulator reaches the
breakpoint it should print the label and the offset of the breakpoint
and stop executing instructions.  Alyssa can then use <tt>get-register-contents</tt> and <tt>set-register-contents!</tt> to manipulate
the state of the simulated machine.  She should then be able to
continue execution by saying</p>

<p class="trans" lang="ja">
ã¯ã€<tt>gcd-machine</tt> ã«ãŠã‘ã‚‹ãƒ–ãƒ¬ã‚¤ã‚¯ãƒã‚¤ãƒ³ãƒˆã‚’ã€<tt>a</tt> ã¨ã„ã†ãƒ¬ã‚¸ã‚¹ã‚¿ã¸ã®å‰²ã‚Šå½“ã¦ã®ç›´å‰ã«ã€è¨­ç½®ã™ã‚‹ã€‚
ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã¯ã€ãƒ–ãƒ¬ã‚¤ã‚¯ãƒã‚¤ãƒ³ãƒˆã«åˆ°é”ã™ã‚‹ã¨ã€ãƒ©ãƒ™ãƒ«ã¨ã€ãƒ–ãƒ¬ã‚¤ã‚¯ãƒã‚¤ãƒ³ãƒˆã®ã‚ªãƒ•ã‚»ãƒƒãƒˆã¨ã‚’å°å­—ã—ã€å‘½ä»¤ã‚’å®Ÿè¡Œã™ã‚‹ã®ã‚’ã‚„ã‚ã‚‹ã€‚
ã™ã‚‹ã¨ã€ã‚¢ãƒªãƒƒã‚µã¯ã€<tt>get-register-contents</tt> ã¨ <tt>set-register-contents!</tt> ã‚’ç”¨ã„ã¦ã€ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ãƒã‚·ãƒ³ã®çŠ¶æ…‹ã‚’æ“ä½œã§ãã‚‹ã€‚
ãã®å¾Œã€å½¼å¥³ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã«è¿°ã¹ã‚‹ã“ã¨ã§å®Ÿè¡Œã‚’ç¶šã‘ã‚‹ã“ã¨ãŒå¯èƒ½ã§ã‚ã‚‹ã¹ãã§ã‚ã‚‹ã€‚
</p>

<p class="lisp">(proceed-machine &lt;<em>machine</em>&gt;)
</p>

<p class="orig" lang="en">She should also be able to remove a specific breakpoint by means of</p>

<p class="trans" lang="ja">
å½¼å¥³ã¯ã€ä»¥ä¸‹ã®æ‰‹æ®µã«ã‚ˆã‚Šã€ç‰¹å®šã®ãƒ–ãƒ¬ã‚¤ã‚¯ãƒã‚¤ãƒ³ãƒˆã‚’å–ã‚Šé™¤ãã“ã¨ã‚‚ã§ãã‚‹ã¹ãã ã—ã€
</p>

<p class="lisp">(cancel-breakpoint &lt;<em>machine</em>&gt; &lt;<em>label</em>&gt; &lt;<em>n</em>&gt;)
</p>

<p class="orig" lang="en">or to remove all breakpoints by means of</p>

<p class="trans" lang="ja">
ã‚ã‚‹ã„ã¯ã€ä»¥ä¸‹ã®æ‰‹æ®µã«ã‚ˆã‚Šã€ã™ã¹ã¦ã®ãƒ–ãƒ¬ã‚¤ã‚¯ãƒã‚¤ãƒ³ãƒˆã‚’å–ã‚Šé™¤ãã“ã¨ã‚‚ã§ãã‚‹ã¹ãã§ã‚ã‚‹ã€‚
</p>

<p class="lisp">(cancel-all-breakpoints &lt;<em>machine</em>&gt;)
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="footnotes"></a>
<hr>

<p class="orig" lang="en"><a name="footnote_Temp_727" href="#call_footnote_Temp_727"><sup><small>4</small></sup></a> <a name="%_idx_5690"></a>Using the <tt>receive</tt> procedure here is a way to get <tt>extract-labels</tt> to effectively return two values -- <tt>labels</tt> and
<tt>insts</tt> -- without explicitly making a compound data structure to
hold them.  An alternative implementation, which returns an explicit
pair of values, is
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_727"><sup><small>4</small></sup></a>
ã“ã“ã§ <tt>receive</tt> æ‰‹ç¶šãã‚’ä½¿ã†ã“ã¨ã¯ã€äºŒã¤ã®å€¤â€”â€” <tt>labels</tt> ã¨ <tt>insts</tt> â€”â€”ã‚’ä¿æŒã™ã‚‹ãŸã‚ã®è¤‡åˆãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’æ˜ç¤ºçš„ã«ä½œã‚‹ã“ã¨ãªã—ã«ã€<tt>extract-labels</tt> ã«å®Ÿè³ªçš„ã«ã“ã‚Œã‚‰äºŒã¤ã®å€¤ã‚’è¿”ã•ã›ã‚‹ãŸã‚ã®æ–¹æ³•ã§ã‚ã‚‹ã€‚
åˆ¥ã®å®Ÿè£…â€”â€”å€¤ã®æ˜ç¤ºçš„ãªå¯¾ã‚’è¿”ã™â€”â€”ã¯ã€ä»¥ä¸‹ã®ã¨ãŠã‚Šã§ã‚ã‚Šã€
</p>

<p class="lisp"><a name="%_idx_5692"></a>(define (extract-labels text)
  (if (null? text)
      (cons '() '())
      (let ((result (extract-labels (cdr text))))
        (let ((insts (car result)) (labels (cdr result)))
          (let ((next-inst (car text)))
            (if (symbol? next-inst)
                (cons insts
                      (cons (make-label-entry next-inst insts) labels))
                (cons (cons (make-instruction next-inst) insts)
                      labels)))))))
</p>

<p class="orig" lang="en">which would be called by <tt>assemble</tt> as follows:
</p>

<p class="trans" lang="ja">
ã“ã‚Œã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¦ <tt>assemble</tt> ã«ã‚ˆã‚Šå‘¼ã³å‡ºã•ã‚Œã‚‹ã ã‚ã†ã€‚
</p>

<p class="lisp"><a name="%_idx_5694"></a>(define (assemble controller-text machine)
  (let ((result (extract-labels controller-text)))
    (let ((insts (car result)) (labels (cdr result)))
      (update-insts! insts labels machine)
      insts)))
</p>

<p class="orig" lang="en"><a name="%_idx_5696"></a><a name="%_idx_5698"></a><a name="%_idx_5700"></a>You can consider our use of <tt>receive</tt> as demonstrating an elegant
way to return multiple values, or simply an excuse to show off a
programming trick.  An argument like <tt>receive</tt> that is the next
procedure to be invoked is called a ``continuation.''  Recall that we
also used continuations to implement the backtracking control
structure in the <tt>amb</tt> evaluator in section <a href="28_sec4_3.html#%_sec_4.3.3">4.3.3</a>.</p>

<p class="trans" lang="ja">
å›ã¯ã€ç§ãŸã¡ã® <tt>receive</tt> ã®ä½¿ç”¨æ³•ã‚’ã€è¤‡æ•°ã®å€¤ã‚’è¿”ã™ãŸã‚ã®æ´—ç·´ã•ã‚ŒãŸæ–¹æ³•ã‚’å®Ÿè¨¼ã™ã‚‹ã‚‚ã®ã ã¨è¦‹ãªã™ã“ã¨ã‚‚ã§ãã‚‹ã—ã€ã‚ã‚‹ã„ã¯ã€å˜ã«ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®ç§˜è¨£ã‚’ã²ã‘ã‚‰ã‹ã™ãŸã‚ã®å£å®Ÿã ã¨è¦‹ãªã™ã“ã¨ã‚‚ã§ãã‚‹ã€‚
å‘¼ã³å‡ºã•ã‚Œã‚‹ã¹ãæ¬¡ã®æ‰‹ç¶šãã§ã‚ã‚‹ã€<tt>receive</tt> ã®ã‚ˆã†ãªå¼•æ•°ã¯ã€ã€Œ<ruby><rb>ç¶™ç¶š</rb><rp> (</rp><rt>ã‚³ãƒ³ãƒ†ã‚£ãƒ‹ãƒ¥ã‚¨ãƒ¼ã‚·ãƒ§ãƒ³</rt><rp>) </rp></ruby>ã€ã¨å‘¼ã°ã‚Œã‚‹ã€‚
<a href="28_sec4_3.html#%_sec_4.3.3">4.3.3</a>ç¯€ã§ã€<tt>amb</tt> è©•ä¾¡å™¨ã«ãŠã‘ã‚‹ãƒãƒƒã‚¯ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°åˆ¶å¾¡æ§‹é€ ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã«ã‚‚ç¶™ç¶šã‚’ä½¿ã£ãŸã“ã¨ã‚’æ€ã„å‡ºã—ã¦ã»ã—ã„ã€‚
</p>

</div>
</body>
</html>
