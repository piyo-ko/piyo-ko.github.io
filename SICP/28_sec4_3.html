<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="sicp.css" type="text/css">
<base target="_top">
<title>Structure and Interpretation of Computer Programs: SICP私訳</title>
</head>
<body>

<div class="idx-bar">
<nav>
<a href="https://twitter.com/share" class="twitter-share-button" data-lang="ja">ツイート</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
<span class="status">推敲待ち</span>
[
<a href="00_cover.html">先頭へ</a> |
<a href="27_sec4_2.html">前へ</a> |
<a href="29_sec4_4.html">次へ</a> |
<a href="04_toc.html#%_toc_start">目次</a> |
<a href="38_index.html#%_index_start">索引</a>
] [<a href="99_about.html">この対訳版について</a> | <a href="../index.html">ホーム</a>]
[
§<a href="#%_sec_4.3">4.3</a>
§<a href="#%_sec_4.3.1">4.3.1</a>
📚<a href="#%_sec_Temp_604">&hellip;</a>
📝<a href="#%_thm_4.35">4.35</a>
📝<a href="#%_thm_4.36">4.36</a>
📝<a href="#%_thm_4.37">4.37</a>
§<a href="#%_sec_4.3.2">4.3.2</a>
📚<a href="#%_sec_Temp_608">&hellip;</a>
📝<a href="#%_thm_4.38">4.38</a>
📝<a href="#%_thm_4.39">4.39</a>
📝<a href="#%_thm_4.40">4.40</a>
📝<a href="#%_thm_4.41">4.41</a>
📝<a href="#%_thm_4.42">4.42</a>
📝<a href="#%_thm_4.43">4.43</a>
📝<a href="#%_thm_4.44">4.44</a>
📚<a href="#%_sec_Temp_618">&hellip;</a>
📝<a href="#%_thm_4.45">4.45</a>
📝<a href="#%_thm_4.46">4.46</a>
📝<a href="#%_thm_4.47">4.47</a>
📝<a href="#%_thm_4.48">4.48</a>
📝<a href="#%_thm_4.49">4.49</a>
§<a href="#%_sec_4.3.3">4.3.3</a>
📚<a href="#%_sec_Temp_630">&hellip;</a>
📚<a href="#%_sec_Temp_631">&hellip;</a>
📚<a href="#%_sec_Temp_633">&hellip;</a>
📚<a href="#%_sec_Temp_634">&hellip;</a>
📚<a href="#%_sec_Temp_635">&hellip;</a>
📚<a href="#%_sec_Temp_637">&hellip;</a>
📚<a href="#%_sec_Temp_638">&hellip;</a>
📚<a href="#%_sec_Temp_639">&hellip;</a>
📝<a href="#%_thm_4.50">4.50</a>
📝<a href="#%_thm_4.51">4.51</a>
📝<a href="#%_thm_4.52">4.52</a>
📝<a href="#%_thm_4.53">4.53</a>
📝<a href="#%_thm_4.54">4.54</a>
<a href="#footnotes">脚注</a>
]
</nav>
</div>

<div class="main-txt">
<a name="%_sec_4.3"></a>
<h2 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_4.3">4.3  Variations on a Scheme -- Nondeterministic Computing</a></h2>
<h2 class="trans" lang="ja">4.3 Schemeの変種——非決定的計算</h2>


<p class="orig" lang="en">
<a name="%_idx_4806"></a>
<a name="%_idx_4808"></a>In this section, we extend the Scheme evaluator to support a
programming paradigm called <em>nondeterministic computing</em> by
building into the evaluator a facility to support automatic search.
This is a much more profound change to the language than the
introduction of lazy evaluation in section <a href="27_sec4_2.html#%_sec_4.2">4.2</a>.</p>

<p class="trans" lang="ja">
本節では、自動的探索をサポートする機能を評価器の中に組み込むことによって、<em>非決定的計算</em>と呼ばれるプログラミング・パラダイムをサポートするよう、Scheme評価器を拡張する。
これは、<a href="27_sec4_2.html#%_sec_4.2">4.2</a>節での遅延評価の導入よりもずっと重大な、言語に対する変更である。
</p>

<p class="orig" lang="en">
<a name="%_idx_4810"></a>Nondeterministic computing, like stream processing, is useful for
``generate and test'' applications.  Consider the task of starting with
two lists of positive integers and finding a pair of integers -- one
from the first list and one from the second list -- whose sum is prime.
We saw how to handle this with finite sequence operations in
section <a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a> and with infinite streams in
section <a href="24_sec3_5.html#%_sec_3.5.3">3.5.3</a>.  Our approach was to generate
the sequence of all possible pairs and filter these to select the
pairs whose sum is prime.  Whether we actually generate the entire
sequence of pairs first as in chapter 2, or interleave the generating
and filtering as in chapter 3, is immaterial to the essential image of
how the computation is organized.</p>

<p class="trans" lang="ja">
非決定的計算は、ストリーム処理と同様に、「生成しては検査する」用途にとって有益である。
正整数の二つのリストから始めて、和が素数であるような整数同士——第1のリストからのものと第2のリストからのもの——の対を見つける、という課題を考えよう。
有限の列演算を使ってこれをどう扱うかについては<a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a>節で見たし、無限のストリームを使ってこれをどう扱うかについては<a href="24_sec3_5.html#%_sec_3.5.3">3.5.3</a>節で見た。
私たちの手法は、すべての可能な対の連なりを生成し、それから、和が素数であるような対を選ぶために、これらの対をフィルタにかける、というものであった。
2章でのように対の連なり全体を最初に実際に生成するのか、それとも3章でのように生成とフィルタリングを交互に行うのか、ということは、計算がどのように組織化されるのか、という本質的な<ruby><rb>像</rb><rp> (</rp><rt>かたち</rt><rp>) </rp></ruby>にとっては重要ではない。
</p>


<p class="orig" lang="en">
<a name="%_idx_4812"></a>The nondeterministic approach evokes a different image.  Imagine simply
that we choose (in some way) a number from the first list and a number
from the second list and require (using some mechanism) that their sum
be prime.  This is expressed by following procedure:</p>

<p class="trans" lang="ja">
非決定的手法は、異なる像を呼び覚ます。
私たちが (何らかの方法で) 第1のリストから数を選び、第2のリストから数を選び、それらの和が素数であることを (何らかの仕組みを使って) 要求するのだ、と単純に想像しよう。
これは、以下の手続きにより表される。
</p>

<p class="lisp"><a name="%_idx_4814"></a>(define (prime-sum-pair list1 list2)
  (let ((a (an-element-of list1))
        (b (an-element-of list2)))
    (require (prime? (+ a b)))
    (list a b)))
</p>

<p class="orig" lang="en">It might seem as if this procedure merely restates the problem,
rather than specifying a way to solve it.  Nevertheless, this is
a legitimate nondeterministic program.<a name="call_footnote_Temp_598" href="#footnote_Temp_598"><sup><small>42</small></sup></a></p>

<p class="trans" lang="ja">
あたかもこの手続きが、問題を解く方法を指定するのではなくて、むしろ単に問題を再度述べているだけであるかのように見えるかもしれない。
それにもかかわらず、これは理にかなった非決定的プログラムなのだ<a href="#footnote_Temp_598"><sup><small>42</small></sup></a>。
</p>

<p class="orig" lang="en">
The key idea here is that expressions in a nondeterministic language
can have more than one possible value.  For instance,
<tt>an-element-of</tt> might return any element of the given list.  Our
nondeterministic program evaluator will work by automatically choosing
a possible value and keeping track of the choice.  If a subsequent
requirement is not met, the evaluator will try a different choice, and
it will keep trying new choices until the evaluation succeeds, or
until we run out of choices.  Just as the lazy evaluator freed the
programmer from the details of how values are delayed and forced, the
nondeterministic program evaluator will free the programmer from the
details of how choices are made.</p>

<p class="trans" lang="ja">
ここで鍵となる概念は、非決定的な言語における式が、一つの可能な値という以上のものを持ち得る、ということである。
たとえば、<tt>an-element-of</tt> は、与えられたリストの任意の要素を返すかもしれない。
私たちの非決定的なプログラム評価器は、可能な値を自動的に選んで、その選択について追跡することで、うまく動くだろう。
もし後続の要件が満たされなければ、評価器は別の選択肢を試すだろうし、評価が成功するまで、もしくは選択肢を使い果たすまで、評価器は新たな選択肢を追跡するだろう。
値がどのようにして遅延されたり強制されたりするのか、という詳細から、遅延評価器がプログラマを解き放ってくれたのとちょうど同じように、非決定的なプログラム評価器は、どのようにして選択がなされるのか、という詳細から、プログラマを解き放ってくれるだろう。
</p>


<p class="orig" lang="en">
<a name="%_idx_4820"></a>It is instructive to contrast the different images of time evoked by
nondeterministic evaluation and stream processing.  Stream processing
uses lazy evaluation to decouple the time when the stream of possible
answers is assembled from the time when the actual stream elements are
produced.  The evaluator supports the illusion that all the possible
answers are laid out before us in a timeless sequence.  With
nondeterministic evaluation, an expression represents the exploration
of a set of possible worlds, each determined by a set of choices.
Some of the possible worlds lead to dead ends, while others have
useful values.  The nondeterministic program evaluator supports the
illusion that time branches, and that our programs have different
possible execution histories.  When we reach a dead end, we can
revisit a previous choice point and proceed along a different branch.</p>

<p class="trans" lang="ja">
非決定的な評価とストリーム処理によって呼び覚まされる、時間についての異なる印象同士を対比することは、ためになる。
ストリーム処理は、遅延評価を使って、可能な答えのストリームが組み立てられる時点を、実際のストリーム要素が生み出される時点から、切り離した。
私たちの眼前で、可能な答えのすべてが、時を超越した列の中に並べられているのだ、という幻想を、評価器は支えている。
非決定的な評価があれば、式は、可能な世界——それらの世界のそれぞれは、選択肢の集合により決定づけられる——の集合の探査を表現する。
可能な世界のうちのいくつかは行き止まりに至るが、一方、他のものは、有益な値を持つ。
時間は分岐し、私たちのプログラムは異なる可能な実行履歴を有する、という幻想を、非決定的なプログラム評価器は支えている。
行き止まりに辿り着くと、私たちは、以前の選択点を再訪して、異なる分岐に沿って進むことができる。
</p>

<p class="orig" lang="en">
The nondeterministic program evaluator implemented below is called the
<tt>amb</tt> evaluator because it is based on a new special form called
<tt>amb</tt>.  We can type the above definition of <tt>prime-sum-pair</tt>
at the <tt>amb</tt> evaluator driver loop (along with definitions of <tt>prime?</tt>, <tt>an-element-of</tt>, and <tt>require</tt>) and run the
procedure as follows:</p>

<p class="trans" lang="ja">
以下で実装される非決定的なプログラム評価器は、<tt>amb</tt> と呼ばれる新たな特殊形式に基づいているので、<tt>amb</tt> 評価器と呼ばれる。
私たちは、<tt>amb</tt> 評価器のドライバ・ループにおいて、<tt>prime-sum-pair</tt> の上記の定義を (<tt>prime?</tt> と <tt>an-element-of</tt> と <tt>require</tt> の定義とともに) 打ち込んで、当該手続きを以下のとおり実行することができる。
</p>

<p class="lisp"><i>;;; Amb-Eval input:</i>
(prime-sum-pair '(1 3 5 8) '(20 35 110))
<i>;;; Starting a new problem</i>
<i>;;; Amb-Eval value:</i>
<i>(3 20)</i>
</p>

<p class="orig" lang="en">The value returned was obtained after the evaluator repeatedly chose
elements from each of the lists, until a successful choice was made.</p>

<p class="trans" lang="ja">
返される値は、うまくいく選択がなされるまで繰り返し、評価器がリストのそれぞれから要素を選んだ後に、得られた。
</p>

<p class="orig" lang="en">
Section <a href="#%_sec_4.3.1">4.3.1</a> introduces <tt>amb</tt> and explains how it
supports nondeterminism through the evaluator's automatic search
mechanism.  Section <a href="#%_sec_4.3.2">4.3.2</a> presents examples of
nondeterministic programs, and section <a href="#%_sec_4.3.3">4.3.3</a>
gives the details of how to implement the <tt>amb</tt> evaluator by
modifying the ordinary Scheme evaluator.</p>

<p class="trans" lang="ja">
<a href="#%_sec_4.3.1">4.3.1</a>節では <tt>amb</tt> を導入し、そして、それが評価器の自動的な探索の仕組みを介して非決定論を支える仕方を説明する。
<a href="#%_sec_4.3.2">4.3.2</a>節では、非決定的なプログラムの例を提示し、<a href="#%_sec_4.3.3">4.3.3</a>節では、元のScheme評価器を改変することによって <tt>amb</tt> 評価器を実装する仕方の詳細を示す。
</p>


<a name="%_sec_4.3.1"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_4.3.1">4.3.1  Amb and Search</a></h3>
<h3 class="trans" lang="ja">4.3.1 amb と探索</h3>

<p class="orig" lang="en"><a name="%_idx_4822"></a>To extend Scheme to support nondeterminism, we introduce a new special
form called <tt>amb</tt>.<a name="call_footnote_Temp_599" href="#footnote_Temp_599"><sup><small>43</small></sup></a>
The expression <tt>(amb &lt;<em><em>e</em><sub>1</sub></em>&gt; &lt;<em><em>e</em><sub>2</sub></em>&gt; <tt>...</tt> &lt;<em><em>e</em><sub><em>n</em></sub></em>&gt;)</tt>
returns the value of one of the <em>n</em> expressions &lt;<em><em>e</em><sub><em>i</em></sub></em>&gt; ``ambiguously.''
For example, the expression</p>

<p class="trans" lang="ja">
非決定論をサポートするようにSchemeを拡張するために、<tt>amb</tt> と呼ばれる新たな特殊形式を導入する<a href="#footnote_Temp_599"><sup><small>43</small></sup></a>。
<tt>(amb &lt;<em class="en">e<sub>1</sub></em>&gt; &lt;<em class="en">e<sub>2</sub></em>&gt; ... &lt;<em class="en">e<sub>n</sub></em>&gt;)</tt>
という式は、<em class="en">n</em> 個の &lt;<em class="en">e<sub>i</sub></em>&gt; という式のうちの一つの値を「曖昧に」返す。
たとえば、以下の式には、
</p>

<p class="lisp">(list (amb 1 2 3) (amb 'a 'b))
</p>

<p class="orig" lang="en">can have six possible values:</p>

<p class="trans" lang="ja">
六つの可能な値があり得る。
</p>

<figure>
<table class="common"><tr><td><tt>(1 a) </tt></td><td><tt>(1 b) </tt></td><td><tt>(2 a) </tt></td><td><tt>(2 b) </tt></td><td><tt>(3 a) </tt></td><td><tt>(3 b) </tt></td></tr></table>
</figure>

<p class="orig" lang="en">
<tt>Amb</tt> with a single choice produces an ordinary (single) value.</p>

<p class="trans" lang="ja">
単一の選択肢をともなう <tt>amb</tt> は、普通の (単一の) 値を作り出す。
</p>


<p class="orig" lang="en">
<a name="%_idx_4826"></a><tt>Amb</tt> with no choices -- the expression <tt>(amb)</tt> -- is an
expression with no acceptable values.  Operationally, we can think of
<tt>(amb)</tt> as an expression that when evaluated causes the
computation to ``fail'': The computation aborts and no value is
produced.  Using this idea, we can express the requirement that a
particular predicate expression <tt>p</tt> must be true as follows:</p>

<p class="trans" lang="ja">
選択肢をともなわない <tt>amb</tt> ——つまり <tt>(amb)</tt> という式——は、許容可能な値を持たない式である。
運用上、私たちは、<tt>(amb)</tt> のことを、評価されれば計算を「失敗」させる——つまり、計算は中止になって、何の値も作り出されない——ような式であるものと、見なすことが可能だ。
この考えを使うと、 <tt>p</tt> という特定の述語式が真でなくてはならない、という要件を、次のように表せる。
</p>

<p class="lisp"><a name="%_idx_4828"></a>(define (require p)
  (if (not p) (amb)))
</p>

<p class="orig" lang="en">
With <tt>amb</tt> and <tt>require</tt>, we can implement the <tt>an-element-of</tt> procedure used above:</p>

<p class="trans" lang="ja">
<tt>amb</tt> と <tt>require</tt> があれば、上記で使った <tt>an-element-of</tt> の手続きを実装できる。
</p>

<p class="lisp"><a name="%_idx_4830"></a>(define (an-element-of items)
  (require (not (null? items)))
  (amb (car items) (an-element-of (cdr items))))
</p>


<p class="orig" lang="en"><tt>An-element-of</tt> fails if the list is empty.  Otherwise it
ambiguously returns either the first element of the list or an element
chosen from the rest of the list.</p>

<p class="trans" lang="ja">
<tt>an-element-of</tt> は、リストが空のとき失敗する。
それ以外の場合、これは、リストの最初の要素か、リストの残りから選ばれた要素のいずれかを、曖昧に返す。
</p>

<p class="orig" lang="en">
We can also express infinite ranges of choices.  The following
procedure potentially returns any integer greater than or equal to
some given <em>n</em>:</p>

<p class="trans" lang="ja">
選択肢の無限の範囲も表現できる。
以下の手続きは、潜在的には、ある与えられた <em class="en">n</em> 以上の任意の整数を返す。
</p>

<p class="lisp"><a name="%_idx_4832"></a>(define (an-integer-starting-from n)
  (amb n (an-integer-starting-from (+ n 1))))
</p>


<p class="orig" lang="en">This is like the stream procedure <tt>integers-starting-from</tt>
described in section <a href="24_sec3_5.html#%_sec_3.5.2">3.5.2</a>, but with an important
difference: The stream procedure returns an object that represents the
sequence of all integers beginning with <em>n</em>, whereas the <tt>amb</tt>
procedure returns a single integer.<a name="call_footnote_Temp_600" href="#footnote_Temp_600"><sup><small>44</small></sup></a></p>

<p class="trans" lang="ja">
これは、<a href="24_sec3_5.html#%_sec_3.5.2">3.5.2</a>節で説明した <tt>integers-starting-from</tt> というストリーム手続きと似ているが、重要な違いがある。
つまり、<tt>amb</tt> 手続きは単一の整数を返すのに対して、ストリーム手続きは、<em class="en">n</em> で始まるすべての整数の連なりを表すオブジェクトを返すのである<a href="#footnote_Temp_600"><sup><small>44</small></sup></a>。
</p>

<p class="orig" lang="en">
<a name="%_idx_4834"></a>Abstractly, we can imagine that evaluating an <tt>amb</tt> expression
causes time to split into branches, where the computation continues on
each branch with one of the possible values of the expression.  We say
that <tt>amb</tt> represents a <a name="%_idx_4836"></a><em>nondeterministic choice point</em>.
If we had a machine with a sufficient number of processors that could
be dynamically allocated, we could implement the search in a
straightforward way.  Execution would proceed as in a sequential
machine, until an <tt>amb</tt> expression is encountered.  At this point,
more processors would be allocated and initialized to continue all of
the parallel executions implied by the choice.  Each processor would
proceed sequentially as if it were the only choice, until it either
terminates by encountering a failure, or it further subdivides, or
it finishes.<a name="call_footnote_Temp_601" href="#footnote_Temp_601"><sup><small>45</small></sup></a></p>

<p class="trans" lang="ja">
抽象的には、<tt>amb</tt> 式を評価することが、時間をいくつかの分岐へと分裂させるのだ——なお、それぞれの分岐上で、式の可能な値のうちの一つを使って、計算は続く——と想像することができる。
<tt>amb</tt> は<em>非決定的な選択点</em>を表す、と私たちは言う。
もし、動的に割り当てられる十分な台数のプロセッサを備えたマシンがあれば、分かりやすい方法で探索を実装できただろう。
実行は、<tt>amb</tt> 式に遭遇するまでは、逐次的なマシンでのものと同様に進むだろう。
この時点で、より多くのプロセッサが割り当てられ、かつ、その選択により示唆されるすべての並列実行を続行するように、初期化されるだろう。
各プロセッサは、それがあたかも唯一の選択肢であるかのように、逐次的に進むだろう——失敗に遭遇することで終了するまで、あるいは、さらに再分割するまで、あるいは、完了するまで<a href="#footnote_Temp_601"><sup><small>45</small></sup></a>。
</p>

<p class="orig" lang="en">
<a name="%_idx_4840"></a>On the other hand, if we have a machine that can execute
only one process (or a few concurrent processes),
we must consider the alternatives sequentially.
One could imagine modifying an evaluator
to pick at random a branch to follow whenever it encounters a choice
point.  Random choice, however, can easily lead to failing values.
We might try running the evaluator over and over, making random
choices and hoping to find a non-failing value, but it is better to <a name="%_idx_4842"></a><a name="%_idx_4844"></a><em>systematically search</em> all possible execution paths.
The <tt>amb</tt> evaluator that we will develop and work with in this section
implements a systematic search as follows: When the evaluator
encounters an application of <tt>amb</tt>, it initially selects the first
alternative.  This selection may itself lead to a further choice.  The
evaluator will always initially choose the first alternative at each
choice point.  If a choice results in a failure, then the evaluator
<a name="%_idx_4846"></a><a name="%_idx_4848"></a><a name="%_idx_4850"></a>automagically<a name="call_footnote_Temp_602" href="#footnote_Temp_602"><sup><small>46</small></sup></a> <a name="%_idx_4852"></a><em>backtracks</em>
to the most recent choice point and tries the next
alternative.  If it runs out of alternatives at any choice point, the
evaluator will back up to the previous choice point and resume from
there.  This process leads to a search strategy known as <a name="%_idx_4854"></a><a name="%_idx_4856"></a><a name="%_idx_4858"></a><em>depth-first search</em> or <em>chronological backtracking</em>.<a name="call_footnote_Temp_603" href="#footnote_Temp_603"><sup><small>47</small></sup></a></p>

<p class="trans" lang="ja">
一方、もし、一つのプロセス (または少数の並行したプロセス) しか実行できないマシンがあれば、選択肢を逐次的に考えなくてはならない。
選択点に遭遇するたびに、たどるべき分岐をランダムに選ぶように、評価器を改変することを、想像することもできる。
しかし、ランダムな選択は、大抵は、失敗する値につながる。
私たちは、ランダムな選択をして、失敗しない値を見つけることを願いつつ、何度も何度も評価器を動かしてみるかもしれないが、あり得るすべての実行経路を<em>組織的に探索する</em>方が良いのである。
私たちが開発しようとしていて、また、本節ではそれを使って作業しようとしている、<tt>amb</tt> 評価器は、以下のように組織的探索を実装する。
評価器は、<tt>amb</tt> の適用に遭遇すると、最初に1番目の選択肢を選ぶ。
この選択は、それ自体が、さらなる選択につながるかもしれない。
評価器は常に、各選択点において、最初は1番目の選択肢を選ぶ。
もし、ある選択が失敗に終わったら、評価器は、<ruby><rb>魔法のように自動的</rb><rp> (</rp><rt>オートマジカル</rt><rp>) </rp></ruby>に<a href="#footnote_Temp_602"><sup><small>46</small></sup></a>、直近の選択点へと<em><ruby><rb>バックトラックして</rb><rp> (</rp><rt>ひきかえして</rt><rp>) </rp></ruby></em>、次の選択肢を試す。
もし、どこかの選択点で選択肢を使い果たしたら、評価器は、前の選択点に戻って、そこから再開する。
このプロセスは、<em>深さ優先探索</em>もしくは<em>時系列順バックトラッキング</em>として知られる探索戦略へと通じる<a href="#footnote_Temp_603"><sup><small>47</small></sup></a>。
</p>

<a name="%_sec_Temp_604"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_604">Driver loop</a></h4>
<h4 class="trans" lang="ja">ドライバ・ループ</h4>

<p class="orig" lang="en">
<a name="%_idx_4908"></a>The driver loop for the <tt>amb</tt> evaluator
has some unusual properties.  It reads an
expression and prints the value of the first non-failing execution, as
in the <tt>prime-sum-pair</tt> example shown above.  If we
want to see the value of the next successful execution, we can
ask the interpreter to backtrack and attempt to generate a second
non-failing execution.  This is signaled by typing the symbol <a name="%_idx_4910"></a><tt>try-again</tt>.  If any expression except <tt>try-again</tt> is given, the
interpreter will start a new problem, discarding the unexplored
alternatives in the previous problem.  Here is a sample
interaction:</p>

<p class="trans" lang="ja">
<tt>amb</tt> 評価器用のドライバ・ループには、やや変わった性質がある。
それは、式を読み、上記の <tt>prime-sum-pair</tt> の例でのとおり、最初の失敗しない実行の値を印字する。
もし次のうまくいく実行の値を見たければ、インタプリタに対して、バックトラックして2番目の失敗しない実行を生成することを試みるように、求めることが可能だ。
これは、<tt>try-again</tt> という記号を打ち込むことで、合図が与えられる。
もし <tt>try-again</tt> 以外の式が何か与えられたら、インタプリタは、前の問題における未探索の選択肢を捨てて、新たな問題を開始するだろう。
ここに見本的なやりとりを示す。
</p>

<p class="lisp"><i>;;; Amb-Eval input:</i>
(prime-sum-pair '(1 3 5 8) '(20 35 110))
<i>;;; Starting a new problem</i>
<i>;;; Amb-Eval value:</i>
<i>(3 20)</i>
<i>;;; Amb-Eval input:</i>
try-again
<i>;;; Amb-Eval value:</i>
<i>(3 110)</i>
<i>;;; Amb-Eval input:</i>
try-again
<i>;;; Amb-Eval value:</i>
<i>(8 35)</i>
<i>;;; Amb-Eval input:</i>
try-again
<i>;;; There are no more values of</i>
<i>(prime-sum-pair (quote (1 3 5 8)) (quote (20 35 110)))</i>
<i>;;; Amb-Eval input:</i>
(prime-sum-pair '(19 27 30) '(11 36 58))
<i>;;; Starting a new problem</i>
<i>;;; Amb-Eval value:</i>
<i>(30 11)</i>
</p>


<p class="orig" lang="en">
<a name="%_thm_4.35"></a>
<b>Exercise 4.35.</b>  <a name="%_idx_4912"></a><a name="%_idx_4914"></a>Write a procedure <tt>an-integer-between</tt> that returns an integer
between two given bounds.  This can be used to implement a
procedure that finds Pythagorean triples,
i.e., triples of integers (<em>i</em>,<em>j</em>,<em>k</em>) between the given bounds such
that <em>i</em> <u>&lt;</u> <em>j</em> and <em>i</em><sup>2</sup>  +  <em>j</em><sup>2</sup>  = <em>k</em><sup>2</sup>, as follows:</p>

<p class="trans" lang="ja">
<b>練習問題 4.35.</b> 与えられた二つの境界の間の整数を一つ返す、<tt>an-integer-between</tt> という手続きを書け。
これは、ピタゴラスの三つ組——すなわち、
<span class="math"><em class="en">i</em> &le; <em class="en">j</em></span>
かつ
<span class="math"><em class="en">i</em><sup>2</sup>  +  <em class="en">j</em><sup>2</sup>  = <em class="en">k</em><sup>2</sup></span>
であるような、与えられた境界の間にある、
<span class="math">(<em class="en">i</em>, <em class="en">j</em>, <em class="en">k</em>)</span>
という整数の三つ組——を見つける手続きを以下のようにして実装するのに使える。
</p>

<p class="lisp">(define (a-pythagorean-triple-between low high)
  (let ((i (an-integer-between low high)))
    (let ((j (an-integer-between i high)))
      (let ((k (an-integer-between j high)))
        (require (= (+ (* i i) (* j j)) (* k k)))
        (list i j k)))))
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_4.36"></a>
<b>Exercise 4.36.</b>  <a name="%_idx_4916"></a><a name="%_idx_4918"></a>Exercise <a href="24_sec3_5.html#%_thm_3.69">3.69</a> discussed how to generate
the stream of <em>all</em> Pythagorean triples, with no upper bound on the
size of the integers to be searched.  Explain why simply replacing
<tt>an-integer-between</tt> by <tt>an-integer-starting-from</tt> in the procedure in
exercise <a href="#%_thm_4.35">4.35</a> is not an adequate way to
generate arbitrary Pythagorean triples.  Write a procedure that
actually will accomplish this.  (That is, write a procedure for which
repeatedly typing <tt>try-again</tt> would in principle eventually
generate all Pythagorean triples.)
</p>

<p class="trans" lang="ja">
<b>練習問題 4.36.</b> 練習問題<a href="24_sec3_5.html#%_thm_3.69">3.69</a>では、探索すべき整数の大きさについて上限を設けずに、<em>すべての</em>ピタゴラスの三つ組のストリームをどのように生成するのか、について議論した。
練習問題<a href="#%_thm_4.35">4.35</a>において、単純に <tt>an-integer-between</tt> を <tt>an-integer-starting-from</tt> で置き換えることが、なぜ、任意のピタゴラスの三つ組を生成するための適切な方法ではないのかを説明せよ。
実際にこれを達成するであろう手続きを書け
(つまり、その手続きに対して <tt>try-again</tt> と繰り返し打ち込むことによって、原理上は、ゆくゆくはすべてのピタゴラスの三つ組を生成することになるであろうような手続きを書け)。
</p>


<p class="orig" lang="en">
<a name="%_thm_4.37"></a>
<b>Exercise 4.37.</b>  <a name="%_idx_4920"></a><a name="%_idx_4922"></a>Ben Bitdiddle claims that the following method for generating
Pythagorean triples is more efficient than the one in
exercise <a href="#%_thm_4.35">4.35</a>.  Is he correct?  (Hint: Consider
the number of possibilities that must be explored.)</p>

<p class="trans" lang="ja">
<b>練習問題 4.37.</b> ベン・ビットディドルは、ピタゴラスの三つ組を生成するための以下の方法が、練習問題<a href="#%_thm_4.35">4.35</a>のものよりも効率的だ、と主張する。
彼は正しいか?
(ヒント: 探索せねばならない可能性の数を考えよ。)
</p>

<p class="lisp">(define (a-pythagorean-triple-between low high)
  (let ((i (an-integer-between low high))
        (hsq (* high high)))
    (let ((j (an-integer-between i high)))
      (let ((ksq (+ (* i i) (* j j))))
        (require (&gt;= hsq ksq))
        (let ((k (sqrt ksq)))
          (require (integer? k))
          (list i j k))))))
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_4.3.2"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_4.3.2">4.3.2  Examples of Nondeterministic Programs</a></h3>
<h3 class="trans" lang="ja">4.3.2 非決定的プログラムの例</h3>

<p class="orig" lang="en">Section <a href="#%_sec_4.3.3">4.3.3</a> describes the implementation of
the <tt>amb</tt> evaluator.  First, however, we give some examples of how
it can be used.  The advantage of nondeterministic programming is that
we can suppress the details of how search is carried out, thereby
<a name="%_idx_4924"></a>expressing our programs at a higher level of abstraction.</p>

<p class="trans" lang="ja">
<a href="#%_sec_4.3.3">4.3.3</a>節では <tt>amb</tt> 評価器の実装について説明する。
しかし、それをどのように使うことができるのか、という幾つかの例をまず挙げておく。
非決定的プログラムの利点は、探索がどのように実行されるのか、<!--という詳細を隠せる点であり、それによって抽象化のより高い水準においてプログラムを表せる点である。-->という詳細を隠し、それによって、より高い抽象化の水準においてプログラムを表す、ということができる点である。
</p>

<a name="%_sec_Temp_608"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_608">Logic Puzzles</a></h4>
<h4 class="trans" lang="ja">論理パズル</h4>



<p class="orig" lang="en">
<a name="%_idx_4926"></a><a name="%_idx_4928"></a><a name="%_idx_4930"></a>
<a name="%_idx_4932"></a>The following puzzle (taken from Dinesman 1968) is typical of a large
class of simple logic puzzles:</p>

<p class="trans" lang="ja">
以下のパズル (Dinesman 1968 から採った) は、単純な論理パズルの大きな部類の典型である。
</p>


<blockquote class="orig" lang="en">
Baker, Cooper, Fletcher, Miller, and Smith live on different floors of
an apartment house that contains only five floors.  Baker does not
live on the top floor.  Cooper does not live on the bottom floor.
Fletcher does not live on either the top or the bottom floor.  Miller
lives on a higher floor than does Cooper.  Smith does not live on a
floor adjacent to Fletcher's.  Fletcher does not live on a floor
adjacent to Cooper's.  Where does everyone live?
</blockquote>

<blockquote class="trans" lang="ja">
ベイカーとクーパーとフレッチャーとミラーとスミスは、5階までしかないアパートの異なる階に住んでいる。
ベイカーは一番上の階には住んでいない。
クーパーは一番下の階には住んでいない。
フレッチャーは一番上の階にも一番下の階にも住んでいない。
ミラーはクーパーより上の階に住んでいる。
スミスはフレッチャーと隣接する階には住んでいない。
フレッチャーはクーパーと隣接する階には住んでいない。
みんなはどの階に住んでいるのだろうか?
</blockquote>

<p class="orig" lang="en">
We can determine who lives on each floor in a straightforward way by
enumerating all the possibilities and imposing the given
restrictions:<a name="call_footnote_Temp_609" href="#footnote_Temp_609"><sup><small>48</small></sup></a></p>

<p class="trans" lang="ja">
すべての可能性を列挙して、与えられた制約を課すことによって、各階に誰が住んでいるのかを単純な方法で判定できる<a href="#footnote_Temp_609"><sup><small>48</small></sup></a>。
</p>

<p class="lisp"><a name="%_idx_4938"></a>(define (multiple-dwelling)
  (let ((baker (amb 1 2 3 4 5))
        (cooper (amb 1 2 3 4 5))
        (fletcher (amb 1 2 3 4 5))
        (miller (amb 1 2 3 4 5))
        (smith (amb 1 2 3 4 5)))
    (require
     (distinct? (list baker cooper fletcher miller smith)))
    (require (not (= baker 5)))
    (require (not (= cooper 1)))
    (require (not (= fletcher 5)))
    (require (not (= fletcher 1)))
    (require (&gt; miller cooper))
    (require (not (= (abs (- smith fletcher)) 1)))
    (require (not (= (abs (- fletcher cooper)) 1)))
    (list (list 'baker baker)
          (list 'cooper cooper)
          (list 'fletcher fletcher)
          (list 'miller miller)
          (list 'smith smith))))
</p>


<p class="orig" lang="en">
Evaluating the expression <tt>(multiple-dwelling)</tt> produces the
result</p>

<p class="trans" lang="ja">
<tt>(multiple-dwelling)</tt> という式を評価すると、以下の結果が生み出される。
</p>

<p class="lisp">((baker 3) (cooper 2) (fletcher 4) (miller 5) (smith 1))
</p>

<p class="orig" lang="en">Although this simple procedure works, it is very slow.
Exercises <a href="#%_thm_4.39">4.39</a>
and <a href="#%_thm_4.40">4.40</a> discuss some possible
improvements.</p>

<p class="trans" lang="ja">
この単純な手続きはうまく動くが、非常に遅い。
練習問題<a href="#%_thm_4.39">4.39</a>と練習問題<a href="#%_thm_4.40">4.40</a>では、いくつかの可能な改善点について議論する。
</p>


<div class="exercise"><span class="ex_comment">ここで、人力でパズルを解いてみる。</span>

<table class="expl ex_comment">
<tr><th>名前</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th></th></tr>
<tr><th>ベイカー</th><td>×i</td><td>×g</td><td>😀j</td><td>×g</td><td>❌a</td><td>a. 一番上の階には住んでいない</td></tr>
<tr><th>クーパー</th><td>❌b</td><td>😀l</td><td>❌f</td><td>×l</td><td>❌d</td><td>b. 一番下の階には住んでいない</td></tr>
<tr><th>フレッチャー</th><td>❌c</td><td>×k</td><td>❌f</td><td>😀k</td><td>❌c</td><td>c. 一番上の階にも一番下の階にも住んでいない<br>f. クーパーと隣接する階には住んでいない</td></tr>
<tr><th>ミラー</th><td>❌d</td><td>×g</td><td>×j</td><td>×g</td><td>😀j</td><td>d. クーパーより上の階に住んでいる</td></tr>
<tr><th>スミス</th><td>😀i</td><td>×g</td><td>❌e</td><td>×g</td><td>×h</td><td>e. フレッチャーと隣接する階には住んでいない</td></tr>
</table>

<span class="ex_comment">❌は、与えられた制約条件から直ちに「ダメ」とわかるところ。a〜fの順に埋めた。
次に (g)、2階と4階はクーパーとフレッチャーで埋まるので、他の人は入れない。
ここで (h)、スミスが5階だとすると、eよりフレッチャーが2階。
すると、クーパーが4階なので、dよりミラーも5階となり、これは矛盾。
よって、スミスは5階ではない。
つまり (i)、スミスは1階である。よって、ベイカーは1階ではない。
ということは (j)、ベイカーは3階である。よって、ミラーは3階ではなく、5階である。
ところで (k)、スミスが1階なので、eよりフレッチャーが4階。
したがって (l)、クーパーは2階である。</span></div>

<p class="orig" lang="en">
<a name="%_thm_4.38"></a>
<b>Exercise 4.38.</b>  Modify the multiple-dwelling procedure to omit the requirement that
Smith and Fletcher do not live on adjacent floors.  How many solutions
are there to this modified puzzle?
</p>

<p class="trans" lang="ja">
<b>練習問題 4.38.</b> スミスとフレッチャーが隣り合った階に住んでいない、という要件を省略するように、<tt>multiple-dwelling</tt> (複数の住居) の手続きを改変せよ。
この改変されたパズルに対しては、いくつの解があるだろう?
</p>


<div class="exercise"><span class="ex_comment">手続きの改変は、</span>
(require (not (= (abs (- smith fletcher)) 1)))
<span class="ex_comment">の行を削除するだけでよい。</span>

<span class="ex_comment">ここで、人力でパズルを解いてみる。</span>

<table class="expl ex_comment">
<tr><th>名前</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th></th></tr>
<tr><th>ベイカー</th><td>💛h<br>💙j<br>💜k</td><td>×g</td><td>💚i<br>❤️l</td><td>×g</td><td>❌a</td><td>a. 一番上の階には住んでいない</td></tr>
<tr><th>クーパー</th><td>❌b</td><td>💙j<br>💜k<br>❤️l</td><td>❌f</td><td>💛h<br>💚i</td><td>❌d</td><td>b. 一番下の階には住んでいない</td></tr>
<tr><th>フレッチャー</th><td>❌c</td><td>💛h<br>💚i</td><td>❌f</td><td>💙j<br>💜k<br>❤️l</td><td>❌c</td><td>c. 一番上の階にも一番下の階にも住んでいない<br>f. クーパーと隣接する階には住んでいない</td></tr>
<tr><th>ミラー</th><td>❌d</td><td>×g</td><td>💙j</td><td>×g</td><td>💛h<br>💚i<br>💜k<br>❤️l</td><td>d. クーパーより上の階に住んでいる</td></tr>
<tr><th>スミス</th><td>💚i<br>❤️l</td><td>×g</td><td>💛h<br>💜k</td><td>×g</td><td>💙j</td><td><del>e. フレッチャーと隣接する階には住んでいない</del></td></tr>
</table>

<span class="ex_comment">❌は、与えられた制約条件から直ちに「ダメ」とわかるところ。a〜d、fの順に埋めた。
次に (g)、2階と4階はクーパーとフレッチャーで埋まるので、他の人は入れない。
ここで (h, i)、クーパーが4階だとすると、フレッチャーが2階で、dよりミラーが5階。
ということは、ベイカーとスミスが1階と3階 (どちらがどちらであってもよい)。
逆に (j, k, l)、クーパーが2階だとすると、フレッチャーが4階で、ミラーは3階でも5階でもよい。
仮にミラーが3階だとすると (j)、1階と5階が残るが、aよりベイカーが1階、スミスが5階である。
逆にミラーが5階だとすると (k, l)、1階と3階が残る。
この場合は、ベイカーとスミスがどちらを占めてもよい。
というわけで、eの制約がなくなると、h, i, j, k, lの5通りの答えが存在することになる。
</span></div>


<p class="orig" lang="en">
<a name="%_thm_4.39"></a>
<b>Exercise 4.39.</b>  Does the order of the restrictions in the multiple-dwelling procedure
affect the answer? Does it affect the time to find an answer?  If you
think it matters, demonstrate a faster program obtained from the given
one by reordering the restrictions.  If you think it does not matter,
argue your case.
</p>

<p class="trans" lang="ja">
<b>練習問題 4.39.</b> <tt>multiple-dwelling</tt> の手続きにおける制約の順序は、答えに影響するか?
答えを見つける時間には影響するか?
もし、その順序が重要だと君が考えるなら、制約の順番を並べ替えることで所与のプログラムから得られる、より高速なプログラムを、実演してみせたまえ。
もし、その順序は重要でないと君が考えるなら、君の立場を論じたまえ。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_4.40"></a>
<b>Exercise 4.40.</b>  In the multiple dwelling problem, how many sets of assignments are
there of people to floors, both before and after the requirement that
floor assignments be distinct?  It is very inefficient to generate all
possible assignments of people to floors and then leave it to
backtracking to eliminate them.  For example, most of the restrictions
depend on only one or two of the person-floor variables, and can thus
be imposed before floors have been selected for all the people.
Write and demonstrate a much more efficient
nondeterministic procedure that solves this problem based upon
generating only those possibilities that are not already ruled out by
previous restrictions.  (Hint: This will require a nest of <tt>let</tt>
expressions.)
</p>

<p class="trans" lang="ja">
<b>練習問題 4.40.</b> 複数の住居の問題において、階の割り当ては相異なるべし、という要件の前後で、人々の階への割り当ては何通りあるだろうか?
人々の階への可能なすべての割り当てを生成して、それからそれらの割り当てを削除するためのバックトラッキングに状況 <span class="note">(=it)</span> を委ねる、というのは非効率である。
たとえば、ほとんどの制約は、人・階の変数のうちのたった一つか二つにしか依存しないし、それゆえ、すべての人たちに対して階が選択済みとなる前に、<span class="note">(その制約を) </span>課すことが可能である。
前の制約によって既に排除されている訳ではない可能性のみを生成することに基づいて、この問題を解くような、もっとずっと効率的な非決定的手続きを、書いて実演せよ
(ヒント: これは、<tt>let</tt> 式の入れ子を必要とするだろう)。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_4.41"></a>
<b>Exercise 4.41.</b>  <a name="%_idx_4940"></a>Write an ordinary Scheme program to solve the multiple dwelling puzzle.
</p>

<p class="trans" lang="ja">
<b>練習問題 4.41.</b> 複数の住居のパズルを解くための、普通のSchemeプログラムを書け。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_4.42"></a>
<b>Exercise 4.42.</b>  <a name="%_idx_4942"></a>Solve the following ``Liars'' puzzle (from Phillips 1934):</p>

<p class="trans" lang="ja">
<b>練習問題 4.42.</b> 以下の「嘘つき」パズル (Phillips 1934 による) を解け。
</p>

<blockquote class="orig" lang="en">
Five schoolgirls sat for an examination.  Their parents -- so they
thought -- showed an undue degree of interest in the result.  They
therefore agreed that, in writing home about the examination, each 
girl should make one true statement and one untrue one.  The following
are the relevant passages from their letters:

<ul>
<li>Betty: ``Kitty was second in the examination.  I was only third.''
<li>Ethel: ``You'll be glad to hear that I was on top.  Joan was second.''
<li>Joan: ``I was third, and poor old Ethel was bottom.''
<li>Kitty: ``I came out second.  Mary was only fourth.''
<li>Mary: ``I was fourth.  Top place was taken by Betty.''
</ul>

What in fact was the order in which the five girls were placed?
</blockquote>


<blockquote class="trans" lang="ja">
5人の女子生徒が試験のために座っていた。
彼女たちの親は、結果について過度の関心を見せた——と、彼女たちは考えた。
そこで彼女たちは、試験について家に書いて送る際には、それぞれの少女が、一つは本当のことを述べ、一つは偽りのことを述べるべきである、と合意した。
以下は、彼女たちの手紙の、当該問題に関する一節である。

<ul>
<li>ベティ「キティは試験で2位でした。わたしは3位でしかありませんでした。」</li>
<li>エセル「わたしが1位だったと聞いたら、喜んでくれることでしょう。ジョーンは2位でした。」</li>
<li>ジョーン「わたしは3位で、まったくだめなエセルときたら、びりでした。」</li>
<li>キティ「わたしは2位だとわかりました。メアリは4位でしかありませんでした。」</li>
<li>メアリ「わたしは4位でした。1位はベティが取りました。」</li>
</ul>

5人の女子生徒が置かれた順位は、実際はどういうものだったのか?
</blockquote>


<p class="exercise"><span class="ex_comment">(1) キティが2位と仮定する。
このとき、ベティの発言の前半が本当で後半が嘘なので、ベティは3位ではない。
また、キティの発言の前半が本当で後半が嘘なので、メアリは4位ではない。
ということは、メアリの発言の前半が嘘で後半が本当なので、1位はベティ
(これは上記の「3位ではない」と矛盾しない)。
すると、エセルの発言の前半が嘘で後半が本当なので、ジョーンは2位。
これは仮定と反する。よって、キティが2位という仮定は間違い。

(2) したがって、キティは2位ではない。
すると、ベティの発言の前半が嘘で後半が本当だから、ベティは3位。
また、キティの発言の前半が嘘で後半が本当だから、メアリは4位。
ということは、メアリの発言の前半が本当で後半が嘘なので、ベティは1位ではない
(これは上記の「3位」と矛盾しない)。
ここまでで、1位、2位、5位が空いている。
キティは2位ではないので、1位か5位である。
2位の可能性があるのはエセルかジョーンである。
エセルが2位だとすると、エセル自身の発言の前半が嘘で後半が本当のはず
だが、それだとジョーンも2位になってしまうから、矛盾。
つまり、エセルも2位ではない。
ということは、2位はジョーンである。
したがって、エセルの発言は、後半が本当で前半が嘘。
つまり、エセルは1位ではないので5位である。
ということはキティが1位である。

答えは、1位・キティ、2位・ジョーン、3位・ベティ、4位・メアリ、5位・エセル。
発言の真偽は、ベティは嘘・本当、エセルは嘘・本当、
ジョーンは嘘・本当、キティは嘘・本当、メアリは本当・嘘。
</span></p>


<p class="orig" lang="en">
<a name="%_thm_4.43"></a>
<b>Exercise 4.43.</b>  Use the <tt>amb</tt> evaluator to solve the following puzzle:<a name="call_footnote_Temp_616" href="#footnote_Temp_616"><sup><small>49</small></sup></a></p>

<p class="trans" lang="ja">
<b>練習問題 4.43.</b> <tt>amb</tt> 評価器を使って以下のパズルを解け<a href="#footnote_Temp_616"><sup><small>49</small></sup></a>。
</p>

<blockquote class="orig" lang="en">
Mary Ann Moore's father has a yacht and so has each of his four
friends:  Colonel Downing, Mr. Hall, Sir Barnacle Hood, and Dr.
Parker.  Each of the five also has one daughter and each has named his
yacht after a daughter of one of the others.  Sir Barnacle's yacht is
the Gabrielle, Mr. Moore owns the Lorna; Mr. Hall the Rosalind.  The
Melissa, owned by Colonel Downing, is named after Sir Barnacle's
daughter.  Gabrielle's father owns the yacht that is named after Dr.
Parker's daughter.  Who is Lorna's father?
</blockquote>

<blockquote class="trans" lang="ja">
メアリ・アン・ムーアの父はヨットを持っており、彼の4人の友人——すなわち、ダウニング大佐、ホール氏、バーナクル・フード卿、パーカー博士——のそれぞれも同様である。
5人の各々には1人の娘がいて、各人は、残りの人たちのうちの1人の娘にちなんで、自分のヨットを名付けた。
バーナクル卿のヨットはガブリエル号で、ムーア氏はロルナ号を所有している。ホール氏はロザリンド号である。
メリッサ号は、ダウニング大佐が所有しているのだが、バーナクル卿の娘にちなんで名付けられたものである。
ガブリエルの父は、パーカー博士の娘にちなんで名付けられたヨットを所有している。
誰がロルナの父だろうか?
</blockquote>

<p class="orig" lang="en">
Try to write the program so that it runs efficiently (see
exercise <a href="#%_thm_4.40">4.40</a>).  Also determine how many
solutions there are if we are not told that Mary Ann's last name is
Moore.
</p>

<p class="trans" lang="ja">
プログラムが効率よく動作するようにプログラムを書こうと試みよ (練習問題<a href="#%_thm_4.40">4.40</a>を参照)。
また、もしメアリ・アンの姓がムーアであると言われていなかったら、いくつの解があるのか、判定せよ。
</p>

<div class="exercise"><span class="ex_comment">人力でとりあえず解いてみよう。</span>
<table class="expl ex_comment">
<tr><th rowspan="2">娘の名</th><th colspan="5">父</th></tr>
<tr><th>ムーア氏</th><th>ダウニング大佐</th><th>ホール氏</th><th>バーナクル卿</th><th>パーカー博士</th></tr>
<tr><th>メアリ・アン</th><td>😀</td><td>❌</td><td>❌</td><td>❌</td><td>❌</td></tr>
<tr><th>ガブリエル</th><td>❌</td><td>🆖(3)</td><td>🎉(4)</td><td>❌</td><td>🆖(2)</td></tr>
<tr><th>ロルナ</th><td>❌</td><td>🎉(6)</td><td>×(4)</td><td>❌</td><td>×(5)</td></tr>
<tr><th>ロザリンド</th><td>❌</td><td>×(5)</td><td>🆖(1)</td><td>❌</td><td>🎉(5)</td></tr>
<tr><th>メリッサ</th><td>❌</td><td>❌</td><td>❌</td><td>😀</td><td>❌</td></tr>
</table>
<table class="expl ex_comment">
<tr><th rowspan="2">ヨットの名</th><th colspan="5">ヨット所有者</th></tr>
<tr><th>ムーア氏</th><th>ダウニング大佐</th><th>ホール氏</th><th>バーナクル卿</th><th>パーカー博士</th></tr>
<tr><th>メアリ・アン</th><td>❌</td><td>❌</td><td>❌</td><td>❌</td><td>⛵</td></tr>
<tr><th>ガブリエル</th><td>❌</td><td>❌</td><td>❌</td><td>😀</td><td>❌</td></tr>
<tr><th>ロルナ</th><td>😀</td><td>❌</td><td>❌</td><td>❌</td><td>❌</td></tr>
<tr><th>ロザリンド</th><td>❌</td><td>❌</td><td>😀</td><td>❌</td><td>❌</td></tr>
<tr><th>メリッサ</th><td>❌</td><td>😀</td><td>❌</td><td>❌</td><td>❌</td></tr>
</table>
<span class="ex_comment">(1) 😀は問題文に記述されていること。❌は、😀のある列・行の残りの部分。
ここからすぐに、⛵が判明する。
また、ヨットには自分の娘の名前をつけないので、🆖(1)も分かる。

(2) ここで、仮にガブリエルの父がパーカー博士だとすると、
「ガブリエルの父は、パーカー博士の娘にちなんで名付けられたヨットを所有している」
という記述(※)より、パーカー博士は自分の娘の名をヨットに付けていることになり、
矛盾する。よって、ガブリエルの父はパーカー博士ではない (🆖(2))。

(3) 次に、ガブリエルの父がダウニング大佐だとする。しかし、ダウニング大佐のヨットは
メリッサ号で、これはバーナクル卿の娘にちなんだ名である。つまり上記の記述(※)と
矛盾する。よって、ガブリエルの父はダウニング大佐でもない (🆖(3))。

(4) するとガブリエルの父の可能性があるのは、ホール氏のみである (🎉(4))。
ということはホール氏はロルナの父ではない (×(4))。

(5) ガブリエルの父たるホール氏が所有しているのは、ロザリンド号である。
上記の記述(※)より、パーカー博士の娘がロザリンドである (🎉(5))。
同じ列・行の空いているところも消せる (×(5))。

(6) というわけで、ロルナの父はダウニング大佐である (🎉(6))。</span>
</div>

<br>

<div class="exercise"><span class="ex_comment">もしメアリ・アンの姓がムーアであると言われていなかったら、どうなるか。</span>

<table class="expl ex_comment">
<tr><th rowspan="2">娘の名</th><th colspan="5">父</th></tr>
<tr><th>ムーア氏</th><th>ダウニング大佐</th><th>ホール氏</th><th>バーナクル卿</th><th>パーカー博士</th></tr>
<tr><th>メアリ・アン</th><td>🌺(d)</td><td></td><td>🌻(d)</td><td>❌</td><td>🆖(1)</td></tr>
<tr><th>ガブリエル</th><td>🌻(a)</td><td>🆖(3)</td><td>🌺(a)</td><td>❌</td><td>🆖(2)</td></tr>
<tr><th>ロルナ</th><td>🆖(1)</td><td>🌺(c)</td><td></td><td>❌</td><td>🌻(b)</td></tr>
<tr><th>ロザリンド</th><td></td><td>🌻(c)</td><td>🆖(1)</td><td>❌</td><td>🌺(b)</td></tr>
<tr><th>メリッサ</th><td>❌</td><td>❌</td><td>❌</td><td>😀</td><td>❌</td></tr>
</table>
<table class="expl ex_comment">
<tr><th rowspan="2">ヨットの名</th><th colspan="5">ヨット所有者</th></tr>
<tr><th>ムーア氏</th><th>ダウニング大佐</th><th>ホール氏</th><th>バーナクル卿</th><th>パーカー博士</th></tr>
<tr><th>メアリ・アン</th><td>❌</td><td>❌</td><td>❌</td><td>❌</td><td>⛵</td></tr>
<tr><th>ガブリエル</th><td>❌</td><td>❌</td><td>❌</td><td>😀</td><td>❌</td></tr>
<tr><th>ロルナ</th><td>😀</td><td>❌</td><td>❌</td><td>❌</td><td>❌</td></tr>
<tr><th>ロザリンド</th><td>❌</td><td>❌</td><td>😀</td><td>❌</td><td>❌</td></tr>
<tr><th>メリッサ</th><td>❌</td><td>😀</td><td>❌</td><td>❌</td><td>❌</td></tr>
</table>
<span class="ex_comment">(1) 😀は問題文に記述されていること。❌は、😀のある列・行の残りの部分。
ここからすぐに、⛵が判明する。
また、ヨットには自分の娘の名前をつけないので、🆖(1)も分かる。

(2) 仮にガブリエルの父がパーカー博士だとすると矛盾するのは、元の場合と同じ。
よって、ガブリエルの父はパーカー博士ではない (🆖(2))。

(3) ガブリエルの父がダウニング大佐でもあり得ない、という点も、元の場合と同じ (🆖(3))。

(4) 仮にガブリエルの父がムーア氏であるとする (🌻(a))。
ムーア氏のヨットはロルナ号なので、上記の記述(※)によれば、
ロルナはパーカー博士の娘ということになる (🌻(b))。
この場合に、ロザリンドの父の可能性があるのは、ダウニング大佐のみ (🌻(c))。
そうすると、メアリ・アンの父はホール氏に定まる (🌻(d))。

(5) 次にガブリエルの父がホール氏だと仮定する (🌺(a))。
ホール氏のヨットはロザリンド号なので、上記の記述(※)によれば、
ロザリンドはパーカー博士の娘ということになる (🌺(b))。
この場合に、ロルナの父の可能性があるのは、ダウニング大佐のみ (🌺(c))。
ということは、残ったムーア氏とメアリ・アンが親子である (🌺(d))。

(6) 以上より、🌻と🌺の2通りの解が存在する。
</span>
</div>

<p class="orig" lang="en">
<a name="%_thm_4.44"></a>
<b>Exercise 4.44.</b>  <a name="%_idx_4944"></a><a name="%_idx_4946"></a><a name="%_idx_4948"></a><a name="%_idx_4950"></a>Exercise <a href="15_sec2_2.html#%_thm_2.42">2.42</a> described the ``eight-queens puzzle'' of
placing queens on a chessboard so that no two attack each other.
Write a nondeterministic program to solve this puzzle.
</p>

<p class="trans" lang="ja">
<b>練習問題 4.44.</b> 練習問題<a href="15_sec2_2.html#%_thm_2.42">2.42</a>では、どの二つのクイーンも互いを攻撃しないようにクイーンをチェス盤の上に配置するという、「エイト・クイーン・パズル」について説明した。
このパズルを解くための非決定的プログラムを書け。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_Temp_618"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_618">Parsing natural language</a></h4>
<h4 class="trans" lang="ja">自然言語を構文解析する</h4>

<p class="orig" lang="en">
<a name="%_idx_4952"></a><a name="%_idx_4954"></a>
Programs designed to accept natural language as input usually start by
attempting to <em>parse</em> the input, that is, to match the input
against some grammatical structure.  For example, we might try to
recognize simple sentences consisting of an article followed by a noun
followed by a verb, such as ``The cat eats.''  To accomplish such an
analysis, we must be able to identify the parts of speech of
individual words.  We could start with some lists that classify
various words:<a name="call_footnote_Temp_619" href="#footnote_Temp_619"><sup><small>50</small></sup></a></p>

<p class="trans" lang="ja">
自然言語を入力として受け付けるように設計されたプログラムは、通常、入力を<em>構文解析する</em>——すなわち、何らかの文法構造に対して入力を適合させる——ことを試みることから、始まる。
たとえば、&ldquo;The cat eats.&rdquo; のように、冠詞があって、その後に名詞が続き、その後に動詞が続くように構成されている単純な文を認識しようとすることがあるかもしれない。
そうした解析を達成するには、個々の語の品詞を特定できなくてはならない。
様々な語を分類するようなある種のリストを使って、始めることもできる<a href="#footnote_Temp_619"><sup><small>50</small></sup></a>。
</p>

<p class="lisp"><a name="%_idx_4956"></a>(define nouns '(noun student professor cat class))
<a name="%_idx_4958"></a>(define verbs '(verb studies lectures eats sleeps))
<a name="%_idx_4960"></a>(define articles '(article the a))
</p>


<p class="orig" lang="en"><a name="%_idx_4962"></a>We also need a <em>grammar</em>, that is, a set of rules describing how
grammatical elements are composed from simpler elements.  A very
simple grammar might stipulate that a sentence always consists of two
pieces -- a noun phrase followed by a verb -- and that a noun phrase
consists of an article followed by a noun.  With this grammar, the
sentence ``The cat eats'' is parsed as follows:</p>

<p class="trans" lang="ja">
また、<em>文法</em>——すなわち、どのようにして文法的要素がより単純な要素から構成されるのか、ということを記述する規則の一式——も必要である。
非常に単純な文法は、文が常に二つの部分——名詞句とそれに続く動詞——からなり、名詞句は冠詞とそれに続く名詞からなる、と規定するかもしれない。
この文法を使うと、&ldquo;The cat eats.&rdquo; という文は、以下のように構文解析される。
</p>

<p class="lisp">(sentence (noun-phrase (article the) (noun cat))
          (verb eats))
</p>


<p class="orig" lang="en">
We can generate such a parse with a simple program that has separate
procedures for each of the grammatical rules.  To parse a sentence, we
identify its two constituent pieces and return a list of
these two elements, tagged with the symbol <tt>sentence</tt>:</p>

<p class="trans" lang="ja">
こうした構文解析を、文法的規則の各々について別々の手続きを有する単純なプログラムを使って、生成することが可能である。
文を構文解析するには、その文の二つの構成要素を特定し、これら二つの要素のリスト——ただし <tt>sentence</tt> という記号でタグ付けしたもの——を返す。
</p>


<a name="%_idx_4964"></a><p class="lisp">(define (parse-sentence)
  (list 'sentence
         (parse-noun-phrase)
         (parse-word verbs)))
</p>

<p class="orig" lang="en">A noun phrase, similarly, is parsed by finding an article followed by a
noun:</p>

<p class="trans" lang="ja">
名詞句は、同様に、冠詞とそれに続く名詞を見つけることで、構文解析される。
</p>

<p class="lisp">(define (parse-noun-phrase)
  (list 'noun-phrase
        (parse-word articles)
        (parse-word nouns)))
</p>

<p class="orig" lang="en">
At the lowest level, parsing boils down to repeatedly checking that
the next unparsed word is a member of the list of words for the
required part of speech.  To implement this, we maintain a global
variable <tt>*unparsed*</tt>, which is the input that has not yet been
parsed.  Each time we check a word, we require that <tt>*unparsed*</tt>
must be non-empty and that it should begin with a word from the
designated list.  If so, we remove that word from <tt>*unparsed*</tt> and
return the word together with its part of speech (which is found at
the head of the list):<a name="call_footnote_Temp_620" href="#footnote_Temp_620"><sup><small>51</small></sup></a></p>

<p class="trans" lang="ja">
もっとも低いレベルにおいて構文解析は、つまるところ、まだ構文解析されていない次の語が、求められる品詞の語のリストの構成要素であることを、繰り返し確認することに帰着する。
これを実装するには、<tt>*unparsed*</tt> という大域変数——まだ構文解析されていない入力である——を維持する。
語を確認するたびに、<tt>*unparsed*</tt> が非空でなければならないと要求するとともに、<tt>*unparsed*</tt> が指定されたリストの語で始まるべきであると要求する。
もしそうであれば、その語を <tt>*unparsed*</tt> から取り除き、その語をその品詞 (リストの先頭で見つかる) とともに返す。
</p>

<p class="lisp">(define (parse-word word-list)
  (require (not (null? *unparsed*)))
  (require (memq (car *unparsed*) (cdr word-list)))
  (let ((found-word (car *unparsed*)))
    (set! *unparsed* (cdr *unparsed*))
    (list (car word-list) found-word)))
</p>

<p class="orig" lang="en">
To start the parsing, all we need to do is set <tt>*unparsed*</tt> to be
the entire input, try to parse a sentence, and check that nothing is
left over:</p>

<p class="trans" lang="ja">
構文解析を始めるには、<tt>*unparsed*</tt> を完全な入力となるように設定して、文を構文解析することを試み、何も残らないことを確認するだけでよい。
</p>

<p class="lisp">(define *unparsed* '())
<a name="%_idx_4966"></a>(define (parse input)
  (set! *unparsed* input)
  (let ((sent (parse-sentence)))
    (require (null? *unparsed*))
    sent))
</p>

<p class="orig" lang="en">
We can now try the parser and verify that it works for our simple test
sentence:</p>

<p class="trans" lang="ja">
さて今や、構文解析器を試してみて、それが私たちの単純なテスト文に対してうまくいくことを確かめることが可能である。
</p>

<p class="lisp"><i>;;; Amb-Eval input:</i>
(parse '(the cat eats))
<i>;;; Starting a new problem</i>
<i>;;; Amb-Eval value:</i>
<i>(sentence (noun-phrase (article the) (noun cat)) (verb eats))</i>
</p>

<p class="orig" lang="en">
The <tt>amb</tt> evaluator is useful here because it is convenient to
express the parsing constraints with the aid of <tt>require</tt>.
Automatic search and backtracking really pay off, however, when we
consider more complex grammars where there are choices for how the
units can be decomposed.</p>

<p class="trans" lang="ja">
<tt>require</tt> の助けを借りて構文解析上の制約を表すのが便利なので、ここでは、<tt>amb</tt> 評価器が有用である。
自動的な探索とバックトラックは、しかし、単位をどのように分解できるのかについていくつかの選択肢があるような更に複雑な文法を考える場合に、本当に実を結ぶのである。
</p>

<p class="orig" lang="en">
Let's add to our grammar a list of prepositions:</p>

<p class="trans" lang="ja">
私たちの文法に、前置詞のリストを加えよう。
</p>

<p class="lisp"><a name="%_idx_4968"></a>(define prepositions '(prep for to in by with))
</p>

<p class="orig" lang="en">
and define a prepositional phrase (e.g., ``for the cat'') to be
a preposition followed by a noun phrase:</p>

<p class="trans" lang="ja">
そして、前置詞句 (たとえば &ldquo;for the cat&rdquo;) を、前置詞とそれに続く名詞句である、と定義しよう。
</p>

<p class="lisp">(define (parse-prepositional-phrase)
  (list 'prep-phrase
        (parse-word prepositions)
        (parse-noun-phrase)))
</p>


<p class="orig" lang="en">Now we can define a sentence to be a noun phrase followed by a verb
phrase, where a verb phrase can be either a verb or a verb phrase
extended by a prepositional phrase:<a name="call_footnote_Temp_621" href="#footnote_Temp_621"><sup><small>52</small></sup></a></p>

<p class="trans" lang="ja">
さて今や、文を、名詞句とそれに続く動詞句である、と定義でき、ここで動詞句とは、動詞か、前置詞により拡張された動詞句のいずれかであり得る <a href="#footnote_Temp_621"><sup><small>52</small></sup></a>。
</p>

<p class="lisp">(define (parse-sentence)
  (list 'sentence
         (parse-noun-phrase)
         (parse-verb-phrase)))
(define (parse-verb-phrase)
  (define (maybe-extend verb-phrase)
    (amb verb-phrase
         (maybe-extend (list 'verb-phrase
                             verb-phrase
                             (parse-prepositional-phrase)))))
  (maybe-extend (parse-word verbs)))
</p>

<p class="orig" lang="en">
While we're at it, we can also elaborate the definition of noun
phrases to permit such things as ``a cat in the class.''  What we used
to call a noun phrase, we'll now call a simple noun phrase, and a noun
phrase will now be either a simple noun phrase or a noun phrase
extended by a prepositional phrase:</p>

<p class="trans" lang="ja">
私たちは精を出す一方で <span class="note">(?)</span>、&ldquo;a cat in the class&rdquo; のようなものを許すために名詞句の定義を練り上げることもできる。
今まで名詞句と呼んできたものを、これからは単純名詞句と呼ぼう。そして、これからは、名詞句とは、単純名詞句か、前置詞句によって拡張された名詞句のいずれかとなる。
</p>

<p class="lisp">(define (parse-simple-noun-phrase)
  (list 'simple-noun-phrase
        (parse-word articles)
        (parse-word nouns)))
(define (parse-noun-phrase)
  (define (maybe-extend noun-phrase)
    (amb noun-phrase
         (maybe-extend (list 'noun-phrase
                             noun-phrase
                             (parse-prepositional-phrase)))))
  (maybe-extend (parse-simple-noun-phrase)))
</p>


<p class="orig" lang="en">
Our new grammar lets us parse more complex sentences.  For example</p>

<p class="trans" lang="ja">
新しい文法により、私たちは、より複雑な文を構文解析できる。
たとえば、
</p>

<p class="lisp">(parse '(the student with the cat sleeps in the class))
</p>

<p class="orig" lang="en">produces</p>

<p class="trans" lang="ja">
は、以下のものを作り出す。
</p>

<p class="lisp">(sentence
 (noun-phrase
  (simple-noun-phrase (article the) (noun student))
  (prep-phrase (prep with)
               (simple-noun-phrase
                (article the) (noun cat))))
 (verb-phrase
  (verb sleeps)
  (prep-phrase (prep in)
               (simple-noun-phrase
                (article the) (noun class)))))
</p>


<p class="orig" lang="en">
Observe that a given input may have more than one legal parse.  In
the sentence ``The professor lectures to the student with the cat,''
it may be that the professor is lecturing with the cat, or that the
student has the cat.  Our nondeterministic program finds both
possibilities:</p>

<p class="trans" lang="ja">
与えられた入力には、適法な構文解析結果が一つより多くあるかもしれない、ということに気づいてほしい。
&ldquo;The professor lectures to the student with the cat&rdquo;
という文では、教授が猫と一緒に講義を行っているのかもしれないし、あるいは、学生が猫を連れているのかもしれない。
私たちの非決定的プログラムは、双方の可能性を見つける。
</p>

<p class="lisp">(parse '(the professor lectures to the student with the cat))
</p>

<p class="orig" lang="en">produces</p>

<p class="trans" lang="ja">
は、以下のものを作り出す。
</p>

<p class="lisp">(sentence
 (simple-noun-phrase (article the) (noun professor))
 (verb-phrase
  (verb-phrase
   (verb lectures)
   (prep-phrase (prep to)
                (simple-noun-phrase
                 (article the) (noun student))))
  (prep-phrase (prep with)
               (simple-noun-phrase
                (article the) (noun cat)))))
</p>

<p class="orig" lang="en">Asking the evaluator to try again yields</p>

<p class="trans" lang="ja">
再び試みよ、と評価器に求めると、以下のものを生み出す。
</p>

<p class="lisp">(sentence
 (simple-noun-phrase (article the) (noun professor))
 (verb-phrase
  (verb lectures)
  (prep-phrase (prep to)
               (noun-phrase
                (simple-noun-phrase
                 (article the) (noun student))
                (prep-phrase (prep with)
                             (simple-noun-phrase
                              (article the) (noun cat)))))))
</p>

<p class="orig" lang="en">
<a name="%_thm_4.45"></a>
<b>Exercise 4.45.</b>  With the grammar given above, the following sentence can be parsed in
five different ways:
``The professor lectures to the student in the class with the cat.''
Give the five parses and explain the differences in shades of
meaning among them.
</p>

<p class="trans" lang="ja">
<b>練習問題 4.45.</b> 上記の文法が与えられた場合、以下の文は、異なる5通りの仕方で構文解析され得る。
&ldquo;The professor lectures to the student in the class with the cat.&rdquo;
5通りの構文解析結果を挙げ、それらの間での意味のニュアンスの違いを説明せよ。
</p>

<p class="exercise"><span class="ex_comment">ニュアンスの違いを汲み取り切れているか不安だが、
一応、以下の5通りが考えられる。</span>

The professor lectures to the student in the class with the cat.
---- NP ----- -- VP -- ---- PP ------
---- NP ----- ------ VP ------------- --- PP -----
---- NP ----- ------ VP -------------------------- ---- PP ----
---- NP ----- ------ VP ---------------------------------------
<span class="ex_comment">その授業で、教授がその学生に講義する。
(この授業に登録している学生はその一人なのかもしれないし、他の学生たちが
たまたま休んでいるのかもしれない。)
なお、教授はなぜか猫を連れて (あるいは猫を使って) 講義をしている。</span>

The professor lectures to the student in the class with the cat.
---- NP ----- -- VP -- ---------- PP ------------- 
---- NP ----- ------ VP -------------------------- ---- PP ----
---- NP ----- ------ VP ---------------------------------------
<span class="ex_comment">その学級のその学生に対して、教授が講義を行う。
(もしかしたら、正規の授業時間外に、その学生に対してだけ、講義してあげて
いるのかもしれない。)
なお、教授は猫を連れて (あるいは猫を使って) 講義をしている。</span>

The professor lectures to the student in the class with the cat.
---- NP ----- -- VP -- ---- PP ------
---- NP ----- ------ VP ------------- ---------- PP -----------
---- NP ----- ------ VP ---------------------------------------
<span class="ex_comment">猫を使ったその授業で、教授が学生に講義する。
(その授業科目自体が、なぜか猫を使う科目なのである。教授が愛猫家である
などの理由で教授が猫を連れてきたのだとは限らない。)
(この授業に登録している学生はその一人なのかもしれないし、他の学生たちが
たまたま休んでいるのかもしれない。)</span>

The professor lectures to the student in the class with the cat.
                          ---- NP --- ----- PP ---
                          -------- NP ------------ ---- PP ----
                       p. --------------- NP ------------------
---- NP ----- -- VP -- ------------------ PP ------------------
---- NP ----- ------ VP ---------------------------------------
<span class="ex_comment">猫を連れた、その学級のその学生に対して、教授が講義を行う。
(もしかしたら、正規の授業時間外に、その学生に対してだけ、講義してあげて
いるのかもしれない。)</span>

The professor lectures to the student in the class with the cat.
                          ---- NP --- ---------- PP -----------
                       p. --------------- NP ------------------
---- NP ----- -- VP -- ------------------ PP ------------------
---- NP ----- ------ VP ---------------------------------------
<span class="ex_comment">なぜかその猫はその学級の一員なのだが、その不思議な
学級に属しているその学生に対して、教授が講義を行う。
(あるいは、猫を使ったその授業を取っているその学生に対して、教授が講義を行う。)
(どちらにせよ、正規の授業時間外に、その学生に対してだけ、講義してあげて
いるのかもしれない、とも読める。)
</span></p>

<p class="orig" lang="en">
<a name="%_thm_4.46"></a>
<b>Exercise 4.46.</b>  <a name="%_idx_4970"></a>The evaluators in sections <a href="26_sec4_1.html#%_sec_4.1">4.1</a> and <a href="27_sec4_2.html#%_sec_4.2">4.2</a>
do not determine what order operands are evaluated in.
We will see that the <tt>amb</tt> evaluator evaluates them from left to right.
Explain why our parsing program wouldn't work if the operands were evaluated
in some other order.
</p>

<p class="trans" lang="ja">
<b>練習問題 4.46.</b> <a href="26_sec4_1.html#%_sec_4.1">4.1</a>節と<a href="27_sec4_2.html#%_sec_4.2">4.2</a>節での評価器は、オペランドがどういう順序で評価されるのかを定めない。
<tt>amb</tt> 評価器がオペランドを左から右へと評価することを、私たちは見るだろう。
もし何らかの別の順序でオペランドが評価されるのであったら、私たちの構文解析プログラムはうまく動かないであろう、という理由を、説明せよ。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_4.47"></a>
<b>Exercise 4.47.</b>  Louis Reasoner suggests that, since a verb phrase is either a verb or
a verb phrase followed by a prepositional phrase, it would be much more
straightforward to define the procedure <tt>parse-verb-phrase</tt> as
follows (and similarly for noun phrases):
</p>

<p class="trans" lang="ja">
<b>練習問題 4.47.</b> 動詞句とは、動詞か、動詞句とそれに続く前置詞句のどちらかなのだから、以下のような <tt>parse-verb-phrase</tt> という手続きを定義する方が、ずっと分りやすい (し、名詞句についても同様である)、とルイス・リーズナは示唆する。
</p>

<p class="lisp">(define (parse-verb-phrase)
  (amb (parse-word verbs)
       (list 'verb-phrase
             (parse-verb-phrase)
             (parse-prepositional-phrase))))
</p>

<p class="orig" lang="en">Does this work?  Does the program's behavior change if we interchange
the order of expressions in the <tt>amb</tt>?
</p>

<p class="trans" lang="ja">
これはうまく動くか?
もし <tt>amb</tt> の中の式の順序を入れ替えたら、プログラムの振る舞いは変化するか?
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_4.48"></a>
<b>Exercise 4.48.</b>  Extend the grammar given above to handle more complex sentences.  For
example, you could extend noun phrases and verb phrases to include
adjectives and adverbs, or you could handle compound sentences.<a name="call_footnote_Temp_626" href="#footnote_Temp_626"><sup><small>53</small></sup></a>
</p>

<p class="trans" lang="ja">
<b>練習問題 4.48.</b> より複雑な文を取り扱うように、上記の文法を拡張せよ。
たとえば、形容詞と副詞を含むように名詞句と動詞句を拡張できるだろうし、または、重文を取り扱うこともできるだろう<a href="#footnote_Temp_626"><sup><small>53</small></sup></a>。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>


<p class="orig" lang="en">
<a name="%_thm_4.49"></a>
<b>Exercise 4.49.</b>  <a name="%_idx_4976"></a>Alyssa P. Hacker is more interested in generating interesting
sentences than in parsing them.  She reasons that by simply changing
the procedure <tt>parse-word</tt> so that it ignores the ``input
sentence'' and instead always succeeds and generates an appropriate
word, we can use the programs we had built for parsing to do
generation instead.  Implement Alyssa's idea, and show the first
half-dozen or so sentences generated.<a name="call_footnote_Temp_628" href="#footnote_Temp_628"><sup><small>54</small></sup></a>
</p>

<p class="trans" lang="ja">
<b>練習問題 4.49.</b> アリッサ・P・ハッカは、興味深い文を構文解析することよりも、それらを生成することの方に興味がある。
<tt>parse-word</tt> が「入力文」を無視するように、そしてその代わりに、常に成功しては適切な語を生成するように、単純に <tt>parse-word</tt> を変更することで、構文解析用に構築したプログラムを使って、代わりに生成を行える、と彼女は推測する。
アリッサの考えを実装し、生成される最初の5〜6個程度の文を示せ<a href="#footnote_Temp_628"><sup><small>54</small></sup></a>。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_4.3.3"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_4.3.3">4.3.3  Implementing the <tt>Amb</tt> Evaluator</a></h3>
<h3 class="trans" lang="ja">4.3.3 <tt>amb</tt> 評価器を実装する</h3>


<p class="orig" lang="en"><a name="%_idx_4978"></a>
The evaluation of an ordinary Scheme expression may return a value,
may never terminate, or may signal an error.  In nondeterministic
Scheme the evaluation of an expression may in addition result in the
discovery of a dead end, in which case evaluation must backtrack to a previous
choice point.  The interpretation of nondeterministic Scheme is
complicated by this extra case.</p>

<p class="trans" lang="ja">
普通のSchemeの式を評価すると、値が返されることもあるし、決して終わらないこともあるし、あるいは、エラーの合図が出されることもある。
非決定的なSchemeでは、式の評価は、それに加えて、行き止まりの発見に終わることもあり、その場合、評価は前の選択点にバックトラックせねばならない。
非決定的なSchemeの解釈は、この追加的な場合によって複雑化している。
</p>


<p class="orig" lang="en">
<a name="%_idx_4980"></a>We will construct the <tt>amb</tt> evaluator for nondeterministic Scheme
by modifying the analyzing evaluator of section <a href="26_sec4_1.html#%_sec_4.1.7">4.1.7</a>.<a name="call_footnote_Temp_629" href="#footnote_Temp_629"><sup><small>55</small></sup></a>
As in the analyzing evaluator, evaluation of an expression is
accomplished by calling an <a name="%_idx_4982"></a>execution procedure produced by analysis of
that expression.  The difference between the interpretation of ordinary
Scheme and the interpretation of nondeterministic Scheme will be entirely
in the execution procedures.</p>

<p class="trans" lang="ja">
<a href="26_sec4_1.html#%_sec_4.1.7">4.1.7</a>節の、解析を行う評価器を改変することによって、非決定的なScheme用の <tt>amb</tt> 評価器を構築しよう<a href="#footnote_Temp_629"><sup><small>55</small></sup></a>。
解析を行う評価器におけるのと同様に、式の評価は、その式の解析によって生み出される実行手続きを呼び出すことによって、達成される。
普通のSchemeの解釈と非決定的なSchemeの解釈との違いは、もっぱら実行手続きの中にあるだろう。
</p>

<a name="%_sec_Temp_630"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_630">Execution procedures and continuations</a></h4>
<h4 class="trans" lang="ja">実行手続きと継続</h4>


<p class="orig" lang="en">
<a name="%_idx_4984"></a>
<a name="%_idx_4986"></a>Recall that the execution procedures for the ordinary evaluator take
one argument: the environment of execution.  In contrast, the
execution procedures in the <tt>amb</tt> evaluator take three arguments:
the environment, and two procedures called <em>continuation
procedures</em>.  The evaluation of an expression will finish by calling
one of these two continuations: If the evaluation results in a value,
the <a name="%_idx_4988"></a><em>success continuation</em> is called with that value; if the
evaluation results in the discovery of a dead end, the <a name="%_idx_4990"></a><em>failure
continuation</em> is called.  Constructing and calling appropriate
continuations is the mechanism by which the nondeterministic evaluator
implements backtracking.</p>

<p class="trans" lang="ja">
通常の評価器用の実行手続きが一つの引数——すなわち実行の環境——をとることを思い出そう。
対照的に、<tt>amb</tt> 評価器の実行手続きは、三つの引数——すなわち、環境と、<em>継続手続き</em>と呼ばれる二つの手続き——をとる。
式の評価は、これら二つの継続のうちの一つを呼び出すことで、完了するだろう。
もし、その評価が値という結果に終われば、<em>成功継続</em>がその値とともに呼び出される。
もし、その評価が行き止まりの発見という結果に終われば、<em>失敗継続</em>が呼び出される。
適切な継続を構築して呼び出すことが、非決定的な評価器がバックトラックを実装するのに使う仕組みなのである。
</p>

<p class="orig" lang="en">
It is the job of the success continuation to receive a value and
proceed with the computation.  Along with that value, the success
continuation is passed another failure continuation, which is to be
called subsequently if the use of that value leads to a dead end.</p>

<p class="trans" lang="ja">
値を受け取って計算を続けることは、成功継続の仕事である。
その値と一緒に成功継続は別の失敗継続へと渡されるのだが、その失敗継続とは、もしその値を使うことが行き止まりに繋がるならば、後に呼ばれることになるはずのものである。
</p>

<p class="orig" lang="en">
It is the job of the failure continuation to try another branch of the
nondeterministic process.  The essence of the nondeterministic
language is in the fact that expressions may represent choices among
alternatives.  The evaluation of such an expression must proceed with
one of the indicated alternative choices, even though it is not known
in advance which choices will lead to acceptable results.  To deal
with this, the evaluator picks one of the alternatives and passes this
value to the success continuation.  Together with this value, the
evaluator constructs and passes along a failure continuation that can
be called later to choose a different alternative.</p>

<p class="trans" lang="ja">
非決定的プロセスの別の分岐を試してみることが、失敗継続の仕事である。
非決定的言語の本質は、式が選択肢の間での選択を表しているのかもしれない、という事実にある。
そうした式の評価は、示された代替選択肢のうちの一つを続行しなくてはならない——どの選択肢が許容可能な結果に至るのか、ということが、たとえ事前には知られていなくてもである。
これを取り扱うために、評価器は、選択肢のうちの一つを選んで、この値を成功継続に渡す。
この値と一緒に、評価器は、別の選択肢を選ぶために後で呼ばれる可能性のある失敗継続を、構築し、かつ、渡す。
</p>

<p class="orig" lang="en">
A failure is triggered during evaluation (that is, a failure
continuation is called) when a user program explicitly rejects the
current line of attack (for example, a call to <tt>require</tt> may
result in execution of <tt>(amb)</tt>, an expression that always
fails -- see section <a href="#%_sec_4.3.1">4.3.1</a>).  The failure continuation in hand
at that point will cause the most recent choice point to choose
another alternative.  If there are no more alternatives to be
considered at that choice point, a failure at an earlier choice point
is triggered, and so on.  Failure continuations are also invoked by
the driver loop in response to a <tt>try-again</tt> request, to find
another value of the expression.</p>

<p class="trans" lang="ja">
現在の取り組みの路線をユーザ・プログラムが明示的に拒絶すると (たとえば、<tt>require</tt> の呼び出しは、<tt>(amb)</tt> ——すなわち常に失敗する式——の実行という結果になることがある。<a href="#%_sec_4.3.1">4.3.1</a>節を参照)、評価中に失敗の引き金が引かれる (つまり、失敗継続が呼び出される)。
その時点で手中にある失敗継続は、直近の選択点に別の選択肢を選ばせることだろう。
もし、その選択点で考慮すべき選択肢がそれ以上なければ、より早い選択点での失敗の引き金が引かれ、以下同様である。
失敗継続は、式の別の値を見つけるために、<tt>try-again</tt> の要求に応えてドライバ・ループによっても呼び出される。
</p>

<p class="orig" lang="en">
In addition, if a side-effect operation (such as assignment to a
variable) occurs on a branch of the process resulting from a choice,
it may be necessary, when the process finds a dead end, to undo the
side effect before making a new choice.  This is accomplished by
having the side-effect operation produce a failure continuation that
undoes the side effect and propagates the failure.</p>

<p class="trans" lang="ja">
さらに、選択の結果として起こる、プロセスのある分岐上で、(変数への<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>などといった) 副作用つき演算が起こると、そのプロセスが行き止まりを見つけたときには、新たな選択を行う前にその副作用を取り消すことが必要になる場合がある。
これは、副作用を取り消して失敗を伝播させるような失敗継続を、その副作用つき演算に作り出させることにより、達成される。
</p>

<p class="orig" lang="en">
In summary, failure continuations are constructed by
</p>

<p class="trans" lang="ja">
つまり、失敗継続は以下のものにより構築される。
</p>

<ul class="orig" lang="en">
<li><tt>amb</tt> expressions -- to provide a mechanism to make
alternative choices if the current choice made by the <tt>amb</tt>
expression leads to a dead end;</li>

<li>the top-level driver -- to provide a mechanism to report failure
when the choices are exhausted;</li>

<li>assignments -- to intercept failures and undo assignments
during backtracking.</li>
</ul>

<ul class="trans" lang="ja">
<li><tt>amb</tt> 式による——当該 <tt>amb</tt> 式によりなされた現在の選択が行き止まりに至ったら、別の選択を行う仕組みを、提供するためである。</li>
<li>トップレベル・ドライバによる——選択肢が尽きたときに失敗を報告する仕組みを提供するためである。</li>
<li><ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>による——バックトラックの最中に失敗を横取りして<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>を取り消すためである。</li>
</ul>

<p class="orig" lang="en">
Failures are initiated only when a dead end is encountered.
This occurs
</p>

<p class="trans" lang="ja">
失敗は、行き止まりに遭遇したときにのみ、開始される。
これは、次の場合に起こる。
</p>

<ul class="orig" lang="en">
<li>if the user program executes <tt>(amb)</tt>;</li>
<li>if the user types <tt>try-again</tt> at the top-level driver.</li>
</ul>

<ul class="trans" lang="ja">
<li>ユーザ・プログラムが <tt>(amb)</tt> を実行するとき。</li>
<li>ユーザがトップレベル・ドライバにおいて <tt>try-again</tt> と打つとき。</li>
</ul>

<p class="orig" lang="en">
Failure continuations are also called during processing of a failure:
</p>

<p class="trans" lang="ja">
失敗継続は、失敗の処理中にも呼ばれる。
</p>


<ul class="orig" lang="en">
<li>When the failure continuation created by an assignment finishes
undoing a side effect, it calls the failure continuation it intercepted,
in order to propagate the failure back to the choice point that
led to this assignment or to the top level.</li>

<li>When the failure continuation for an <tt>amb</tt> runs out of choices,
it calls the failure continuation that was originally given to the <tt>amb</tt>,
in order to propagate the failure back to the previous choice point
or to the top level.</li>
</ul>


<ul class="trans" lang="ja">
<li><ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>により作成された失敗継続は、副作用の取り消しを完了すると、この<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>につながった選択点またはトップレベルへと逆方向に失敗を伝播させるために、自分が横取りした失敗継続を呼び出す。</li>
<li><tt>amb</tt> のための失敗継続は、選択肢を使い尽くした場合には、前の選択点またはトップレベルへと逆方向に失敗を伝播させるために、当該 <tt>amb</tt> に元々与えられていた失敗継続を呼び出す。</li>
</ul>

<a name="%_sec_Temp_631"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_631">Structure of the evaluator</a></h4>
<h4 class="trans" lang="ja">評価器の構造</h4>


<p class="orig" lang="en">
<a name="%_idx_4992"></a>The syntax- and data-representation procedures for the <tt>amb</tt>
evaluator, and also the basic <tt>analyze</tt> procedure, are identical
to those in the evaluator of section <a href="26_sec4_1.html#%_sec_4.1.7">4.1.7</a>,
except for the fact that we need additional syntax procedures to
recognize the <tt>amb</tt> special form:<a name="call_footnote_Temp_632" href="#footnote_Temp_632"><sup><small>56</small></sup></a>
</p>

<p class="trans" lang="ja">
<tt>amb</tt> 評価器用の文法表現手続きとデータ表現手続きと、そしてまた基礎的な <tt>analyze</tt> 手続きは、<tt>amb</tt> の特殊形式を認識するための付加的な文法手続きが必要だという事実を除いて、<a href="26_sec4_1.html#%_sec_4.1.7">4.1.7</a>節の評価器でのものと同一である<a href="#footnote_Temp_632"><sup><small>56</small></sup></a>。
</p>

<p class="lisp">(define (amb? exp) (tagged-list? exp 'amb))
(define (amb-choices exp) (cdr exp))
</p>

<p class="orig" lang="en">We must also add to the dispatch in <tt>analyze</tt> a clause that will
recognize this special form and generate an appropriate execution procedure:</p>

<p class="trans" lang="ja">
また、この特殊形式を認識して適切な実行手続きを生成する節を、<tt>analyze</tt> における振り分けに追加せねばならない。
</p>

<p class="lisp">((amb? exp) (analyze-amb exp))
</p>

<p class="orig" lang="en">
The top-level procedure <tt>ambeval</tt> (similar to the version of <tt>eval</tt> given in section <a href="26_sec4_1.html#%_sec_4.1.7">4.1.7</a>) analyzes the
given expression and applies the resulting execution procedure to the
given environment, together with two given continuations:</p>

<p class="trans" lang="ja">
<tt>ambeval</tt> というトップレベルの手続き (<a href="26_sec4_1.html#%_sec_4.1.7">4.1.7</a>節で与えられたバージョンの <tt>eval</tt> と類似のもの) が、与えられた式を解析し、結果として生じる実行手続きを、二つの与えられた継続と一緒になっている、与えられた環境へと適用する。
</p>

<p class="lisp"><a name="%_idx_4994"></a>(define (ambeval exp env succeed fail)
  ((analyze exp) env succeed fail))
</p>

<p class="orig" lang="en">
<a name="%_idx_4996"></a><a name="%_idx_4998"></a><a name="%_idx_5000"></a>A success continuation is a procedure of two arguments: the value just
obtained and another failure continuation to be used if that value leads
to a subsequent failure. A failure continuation is a procedure of no
arguments.  So <a name="%_idx_5002"></a>the general form of an execution procedure is</p>

<p class="trans" lang="ja">
成功継続は、2引数の——つまり、ちょうど得られた値と、もしその値が後の失敗につながったら使われるべき別の失敗継続とをとる——手続きである。
失敗継続は、引数のない手続きである。
よって、実行手続きの一般形は以下のとおりである。
</p>

<p class="lisp">(lambda (env succeed fail)
  <em>;; <tt>succeed</tt> is <tt>(lambda (value fail) <tt>...</tt>)</tt></em>
  <em>;; <tt>fail</tt> is <tt>(lambda () <tt>...</tt>)</tt></em>
  <tt>...</tt>)
</p>

<p class="orig" lang="en">
For example, executing</p>

<p class="trans" lang="ja">
たとえば、以下のものを実行すると、
</p>

<p class="lisp">(ambeval &lt;<em>exp</em>&gt;
         the-global-environment
         (lambda (value fail) value)
         (lambda () 'failed))
</p>

<p class="orig" lang="en">will attempt to evaluate the given expression and will return
either the expression's value (if the evaluation succeeds) or
the symbol <tt>failed</tt> (if the evaluation fails).
The call to <tt>ambeval</tt> in the driver loop shown below uses
much more complicated continuation procedures, which continue the
loop and support the <tt>try-again</tt> request.</p>

<p class="trans" lang="ja">
与えられた式を評価しようとし、そして、その式の値を返す (評価が成功した場合) か、もしくは、<tt>failed</tt> という記号を返す (評価が失敗した場合) だろう。
以下に示す、ドライバ・ループ内での <tt>ambeval</tt> の呼び出しは、もっとずっと入り組んだ継続手続き——ループを続けて <tt>try-again</tt> の要求をサポートする——を使っている。
</p>

<p class="orig" lang="en">
Most of the complexity of the <tt>amb</tt> evaluator results
from the mechanics of passing the continuations around as the
execution procedures call each other.  In going through the following code,
you should compare each of the execution procedures with the
corresponding procedure for the ordinary evaluator given in
section <a href="26_sec4_1.html#%_sec_4.1.7">4.1.7</a>.</p>

<p class="trans" lang="ja">
<tt>amb</tt> 評価器の複雑さのほとんどは、実行手続きがお互いを呼び出すのに連れて継続を渡す手順に起因する。
以下のコードを詳しく検討する際に、君は、実行手続きの各々を、<a href="26_sec4_1.html#%_sec_4.1.7">4.1.7</a>節で与えられた通常の評価器のための、対応する手続きと、比較すべきである。
</p>

<a name="%_sec_Temp_633"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_633">Simple expressions</a></h4>
<h4 class="trans" lang="ja">単純な式</h4>


<p class="orig" lang="en">
The execution procedures for the simplest kinds of expressions are
essentially the same as those for the ordinary evaluator, except for the
need to manage the continuations.  The execution procedures simply
succeed with the value of the expression, passing along the failure
continuation that was passed to them.</p>

<p class="trans" lang="ja">
もっとも単純な種類の式のための実行手続きは、継続を管理する必要性を除けば、通常の評価器用のものと本質的に同じである。
実行手続きは、自分に渡された失敗継続を受け渡しつつも、単に式の値とともに成功するだけである。
</p>

<a name="%_idx_5004"></a>
<p class="lisp">(define (analyze-self-evaluating exp)
  (lambda (env succeed fail)
    (succeed exp fail)))
(define (analyze-quoted exp)
  (let ((qval (text-of-quotation exp)))
    (lambda (env succeed fail)
      (succeed qval fail))))
(define (analyze-variable exp)
  (lambda (env succeed fail)
    (succeed (lookup-variable-value exp env)
             fail)))
(define (analyze-lambda exp)
  (let ((vars (lambda-parameters exp))
        (bproc (analyze-sequence (lambda-body exp))))
    (lambda (env succeed fail)
      (succeed (make-procedure vars bproc env)
               fail))))
</p>

<p class="orig" lang="en">
<a name="%_idx_5006"></a>Notice that looking up a variable always ``succeeds.''  If <tt>lookup-variable-value</tt> fails to find the variable, it signals an
error, as usual.  Such a ``failure'' indicates a program bug -- a
reference to an unbound variable; it is not an indication that we
should try another nondeterministic choice instead of the one that is
currently being tried.</p>

<p class="trans" lang="ja">
変数を調べることが常に「成功する」ことに注意してほしい。
<tt>lookup-variable-value</tt> は、もし変数を見つけられなければ、通常どおり、エラーの合図をよこす。
そうした「失敗」は、プログラムのバグ——束縛されていない変数への参照——を示すが、これは、現在試しているものの代わりに別の非決定的選択肢を試すべきである、という<ruby><rb>徴</rb><rp> (</rp><rt>しるし</rt><rp>) </rp></ruby>ではない。
</p>

<a name="%_sec_Temp_634"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_634">Conditionals and sequences</a></h4>
<h4 class="trans" lang="ja">条件式と列</h4>


<p class="orig" lang="en">
Conditionals are also handled in a similar way as in the ordinary
evaluator.  The execution procedure generated by <tt>analyze-if</tt>
invokes the predicate execution procedure <tt>pproc</tt> with a success
continuation that checks whether the predicate value is true and goes
on to execute either the consequent or the alternative.  If the
execution of <tt>pproc</tt> fails, the original failure continuation for
the <tt>if</tt> expression is called.</p>

<p class="trans" lang="ja">
条件式も、普通の評価器における方法と同様な方法で扱われる。
<tt>analyze-if</tt> により生成される実行手続きは、<tt>pproc</tt> という述語実行手続きを、述語の値が真かどうかを調べる成功継続とともに呼び出して、それに続けて、帰結式または代替式のいずれかを実行する。
もし <tt>pproc</tt> の実行が失敗したら、<tt>if</tt> 式に対する元の失敗継続が呼ばれる。
</p>

<p class="lisp">(define (analyze-if exp)
  (let ((pproc (analyze (if-predicate exp)))
        (cproc (analyze (if-consequent exp)))
        (aproc (analyze (if-alternative exp))))
    (lambda (env succeed fail)
      (pproc env
             <em>;; success continuation for evaluating the predicate</em>
             <em>;; to obtain <tt>pred-value</tt></em>
             (lambda (pred-value fail2)
               (if (true? pred-value)
                   (cproc env succeed fail2)
                   (aproc env succeed fail2)))
             <em>;; failure continuation for evaluating the predicate</em>
             fail))))
</p>


<p class="orig" lang="en">
Sequences are also handled in the same way as in the previous
evaluator, except for the machinations in the subprocedure <tt>sequentially</tt> that are required for passing the continuations.
Namely, to sequentially execute <tt>a</tt> and then <tt>b</tt>, we call <tt>a</tt> with a success continuation that calls <tt>b</tt>.</p>

<p class="trans" lang="ja">
列も、継続を渡すのに必要な <tt>sequentially</tt> という下位手続きにおける計略を除けば、以前の評価器における方法と同じ方法で扱われる。
つまり、逐次的に <tt>a</tt> を実行してそれから <tt>b</tt> を実行するために、<tt>b</tt> を呼び出す成功継続とともに <tt>a</tt> を呼び出すわけだ。
</p>

<p class="lisp">(define (analyze-sequence exps)
  (define (sequentially a b)
    (lambda (env succeed fail)
      (a env
         <em>;; success continuation for calling <tt>a</tt></em>
         (lambda (a-value fail2)
           (b env succeed fail2))
         <em>;; failure continuation for calling <tt>a</tt></em>
         fail)))
  (define (loop first-proc rest-procs)
    (if (null? rest-procs)
        first-proc
        (loop (sequentially first-proc (car rest-procs))
              (cdr rest-procs))))
  (let ((procs (map analyze exps)))
    (if (null? procs)
        (error &quot;Empty sequence -- ANALYZE&quot;))
    (loop (car procs) (cdr procs))))
</p>

<a name="%_sec_Temp_635"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_635">Definitions and assignments</a></h4>
<h4 class="trans" lang="ja">定義と<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby></h4>


<p class="orig" lang="en">
Definitions are another case where we must go to some trouble to
manage the continuations, because it is necessary to evaluate the
definition-value expression before actually defining the new variable.
To accomplish this, the definition-value execution procedure <tt>vproc</tt> is called with the environment, a success continuation, and the
failure continuation.  If the execution of <tt>vproc</tt> succeeds,
obtaining a value <tt>val</tt> for the defined variable, the variable is
defined and the success is propagated:</p>

<p class="trans" lang="ja">
定義は、継続をなんとかうまく扱うべき、ある種の厄介ごとにならざるを得ない、もう一つの場合である。というのも、新たな変数を実際に定義する前に、定義の値の式を評価する必要があるからである。<span class="note">(? 要検討)</span>
これを達成するために、<tt>vproc</tt> という、定義の値の実行手続きが、環境と成功継続と失敗継続とともに呼ばれる。
もし <tt>vproc</tt> の実行が成功すれば、定義される変数のための <tt>val</tt> という値を取得しているわけだから <span class="note">(? 文のつながりは要検討)</span>、変数が定義され、成功が伝播される。
</p>

<p class="lisp">(define (analyze-definition exp)
  (let ((var (definition-variable exp))
        (vproc (analyze (definition-value exp))))
    (lambda (env succeed fail)
      (vproc env                        
             (lambda (val fail2)
               (define-variable! var val env)
               (succeed 'ok fail2))
             fail))))
</p>

<p class="orig" lang="en">
<a name="%_idx_5008"></a>Assignments are more interesting.  This is the first place where we
really use the continuations, rather than just passing them around.
The execution procedure for assignments starts out like the one for
definitions.  It first attempts to obtain the new value to be assigned
to the variable. If this evaluation of <tt>vproc</tt> fails, the
assignment fails.</p>

<p class="trans" lang="ja">
<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>は、もっと面白い。
これは、継続をただ受け渡してゆくというよりむしろ、真に継続を用いる、最初の場である。
<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>用の実行手続きは、定義用のものと似たような感じで始まる。
それは、まず、変数に<ruby><rb>代入される</rb><rp> (</rp><rt>わりあてられる</rt><rp>) </rp></ruby>べき新たな値を得ようとする。
もし、<tt>vproc</tt> のこの評価が失敗すれば、<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>は失敗する。
</p>

<p class="orig" lang="en">
If <tt>vproc</tt> succeeds, however, and we go on to make the assignment,
we must consider the possibility that this branch of the computation
might later fail, which will require us to backtrack out of the
assignment.  Thus, we must arrange to undo the assignment as
part of the backtracking process.<a name="call_footnote_Temp_636" href="#footnote_Temp_636"><sup><small>57</small></sup></a></p>

<p class="trans" lang="ja">
しかし、もし <tt>vproc</tt> が成功して、それに引き続いて<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>を行えば、私たちは、この計算の分岐が後に失敗するかもしれないという可能性を考えなくてはならないし、そのことは、<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>から抜けてバックトラックすることを要請するだろう。
よって、バックトラックする過程の一部として、<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>を取り消す手筈を整えねばならない<a href="#footnote_Temp_636"><sup><small>57</small></sup></a>。
</p>

<p class="orig" lang="en">
This is accomplished by giving <tt>vproc</tt> a success continuation
(marked with the comment ``*1*'' below) that saves the old value of
the variable before assigning the new value to the
variable and proceeding from the assignment.  The failure continuation
that is passed along with the value of the assignment (marked with the
comment ``*2*'' below) restores the old value of the variable
before continuing the failure.
That is, a successful assignment provides a failure continuation that
will intercept a subsequent failure; whatever failure would otherwise
have called <tt>fail2</tt> calls this procedure instead, to undo the
assignment before actually calling <tt>fail2</tt>.</p>

<p class="trans" lang="ja">
これは、変数に新たな値を<ruby><rb>代入する</rb><rp> (</rp><rt>わりあてる</rt><rp>) </rp></ruby>前の、その変数の古い値を退避するような成功継続 (以下では「*1*」というコメントで印が付けられている) を <tt>vproc</tt> に与えて、その<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>から続けることによって、達成される。
<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>の値とともに渡される失敗継続 (以下では「*2*」というコメントで印が付けられている) は、失敗を継続する前に、その変数の古い値を復元する。
つまり、成功した<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>は、後続の失敗を横取りすることになる失敗継続をもたらす。どのような失敗が他の方法で <tt>fail2</tt> を呼び出したのであれ、実際に <tt>fail2</tt> を呼ぶ前に<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>を取り消すために、代わりにこの手続きが呼び出すのである。<span class="note">(構文がうまく取れない。倒置?)</span>
</p>

<p class="lisp">(define (analyze-assignment exp)
  (let ((var (assignment-variable exp))
        (vproc (analyze (assignment-value exp))))
    (lambda (env succeed fail)
      (vproc env
             (lambda (val fail2)        <em>; *1*</em>
               (let ((old-value
                      (lookup-variable-value var env))) 
                 (set-variable-value! var val env)
                 (succeed 'ok
                          (lambda ()    <em>; *2*</em>
                            (set-variable-value! var
                                                 old-value
                                                 env)
                            (fail2)))))
             fail))))
</p>

<a name="%_sec_Temp_637"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_637">Procedure applications</a></h4>
<h4 class="trans" lang="ja">手続き適用</h4>

<p class="orig" lang="en">
The execution procedure for applications contains no new ideas except
for the technical complexity of managing the continuations.  This
complexity arises in <tt>analyze-application</tt>, due to the need to
keep track of the success and failure continuations as we evaluate the
operands.  We use a procedure <tt>get-args</tt> to evaluate the list of
operands, rather than a simple <tt>map</tt> as in the ordinary evaluator.</p>

<p class="trans" lang="ja">
適用についての実行手続きは、継続を管理することの技術的な複雑さを除いて、何も新しい考えを含んではいない。
この複雑さは、オペランドを評価する際に成功継続と失敗継続を把握し続ける必要があるせいで、<tt>analyze-application</tt> において生じる。
オペランドのリストを評価するためには、元の評価器でのように単純な <tt>map</tt> を使うのではなく、<tt>get-args</tt> という手続きを使う。
</p>

<p class="lisp">(define (analyze-application exp)
  (let ((fproc (analyze (operator exp)))
        (aprocs (map analyze (operands exp))))
    (lambda (env succeed fail)
      (fproc env
             (lambda (proc fail2)
               (get-args aprocs
                         env
                         (lambda (args fail3)
                           (execute-application
                            proc args succeed fail3))
                         fail2))
             fail))))
</p>

<p class="orig" lang="en">
In <tt>get-args</tt>, notice how <tt>cdr</tt>ing down the list of <tt>aproc</tt> execution procedures and <tt>cons</tt>ing up the resulting list of
<tt>args</tt> is accomplished by calling each <tt>aproc</tt> in the list
with a success continuation that recursively calls <tt>get-args</tt>.
Each of these recursive calls to <tt>get-args</tt> has a success
continuation whose value is the <tt>cons</tt> of the newly obtained
argument onto the list of accumulated arguments:</p>

<p class="trans" lang="ja">
<tt>get-args</tt> においては、<tt>aproc</tt> 実行手続きのリストの <tt>cdr</tt> をとっていってそれから結果としてできる <tt>args</tt> のリストを <tt>cons</tt> してまとめてゆくことが、<tt>get-args</tt> を再帰的に呼び出す成功継続とともにリスト内のそれぞれの <tt>aproc</tt> を呼び出すことにより、どのようにして達成されるのか、ということに注意してほしい。
<tt>get-args</tt> に対するこれらの再帰呼び出しの各々は、蓄積された引数のリストの前に、新たに得られた引数を付けた <tt>cons</tt> を値とするような、成功継続を持っている。
</p>

<p class="lisp">(define (get-args aprocs env succeed fail)
  (if (null? aprocs)
      (succeed '() fail)
      ((car aprocs) env
                    <em>;; success continuation for this <tt>aproc</tt></em>
                    (lambda (arg fail2)
                      (get-args (cdr aprocs)
                                env
                                <em>;; success continuation for recursive</em>
                                <em>;; call to <tt>get-args</tt></em>
                                (lambda (args fail3)
                                  (succeed (cons arg args)
                                           fail3))
                                fail2))
                    fail)))
</p>


<p class="orig" lang="en">
The actual procedure application, which is
performed by <tt>execute-application</tt>, is
accomplished in the same way as for the ordinary evaluator, except for
the need to manage the continuations.</p>

<p class="trans" lang="ja">
実際の手続き適用は、<tt>execute-application</tt> により実行されるものなのだが、継続を管理する必要性を除けば、元の評価器についてのものと同様にして達成される。
</p>

<p class="lisp"><a name="%_idx_5012"></a>(define (execute-application proc args succeed fail)
  (cond ((primitive-procedure? proc)
         (succeed (apply-primitive-procedure proc args)
                  fail))
        ((compound-procedure? proc)
         ((procedure-body proc)
          (extend-environment (procedure-parameters proc)
                              args
                              (procedure-environment proc))
          succeed
          fail))
        (else
         (error
          &quot;Unknown procedure type -- EXECUTE-APPLICATION&quot;
          proc))))
</p>

<a name="%_sec_Temp_638"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_638">Evaluating <tt>amb</tt> expressions</a></h4>
<h4 class="trans" lang="ja"><tt>amb</tt> 式を評価する</h4>

<p class="orig" lang="en">
<a name="%_idx_5014"></a>The <tt>amb</tt> special form is the key element in the nondeterministic
language.  Here we see the essence of the interpretation process and
the reason for keeping track of the continuations.  The execution
procedure for <tt>amb</tt> defines a loop <tt>try-next</tt> that cycles
through the execution procedures for all the possible values of the
<tt>amb</tt> expression.  Each execution procedure is called with a
failure continuation that will try the next one.  When there are no
more alternatives to try, the entire <tt>amb</tt> expression fails.</p>

<p class="trans" lang="ja">
<tt>amb</tt> という特殊形式は、非決定的言語における鍵となる要素である。
ここでは、解釈過程の最重要点と、継続を把握し続ける理由を見る。
<tt>amb</tt> に対する実行手続きは、<tt>amb</tt> 式のあらゆる可能な値に対する実行手続き全部を通じて循環する、<tt>try-next</tt> というループを定義している。
各実行手続きは、次のものを試すことになるであろう失敗継続とともに、呼ばれる。
試すべき更なる代替物がなくなったら、<tt>amb</tt> 式全体が失敗する。
</p>

<p class="lisp"><a name="%_idx_5016"></a>(define (analyze-amb exp)
  (let ((cprocs (map analyze (amb-choices exp))))
    (lambda (env succeed fail)
      (define (try-next choices)
        (if (null? choices)
            (fail)
            ((car choices) env
                           succeed
                           (lambda ()
                             (try-next (cdr choices))))))
      (try-next cprocs))))
</p>

<a name="%_sec_Temp_639"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_639">Driver loop</a></h4>
<h4 class="trans" lang="ja">ドライバ・ループ</h4>


<p class="orig" lang="en">
<a name="%_idx_5018"></a>
<a name="%_idx_5020"></a>The driver loop for the <tt>amb</tt> evaluator is complex, due to
the mechanism that permits the user to try again in evaluating an
expression.  The driver uses a procedure called <tt>internal-loop</tt>,
which takes as argument a procedure <tt>try-again</tt>.  The intent is
that calling <tt>try-again</tt> should go on to the next untried
alternative in the nondeterministic evaluation.  <tt>Internal-loop</tt>
either calls <tt>try-again</tt> in response to the user typing <tt>try-again</tt> at the driver loop, or else starts a new evaluation by
calling <tt>ambeval</tt>.  </p>

<p class="trans" lang="ja">
<tt>amb</tt> 評価器用のドライバ・ループは、式を評価する際にユーザが再度試せるようにする仕組みのために、複雑である。
ドライバは、<tt>internal-loop</tt> と呼ばれる手続きを使うが、これは、引数として <tt>try-again</tt> という手続きをとる。
その意図は、<tt>try-again</tt> を呼び出すことは、それに引き続いて、非決定的評価における、まだ試していない次の代替物へと進むべきである、というものである。
<tt>internal-loop</tt> は、ドライバ・ループにおいてユーザが <tt>try-again</tt> と打ち込むのに応じて  <tt>try-again</tt> を呼び出すか、そうでなければ、<tt>ambeval</tt> を呼び出すことで新たな評価を開始するか、のいずれかである。
</p>

<p class="orig" lang="en">
The failure continuation for this call to <tt>ambeval</tt>
informs the user that there are no more values and re-invokes the driver loop.</p>

<p class="trans" lang="ja">
この <tt>ambeval</tt> の呼び出しに対する失敗継続は、更なる値はもうないのだとユーザに知らせるとともに、ドライバ・ループを再度呼び出す。
</p>

<p class="orig" lang="en">
The success continuation for the call to <tt>ambeval</tt>
is more subtle.  We print the obtained value and then invoke
the internal loop again with a <tt>try-again</tt> procedure that will be
able to try the next alternative.  This <tt>next-alternative</tt>
procedure is the second argument that was passed to the
success continuation.  Ordinarily, we think of this second argument
as a failure continuation to be used if the current evaluation branch
later fails.  In this case, however, we have completed a successful
evaluation, so we can invoke the ``failure'' alternative branch in
order to search for additional successful evaluations.</p>

<p class="trans" lang="ja">
<tt>ambeval</tt> の呼び出しに対する成功継続は、より微妙である。
得られた値を印字して、それから、内部ループを、次の代替物を試すことができるであろう <tt>try-again</tt> という手続きとともに、再度呼び出すのだ。
この <tt>next-alternative</tt> という手続きは、成功継続に渡された2番目の引数である。
大抵は、この2番目の引数を、現在の評価分岐が後に失敗したら使われることになる失敗継続と見なす。
しかし、この場合、成功した評価を完了したところなのであり、よって、さらなる成功する評価を探すためには、「失敗」の代替分岐を呼び出せる。
<span class="note">(要検討)</span>
</p>

<p class="lisp"><a name="%_idx_5022"></a>(define input-prompt &quot;;;; Amb-Eval input:&quot;)
(define output-prompt &quot;;;; Amb-Eval value:&quot;)
<a name="%_idx_5024"></a>(define (driver-loop)
  (define (internal-loop try-again)
    (prompt-for-input input-prompt)
    (let ((input (read)))
      (if (eq? input 'try-again)
          (try-again)
          (begin
            (newline)
            (display &quot;;;; Starting a new problem &quot;)
            (ambeval input
                     the-global-environment
                     <em>;; <tt>ambeval</tt> success</em>
                     (lambda (val next-alternative)
                       (announce-output output-prompt)
                       (user-print val)
                       (internal-loop next-alternative))
                     <em>;; <tt>ambeval</tt> failure</em>
                     (lambda ()
                       (announce-output
                        &quot;;;; There are no more values of&quot;)
                       (user-print input)
                       (driver-loop)))))))
  (internal-loop
   (lambda ()
     (newline)
     (display &quot;;;; There is no current problem&quot;)
     (driver-loop))))
</p>

<p class="orig" lang="en">The initial call to <tt>internal-loop</tt> uses a <tt>try-again</tt> procedure that complains that there is no current
problem and restarts the driver loop.  This is the behavior that will
happen if the user types <tt>try-again</tt> when there is no evaluation
in progress.</p>

<p class="trans" lang="ja">
<tt>internal-loop</tt> への最初の呼び出しは、今は何も問題がないと訴えてドライバ・ループを再度開始する、<tt>try-again</tt> という手続きを使う。
これは、進行中の評価が何もない場合にユーザが <tt>try-again</tt> と打ち込んだら起こるであろう振る舞いである。
</p>

<p class="orig" lang="en">
<a name="%_thm_4.50"></a>
<b>Exercise 4.50.</b>  Implement a new special form <tt>ramb</tt> that is like <tt>amb</tt> except that it searches alternatives in a random order, rather 
than from left to right.  Show how this can help with Alyssa's problem
in exercise <a href="#%_thm_4.49">4.49</a>.
</p>

<p class="trans" lang="ja">
<b>練習問題 4.50.</b> 左から右へというよりもむしろランダムな順序で代替物を探す、という点を除けば <tt>amb</tt> に似ている、<tt>ramb</tt> という新たな特殊形式を実装せよ。
これが、練習問題<a href="#%_thm_4.49">4.49</a>におけるアリッサの問題をどのように助けるのかを示せ。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>


<p class="orig" lang="en">
<a name="%_thm_4.51"></a>
<b>Exercise 4.51.</b>  Implement a new kind of assignment called <tt>permanent-set!</tt> that
is not undone upon failure.  For example, we can choose two distinct
elements from a list and count the number of trials required to make a
successful choice as follows:</p>

<p class="trans" lang="ja">
<b>練習問題 4.51.</b> 失敗の際に取り消されない、<tt>permanent-set!</tt> と呼ばれる新たな種類の<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>を実装せよ。
たとえば、以下のようにして、リストから二つの異なる要素を選んで、成功する選択を行うまでに要する試行の回数を数える、ということが可能だ。
</p>

<p class="lisp">(define count 0)
(let ((x (an-element-of '(a b c)))
      (y (an-element-of '(a b c))))
  (permanent-set! count (+ count 1))
  (require (not (eq? x y)))
  (list x y count))
<i>;;; Starting a new problem</i>
<i>;;; Amb-Eval value:</i>
<i>(a b 2)</i>
<i>;;; Amb-Eval input:</i>
try-again
<i>;;; Amb-Eval value:</i>
<i>(a c 3)</i>
</p>


<p class="orig" lang="en">What values would have been displayed if we had used <tt>set!</tt> here
rather than <tt>permanent-set!</tt> ?
</p>

<p class="trans" lang="ja">
もしここで <tt>permanent-set!</tt> ではなく <tt>set!</tt> を使っていたら、どのような値が表示されていただろうか?
</p>

<p class="exercise"><span class="ex_comment">
</span></p>


<p class="orig" lang="en">
<a name="%_thm_4.52"></a>
<b>Exercise 4.52.</b>  Implement a new construct called <tt>if-fail</tt> that permits the user to
catch the failure of an expression.  <tt>If-fail</tt> takes two
expressions.  It evaluates the first expression as usual and returns
as usual if the evaluation succeeds.  If the evaluation fails,
however, the value of the second expression is returned, as in the
following example:
</p>

<p class="trans" lang="ja">
<b>練習問題 4.52.</b> ユーザが式の失敗を捕まえることを可能にする、<tt>if-fail</tt> と呼ばれる新たな構造を実装せよ。
<tt>if-fail</tt> は二つの式をとる。
これは、1番目の式を通常どおり評価し、その式が成功すれば通常どおりに返ってくる。
しかし、もし評価が失敗すれば、以下の例のように、2番目の式の値が返される。
</p>

<p class="lisp"><i>;;; Amb-Eval input:</i>
(if-fail (let ((x (an-element-of '(1 3 5))))
           (require (even? x))
           x)
         'all-odd)
<i>;;; Starting a new problem</i>
<i>;;; Amb-Eval value:</i>
<i>all-odd</i>
<i>;;; Amb-Eval input:</i>
(if-fail (let ((x (an-element-of '(1 3 5 8))))
           (require (even? x))
           x)
         'all-odd)
<i>;;; Starting a new problem</i>
<i>;;; Amb-Eval value:</i>
<i>8</i>
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_4.53"></a>
<b>Exercise 4.53.</b>  With <tt>permanent-set!</tt> as described in
exercise <a href="#%_thm_4.51">4.51</a> and <tt>if-fail</tt> as in
exercise <a href="#%_thm_4.52">4.52</a>, what will be the result of evaluating
</p>


<p class="trans" lang="ja">
<b>練習問題 4.53.</b> 練習問題<a href="#%_thm_4.51">4.51</a>で説明したような <tt>permanent-set!</tt> と、練習問題<a href="#%_thm_4.52">4.52</a>のような <tt>if-fail</tt> があるとして、以下のものを評価した結果はどうなるか。
</p>

<p class="lisp">(let ((pairs '()))
  (if-fail (let ((p (prime-sum-pair '(1 3 5 8) '(20 35 110))))
             (permanent-set! pairs (cons p pairs))
             (amb))
           pairs))
</p>

<p class="exercise"><span class="ex_comment">
</span></p>


<p class="extra" id="translating">***ここから</p>
<p class="orig" lang="en">
<a name="%_thm_4.54"></a>
<b>Exercise 4.54.</b>  <a name="%_idx_5026"></a>If we had not realized that <tt>require</tt> could be implemented as an
ordinary procedure that uses <tt>amb</tt>, to be defined by the user as
part of a nondeterministic program, we would have had to implement it
as a special form.  This would require syntax procedures</p>

<p class="trans" lang="ja">
<b>練習問題 4.54.</b> 非決定的プログラムの一部としてユーザにより定義されることになる筈の、<tt>amb</tt> を用いる通常の手続きとして、<tt>require</tt> を実装できるのだ、ということに、もし私たちが気づかなかったとしたら、私たちは、<tt>require</tt> を特殊形式として実装せざるを得なかったことだろう。
これは、次のような文法手続きを必要とするだろうし、
</p>

<p class="lisp">(define (require? exp) (tagged-list? exp 'require))

(define (require-predicate exp) (cadr exp))
</p>

<p class="orig" lang="en">and a new clause in the dispatch in <tt>analyze</tt></p>

<p class="trans" lang="ja">
<tt>analyze</tt> の中の振り分けにおける、以下のような新たな節も必要とするだろうし、
</p>

<p class="lisp">((require? exp) (analyze-require exp))
</p>

<p class="orig" lang="en">as well the procedure <tt>analyze-require</tt> that handles <tt>require</tt>
expressions.  Complete the following definition of <tt>analyze-require</tt>.</p>

<p class="trans" lang="ja">
<tt>require</tt> 式を扱う、<tt>analyze-require</tt> という手続きも同様に必要とするだろう。
以下の <tt>analyze-require</tt> の定義を完成させよ。
</p>

<p class="lisp">(define (analyze-require exp)
  (let ((pproc (analyze (require-predicate exp))))
    (lambda (env succeed fail)
      (pproc env
             (lambda (pred-value fail2)
               (if &lt;<em>??</em>&gt;
                   &lt;<em>??</em>&gt;
                   (succeed 'ok fail2)))
             fail))))
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<a name="footnotes"></a>
<hr>
<p class="orig" lang="en"><a name="footnote_Temp_598" href="#call_footnote_Temp_598"><sup><small>42</small></sup></a> We assume that we have previously defined a
procedure <tt>prime?</tt> that tests whether numbers are prime.  Even with
<tt>prime?</tt> defined, the <tt>prime-sum-pair</tt> procedure may look
suspiciously like the unhelpful ``pseudo-Lisp'' attempt to define the
square-root function, which we described at the beginning of
section <a href="10_sec1_1.html#%_sec_1.1.7">1.1.7</a>.  In fact, a square-root procedure along those
lines can actually be formulated as a nondeterministic program.
By incorporating a search mechanism into the evaluator, we
are eroding the <a name="%_idx_4816"></a><a name="%_idx_4818"></a>distinction between purely declarative descriptions
and imperative specifications of how to compute answers.  We'll go
even farther in this direction in
section <a href="29_sec4_4.html#%_sec_4.4">4.4</a>.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_598"><sup><small>42</small></sup></a>
数が素数かどうかを検査する <tt>prime?</tt> という手続きを、前もって定義済みである、と私たちは想定している。
<tt>prime?</tt> が定義されていてさえ、<tt>prime-sum-pair</tt> という手続きは、疑わしくも、二乗根関数を定義するための役立たずの「擬似Lisp」的な試み——<a href="10_sec1_1.html#%_sec_1.1.7">1.1.7</a>節の最初で説明した——と同様なものように見えてしまうかもしれない。
実を言うと、その手の二乗根関数を、実際に非決定的プログラムとして定式化できる。
探索メカニズムを評価器の中に取り入れることによって、私たちは、答えをどのようにして計算するのかについての、純粋に宣言的な記述と命令的な指定との間の区別を、侵蝕しているところなのである。
<a href="29_sec4_4.html#%_sec_4.4">4.4</a>節では、この方向のもっと先にまですら行くことになるだろう。
</p>



<p class="orig" lang="en"><a name="footnote_Temp_599" href="#call_footnote_Temp_599"><sup><small>43</small></sup></a> The idea of <tt>amb</tt> for nondeterministic programming was
<a name="%_idx_4824"></a>first described in 1961 by John McCarthy (see McCarthy 1967).</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_599"><sup><small>43</small></sup></a>
非決定的プログラミングのための <tt>amb</tt> の概念は、最初、1961年にジョン・マッカーシーによって記述された (McCarthy 1967 を参照)。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_600" href="#call_footnote_Temp_600"><sup><small>44</small></sup></a> In actuality, the distinction between nondeterministically
returning a single choice and returning all choices depends somewhat
on our point of view.  From the perspective of the code that uses the
value, the nondeterministic choice returns a single value.  From the
perspective of the programmer designing the code, the nondeterministic
choice potentially returns all possible values, and the computation
branches so that each value is investigated separately.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_600"><sup><small>44</small></sup></a>
現実には、非決定的に単一の選択肢を返すことと、すべての選択肢を返すことの区別は、ある程度は私たちの視点による。
値を使うコードの視点からは、非決定的な選択は、単一の値を返すのである。
コードを設計するプログラマの観点からは、非決定的な選択は、潜在的にすべての可能な値を返すのであり、それぞれの値が別々に調査されるように、計算は分岐するのである。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_601" href="#call_footnote_Temp_601"><sup><small>45</small></sup></a> One might object that this is a hopelessly
inefficient mechanism.  It might require millions of processors to
solve some easily stated problem this way, and most of the time most
of those processors would be idle.  This objection should be taken in
the context of history.  Memory used to be considered just such an
expensive commodity.  <a name="%_idx_4838"></a>In 1964 a megabyte of RAM cost about $400,000.
Now every personal computer has many megabytes of RAM, and most of the
time most of that RAM is unused.  It is hard to underestimate the cost
of mass-produced electronics.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_601"><sup><small>45</small></sup></a>
これはどうしようもなく非効率的な仕組みだ、と人は異議を唱えるかもしれない。
簡単に記述されるある種の問題をこの方法で解くのに、何百万台ものプロセッサを必要とするかもしれないし、ほとんどの時間、それらのプロセッサのうちのほとんどが遊んでいるだろう、と。
この異議は、歴史の文脈で捉えられるべきである。
メモリは、かつて、ちょうどそうした高価な商品であると考えられていた。
1964年には、1メガバイトのRAMは、約40万米ドルした。
現在、あらゆるパーソナル・コンピュータが何メガバイトものRAMを備えており、ほとんどの時間、そのRAMのほとんどは使われていない。
<span class="note">(そして今では何ギガバイト単位である。)</span>
大量生産される電子回路部品の費用を少なめに見積もることは難しい。
</p>



<p class="orig" lang="en"><a name="footnote_Temp_602" href="#call_footnote_Temp_602"><sup><small>46</small></sup></a> Automagically: ``Automatically, but in a way
which, for some reason (typically because it is too complicated, or
too ugly, or perhaps even too trivial), the speaker doesn't feel like
explaining.''  (Steele 1983, Raymond 1993)</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_602"><sup><small>46</small></sup></a>
オートマジカルに、とは「自動的に、だが、何らかの理由で (典型的には、複雑すぎるから、もしくは、あまりに見苦しいからという理由で、または、ひょっとすると、あまりに瑣末だから、という理由さえもあり得るが)、話者が説明したくないと思っている方法で」の意 (Steele 1983, Raymond 1993)。
</p>



<p class="orig" lang="en"><a name="footnote_Temp_603" href="#call_footnote_Temp_603"><sup><small>47</small></sup></a> The integration of automatic search strategies
<a name="%_idx_4860"></a>into programming languages has had a long and checkered history.  The
first suggestions that nondeterministic algorithms might be elegantly
encoded in a programming language with search and automatic
backtracking came from <a name="%_idx_4862"></a>Robert Floyd (1967).  <a name="%_idx_4864"></a>Carl Hewitt
(1969) invented a programming language called <a name="%_idx_4866"></a>Planner that explicitly
supported automatic chronological backtracking, providing for a
built-in depth-first search strategy.  <a name="%_idx_4868"></a><a name="%_idx_4870"></a><a name="%_idx_4872"></a>Sussman, Winograd, and Charniak 
(1971) implemented a subset of this language, called <a name="%_idx_4874"></a>MicroPlanner,
which was used to support work in problem solving and robot planning.
Similar ideas, arising from logic and theorem proving, led to the
genesis in Edinburgh and Marseille of the elegant language <a name="%_idx_4876"></a>Prolog
(which we will discuss in section <a href="29_sec4_4.html#%_sec_4.4">4.4</a>).  After
sufficient frustration with automatic search, <a name="%_idx_4878"></a><a name="%_idx_4880"></a>McDermott and Sussman
(1972) developed a language called <a name="%_idx_4882"></a>Conniver, which included mechanisms
for placing the search strategy under programmer control.  This proved
unwieldy, however, and <a name="%_idx_4884"></a><a name="%_idx_4886"></a>Sussman and Stallman (1975) found a more
tractable approach while investigating methods of symbolic analysis
for electrical circuits.  They developed a non-chronological
backtracking scheme that was based on tracing out the logical
dependencies connecting facts, a technique that has come to be known
as <a name="%_idx_4888"></a><em>dependency-directed backtracking</em>.  Although their method was
complex, it produced reasonably efficient programs because it did
little redundant search.  <a name="%_idx_4890"></a><a name="%_idx_4892"></a>Doyle (1979) and McAllester (1978, 1980)
generalized and clarified the methods of Stallman and Sussman,
developing a new paradigm for formulating search that is now called
<a name="%_idx_4894"></a><em>truth maintenance</em>.  Modern problem-solving systems all
use some form of truth-maintenance system as a substrate.  See <a name="%_idx_4896"></a><a name="%_idx_4898"></a>Forbus
and deKleer 1993 for a discussion of elegant ways to build
truth-maintenance systems and applications using truth maintenance.
<a name="%_idx_4900"></a><a name="%_idx_4902"></a><a name="%_idx_4904"></a>Zabih, McAllester, and
Chapman 1987 describes a nondeterministic extension to Scheme that
is based on <tt>amb</tt>; it is similar to the interpreter described in
this section, but more sophisticated, because it uses
dependency-directed backtracking rather than chronological
<a name="%_idx_4906"></a>backtracking.  Winston 1992 gives an introduction to both kinds of
backtracking.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_603"><sup><small>47</small></sup></a>
自動的探索戦略のプログラミング言語への統合は、長く波乱に富んだ歴史を重ねてきた。
非決定的アルゴリズムを、探索と自動的バックトラッキングをともなうプログラミング言語の中に、<!--洗練された-->簡潔な方法でコード化できるかもしれない、という最初の示唆は、Robert Floyd (1967) に由来する。
Carl Hewitt (1969) は、明示的に自動的時系列順バックトラッキングをサポートする、Planner と呼ばれるプログラミング言語を考案し、組み込みの深さ優先探索戦略を与えた。
Sussman, Winograd, and Charniak (1971) は、この言語のサブセット——MicroPlanner と呼ばれる——を実装し、これは、問題解決とロボット計画立案における作業を支援するのに使われた。
似たような考えが、論理および定理証明から生じたのだが、これは、Prolog という<!--洗練された-->明晰な言語 (<a href="29_sec4_4.html#%_sec_4.4">4.4</a>節で議論することにしよう) の、エディンバラとマルセイユにおける起源につながった。
自動的探索にともなう十分な頓挫の後に、McDermott and Sussman
(1972) は、Conniver と呼ばれる言語を開発したが、これは、探索戦略をプログラマの制御のもとに置くための仕組みを含んでいた。
しかし、これは扱いにくいと分かり、Sussman and Stallman (1975) は、電気回路用の記号的解析の方法を調べつつ、より扱いやすい手法を見つけた。
かれらは、事実同士をつなぐ論理的依存関係を突き止めることに基づいた、非時系列的バックトラッキングの体系——すなわち、<em>依存関係指向のバックトラッキング</em>として知られることになった技法——を開発した。
かれらの手法は複雑だったが、やや冗長な探索を行ったので、まずまず効率的なプログラムを作り出した。
Doyle (1979) and McAllester (1978, 1980) はストールマンとサスマンの手法を一般化・明確化し、今では<em>真理維持</em>と呼ばれる、探索を定式化するための新たな枠組みを、開発した。
近代的な問題解決システムは、すべて、真理維持システムの何らかの形を基盤として使っている。
真理維持システムを構築するための<!--洗練された-->簡潔な方法と、真理維持を使う応用とについての議論に関しては、Forbus and deKleer 1993 を参照のこと。
Zabih, McAllester, and Chapman 1987 では、<tt>amb</tt> に基づいた、Schemeに対する非決定論的拡張を説明している。これは、本節で説明するインタプリタに似ているが、時系列順バックトラッキングではなくむしろ依存関係指向のバックトラッキングを使うので、より精巧である。
Winston 1992 は、双方の種類のバックトラッキングについての序論を示している。
</p>


<p class="orig" lang="en"><a name="footnote_Temp_609" href="#call_footnote_Temp_609"><sup><small>48</small></sup></a> Our program uses the following procedure to determine 
if the elements of a list are distinct:
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_609"><sup><small>48</small></sup></a>
私たちのプログラムは、リストの要素同士が相異なるか否かを判定するための以下の手続きを用いる。
</p>

<p class="lisp"><a name="%_idx_4934"></a>(define (distinct? items)
  (cond ((null? items) true)
        ((null? (cdr items)) true)
        ((member (car items) (cdr items)) false)
        (else (distinct? (cdr items)))))
</p>

<p class="orig" lang="en"><a name="%_idx_4936"></a><tt>Member</tt> is like <tt>memq</tt> except that it uses <tt>equal?</tt> instead
of <tt>eq?</tt> to test for equality.</p>

<p class="trans" lang="ja">
<tt>member</tt> は、等価性を検査するために <tt>eq?</tt> の代わりに <tt>equal?</tt> を使う、という点を除いて、<tt>memq</tt> と同様である。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_616" href="#call_footnote_Temp_616"><sup><small>49</small></sup></a> This is taken from a booklet called ``Problematical
Recreations,'' published in the 1960s by Litton Industries, where it
is attributed to the <em>Kansas State Engineer</em>.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_616"><sup><small>49</small></sup></a>
これは、1960年代にリットン工業により出版された「難しいお愉しみ」と呼ばれる小冊子から取られたもので、その小冊子では、これは、<em>カンザス州の技師</em>の作であるとされている。
</p>



<p class="orig" lang="en"><a name="footnote_Temp_619" href="#call_footnote_Temp_619"><sup><small>50</small></sup></a> Here we use the convention that the first element of each list
designates the part of speech for the rest of the words in the list.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_619"><sup><small>50</small></sup></a>
ここでは、各リストの最初の要素が、そのリスト内の残りの語の品詞を指定する、という慣習を用いている。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_620" href="#call_footnote_Temp_620"><sup><small>51</small></sup></a> Notice that <tt>parse-word</tt> uses <tt>set!</tt> to modify the
unparsed input list.  For this to work, our <tt>amb</tt> evaluator must
undo the effects of <tt>set!</tt> operations when it backtracks.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_620"><sup><small>51</small></sup></a>
<tt>parse-word</tt> が <tt>set!</tt> を使って、構文解析されていない入力リストを改変する、ということに気づいてほしい。
これがうまくいくようにするには、私たちの <tt>amb</tt> 評価器は、バックトラックするときに <tt>set!</tt> 操作の効果を取り消さなくてはならない。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_621" href="#call_footnote_Temp_621"><sup><small>52</small></sup></a> Observe that this
definition is recursive -- a verb may be followed by any number
of prepositional phrases.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_621"><sup><small>52</small></sup></a>
この定義が再帰的である——動詞の後には、いくつの前置詞句が続いていてもよい——ことに気づいてほしい。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_626" href="#call_footnote_Temp_626"><sup><small>53</small></sup></a> This kind of grammar can become arbitrarily complex, but it
<a name="%_idx_4972"></a>is only a toy as far as real language understanding is concerned.
Real natural-language understanding by computer requires an elaborate
mixture of syntactic analysis and interpretation of meaning.  On the
other hand, even toy parsers can be useful in supporting flexible
command languages for programs such as information-retrieval systems.
<a name="%_idx_4974"></a>Winston 1992 discusses computational approaches to real
language understanding and also the applications of simple grammars to
command languages.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_626"><sup><small>53</small></sup></a>
この種の文法は、任意に複雑なものになり得るが、現実の言語理解に関する限り、おもちゃに過ぎない。
コンピュータによる現実の自然言語理解には、構文的な分析と意味の解釈の、込み入った混合物が必要である。
一方、おもちゃ的な構文解析器でさえも、情報検索システムのようなプログラムのための柔軟なコマンド言語をサポートするうえでは、有用たり得る。
Winston 1992 では、現実の言語理解への、コンピュータを用いた手法について議論しており、また、単純な文法のコマンド言語への適用についても議論している。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_628" href="#call_footnote_Temp_628"><sup><small>54</small></sup></a> Although Alyssa's idea works just fine (and is
surprisingly simple), the sentences that it generates are a bit
boring -- they don't sample the possible sentences of this language in
a very interesting way.  In fact, the grammar is highly recursive in
many places, and Alyssa's technique ``falls into'' one of these recursions and
gets stuck.  See exercise <a href="#%_thm_4.50">4.50</a> for a way to deal with this.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_628"><sup><small>54</small></sup></a>
アリッサの考えは、まさに申し分なくうまくいく (それに驚くほど簡潔である) のだが、その考えで生成される文は、やや退屈である——それらの文は、とても面白い方法でこの言語の可能な文の標本を抽出しているわけではないのだ。
実際、文法は多くの場所で非常に再帰的であり、アリッサの技法は、これらの再帰のうちの一つに「落ち込み」、そこから抜け出せない。
これを扱うための方法については、練習問題<a href="#%_thm_4.50">4.50</a>を参照のこと。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_629" href="#call_footnote_Temp_629"><sup><small>55</small></sup></a> We chose to implement the lazy evaluator in
section <a href="27_sec4_2.html#%_sec_4.2">4.2</a> as a modification of the ordinary
metacircular evaluator of section <a href="26_sec4_1.html#%_sec_4.1.1">4.1.1</a>.  In
contrast, we will base the <tt>amb</tt> evaluator on the analyzing evaluator
of section <a href="26_sec4_1.html#%_sec_4.1.7">4.1.7</a>, because the execution procedures
in that evaluator provide a convenient framework for implementing
backtracking.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_629"><sup><small>55</small></sup></a>
<a href="27_sec4_2.html#%_sec_4.2">4.2</a>節では、<a href="26_sec4_1.html#%_sec_4.1.1">4.1.1</a>節の普通のメタ循環的な評価器の改変版として遅延評価器を実装することを選んだ。
それとは対照的に、<tt>amb</tt> 評価器の基礎は、<a href="26_sec4_1.html#%_sec_4.1.7">4.1.7</a>節の解析を行う評価器に置くことにしよう。というのも、その評価器での実行手続きが、バックトラックを実装するための便利な枠組みを与えてくれるためである。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_632" href="#call_footnote_Temp_632"><sup><small>56</small></sup></a> We assume that the evaluator supports <tt>let</tt>
(see exercise <a href="26_sec4_1.html#%_thm_4.22">4.22</a>),
which we have used in our nondeterministic programs.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_632"><sup><small>56</small></sup></a>
<tt>let</tt> ——非決定的プログラムで使った—— (練習問題<a href="26_sec4_1.html#%_thm_4.22">4.22</a>を参照) を評価器がサポートしていることを仮定している。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_636" href="#call_footnote_Temp_636"><sup><small>57</small></sup></a> We didn't worry about undoing definitions, since we can
<a name="%_idx_5010"></a>assume that internal definitions are scanned out
(section <a href="26_sec4_1.html#%_sec_4.1.6">4.1.6</a>).</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_636"><sup><small>57</small></sup></a>
定義を取り消すことについては心配していなかった。というのも、内部定義は走査され尽くす (<a href="26_sec4_1.html#%_sec_4.1.6">4.1.6</a>節) と仮定できるためである。
</p>

</div>
</body>
</html>
