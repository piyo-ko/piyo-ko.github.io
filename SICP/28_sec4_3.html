<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="sicp.css" type="text/css">
<base target="_top">
<title>Structure and Interpretation of Computer Programs: SICPç§è¨³</title>
</head>
<body>

<div class="idx-bar">
<nav>
<a href="https://twitter.com/share" class="twitter-share-button" data-lang="ja">ãƒ„ã‚¤ãƒ¼ãƒˆ</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
<span class="status">æ¨æ•²å¾…ã¡</span>
[
<a href="00_cover.html">å…ˆé ­ã¸</a> |
<a href="27_sec4_2.html">å‰ã¸</a> |
<a href="29_sec4_4.html">æ¬¡ã¸</a> |
<a href="04_toc.html#%_toc_start">ç›®æ¬¡</a> |
<a href="38_index.html#%_index_start">ç´¢å¼•</a>
] [<a href="99_about.html">ã“ã®å¯¾è¨³ç‰ˆã«ã¤ã„ã¦</a> | <a href="../index.html">ãƒ›ãƒ¼ãƒ </a>]
[
Â§<a href="#%_sec_4.3">4.3</a>
Â§<a href="#%_sec_4.3.1">4.3.1</a>
ğŸ“š<a href="#%_sec_Temp_604">&hellip;</a>
ğŸ“<a href="#%_thm_4.35">4.35</a>
ğŸ“<a href="#%_thm_4.36">4.36</a>
ğŸ“<a href="#%_thm_4.37">4.37</a>
Â§<a href="#%_sec_4.3.2">4.3.2</a>
ğŸ“š<a href="#%_sec_Temp_608">&hellip;</a>
ğŸ“<a href="#%_thm_4.38">4.38</a>
ğŸ“<a href="#%_thm_4.39">4.39</a>
ğŸ“<a href="#%_thm_4.40">4.40</a>
ğŸ“<a href="#%_thm_4.41">4.41</a>
ğŸ“<a href="#%_thm_4.42">4.42</a>
ğŸ“<a href="#%_thm_4.43">4.43</a>
ğŸ“<a href="#%_thm_4.44">4.44</a>
ğŸ“š<a href="#%_sec_Temp_618">&hellip;</a>
ğŸ“<a href="#%_thm_4.45">4.45</a>
ğŸ“<a href="#%_thm_4.46">4.46</a>
ğŸ“<a href="#%_thm_4.47">4.47</a>
ğŸ“<a href="#%_thm_4.48">4.48</a>
ğŸ“<a href="#%_thm_4.49">4.49</a>
Â§<a href="#%_sec_4.3.3">4.3.3</a>
ğŸ“š<a href="#%_sec_Temp_630">&hellip;</a>
ğŸ“š<a href="#%_sec_Temp_631">&hellip;</a>
ğŸ“š<a href="#%_sec_Temp_633">&hellip;</a>
ğŸ“š<a href="#%_sec_Temp_634">&hellip;</a>
ğŸ“š<a href="#%_sec_Temp_635">&hellip;</a>
ğŸ“š<a href="#%_sec_Temp_637">&hellip;</a>
ğŸ“š<a href="#%_sec_Temp_638">&hellip;</a>
ğŸ“š<a href="#%_sec_Temp_639">&hellip;</a>
ğŸ“<a href="#%_thm_4.50">4.50</a>
ğŸ“<a href="#%_thm_4.51">4.51</a>
ğŸ“<a href="#%_thm_4.52">4.52</a>
ğŸ“<a href="#%_thm_4.53">4.53</a>
ğŸ“<a href="#%_thm_4.54">4.54</a>
<a href="#footnotes">è„šæ³¨</a>
]
</nav>
</div>

<div class="main-txt">
<a name="%_sec_4.3"></a>
<h2 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_4.3">4.3  Variations on a Scheme -- Nondeterministic Computing</a></h2>
<h2 class="trans" lang="ja">4.3 Schemeã®å¤‰ç¨®â€”â€”éæ±ºå®šçš„è¨ˆç®—</h2>


<p class="orig" lang="en">
<a name="%_idx_4806"></a>
<a name="%_idx_4808"></a>In this section, we extend the Scheme evaluator to support a
programming paradigm called <em>nondeterministic computing</em> by
building into the evaluator a facility to support automatic search.
This is a much more profound change to the language than the
introduction of lazy evaluation in section <a href="27_sec4_2.html#%_sec_4.2">4.2</a>.</p>

<p class="trans" lang="ja">
æœ¬ç¯€ã§ã¯ã€è‡ªå‹•çš„æ¢ç´¢ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹æ©Ÿèƒ½ã‚’è©•ä¾¡å™¨ã®ä¸­ã«çµ„ã¿è¾¼ã‚€ã“ã¨ã«ã‚ˆã£ã¦ã€<em>éæ±ºå®šçš„è¨ˆç®—</em>ã¨å‘¼ã°ã‚Œã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ãƒ»ãƒ‘ãƒ©ãƒ€ã‚¤ãƒ ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚ˆã†ã€Schemeè©•ä¾¡å™¨ã‚’æ‹¡å¼µã™ã‚‹ã€‚
ã“ã‚Œã¯ã€<a href="27_sec4_2.html#%_sec_4.2">4.2</a>ç¯€ã§ã®é…å»¶è©•ä¾¡ã®å°å…¥ã‚ˆã‚Šã‚‚ãšã£ã¨é‡å¤§ãªã€è¨€èªã«å¯¾ã™ã‚‹å¤‰æ›´ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_4810"></a>Nondeterministic computing, like stream processing, is useful for
``generate and test'' applications.  Consider the task of starting with
two lists of positive integers and finding a pair of integers -- one
from the first list and one from the second list -- whose sum is prime.
We saw how to handle this with finite sequence operations in
section <a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a> and with infinite streams in
section <a href="24_sec3_5.html#%_sec_3.5.3">3.5.3</a>.  Our approach was to generate
the sequence of all possible pairs and filter these to select the
pairs whose sum is prime.  Whether we actually generate the entire
sequence of pairs first as in chapter 2, or interleave the generating
and filtering as in chapter 3, is immaterial to the essential image of
how the computation is organized.</p>

<p class="trans" lang="ja">
éæ±ºå®šçš„è¨ˆç®—ã¯ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ å‡¦ç†ã¨åŒæ§˜ã«ã€ã€Œç”Ÿæˆã—ã¦ã¯æ¤œæŸ»ã™ã‚‹ã€ç”¨é€”ã«ã¨ã£ã¦æœ‰ç›Šã§ã‚ã‚‹ã€‚
æ­£æ•´æ•°ã®äºŒã¤ã®ãƒªã‚¹ãƒˆã‹ã‚‰å§‹ã‚ã¦ã€å’ŒãŒç´ æ•°ã§ã‚ã‚‹ã‚ˆã†ãªæ•´æ•°åŒå£«â€”â€”ç¬¬1ã®ãƒªã‚¹ãƒˆã‹ã‚‰ã®ã‚‚ã®ã¨ç¬¬2ã®ãƒªã‚¹ãƒˆã‹ã‚‰ã®ã‚‚ã®â€”â€”ã®å¯¾ã‚’è¦‹ã¤ã‘ã‚‹ã€ã¨ã„ã†èª²é¡Œã‚’è€ƒãˆã‚ˆã†ã€‚
æœ‰é™ã®åˆ—æ¼”ç®—ã‚’ä½¿ã£ã¦ã“ã‚Œã‚’ã©ã†æ‰±ã†ã‹ã«ã¤ã„ã¦ã¯<a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a>ç¯€ã§è¦‹ãŸã—ã€ç„¡é™ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½¿ã£ã¦ã“ã‚Œã‚’ã©ã†æ‰±ã†ã‹ã«ã¤ã„ã¦ã¯<a href="24_sec3_5.html#%_sec_3.5.3">3.5.3</a>ç¯€ã§è¦‹ãŸã€‚
ç§ãŸã¡ã®æ‰‹æ³•ã¯ã€ã™ã¹ã¦ã®å¯èƒ½ãªå¯¾ã®é€£ãªã‚Šã‚’ç”Ÿæˆã—ã€ãã‚Œã‹ã‚‰ã€å’ŒãŒç´ æ•°ã§ã‚ã‚‹ã‚ˆã†ãªå¯¾ã‚’é¸ã¶ãŸã‚ã«ã€ã“ã‚Œã‚‰ã®å¯¾ã‚’ãƒ•ã‚£ãƒ«ã‚¿ã«ã‹ã‘ã‚‹ã€ã¨ã„ã†ã‚‚ã®ã§ã‚ã£ãŸã€‚
2ç« ã§ã®ã‚ˆã†ã«å¯¾ã®é€£ãªã‚Šå…¨ä½“ã‚’æœ€åˆã«å®Ÿéš›ã«ç”Ÿæˆã™ã‚‹ã®ã‹ã€ãã‚Œã¨ã‚‚3ç« ã§ã®ã‚ˆã†ã«ç”Ÿæˆã¨ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã‚’äº¤äº’ã«è¡Œã†ã®ã‹ã€ã¨ã„ã†ã“ã¨ã¯ã€è¨ˆç®—ãŒã©ã®ã‚ˆã†ã«çµ„ç¹”åŒ–ã•ã‚Œã‚‹ã®ã‹ã€ã¨ã„ã†æœ¬è³ªçš„ãª<ruby><rb>åƒ</rb><rp> (</rp><rt>ã‹ãŸã¡</rt><rp>) </rp></ruby>ã«ã¨ã£ã¦ã¯é‡è¦ã§ã¯ãªã„ã€‚
</p>


<p class="orig" lang="en">
<a name="%_idx_4812"></a>The nondeterministic approach evokes a different image.  Imagine simply
that we choose (in some way) a number from the first list and a number
from the second list and require (using some mechanism) that their sum
be prime.  This is expressed by following procedure:</p>

<p class="trans" lang="ja">
éæ±ºå®šçš„æ‰‹æ³•ã¯ã€ç•°ãªã‚‹åƒã‚’å‘¼ã³è¦šã¾ã™ã€‚
ç§ãŸã¡ãŒ (ä½•ã‚‰ã‹ã®æ–¹æ³•ã§) ç¬¬1ã®ãƒªã‚¹ãƒˆã‹ã‚‰æ•°ã‚’é¸ã³ã€ç¬¬2ã®ãƒªã‚¹ãƒˆã‹ã‚‰æ•°ã‚’é¸ã³ã€ãã‚Œã‚‰ã®å’ŒãŒç´ æ•°ã§ã‚ã‚‹ã“ã¨ã‚’ (ä½•ã‚‰ã‹ã®ä»•çµ„ã¿ã‚’ä½¿ã£ã¦) è¦æ±‚ã™ã‚‹ã®ã ã€ã¨å˜ç´”ã«æƒ³åƒã—ã‚ˆã†ã€‚
ã“ã‚Œã¯ã€ä»¥ä¸‹ã®æ‰‹ç¶šãã«ã‚ˆã‚Šè¡¨ã•ã‚Œã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_4814"></a>(define (prime-sum-pair list1 list2)
  (let ((a (an-element-of list1))
        (b (an-element-of list2)))
    (require (prime? (+ a b)))
    (list a b)))
</p>

<p class="orig" lang="en">It might seem as if this procedure merely restates the problem,
rather than specifying a way to solve it.  Nevertheless, this is
a legitimate nondeterministic program.<a name="call_footnote_Temp_598" href="#footnote_Temp_598"><sup><small>42</small></sup></a></p>

<p class="trans" lang="ja">
ã‚ãŸã‹ã‚‚ã“ã®æ‰‹ç¶šããŒã€å•é¡Œã‚’è§£ãæ–¹æ³•ã‚’æŒ‡å®šã™ã‚‹ã®ã§ã¯ãªãã¦ã€ã‚€ã—ã‚å˜ã«å•é¡Œã‚’å†åº¦è¿°ã¹ã¦ã„ã‚‹ã ã‘ã§ã‚ã‚‹ã‹ã®ã‚ˆã†ã«è¦‹ãˆã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚
ãã‚Œã«ã‚‚ã‹ã‹ã‚ã‚‰ãšã€ã“ã‚Œã¯ç†ã«ã‹ãªã£ãŸéæ±ºå®šçš„ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãªã®ã <a href="#footnote_Temp_598"><sup><small>42</small></sup></a>ã€‚
</p>

<p class="orig" lang="en">
The key idea here is that expressions in a nondeterministic language
can have more than one possible value.  For instance,
<tt>an-element-of</tt> might return any element of the given list.  Our
nondeterministic program evaluator will work by automatically choosing
a possible value and keeping track of the choice.  If a subsequent
requirement is not met, the evaluator will try a different choice, and
it will keep trying new choices until the evaluation succeeds, or
until we run out of choices.  Just as the lazy evaluator freed the
programmer from the details of how values are delayed and forced, the
nondeterministic program evaluator will free the programmer from the
details of how choices are made.</p>

<p class="trans" lang="ja">
ã“ã“ã§éµã¨ãªã‚‹æ¦‚å¿µã¯ã€éæ±ºå®šçš„ãªè¨€èªã«ãŠã‘ã‚‹å¼ãŒã€ä¸€ã¤ã®å¯èƒ½ãªå€¤ã¨ã„ã†ä»¥ä¸Šã®ã‚‚ã®ã‚’æŒã¡å¾—ã‚‹ã€ã¨ã„ã†ã“ã¨ã§ã‚ã‚‹ã€‚
ãŸã¨ãˆã°ã€<tt>an-element-of</tt> ã¯ã€ä¸ãˆã‚‰ã‚ŒãŸãƒªã‚¹ãƒˆã®ä»»æ„ã®è¦ç´ ã‚’è¿”ã™ã‹ã‚‚ã—ã‚Œãªã„ã€‚
ç§ãŸã¡ã®éæ±ºå®šçš„ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ è©•ä¾¡å™¨ã¯ã€å¯èƒ½ãªå€¤ã‚’è‡ªå‹•çš„ã«é¸ã‚“ã§ã€ãã®é¸æŠã«ã¤ã„ã¦è¿½è·¡ã™ã‚‹ã“ã¨ã§ã€ã†ã¾ãå‹•ãã ã‚ã†ã€‚
ã‚‚ã—å¾Œç¶šã®è¦ä»¶ãŒæº€ãŸã•ã‚Œãªã‘ã‚Œã°ã€è©•ä¾¡å™¨ã¯åˆ¥ã®é¸æŠè‚¢ã‚’è©¦ã™ã ã‚ã†ã—ã€è©•ä¾¡ãŒæˆåŠŸã™ã‚‹ã¾ã§ã€ã‚‚ã—ãã¯é¸æŠè‚¢ã‚’ä½¿ã„æœãŸã™ã¾ã§ã€è©•ä¾¡å™¨ã¯æ–°ãŸãªé¸æŠè‚¢ã‚’è¿½è·¡ã™ã‚‹ã ã‚ã†ã€‚
å€¤ãŒã©ã®ã‚ˆã†ã«ã—ã¦é…å»¶ã•ã‚ŒãŸã‚Šå¼·åˆ¶ã•ã‚ŒãŸã‚Šã™ã‚‹ã®ã‹ã€ã¨ã„ã†è©³ç´°ã‹ã‚‰ã€é…å»¶è©•ä¾¡å™¨ãŒãƒ—ãƒ­ã‚°ãƒ©ãƒã‚’è§£ãæ”¾ã£ã¦ãã‚ŒãŸã®ã¨ã¡ã‚‡ã†ã©åŒã˜ã‚ˆã†ã«ã€éæ±ºå®šçš„ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ è©•ä¾¡å™¨ã¯ã€ã©ã®ã‚ˆã†ã«ã—ã¦é¸æŠãŒãªã•ã‚Œã‚‹ã®ã‹ã€ã¨ã„ã†è©³ç´°ã‹ã‚‰ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒã‚’è§£ãæ”¾ã£ã¦ãã‚Œã‚‹ã ã‚ã†ã€‚
</p>


<p class="orig" lang="en">
<a name="%_idx_4820"></a>It is instructive to contrast the different images of time evoked by
nondeterministic evaluation and stream processing.  Stream processing
uses lazy evaluation to decouple the time when the stream of possible
answers is assembled from the time when the actual stream elements are
produced.  The evaluator supports the illusion that all the possible
answers are laid out before us in a timeless sequence.  With
nondeterministic evaluation, an expression represents the exploration
of a set of possible worlds, each determined by a set of choices.
Some of the possible worlds lead to dead ends, while others have
useful values.  The nondeterministic program evaluator supports the
illusion that time branches, and that our programs have different
possible execution histories.  When we reach a dead end, we can
revisit a previous choice point and proceed along a different branch.</p>

<p class="trans" lang="ja">
éæ±ºå®šçš„ãªè©•ä¾¡ã¨ã‚¹ãƒˆãƒªãƒ¼ãƒ å‡¦ç†ã«ã‚ˆã£ã¦å‘¼ã³è¦šã¾ã•ã‚Œã‚‹ã€æ™‚é–“ã«ã¤ã„ã¦ã®ç•°ãªã‚‹å°è±¡åŒå£«ã‚’å¯¾æ¯”ã™ã‚‹ã“ã¨ã¯ã€ãŸã‚ã«ãªã‚‹ã€‚
ã‚¹ãƒˆãƒªãƒ¼ãƒ å‡¦ç†ã¯ã€é…å»¶è©•ä¾¡ã‚’ä½¿ã£ã¦ã€å¯èƒ½ãªç­”ãˆã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒçµ„ã¿ç«‹ã¦ã‚‰ã‚Œã‚‹æ™‚ç‚¹ã‚’ã€å®Ÿéš›ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ è¦ç´ ãŒç”Ÿã¿å‡ºã•ã‚Œã‚‹æ™‚ç‚¹ã‹ã‚‰ã€åˆ‡ã‚Šé›¢ã—ãŸã€‚
ç§ãŸã¡ã®çœ¼å‰ã§ã€å¯èƒ½ãªç­”ãˆã®ã™ã¹ã¦ãŒã€æ™‚ã‚’è¶…è¶Šã—ãŸåˆ—ã®ä¸­ã«ä¸¦ã¹ã‚‰ã‚Œã¦ã„ã‚‹ã®ã ã€ã¨ã„ã†å¹»æƒ³ã‚’ã€è©•ä¾¡å™¨ã¯æ”¯ãˆã¦ã„ã‚‹ã€‚
éæ±ºå®šçš„ãªè©•ä¾¡ãŒã‚ã‚Œã°ã€å¼ã¯ã€å¯èƒ½ãªä¸–ç•Œâ€”â€”ãã‚Œã‚‰ã®ä¸–ç•Œã®ãã‚Œãã‚Œã¯ã€é¸æŠè‚¢ã®é›†åˆã«ã‚ˆã‚Šæ±ºå®šã¥ã‘ã‚‰ã‚Œã‚‹â€”â€”ã®é›†åˆã®æ¢æŸ»ã‚’è¡¨ç¾ã™ã‚‹ã€‚
å¯èƒ½ãªä¸–ç•Œã®ã†ã¡ã®ã„ãã¤ã‹ã¯è¡Œãæ­¢ã¾ã‚Šã«è‡³ã‚‹ãŒã€ä¸€æ–¹ã€ä»–ã®ã‚‚ã®ã¯ã€æœ‰ç›Šãªå€¤ã‚’æŒã¤ã€‚
æ™‚é–“ã¯åˆ†å²ã—ã€ç§ãŸã¡ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ç•°ãªã‚‹å¯èƒ½ãªå®Ÿè¡Œå±¥æ­´ã‚’æœ‰ã™ã‚‹ã€ã¨ã„ã†å¹»æƒ³ã‚’ã€éæ±ºå®šçš„ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ è©•ä¾¡å™¨ã¯æ”¯ãˆã¦ã„ã‚‹ã€‚
è¡Œãæ­¢ã¾ã‚Šã«è¾¿ã‚Šç€ãã¨ã€ç§ãŸã¡ã¯ã€ä»¥å‰ã®é¸æŠç‚¹ã‚’å†è¨ªã—ã¦ã€ç•°ãªã‚‹åˆ†å²ã«æ²¿ã£ã¦é€²ã‚€ã“ã¨ãŒã§ãã‚‹ã€‚
</p>

<p class="orig" lang="en">
The nondeterministic program evaluator implemented below is called the
<tt>amb</tt> evaluator because it is based on a new special form called
<tt>amb</tt>.  We can type the above definition of <tt>prime-sum-pair</tt>
at the <tt>amb</tt> evaluator driver loop (along with definitions of <tt>prime?</tt>, <tt>an-element-of</tt>, and <tt>require</tt>) and run the
procedure as follows:</p>

<p class="trans" lang="ja">
ä»¥ä¸‹ã§å®Ÿè£…ã•ã‚Œã‚‹éæ±ºå®šçš„ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ è©•ä¾¡å™¨ã¯ã€<tt>amb</tt> ã¨å‘¼ã°ã‚Œã‚‹æ–°ãŸãªç‰¹æ®Šå½¢å¼ã«åŸºã¥ã„ã¦ã„ã‚‹ã®ã§ã€<tt>amb</tt> è©•ä¾¡å™¨ã¨å‘¼ã°ã‚Œã‚‹ã€‚
ç§ãŸã¡ã¯ã€<tt>amb</tt> è©•ä¾¡å™¨ã®ãƒ‰ãƒ©ã‚¤ãƒãƒ»ãƒ«ãƒ¼ãƒ—ã«ãŠã„ã¦ã€<tt>prime-sum-pair</tt> ã®ä¸Šè¨˜ã®å®šç¾©ã‚’ (<tt>prime?</tt> ã¨ <tt>an-element-of</tt> ã¨ <tt>require</tt> ã®å®šç¾©ã¨ã¨ã‚‚ã«) æ‰“ã¡è¾¼ã‚“ã§ã€å½“è©²æ‰‹ç¶šãã‚’ä»¥ä¸‹ã®ã¨ãŠã‚Šå®Ÿè¡Œã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
</p>

<p class="lisp"><i>;;; Amb-Eval input:</i>
(prime-sum-pair '(1 3 5 8) '(20 35 110))
<i>;;; Starting a new problem</i>
<i>;;; Amb-Eval value:</i>
<i>(3 20)</i>
</p>

<p class="orig" lang="en">The value returned was obtained after the evaluator repeatedly chose
elements from each of the lists, until a successful choice was made.</p>

<p class="trans" lang="ja">
è¿”ã•ã‚Œã‚‹å€¤ã¯ã€ã†ã¾ãã„ãé¸æŠãŒãªã•ã‚Œã‚‹ã¾ã§ç¹°ã‚Šè¿”ã—ã€è©•ä¾¡å™¨ãŒãƒªã‚¹ãƒˆã®ãã‚Œãã‚Œã‹ã‚‰è¦ç´ ã‚’é¸ã‚“ã å¾Œã«ã€å¾—ã‚‰ã‚ŒãŸã€‚
</p>

<p class="orig" lang="en">
Section <a href="#%_sec_4.3.1">4.3.1</a> introduces <tt>amb</tt> and explains how it
supports nondeterminism through the evaluator's automatic search
mechanism.  Section <a href="#%_sec_4.3.2">4.3.2</a> presents examples of
nondeterministic programs, and section <a href="#%_sec_4.3.3">4.3.3</a>
gives the details of how to implement the <tt>amb</tt> evaluator by
modifying the ordinary Scheme evaluator.</p>

<p class="trans" lang="ja">
<a href="#%_sec_4.3.1">4.3.1</a>ç¯€ã§ã¯ <tt>amb</tt> ã‚’å°å…¥ã—ã€ãã—ã¦ã€ãã‚ŒãŒè©•ä¾¡å™¨ã®è‡ªå‹•çš„ãªæ¢ç´¢ã®ä»•çµ„ã¿ã‚’ä»‹ã—ã¦éæ±ºå®šè«–ã‚’æ”¯ãˆã‚‹ä»•æ–¹ã‚’èª¬æ˜ã™ã‚‹ã€‚
<a href="#%_sec_4.3.2">4.3.2</a>ç¯€ã§ã¯ã€éæ±ºå®šçš„ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ä¾‹ã‚’æç¤ºã—ã€<a href="#%_sec_4.3.3">4.3.3</a>ç¯€ã§ã¯ã€å…ƒã®Schemeè©•ä¾¡å™¨ã‚’æ”¹å¤‰ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ <tt>amb</tt> è©•ä¾¡å™¨ã‚’å®Ÿè£…ã™ã‚‹ä»•æ–¹ã®è©³ç´°ã‚’ç¤ºã™ã€‚
</p>


<a name="%_sec_4.3.1"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_4.3.1">4.3.1  Amb and Search</a></h3>
<h3 class="trans" lang="ja">4.3.1 amb ã¨æ¢ç´¢</h3>

<p class="orig" lang="en"><a name="%_idx_4822"></a>To extend Scheme to support nondeterminism, we introduce a new special
form called <tt>amb</tt>.<a name="call_footnote_Temp_599" href="#footnote_Temp_599"><sup><small>43</small></sup></a>
The expression <tt>(amb &lt;<em><em>e</em><sub>1</sub></em>&gt; &lt;<em><em>e</em><sub>2</sub></em>&gt; <tt>...</tt> &lt;<em><em>e</em><sub><em>n</em></sub></em>&gt;)</tt>
returns the value of one of the <em>n</em> expressions &lt;<em><em>e</em><sub><em>i</em></sub></em>&gt; ``ambiguously.''
For example, the expression</p>

<p class="trans" lang="ja">
éæ±ºå®šè«–ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚ˆã†ã«Schemeã‚’æ‹¡å¼µã™ã‚‹ãŸã‚ã«ã€<tt>amb</tt> ã¨å‘¼ã°ã‚Œã‚‹æ–°ãŸãªç‰¹æ®Šå½¢å¼ã‚’å°å…¥ã™ã‚‹<a href="#footnote_Temp_599"><sup><small>43</small></sup></a>ã€‚
<tt>(amb &lt;<em class="en">e<sub>1</sub></em>&gt; &lt;<em class="en">e<sub>2</sub></em>&gt; ... &lt;<em class="en">e<sub>n</sub></em>&gt;)</tt>
ã¨ã„ã†å¼ã¯ã€<em class="en">n</em> å€‹ã® &lt;<em class="en">e<sub>i</sub></em>&gt; ã¨ã„ã†å¼ã®ã†ã¡ã®ä¸€ã¤ã®å€¤ã‚’ã€Œæ›–æ˜§ã«ã€è¿”ã™ã€‚
ãŸã¨ãˆã°ã€ä»¥ä¸‹ã®å¼ã«ã¯ã€
</p>

<p class="lisp">(list (amb 1 2 3) (amb 'a 'b))
</p>

<p class="orig" lang="en">can have six possible values:</p>

<p class="trans" lang="ja">
å…­ã¤ã®å¯èƒ½ãªå€¤ãŒã‚ã‚Šå¾—ã‚‹ã€‚
</p>

<figure>
<table class="common"><tr><td><tt>(1 a) </tt></td><td><tt>(1 b) </tt></td><td><tt>(2 a) </tt></td><td><tt>(2 b) </tt></td><td><tt>(3 a) </tt></td><td><tt>(3 b) </tt></td></tr></table>
</figure>

<p class="orig" lang="en">
<tt>Amb</tt> with a single choice produces an ordinary (single) value.</p>

<p class="trans" lang="ja">
å˜ä¸€ã®é¸æŠè‚¢ã‚’ã¨ã‚‚ãªã† <tt>amb</tt> ã¯ã€æ™®é€šã® (å˜ä¸€ã®) å€¤ã‚’ä½œã‚Šå‡ºã™ã€‚
</p>


<p class="orig" lang="en">
<a name="%_idx_4826"></a><tt>Amb</tt> with no choices -- the expression <tt>(amb)</tt> -- is an
expression with no acceptable values.  Operationally, we can think of
<tt>(amb)</tt> as an expression that when evaluated causes the
computation to ``fail'': The computation aborts and no value is
produced.  Using this idea, we can express the requirement that a
particular predicate expression <tt>p</tt> must be true as follows:</p>

<p class="trans" lang="ja">
é¸æŠè‚¢ã‚’ã¨ã‚‚ãªã‚ãªã„ <tt>amb</tt> â€”â€”ã¤ã¾ã‚Š <tt>(amb)</tt> ã¨ã„ã†å¼â€”â€”ã¯ã€è¨±å®¹å¯èƒ½ãªå€¤ã‚’æŒãŸãªã„å¼ã§ã‚ã‚‹ã€‚
é‹ç”¨ä¸Šã€ç§ãŸã¡ã¯ã€<tt>(amb)</tt> ã®ã“ã¨ã‚’ã€è©•ä¾¡ã•ã‚Œã‚Œã°è¨ˆç®—ã‚’ã€Œå¤±æ•—ã€ã•ã›ã‚‹â€”â€”ã¤ã¾ã‚Šã€è¨ˆç®—ã¯ä¸­æ­¢ã«ãªã£ã¦ã€ä½•ã®å€¤ã‚‚ä½œã‚Šå‡ºã•ã‚Œãªã„â€”â€”ã‚ˆã†ãªå¼ã§ã‚ã‚‹ã‚‚ã®ã¨ã€è¦‹ãªã™ã“ã¨ãŒå¯èƒ½ã ã€‚
ã“ã®è€ƒãˆã‚’ä½¿ã†ã¨ã€ <tt>p</tt> ã¨ã„ã†ç‰¹å®šã®è¿°èªå¼ãŒçœŸã§ãªãã¦ã¯ãªã‚‰ãªã„ã€ã¨ã„ã†è¦ä»¶ã‚’ã€æ¬¡ã®ã‚ˆã†ã«è¡¨ã›ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_4828"></a>(define (require p)
  (if (not p) (amb)))
</p>

<p class="orig" lang="en">
With <tt>amb</tt> and <tt>require</tt>, we can implement the <tt>an-element-of</tt> procedure used above:</p>

<p class="trans" lang="ja">
<tt>amb</tt> ã¨ <tt>require</tt> ãŒã‚ã‚Œã°ã€ä¸Šè¨˜ã§ä½¿ã£ãŸ <tt>an-element-of</tt> ã®æ‰‹ç¶šãã‚’å®Ÿè£…ã§ãã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_4830"></a>(define (an-element-of items)
  (require (not (null? items)))
  (amb (car items) (an-element-of (cdr items))))
</p>


<p class="orig" lang="en"><tt>An-element-of</tt> fails if the list is empty.  Otherwise it
ambiguously returns either the first element of the list or an element
chosen from the rest of the list.</p>

<p class="trans" lang="ja">
<tt>an-element-of</tt> ã¯ã€ãƒªã‚¹ãƒˆãŒç©ºã®ã¨ãå¤±æ•—ã™ã‚‹ã€‚
ãã‚Œä»¥å¤–ã®å ´åˆã€ã“ã‚Œã¯ã€ãƒªã‚¹ãƒˆã®æœ€åˆã®è¦ç´ ã‹ã€ãƒªã‚¹ãƒˆã®æ®‹ã‚Šã‹ã‚‰é¸ã°ã‚ŒãŸè¦ç´ ã®ã„ãšã‚Œã‹ã‚’ã€æ›–æ˜§ã«è¿”ã™ã€‚
</p>

<p class="orig" lang="en">
We can also express infinite ranges of choices.  The following
procedure potentially returns any integer greater than or equal to
some given <em>n</em>:</p>

<p class="trans" lang="ja">
é¸æŠè‚¢ã®ç„¡é™ã®ç¯„å›²ã‚‚è¡¨ç¾ã§ãã‚‹ã€‚
ä»¥ä¸‹ã®æ‰‹ç¶šãã¯ã€æ½œåœ¨çš„ã«ã¯ã€ã‚ã‚‹ä¸ãˆã‚‰ã‚ŒãŸ <em class="en">n</em> ä»¥ä¸Šã®ä»»æ„ã®æ•´æ•°ã‚’è¿”ã™ã€‚
</p>

<p class="lisp"><a name="%_idx_4832"></a>(define (an-integer-starting-from n)
  (amb n (an-integer-starting-from (+ n 1))))
</p>


<p class="orig" lang="en">This is like the stream procedure <tt>integers-starting-from</tt>
described in section <a href="24_sec3_5.html#%_sec_3.5.2">3.5.2</a>, but with an important
difference: The stream procedure returns an object that represents the
sequence of all integers beginning with <em>n</em>, whereas the <tt>amb</tt>
procedure returns a single integer.<a name="call_footnote_Temp_600" href="#footnote_Temp_600"><sup><small>44</small></sup></a></p>

<p class="trans" lang="ja">
ã“ã‚Œã¯ã€<a href="24_sec3_5.html#%_sec_3.5.2">3.5.2</a>ç¯€ã§èª¬æ˜ã—ãŸ <tt>integers-starting-from</tt> ã¨ã„ã†ã‚¹ãƒˆãƒªãƒ¼ãƒ æ‰‹ç¶šãã¨ä¼¼ã¦ã„ã‚‹ãŒã€é‡è¦ãªé•ã„ãŒã‚ã‚‹ã€‚
ã¤ã¾ã‚Šã€<tt>amb</tt> æ‰‹ç¶šãã¯å˜ä¸€ã®æ•´æ•°ã‚’è¿”ã™ã®ã«å¯¾ã—ã¦ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ æ‰‹ç¶šãã¯ã€<em class="en">n</em> ã§å§‹ã¾ã‚‹ã™ã¹ã¦ã®æ•´æ•°ã®é€£ãªã‚Šã‚’è¡¨ã™ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã™ã®ã§ã‚ã‚‹<a href="#footnote_Temp_600"><sup><small>44</small></sup></a>ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_4834"></a>Abstractly, we can imagine that evaluating an <tt>amb</tt> expression
causes time to split into branches, where the computation continues on
each branch with one of the possible values of the expression.  We say
that <tt>amb</tt> represents a <a name="%_idx_4836"></a><em>nondeterministic choice point</em>.
If we had a machine with a sufficient number of processors that could
be dynamically allocated, we could implement the search in a
straightforward way.  Execution would proceed as in a sequential
machine, until an <tt>amb</tt> expression is encountered.  At this point,
more processors would be allocated and initialized to continue all of
the parallel executions implied by the choice.  Each processor would
proceed sequentially as if it were the only choice, until it either
terminates by encountering a failure, or it further subdivides, or
it finishes.<a name="call_footnote_Temp_601" href="#footnote_Temp_601"><sup><small>45</small></sup></a></p>

<p class="trans" lang="ja">
æŠ½è±¡çš„ã«ã¯ã€<tt>amb</tt> å¼ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ãŒã€æ™‚é–“ã‚’ã„ãã¤ã‹ã®åˆ†å²ã¸ã¨åˆ†è£‚ã•ã›ã‚‹ã®ã â€”â€”ãªãŠã€ãã‚Œãã‚Œã®åˆ†å²ä¸Šã§ã€å¼ã®å¯èƒ½ãªå€¤ã®ã†ã¡ã®ä¸€ã¤ã‚’ä½¿ã£ã¦ã€è¨ˆç®—ã¯ç¶šãâ€”â€”ã¨æƒ³åƒã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
<tt>amb</tt> ã¯<em>éæ±ºå®šçš„ãªé¸æŠç‚¹</em>ã‚’è¡¨ã™ã€ã¨ç§ãŸã¡ã¯è¨€ã†ã€‚
ã‚‚ã—ã€å‹•çš„ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚Œã‚‹ååˆ†ãªå°æ•°ã®ãƒ—ãƒ­ã‚»ãƒƒã‚µã‚’å‚™ãˆãŸãƒã‚·ãƒ³ãŒã‚ã‚Œã°ã€åˆ†ã‹ã‚Šã‚„ã™ã„æ–¹æ³•ã§æ¢ç´¢ã‚’å®Ÿè£…ã§ããŸã ã‚ã†ã€‚
å®Ÿè¡Œã¯ã€<tt>amb</tt> å¼ã«é­é‡ã™ã‚‹ã¾ã§ã¯ã€é€æ¬¡çš„ãªãƒã‚·ãƒ³ã§ã®ã‚‚ã®ã¨åŒæ§˜ã«é€²ã‚€ã ã‚ã†ã€‚
ã“ã®æ™‚ç‚¹ã§ã€ã‚ˆã‚Šå¤šãã®ãƒ—ãƒ­ã‚»ãƒƒã‚µãŒå‰²ã‚Šå½“ã¦ã‚‰ã‚Œã€ã‹ã¤ã€ãã®é¸æŠã«ã‚ˆã‚Šç¤ºå”†ã•ã‚Œã‚‹ã™ã¹ã¦ã®ä¸¦åˆ—å®Ÿè¡Œã‚’ç¶šè¡Œã™ã‚‹ã‚ˆã†ã«ã€åˆæœŸåŒ–ã•ã‚Œã‚‹ã ã‚ã†ã€‚
å„ãƒ—ãƒ­ã‚»ãƒƒã‚µã¯ã€ãã‚ŒãŒã‚ãŸã‹ã‚‚å”¯ä¸€ã®é¸æŠè‚¢ã§ã‚ã‚‹ã‹ã®ã‚ˆã†ã«ã€é€æ¬¡çš„ã«é€²ã‚€ã ã‚ã†â€”â€”å¤±æ•—ã«é­é‡ã™ã‚‹ã“ã¨ã§çµ‚äº†ã™ã‚‹ã¾ã§ã€ã‚ã‚‹ã„ã¯ã€ã•ã‚‰ã«å†åˆ†å‰²ã™ã‚‹ã¾ã§ã€ã‚ã‚‹ã„ã¯ã€å®Œäº†ã™ã‚‹ã¾ã§<a href="#footnote_Temp_601"><sup><small>45</small></sup></a>ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_4840"></a>On the other hand, if we have a machine that can execute
only one process (or a few concurrent processes),
we must consider the alternatives sequentially.
One could imagine modifying an evaluator
to pick at random a branch to follow whenever it encounters a choice
point.  Random choice, however, can easily lead to failing values.
We might try running the evaluator over and over, making random
choices and hoping to find a non-failing value, but it is better to <a name="%_idx_4842"></a><a name="%_idx_4844"></a><em>systematically search</em> all possible execution paths.
The <tt>amb</tt> evaluator that we will develop and work with in this section
implements a systematic search as follows: When the evaluator
encounters an application of <tt>amb</tt>, it initially selects the first
alternative.  This selection may itself lead to a further choice.  The
evaluator will always initially choose the first alternative at each
choice point.  If a choice results in a failure, then the evaluator
<a name="%_idx_4846"></a><a name="%_idx_4848"></a><a name="%_idx_4850"></a>automagically<a name="call_footnote_Temp_602" href="#footnote_Temp_602"><sup><small>46</small></sup></a> <a name="%_idx_4852"></a><em>backtracks</em>
to the most recent choice point and tries the next
alternative.  If it runs out of alternatives at any choice point, the
evaluator will back up to the previous choice point and resume from
there.  This process leads to a search strategy known as <a name="%_idx_4854"></a><a name="%_idx_4856"></a><a name="%_idx_4858"></a><em>depth-first search</em> or <em>chronological backtracking</em>.<a name="call_footnote_Temp_603" href="#footnote_Temp_603"><sup><small>47</small></sup></a></p>

<p class="trans" lang="ja">
ä¸€æ–¹ã€ã‚‚ã—ã€ä¸€ã¤ã®ãƒ—ãƒ­ã‚»ã‚¹ (ã¾ãŸã¯å°‘æ•°ã®ä¸¦è¡Œã—ãŸãƒ—ãƒ­ã‚»ã‚¹) ã—ã‹å®Ÿè¡Œã§ããªã„ãƒã‚·ãƒ³ãŒã‚ã‚Œã°ã€é¸æŠè‚¢ã‚’é€æ¬¡çš„ã«è€ƒãˆãªãã¦ã¯ãªã‚‰ãªã„ã€‚
é¸æŠç‚¹ã«é­é‡ã™ã‚‹ãŸã³ã«ã€ãŸã©ã‚‹ã¹ãåˆ†å²ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«é¸ã¶ã‚ˆã†ã«ã€è©•ä¾¡å™¨ã‚’æ”¹å¤‰ã™ã‚‹ã“ã¨ã‚’ã€æƒ³åƒã™ã‚‹ã“ã¨ã‚‚ã§ãã‚‹ã€‚
ã—ã‹ã—ã€ãƒ©ãƒ³ãƒ€ãƒ ãªé¸æŠã¯ã€å¤§æŠµã¯ã€å¤±æ•—ã™ã‚‹å€¤ã«ã¤ãªãŒã‚‹ã€‚
ç§ãŸã¡ã¯ã€ãƒ©ãƒ³ãƒ€ãƒ ãªé¸æŠã‚’ã—ã¦ã€å¤±æ•—ã—ãªã„å€¤ã‚’è¦‹ã¤ã‘ã‚‹ã“ã¨ã‚’é¡˜ã„ã¤ã¤ã€ä½•åº¦ã‚‚ä½•åº¦ã‚‚è©•ä¾¡å™¨ã‚’å‹•ã‹ã—ã¦ã¿ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ãŒã€ã‚ã‚Šå¾—ã‚‹ã™ã¹ã¦ã®å®Ÿè¡ŒçµŒè·¯ã‚’<em>çµ„ç¹”çš„ã«æ¢ç´¢ã™ã‚‹</em>æ–¹ãŒè‰¯ã„ã®ã§ã‚ã‚‹ã€‚
ç§ãŸã¡ãŒé–‹ç™ºã—ã‚ˆã†ã¨ã—ã¦ã„ã¦ã€ã¾ãŸã€æœ¬ç¯€ã§ã¯ãã‚Œã‚’ä½¿ã£ã¦ä½œæ¥­ã—ã‚ˆã†ã¨ã—ã¦ã„ã‚‹ã€<tt>amb</tt> è©•ä¾¡å™¨ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã«çµ„ç¹”çš„æ¢ç´¢ã‚’å®Ÿè£…ã™ã‚‹ã€‚
è©•ä¾¡å™¨ã¯ã€<tt>amb</tt> ã®é©ç”¨ã«é­é‡ã™ã‚‹ã¨ã€æœ€åˆã«1ç•ªç›®ã®é¸æŠè‚¢ã‚’é¸ã¶ã€‚
ã“ã®é¸æŠã¯ã€ãã‚Œè‡ªä½“ãŒã€ã•ã‚‰ãªã‚‹é¸æŠã«ã¤ãªãŒã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚
è©•ä¾¡å™¨ã¯å¸¸ã«ã€å„é¸æŠç‚¹ã«ãŠã„ã¦ã€æœ€åˆã¯1ç•ªç›®ã®é¸æŠè‚¢ã‚’é¸ã¶ã€‚
ã‚‚ã—ã€ã‚ã‚‹é¸æŠãŒå¤±æ•—ã«çµ‚ã‚ã£ãŸã‚‰ã€è©•ä¾¡å™¨ã¯ã€<ruby><rb>é­”æ³•ã®ã‚ˆã†ã«è‡ªå‹•çš„</rb><rp> (</rp><rt>ã‚ªãƒ¼ãƒˆãƒã‚¸ã‚«ãƒ«</rt><rp>) </rp></ruby>ã«<a href="#footnote_Temp_602"><sup><small>46</small></sup></a>ã€ç›´è¿‘ã®é¸æŠç‚¹ã¸ã¨<em><ruby><rb>ãƒãƒƒã‚¯ãƒˆãƒ©ãƒƒã‚¯ã—ã¦</rb><rp> (</rp><rt>ã²ãã‹ãˆã—ã¦</rt><rp>) </rp></ruby></em>ã€æ¬¡ã®é¸æŠè‚¢ã‚’è©¦ã™ã€‚
ã‚‚ã—ã€ã©ã“ã‹ã®é¸æŠç‚¹ã§é¸æŠè‚¢ã‚’ä½¿ã„æœãŸã—ãŸã‚‰ã€è©•ä¾¡å™¨ã¯ã€å‰ã®é¸æŠç‚¹ã«æˆ»ã£ã¦ã€ãã“ã‹ã‚‰å†é–‹ã™ã‚‹ã€‚
ã“ã®ãƒ—ãƒ­ã‚»ã‚¹ã¯ã€<em>æ·±ã•å„ªå…ˆæ¢ç´¢</em>ã‚‚ã—ãã¯<em>æ™‚ç³»åˆ—é †ãƒãƒƒã‚¯ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°</em>ã¨ã—ã¦çŸ¥ã‚‰ã‚Œã‚‹æ¢ç´¢æˆ¦ç•¥ã¸ã¨é€šã˜ã‚‹<a href="#footnote_Temp_603"><sup><small>47</small></sup></a>ã€‚
</p>

<a name="%_sec_Temp_604"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_604">Driver loop</a></h4>
<h4 class="trans" lang="ja">ãƒ‰ãƒ©ã‚¤ãƒãƒ»ãƒ«ãƒ¼ãƒ—</h4>

<p class="orig" lang="en">
<a name="%_idx_4908"></a>The driver loop for the <tt>amb</tt> evaluator
has some unusual properties.  It reads an
expression and prints the value of the first non-failing execution, as
in the <tt>prime-sum-pair</tt> example shown above.  If we
want to see the value of the next successful execution, we can
ask the interpreter to backtrack and attempt to generate a second
non-failing execution.  This is signaled by typing the symbol <a name="%_idx_4910"></a><tt>try-again</tt>.  If any expression except <tt>try-again</tt> is given, the
interpreter will start a new problem, discarding the unexplored
alternatives in the previous problem.  Here is a sample
interaction:</p>

<p class="trans" lang="ja">
<tt>amb</tt> è©•ä¾¡å™¨ç”¨ã®ãƒ‰ãƒ©ã‚¤ãƒãƒ»ãƒ«ãƒ¼ãƒ—ã«ã¯ã€ã‚„ã‚„å¤‰ã‚ã£ãŸæ€§è³ªãŒã‚ã‚‹ã€‚
ãã‚Œã¯ã€å¼ã‚’èª­ã¿ã€ä¸Šè¨˜ã® <tt>prime-sum-pair</tt> ã®ä¾‹ã§ã®ã¨ãŠã‚Šã€æœ€åˆã®å¤±æ•—ã—ãªã„å®Ÿè¡Œã®å€¤ã‚’å°å­—ã™ã‚‹ã€‚
ã‚‚ã—æ¬¡ã®ã†ã¾ãã„ãå®Ÿè¡Œã®å€¤ã‚’è¦‹ãŸã‘ã‚Œã°ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«å¯¾ã—ã¦ã€ãƒãƒƒã‚¯ãƒˆãƒ©ãƒƒã‚¯ã—ã¦2ç•ªç›®ã®å¤±æ•—ã—ãªã„å®Ÿè¡Œã‚’ç”Ÿæˆã™ã‚‹ã“ã¨ã‚’è©¦ã¿ã‚‹ã‚ˆã†ã«ã€æ±‚ã‚ã‚‹ã“ã¨ãŒå¯èƒ½ã ã€‚
ã“ã‚Œã¯ã€<tt>try-again</tt> ã¨ã„ã†è¨˜å·ã‚’æ‰“ã¡è¾¼ã‚€ã“ã¨ã§ã€åˆå›³ãŒä¸ãˆã‚‰ã‚Œã‚‹ã€‚
ã‚‚ã— <tt>try-again</tt> ä»¥å¤–ã®å¼ãŒä½•ã‹ä¸ãˆã‚‰ã‚ŒãŸã‚‰ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã¯ã€å‰ã®å•é¡Œã«ãŠã‘ã‚‹æœªæ¢ç´¢ã®é¸æŠè‚¢ã‚’æ¨ã¦ã¦ã€æ–°ãŸãªå•é¡Œã‚’é–‹å§‹ã™ã‚‹ã ã‚ã†ã€‚
ã“ã“ã«è¦‹æœ¬çš„ãªã‚„ã‚Šã¨ã‚Šã‚’ç¤ºã™ã€‚
</p>

<p class="lisp"><i>;;; Amb-Eval input:</i>
(prime-sum-pair '(1 3 5 8) '(20 35 110))
<i>;;; Starting a new problem</i>
<i>;;; Amb-Eval value:</i>
<i>(3 20)</i>
<i>;;; Amb-Eval input:</i>
try-again
<i>;;; Amb-Eval value:</i>
<i>(3 110)</i>
<i>;;; Amb-Eval input:</i>
try-again
<i>;;; Amb-Eval value:</i>
<i>(8 35)</i>
<i>;;; Amb-Eval input:</i>
try-again
<i>;;; There are no more values of</i>
<i>(prime-sum-pair (quote (1 3 5 8)) (quote (20 35 110)))</i>
<i>;;; Amb-Eval input:</i>
(prime-sum-pair '(19 27 30) '(11 36 58))
<i>;;; Starting a new problem</i>
<i>;;; Amb-Eval value:</i>
<i>(30 11)</i>
</p>


<p class="orig" lang="en">
<a name="%_thm_4.35"></a>
<b>Exercise 4.35.</b>  <a name="%_idx_4912"></a><a name="%_idx_4914"></a>Write a procedure <tt>an-integer-between</tt> that returns an integer
between two given bounds.  This can be used to implement a
procedure that finds Pythagorean triples,
i.e., triples of integers (<em>i</em>,<em>j</em>,<em>k</em>) between the given bounds such
that <em>i</em> <u>&lt;</u> <em>j</em> and <em>i</em><sup>2</sup>  +  <em>j</em><sup>2</sup>  = <em>k</em><sup>2</sup>, as follows:</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ 4.35.</b> ä¸ãˆã‚‰ã‚ŒãŸäºŒã¤ã®å¢ƒç•Œã®é–“ã®æ•´æ•°ã‚’ä¸€ã¤è¿”ã™ã€<tt>an-integer-between</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’æ›¸ã‘ã€‚
ã“ã‚Œã¯ã€ãƒ”ã‚¿ã‚´ãƒ©ã‚¹ã®ä¸‰ã¤çµ„â€”â€”ã™ãªã‚ã¡ã€
<span class="math"><em class="en">i</em> &le; <em class="en">j</em></span>
ã‹ã¤
<span class="math"><em class="en">i</em><sup>2</sup>  +  <em class="en">j</em><sup>2</sup>  = <em class="en">k</em><sup>2</sup></span>
ã§ã‚ã‚‹ã‚ˆã†ãªã€ä¸ãˆã‚‰ã‚ŒãŸå¢ƒç•Œã®é–“ã«ã‚ã‚‹ã€
<span class="math">(<em class="en">i</em>, <em class="en">j</em>, <em class="en">k</em>)</span>
ã¨ã„ã†æ•´æ•°ã®ä¸‰ã¤çµ„â€”â€”ã‚’è¦‹ã¤ã‘ã‚‹æ‰‹ç¶šãã‚’ä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¦å®Ÿè£…ã™ã‚‹ã®ã«ä½¿ãˆã‚‹ã€‚
</p>

<p class="lisp">(define (a-pythagorean-triple-between low high)
  (let ((i (an-integer-between low high)))
    (let ((j (an-integer-between i high)))
      (let ((k (an-integer-between j high)))
        (require (= (+ (* i i) (* j j)) (* k k)))
        (list i j k)))))
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_4.36"></a>
<b>Exercise 4.36.</b>  <a name="%_idx_4916"></a><a name="%_idx_4918"></a>Exercise <a href="24_sec3_5.html#%_thm_3.69">3.69</a> discussed how to generate
the stream of <em>all</em> Pythagorean triples, with no upper bound on the
size of the integers to be searched.  Explain why simply replacing
<tt>an-integer-between</tt> by <tt>an-integer-starting-from</tt> in the procedure in
exercise <a href="#%_thm_4.35">4.35</a> is not an adequate way to
generate arbitrary Pythagorean triples.  Write a procedure that
actually will accomplish this.  (That is, write a procedure for which
repeatedly typing <tt>try-again</tt> would in principle eventually
generate all Pythagorean triples.)
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ 4.36.</b> ç·´ç¿’å•é¡Œ<a href="24_sec3_5.html#%_thm_3.69">3.69</a>ã§ã¯ã€æ¢ç´¢ã™ã¹ãæ•´æ•°ã®å¤§ãã•ã«ã¤ã„ã¦ä¸Šé™ã‚’è¨­ã‘ãšã«ã€<em>ã™ã¹ã¦ã®</em>ãƒ”ã‚¿ã‚´ãƒ©ã‚¹ã®ä¸‰ã¤çµ„ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ã©ã®ã‚ˆã†ã«ç”Ÿæˆã™ã‚‹ã®ã‹ã€ã«ã¤ã„ã¦è­°è«–ã—ãŸã€‚
ç·´ç¿’å•é¡Œ<a href="#%_thm_4.35">4.35</a>ã«ãŠã„ã¦ã€å˜ç´”ã« <tt>an-integer-between</tt> ã‚’ <tt>an-integer-starting-from</tt> ã§ç½®ãæ›ãˆã‚‹ã“ã¨ãŒã€ãªãœã€ä»»æ„ã®ãƒ”ã‚¿ã‚´ãƒ©ã‚¹ã®ä¸‰ã¤çµ„ã‚’ç”Ÿæˆã™ã‚‹ãŸã‚ã®é©åˆ‡ãªæ–¹æ³•ã§ã¯ãªã„ã®ã‹ã‚’èª¬æ˜ã›ã‚ˆã€‚
å®Ÿéš›ã«ã“ã‚Œã‚’é”æˆã™ã‚‹ã§ã‚ã‚ã†æ‰‹ç¶šãã‚’æ›¸ã‘
(ã¤ã¾ã‚Šã€ãã®æ‰‹ç¶šãã«å¯¾ã—ã¦ <tt>try-again</tt> ã¨ç¹°ã‚Šè¿”ã—æ‰“ã¡è¾¼ã‚€ã“ã¨ã«ã‚ˆã£ã¦ã€åŸç†ä¸Šã¯ã€ã‚†ãã‚†ãã¯ã™ã¹ã¦ã®ãƒ”ã‚¿ã‚´ãƒ©ã‚¹ã®ä¸‰ã¤çµ„ã‚’ç”Ÿæˆã™ã‚‹ã“ã¨ã«ãªã‚‹ã§ã‚ã‚ã†ã‚ˆã†ãªæ‰‹ç¶šãã‚’æ›¸ã‘)ã€‚
</p>


<p class="orig" lang="en">
<a name="%_thm_4.37"></a>
<b>Exercise 4.37.</b>  <a name="%_idx_4920"></a><a name="%_idx_4922"></a>Ben Bitdiddle claims that the following method for generating
Pythagorean triples is more efficient than the one in
exercise <a href="#%_thm_4.35">4.35</a>.  Is he correct?  (Hint: Consider
the number of possibilities that must be explored.)</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ 4.37.</b> ãƒ™ãƒ³ãƒ»ãƒ“ãƒƒãƒˆãƒ‡ã‚£ãƒ‰ãƒ«ã¯ã€ãƒ”ã‚¿ã‚´ãƒ©ã‚¹ã®ä¸‰ã¤çµ„ã‚’ç”Ÿæˆã™ã‚‹ãŸã‚ã®ä»¥ä¸‹ã®æ–¹æ³•ãŒã€ç·´ç¿’å•é¡Œ<a href="#%_thm_4.35">4.35</a>ã®ã‚‚ã®ã‚ˆã‚Šã‚‚åŠ¹ç‡çš„ã ã€ã¨ä¸»å¼µã™ã‚‹ã€‚
å½¼ã¯æ­£ã—ã„ã‹?
(ãƒ’ãƒ³ãƒˆ: æ¢ç´¢ã›ã­ã°ãªã‚‰ãªã„å¯èƒ½æ€§ã®æ•°ã‚’è€ƒãˆã‚ˆã€‚)
</p>

<p class="lisp">(define (a-pythagorean-triple-between low high)
  (let ((i (an-integer-between low high))
        (hsq (* high high)))
    (let ((j (an-integer-between i high)))
      (let ((ksq (+ (* i i) (* j j))))
        (require (&gt;= hsq ksq))
        (let ((k (sqrt ksq)))
          (require (integer? k))
          (list i j k))))))
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_4.3.2"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_4.3.2">4.3.2  Examples of Nondeterministic Programs</a></h3>
<h3 class="trans" lang="ja">4.3.2 éæ±ºå®šçš„ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ä¾‹</h3>

<p class="orig" lang="en">Section <a href="#%_sec_4.3.3">4.3.3</a> describes the implementation of
the <tt>amb</tt> evaluator.  First, however, we give some examples of how
it can be used.  The advantage of nondeterministic programming is that
we can suppress the details of how search is carried out, thereby
<a name="%_idx_4924"></a>expressing our programs at a higher level of abstraction.</p>

<p class="trans" lang="ja">
<a href="#%_sec_4.3.3">4.3.3</a>ç¯€ã§ã¯ <tt>amb</tt> è©•ä¾¡å™¨ã®å®Ÿè£…ã«ã¤ã„ã¦èª¬æ˜ã™ã‚‹ã€‚
ã—ã‹ã—ã€ãã‚Œã‚’ã©ã®ã‚ˆã†ã«ä½¿ã†ã“ã¨ãŒã§ãã‚‹ã®ã‹ã€ã¨ã„ã†å¹¾ã¤ã‹ã®ä¾‹ã‚’ã¾ãšæŒ™ã’ã¦ãŠãã€‚
éæ±ºå®šçš„ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®åˆ©ç‚¹ã¯ã€æ¢ç´¢ãŒã©ã®ã‚ˆã†ã«å®Ÿè¡Œã•ã‚Œã‚‹ã®ã‹ã€<!--ã¨ã„ã†è©³ç´°ã‚’éš ã›ã‚‹ç‚¹ã§ã‚ã‚Šã€ãã‚Œã«ã‚ˆã£ã¦æŠ½è±¡åŒ–ã®ã‚ˆã‚Šé«˜ã„æ°´æº–ã«ãŠã„ã¦ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’è¡¨ã›ã‚‹ç‚¹ã§ã‚ã‚‹ã€‚-->ã¨ã„ã†è©³ç´°ã‚’éš ã—ã€ãã‚Œã«ã‚ˆã£ã¦ã€ã‚ˆã‚Šé«˜ã„æŠ½è±¡åŒ–ã®æ°´æº–ã«ãŠã„ã¦ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’è¡¨ã™ã€ã¨ã„ã†ã“ã¨ãŒã§ãã‚‹ç‚¹ã§ã‚ã‚‹ã€‚
</p>

<a name="%_sec_Temp_608"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_608">Logic Puzzles</a></h4>
<h4 class="trans" lang="ja">è«–ç†ãƒ‘ã‚ºãƒ«</h4>



<p class="orig" lang="en">
<a name="%_idx_4926"></a><a name="%_idx_4928"></a><a name="%_idx_4930"></a>
<a name="%_idx_4932"></a>The following puzzle (taken from Dinesman 1968) is typical of a large
class of simple logic puzzles:</p>

<p class="trans" lang="ja">
ä»¥ä¸‹ã®ãƒ‘ã‚ºãƒ« (Dinesman 1968 ã‹ã‚‰æ¡ã£ãŸ) ã¯ã€å˜ç´”ãªè«–ç†ãƒ‘ã‚ºãƒ«ã®å¤§ããªéƒ¨é¡ã®å…¸å‹ã§ã‚ã‚‹ã€‚
</p>


<blockquote class="orig" lang="en">
Baker, Cooper, Fletcher, Miller, and Smith live on different floors of
an apartment house that contains only five floors.  Baker does not
live on the top floor.  Cooper does not live on the bottom floor.
Fletcher does not live on either the top or the bottom floor.  Miller
lives on a higher floor than does Cooper.  Smith does not live on a
floor adjacent to Fletcher's.  Fletcher does not live on a floor
adjacent to Cooper's.  Where does everyone live?
</blockquote>

<blockquote class="trans" lang="ja">
ãƒ™ã‚¤ã‚«ãƒ¼ã¨ã‚¯ãƒ¼ãƒ‘ãƒ¼ã¨ãƒ•ãƒ¬ãƒƒãƒãƒ£ãƒ¼ã¨ãƒŸãƒ©ãƒ¼ã¨ã‚¹ãƒŸã‚¹ã¯ã€5éšã¾ã§ã—ã‹ãªã„ã‚¢ãƒ‘ãƒ¼ãƒˆã®ç•°ãªã‚‹éšã«ä½ã‚“ã§ã„ã‚‹ã€‚
ãƒ™ã‚¤ã‚«ãƒ¼ã¯ä¸€ç•ªä¸Šã®éšã«ã¯ä½ã‚“ã§ã„ãªã„ã€‚
ã‚¯ãƒ¼ãƒ‘ãƒ¼ã¯ä¸€ç•ªä¸‹ã®éšã«ã¯ä½ã‚“ã§ã„ãªã„ã€‚
ãƒ•ãƒ¬ãƒƒãƒãƒ£ãƒ¼ã¯ä¸€ç•ªä¸Šã®éšã«ã‚‚ä¸€ç•ªä¸‹ã®éšã«ã‚‚ä½ã‚“ã§ã„ãªã„ã€‚
ãƒŸãƒ©ãƒ¼ã¯ã‚¯ãƒ¼ãƒ‘ãƒ¼ã‚ˆã‚Šä¸Šã®éšã«ä½ã‚“ã§ã„ã‚‹ã€‚
ã‚¹ãƒŸã‚¹ã¯ãƒ•ãƒ¬ãƒƒãƒãƒ£ãƒ¼ã¨éš£æ¥ã™ã‚‹éšã«ã¯ä½ã‚“ã§ã„ãªã„ã€‚
ãƒ•ãƒ¬ãƒƒãƒãƒ£ãƒ¼ã¯ã‚¯ãƒ¼ãƒ‘ãƒ¼ã¨éš£æ¥ã™ã‚‹éšã«ã¯ä½ã‚“ã§ã„ãªã„ã€‚
ã¿ã‚“ãªã¯ã©ã®éšã«ä½ã‚“ã§ã„ã‚‹ã®ã ã‚ã†ã‹?
</blockquote>

<p class="orig" lang="en">
We can determine who lives on each floor in a straightforward way by
enumerating all the possibilities and imposing the given
restrictions:<a name="call_footnote_Temp_609" href="#footnote_Temp_609"><sup><small>48</small></sup></a></p>

<p class="trans" lang="ja">
ã™ã¹ã¦ã®å¯èƒ½æ€§ã‚’åˆ—æŒ™ã—ã¦ã€ä¸ãˆã‚‰ã‚ŒãŸåˆ¶ç´„ã‚’èª²ã™ã“ã¨ã«ã‚ˆã£ã¦ã€å„éšã«èª°ãŒä½ã‚“ã§ã„ã‚‹ã®ã‹ã‚’å˜ç´”ãªæ–¹æ³•ã§åˆ¤å®šã§ãã‚‹<a href="#footnote_Temp_609"><sup><small>48</small></sup></a>ã€‚
</p>

<p class="lisp"><a name="%_idx_4938"></a>(define (multiple-dwelling)
  (let ((baker (amb 1 2 3 4 5))
        (cooper (amb 1 2 3 4 5))
        (fletcher (amb 1 2 3 4 5))
        (miller (amb 1 2 3 4 5))
        (smith (amb 1 2 3 4 5)))
    (require
     (distinct? (list baker cooper fletcher miller smith)))
    (require (not (= baker 5)))
    (require (not (= cooper 1)))
    (require (not (= fletcher 5)))
    (require (not (= fletcher 1)))
    (require (&gt; miller cooper))
    (require (not (= (abs (- smith fletcher)) 1)))
    (require (not (= (abs (- fletcher cooper)) 1)))
    (list (list 'baker baker)
          (list 'cooper cooper)
          (list 'fletcher fletcher)
          (list 'miller miller)
          (list 'smith smith))))
</p>


<p class="orig" lang="en">
Evaluating the expression <tt>(multiple-dwelling)</tt> produces the
result</p>

<p class="trans" lang="ja">
<tt>(multiple-dwelling)</tt> ã¨ã„ã†å¼ã‚’è©•ä¾¡ã™ã‚‹ã¨ã€ä»¥ä¸‹ã®çµæœãŒç”Ÿã¿å‡ºã•ã‚Œã‚‹ã€‚
</p>

<p class="lisp">((baker 3) (cooper 2) (fletcher 4) (miller 5) (smith 1))
</p>

<p class="orig" lang="en">Although this simple procedure works, it is very slow.
Exercises <a href="#%_thm_4.39">4.39</a>
and <a href="#%_thm_4.40">4.40</a> discuss some possible
improvements.</p>

<p class="trans" lang="ja">
ã“ã®å˜ç´”ãªæ‰‹ç¶šãã¯ã†ã¾ãå‹•ããŒã€éå¸¸ã«é…ã„ã€‚
ç·´ç¿’å•é¡Œ<a href="#%_thm_4.39">4.39</a>ã¨ç·´ç¿’å•é¡Œ<a href="#%_thm_4.40">4.40</a>ã§ã¯ã€ã„ãã¤ã‹ã®å¯èƒ½ãªæ”¹å–„ç‚¹ã«ã¤ã„ã¦è­°è«–ã™ã‚‹ã€‚
</p>


<div class="exercise"><span class="ex_comment">ã“ã“ã§ã€äººåŠ›ã§ãƒ‘ã‚ºãƒ«ã‚’è§£ã„ã¦ã¿ã‚‹ã€‚</span>

<table class="expl ex_comment">
<tr><th>åå‰</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th></th></tr>
<tr><th>ãƒ™ã‚¤ã‚«ãƒ¼</th><td>Ã—i</td><td>Ã—g</td><td>ğŸ˜€j</td><td>Ã—g</td><td>âŒa</td><td>a. ä¸€ç•ªä¸Šã®éšã«ã¯ä½ã‚“ã§ã„ãªã„</td></tr>
<tr><th>ã‚¯ãƒ¼ãƒ‘ãƒ¼</th><td>âŒb</td><td>ğŸ˜€l</td><td>âŒf</td><td>Ã—l</td><td>âŒd</td><td>b. ä¸€ç•ªä¸‹ã®éšã«ã¯ä½ã‚“ã§ã„ãªã„</td></tr>
<tr><th>ãƒ•ãƒ¬ãƒƒãƒãƒ£ãƒ¼</th><td>âŒc</td><td>Ã—k</td><td>âŒf</td><td>ğŸ˜€k</td><td>âŒc</td><td>c. ä¸€ç•ªä¸Šã®éšã«ã‚‚ä¸€ç•ªä¸‹ã®éšã«ã‚‚ä½ã‚“ã§ã„ãªã„<br>f. ã‚¯ãƒ¼ãƒ‘ãƒ¼ã¨éš£æ¥ã™ã‚‹éšã«ã¯ä½ã‚“ã§ã„ãªã„</td></tr>
<tr><th>ãƒŸãƒ©ãƒ¼</th><td>âŒd</td><td>Ã—g</td><td>Ã—j</td><td>Ã—g</td><td>ğŸ˜€j</td><td>d. ã‚¯ãƒ¼ãƒ‘ãƒ¼ã‚ˆã‚Šä¸Šã®éšã«ä½ã‚“ã§ã„ã‚‹</td></tr>
<tr><th>ã‚¹ãƒŸã‚¹</th><td>ğŸ˜€i</td><td>Ã—g</td><td>âŒe</td><td>Ã—g</td><td>Ã—h</td><td>e. ãƒ•ãƒ¬ãƒƒãƒãƒ£ãƒ¼ã¨éš£æ¥ã™ã‚‹éšã«ã¯ä½ã‚“ã§ã„ãªã„</td></tr>
</table>

<span class="ex_comment">âŒã¯ã€ä¸ãˆã‚‰ã‚ŒãŸåˆ¶ç´„æ¡ä»¶ã‹ã‚‰ç›´ã¡ã«ã€Œãƒ€ãƒ¡ã€ã¨ã‚ã‹ã‚‹ã¨ã“ã‚ã€‚aã€œfã®é †ã«åŸ‹ã‚ãŸã€‚
æ¬¡ã« (g)ã€2éšã¨4éšã¯ã‚¯ãƒ¼ãƒ‘ãƒ¼ã¨ãƒ•ãƒ¬ãƒƒãƒãƒ£ãƒ¼ã§åŸ‹ã¾ã‚‹ã®ã§ã€ä»–ã®äººã¯å…¥ã‚Œãªã„ã€‚
ã“ã“ã§ (h)ã€ã‚¹ãƒŸã‚¹ãŒ5éšã ã¨ã™ã‚‹ã¨ã€eã‚ˆã‚Šãƒ•ãƒ¬ãƒƒãƒãƒ£ãƒ¼ãŒ2éšã€‚
ã™ã‚‹ã¨ã€ã‚¯ãƒ¼ãƒ‘ãƒ¼ãŒ4éšãªã®ã§ã€dã‚ˆã‚ŠãƒŸãƒ©ãƒ¼ã‚‚5éšã¨ãªã‚Šã€ã“ã‚Œã¯çŸ›ç›¾ã€‚
ã‚ˆã£ã¦ã€ã‚¹ãƒŸã‚¹ã¯5éšã§ã¯ãªã„ã€‚
ã¤ã¾ã‚Š (i)ã€ã‚¹ãƒŸã‚¹ã¯1éšã§ã‚ã‚‹ã€‚ã‚ˆã£ã¦ã€ãƒ™ã‚¤ã‚«ãƒ¼ã¯1éšã§ã¯ãªã„ã€‚
ã¨ã„ã†ã“ã¨ã¯ (j)ã€ãƒ™ã‚¤ã‚«ãƒ¼ã¯3éšã§ã‚ã‚‹ã€‚ã‚ˆã£ã¦ã€ãƒŸãƒ©ãƒ¼ã¯3éšã§ã¯ãªãã€5éšã§ã‚ã‚‹ã€‚
ã¨ã“ã‚ã§ (k)ã€ã‚¹ãƒŸã‚¹ãŒ1éšãªã®ã§ã€eã‚ˆã‚Šãƒ•ãƒ¬ãƒƒãƒãƒ£ãƒ¼ãŒ4éšã€‚
ã—ãŸãŒã£ã¦ (l)ã€ã‚¯ãƒ¼ãƒ‘ãƒ¼ã¯2éšã§ã‚ã‚‹ã€‚</span></div>

<p class="orig" lang="en">
<a name="%_thm_4.38"></a>
<b>Exercise 4.38.</b>  Modify the multiple-dwelling procedure to omit the requirement that
Smith and Fletcher do not live on adjacent floors.  How many solutions
are there to this modified puzzle?
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ 4.38.</b> ã‚¹ãƒŸã‚¹ã¨ãƒ•ãƒ¬ãƒƒãƒãƒ£ãƒ¼ãŒéš£ã‚Šåˆã£ãŸéšã«ä½ã‚“ã§ã„ãªã„ã€ã¨ã„ã†è¦ä»¶ã‚’çœç•¥ã™ã‚‹ã‚ˆã†ã«ã€<tt>multiple-dwelling</tt> (è¤‡æ•°ã®ä½å±…) ã®æ‰‹ç¶šãã‚’æ”¹å¤‰ã›ã‚ˆã€‚
ã“ã®æ”¹å¤‰ã•ã‚ŒãŸãƒ‘ã‚ºãƒ«ã«å¯¾ã—ã¦ã¯ã€ã„ãã¤ã®è§£ãŒã‚ã‚‹ã ã‚ã†?
</p>


<div class="exercise"><span class="ex_comment">æ‰‹ç¶šãã®æ”¹å¤‰ã¯ã€</span>
(require (not (= (abs (- smith fletcher)) 1)))
<span class="ex_comment">ã®è¡Œã‚’å‰Šé™¤ã™ã‚‹ã ã‘ã§ã‚ˆã„ã€‚</span>

<span class="ex_comment">ã“ã“ã§ã€äººåŠ›ã§ãƒ‘ã‚ºãƒ«ã‚’è§£ã„ã¦ã¿ã‚‹ã€‚</span>

<table class="expl ex_comment">
<tr><th>åå‰</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th></th></tr>
<tr><th>ãƒ™ã‚¤ã‚«ãƒ¼</th><td>ğŸ’›h<br>ğŸ’™j<br>ğŸ’œk</td><td>Ã—g</td><td>ğŸ’ši<br>â¤ï¸l</td><td>Ã—g</td><td>âŒa</td><td>a. ä¸€ç•ªä¸Šã®éšã«ã¯ä½ã‚“ã§ã„ãªã„</td></tr>
<tr><th>ã‚¯ãƒ¼ãƒ‘ãƒ¼</th><td>âŒb</td><td>ğŸ’™j<br>ğŸ’œk<br>â¤ï¸l</td><td>âŒf</td><td>ğŸ’›h<br>ğŸ’ši</td><td>âŒd</td><td>b. ä¸€ç•ªä¸‹ã®éšã«ã¯ä½ã‚“ã§ã„ãªã„</td></tr>
<tr><th>ãƒ•ãƒ¬ãƒƒãƒãƒ£ãƒ¼</th><td>âŒc</td><td>ğŸ’›h<br>ğŸ’ši</td><td>âŒf</td><td>ğŸ’™j<br>ğŸ’œk<br>â¤ï¸l</td><td>âŒc</td><td>c. ä¸€ç•ªä¸Šã®éšã«ã‚‚ä¸€ç•ªä¸‹ã®éšã«ã‚‚ä½ã‚“ã§ã„ãªã„<br>f. ã‚¯ãƒ¼ãƒ‘ãƒ¼ã¨éš£æ¥ã™ã‚‹éšã«ã¯ä½ã‚“ã§ã„ãªã„</td></tr>
<tr><th>ãƒŸãƒ©ãƒ¼</th><td>âŒd</td><td>Ã—g</td><td>ğŸ’™j</td><td>Ã—g</td><td>ğŸ’›h<br>ğŸ’ši<br>ğŸ’œk<br>â¤ï¸l</td><td>d. ã‚¯ãƒ¼ãƒ‘ãƒ¼ã‚ˆã‚Šä¸Šã®éšã«ä½ã‚“ã§ã„ã‚‹</td></tr>
<tr><th>ã‚¹ãƒŸã‚¹</th><td>ğŸ’ši<br>â¤ï¸l</td><td>Ã—g</td><td>ğŸ’›h<br>ğŸ’œk</td><td>Ã—g</td><td>ğŸ’™j</td><td><del>e. ãƒ•ãƒ¬ãƒƒãƒãƒ£ãƒ¼ã¨éš£æ¥ã™ã‚‹éšã«ã¯ä½ã‚“ã§ã„ãªã„</del></td></tr>
</table>

<span class="ex_comment">âŒã¯ã€ä¸ãˆã‚‰ã‚ŒãŸåˆ¶ç´„æ¡ä»¶ã‹ã‚‰ç›´ã¡ã«ã€Œãƒ€ãƒ¡ã€ã¨ã‚ã‹ã‚‹ã¨ã“ã‚ã€‚aã€œdã€fã®é †ã«åŸ‹ã‚ãŸã€‚
æ¬¡ã« (g)ã€2éšã¨4éšã¯ã‚¯ãƒ¼ãƒ‘ãƒ¼ã¨ãƒ•ãƒ¬ãƒƒãƒãƒ£ãƒ¼ã§åŸ‹ã¾ã‚‹ã®ã§ã€ä»–ã®äººã¯å…¥ã‚Œãªã„ã€‚
ã“ã“ã§ (h, i)ã€ã‚¯ãƒ¼ãƒ‘ãƒ¼ãŒ4éšã ã¨ã™ã‚‹ã¨ã€ãƒ•ãƒ¬ãƒƒãƒãƒ£ãƒ¼ãŒ2éšã§ã€dã‚ˆã‚ŠãƒŸãƒ©ãƒ¼ãŒ5éšã€‚
ã¨ã„ã†ã“ã¨ã¯ã€ãƒ™ã‚¤ã‚«ãƒ¼ã¨ã‚¹ãƒŸã‚¹ãŒ1éšã¨3éš (ã©ã¡ã‚‰ãŒã©ã¡ã‚‰ã§ã‚ã£ã¦ã‚‚ã‚ˆã„)ã€‚
é€†ã« (j, k, l)ã€ã‚¯ãƒ¼ãƒ‘ãƒ¼ãŒ2éšã ã¨ã™ã‚‹ã¨ã€ãƒ•ãƒ¬ãƒƒãƒãƒ£ãƒ¼ãŒ4éšã§ã€ãƒŸãƒ©ãƒ¼ã¯3éšã§ã‚‚5éšã§ã‚‚ã‚ˆã„ã€‚
ä»®ã«ãƒŸãƒ©ãƒ¼ãŒ3éšã ã¨ã™ã‚‹ã¨ (j)ã€1éšã¨5éšãŒæ®‹ã‚‹ãŒã€aã‚ˆã‚Šãƒ™ã‚¤ã‚«ãƒ¼ãŒ1éšã€ã‚¹ãƒŸã‚¹ãŒ5éšã§ã‚ã‚‹ã€‚
é€†ã«ãƒŸãƒ©ãƒ¼ãŒ5éšã ã¨ã™ã‚‹ã¨ (k, l)ã€1éšã¨3éšãŒæ®‹ã‚‹ã€‚
ã“ã®å ´åˆã¯ã€ãƒ™ã‚¤ã‚«ãƒ¼ã¨ã‚¹ãƒŸã‚¹ãŒã©ã¡ã‚‰ã‚’å ã‚ã¦ã‚‚ã‚ˆã„ã€‚
ã¨ã„ã†ã‚ã‘ã§ã€eã®åˆ¶ç´„ãŒãªããªã‚‹ã¨ã€h, i, j, k, lã®5é€šã‚Šã®ç­”ãˆãŒå­˜åœ¨ã™ã‚‹ã“ã¨ã«ãªã‚‹ã€‚
</span></div>


<p class="orig" lang="en">
<a name="%_thm_4.39"></a>
<b>Exercise 4.39.</b>  Does the order of the restrictions in the multiple-dwelling procedure
affect the answer? Does it affect the time to find an answer?  If you
think it matters, demonstrate a faster program obtained from the given
one by reordering the restrictions.  If you think it does not matter,
argue your case.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ 4.39.</b> <tt>multiple-dwelling</tt> ã®æ‰‹ç¶šãã«ãŠã‘ã‚‹åˆ¶ç´„ã®é †åºã¯ã€ç­”ãˆã«å½±éŸ¿ã™ã‚‹ã‹?
ç­”ãˆã‚’è¦‹ã¤ã‘ã‚‹æ™‚é–“ã«ã¯å½±éŸ¿ã™ã‚‹ã‹?
ã‚‚ã—ã€ãã®é †åºãŒé‡è¦ã ã¨å›ãŒè€ƒãˆã‚‹ãªã‚‰ã€åˆ¶ç´„ã®é †ç•ªã‚’ä¸¦ã¹æ›¿ãˆã‚‹ã“ã¨ã§æ‰€ä¸ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‹ã‚‰å¾—ã‚‰ã‚Œã‚‹ã€ã‚ˆã‚Šé«˜é€Ÿãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ã€å®Ÿæ¼”ã—ã¦ã¿ã›ãŸã¾ãˆã€‚
ã‚‚ã—ã€ãã®é †åºã¯é‡è¦ã§ãªã„ã¨å›ãŒè€ƒãˆã‚‹ãªã‚‰ã€å›ã®ç«‹å ´ã‚’è«–ã˜ãŸã¾ãˆã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_4.40"></a>
<b>Exercise 4.40.</b>  In the multiple dwelling problem, how many sets of assignments are
there of people to floors, both before and after the requirement that
floor assignments be distinct?  It is very inefficient to generate all
possible assignments of people to floors and then leave it to
backtracking to eliminate them.  For example, most of the restrictions
depend on only one or two of the person-floor variables, and can thus
be imposed before floors have been selected for all the people.
Write and demonstrate a much more efficient
nondeterministic procedure that solves this problem based upon
generating only those possibilities that are not already ruled out by
previous restrictions.  (Hint: This will require a nest of <tt>let</tt>
expressions.)
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ 4.40.</b> è¤‡æ•°ã®ä½å±…ã®å•é¡Œã«ãŠã„ã¦ã€éšã®å‰²ã‚Šå½“ã¦ã¯ç›¸ç•°ãªã‚‹ã¹ã—ã€ã¨ã„ã†è¦ä»¶ã®å‰å¾Œã§ã€äººã€…ã®éšã¸ã®å‰²ã‚Šå½“ã¦ã¯ä½•é€šã‚Šã‚ã‚‹ã ã‚ã†ã‹?
äººã€…ã®éšã¸ã®å¯èƒ½ãªã™ã¹ã¦ã®å‰²ã‚Šå½“ã¦ã‚’ç”Ÿæˆã—ã¦ã€ãã‚Œã‹ã‚‰ãã‚Œã‚‰ã®å‰²ã‚Šå½“ã¦ã‚’å‰Šé™¤ã™ã‚‹ãŸã‚ã®ãƒãƒƒã‚¯ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°ã«çŠ¶æ³ <span class="note">(=it)</span> ã‚’å§”ã­ã‚‹ã€ã¨ã„ã†ã®ã¯éåŠ¹ç‡ã§ã‚ã‚‹ã€‚
ãŸã¨ãˆã°ã€ã»ã¨ã‚“ã©ã®åˆ¶ç´„ã¯ã€äººãƒ»éšã®å¤‰æ•°ã®ã†ã¡ã®ãŸã£ãŸä¸€ã¤ã‹äºŒã¤ã«ã—ã‹ä¾å­˜ã—ãªã„ã—ã€ãã‚Œã‚†ãˆã€ã™ã¹ã¦ã®äººãŸã¡ã«å¯¾ã—ã¦éšãŒé¸æŠæ¸ˆã¿ã¨ãªã‚‹å‰ã«ã€<span class="note">(ãã®åˆ¶ç´„ã‚’) </span>èª²ã™ã“ã¨ãŒå¯èƒ½ã§ã‚ã‚‹ã€‚
å‰ã®åˆ¶ç´„ã«ã‚ˆã£ã¦æ—¢ã«æ’é™¤ã•ã‚Œã¦ã„ã‚‹è¨³ã§ã¯ãªã„å¯èƒ½æ€§ã®ã¿ã‚’ç”Ÿæˆã™ã‚‹ã“ã¨ã«åŸºã¥ã„ã¦ã€ã“ã®å•é¡Œã‚’è§£ãã‚ˆã†ãªã€ã‚‚ã£ã¨ãšã£ã¨åŠ¹ç‡çš„ãªéæ±ºå®šçš„æ‰‹ç¶šãã‚’ã€æ›¸ã„ã¦å®Ÿæ¼”ã›ã‚ˆ
(ãƒ’ãƒ³ãƒˆ: ã“ã‚Œã¯ã€<tt>let</tt> å¼ã®å…¥ã‚Œå­ã‚’å¿…è¦ã¨ã™ã‚‹ã ã‚ã†)ã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_4.41"></a>
<b>Exercise 4.41.</b>  <a name="%_idx_4940"></a>Write an ordinary Scheme program to solve the multiple dwelling puzzle.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ 4.41.</b> è¤‡æ•°ã®ä½å±…ã®ãƒ‘ã‚ºãƒ«ã‚’è§£ããŸã‚ã®ã€æ™®é€šã®Schemeãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ã‘ã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_4.42"></a>
<b>Exercise 4.42.</b>  <a name="%_idx_4942"></a>Solve the following ``Liars'' puzzle (from Phillips 1934):</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ 4.42.</b> ä»¥ä¸‹ã®ã€Œå˜˜ã¤ãã€ãƒ‘ã‚ºãƒ« (Phillips 1934 ã«ã‚ˆã‚‹) ã‚’è§£ã‘ã€‚
</p>

<blockquote class="orig" lang="en">
Five schoolgirls sat for an examination.  Their parents -- so they
thought -- showed an undue degree of interest in the result.  They
therefore agreed that, in writing home about the examination, each 
girl should make one true statement and one untrue one.  The following
are the relevant passages from their letters:

<ul>
<li>Betty: ``Kitty was second in the examination.  I was only third.''
<li>Ethel: ``You'll be glad to hear that I was on top.  Joan was second.''
<li>Joan: ``I was third, and poor old Ethel was bottom.''
<li>Kitty: ``I came out second.  Mary was only fourth.''
<li>Mary: ``I was fourth.  Top place was taken by Betty.''
</ul>

What in fact was the order in which the five girls were placed?
</blockquote>


<blockquote class="trans" lang="ja">
5äººã®å¥³å­ç”Ÿå¾’ãŒè©¦é¨“ã®ãŸã‚ã«åº§ã£ã¦ã„ãŸã€‚
å½¼å¥³ãŸã¡ã®è¦ªã¯ã€çµæœã«ã¤ã„ã¦éåº¦ã®é–¢å¿ƒã‚’è¦‹ã›ãŸâ€”â€”ã¨ã€å½¼å¥³ãŸã¡ã¯è€ƒãˆãŸã€‚
ãã“ã§å½¼å¥³ãŸã¡ã¯ã€è©¦é¨“ã«ã¤ã„ã¦å®¶ã«æ›¸ã„ã¦é€ã‚‹éš›ã«ã¯ã€ãã‚Œãã‚Œã®å°‘å¥³ãŒã€ä¸€ã¤ã¯æœ¬å½“ã®ã“ã¨ã‚’è¿°ã¹ã€ä¸€ã¤ã¯å½ã‚Šã®ã“ã¨ã‚’è¿°ã¹ã‚‹ã¹ãã§ã‚ã‚‹ã€ã¨åˆæ„ã—ãŸã€‚
ä»¥ä¸‹ã¯ã€å½¼å¥³ãŸã¡ã®æ‰‹ç´™ã®ã€å½“è©²å•é¡Œã«é–¢ã™ã‚‹ä¸€ç¯€ã§ã‚ã‚‹ã€‚

<ul>
<li>ãƒ™ãƒ†ã‚£ã€Œã‚­ãƒ†ã‚£ã¯è©¦é¨“ã§2ä½ã§ã—ãŸã€‚ã‚ãŸã—ã¯3ä½ã§ã—ã‹ã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚ã€</li>
<li>ã‚¨ã‚»ãƒ«ã€Œã‚ãŸã—ãŒ1ä½ã ã£ãŸã¨èã„ãŸã‚‰ã€å–œã‚“ã§ãã‚Œã‚‹ã“ã¨ã§ã—ã‚‡ã†ã€‚ã‚¸ãƒ§ãƒ¼ãƒ³ã¯2ä½ã§ã—ãŸã€‚ã€</li>
<li>ã‚¸ãƒ§ãƒ¼ãƒ³ã€Œã‚ãŸã—ã¯3ä½ã§ã€ã¾ã£ãŸãã ã‚ãªã‚¨ã‚»ãƒ«ã¨ããŸã‚‰ã€ã³ã‚Šã§ã—ãŸã€‚ã€</li>
<li>ã‚­ãƒ†ã‚£ã€Œã‚ãŸã—ã¯2ä½ã ã¨ã‚ã‹ã‚Šã¾ã—ãŸã€‚ãƒ¡ã‚¢ãƒªã¯4ä½ã§ã—ã‹ã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚ã€</li>
<li>ãƒ¡ã‚¢ãƒªã€Œã‚ãŸã—ã¯4ä½ã§ã—ãŸã€‚1ä½ã¯ãƒ™ãƒ†ã‚£ãŒå–ã‚Šã¾ã—ãŸã€‚ã€</li>
</ul>

5äººã®å¥³å­ç”Ÿå¾’ãŒç½®ã‹ã‚ŒãŸé †ä½ã¯ã€å®Ÿéš›ã¯ã©ã†ã„ã†ã‚‚ã®ã ã£ãŸã®ã‹?
</blockquote>


<p class="exercise"><span class="ex_comment">(1) ã‚­ãƒ†ã‚£ãŒ2ä½ã¨ä»®å®šã™ã‚‹ã€‚
ã“ã®ã¨ãã€ãƒ™ãƒ†ã‚£ã®ç™ºè¨€ã®å‰åŠãŒæœ¬å½“ã§å¾ŒåŠãŒå˜˜ãªã®ã§ã€ãƒ™ãƒ†ã‚£ã¯3ä½ã§ã¯ãªã„ã€‚
ã¾ãŸã€ã‚­ãƒ†ã‚£ã®ç™ºè¨€ã®å‰åŠãŒæœ¬å½“ã§å¾ŒåŠãŒå˜˜ãªã®ã§ã€ãƒ¡ã‚¢ãƒªã¯4ä½ã§ã¯ãªã„ã€‚
ã¨ã„ã†ã“ã¨ã¯ã€ãƒ¡ã‚¢ãƒªã®ç™ºè¨€ã®å‰åŠãŒå˜˜ã§å¾ŒåŠãŒæœ¬å½“ãªã®ã§ã€1ä½ã¯ãƒ™ãƒ†ã‚£
(ã“ã‚Œã¯ä¸Šè¨˜ã®ã€Œ3ä½ã§ã¯ãªã„ã€ã¨çŸ›ç›¾ã—ãªã„)ã€‚
ã™ã‚‹ã¨ã€ã‚¨ã‚»ãƒ«ã®ç™ºè¨€ã®å‰åŠãŒå˜˜ã§å¾ŒåŠãŒæœ¬å½“ãªã®ã§ã€ã‚¸ãƒ§ãƒ¼ãƒ³ã¯2ä½ã€‚
ã“ã‚Œã¯ä»®å®šã¨åã™ã‚‹ã€‚ã‚ˆã£ã¦ã€ã‚­ãƒ†ã‚£ãŒ2ä½ã¨ã„ã†ä»®å®šã¯é–“é•ã„ã€‚

(2) ã—ãŸãŒã£ã¦ã€ã‚­ãƒ†ã‚£ã¯2ä½ã§ã¯ãªã„ã€‚
ã™ã‚‹ã¨ã€ãƒ™ãƒ†ã‚£ã®ç™ºè¨€ã®å‰åŠãŒå˜˜ã§å¾ŒåŠãŒæœ¬å½“ã ã‹ã‚‰ã€ãƒ™ãƒ†ã‚£ã¯3ä½ã€‚
ã¾ãŸã€ã‚­ãƒ†ã‚£ã®ç™ºè¨€ã®å‰åŠãŒå˜˜ã§å¾ŒåŠãŒæœ¬å½“ã ã‹ã‚‰ã€ãƒ¡ã‚¢ãƒªã¯4ä½ã€‚
ã¨ã„ã†ã“ã¨ã¯ã€ãƒ¡ã‚¢ãƒªã®ç™ºè¨€ã®å‰åŠãŒæœ¬å½“ã§å¾ŒåŠãŒå˜˜ãªã®ã§ã€ãƒ™ãƒ†ã‚£ã¯1ä½ã§ã¯ãªã„
(ã“ã‚Œã¯ä¸Šè¨˜ã®ã€Œ3ä½ã€ã¨çŸ›ç›¾ã—ãªã„)ã€‚
ã“ã“ã¾ã§ã§ã€1ä½ã€2ä½ã€5ä½ãŒç©ºã„ã¦ã„ã‚‹ã€‚
ã‚­ãƒ†ã‚£ã¯2ä½ã§ã¯ãªã„ã®ã§ã€1ä½ã‹5ä½ã§ã‚ã‚‹ã€‚
2ä½ã®å¯èƒ½æ€§ãŒã‚ã‚‹ã®ã¯ã‚¨ã‚»ãƒ«ã‹ã‚¸ãƒ§ãƒ¼ãƒ³ã§ã‚ã‚‹ã€‚
ã‚¨ã‚»ãƒ«ãŒ2ä½ã ã¨ã™ã‚‹ã¨ã€ã‚¨ã‚»ãƒ«è‡ªèº«ã®ç™ºè¨€ã®å‰åŠãŒå˜˜ã§å¾ŒåŠãŒæœ¬å½“ã®ã¯ãš
ã ãŒã€ãã‚Œã ã¨ã‚¸ãƒ§ãƒ¼ãƒ³ã‚‚2ä½ã«ãªã£ã¦ã—ã¾ã†ã‹ã‚‰ã€çŸ›ç›¾ã€‚
ã¤ã¾ã‚Šã€ã‚¨ã‚»ãƒ«ã‚‚2ä½ã§ã¯ãªã„ã€‚
ã¨ã„ã†ã“ã¨ã¯ã€2ä½ã¯ã‚¸ãƒ§ãƒ¼ãƒ³ã§ã‚ã‚‹ã€‚
ã—ãŸãŒã£ã¦ã€ã‚¨ã‚»ãƒ«ã®ç™ºè¨€ã¯ã€å¾ŒåŠãŒæœ¬å½“ã§å‰åŠãŒå˜˜ã€‚
ã¤ã¾ã‚Šã€ã‚¨ã‚»ãƒ«ã¯1ä½ã§ã¯ãªã„ã®ã§5ä½ã§ã‚ã‚‹ã€‚
ã¨ã„ã†ã“ã¨ã¯ã‚­ãƒ†ã‚£ãŒ1ä½ã§ã‚ã‚‹ã€‚

ç­”ãˆã¯ã€1ä½ãƒ»ã‚­ãƒ†ã‚£ã€2ä½ãƒ»ã‚¸ãƒ§ãƒ¼ãƒ³ã€3ä½ãƒ»ãƒ™ãƒ†ã‚£ã€4ä½ãƒ»ãƒ¡ã‚¢ãƒªã€5ä½ãƒ»ã‚¨ã‚»ãƒ«ã€‚
ç™ºè¨€ã®çœŸå½ã¯ã€ãƒ™ãƒ†ã‚£ã¯å˜˜ãƒ»æœ¬å½“ã€ã‚¨ã‚»ãƒ«ã¯å˜˜ãƒ»æœ¬å½“ã€
ã‚¸ãƒ§ãƒ¼ãƒ³ã¯å˜˜ãƒ»æœ¬å½“ã€ã‚­ãƒ†ã‚£ã¯å˜˜ãƒ»æœ¬å½“ã€ãƒ¡ã‚¢ãƒªã¯æœ¬å½“ãƒ»å˜˜ã€‚
</span></p>


<p class="orig" lang="en">
<a name="%_thm_4.43"></a>
<b>Exercise 4.43.</b>  Use the <tt>amb</tt> evaluator to solve the following puzzle:<a name="call_footnote_Temp_616" href="#footnote_Temp_616"><sup><small>49</small></sup></a></p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ 4.43.</b> <tt>amb</tt> è©•ä¾¡å™¨ã‚’ä½¿ã£ã¦ä»¥ä¸‹ã®ãƒ‘ã‚ºãƒ«ã‚’è§£ã‘<a href="#footnote_Temp_616"><sup><small>49</small></sup></a>ã€‚
</p>

<blockquote class="orig" lang="en">
Mary Ann Moore's father has a yacht and so has each of his four
friends:  Colonel Downing, Mr. Hall, Sir Barnacle Hood, and Dr.
Parker.  Each of the five also has one daughter and each has named his
yacht after a daughter of one of the others.  Sir Barnacle's yacht is
the Gabrielle, Mr. Moore owns the Lorna; Mr. Hall the Rosalind.  The
Melissa, owned by Colonel Downing, is named after Sir Barnacle's
daughter.  Gabrielle's father owns the yacht that is named after Dr.
Parker's daughter.  Who is Lorna's father?
</blockquote>

<blockquote class="trans" lang="ja">
ãƒ¡ã‚¢ãƒªãƒ»ã‚¢ãƒ³ãƒ»ãƒ ãƒ¼ã‚¢ã®çˆ¶ã¯ãƒ¨ãƒƒãƒˆã‚’æŒã£ã¦ãŠã‚Šã€å½¼ã®4äººã®å‹äººâ€”â€”ã™ãªã‚ã¡ã€ãƒ€ã‚¦ãƒ‹ãƒ³ã‚°å¤§ä½ã€ãƒ›ãƒ¼ãƒ«æ°ã€ãƒãƒ¼ãƒŠã‚¯ãƒ«ãƒ»ãƒ•ãƒ¼ãƒ‰å¿ã€ãƒ‘ãƒ¼ã‚«ãƒ¼åšå£«â€”â€”ã®ãã‚Œãã‚Œã‚‚åŒæ§˜ã§ã‚ã‚‹ã€‚
5äººã®å„ã€…ã«ã¯1äººã®å¨˜ãŒã„ã¦ã€å„äººã¯ã€æ®‹ã‚Šã®äººãŸã¡ã®ã†ã¡ã®1äººã®å¨˜ã«ã¡ãªã‚“ã§ã€è‡ªåˆ†ã®ãƒ¨ãƒƒãƒˆã‚’åä»˜ã‘ãŸã€‚
ãƒãƒ¼ãƒŠã‚¯ãƒ«å¿ã®ãƒ¨ãƒƒãƒˆã¯ã‚¬ãƒ–ãƒªã‚¨ãƒ«å·ã§ã€ãƒ ãƒ¼ã‚¢æ°ã¯ãƒ­ãƒ«ãƒŠå·ã‚’æ‰€æœ‰ã—ã¦ã„ã‚‹ã€‚ãƒ›ãƒ¼ãƒ«æ°ã¯ãƒ­ã‚¶ãƒªãƒ³ãƒ‰å·ã§ã‚ã‚‹ã€‚
ãƒ¡ãƒªãƒƒã‚µå·ã¯ã€ãƒ€ã‚¦ãƒ‹ãƒ³ã‚°å¤§ä½ãŒæ‰€æœ‰ã—ã¦ã„ã‚‹ã®ã ãŒã€ãƒãƒ¼ãƒŠã‚¯ãƒ«å¿ã®å¨˜ã«ã¡ãªã‚“ã§åä»˜ã‘ã‚‰ã‚ŒãŸã‚‚ã®ã§ã‚ã‚‹ã€‚
ã‚¬ãƒ–ãƒªã‚¨ãƒ«ã®çˆ¶ã¯ã€ãƒ‘ãƒ¼ã‚«ãƒ¼åšå£«ã®å¨˜ã«ã¡ãªã‚“ã§åä»˜ã‘ã‚‰ã‚ŒãŸãƒ¨ãƒƒãƒˆã‚’æ‰€æœ‰ã—ã¦ã„ã‚‹ã€‚
èª°ãŒãƒ­ãƒ«ãƒŠã®çˆ¶ã ã‚ã†ã‹?
</blockquote>

<p class="orig" lang="en">
Try to write the program so that it runs efficiently (see
exercise <a href="#%_thm_4.40">4.40</a>).  Also determine how many
solutions there are if we are not told that Mary Ann's last name is
Moore.
</p>

<p class="trans" lang="ja">
ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒåŠ¹ç‡ã‚ˆãå‹•ä½œã™ã‚‹ã‚ˆã†ã«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ã“ã†ã¨è©¦ã¿ã‚ˆ (ç·´ç¿’å•é¡Œ<a href="#%_thm_4.40">4.40</a>ã‚’å‚ç…§)ã€‚
ã¾ãŸã€ã‚‚ã—ãƒ¡ã‚¢ãƒªãƒ»ã‚¢ãƒ³ã®å§“ãŒãƒ ãƒ¼ã‚¢ã§ã‚ã‚‹ã¨è¨€ã‚ã‚Œã¦ã„ãªã‹ã£ãŸã‚‰ã€ã„ãã¤ã®è§£ãŒã‚ã‚‹ã®ã‹ã€åˆ¤å®šã›ã‚ˆã€‚
</p>

<div class="exercise"><span class="ex_comment">äººåŠ›ã§ã¨ã‚Šã‚ãˆãšè§£ã„ã¦ã¿ã‚ˆã†ã€‚</span>
<table class="expl ex_comment">
<tr><th rowspan="2">å¨˜ã®å</th><th colspan="5">çˆ¶</th></tr>
<tr><th>ãƒ ãƒ¼ã‚¢æ°</th><th>ãƒ€ã‚¦ãƒ‹ãƒ³ã‚°å¤§ä½</th><th>ãƒ›ãƒ¼ãƒ«æ°</th><th>ãƒãƒ¼ãƒŠã‚¯ãƒ«å¿</th><th>ãƒ‘ãƒ¼ã‚«ãƒ¼åšå£«</th></tr>
<tr><th>ãƒ¡ã‚¢ãƒªãƒ»ã‚¢ãƒ³</th><td>ğŸ˜€</td><td>âŒ</td><td>âŒ</td><td>âŒ</td><td>âŒ</td></tr>
<tr><th>ã‚¬ãƒ–ãƒªã‚¨ãƒ«</th><td>âŒ</td><td>ğŸ†–(3)</td><td>ğŸ‰(4)</td><td>âŒ</td><td>ğŸ†–(2)</td></tr>
<tr><th>ãƒ­ãƒ«ãƒŠ</th><td>âŒ</td><td>ğŸ‰(6)</td><td>Ã—(4)</td><td>âŒ</td><td>Ã—(5)</td></tr>
<tr><th>ãƒ­ã‚¶ãƒªãƒ³ãƒ‰</th><td>âŒ</td><td>Ã—(5)</td><td>ğŸ†–(1)</td><td>âŒ</td><td>ğŸ‰(5)</td></tr>
<tr><th>ãƒ¡ãƒªãƒƒã‚µ</th><td>âŒ</td><td>âŒ</td><td>âŒ</td><td>ğŸ˜€</td><td>âŒ</td></tr>
</table>
<table class="expl ex_comment">
<tr><th rowspan="2">ãƒ¨ãƒƒãƒˆã®å</th><th colspan="5">ãƒ¨ãƒƒãƒˆæ‰€æœ‰è€…</th></tr>
<tr><th>ãƒ ãƒ¼ã‚¢æ°</th><th>ãƒ€ã‚¦ãƒ‹ãƒ³ã‚°å¤§ä½</th><th>ãƒ›ãƒ¼ãƒ«æ°</th><th>ãƒãƒ¼ãƒŠã‚¯ãƒ«å¿</th><th>ãƒ‘ãƒ¼ã‚«ãƒ¼åšå£«</th></tr>
<tr><th>ãƒ¡ã‚¢ãƒªãƒ»ã‚¢ãƒ³</th><td>âŒ</td><td>âŒ</td><td>âŒ</td><td>âŒ</td><td>â›µ</td></tr>
<tr><th>ã‚¬ãƒ–ãƒªã‚¨ãƒ«</th><td>âŒ</td><td>âŒ</td><td>âŒ</td><td>ğŸ˜€</td><td>âŒ</td></tr>
<tr><th>ãƒ­ãƒ«ãƒŠ</th><td>ğŸ˜€</td><td>âŒ</td><td>âŒ</td><td>âŒ</td><td>âŒ</td></tr>
<tr><th>ãƒ­ã‚¶ãƒªãƒ³ãƒ‰</th><td>âŒ</td><td>âŒ</td><td>ğŸ˜€</td><td>âŒ</td><td>âŒ</td></tr>
<tr><th>ãƒ¡ãƒªãƒƒã‚µ</th><td>âŒ</td><td>ğŸ˜€</td><td>âŒ</td><td>âŒ</td><td>âŒ</td></tr>
</table>
<span class="ex_comment">(1) ğŸ˜€ã¯å•é¡Œæ–‡ã«è¨˜è¿°ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã€‚âŒã¯ã€ğŸ˜€ã®ã‚ã‚‹åˆ—ãƒ»è¡Œã®æ®‹ã‚Šã®éƒ¨åˆ†ã€‚
ã“ã“ã‹ã‚‰ã™ãã«ã€â›µãŒåˆ¤æ˜ã™ã‚‹ã€‚
ã¾ãŸã€ãƒ¨ãƒƒãƒˆã«ã¯è‡ªåˆ†ã®å¨˜ã®åå‰ã‚’ã¤ã‘ãªã„ã®ã§ã€ğŸ†–(1)ã‚‚åˆ†ã‹ã‚‹ã€‚

(2) ã“ã“ã§ã€ä»®ã«ã‚¬ãƒ–ãƒªã‚¨ãƒ«ã®çˆ¶ãŒãƒ‘ãƒ¼ã‚«ãƒ¼åšå£«ã ã¨ã™ã‚‹ã¨ã€
ã€Œã‚¬ãƒ–ãƒªã‚¨ãƒ«ã®çˆ¶ã¯ã€ãƒ‘ãƒ¼ã‚«ãƒ¼åšå£«ã®å¨˜ã«ã¡ãªã‚“ã§åä»˜ã‘ã‚‰ã‚ŒãŸãƒ¨ãƒƒãƒˆã‚’æ‰€æœ‰ã—ã¦ã„ã‚‹ã€
ã¨ã„ã†è¨˜è¿°(â€»)ã‚ˆã‚Šã€ãƒ‘ãƒ¼ã‚«ãƒ¼åšå£«ã¯è‡ªåˆ†ã®å¨˜ã®åã‚’ãƒ¨ãƒƒãƒˆã«ä»˜ã‘ã¦ã„ã‚‹ã“ã¨ã«ãªã‚Šã€
çŸ›ç›¾ã™ã‚‹ã€‚ã‚ˆã£ã¦ã€ã‚¬ãƒ–ãƒªã‚¨ãƒ«ã®çˆ¶ã¯ãƒ‘ãƒ¼ã‚«ãƒ¼åšå£«ã§ã¯ãªã„ (ğŸ†–(2))ã€‚

(3) æ¬¡ã«ã€ã‚¬ãƒ–ãƒªã‚¨ãƒ«ã®çˆ¶ãŒãƒ€ã‚¦ãƒ‹ãƒ³ã‚°å¤§ä½ã ã¨ã™ã‚‹ã€‚ã—ã‹ã—ã€ãƒ€ã‚¦ãƒ‹ãƒ³ã‚°å¤§ä½ã®ãƒ¨ãƒƒãƒˆã¯
ãƒ¡ãƒªãƒƒã‚µå·ã§ã€ã“ã‚Œã¯ãƒãƒ¼ãƒŠã‚¯ãƒ«å¿ã®å¨˜ã«ã¡ãªã‚“ã åã§ã‚ã‚‹ã€‚ã¤ã¾ã‚Šä¸Šè¨˜ã®è¨˜è¿°(â€»)ã¨
çŸ›ç›¾ã™ã‚‹ã€‚ã‚ˆã£ã¦ã€ã‚¬ãƒ–ãƒªã‚¨ãƒ«ã®çˆ¶ã¯ãƒ€ã‚¦ãƒ‹ãƒ³ã‚°å¤§ä½ã§ã‚‚ãªã„ (ğŸ†–(3))ã€‚

(4) ã™ã‚‹ã¨ã‚¬ãƒ–ãƒªã‚¨ãƒ«ã®çˆ¶ã®å¯èƒ½æ€§ãŒã‚ã‚‹ã®ã¯ã€ãƒ›ãƒ¼ãƒ«æ°ã®ã¿ã§ã‚ã‚‹ (ğŸ‰(4))ã€‚
ã¨ã„ã†ã“ã¨ã¯ãƒ›ãƒ¼ãƒ«æ°ã¯ãƒ­ãƒ«ãƒŠã®çˆ¶ã§ã¯ãªã„ (Ã—(4))ã€‚

(5) ã‚¬ãƒ–ãƒªã‚¨ãƒ«ã®çˆ¶ãŸã‚‹ãƒ›ãƒ¼ãƒ«æ°ãŒæ‰€æœ‰ã—ã¦ã„ã‚‹ã®ã¯ã€ãƒ­ã‚¶ãƒªãƒ³ãƒ‰å·ã§ã‚ã‚‹ã€‚
ä¸Šè¨˜ã®è¨˜è¿°(â€»)ã‚ˆã‚Šã€ãƒ‘ãƒ¼ã‚«ãƒ¼åšå£«ã®å¨˜ãŒãƒ­ã‚¶ãƒªãƒ³ãƒ‰ã§ã‚ã‚‹ (ğŸ‰(5))ã€‚
åŒã˜åˆ—ãƒ»è¡Œã®ç©ºã„ã¦ã„ã‚‹ã¨ã“ã‚ã‚‚æ¶ˆã›ã‚‹ (Ã—(5))ã€‚

(6) ã¨ã„ã†ã‚ã‘ã§ã€ãƒ­ãƒ«ãƒŠã®çˆ¶ã¯ãƒ€ã‚¦ãƒ‹ãƒ³ã‚°å¤§ä½ã§ã‚ã‚‹ (ğŸ‰(6))ã€‚</span>
</div>

<br>

<div class="exercise"><span class="ex_comment">ã‚‚ã—ãƒ¡ã‚¢ãƒªãƒ»ã‚¢ãƒ³ã®å§“ãŒãƒ ãƒ¼ã‚¢ã§ã‚ã‚‹ã¨è¨€ã‚ã‚Œã¦ã„ãªã‹ã£ãŸã‚‰ã€ã©ã†ãªã‚‹ã‹ã€‚</span>

<table class="expl ex_comment">
<tr><th rowspan="2">å¨˜ã®å</th><th colspan="5">çˆ¶</th></tr>
<tr><th>ãƒ ãƒ¼ã‚¢æ°</th><th>ãƒ€ã‚¦ãƒ‹ãƒ³ã‚°å¤§ä½</th><th>ãƒ›ãƒ¼ãƒ«æ°</th><th>ãƒãƒ¼ãƒŠã‚¯ãƒ«å¿</th><th>ãƒ‘ãƒ¼ã‚«ãƒ¼åšå£«</th></tr>
<tr><th>ãƒ¡ã‚¢ãƒªãƒ»ã‚¢ãƒ³</th><td>ğŸŒº(d)</td><td></td><td>ğŸŒ»(d)</td><td>âŒ</td><td>ğŸ†–(1)</td></tr>
<tr><th>ã‚¬ãƒ–ãƒªã‚¨ãƒ«</th><td>ğŸŒ»(a)</td><td>ğŸ†–(3)</td><td>ğŸŒº(a)</td><td>âŒ</td><td>ğŸ†–(2)</td></tr>
<tr><th>ãƒ­ãƒ«ãƒŠ</th><td>ğŸ†–(1)</td><td>ğŸŒº(c)</td><td></td><td>âŒ</td><td>ğŸŒ»(b)</td></tr>
<tr><th>ãƒ­ã‚¶ãƒªãƒ³ãƒ‰</th><td></td><td>ğŸŒ»(c)</td><td>ğŸ†–(1)</td><td>âŒ</td><td>ğŸŒº(b)</td></tr>
<tr><th>ãƒ¡ãƒªãƒƒã‚µ</th><td>âŒ</td><td>âŒ</td><td>âŒ</td><td>ğŸ˜€</td><td>âŒ</td></tr>
</table>
<table class="expl ex_comment">
<tr><th rowspan="2">ãƒ¨ãƒƒãƒˆã®å</th><th colspan="5">ãƒ¨ãƒƒãƒˆæ‰€æœ‰è€…</th></tr>
<tr><th>ãƒ ãƒ¼ã‚¢æ°</th><th>ãƒ€ã‚¦ãƒ‹ãƒ³ã‚°å¤§ä½</th><th>ãƒ›ãƒ¼ãƒ«æ°</th><th>ãƒãƒ¼ãƒŠã‚¯ãƒ«å¿</th><th>ãƒ‘ãƒ¼ã‚«ãƒ¼åšå£«</th></tr>
<tr><th>ãƒ¡ã‚¢ãƒªãƒ»ã‚¢ãƒ³</th><td>âŒ</td><td>âŒ</td><td>âŒ</td><td>âŒ</td><td>â›µ</td></tr>
<tr><th>ã‚¬ãƒ–ãƒªã‚¨ãƒ«</th><td>âŒ</td><td>âŒ</td><td>âŒ</td><td>ğŸ˜€</td><td>âŒ</td></tr>
<tr><th>ãƒ­ãƒ«ãƒŠ</th><td>ğŸ˜€</td><td>âŒ</td><td>âŒ</td><td>âŒ</td><td>âŒ</td></tr>
<tr><th>ãƒ­ã‚¶ãƒªãƒ³ãƒ‰</th><td>âŒ</td><td>âŒ</td><td>ğŸ˜€</td><td>âŒ</td><td>âŒ</td></tr>
<tr><th>ãƒ¡ãƒªãƒƒã‚µ</th><td>âŒ</td><td>ğŸ˜€</td><td>âŒ</td><td>âŒ</td><td>âŒ</td></tr>
</table>
<span class="ex_comment">(1) ğŸ˜€ã¯å•é¡Œæ–‡ã«è¨˜è¿°ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã€‚âŒã¯ã€ğŸ˜€ã®ã‚ã‚‹åˆ—ãƒ»è¡Œã®æ®‹ã‚Šã®éƒ¨åˆ†ã€‚
ã“ã“ã‹ã‚‰ã™ãã«ã€â›µãŒåˆ¤æ˜ã™ã‚‹ã€‚
ã¾ãŸã€ãƒ¨ãƒƒãƒˆã«ã¯è‡ªåˆ†ã®å¨˜ã®åå‰ã‚’ã¤ã‘ãªã„ã®ã§ã€ğŸ†–(1)ã‚‚åˆ†ã‹ã‚‹ã€‚

(2) ä»®ã«ã‚¬ãƒ–ãƒªã‚¨ãƒ«ã®çˆ¶ãŒãƒ‘ãƒ¼ã‚«ãƒ¼åšå£«ã ã¨ã™ã‚‹ã¨çŸ›ç›¾ã™ã‚‹ã®ã¯ã€å…ƒã®å ´åˆã¨åŒã˜ã€‚
ã‚ˆã£ã¦ã€ã‚¬ãƒ–ãƒªã‚¨ãƒ«ã®çˆ¶ã¯ãƒ‘ãƒ¼ã‚«ãƒ¼åšå£«ã§ã¯ãªã„ (ğŸ†–(2))ã€‚

(3) ã‚¬ãƒ–ãƒªã‚¨ãƒ«ã®çˆ¶ãŒãƒ€ã‚¦ãƒ‹ãƒ³ã‚°å¤§ä½ã§ã‚‚ã‚ã‚Šå¾—ãªã„ã€ã¨ã„ã†ç‚¹ã‚‚ã€å…ƒã®å ´åˆã¨åŒã˜ (ğŸ†–(3))ã€‚

(4) ä»®ã«ã‚¬ãƒ–ãƒªã‚¨ãƒ«ã®çˆ¶ãŒãƒ ãƒ¼ã‚¢æ°ã§ã‚ã‚‹ã¨ã™ã‚‹ (ğŸŒ»(a))ã€‚
ãƒ ãƒ¼ã‚¢æ°ã®ãƒ¨ãƒƒãƒˆã¯ãƒ­ãƒ«ãƒŠå·ãªã®ã§ã€ä¸Šè¨˜ã®è¨˜è¿°(â€»)ã«ã‚ˆã‚Œã°ã€
ãƒ­ãƒ«ãƒŠã¯ãƒ‘ãƒ¼ã‚«ãƒ¼åšå£«ã®å¨˜ã¨ã„ã†ã“ã¨ã«ãªã‚‹ (ğŸŒ»(b))ã€‚
ã“ã®å ´åˆã«ã€ãƒ­ã‚¶ãƒªãƒ³ãƒ‰ã®çˆ¶ã®å¯èƒ½æ€§ãŒã‚ã‚‹ã®ã¯ã€ãƒ€ã‚¦ãƒ‹ãƒ³ã‚°å¤§ä½ã®ã¿ (ğŸŒ»(c))ã€‚
ãã†ã™ã‚‹ã¨ã€ãƒ¡ã‚¢ãƒªãƒ»ã‚¢ãƒ³ã®çˆ¶ã¯ãƒ›ãƒ¼ãƒ«æ°ã«å®šã¾ã‚‹ (ğŸŒ»(d))ã€‚

(5) æ¬¡ã«ã‚¬ãƒ–ãƒªã‚¨ãƒ«ã®çˆ¶ãŒãƒ›ãƒ¼ãƒ«æ°ã ã¨ä»®å®šã™ã‚‹ (ğŸŒº(a))ã€‚
ãƒ›ãƒ¼ãƒ«æ°ã®ãƒ¨ãƒƒãƒˆã¯ãƒ­ã‚¶ãƒªãƒ³ãƒ‰å·ãªã®ã§ã€ä¸Šè¨˜ã®è¨˜è¿°(â€»)ã«ã‚ˆã‚Œã°ã€
ãƒ­ã‚¶ãƒªãƒ³ãƒ‰ã¯ãƒ‘ãƒ¼ã‚«ãƒ¼åšå£«ã®å¨˜ã¨ã„ã†ã“ã¨ã«ãªã‚‹ (ğŸŒº(b))ã€‚
ã“ã®å ´åˆã«ã€ãƒ­ãƒ«ãƒŠã®çˆ¶ã®å¯èƒ½æ€§ãŒã‚ã‚‹ã®ã¯ã€ãƒ€ã‚¦ãƒ‹ãƒ³ã‚°å¤§ä½ã®ã¿ (ğŸŒº(c))ã€‚
ã¨ã„ã†ã“ã¨ã¯ã€æ®‹ã£ãŸãƒ ãƒ¼ã‚¢æ°ã¨ãƒ¡ã‚¢ãƒªãƒ»ã‚¢ãƒ³ãŒè¦ªå­ã§ã‚ã‚‹ (ğŸŒº(d))ã€‚

(6) ä»¥ä¸Šã‚ˆã‚Šã€ğŸŒ»ã¨ğŸŒºã®2é€šã‚Šã®è§£ãŒå­˜åœ¨ã™ã‚‹ã€‚
</span>
</div>

<p class="orig" lang="en">
<a name="%_thm_4.44"></a>
<b>Exercise 4.44.</b>  <a name="%_idx_4944"></a><a name="%_idx_4946"></a><a name="%_idx_4948"></a><a name="%_idx_4950"></a>Exercise <a href="15_sec2_2.html#%_thm_2.42">2.42</a> described the ``eight-queens puzzle'' of
placing queens on a chessboard so that no two attack each other.
Write a nondeterministic program to solve this puzzle.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ 4.44.</b> ç·´ç¿’å•é¡Œ<a href="15_sec2_2.html#%_thm_2.42">2.42</a>ã§ã¯ã€ã©ã®äºŒã¤ã®ã‚¯ã‚¤ãƒ¼ãƒ³ã‚‚äº’ã„ã‚’æ”»æ’ƒã—ãªã„ã‚ˆã†ã«ã‚¯ã‚¤ãƒ¼ãƒ³ã‚’ãƒã‚§ã‚¹ç›¤ã®ä¸Šã«é…ç½®ã™ã‚‹ã¨ã„ã†ã€ã€Œã‚¨ã‚¤ãƒˆãƒ»ã‚¯ã‚¤ãƒ¼ãƒ³ãƒ»ãƒ‘ã‚ºãƒ«ã€ã«ã¤ã„ã¦èª¬æ˜ã—ãŸã€‚
ã“ã®ãƒ‘ã‚ºãƒ«ã‚’è§£ããŸã‚ã®éæ±ºå®šçš„ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ã‘ã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_Temp_618"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_618">Parsing natural language</a></h4>
<h4 class="trans" lang="ja">è‡ªç„¶è¨€èªã‚’æ§‹æ–‡è§£æã™ã‚‹</h4>

<p class="orig" lang="en">
<a name="%_idx_4952"></a><a name="%_idx_4954"></a>
Programs designed to accept natural language as input usually start by
attempting to <em>parse</em> the input, that is, to match the input
against some grammatical structure.  For example, we might try to
recognize simple sentences consisting of an article followed by a noun
followed by a verb, such as ``The cat eats.''  To accomplish such an
analysis, we must be able to identify the parts of speech of
individual words.  We could start with some lists that classify
various words:<a name="call_footnote_Temp_619" href="#footnote_Temp_619"><sup><small>50</small></sup></a></p>

<p class="trans" lang="ja">
è‡ªç„¶è¨€èªã‚’å…¥åŠ›ã¨ã—ã¦å—ã‘ä»˜ã‘ã‚‹ã‚ˆã†ã«è¨­è¨ˆã•ã‚ŒãŸãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€é€šå¸¸ã€å…¥åŠ›ã‚’<em>æ§‹æ–‡è§£æã™ã‚‹</em>â€”â€”ã™ãªã‚ã¡ã€ä½•ã‚‰ã‹ã®æ–‡æ³•æ§‹é€ ã«å¯¾ã—ã¦å…¥åŠ›ã‚’é©åˆã•ã›ã‚‹â€”â€”ã“ã¨ã‚’è©¦ã¿ã‚‹ã“ã¨ã‹ã‚‰ã€å§‹ã¾ã‚‹ã€‚
ãŸã¨ãˆã°ã€&ldquo;The cat eats.&rdquo; ã®ã‚ˆã†ã«ã€å† è©ãŒã‚ã£ã¦ã€ãã®å¾Œã«åè©ãŒç¶šãã€ãã®å¾Œã«å‹•è©ãŒç¶šãã‚ˆã†ã«æ§‹æˆã•ã‚Œã¦ã„ã‚‹å˜ç´”ãªæ–‡ã‚’èªè­˜ã—ã‚ˆã†ã¨ã™ã‚‹ã“ã¨ãŒã‚ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚
ãã†ã—ãŸè§£æã‚’é”æˆã™ã‚‹ã«ã¯ã€å€‹ã€…ã®èªã®å“è©ã‚’ç‰¹å®šã§ããªãã¦ã¯ãªã‚‰ãªã„ã€‚
æ§˜ã€…ãªèªã‚’åˆ†é¡ã™ã‚‹ã‚ˆã†ãªã‚ã‚‹ç¨®ã®ãƒªã‚¹ãƒˆã‚’ä½¿ã£ã¦ã€å§‹ã‚ã‚‹ã“ã¨ã‚‚ã§ãã‚‹<a href="#footnote_Temp_619"><sup><small>50</small></sup></a>ã€‚
</p>

<p class="lisp"><a name="%_idx_4956"></a>(define nouns '(noun student professor cat class))
<a name="%_idx_4958"></a>(define verbs '(verb studies lectures eats sleeps))
<a name="%_idx_4960"></a>(define articles '(article the a))
</p>


<p class="orig" lang="en"><a name="%_idx_4962"></a>We also need a <em>grammar</em>, that is, a set of rules describing how
grammatical elements are composed from simpler elements.  A very
simple grammar might stipulate that a sentence always consists of two
pieces -- a noun phrase followed by a verb -- and that a noun phrase
consists of an article followed by a noun.  With this grammar, the
sentence ``The cat eats'' is parsed as follows:</p>

<p class="trans" lang="ja">
ã¾ãŸã€<em>æ–‡æ³•</em>â€”â€”ã™ãªã‚ã¡ã€ã©ã®ã‚ˆã†ã«ã—ã¦æ–‡æ³•çš„è¦ç´ ãŒã‚ˆã‚Šå˜ç´”ãªè¦ç´ ã‹ã‚‰æ§‹æˆã•ã‚Œã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’è¨˜è¿°ã™ã‚‹è¦å‰‡ã®ä¸€å¼â€”â€”ã‚‚å¿…è¦ã§ã‚ã‚‹ã€‚
éå¸¸ã«å˜ç´”ãªæ–‡æ³•ã¯ã€æ–‡ãŒå¸¸ã«äºŒã¤ã®éƒ¨åˆ†â€”â€”åè©å¥ã¨ãã‚Œã«ç¶šãå‹•è©â€”â€”ã‹ã‚‰ãªã‚Šã€åè©å¥ã¯å† è©ã¨ãã‚Œã«ç¶šãåè©ã‹ã‚‰ãªã‚‹ã€ã¨è¦å®šã™ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚
ã“ã®æ–‡æ³•ã‚’ä½¿ã†ã¨ã€&ldquo;The cat eats.&rdquo; ã¨ã„ã†æ–‡ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã«æ§‹æ–‡è§£æã•ã‚Œã‚‹ã€‚
</p>

<p class="lisp">(sentence (noun-phrase (article the) (noun cat))
          (verb eats))
</p>


<p class="orig" lang="en">
We can generate such a parse with a simple program that has separate
procedures for each of the grammatical rules.  To parse a sentence, we
identify its two constituent pieces and return a list of
these two elements, tagged with the symbol <tt>sentence</tt>:</p>

<p class="trans" lang="ja">
ã“ã†ã—ãŸæ§‹æ–‡è§£æã‚’ã€æ–‡æ³•çš„è¦å‰‡ã®å„ã€…ã«ã¤ã„ã¦åˆ¥ã€…ã®æ‰‹ç¶šãã‚’æœ‰ã™ã‚‹å˜ç´”ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ä½¿ã£ã¦ã€ç”Ÿæˆã™ã‚‹ã“ã¨ãŒå¯èƒ½ã§ã‚ã‚‹ã€‚
æ–‡ã‚’æ§‹æ–‡è§£æã™ã‚‹ã«ã¯ã€ãã®æ–‡ã®äºŒã¤ã®æ§‹æˆè¦ç´ ã‚’ç‰¹å®šã—ã€ã“ã‚Œã‚‰äºŒã¤ã®è¦ç´ ã®ãƒªã‚¹ãƒˆâ€”â€”ãŸã ã— <tt>sentence</tt> ã¨ã„ã†è¨˜å·ã§ã‚¿ã‚°ä»˜ã‘ã—ãŸã‚‚ã®â€”â€”ã‚’è¿”ã™ã€‚
</p>


<a name="%_idx_4964"></a><p class="lisp">(define (parse-sentence)
  (list 'sentence
         (parse-noun-phrase)
         (parse-word verbs)))
</p>

<p class="orig" lang="en">A noun phrase, similarly, is parsed by finding an article followed by a
noun:</p>

<p class="trans" lang="ja">
åè©å¥ã¯ã€åŒæ§˜ã«ã€å† è©ã¨ãã‚Œã«ç¶šãåè©ã‚’è¦‹ã¤ã‘ã‚‹ã“ã¨ã§ã€æ§‹æ–‡è§£æã•ã‚Œã‚‹ã€‚
</p>

<p class="lisp">(define (parse-noun-phrase)
  (list 'noun-phrase
        (parse-word articles)
        (parse-word nouns)))
</p>

<p class="orig" lang="en">
At the lowest level, parsing boils down to repeatedly checking that
the next unparsed word is a member of the list of words for the
required part of speech.  To implement this, we maintain a global
variable <tt>*unparsed*</tt>, which is the input that has not yet been
parsed.  Each time we check a word, we require that <tt>*unparsed*</tt>
must be non-empty and that it should begin with a word from the
designated list.  If so, we remove that word from <tt>*unparsed*</tt> and
return the word together with its part of speech (which is found at
the head of the list):<a name="call_footnote_Temp_620" href="#footnote_Temp_620"><sup><small>51</small></sup></a></p>

<p class="trans" lang="ja">
ã‚‚ã£ã¨ã‚‚ä½ã„ãƒ¬ãƒ™ãƒ«ã«ãŠã„ã¦æ§‹æ–‡è§£æã¯ã€ã¤ã¾ã‚‹ã¨ã“ã‚ã€ã¾ã æ§‹æ–‡è§£æã•ã‚Œã¦ã„ãªã„æ¬¡ã®èªãŒã€æ±‚ã‚ã‚‰ã‚Œã‚‹å“è©ã®èªã®ãƒªã‚¹ãƒˆã®æ§‹æˆè¦ç´ ã§ã‚ã‚‹ã“ã¨ã‚’ã€ç¹°ã‚Šè¿”ã—ç¢ºèªã™ã‚‹ã“ã¨ã«å¸°ç€ã™ã‚‹ã€‚
ã“ã‚Œã‚’å®Ÿè£…ã™ã‚‹ã«ã¯ã€<tt>*unparsed*</tt> ã¨ã„ã†å¤§åŸŸå¤‰æ•°â€”â€”ã¾ã æ§‹æ–‡è§£æã•ã‚Œã¦ã„ãªã„å…¥åŠ›ã§ã‚ã‚‹â€”â€”ã‚’ç¶­æŒã™ã‚‹ã€‚
èªã‚’ç¢ºèªã™ã‚‹ãŸã³ã«ã€<tt>*unparsed*</tt> ãŒéç©ºã§ãªã‘ã‚Œã°ãªã‚‰ãªã„ã¨è¦æ±‚ã™ã‚‹ã¨ã¨ã‚‚ã«ã€<tt>*unparsed*</tt> ãŒæŒ‡å®šã•ã‚ŒãŸãƒªã‚¹ãƒˆã®èªã§å§‹ã¾ã‚‹ã¹ãã§ã‚ã‚‹ã¨è¦æ±‚ã™ã‚‹ã€‚
ã‚‚ã—ãã†ã§ã‚ã‚Œã°ã€ãã®èªã‚’ <tt>*unparsed*</tt> ã‹ã‚‰å–ã‚Šé™¤ãã€ãã®èªã‚’ãã®å“è© (ãƒªã‚¹ãƒˆã®å…ˆé ­ã§è¦‹ã¤ã‹ã‚‹) ã¨ã¨ã‚‚ã«è¿”ã™ã€‚
</p>

<p class="lisp">(define (parse-word word-list)
  (require (not (null? *unparsed*)))
  (require (memq (car *unparsed*) (cdr word-list)))
  (let ((found-word (car *unparsed*)))
    (set! *unparsed* (cdr *unparsed*))
    (list (car word-list) found-word)))
</p>

<p class="orig" lang="en">
To start the parsing, all we need to do is set <tt>*unparsed*</tt> to be
the entire input, try to parse a sentence, and check that nothing is
left over:</p>

<p class="trans" lang="ja">
æ§‹æ–‡è§£æã‚’å§‹ã‚ã‚‹ã«ã¯ã€<tt>*unparsed*</tt> ã‚’å®Œå…¨ãªå…¥åŠ›ã¨ãªã‚‹ã‚ˆã†ã«è¨­å®šã—ã¦ã€æ–‡ã‚’æ§‹æ–‡è§£æã™ã‚‹ã“ã¨ã‚’è©¦ã¿ã€ä½•ã‚‚æ®‹ã‚‰ãªã„ã“ã¨ã‚’ç¢ºèªã™ã‚‹ã ã‘ã§ã‚ˆã„ã€‚
</p>

<p class="lisp">(define *unparsed* '())
<a name="%_idx_4966"></a>(define (parse input)
  (set! *unparsed* input)
  (let ((sent (parse-sentence)))
    (require (null? *unparsed*))
    sent))
</p>

<p class="orig" lang="en">
We can now try the parser and verify that it works for our simple test
sentence:</p>

<p class="trans" lang="ja">
ã•ã¦ä»Šã‚„ã€æ§‹æ–‡è§£æå™¨ã‚’è©¦ã—ã¦ã¿ã¦ã€ãã‚ŒãŒç§ãŸã¡ã®å˜ç´”ãªãƒ†ã‚¹ãƒˆæ–‡ã«å¯¾ã—ã¦ã†ã¾ãã„ãã“ã¨ã‚’ç¢ºã‹ã‚ã‚‹ã“ã¨ãŒå¯èƒ½ã§ã‚ã‚‹ã€‚
</p>

<p class="lisp"><i>;;; Amb-Eval input:</i>
(parse '(the cat eats))
<i>;;; Starting a new problem</i>
<i>;;; Amb-Eval value:</i>
<i>(sentence (noun-phrase (article the) (noun cat)) (verb eats))</i>
</p>

<p class="orig" lang="en">
The <tt>amb</tt> evaluator is useful here because it is convenient to
express the parsing constraints with the aid of <tt>require</tt>.
Automatic search and backtracking really pay off, however, when we
consider more complex grammars where there are choices for how the
units can be decomposed.</p>

<p class="trans" lang="ja">
<tt>require</tt> ã®åŠ©ã‘ã‚’å€Ÿã‚Šã¦æ§‹æ–‡è§£æä¸Šã®åˆ¶ç´„ã‚’è¡¨ã™ã®ãŒä¾¿åˆ©ãªã®ã§ã€ã“ã“ã§ã¯ã€<tt>amb</tt> è©•ä¾¡å™¨ãŒæœ‰ç”¨ã§ã‚ã‚‹ã€‚
è‡ªå‹•çš„ãªæ¢ç´¢ã¨ãƒãƒƒã‚¯ãƒˆãƒ©ãƒƒã‚¯ã¯ã€ã—ã‹ã—ã€å˜ä½ã‚’ã©ã®ã‚ˆã†ã«åˆ†è§£ã§ãã‚‹ã®ã‹ã«ã¤ã„ã¦ã„ãã¤ã‹ã®é¸æŠè‚¢ãŒã‚ã‚‹ã‚ˆã†ãªæ›´ã«è¤‡é›‘ãªæ–‡æ³•ã‚’è€ƒãˆã‚‹å ´åˆã«ã€æœ¬å½“ã«å®Ÿã‚’çµã¶ã®ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
Let's add to our grammar a list of prepositions:</p>

<p class="trans" lang="ja">
ç§ãŸã¡ã®æ–‡æ³•ã«ã€å‰ç½®è©ã®ãƒªã‚¹ãƒˆã‚’åŠ ãˆã‚ˆã†ã€‚
</p>

<p class="lisp"><a name="%_idx_4968"></a>(define prepositions '(prep for to in by with))
</p>

<p class="orig" lang="en">
and define a prepositional phrase (e.g., ``for the cat'') to be
a preposition followed by a noun phrase:</p>

<p class="trans" lang="ja">
ãã—ã¦ã€å‰ç½®è©å¥ (ãŸã¨ãˆã° &ldquo;for the cat&rdquo;) ã‚’ã€å‰ç½®è©ã¨ãã‚Œã«ç¶šãåè©å¥ã§ã‚ã‚‹ã€ã¨å®šç¾©ã—ã‚ˆã†ã€‚
</p>

<p class="lisp">(define (parse-prepositional-phrase)
  (list 'prep-phrase
        (parse-word prepositions)
        (parse-noun-phrase)))
</p>


<p class="orig" lang="en">Now we can define a sentence to be a noun phrase followed by a verb
phrase, where a verb phrase can be either a verb or a verb phrase
extended by a prepositional phrase:<a name="call_footnote_Temp_621" href="#footnote_Temp_621"><sup><small>52</small></sup></a></p>

<p class="trans" lang="ja">
ã•ã¦ä»Šã‚„ã€æ–‡ã‚’ã€åè©å¥ã¨ãã‚Œã«ç¶šãå‹•è©å¥ã§ã‚ã‚‹ã€ã¨å®šç¾©ã§ãã€ã“ã“ã§å‹•è©å¥ã¨ã¯ã€å‹•è©ã‹ã€å‰ç½®è©ã«ã‚ˆã‚Šæ‹¡å¼µã•ã‚ŒãŸå‹•è©å¥ã®ã„ãšã‚Œã‹ã§ã‚ã‚Šå¾—ã‚‹ <a href="#footnote_Temp_621"><sup><small>52</small></sup></a>ã€‚
</p>

<p class="lisp">(define (parse-sentence)
  (list 'sentence
         (parse-noun-phrase)
         (parse-verb-phrase)))
(define (parse-verb-phrase)
  (define (maybe-extend verb-phrase)
    (amb verb-phrase
         (maybe-extend (list 'verb-phrase
                             verb-phrase
                             (parse-prepositional-phrase)))))
  (maybe-extend (parse-word verbs)))
</p>

<p class="orig" lang="en">
While we're at it, we can also elaborate the definition of noun
phrases to permit such things as ``a cat in the class.''  What we used
to call a noun phrase, we'll now call a simple noun phrase, and a noun
phrase will now be either a simple noun phrase or a noun phrase
extended by a prepositional phrase:</p>

<p class="trans" lang="ja">
ç§ãŸã¡ã¯ç²¾ã‚’å‡ºã™ä¸€æ–¹ã§ <span class="note">(?)</span>ã€&ldquo;a cat in the class&rdquo; ã®ã‚ˆã†ãªã‚‚ã®ã‚’è¨±ã™ãŸã‚ã«åè©å¥ã®å®šç¾©ã‚’ç·´ã‚Šä¸Šã’ã‚‹ã“ã¨ã‚‚ã§ãã‚‹ã€‚
ä»Šã¾ã§åè©å¥ã¨å‘¼ã‚“ã§ããŸã‚‚ã®ã‚’ã€ã“ã‚Œã‹ã‚‰ã¯å˜ç´”åè©å¥ã¨å‘¼ã¼ã†ã€‚ãã—ã¦ã€ã“ã‚Œã‹ã‚‰ã¯ã€åè©å¥ã¨ã¯ã€å˜ç´”åè©å¥ã‹ã€å‰ç½®è©å¥ã«ã‚ˆã£ã¦æ‹¡å¼µã•ã‚ŒãŸåè©å¥ã®ã„ãšã‚Œã‹ã¨ãªã‚‹ã€‚
</p>

<p class="lisp">(define (parse-simple-noun-phrase)
  (list 'simple-noun-phrase
        (parse-word articles)
        (parse-word nouns)))
(define (parse-noun-phrase)
  (define (maybe-extend noun-phrase)
    (amb noun-phrase
         (maybe-extend (list 'noun-phrase
                             noun-phrase
                             (parse-prepositional-phrase)))))
  (maybe-extend (parse-simple-noun-phrase)))
</p>


<p class="orig" lang="en">
Our new grammar lets us parse more complex sentences.  For example</p>

<p class="trans" lang="ja">
æ–°ã—ã„æ–‡æ³•ã«ã‚ˆã‚Šã€ç§ãŸã¡ã¯ã€ã‚ˆã‚Šè¤‡é›‘ãªæ–‡ã‚’æ§‹æ–‡è§£æã§ãã‚‹ã€‚
ãŸã¨ãˆã°ã€
</p>

<p class="lisp">(parse '(the student with the cat sleeps in the class))
</p>

<p class="orig" lang="en">produces</p>

<p class="trans" lang="ja">
ã¯ã€ä»¥ä¸‹ã®ã‚‚ã®ã‚’ä½œã‚Šå‡ºã™ã€‚
</p>

<p class="lisp">(sentence
 (noun-phrase
  (simple-noun-phrase (article the) (noun student))
  (prep-phrase (prep with)
               (simple-noun-phrase
                (article the) (noun cat))))
 (verb-phrase
  (verb sleeps)
  (prep-phrase (prep in)
               (simple-noun-phrase
                (article the) (noun class)))))
</p>


<p class="orig" lang="en">
Observe that a given input may have more than one legal parse.  In
the sentence ``The professor lectures to the student with the cat,''
it may be that the professor is lecturing with the cat, or that the
student has the cat.  Our nondeterministic program finds both
possibilities:</p>

<p class="trans" lang="ja">
ä¸ãˆã‚‰ã‚ŒãŸå…¥åŠ›ã«ã¯ã€é©æ³•ãªæ§‹æ–‡è§£æçµæœãŒä¸€ã¤ã‚ˆã‚Šå¤šãã‚ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€ã¨ã„ã†ã“ã¨ã«æ°—ã¥ã„ã¦ã»ã—ã„ã€‚
&ldquo;The professor lectures to the student with the cat&rdquo;
ã¨ã„ã†æ–‡ã§ã¯ã€æ•™æˆãŒçŒ«ã¨ä¸€ç·’ã«è¬›ç¾©ã‚’è¡Œã£ã¦ã„ã‚‹ã®ã‹ã‚‚ã—ã‚Œãªã„ã—ã€ã‚ã‚‹ã„ã¯ã€å­¦ç”ŸãŒçŒ«ã‚’é€£ã‚Œã¦ã„ã‚‹ã®ã‹ã‚‚ã—ã‚Œãªã„ã€‚
ç§ãŸã¡ã®éæ±ºå®šçš„ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€åŒæ–¹ã®å¯èƒ½æ€§ã‚’è¦‹ã¤ã‘ã‚‹ã€‚
</p>

<p class="lisp">(parse '(the professor lectures to the student with the cat))
</p>

<p class="orig" lang="en">produces</p>

<p class="trans" lang="ja">
ã¯ã€ä»¥ä¸‹ã®ã‚‚ã®ã‚’ä½œã‚Šå‡ºã™ã€‚
</p>

<p class="lisp">(sentence
 (simple-noun-phrase (article the) (noun professor))
 (verb-phrase
  (verb-phrase
   (verb lectures)
   (prep-phrase (prep to)
                (simple-noun-phrase
                 (article the) (noun student))))
  (prep-phrase (prep with)
               (simple-noun-phrase
                (article the) (noun cat)))))
</p>

<p class="orig" lang="en">Asking the evaluator to try again yields</p>

<p class="trans" lang="ja">
å†ã³è©¦ã¿ã‚ˆã€ã¨è©•ä¾¡å™¨ã«æ±‚ã‚ã‚‹ã¨ã€ä»¥ä¸‹ã®ã‚‚ã®ã‚’ç”Ÿã¿å‡ºã™ã€‚
</p>

<p class="lisp">(sentence
 (simple-noun-phrase (article the) (noun professor))
 (verb-phrase
  (verb lectures)
  (prep-phrase (prep to)
               (noun-phrase
                (simple-noun-phrase
                 (article the) (noun student))
                (prep-phrase (prep with)
                             (simple-noun-phrase
                              (article the) (noun cat)))))))
</p>

<p class="orig" lang="en">
<a name="%_thm_4.45"></a>
<b>Exercise 4.45.</b>  With the grammar given above, the following sentence can be parsed in
five different ways:
``The professor lectures to the student in the class with the cat.''
Give the five parses and explain the differences in shades of
meaning among them.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ 4.45.</b> ä¸Šè¨˜ã®æ–‡æ³•ãŒä¸ãˆã‚‰ã‚ŒãŸå ´åˆã€ä»¥ä¸‹ã®æ–‡ã¯ã€ç•°ãªã‚‹5é€šã‚Šã®ä»•æ–¹ã§æ§‹æ–‡è§£æã•ã‚Œå¾—ã‚‹ã€‚
&ldquo;The professor lectures to the student in the class with the cat.&rdquo;
5é€šã‚Šã®æ§‹æ–‡è§£æçµæœã‚’æŒ™ã’ã€ãã‚Œã‚‰ã®é–“ã§ã®æ„å‘³ã®ãƒ‹ãƒ¥ã‚¢ãƒ³ã‚¹ã®é•ã„ã‚’èª¬æ˜ã›ã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment">ãƒ‹ãƒ¥ã‚¢ãƒ³ã‚¹ã®é•ã„ã‚’æ±²ã¿å–ã‚Šåˆ‡ã‚Œã¦ã„ã‚‹ã‹ä¸å®‰ã ãŒã€
ä¸€å¿œã€ä»¥ä¸‹ã®5é€šã‚ŠãŒè€ƒãˆã‚‰ã‚Œã‚‹ã€‚</span>

The professor lectures to the student in the class with the cat.
---- NP ----- -- VP -- ---- PP ------
---- NP ----- ------ VP ------------- --- PP -----
---- NP ----- ------ VP -------------------------- ---- PP ----
---- NP ----- ------ VP ---------------------------------------
<span class="ex_comment">ãã®æˆæ¥­ã§ã€æ•™æˆãŒãã®å­¦ç”Ÿã«è¬›ç¾©ã™ã‚‹ã€‚
(ã“ã®æˆæ¥­ã«ç™»éŒ²ã—ã¦ã„ã‚‹å­¦ç”Ÿã¯ãã®ä¸€äººãªã®ã‹ã‚‚ã—ã‚Œãªã„ã—ã€ä»–ã®å­¦ç”ŸãŸã¡ãŒ
ãŸã¾ãŸã¾ä¼‘ã‚“ã§ã„ã‚‹ã®ã‹ã‚‚ã—ã‚Œãªã„ã€‚)
ãªãŠã€æ•™æˆã¯ãªãœã‹çŒ«ã‚’é€£ã‚Œã¦ (ã‚ã‚‹ã„ã¯çŒ«ã‚’ä½¿ã£ã¦) è¬›ç¾©ã‚’ã—ã¦ã„ã‚‹ã€‚</span>

The professor lectures to the student in the class with the cat.
---- NP ----- -- VP -- ---------- PP ------------- 
---- NP ----- ------ VP -------------------------- ---- PP ----
---- NP ----- ------ VP ---------------------------------------
<span class="ex_comment">ãã®å­¦ç´šã®ãã®å­¦ç”Ÿã«å¯¾ã—ã¦ã€æ•™æˆãŒè¬›ç¾©ã‚’è¡Œã†ã€‚
(ã‚‚ã—ã‹ã—ãŸã‚‰ã€æ­£è¦ã®æˆæ¥­æ™‚é–“å¤–ã«ã€ãã®å­¦ç”Ÿã«å¯¾ã—ã¦ã ã‘ã€è¬›ç¾©ã—ã¦ã‚ã’ã¦
ã„ã‚‹ã®ã‹ã‚‚ã—ã‚Œãªã„ã€‚)
ãªãŠã€æ•™æˆã¯çŒ«ã‚’é€£ã‚Œã¦ (ã‚ã‚‹ã„ã¯çŒ«ã‚’ä½¿ã£ã¦) è¬›ç¾©ã‚’ã—ã¦ã„ã‚‹ã€‚</span>

The professor lectures to the student in the class with the cat.
---- NP ----- -- VP -- ---- PP ------
---- NP ----- ------ VP ------------- ---------- PP -----------
---- NP ----- ------ VP ---------------------------------------
<span class="ex_comment">çŒ«ã‚’ä½¿ã£ãŸãã®æˆæ¥­ã§ã€æ•™æˆãŒå­¦ç”Ÿã«è¬›ç¾©ã™ã‚‹ã€‚
(ãã®æˆæ¥­ç§‘ç›®è‡ªä½“ãŒã€ãªãœã‹çŒ«ã‚’ä½¿ã†ç§‘ç›®ãªã®ã§ã‚ã‚‹ã€‚æ•™æˆãŒæ„›çŒ«å®¶ã§ã‚ã‚‹
ãªã©ã®ç†ç”±ã§æ•™æˆãŒçŒ«ã‚’é€£ã‚Œã¦ããŸã®ã ã¨ã¯é™ã‚‰ãªã„ã€‚)
(ã“ã®æˆæ¥­ã«ç™»éŒ²ã—ã¦ã„ã‚‹å­¦ç”Ÿã¯ãã®ä¸€äººãªã®ã‹ã‚‚ã—ã‚Œãªã„ã—ã€ä»–ã®å­¦ç”ŸãŸã¡ãŒ
ãŸã¾ãŸã¾ä¼‘ã‚“ã§ã„ã‚‹ã®ã‹ã‚‚ã—ã‚Œãªã„ã€‚)</span>

The professor lectures to the student in the class with the cat.
                          ---- NP --- ----- PP ---
                          -------- NP ------------ ---- PP ----
                       p. --------------- NP ------------------
---- NP ----- -- VP -- ------------------ PP ------------------
---- NP ----- ------ VP ---------------------------------------
<span class="ex_comment">çŒ«ã‚’é€£ã‚ŒãŸã€ãã®å­¦ç´šã®ãã®å­¦ç”Ÿã«å¯¾ã—ã¦ã€æ•™æˆãŒè¬›ç¾©ã‚’è¡Œã†ã€‚
(ã‚‚ã—ã‹ã—ãŸã‚‰ã€æ­£è¦ã®æˆæ¥­æ™‚é–“å¤–ã«ã€ãã®å­¦ç”Ÿã«å¯¾ã—ã¦ã ã‘ã€è¬›ç¾©ã—ã¦ã‚ã’ã¦
ã„ã‚‹ã®ã‹ã‚‚ã—ã‚Œãªã„ã€‚)</span>

The professor lectures to the student in the class with the cat.
                          ---- NP --- ---------- PP -----------
                       p. --------------- NP ------------------
---- NP ----- -- VP -- ------------------ PP ------------------
---- NP ----- ------ VP ---------------------------------------
<span class="ex_comment">ãªãœã‹ãã®çŒ«ã¯ãã®å­¦ç´šã®ä¸€å“¡ãªã®ã ãŒã€ãã®ä¸æ€è­°ãª
å­¦ç´šã«å±ã—ã¦ã„ã‚‹ãã®å­¦ç”Ÿã«å¯¾ã—ã¦ã€æ•™æˆãŒè¬›ç¾©ã‚’è¡Œã†ã€‚
(ã‚ã‚‹ã„ã¯ã€çŒ«ã‚’ä½¿ã£ãŸãã®æˆæ¥­ã‚’å–ã£ã¦ã„ã‚‹ãã®å­¦ç”Ÿã«å¯¾ã—ã¦ã€æ•™æˆãŒè¬›ç¾©ã‚’è¡Œã†ã€‚)
(ã©ã¡ã‚‰ã«ã›ã‚ˆã€æ­£è¦ã®æˆæ¥­æ™‚é–“å¤–ã«ã€ãã®å­¦ç”Ÿã«å¯¾ã—ã¦ã ã‘ã€è¬›ç¾©ã—ã¦ã‚ã’ã¦
ã„ã‚‹ã®ã‹ã‚‚ã—ã‚Œãªã„ã€ã¨ã‚‚èª­ã‚ã‚‹ã€‚)
</span></p>

<p class="orig" lang="en">
<a name="%_thm_4.46"></a>
<b>Exercise 4.46.</b>  <a name="%_idx_4970"></a>The evaluators in sections <a href="26_sec4_1.html#%_sec_4.1">4.1</a> and <a href="27_sec4_2.html#%_sec_4.2">4.2</a>
do not determine what order operands are evaluated in.
We will see that the <tt>amb</tt> evaluator evaluates them from left to right.
Explain why our parsing program wouldn't work if the operands were evaluated
in some other order.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ 4.46.</b> <a href="26_sec4_1.html#%_sec_4.1">4.1</a>ç¯€ã¨<a href="27_sec4_2.html#%_sec_4.2">4.2</a>ç¯€ã§ã®è©•ä¾¡å™¨ã¯ã€ã‚ªãƒšãƒ©ãƒ³ãƒ‰ãŒã©ã†ã„ã†é †åºã§è©•ä¾¡ã•ã‚Œã‚‹ã®ã‹ã‚’å®šã‚ãªã„ã€‚
<tt>amb</tt> è©•ä¾¡å™¨ãŒã‚ªãƒšãƒ©ãƒ³ãƒ‰ã‚’å·¦ã‹ã‚‰å³ã¸ã¨è©•ä¾¡ã™ã‚‹ã“ã¨ã‚’ã€ç§ãŸã¡ã¯è¦‹ã‚‹ã ã‚ã†ã€‚
ã‚‚ã—ä½•ã‚‰ã‹ã®åˆ¥ã®é †åºã§ã‚ªãƒšãƒ©ãƒ³ãƒ‰ãŒè©•ä¾¡ã•ã‚Œã‚‹ã®ã§ã‚ã£ãŸã‚‰ã€ç§ãŸã¡ã®æ§‹æ–‡è§£æãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã†ã¾ãå‹•ã‹ãªã„ã§ã‚ã‚ã†ã€ã¨ã„ã†ç†ç”±ã‚’ã€èª¬æ˜ã›ã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_4.47"></a>
<b>Exercise 4.47.</b>  Louis Reasoner suggests that, since a verb phrase is either a verb or
a verb phrase followed by a prepositional phrase, it would be much more
straightforward to define the procedure <tt>parse-verb-phrase</tt> as
follows (and similarly for noun phrases):
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ 4.47.</b> å‹•è©å¥ã¨ã¯ã€å‹•è©ã‹ã€å‹•è©å¥ã¨ãã‚Œã«ç¶šãå‰ç½®è©å¥ã®ã©ã¡ã‚‰ã‹ãªã®ã ã‹ã‚‰ã€ä»¥ä¸‹ã®ã‚ˆã†ãª <tt>parse-verb-phrase</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’å®šç¾©ã™ã‚‹æ–¹ãŒã€ãšã£ã¨åˆ†ã‚Šã‚„ã™ã„ (ã—ã€åè©å¥ã«ã¤ã„ã¦ã‚‚åŒæ§˜ã§ã‚ã‚‹)ã€ã¨ãƒ«ã‚¤ã‚¹ãƒ»ãƒªãƒ¼ã‚ºãƒŠã¯ç¤ºå”†ã™ã‚‹ã€‚
</p>

<p class="lisp">(define (parse-verb-phrase)
  (amb (parse-word verbs)
       (list 'verb-phrase
             (parse-verb-phrase)
             (parse-prepositional-phrase))))
</p>

<p class="orig" lang="en">Does this work?  Does the program's behavior change if we interchange
the order of expressions in the <tt>amb</tt>?
</p>

<p class="trans" lang="ja">
ã“ã‚Œã¯ã†ã¾ãå‹•ãã‹?
ã‚‚ã— <tt>amb</tt> ã®ä¸­ã®å¼ã®é †åºã‚’å…¥ã‚Œæ›¿ãˆãŸã‚‰ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®æŒ¯ã‚‹èˆã„ã¯å¤‰åŒ–ã™ã‚‹ã‹?
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_4.48"></a>
<b>Exercise 4.48.</b>  Extend the grammar given above to handle more complex sentences.  For
example, you could extend noun phrases and verb phrases to include
adjectives and adverbs, or you could handle compound sentences.<a name="call_footnote_Temp_626" href="#footnote_Temp_626"><sup><small>53</small></sup></a>
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ 4.48.</b> ã‚ˆã‚Šè¤‡é›‘ãªæ–‡ã‚’å–ã‚Šæ‰±ã†ã‚ˆã†ã«ã€ä¸Šè¨˜ã®æ–‡æ³•ã‚’æ‹¡å¼µã›ã‚ˆã€‚
ãŸã¨ãˆã°ã€å½¢å®¹è©ã¨å‰¯è©ã‚’å«ã‚€ã‚ˆã†ã«åè©å¥ã¨å‹•è©å¥ã‚’æ‹¡å¼µã§ãã‚‹ã ã‚ã†ã—ã€ã¾ãŸã¯ã€é‡æ–‡ã‚’å–ã‚Šæ‰±ã†ã“ã¨ã‚‚ã§ãã‚‹ã ã‚ã†<a href="#footnote_Temp_626"><sup><small>53</small></sup></a>ã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>


<p class="orig" lang="en">
<a name="%_thm_4.49"></a>
<b>Exercise 4.49.</b>  <a name="%_idx_4976"></a>Alyssa P. Hacker is more interested in generating interesting
sentences than in parsing them.  She reasons that by simply changing
the procedure <tt>parse-word</tt> so that it ignores the ``input
sentence'' and instead always succeeds and generates an appropriate
word, we can use the programs we had built for parsing to do
generation instead.  Implement Alyssa's idea, and show the first
half-dozen or so sentences generated.<a name="call_footnote_Temp_628" href="#footnote_Temp_628"><sup><small>54</small></sup></a>
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ 4.49.</b> ã‚¢ãƒªãƒƒã‚µãƒ»Pãƒ»ãƒãƒƒã‚«ã¯ã€èˆˆå‘³æ·±ã„æ–‡ã‚’æ§‹æ–‡è§£æã™ã‚‹ã“ã¨ã‚ˆã‚Šã‚‚ã€ãã‚Œã‚‰ã‚’ç”Ÿæˆã™ã‚‹ã“ã¨ã®æ–¹ã«èˆˆå‘³ãŒã‚ã‚‹ã€‚
<tt>parse-word</tt> ãŒã€Œå…¥åŠ›æ–‡ã€ã‚’ç„¡è¦–ã™ã‚‹ã‚ˆã†ã«ã€ãã—ã¦ãã®ä»£ã‚ã‚Šã«ã€å¸¸ã«æˆåŠŸã—ã¦ã¯é©åˆ‡ãªèªã‚’ç”Ÿæˆã™ã‚‹ã‚ˆã†ã«ã€å˜ç´”ã« <tt>parse-word</tt> ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ã§ã€æ§‹æ–‡è§£æç”¨ã«æ§‹ç¯‰ã—ãŸãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ä½¿ã£ã¦ã€ä»£ã‚ã‚Šã«ç”Ÿæˆã‚’è¡Œãˆã‚‹ã€ã¨å½¼å¥³ã¯æ¨æ¸¬ã™ã‚‹ã€‚
ã‚¢ãƒªãƒƒã‚µã®è€ƒãˆã‚’å®Ÿè£…ã—ã€ç”Ÿæˆã•ã‚Œã‚‹æœ€åˆã®5ã€œ6å€‹ç¨‹åº¦ã®æ–‡ã‚’ç¤ºã›<a href="#footnote_Temp_628"><sup><small>54</small></sup></a>ã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_4.3.3"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_4.3.3">4.3.3  Implementing the <tt>Amb</tt> Evaluator</a></h3>
<h3 class="trans" lang="ja">4.3.3 <tt>amb</tt> è©•ä¾¡å™¨ã‚’å®Ÿè£…ã™ã‚‹</h3>


<p class="orig" lang="en"><a name="%_idx_4978"></a>
The evaluation of an ordinary Scheme expression may return a value,
may never terminate, or may signal an error.  In nondeterministic
Scheme the evaluation of an expression may in addition result in the
discovery of a dead end, in which case evaluation must backtrack to a previous
choice point.  The interpretation of nondeterministic Scheme is
complicated by this extra case.</p>

<p class="trans" lang="ja">
æ™®é€šã®Schemeã®å¼ã‚’è©•ä¾¡ã™ã‚‹ã¨ã€å€¤ãŒè¿”ã•ã‚Œã‚‹ã“ã¨ã‚‚ã‚ã‚‹ã—ã€æ±ºã—ã¦çµ‚ã‚ã‚‰ãªã„ã“ã¨ã‚‚ã‚ã‚‹ã—ã€ã‚ã‚‹ã„ã¯ã€ã‚¨ãƒ©ãƒ¼ã®åˆå›³ãŒå‡ºã•ã‚Œã‚‹ã“ã¨ã‚‚ã‚ã‚‹ã€‚
éæ±ºå®šçš„ãªSchemeã§ã¯ã€å¼ã®è©•ä¾¡ã¯ã€ãã‚Œã«åŠ ãˆã¦ã€è¡Œãæ­¢ã¾ã‚Šã®ç™ºè¦‹ã«çµ‚ã‚ã‚‹ã“ã¨ã‚‚ã‚ã‚Šã€ãã®å ´åˆã€è©•ä¾¡ã¯å‰ã®é¸æŠç‚¹ã«ãƒãƒƒã‚¯ãƒˆãƒ©ãƒƒã‚¯ã›ã­ã°ãªã‚‰ãªã„ã€‚
éæ±ºå®šçš„ãªSchemeã®è§£é‡ˆã¯ã€ã“ã®è¿½åŠ çš„ãªå ´åˆã«ã‚ˆã£ã¦è¤‡é›‘åŒ–ã—ã¦ã„ã‚‹ã€‚
</p>


<p class="orig" lang="en">
<a name="%_idx_4980"></a>We will construct the <tt>amb</tt> evaluator for nondeterministic Scheme
by modifying the analyzing evaluator of section <a href="26_sec4_1.html#%_sec_4.1.7">4.1.7</a>.<a name="call_footnote_Temp_629" href="#footnote_Temp_629"><sup><small>55</small></sup></a>
As in the analyzing evaluator, evaluation of an expression is
accomplished by calling an <a name="%_idx_4982"></a>execution procedure produced by analysis of
that expression.  The difference between the interpretation of ordinary
Scheme and the interpretation of nondeterministic Scheme will be entirely
in the execution procedures.</p>

<p class="trans" lang="ja">
<a href="26_sec4_1.html#%_sec_4.1.7">4.1.7</a>ç¯€ã®ã€è§£æã‚’è¡Œã†è©•ä¾¡å™¨ã‚’æ”¹å¤‰ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€éæ±ºå®šçš„ãªSchemeç”¨ã® <tt>amb</tt> è©•ä¾¡å™¨ã‚’æ§‹ç¯‰ã—ã‚ˆã†<a href="#footnote_Temp_629"><sup><small>55</small></sup></a>ã€‚
è§£æã‚’è¡Œã†è©•ä¾¡å™¨ã«ãŠã‘ã‚‹ã®ã¨åŒæ§˜ã«ã€å¼ã®è©•ä¾¡ã¯ã€ãã®å¼ã®è§£æã«ã‚ˆã£ã¦ç”Ÿã¿å‡ºã•ã‚Œã‚‹å®Ÿè¡Œæ‰‹ç¶šãã‚’å‘¼ã³å‡ºã™ã“ã¨ã«ã‚ˆã£ã¦ã€é”æˆã•ã‚Œã‚‹ã€‚
æ™®é€šã®Schemeã®è§£é‡ˆã¨éæ±ºå®šçš„ãªSchemeã®è§£é‡ˆã¨ã®é•ã„ã¯ã€ã‚‚ã£ã±ã‚‰å®Ÿè¡Œæ‰‹ç¶šãã®ä¸­ã«ã‚ã‚‹ã ã‚ã†ã€‚
</p>

<a name="%_sec_Temp_630"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_630">Execution procedures and continuations</a></h4>
<h4 class="trans" lang="ja">å®Ÿè¡Œæ‰‹ç¶šãã¨ç¶™ç¶š</h4>


<p class="orig" lang="en">
<a name="%_idx_4984"></a>
<a name="%_idx_4986"></a>Recall that the execution procedures for the ordinary evaluator take
one argument: the environment of execution.  In contrast, the
execution procedures in the <tt>amb</tt> evaluator take three arguments:
the environment, and two procedures called <em>continuation
procedures</em>.  The evaluation of an expression will finish by calling
one of these two continuations: If the evaluation results in a value,
the <a name="%_idx_4988"></a><em>success continuation</em> is called with that value; if the
evaluation results in the discovery of a dead end, the <a name="%_idx_4990"></a><em>failure
continuation</em> is called.  Constructing and calling appropriate
continuations is the mechanism by which the nondeterministic evaluator
implements backtracking.</p>

<p class="trans" lang="ja">
é€šå¸¸ã®è©•ä¾¡å™¨ç”¨ã®å®Ÿè¡Œæ‰‹ç¶šããŒä¸€ã¤ã®å¼•æ•°â€”â€”ã™ãªã‚ã¡å®Ÿè¡Œã®ç’°å¢ƒâ€”â€”ã‚’ã¨ã‚‹ã“ã¨ã‚’æ€ã„å‡ºãã†ã€‚
å¯¾ç…§çš„ã«ã€<tt>amb</tt> è©•ä¾¡å™¨ã®å®Ÿè¡Œæ‰‹ç¶šãã¯ã€ä¸‰ã¤ã®å¼•æ•°â€”â€”ã™ãªã‚ã¡ã€ç’°å¢ƒã¨ã€<em>ç¶™ç¶šæ‰‹ç¶šã</em>ã¨å‘¼ã°ã‚Œã‚‹äºŒã¤ã®æ‰‹ç¶šãâ€”â€”ã‚’ã¨ã‚‹ã€‚
å¼ã®è©•ä¾¡ã¯ã€ã“ã‚Œã‚‰äºŒã¤ã®ç¶™ç¶šã®ã†ã¡ã®ä¸€ã¤ã‚’å‘¼ã³å‡ºã™ã“ã¨ã§ã€å®Œäº†ã™ã‚‹ã ã‚ã†ã€‚
ã‚‚ã—ã€ãã®è©•ä¾¡ãŒå€¤ã¨ã„ã†çµæœã«çµ‚ã‚ã‚Œã°ã€<em>æˆåŠŸç¶™ç¶š</em>ãŒãã®å€¤ã¨ã¨ã‚‚ã«å‘¼ã³å‡ºã•ã‚Œã‚‹ã€‚
ã‚‚ã—ã€ãã®è©•ä¾¡ãŒè¡Œãæ­¢ã¾ã‚Šã®ç™ºè¦‹ã¨ã„ã†çµæœã«çµ‚ã‚ã‚Œã°ã€<em>å¤±æ•—ç¶™ç¶š</em>ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ã€‚
é©åˆ‡ãªç¶™ç¶šã‚’æ§‹ç¯‰ã—ã¦å‘¼ã³å‡ºã™ã“ã¨ãŒã€éæ±ºå®šçš„ãªè©•ä¾¡å™¨ãŒãƒãƒƒã‚¯ãƒˆãƒ©ãƒƒã‚¯ã‚’å®Ÿè£…ã™ã‚‹ã®ã«ä½¿ã†ä»•çµ„ã¿ãªã®ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
It is the job of the success continuation to receive a value and
proceed with the computation.  Along with that value, the success
continuation is passed another failure continuation, which is to be
called subsequently if the use of that value leads to a dead end.</p>

<p class="trans" lang="ja">
å€¤ã‚’å—ã‘å–ã£ã¦è¨ˆç®—ã‚’ç¶šã‘ã‚‹ã“ã¨ã¯ã€æˆåŠŸç¶™ç¶šã®ä»•äº‹ã§ã‚ã‚‹ã€‚
ãã®å€¤ã¨ä¸€ç·’ã«æˆåŠŸç¶™ç¶šã¯åˆ¥ã®å¤±æ•—ç¶™ç¶šã¸ã¨æ¸¡ã•ã‚Œã‚‹ã®ã ãŒã€ãã®å¤±æ•—ç¶™ç¶šã¨ã¯ã€ã‚‚ã—ãã®å€¤ã‚’ä½¿ã†ã“ã¨ãŒè¡Œãæ­¢ã¾ã‚Šã«ç¹‹ãŒã‚‹ãªã‚‰ã°ã€å¾Œã«å‘¼ã°ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã¯ãšã®ã‚‚ã®ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
It is the job of the failure continuation to try another branch of the
nondeterministic process.  The essence of the nondeterministic
language is in the fact that expressions may represent choices among
alternatives.  The evaluation of such an expression must proceed with
one of the indicated alternative choices, even though it is not known
in advance which choices will lead to acceptable results.  To deal
with this, the evaluator picks one of the alternatives and passes this
value to the success continuation.  Together with this value, the
evaluator constructs and passes along a failure continuation that can
be called later to choose a different alternative.</p>

<p class="trans" lang="ja">
éæ±ºå®šçš„ãƒ—ãƒ­ã‚»ã‚¹ã®åˆ¥ã®åˆ†å²ã‚’è©¦ã—ã¦ã¿ã‚‹ã“ã¨ãŒã€å¤±æ•—ç¶™ç¶šã®ä»•äº‹ã§ã‚ã‚‹ã€‚
éæ±ºå®šçš„è¨€èªã®æœ¬è³ªã¯ã€å¼ãŒé¸æŠè‚¢ã®é–“ã§ã®é¸æŠã‚’è¡¨ã—ã¦ã„ã‚‹ã®ã‹ã‚‚ã—ã‚Œãªã„ã€ã¨ã„ã†äº‹å®Ÿã«ã‚ã‚‹ã€‚
ãã†ã—ãŸå¼ã®è©•ä¾¡ã¯ã€ç¤ºã•ã‚ŒãŸä»£æ›¿é¸æŠè‚¢ã®ã†ã¡ã®ä¸€ã¤ã‚’ç¶šè¡Œã—ãªãã¦ã¯ãªã‚‰ãªã„â€”â€”ã©ã®é¸æŠè‚¢ãŒè¨±å®¹å¯èƒ½ãªçµæœã«è‡³ã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ãŒã€ãŸã¨ãˆäº‹å‰ã«ã¯çŸ¥ã‚‰ã‚Œã¦ã„ãªãã¦ã‚‚ã§ã‚ã‚‹ã€‚
ã“ã‚Œã‚’å–ã‚Šæ‰±ã†ãŸã‚ã«ã€è©•ä¾¡å™¨ã¯ã€é¸æŠè‚¢ã®ã†ã¡ã®ä¸€ã¤ã‚’é¸ã‚“ã§ã€ã“ã®å€¤ã‚’æˆåŠŸç¶™ç¶šã«æ¸¡ã™ã€‚
ã“ã®å€¤ã¨ä¸€ç·’ã«ã€è©•ä¾¡å™¨ã¯ã€åˆ¥ã®é¸æŠè‚¢ã‚’é¸ã¶ãŸã‚ã«å¾Œã§å‘¼ã°ã‚Œã‚‹å¯èƒ½æ€§ã®ã‚ã‚‹å¤±æ•—ç¶™ç¶šã‚’ã€æ§‹ç¯‰ã—ã€ã‹ã¤ã€æ¸¡ã™ã€‚
</p>

<p class="orig" lang="en">
A failure is triggered during evaluation (that is, a failure
continuation is called) when a user program explicitly rejects the
current line of attack (for example, a call to <tt>require</tt> may
result in execution of <tt>(amb)</tt>, an expression that always
fails -- see section <a href="#%_sec_4.3.1">4.3.1</a>).  The failure continuation in hand
at that point will cause the most recent choice point to choose
another alternative.  If there are no more alternatives to be
considered at that choice point, a failure at an earlier choice point
is triggered, and so on.  Failure continuations are also invoked by
the driver loop in response to a <tt>try-again</tt> request, to find
another value of the expression.</p>

<p class="trans" lang="ja">
ç¾åœ¨ã®å–ã‚Šçµ„ã¿ã®è·¯ç·šã‚’ãƒ¦ãƒ¼ã‚¶ãƒ»ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒæ˜ç¤ºçš„ã«æ‹’çµ¶ã™ã‚‹ã¨ (ãŸã¨ãˆã°ã€<tt>require</tt> ã®å‘¼ã³å‡ºã—ã¯ã€<tt>(amb)</tt> â€”â€”ã™ãªã‚ã¡å¸¸ã«å¤±æ•—ã™ã‚‹å¼â€”â€”ã®å®Ÿè¡Œã¨ã„ã†çµæœã«ãªã‚‹ã“ã¨ãŒã‚ã‚‹ã€‚<a href="#%_sec_4.3.1">4.3.1</a>ç¯€ã‚’å‚ç…§)ã€è©•ä¾¡ä¸­ã«å¤±æ•—ã®å¼•ãé‡‘ãŒå¼•ã‹ã‚Œã‚‹ (ã¤ã¾ã‚Šã€å¤±æ•—ç¶™ç¶šãŒå‘¼ã³å‡ºã•ã‚Œã‚‹)ã€‚
ãã®æ™‚ç‚¹ã§æ‰‹ä¸­ã«ã‚ã‚‹å¤±æ•—ç¶™ç¶šã¯ã€ç›´è¿‘ã®é¸æŠç‚¹ã«åˆ¥ã®é¸æŠè‚¢ã‚’é¸ã°ã›ã‚‹ã“ã¨ã ã‚ã†ã€‚
ã‚‚ã—ã€ãã®é¸æŠç‚¹ã§è€ƒæ…®ã™ã¹ãé¸æŠè‚¢ãŒãã‚Œä»¥ä¸Šãªã‘ã‚Œã°ã€ã‚ˆã‚Šæ—©ã„é¸æŠç‚¹ã§ã®å¤±æ•—ã®å¼•ãé‡‘ãŒå¼•ã‹ã‚Œã€ä»¥ä¸‹åŒæ§˜ã§ã‚ã‚‹ã€‚
å¤±æ•—ç¶™ç¶šã¯ã€å¼ã®åˆ¥ã®å€¤ã‚’è¦‹ã¤ã‘ã‚‹ãŸã‚ã«ã€<tt>try-again</tt> ã®è¦æ±‚ã«å¿œãˆã¦ãƒ‰ãƒ©ã‚¤ãƒãƒ»ãƒ«ãƒ¼ãƒ—ã«ã‚ˆã£ã¦ã‚‚å‘¼ã³å‡ºã•ã‚Œã‚‹ã€‚
</p>

<p class="orig" lang="en">
In addition, if a side-effect operation (such as assignment to a
variable) occurs on a branch of the process resulting from a choice,
it may be necessary, when the process finds a dead end, to undo the
side effect before making a new choice.  This is accomplished by
having the side-effect operation produce a failure continuation that
undoes the side effect and propagates the failure.</p>

<p class="trans" lang="ja">
ã•ã‚‰ã«ã€é¸æŠã®çµæœã¨ã—ã¦èµ·ã“ã‚‹ã€ãƒ—ãƒ­ã‚»ã‚¹ã®ã‚ã‚‹åˆ†å²ä¸Šã§ã€(å¤‰æ•°ã¸ã®<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ãªã©ã¨ã„ã£ãŸ) å‰¯ä½œç”¨ã¤ãæ¼”ç®—ãŒèµ·ã“ã‚‹ã¨ã€ãã®ãƒ—ãƒ­ã‚»ã‚¹ãŒè¡Œãæ­¢ã¾ã‚Šã‚’è¦‹ã¤ã‘ãŸã¨ãã«ã¯ã€æ–°ãŸãªé¸æŠã‚’è¡Œã†å‰ã«ãã®å‰¯ä½œç”¨ã‚’å–ã‚Šæ¶ˆã™ã“ã¨ãŒå¿…è¦ã«ãªã‚‹å ´åˆãŒã‚ã‚‹ã€‚
ã“ã‚Œã¯ã€å‰¯ä½œç”¨ã‚’å–ã‚Šæ¶ˆã—ã¦å¤±æ•—ã‚’ä¼æ’­ã•ã›ã‚‹ã‚ˆã†ãªå¤±æ•—ç¶™ç¶šã‚’ã€ãã®å‰¯ä½œç”¨ã¤ãæ¼”ç®—ã«ä½œã‚Šå‡ºã•ã›ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€é”æˆã•ã‚Œã‚‹ã€‚
</p>

<p class="orig" lang="en">
In summary, failure continuations are constructed by
</p>

<p class="trans" lang="ja">
ã¤ã¾ã‚Šã€å¤±æ•—ç¶™ç¶šã¯ä»¥ä¸‹ã®ã‚‚ã®ã«ã‚ˆã‚Šæ§‹ç¯‰ã•ã‚Œã‚‹ã€‚
</p>

<ul class="orig" lang="en">
<li><tt>amb</tt> expressions -- to provide a mechanism to make
alternative choices if the current choice made by the <tt>amb</tt>
expression leads to a dead end;</li>

<li>the top-level driver -- to provide a mechanism to report failure
when the choices are exhausted;</li>

<li>assignments -- to intercept failures and undo assignments
during backtracking.</li>
</ul>

<ul class="trans" lang="ja">
<li><tt>amb</tt> å¼ã«ã‚ˆã‚‹â€”â€”å½“è©² <tt>amb</tt> å¼ã«ã‚ˆã‚Šãªã•ã‚ŒãŸç¾åœ¨ã®é¸æŠãŒè¡Œãæ­¢ã¾ã‚Šã«è‡³ã£ãŸã‚‰ã€åˆ¥ã®é¸æŠã‚’è¡Œã†ä»•çµ„ã¿ã‚’ã€æä¾›ã™ã‚‹ãŸã‚ã§ã‚ã‚‹ã€‚</li>
<li>ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ãƒ»ãƒ‰ãƒ©ã‚¤ãƒã«ã‚ˆã‚‹â€”â€”é¸æŠè‚¢ãŒå°½ããŸã¨ãã«å¤±æ•—ã‚’å ±å‘Šã™ã‚‹ä»•çµ„ã¿ã‚’æä¾›ã™ã‚‹ãŸã‚ã§ã‚ã‚‹ã€‚</li>
<li><ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã«ã‚ˆã‚‹â€”â€”ãƒãƒƒã‚¯ãƒˆãƒ©ãƒƒã‚¯ã®æœ€ä¸­ã«å¤±æ•—ã‚’æ¨ªå–ã‚Šã—ã¦<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã‚’å–ã‚Šæ¶ˆã™ãŸã‚ã§ã‚ã‚‹ã€‚</li>
</ul>

<p class="orig" lang="en">
Failures are initiated only when a dead end is encountered.
This occurs
</p>

<p class="trans" lang="ja">
å¤±æ•—ã¯ã€è¡Œãæ­¢ã¾ã‚Šã«é­é‡ã—ãŸã¨ãã«ã®ã¿ã€é–‹å§‹ã•ã‚Œã‚‹ã€‚
ã“ã‚Œã¯ã€æ¬¡ã®å ´åˆã«èµ·ã“ã‚‹ã€‚
</p>

<ul class="orig" lang="en">
<li>if the user program executes <tt>(amb)</tt>;</li>
<li>if the user types <tt>try-again</tt> at the top-level driver.</li>
</ul>

<ul class="trans" lang="ja">
<li>ãƒ¦ãƒ¼ã‚¶ãƒ»ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒ <tt>(amb)</tt> ã‚’å®Ÿè¡Œã™ã‚‹ã¨ãã€‚</li>
<li>ãƒ¦ãƒ¼ã‚¶ãŒãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ãƒ»ãƒ‰ãƒ©ã‚¤ãƒã«ãŠã„ã¦ <tt>try-again</tt> ã¨æ‰“ã¤ã¨ãã€‚</li>
</ul>

<p class="orig" lang="en">
Failure continuations are also called during processing of a failure:
</p>

<p class="trans" lang="ja">
å¤±æ•—ç¶™ç¶šã¯ã€å¤±æ•—ã®å‡¦ç†ä¸­ã«ã‚‚å‘¼ã°ã‚Œã‚‹ã€‚
</p>


<ul class="orig" lang="en">
<li>When the failure continuation created by an assignment finishes
undoing a side effect, it calls the failure continuation it intercepted,
in order to propagate the failure back to the choice point that
led to this assignment or to the top level.</li>

<li>When the failure continuation for an <tt>amb</tt> runs out of choices,
it calls the failure continuation that was originally given to the <tt>amb</tt>,
in order to propagate the failure back to the previous choice point
or to the top level.</li>
</ul>


<ul class="trans" lang="ja">
<li><ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã«ã‚ˆã‚Šä½œæˆã•ã‚ŒãŸå¤±æ•—ç¶™ç¶šã¯ã€å‰¯ä½œç”¨ã®å–ã‚Šæ¶ˆã—ã‚’å®Œäº†ã™ã‚‹ã¨ã€ã“ã®<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã«ã¤ãªãŒã£ãŸé¸æŠç‚¹ã¾ãŸã¯ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã¸ã¨é€†æ–¹å‘ã«å¤±æ•—ã‚’ä¼æ’­ã•ã›ã‚‹ãŸã‚ã«ã€è‡ªåˆ†ãŒæ¨ªå–ã‚Šã—ãŸå¤±æ•—ç¶™ç¶šã‚’å‘¼ã³å‡ºã™ã€‚</li>
<li><tt>amb</tt> ã®ãŸã‚ã®å¤±æ•—ç¶™ç¶šã¯ã€é¸æŠè‚¢ã‚’ä½¿ã„å°½ãã—ãŸå ´åˆã«ã¯ã€å‰ã®é¸æŠç‚¹ã¾ãŸã¯ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã¸ã¨é€†æ–¹å‘ã«å¤±æ•—ã‚’ä¼æ’­ã•ã›ã‚‹ãŸã‚ã«ã€å½“è©² <tt>amb</tt> ã«å…ƒã€…ä¸ãˆã‚‰ã‚Œã¦ã„ãŸå¤±æ•—ç¶™ç¶šã‚’å‘¼ã³å‡ºã™ã€‚</li>
</ul>

<a name="%_sec_Temp_631"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_631">Structure of the evaluator</a></h4>
<h4 class="trans" lang="ja">è©•ä¾¡å™¨ã®æ§‹é€ </h4>


<p class="orig" lang="en">
<a name="%_idx_4992"></a>The syntax- and data-representation procedures for the <tt>amb</tt>
evaluator, and also the basic <tt>analyze</tt> procedure, are identical
to those in the evaluator of section <a href="26_sec4_1.html#%_sec_4.1.7">4.1.7</a>,
except for the fact that we need additional syntax procedures to
recognize the <tt>amb</tt> special form:<a name="call_footnote_Temp_632" href="#footnote_Temp_632"><sup><small>56</small></sup></a>
</p>

<p class="trans" lang="ja">
<tt>amb</tt> è©•ä¾¡å™¨ç”¨ã®æ–‡æ³•è¡¨ç¾æ‰‹ç¶šãã¨ãƒ‡ãƒ¼ã‚¿è¡¨ç¾æ‰‹ç¶šãã¨ã€ãã—ã¦ã¾ãŸåŸºç¤çš„ãª <tt>analyze</tt> æ‰‹ç¶šãã¯ã€<tt>amb</tt> ã®ç‰¹æ®Šå½¢å¼ã‚’èªè­˜ã™ã‚‹ãŸã‚ã®ä»˜åŠ çš„ãªæ–‡æ³•æ‰‹ç¶šããŒå¿…è¦ã ã¨ã„ã†äº‹å®Ÿã‚’é™¤ã„ã¦ã€<a href="26_sec4_1.html#%_sec_4.1.7">4.1.7</a>ç¯€ã®è©•ä¾¡å™¨ã§ã®ã‚‚ã®ã¨åŒä¸€ã§ã‚ã‚‹<a href="#footnote_Temp_632"><sup><small>56</small></sup></a>ã€‚
</p>

<p class="lisp">(define (amb? exp) (tagged-list? exp 'amb))
(define (amb-choices exp) (cdr exp))
</p>

<p class="orig" lang="en">We must also add to the dispatch in <tt>analyze</tt> a clause that will
recognize this special form and generate an appropriate execution procedure:</p>

<p class="trans" lang="ja">
ã¾ãŸã€ã“ã®ç‰¹æ®Šå½¢å¼ã‚’èªè­˜ã—ã¦é©åˆ‡ãªå®Ÿè¡Œæ‰‹ç¶šãã‚’ç”Ÿæˆã™ã‚‹ç¯€ã‚’ã€<tt>analyze</tt> ã«ãŠã‘ã‚‹æŒ¯ã‚Šåˆ†ã‘ã«è¿½åŠ ã›ã­ã°ãªã‚‰ãªã„ã€‚
</p>

<p class="lisp">((amb? exp) (analyze-amb exp))
</p>

<p class="orig" lang="en">
The top-level procedure <tt>ambeval</tt> (similar to the version of <tt>eval</tt> given in section <a href="26_sec4_1.html#%_sec_4.1.7">4.1.7</a>) analyzes the
given expression and applies the resulting execution procedure to the
given environment, together with two given continuations:</p>

<p class="trans" lang="ja">
<tt>ambeval</tt> ã¨ã„ã†ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã®æ‰‹ç¶šã (<a href="26_sec4_1.html#%_sec_4.1.7">4.1.7</a>ç¯€ã§ä¸ãˆã‚‰ã‚ŒãŸãƒãƒ¼ã‚¸ãƒ§ãƒ³ã® <tt>eval</tt> ã¨é¡ä¼¼ã®ã‚‚ã®) ãŒã€ä¸ãˆã‚‰ã‚ŒãŸå¼ã‚’è§£æã—ã€çµæœã¨ã—ã¦ç”Ÿã˜ã‚‹å®Ÿè¡Œæ‰‹ç¶šãã‚’ã€äºŒã¤ã®ä¸ãˆã‚‰ã‚ŒãŸç¶™ç¶šã¨ä¸€ç·’ã«ãªã£ã¦ã„ã‚‹ã€ä¸ãˆã‚‰ã‚ŒãŸç’°å¢ƒã¸ã¨é©ç”¨ã™ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_4994"></a>(define (ambeval exp env succeed fail)
  ((analyze exp) env succeed fail))
</p>

<p class="orig" lang="en">
<a name="%_idx_4996"></a><a name="%_idx_4998"></a><a name="%_idx_5000"></a>A success continuation is a procedure of two arguments: the value just
obtained and another failure continuation to be used if that value leads
to a subsequent failure. A failure continuation is a procedure of no
arguments.  So <a name="%_idx_5002"></a>the general form of an execution procedure is</p>

<p class="trans" lang="ja">
æˆåŠŸç¶™ç¶šã¯ã€2å¼•æ•°ã®â€”â€”ã¤ã¾ã‚Šã€ã¡ã‚‡ã†ã©å¾—ã‚‰ã‚ŒãŸå€¤ã¨ã€ã‚‚ã—ãã®å€¤ãŒå¾Œã®å¤±æ•—ã«ã¤ãªãŒã£ãŸã‚‰ä½¿ã‚ã‚Œã‚‹ã¹ãåˆ¥ã®å¤±æ•—ç¶™ç¶šã¨ã‚’ã¨ã‚‹â€”â€”æ‰‹ç¶šãã§ã‚ã‚‹ã€‚
å¤±æ•—ç¶™ç¶šã¯ã€å¼•æ•°ã®ãªã„æ‰‹ç¶šãã§ã‚ã‚‹ã€‚
ã‚ˆã£ã¦ã€å®Ÿè¡Œæ‰‹ç¶šãã®ä¸€èˆ¬å½¢ã¯ä»¥ä¸‹ã®ã¨ãŠã‚Šã§ã‚ã‚‹ã€‚
</p>

<p class="lisp">(lambda (env succeed fail)
  <em>;; <tt>succeed</tt> is <tt>(lambda (value fail) <tt>...</tt>)</tt></em>
  <em>;; <tt>fail</tt> is <tt>(lambda () <tt>...</tt>)</tt></em>
  <tt>...</tt>)
</p>

<p class="orig" lang="en">
For example, executing</p>

<p class="trans" lang="ja">
ãŸã¨ãˆã°ã€ä»¥ä¸‹ã®ã‚‚ã®ã‚’å®Ÿè¡Œã™ã‚‹ã¨ã€
</p>

<p class="lisp">(ambeval &lt;<em>exp</em>&gt;
         the-global-environment
         (lambda (value fail) value)
         (lambda () 'failed))
</p>

<p class="orig" lang="en">will attempt to evaluate the given expression and will return
either the expression's value (if the evaluation succeeds) or
the symbol <tt>failed</tt> (if the evaluation fails).
The call to <tt>ambeval</tt> in the driver loop shown below uses
much more complicated continuation procedures, which continue the
loop and support the <tt>try-again</tt> request.</p>

<p class="trans" lang="ja">
ä¸ãˆã‚‰ã‚ŒãŸå¼ã‚’è©•ä¾¡ã—ã‚ˆã†ã¨ã—ã€ãã—ã¦ã€ãã®å¼ã®å€¤ã‚’è¿”ã™ (è©•ä¾¡ãŒæˆåŠŸã—ãŸå ´åˆ) ã‹ã€ã‚‚ã—ãã¯ã€<tt>failed</tt> ã¨ã„ã†è¨˜å·ã‚’è¿”ã™ (è©•ä¾¡ãŒå¤±æ•—ã—ãŸå ´åˆ) ã ã‚ã†ã€‚
ä»¥ä¸‹ã«ç¤ºã™ã€ãƒ‰ãƒ©ã‚¤ãƒãƒ»ãƒ«ãƒ¼ãƒ—å†…ã§ã® <tt>ambeval</tt> ã®å‘¼ã³å‡ºã—ã¯ã€ã‚‚ã£ã¨ãšã£ã¨å…¥ã‚Šçµ„ã‚“ã ç¶™ç¶šæ‰‹ç¶šãâ€”â€”ãƒ«ãƒ¼ãƒ—ã‚’ç¶šã‘ã¦ <tt>try-again</tt> ã®è¦æ±‚ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹â€”â€”ã‚’ä½¿ã£ã¦ã„ã‚‹ã€‚
</p>

<p class="orig" lang="en">
Most of the complexity of the <tt>amb</tt> evaluator results
from the mechanics of passing the continuations around as the
execution procedures call each other.  In going through the following code,
you should compare each of the execution procedures with the
corresponding procedure for the ordinary evaluator given in
section <a href="26_sec4_1.html#%_sec_4.1.7">4.1.7</a>.</p>

<p class="trans" lang="ja">
<tt>amb</tt> è©•ä¾¡å™¨ã®è¤‡é›‘ã•ã®ã»ã¨ã‚“ã©ã¯ã€å®Ÿè¡Œæ‰‹ç¶šããŒãŠäº’ã„ã‚’å‘¼ã³å‡ºã™ã®ã«é€£ã‚Œã¦ç¶™ç¶šã‚’æ¸¡ã™æ‰‹é †ã«èµ·å› ã™ã‚‹ã€‚
ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã‚’è©³ã—ãæ¤œè¨ã™ã‚‹éš›ã«ã€å›ã¯ã€å®Ÿè¡Œæ‰‹ç¶šãã®å„ã€…ã‚’ã€<a href="26_sec4_1.html#%_sec_4.1.7">4.1.7</a>ç¯€ã§ä¸ãˆã‚‰ã‚ŒãŸé€šå¸¸ã®è©•ä¾¡å™¨ã®ãŸã‚ã®ã€å¯¾å¿œã™ã‚‹æ‰‹ç¶šãã¨ã€æ¯”è¼ƒã™ã¹ãã§ã‚ã‚‹ã€‚
</p>

<a name="%_sec_Temp_633"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_633">Simple expressions</a></h4>
<h4 class="trans" lang="ja">å˜ç´”ãªå¼</h4>


<p class="orig" lang="en">
The execution procedures for the simplest kinds of expressions are
essentially the same as those for the ordinary evaluator, except for the
need to manage the continuations.  The execution procedures simply
succeed with the value of the expression, passing along the failure
continuation that was passed to them.</p>

<p class="trans" lang="ja">
ã‚‚ã£ã¨ã‚‚å˜ç´”ãªç¨®é¡ã®å¼ã®ãŸã‚ã®å®Ÿè¡Œæ‰‹ç¶šãã¯ã€ç¶™ç¶šã‚’ç®¡ç†ã™ã‚‹å¿…è¦æ€§ã‚’é™¤ã‘ã°ã€é€šå¸¸ã®è©•ä¾¡å™¨ç”¨ã®ã‚‚ã®ã¨æœ¬è³ªçš„ã«åŒã˜ã§ã‚ã‚‹ã€‚
å®Ÿè¡Œæ‰‹ç¶šãã¯ã€è‡ªåˆ†ã«æ¸¡ã•ã‚ŒãŸå¤±æ•—ç¶™ç¶šã‚’å—ã‘æ¸¡ã—ã¤ã¤ã‚‚ã€å˜ã«å¼ã®å€¤ã¨ã¨ã‚‚ã«æˆåŠŸã™ã‚‹ã ã‘ã§ã‚ã‚‹ã€‚
</p>

<a name="%_idx_5004"></a>
<p class="lisp">(define (analyze-self-evaluating exp)
  (lambda (env succeed fail)
    (succeed exp fail)))
(define (analyze-quoted exp)
  (let ((qval (text-of-quotation exp)))
    (lambda (env succeed fail)
      (succeed qval fail))))
(define (analyze-variable exp)
  (lambda (env succeed fail)
    (succeed (lookup-variable-value exp env)
             fail)))
(define (analyze-lambda exp)
  (let ((vars (lambda-parameters exp))
        (bproc (analyze-sequence (lambda-body exp))))
    (lambda (env succeed fail)
      (succeed (make-procedure vars bproc env)
               fail))))
</p>

<p class="orig" lang="en">
<a name="%_idx_5006"></a>Notice that looking up a variable always ``succeeds.''  If <tt>lookup-variable-value</tt> fails to find the variable, it signals an
error, as usual.  Such a ``failure'' indicates a program bug -- a
reference to an unbound variable; it is not an indication that we
should try another nondeterministic choice instead of the one that is
currently being tried.</p>

<p class="trans" lang="ja">
å¤‰æ•°ã‚’èª¿ã¹ã‚‹ã“ã¨ãŒå¸¸ã«ã€ŒæˆåŠŸã™ã‚‹ã€ã“ã¨ã«æ³¨æ„ã—ã¦ã»ã—ã„ã€‚
<tt>lookup-variable-value</tt> ã¯ã€ã‚‚ã—å¤‰æ•°ã‚’è¦‹ã¤ã‘ã‚‰ã‚Œãªã‘ã‚Œã°ã€é€šå¸¸ã©ãŠã‚Šã€ã‚¨ãƒ©ãƒ¼ã®åˆå›³ã‚’ã‚ˆã“ã™ã€‚
ãã†ã—ãŸã€Œå¤±æ•—ã€ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ãƒã‚°â€”â€”æŸç¸›ã•ã‚Œã¦ã„ãªã„å¤‰æ•°ã¸ã®å‚ç…§â€”â€”ã‚’ç¤ºã™ãŒã€ã“ã‚Œã¯ã€ç¾åœ¨è©¦ã—ã¦ã„ã‚‹ã‚‚ã®ã®ä»£ã‚ã‚Šã«åˆ¥ã®éæ±ºå®šçš„é¸æŠè‚¢ã‚’è©¦ã™ã¹ãã§ã‚ã‚‹ã€ã¨ã„ã†<ruby><rb>å¾´</rb><rp> (</rp><rt>ã—ã‚‹ã—</rt><rp>) </rp></ruby>ã§ã¯ãªã„ã€‚
</p>

<a name="%_sec_Temp_634"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_634">Conditionals and sequences</a></h4>
<h4 class="trans" lang="ja">æ¡ä»¶å¼ã¨åˆ—</h4>


<p class="orig" lang="en">
Conditionals are also handled in a similar way as in the ordinary
evaluator.  The execution procedure generated by <tt>analyze-if</tt>
invokes the predicate execution procedure <tt>pproc</tt> with a success
continuation that checks whether the predicate value is true and goes
on to execute either the consequent or the alternative.  If the
execution of <tt>pproc</tt> fails, the original failure continuation for
the <tt>if</tt> expression is called.</p>

<p class="trans" lang="ja">
æ¡ä»¶å¼ã‚‚ã€æ™®é€šã®è©•ä¾¡å™¨ã«ãŠã‘ã‚‹æ–¹æ³•ã¨åŒæ§˜ãªæ–¹æ³•ã§æ‰±ã‚ã‚Œã‚‹ã€‚
<tt>analyze-if</tt> ã«ã‚ˆã‚Šç”Ÿæˆã•ã‚Œã‚‹å®Ÿè¡Œæ‰‹ç¶šãã¯ã€<tt>pproc</tt> ã¨ã„ã†è¿°èªå®Ÿè¡Œæ‰‹ç¶šãã‚’ã€è¿°èªã®å€¤ãŒçœŸã‹ã©ã†ã‹ã‚’èª¿ã¹ã‚‹æˆåŠŸç¶™ç¶šã¨ã¨ã‚‚ã«å‘¼ã³å‡ºã—ã¦ã€ãã‚Œã«ç¶šã‘ã¦ã€å¸°çµå¼ã¾ãŸã¯ä»£æ›¿å¼ã®ã„ãšã‚Œã‹ã‚’å®Ÿè¡Œã™ã‚‹ã€‚
ã‚‚ã— <tt>pproc</tt> ã®å®Ÿè¡ŒãŒå¤±æ•—ã—ãŸã‚‰ã€<tt>if</tt> å¼ã«å¯¾ã™ã‚‹å…ƒã®å¤±æ•—ç¶™ç¶šãŒå‘¼ã°ã‚Œã‚‹ã€‚
</p>

<p class="lisp">(define (analyze-if exp)
  (let ((pproc (analyze (if-predicate exp)))
        (cproc (analyze (if-consequent exp)))
        (aproc (analyze (if-alternative exp))))
    (lambda (env succeed fail)
      (pproc env
             <em>;; success continuation for evaluating the predicate</em>
             <em>;; to obtain <tt>pred-value</tt></em>
             (lambda (pred-value fail2)
               (if (true? pred-value)
                   (cproc env succeed fail2)
                   (aproc env succeed fail2)))
             <em>;; failure continuation for evaluating the predicate</em>
             fail))))
</p>


<p class="orig" lang="en">
Sequences are also handled in the same way as in the previous
evaluator, except for the machinations in the subprocedure <tt>sequentially</tt> that are required for passing the continuations.
Namely, to sequentially execute <tt>a</tt> and then <tt>b</tt>, we call <tt>a</tt> with a success continuation that calls <tt>b</tt>.</p>

<p class="trans" lang="ja">
åˆ—ã‚‚ã€ç¶™ç¶šã‚’æ¸¡ã™ã®ã«å¿…è¦ãª <tt>sequentially</tt> ã¨ã„ã†ä¸‹ä½æ‰‹ç¶šãã«ãŠã‘ã‚‹è¨ˆç•¥ã‚’é™¤ã‘ã°ã€ä»¥å‰ã®è©•ä¾¡å™¨ã«ãŠã‘ã‚‹æ–¹æ³•ã¨åŒã˜æ–¹æ³•ã§æ‰±ã‚ã‚Œã‚‹ã€‚
ã¤ã¾ã‚Šã€é€æ¬¡çš„ã« <tt>a</tt> ã‚’å®Ÿè¡Œã—ã¦ãã‚Œã‹ã‚‰ <tt>b</tt> ã‚’å®Ÿè¡Œã™ã‚‹ãŸã‚ã«ã€<tt>b</tt> ã‚’å‘¼ã³å‡ºã™æˆåŠŸç¶™ç¶šã¨ã¨ã‚‚ã« <tt>a</tt> ã‚’å‘¼ã³å‡ºã™ã‚ã‘ã ã€‚
</p>

<p class="lisp">(define (analyze-sequence exps)
  (define (sequentially a b)
    (lambda (env succeed fail)
      (a env
         <em>;; success continuation for calling <tt>a</tt></em>
         (lambda (a-value fail2)
           (b env succeed fail2))
         <em>;; failure continuation for calling <tt>a</tt></em>
         fail)))
  (define (loop first-proc rest-procs)
    (if (null? rest-procs)
        first-proc
        (loop (sequentially first-proc (car rest-procs))
              (cdr rest-procs))))
  (let ((procs (map analyze exps)))
    (if (null? procs)
        (error &quot;Empty sequence -- ANALYZE&quot;))
    (loop (car procs) (cdr procs))))
</p>

<a name="%_sec_Temp_635"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_635">Definitions and assignments</a></h4>
<h4 class="trans" lang="ja">å®šç¾©ã¨<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby></h4>


<p class="orig" lang="en">
Definitions are another case where we must go to some trouble to
manage the continuations, because it is necessary to evaluate the
definition-value expression before actually defining the new variable.
To accomplish this, the definition-value execution procedure <tt>vproc</tt> is called with the environment, a success continuation, and the
failure continuation.  If the execution of <tt>vproc</tt> succeeds,
obtaining a value <tt>val</tt> for the defined variable, the variable is
defined and the success is propagated:</p>

<p class="trans" lang="ja">
å®šç¾©ã¯ã€ç¶™ç¶šã‚’ãªã‚“ã¨ã‹ã†ã¾ãæ‰±ã†ã¹ãã€ã‚ã‚‹ç¨®ã®å„ä»‹ã”ã¨ã«ãªã‚‰ã–ã‚‹ã‚’å¾—ãªã„ã€ã‚‚ã†ä¸€ã¤ã®å ´åˆã§ã‚ã‚‹ã€‚ã¨ã„ã†ã®ã‚‚ã€æ–°ãŸãªå¤‰æ•°ã‚’å®Ÿéš›ã«å®šç¾©ã™ã‚‹å‰ã«ã€å®šç¾©ã®å€¤ã®å¼ã‚’è©•ä¾¡ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã‹ã‚‰ã§ã‚ã‚‹ã€‚<span class="note">(? è¦æ¤œè¨)</span>
ã“ã‚Œã‚’é”æˆã™ã‚‹ãŸã‚ã«ã€<tt>vproc</tt> ã¨ã„ã†ã€å®šç¾©ã®å€¤ã®å®Ÿè¡Œæ‰‹ç¶šããŒã€ç’°å¢ƒã¨æˆåŠŸç¶™ç¶šã¨å¤±æ•—ç¶™ç¶šã¨ã¨ã‚‚ã«å‘¼ã°ã‚Œã‚‹ã€‚
ã‚‚ã— <tt>vproc</tt> ã®å®Ÿè¡ŒãŒæˆåŠŸã™ã‚Œã°ã€å®šç¾©ã•ã‚Œã‚‹å¤‰æ•°ã®ãŸã‚ã® <tt>val</tt> ã¨ã„ã†å€¤ã‚’å–å¾—ã—ã¦ã„ã‚‹ã‚ã‘ã ã‹ã‚‰ <span class="note">(? æ–‡ã®ã¤ãªãŒã‚Šã¯è¦æ¤œè¨)</span>ã€å¤‰æ•°ãŒå®šç¾©ã•ã‚Œã€æˆåŠŸãŒä¼æ’­ã•ã‚Œã‚‹ã€‚
</p>

<p class="lisp">(define (analyze-definition exp)
  (let ((var (definition-variable exp))
        (vproc (analyze (definition-value exp))))
    (lambda (env succeed fail)
      (vproc env                        
             (lambda (val fail2)
               (define-variable! var val env)
               (succeed 'ok fail2))
             fail))))
</p>

<p class="orig" lang="en">
<a name="%_idx_5008"></a>Assignments are more interesting.  This is the first place where we
really use the continuations, rather than just passing them around.
The execution procedure for assignments starts out like the one for
definitions.  It first attempts to obtain the new value to be assigned
to the variable. If this evaluation of <tt>vproc</tt> fails, the
assignment fails.</p>

<p class="trans" lang="ja">
<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã¯ã€ã‚‚ã£ã¨é¢ç™½ã„ã€‚
ã“ã‚Œã¯ã€ç¶™ç¶šã‚’ãŸã å—ã‘æ¸¡ã—ã¦ã‚†ãã¨ã„ã†ã‚ˆã‚Šã‚€ã—ã‚ã€çœŸã«ç¶™ç¶šã‚’ç”¨ã„ã‚‹ã€æœ€åˆã®å ´ã§ã‚ã‚‹ã€‚
<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ç”¨ã®å®Ÿè¡Œæ‰‹ç¶šãã¯ã€å®šç¾©ç”¨ã®ã‚‚ã®ã¨ä¼¼ãŸã‚ˆã†ãªæ„Ÿã˜ã§å§‹ã¾ã‚‹ã€‚
ãã‚Œã¯ã€ã¾ãšã€å¤‰æ•°ã«<ruby><rb>ä»£å…¥ã•ã‚Œã‚‹</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦ã‚‰ã‚Œã‚‹</rt><rp>) </rp></ruby>ã¹ãæ–°ãŸãªå€¤ã‚’å¾—ã‚ˆã†ã¨ã™ã‚‹ã€‚
ã‚‚ã—ã€<tt>vproc</tt> ã®ã“ã®è©•ä¾¡ãŒå¤±æ•—ã™ã‚Œã°ã€<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã¯å¤±æ•—ã™ã‚‹ã€‚
</p>

<p class="orig" lang="en">
If <tt>vproc</tt> succeeds, however, and we go on to make the assignment,
we must consider the possibility that this branch of the computation
might later fail, which will require us to backtrack out of the
assignment.  Thus, we must arrange to undo the assignment as
part of the backtracking process.<a name="call_footnote_Temp_636" href="#footnote_Temp_636"><sup><small>57</small></sup></a></p>

<p class="trans" lang="ja">
ã—ã‹ã—ã€ã‚‚ã— <tt>vproc</tt> ãŒæˆåŠŸã—ã¦ã€ãã‚Œã«å¼•ãç¶šã„ã¦<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã‚’è¡Œãˆã°ã€ç§ãŸã¡ã¯ã€ã“ã®è¨ˆç®—ã®åˆ†å²ãŒå¾Œã«å¤±æ•—ã™ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã¨ã„ã†å¯èƒ½æ€§ã‚’è€ƒãˆãªãã¦ã¯ãªã‚‰ãªã„ã—ã€ãã®ã“ã¨ã¯ã€<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã‹ã‚‰æŠœã‘ã¦ãƒãƒƒã‚¯ãƒˆãƒ©ãƒƒã‚¯ã™ã‚‹ã“ã¨ã‚’è¦è«‹ã™ã‚‹ã ã‚ã†ã€‚
ã‚ˆã£ã¦ã€ãƒãƒƒã‚¯ãƒˆãƒ©ãƒƒã‚¯ã™ã‚‹éç¨‹ã®ä¸€éƒ¨ã¨ã—ã¦ã€<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã‚’å–ã‚Šæ¶ˆã™æ‰‹ç­ˆã‚’æ•´ãˆã­ã°ãªã‚‰ãªã„<a href="#footnote_Temp_636"><sup><small>57</small></sup></a>ã€‚
</p>

<p class="orig" lang="en">
This is accomplished by giving <tt>vproc</tt> a success continuation
(marked with the comment ``*1*'' below) that saves the old value of
the variable before assigning the new value to the
variable and proceeding from the assignment.  The failure continuation
that is passed along with the value of the assignment (marked with the
comment ``*2*'' below) restores the old value of the variable
before continuing the failure.
That is, a successful assignment provides a failure continuation that
will intercept a subsequent failure; whatever failure would otherwise
have called <tt>fail2</tt> calls this procedure instead, to undo the
assignment before actually calling <tt>fail2</tt>.</p>

<p class="trans" lang="ja">
ã“ã‚Œã¯ã€å¤‰æ•°ã«æ–°ãŸãªå€¤ã‚’<ruby><rb>ä»£å…¥ã™ã‚‹</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦ã‚‹</rt><rp>) </rp></ruby>å‰ã®ã€ãã®å¤‰æ•°ã®å¤ã„å€¤ã‚’é€€é¿ã™ã‚‹ã‚ˆã†ãªæˆåŠŸç¶™ç¶š (ä»¥ä¸‹ã§ã¯ã€Œ*1*ã€ã¨ã„ã†ã‚³ãƒ¡ãƒ³ãƒˆã§å°ãŒä»˜ã‘ã‚‰ã‚Œã¦ã„ã‚‹) ã‚’ <tt>vproc</tt> ã«ä¸ãˆã¦ã€ãã®<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã‹ã‚‰ç¶šã‘ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€é”æˆã•ã‚Œã‚‹ã€‚
<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã®å€¤ã¨ã¨ã‚‚ã«æ¸¡ã•ã‚Œã‚‹å¤±æ•—ç¶™ç¶š (ä»¥ä¸‹ã§ã¯ã€Œ*2*ã€ã¨ã„ã†ã‚³ãƒ¡ãƒ³ãƒˆã§å°ãŒä»˜ã‘ã‚‰ã‚Œã¦ã„ã‚‹) ã¯ã€å¤±æ•—ã‚’ç¶™ç¶šã™ã‚‹å‰ã«ã€ãã®å¤‰æ•°ã®å¤ã„å€¤ã‚’å¾©å…ƒã™ã‚‹ã€‚
ã¤ã¾ã‚Šã€æˆåŠŸã—ãŸ<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã¯ã€å¾Œç¶šã®å¤±æ•—ã‚’æ¨ªå–ã‚Šã™ã‚‹ã“ã¨ã«ãªã‚‹å¤±æ•—ç¶™ç¶šã‚’ã‚‚ãŸã‚‰ã™ã€‚ã©ã®ã‚ˆã†ãªå¤±æ•—ãŒä»–ã®æ–¹æ³•ã§ <tt>fail2</tt> ã‚’å‘¼ã³å‡ºã—ãŸã®ã§ã‚ã‚Œã€å®Ÿéš›ã« <tt>fail2</tt> ã‚’å‘¼ã¶å‰ã«<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã‚’å–ã‚Šæ¶ˆã™ãŸã‚ã«ã€ä»£ã‚ã‚Šã«ã“ã®æ‰‹ç¶šããŒå‘¼ã³å‡ºã™ã®ã§ã‚ã‚‹ã€‚<span class="note">(æ§‹æ–‡ãŒã†ã¾ãå–ã‚Œãªã„ã€‚å€’ç½®?)</span>
</p>

<p class="lisp">(define (analyze-assignment exp)
  (let ((var (assignment-variable exp))
        (vproc (analyze (assignment-value exp))))
    (lambda (env succeed fail)
      (vproc env
             (lambda (val fail2)        <em>; *1*</em>
               (let ((old-value
                      (lookup-variable-value var env))) 
                 (set-variable-value! var val env)
                 (succeed 'ok
                          (lambda ()    <em>; *2*</em>
                            (set-variable-value! var
                                                 old-value
                                                 env)
                            (fail2)))))
             fail))))
</p>

<a name="%_sec_Temp_637"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_637">Procedure applications</a></h4>
<h4 class="trans" lang="ja">æ‰‹ç¶šãé©ç”¨</h4>

<p class="orig" lang="en">
The execution procedure for applications contains no new ideas except
for the technical complexity of managing the continuations.  This
complexity arises in <tt>analyze-application</tt>, due to the need to
keep track of the success and failure continuations as we evaluate the
operands.  We use a procedure <tt>get-args</tt> to evaluate the list of
operands, rather than a simple <tt>map</tt> as in the ordinary evaluator.</p>

<p class="trans" lang="ja">
é©ç”¨ã«ã¤ã„ã¦ã®å®Ÿè¡Œæ‰‹ç¶šãã¯ã€ç¶™ç¶šã‚’ç®¡ç†ã™ã‚‹ã“ã¨ã®æŠ€è¡“çš„ãªè¤‡é›‘ã•ã‚’é™¤ã„ã¦ã€ä½•ã‚‚æ–°ã—ã„è€ƒãˆã‚’å«ã‚“ã§ã¯ã„ãªã„ã€‚
ã“ã®è¤‡é›‘ã•ã¯ã€ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã‚’è©•ä¾¡ã™ã‚‹éš›ã«æˆåŠŸç¶™ç¶šã¨å¤±æ•—ç¶™ç¶šã‚’æŠŠæ¡ã—ç¶šã‘ã‚‹å¿…è¦ãŒã‚ã‚‹ã›ã„ã§ã€<tt>analyze-application</tt> ã«ãŠã„ã¦ç”Ÿã˜ã‚‹ã€‚
ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã®ãƒªã‚¹ãƒˆã‚’è©•ä¾¡ã™ã‚‹ãŸã‚ã«ã¯ã€å…ƒã®è©•ä¾¡å™¨ã§ã®ã‚ˆã†ã«å˜ç´”ãª <tt>map</tt> ã‚’ä½¿ã†ã®ã§ã¯ãªãã€<tt>get-args</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’ä½¿ã†ã€‚
</p>

<p class="lisp">(define (analyze-application exp)
  (let ((fproc (analyze (operator exp)))
        (aprocs (map analyze (operands exp))))
    (lambda (env succeed fail)
      (fproc env
             (lambda (proc fail2)
               (get-args aprocs
                         env
                         (lambda (args fail3)
                           (execute-application
                            proc args succeed fail3))
                         fail2))
             fail))))
</p>

<p class="orig" lang="en">
In <tt>get-args</tt>, notice how <tt>cdr</tt>ing down the list of <tt>aproc</tt> execution procedures and <tt>cons</tt>ing up the resulting list of
<tt>args</tt> is accomplished by calling each <tt>aproc</tt> in the list
with a success continuation that recursively calls <tt>get-args</tt>.
Each of these recursive calls to <tt>get-args</tt> has a success
continuation whose value is the <tt>cons</tt> of the newly obtained
argument onto the list of accumulated arguments:</p>

<p class="trans" lang="ja">
<tt>get-args</tt> ã«ãŠã„ã¦ã¯ã€<tt>aproc</tt> å®Ÿè¡Œæ‰‹ç¶šãã®ãƒªã‚¹ãƒˆã® <tt>cdr</tt> ã‚’ã¨ã£ã¦ã„ã£ã¦ãã‚Œã‹ã‚‰çµæœã¨ã—ã¦ã§ãã‚‹ <tt>args</tt> ã®ãƒªã‚¹ãƒˆã‚’ <tt>cons</tt> ã—ã¦ã¾ã¨ã‚ã¦ã‚†ãã“ã¨ãŒã€<tt>get-args</tt> ã‚’å†å¸°çš„ã«å‘¼ã³å‡ºã™æˆåŠŸç¶™ç¶šã¨ã¨ã‚‚ã«ãƒªã‚¹ãƒˆå†…ã®ãã‚Œãã‚Œã® <tt>aproc</tt> ã‚’å‘¼ã³å‡ºã™ã“ã¨ã«ã‚ˆã‚Šã€ã©ã®ã‚ˆã†ã«ã—ã¦é”æˆã•ã‚Œã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã«æ³¨æ„ã—ã¦ã»ã—ã„ã€‚
<tt>get-args</tt> ã«å¯¾ã™ã‚‹ã“ã‚Œã‚‰ã®å†å¸°å‘¼ã³å‡ºã—ã®å„ã€…ã¯ã€è“„ç©ã•ã‚ŒãŸå¼•æ•°ã®ãƒªã‚¹ãƒˆã®å‰ã«ã€æ–°ãŸã«å¾—ã‚‰ã‚ŒãŸå¼•æ•°ã‚’ä»˜ã‘ãŸ <tt>cons</tt> ã‚’å€¤ã¨ã™ã‚‹ã‚ˆã†ãªã€æˆåŠŸç¶™ç¶šã‚’æŒã£ã¦ã„ã‚‹ã€‚
</p>

<p class="lisp">(define (get-args aprocs env succeed fail)
  (if (null? aprocs)
      (succeed '() fail)
      ((car aprocs) env
                    <em>;; success continuation for this <tt>aproc</tt></em>
                    (lambda (arg fail2)
                      (get-args (cdr aprocs)
                                env
                                <em>;; success continuation for recursive</em>
                                <em>;; call to <tt>get-args</tt></em>
                                (lambda (args fail3)
                                  (succeed (cons arg args)
                                           fail3))
                                fail2))
                    fail)))
</p>


<p class="orig" lang="en">
The actual procedure application, which is
performed by <tt>execute-application</tt>, is
accomplished in the same way as for the ordinary evaluator, except for
the need to manage the continuations.</p>

<p class="trans" lang="ja">
å®Ÿéš›ã®æ‰‹ç¶šãé©ç”¨ã¯ã€<tt>execute-application</tt> ã«ã‚ˆã‚Šå®Ÿè¡Œã•ã‚Œã‚‹ã‚‚ã®ãªã®ã ãŒã€ç¶™ç¶šã‚’ç®¡ç†ã™ã‚‹å¿…è¦æ€§ã‚’é™¤ã‘ã°ã€å…ƒã®è©•ä¾¡å™¨ã«ã¤ã„ã¦ã®ã‚‚ã®ã¨åŒæ§˜ã«ã—ã¦é”æˆã•ã‚Œã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_5012"></a>(define (execute-application proc args succeed fail)
  (cond ((primitive-procedure? proc)
         (succeed (apply-primitive-procedure proc args)
                  fail))
        ((compound-procedure? proc)
         ((procedure-body proc)
          (extend-environment (procedure-parameters proc)
                              args
                              (procedure-environment proc))
          succeed
          fail))
        (else
         (error
          &quot;Unknown procedure type -- EXECUTE-APPLICATION&quot;
          proc))))
</p>

<a name="%_sec_Temp_638"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_638">Evaluating <tt>amb</tt> expressions</a></h4>
<h4 class="trans" lang="ja"><tt>amb</tt> å¼ã‚’è©•ä¾¡ã™ã‚‹</h4>

<p class="orig" lang="en">
<a name="%_idx_5014"></a>The <tt>amb</tt> special form is the key element in the nondeterministic
language.  Here we see the essence of the interpretation process and
the reason for keeping track of the continuations.  The execution
procedure for <tt>amb</tt> defines a loop <tt>try-next</tt> that cycles
through the execution procedures for all the possible values of the
<tt>amb</tt> expression.  Each execution procedure is called with a
failure continuation that will try the next one.  When there are no
more alternatives to try, the entire <tt>amb</tt> expression fails.</p>

<p class="trans" lang="ja">
<tt>amb</tt> ã¨ã„ã†ç‰¹æ®Šå½¢å¼ã¯ã€éæ±ºå®šçš„è¨€èªã«ãŠã‘ã‚‹éµã¨ãªã‚‹è¦ç´ ã§ã‚ã‚‹ã€‚
ã“ã“ã§ã¯ã€è§£é‡ˆéç¨‹ã®æœ€é‡è¦ç‚¹ã¨ã€ç¶™ç¶šã‚’æŠŠæ¡ã—ç¶šã‘ã‚‹ç†ç”±ã‚’è¦‹ã‚‹ã€‚
<tt>amb</tt> ã«å¯¾ã™ã‚‹å®Ÿè¡Œæ‰‹ç¶šãã¯ã€<tt>amb</tt> å¼ã®ã‚ã‚‰ã‚†ã‚‹å¯èƒ½ãªå€¤ã«å¯¾ã™ã‚‹å®Ÿè¡Œæ‰‹ç¶šãå…¨éƒ¨ã‚’é€šã˜ã¦å¾ªç’°ã™ã‚‹ã€<tt>try-next</tt> ã¨ã„ã†ãƒ«ãƒ¼ãƒ—ã‚’å®šç¾©ã—ã¦ã„ã‚‹ã€‚
å„å®Ÿè¡Œæ‰‹ç¶šãã¯ã€æ¬¡ã®ã‚‚ã®ã‚’è©¦ã™ã“ã¨ã«ãªã‚‹ã§ã‚ã‚ã†å¤±æ•—ç¶™ç¶šã¨ã¨ã‚‚ã«ã€å‘¼ã°ã‚Œã‚‹ã€‚
è©¦ã™ã¹ãæ›´ãªã‚‹ä»£æ›¿ç‰©ãŒãªããªã£ãŸã‚‰ã€<tt>amb</tt> å¼å…¨ä½“ãŒå¤±æ•—ã™ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_5016"></a>(define (analyze-amb exp)
  (let ((cprocs (map analyze (amb-choices exp))))
    (lambda (env succeed fail)
      (define (try-next choices)
        (if (null? choices)
            (fail)
            ((car choices) env
                           succeed
                           (lambda ()
                             (try-next (cdr choices))))))
      (try-next cprocs))))
</p>

<a name="%_sec_Temp_639"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_639">Driver loop</a></h4>
<h4 class="trans" lang="ja">ãƒ‰ãƒ©ã‚¤ãƒãƒ»ãƒ«ãƒ¼ãƒ—</h4>


<p class="orig" lang="en">
<a name="%_idx_5018"></a>
<a name="%_idx_5020"></a>The driver loop for the <tt>amb</tt> evaluator is complex, due to
the mechanism that permits the user to try again in evaluating an
expression.  The driver uses a procedure called <tt>internal-loop</tt>,
which takes as argument a procedure <tt>try-again</tt>.  The intent is
that calling <tt>try-again</tt> should go on to the next untried
alternative in the nondeterministic evaluation.  <tt>Internal-loop</tt>
either calls <tt>try-again</tt> in response to the user typing <tt>try-again</tt> at the driver loop, or else starts a new evaluation by
calling <tt>ambeval</tt>.  </p>

<p class="trans" lang="ja">
<tt>amb</tt> è©•ä¾¡å™¨ç”¨ã®ãƒ‰ãƒ©ã‚¤ãƒãƒ»ãƒ«ãƒ¼ãƒ—ã¯ã€å¼ã‚’è©•ä¾¡ã™ã‚‹éš›ã«ãƒ¦ãƒ¼ã‚¶ãŒå†åº¦è©¦ã›ã‚‹ã‚ˆã†ã«ã™ã‚‹ä»•çµ„ã¿ã®ãŸã‚ã«ã€è¤‡é›‘ã§ã‚ã‚‹ã€‚
ãƒ‰ãƒ©ã‚¤ãƒã¯ã€<tt>internal-loop</tt> ã¨å‘¼ã°ã‚Œã‚‹æ‰‹ç¶šãã‚’ä½¿ã†ãŒã€ã“ã‚Œã¯ã€å¼•æ•°ã¨ã—ã¦ <tt>try-again</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’ã¨ã‚‹ã€‚
ãã®æ„å›³ã¯ã€<tt>try-again</tt> ã‚’å‘¼ã³å‡ºã™ã“ã¨ã¯ã€ãã‚Œã«å¼•ãç¶šã„ã¦ã€éæ±ºå®šçš„è©•ä¾¡ã«ãŠã‘ã‚‹ã€ã¾ã è©¦ã—ã¦ã„ãªã„æ¬¡ã®ä»£æ›¿ç‰©ã¸ã¨é€²ã‚€ã¹ãã§ã‚ã‚‹ã€ã¨ã„ã†ã‚‚ã®ã§ã‚ã‚‹ã€‚
<tt>internal-loop</tt> ã¯ã€ãƒ‰ãƒ©ã‚¤ãƒãƒ»ãƒ«ãƒ¼ãƒ—ã«ãŠã„ã¦ãƒ¦ãƒ¼ã‚¶ãŒ <tt>try-again</tt> ã¨æ‰“ã¡è¾¼ã‚€ã®ã«å¿œã˜ã¦  <tt>try-again</tt> ã‚’å‘¼ã³å‡ºã™ã‹ã€ãã†ã§ãªã‘ã‚Œã°ã€<tt>ambeval</tt> ã‚’å‘¼ã³å‡ºã™ã“ã¨ã§æ–°ãŸãªè©•ä¾¡ã‚’é–‹å§‹ã™ã‚‹ã‹ã€ã®ã„ãšã‚Œã‹ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
The failure continuation for this call to <tt>ambeval</tt>
informs the user that there are no more values and re-invokes the driver loop.</p>

<p class="trans" lang="ja">
ã“ã® <tt>ambeval</tt> ã®å‘¼ã³å‡ºã—ã«å¯¾ã™ã‚‹å¤±æ•—ç¶™ç¶šã¯ã€æ›´ãªã‚‹å€¤ã¯ã‚‚ã†ãªã„ã®ã ã¨ãƒ¦ãƒ¼ã‚¶ã«çŸ¥ã‚‰ã›ã‚‹ã¨ã¨ã‚‚ã«ã€ãƒ‰ãƒ©ã‚¤ãƒãƒ»ãƒ«ãƒ¼ãƒ—ã‚’å†åº¦å‘¼ã³å‡ºã™ã€‚
</p>

<p class="orig" lang="en">
The success continuation for the call to <tt>ambeval</tt>
is more subtle.  We print the obtained value and then invoke
the internal loop again with a <tt>try-again</tt> procedure that will be
able to try the next alternative.  This <tt>next-alternative</tt>
procedure is the second argument that was passed to the
success continuation.  Ordinarily, we think of this second argument
as a failure continuation to be used if the current evaluation branch
later fails.  In this case, however, we have completed a successful
evaluation, so we can invoke the ``failure'' alternative branch in
order to search for additional successful evaluations.</p>

<p class="trans" lang="ja">
<tt>ambeval</tt> ã®å‘¼ã³å‡ºã—ã«å¯¾ã™ã‚‹æˆåŠŸç¶™ç¶šã¯ã€ã‚ˆã‚Šå¾®å¦™ã§ã‚ã‚‹ã€‚
å¾—ã‚‰ã‚ŒãŸå€¤ã‚’å°å­—ã—ã¦ã€ãã‚Œã‹ã‚‰ã€å†…éƒ¨ãƒ«ãƒ¼ãƒ—ã‚’ã€æ¬¡ã®ä»£æ›¿ç‰©ã‚’è©¦ã™ã“ã¨ãŒã§ãã‚‹ã§ã‚ã‚ã† <tt>try-again</tt> ã¨ã„ã†æ‰‹ç¶šãã¨ã¨ã‚‚ã«ã€å†åº¦å‘¼ã³å‡ºã™ã®ã ã€‚
ã“ã® <tt>next-alternative</tt> ã¨ã„ã†æ‰‹ç¶šãã¯ã€æˆåŠŸç¶™ç¶šã«æ¸¡ã•ã‚ŒãŸ2ç•ªç›®ã®å¼•æ•°ã§ã‚ã‚‹ã€‚
å¤§æŠµã¯ã€ã“ã®2ç•ªç›®ã®å¼•æ•°ã‚’ã€ç¾åœ¨ã®è©•ä¾¡åˆ†å²ãŒå¾Œã«å¤±æ•—ã—ãŸã‚‰ä½¿ã‚ã‚Œã‚‹ã“ã¨ã«ãªã‚‹å¤±æ•—ç¶™ç¶šã¨è¦‹ãªã™ã€‚
ã—ã‹ã—ã€ã“ã®å ´åˆã€æˆåŠŸã—ãŸè©•ä¾¡ã‚’å®Œäº†ã—ãŸã¨ã“ã‚ãªã®ã§ã‚ã‚Šã€ã‚ˆã£ã¦ã€ã•ã‚‰ãªã‚‹æˆåŠŸã™ã‚‹è©•ä¾¡ã‚’æ¢ã™ãŸã‚ã«ã¯ã€ã€Œå¤±æ•—ã€ã®ä»£æ›¿åˆ†å²ã‚’å‘¼ã³å‡ºã›ã‚‹ã€‚
<span class="note">(è¦æ¤œè¨)</span>
</p>

<p class="lisp"><a name="%_idx_5022"></a>(define input-prompt &quot;;;; Amb-Eval input:&quot;)
(define output-prompt &quot;;;; Amb-Eval value:&quot;)
<a name="%_idx_5024"></a>(define (driver-loop)
  (define (internal-loop try-again)
    (prompt-for-input input-prompt)
    (let ((input (read)))
      (if (eq? input 'try-again)
          (try-again)
          (begin
            (newline)
            (display &quot;;;; Starting a new problem &quot;)
            (ambeval input
                     the-global-environment
                     <em>;; <tt>ambeval</tt> success</em>
                     (lambda (val next-alternative)
                       (announce-output output-prompt)
                       (user-print val)
                       (internal-loop next-alternative))
                     <em>;; <tt>ambeval</tt> failure</em>
                     (lambda ()
                       (announce-output
                        &quot;;;; There are no more values of&quot;)
                       (user-print input)
                       (driver-loop)))))))
  (internal-loop
   (lambda ()
     (newline)
     (display &quot;;;; There is no current problem&quot;)
     (driver-loop))))
</p>

<p class="orig" lang="en">The initial call to <tt>internal-loop</tt> uses a <tt>try-again</tt> procedure that complains that there is no current
problem and restarts the driver loop.  This is the behavior that will
happen if the user types <tt>try-again</tt> when there is no evaluation
in progress.</p>

<p class="trans" lang="ja">
<tt>internal-loop</tt> ã¸ã®æœ€åˆã®å‘¼ã³å‡ºã—ã¯ã€ä»Šã¯ä½•ã‚‚å•é¡ŒãŒãªã„ã¨è¨´ãˆã¦ãƒ‰ãƒ©ã‚¤ãƒãƒ»ãƒ«ãƒ¼ãƒ—ã‚’å†åº¦é–‹å§‹ã™ã‚‹ã€<tt>try-again</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’ä½¿ã†ã€‚
ã“ã‚Œã¯ã€é€²è¡Œä¸­ã®è©•ä¾¡ãŒä½•ã‚‚ãªã„å ´åˆã«ãƒ¦ãƒ¼ã‚¶ãŒ <tt>try-again</tt> ã¨æ‰“ã¡è¾¼ã‚“ã ã‚‰èµ·ã“ã‚‹ã§ã‚ã‚ã†æŒ¯ã‚‹èˆã„ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
<a name="%_thm_4.50"></a>
<b>Exercise 4.50.</b>  Implement a new special form <tt>ramb</tt> that is like <tt>amb</tt> except that it searches alternatives in a random order, rather 
than from left to right.  Show how this can help with Alyssa's problem
in exercise <a href="#%_thm_4.49">4.49</a>.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ 4.50.</b> å·¦ã‹ã‚‰å³ã¸ã¨ã„ã†ã‚ˆã‚Šã‚‚ã‚€ã—ã‚ãƒ©ãƒ³ãƒ€ãƒ ãªé †åºã§ä»£æ›¿ç‰©ã‚’æ¢ã™ã€ã¨ã„ã†ç‚¹ã‚’é™¤ã‘ã° <tt>amb</tt> ã«ä¼¼ã¦ã„ã‚‹ã€<tt>ramb</tt> ã¨ã„ã†æ–°ãŸãªç‰¹æ®Šå½¢å¼ã‚’å®Ÿè£…ã›ã‚ˆã€‚
ã“ã‚ŒãŒã€ç·´ç¿’å•é¡Œ<a href="#%_thm_4.49">4.49</a>ã«ãŠã‘ã‚‹ã‚¢ãƒªãƒƒã‚µã®å•é¡Œã‚’ã©ã®ã‚ˆã†ã«åŠ©ã‘ã‚‹ã®ã‹ã‚’ç¤ºã›ã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>


<p class="orig" lang="en">
<a name="%_thm_4.51"></a>
<b>Exercise 4.51.</b>  Implement a new kind of assignment called <tt>permanent-set!</tt> that
is not undone upon failure.  For example, we can choose two distinct
elements from a list and count the number of trials required to make a
successful choice as follows:</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ 4.51.</b> å¤±æ•—ã®éš›ã«å–ã‚Šæ¶ˆã•ã‚Œãªã„ã€<tt>permanent-set!</tt> ã¨å‘¼ã°ã‚Œã‚‹æ–°ãŸãªç¨®é¡ã®<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã‚’å®Ÿè£…ã›ã‚ˆã€‚
ãŸã¨ãˆã°ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¦ã€ãƒªã‚¹ãƒˆã‹ã‚‰äºŒã¤ã®ç•°ãªã‚‹è¦ç´ ã‚’é¸ã‚“ã§ã€æˆåŠŸã™ã‚‹é¸æŠã‚’è¡Œã†ã¾ã§ã«è¦ã™ã‚‹è©¦è¡Œã®å›æ•°ã‚’æ•°ãˆã‚‹ã€ã¨ã„ã†ã“ã¨ãŒå¯èƒ½ã ã€‚
</p>

<p class="lisp">(define count 0)
(let ((x (an-element-of '(a b c)))
      (y (an-element-of '(a b c))))
  (permanent-set! count (+ count 1))
  (require (not (eq? x y)))
  (list x y count))
<i>;;; Starting a new problem</i>
<i>;;; Amb-Eval value:</i>
<i>(a b 2)</i>
<i>;;; Amb-Eval input:</i>
try-again
<i>;;; Amb-Eval value:</i>
<i>(a c 3)</i>
</p>


<p class="orig" lang="en">What values would have been displayed if we had used <tt>set!</tt> here
rather than <tt>permanent-set!</tt> ?
</p>

<p class="trans" lang="ja">
ã‚‚ã—ã“ã“ã§ <tt>permanent-set!</tt> ã§ã¯ãªã <tt>set!</tt> ã‚’ä½¿ã£ã¦ã„ãŸã‚‰ã€ã©ã®ã‚ˆã†ãªå€¤ãŒè¡¨ç¤ºã•ã‚Œã¦ã„ãŸã ã‚ã†ã‹?
</p>

<p class="exercise"><span class="ex_comment">
</span></p>


<p class="orig" lang="en">
<a name="%_thm_4.52"></a>
<b>Exercise 4.52.</b>  Implement a new construct called <tt>if-fail</tt> that permits the user to
catch the failure of an expression.  <tt>If-fail</tt> takes two
expressions.  It evaluates the first expression as usual and returns
as usual if the evaluation succeeds.  If the evaluation fails,
however, the value of the second expression is returned, as in the
following example:
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ 4.52.</b> ãƒ¦ãƒ¼ã‚¶ãŒå¼ã®å¤±æ•—ã‚’æ•ã¾ãˆã‚‹ã“ã¨ã‚’å¯èƒ½ã«ã™ã‚‹ã€<tt>if-fail</tt> ã¨å‘¼ã°ã‚Œã‚‹æ–°ãŸãªæ§‹é€ ã‚’å®Ÿè£…ã›ã‚ˆã€‚
<tt>if-fail</tt> ã¯äºŒã¤ã®å¼ã‚’ã¨ã‚‹ã€‚
ã“ã‚Œã¯ã€1ç•ªç›®ã®å¼ã‚’é€šå¸¸ã©ãŠã‚Šè©•ä¾¡ã—ã€ãã®å¼ãŒæˆåŠŸã™ã‚Œã°é€šå¸¸ã©ãŠã‚Šã«è¿”ã£ã¦ãã‚‹ã€‚
ã—ã‹ã—ã€ã‚‚ã—è©•ä¾¡ãŒå¤±æ•—ã™ã‚Œã°ã€ä»¥ä¸‹ã®ä¾‹ã®ã‚ˆã†ã«ã€2ç•ªç›®ã®å¼ã®å€¤ãŒè¿”ã•ã‚Œã‚‹ã€‚
</p>

<p class="lisp"><i>;;; Amb-Eval input:</i>
(if-fail (let ((x (an-element-of '(1 3 5))))
           (require (even? x))
           x)
         'all-odd)
<i>;;; Starting a new problem</i>
<i>;;; Amb-Eval value:</i>
<i>all-odd</i>
<i>;;; Amb-Eval input:</i>
(if-fail (let ((x (an-element-of '(1 3 5 8))))
           (require (even? x))
           x)
         'all-odd)
<i>;;; Starting a new problem</i>
<i>;;; Amb-Eval value:</i>
<i>8</i>
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_4.53"></a>
<b>Exercise 4.53.</b>  With <tt>permanent-set!</tt> as described in
exercise <a href="#%_thm_4.51">4.51</a> and <tt>if-fail</tt> as in
exercise <a href="#%_thm_4.52">4.52</a>, what will be the result of evaluating
</p>


<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ 4.53.</b> ç·´ç¿’å•é¡Œ<a href="#%_thm_4.51">4.51</a>ã§èª¬æ˜ã—ãŸã‚ˆã†ãª <tt>permanent-set!</tt> ã¨ã€ç·´ç¿’å•é¡Œ<a href="#%_thm_4.52">4.52</a>ã®ã‚ˆã†ãª <tt>if-fail</tt> ãŒã‚ã‚‹ã¨ã—ã¦ã€ä»¥ä¸‹ã®ã‚‚ã®ã‚’è©•ä¾¡ã—ãŸçµæœã¯ã©ã†ãªã‚‹ã‹ã€‚
</p>

<p class="lisp">(let ((pairs '()))
  (if-fail (let ((p (prime-sum-pair '(1 3 5 8) '(20 35 110))))
             (permanent-set! pairs (cons p pairs))
             (amb))
           pairs))
</p>

<p class="exercise"><span class="ex_comment">
</span></p>


<p class="extra" id="translating">***ã“ã“ã‹ã‚‰</p>
<p class="orig" lang="en">
<a name="%_thm_4.54"></a>
<b>Exercise 4.54.</b>  <a name="%_idx_5026"></a>If we had not realized that <tt>require</tt> could be implemented as an
ordinary procedure that uses <tt>amb</tt>, to be defined by the user as
part of a nondeterministic program, we would have had to implement it
as a special form.  This would require syntax procedures</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ 4.54.</b> éæ±ºå®šçš„ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ä¸€éƒ¨ã¨ã—ã¦ãƒ¦ãƒ¼ã‚¶ã«ã‚ˆã‚Šå®šç¾©ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ç­ˆã®ã€<tt>amb</tt> ã‚’ç”¨ã„ã‚‹é€šå¸¸ã®æ‰‹ç¶šãã¨ã—ã¦ã€<tt>require</tt> ã‚’å®Ÿè£…ã§ãã‚‹ã®ã ã€ã¨ã„ã†ã“ã¨ã«ã€ã‚‚ã—ç§ãŸã¡ãŒæ°—ã¥ã‹ãªã‹ã£ãŸã¨ã—ãŸã‚‰ã€ç§ãŸã¡ã¯ã€<tt>require</tt> ã‚’ç‰¹æ®Šå½¢å¼ã¨ã—ã¦å®Ÿè£…ã›ã–ã‚‹ã‚’å¾—ãªã‹ã£ãŸã“ã¨ã ã‚ã†ã€‚
ã“ã‚Œã¯ã€æ¬¡ã®ã‚ˆã†ãªæ–‡æ³•æ‰‹ç¶šãã‚’å¿…è¦ã¨ã™ã‚‹ã ã‚ã†ã—ã€
</p>

<p class="lisp">(define (require? exp) (tagged-list? exp 'require))

(define (require-predicate exp) (cadr exp))
</p>

<p class="orig" lang="en">and a new clause in the dispatch in <tt>analyze</tt></p>

<p class="trans" lang="ja">
<tt>analyze</tt> ã®ä¸­ã®æŒ¯ã‚Šåˆ†ã‘ã«ãŠã‘ã‚‹ã€ä»¥ä¸‹ã®ã‚ˆã†ãªæ–°ãŸãªç¯€ã‚‚å¿…è¦ã¨ã™ã‚‹ã ã‚ã†ã—ã€
</p>

<p class="lisp">((require? exp) (analyze-require exp))
</p>

<p class="orig" lang="en">as well the procedure <tt>analyze-require</tt> that handles <tt>require</tt>
expressions.  Complete the following definition of <tt>analyze-require</tt>.</p>

<p class="trans" lang="ja">
<tt>require</tt> å¼ã‚’æ‰±ã†ã€<tt>analyze-require</tt> ã¨ã„ã†æ‰‹ç¶šãã‚‚åŒæ§˜ã«å¿…è¦ã¨ã™ã‚‹ã ã‚ã†ã€‚
ä»¥ä¸‹ã® <tt>analyze-require</tt> ã®å®šç¾©ã‚’å®Œæˆã•ã›ã‚ˆã€‚
</p>

<p class="lisp">(define (analyze-require exp)
  (let ((pproc (analyze (require-predicate exp))))
    (lambda (env succeed fail)
      (pproc env
             (lambda (pred-value fail2)
               (if &lt;<em>??</em>&gt;
                   &lt;<em>??</em>&gt;
                   (succeed 'ok fail2)))
             fail))))
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<a name="footnotes"></a>
<hr>
<p class="orig" lang="en"><a name="footnote_Temp_598" href="#call_footnote_Temp_598"><sup><small>42</small></sup></a> We assume that we have previously defined a
procedure <tt>prime?</tt> that tests whether numbers are prime.  Even with
<tt>prime?</tt> defined, the <tt>prime-sum-pair</tt> procedure may look
suspiciously like the unhelpful ``pseudo-Lisp'' attempt to define the
square-root function, which we described at the beginning of
section <a href="10_sec1_1.html#%_sec_1.1.7">1.1.7</a>.  In fact, a square-root procedure along those
lines can actually be formulated as a nondeterministic program.
By incorporating a search mechanism into the evaluator, we
are eroding the <a name="%_idx_4816"></a><a name="%_idx_4818"></a>distinction between purely declarative descriptions
and imperative specifications of how to compute answers.  We'll go
even farther in this direction in
section <a href="29_sec4_4.html#%_sec_4.4">4.4</a>.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_598"><sup><small>42</small></sup></a>
æ•°ãŒç´ æ•°ã‹ã©ã†ã‹ã‚’æ¤œæŸ»ã™ã‚‹ <tt>prime?</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’ã€å‰ã‚‚ã£ã¦å®šç¾©æ¸ˆã¿ã§ã‚ã‚‹ã€ã¨ç§ãŸã¡ã¯æƒ³å®šã—ã¦ã„ã‚‹ã€‚
<tt>prime?</tt> ãŒå®šç¾©ã•ã‚Œã¦ã„ã¦ã•ãˆã€<tt>prime-sum-pair</tt> ã¨ã„ã†æ‰‹ç¶šãã¯ã€ç–‘ã‚ã—ãã‚‚ã€äºŒä¹—æ ¹é–¢æ•°ã‚’å®šç¾©ã™ã‚‹ãŸã‚ã®å½¹ç«‹ãŸãšã®ã€Œæ“¬ä¼¼Lispã€çš„ãªè©¦ã¿â€”â€”<a href="10_sec1_1.html#%_sec_1.1.7">1.1.7</a>ç¯€ã®æœ€åˆã§èª¬æ˜ã—ãŸâ€”â€”ã¨åŒæ§˜ãªã‚‚ã®ã‚ˆã†ã«è¦‹ãˆã¦ã—ã¾ã†ã‹ã‚‚ã—ã‚Œãªã„ã€‚
å®Ÿã‚’è¨€ã†ã¨ã€ãã®æ‰‹ã®äºŒä¹—æ ¹é–¢æ•°ã‚’ã€å®Ÿéš›ã«éæ±ºå®šçš„ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¨ã—ã¦å®šå¼åŒ–ã§ãã‚‹ã€‚
æ¢ç´¢ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã‚’è©•ä¾¡å™¨ã®ä¸­ã«å–ã‚Šå…¥ã‚Œã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€ç§ãŸã¡ã¯ã€ç­”ãˆã‚’ã©ã®ã‚ˆã†ã«ã—ã¦è¨ˆç®—ã™ã‚‹ã®ã‹ã«ã¤ã„ã¦ã®ã€ç´”ç²‹ã«å®£è¨€çš„ãªè¨˜è¿°ã¨å‘½ä»¤çš„ãªæŒ‡å®šã¨ã®é–“ã®åŒºåˆ¥ã‚’ã€ä¾µè•ã—ã¦ã„ã‚‹ã¨ã“ã‚ãªã®ã§ã‚ã‚‹ã€‚
<a href="29_sec4_4.html#%_sec_4.4">4.4</a>ç¯€ã§ã¯ã€ã“ã®æ–¹å‘ã®ã‚‚ã£ã¨å…ˆã«ã¾ã§ã™ã‚‰è¡Œãã“ã¨ã«ãªã‚‹ã ã‚ã†ã€‚
</p>



<p class="orig" lang="en"><a name="footnote_Temp_599" href="#call_footnote_Temp_599"><sup><small>43</small></sup></a> The idea of <tt>amb</tt> for nondeterministic programming was
<a name="%_idx_4824"></a>first described in 1961 by John McCarthy (see McCarthy 1967).</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_599"><sup><small>43</small></sup></a>
éæ±ºå®šçš„ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®ãŸã‚ã® <tt>amb</tt> ã®æ¦‚å¿µã¯ã€æœ€åˆã€1961å¹´ã«ã‚¸ãƒ§ãƒ³ãƒ»ãƒãƒƒã‚«ãƒ¼ã‚·ãƒ¼ã«ã‚ˆã£ã¦è¨˜è¿°ã•ã‚ŒãŸ (McCarthy 1967 ã‚’å‚ç…§)ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_600" href="#call_footnote_Temp_600"><sup><small>44</small></sup></a> In actuality, the distinction between nondeterministically
returning a single choice and returning all choices depends somewhat
on our point of view.  From the perspective of the code that uses the
value, the nondeterministic choice returns a single value.  From the
perspective of the programmer designing the code, the nondeterministic
choice potentially returns all possible values, and the computation
branches so that each value is investigated separately.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_600"><sup><small>44</small></sup></a>
ç¾å®Ÿã«ã¯ã€éæ±ºå®šçš„ã«å˜ä¸€ã®é¸æŠè‚¢ã‚’è¿”ã™ã“ã¨ã¨ã€ã™ã¹ã¦ã®é¸æŠè‚¢ã‚’è¿”ã™ã“ã¨ã®åŒºåˆ¥ã¯ã€ã‚ã‚‹ç¨‹åº¦ã¯ç§ãŸã¡ã®è¦–ç‚¹ã«ã‚ˆã‚‹ã€‚
å€¤ã‚’ä½¿ã†ã‚³ãƒ¼ãƒ‰ã®è¦–ç‚¹ã‹ã‚‰ã¯ã€éæ±ºå®šçš„ãªé¸æŠã¯ã€å˜ä¸€ã®å€¤ã‚’è¿”ã™ã®ã§ã‚ã‚‹ã€‚
ã‚³ãƒ¼ãƒ‰ã‚’è¨­è¨ˆã™ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒã®è¦³ç‚¹ã‹ã‚‰ã¯ã€éæ±ºå®šçš„ãªé¸æŠã¯ã€æ½œåœ¨çš„ã«ã™ã¹ã¦ã®å¯èƒ½ãªå€¤ã‚’è¿”ã™ã®ã§ã‚ã‚Šã€ãã‚Œãã‚Œã®å€¤ãŒåˆ¥ã€…ã«èª¿æŸ»ã•ã‚Œã‚‹ã‚ˆã†ã«ã€è¨ˆç®—ã¯åˆ†å²ã™ã‚‹ã®ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_601" href="#call_footnote_Temp_601"><sup><small>45</small></sup></a> One might object that this is a hopelessly
inefficient mechanism.  It might require millions of processors to
solve some easily stated problem this way, and most of the time most
of those processors would be idle.  This objection should be taken in
the context of history.  Memory used to be considered just such an
expensive commodity.  <a name="%_idx_4838"></a>In 1964 a megabyte of RAM cost about $400,000.
Now every personal computer has many megabytes of RAM, and most of the
time most of that RAM is unused.  It is hard to underestimate the cost
of mass-produced electronics.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_601"><sup><small>45</small></sup></a>
ã“ã‚Œã¯ã©ã†ã—ã‚ˆã†ã‚‚ãªãéåŠ¹ç‡çš„ãªä»•çµ„ã¿ã ã€ã¨äººã¯ç•°è­°ã‚’å”±ãˆã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚
ç°¡å˜ã«è¨˜è¿°ã•ã‚Œã‚‹ã‚ã‚‹ç¨®ã®å•é¡Œã‚’ã“ã®æ–¹æ³•ã§è§£ãã®ã«ã€ä½•ç™¾ä¸‡å°ã‚‚ã®ãƒ—ãƒ­ã‚»ãƒƒã‚µã‚’å¿…è¦ã¨ã™ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã—ã€ã»ã¨ã‚“ã©ã®æ™‚é–“ã€ãã‚Œã‚‰ã®ãƒ—ãƒ­ã‚»ãƒƒã‚µã®ã†ã¡ã®ã»ã¨ã‚“ã©ãŒéŠã‚“ã§ã„ã‚‹ã ã‚ã†ã€ã¨ã€‚
ã“ã®ç•°è­°ã¯ã€æ­´å²ã®æ–‡è„ˆã§æ‰ãˆã‚‰ã‚Œã‚‹ã¹ãã§ã‚ã‚‹ã€‚
ãƒ¡ãƒ¢ãƒªã¯ã€ã‹ã¤ã¦ã€ã¡ã‚‡ã†ã©ãã†ã—ãŸé«˜ä¾¡ãªå•†å“ã§ã‚ã‚‹ã¨è€ƒãˆã‚‰ã‚Œã¦ã„ãŸã€‚
1964å¹´ã«ã¯ã€1ãƒ¡ã‚¬ãƒã‚¤ãƒˆã®RAMã¯ã€ç´„40ä¸‡ç±³ãƒ‰ãƒ«ã—ãŸã€‚
ç¾åœ¨ã€ã‚ã‚‰ã‚†ã‚‹ãƒ‘ãƒ¼ã‚½ãƒŠãƒ«ãƒ»ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãŒä½•ãƒ¡ã‚¬ãƒã‚¤ãƒˆã‚‚ã®RAMã‚’å‚™ãˆã¦ãŠã‚Šã€ã»ã¨ã‚“ã©ã®æ™‚é–“ã€ãã®RAMã®ã»ã¨ã‚“ã©ã¯ä½¿ã‚ã‚Œã¦ã„ãªã„ã€‚
<span class="note">(ãã—ã¦ä»Šã§ã¯ä½•ã‚®ã‚¬ãƒã‚¤ãƒˆå˜ä½ã§ã‚ã‚‹ã€‚)</span>
å¤§é‡ç”Ÿç”£ã•ã‚Œã‚‹é›»å­å›è·¯éƒ¨å“ã®è²»ç”¨ã‚’å°‘ãªã‚ã«è¦‹ç©ã‚‚ã‚‹ã“ã¨ã¯é›£ã—ã„ã€‚
</p>



<p class="orig" lang="en"><a name="footnote_Temp_602" href="#call_footnote_Temp_602"><sup><small>46</small></sup></a> Automagically: ``Automatically, but in a way
which, for some reason (typically because it is too complicated, or
too ugly, or perhaps even too trivial), the speaker doesn't feel like
explaining.''  (Steele 1983, Raymond 1993)</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_602"><sup><small>46</small></sup></a>
ã‚ªãƒ¼ãƒˆãƒã‚¸ã‚«ãƒ«ã«ã€ã¨ã¯ã€Œè‡ªå‹•çš„ã«ã€ã ãŒã€ä½•ã‚‰ã‹ã®ç†ç”±ã§ (å…¸å‹çš„ã«ã¯ã€è¤‡é›‘ã™ãã‚‹ã‹ã‚‰ã€ã‚‚ã—ãã¯ã€ã‚ã¾ã‚Šã«è¦‹è‹¦ã—ã„ã‹ã‚‰ã¨ã„ã†ç†ç”±ã§ã€ã¾ãŸã¯ã€ã²ã‚‡ã£ã¨ã™ã‚‹ã¨ã€ã‚ã¾ã‚Šã«ç‘£æœ«ã ã‹ã‚‰ã€ã¨ã„ã†ç†ç”±ã•ãˆã‚‚ã‚ã‚Šå¾—ã‚‹ãŒ)ã€è©±è€…ãŒèª¬æ˜ã—ãŸããªã„ã¨æ€ã£ã¦ã„ã‚‹æ–¹æ³•ã§ã€ã®æ„ (Steele 1983, Raymond 1993)ã€‚
</p>



<p class="orig" lang="en"><a name="footnote_Temp_603" href="#call_footnote_Temp_603"><sup><small>47</small></sup></a> The integration of automatic search strategies
<a name="%_idx_4860"></a>into programming languages has had a long and checkered history.  The
first suggestions that nondeterministic algorithms might be elegantly
encoded in a programming language with search and automatic
backtracking came from <a name="%_idx_4862"></a>Robert Floyd (1967).  <a name="%_idx_4864"></a>Carl Hewitt
(1969) invented a programming language called <a name="%_idx_4866"></a>Planner that explicitly
supported automatic chronological backtracking, providing for a
built-in depth-first search strategy.  <a name="%_idx_4868"></a><a name="%_idx_4870"></a><a name="%_idx_4872"></a>Sussman, Winograd, and Charniak 
(1971) implemented a subset of this language, called <a name="%_idx_4874"></a>MicroPlanner,
which was used to support work in problem solving and robot planning.
Similar ideas, arising from logic and theorem proving, led to the
genesis in Edinburgh and Marseille of the elegant language <a name="%_idx_4876"></a>Prolog
(which we will discuss in section <a href="29_sec4_4.html#%_sec_4.4">4.4</a>).  After
sufficient frustration with automatic search, <a name="%_idx_4878"></a><a name="%_idx_4880"></a>McDermott and Sussman
(1972) developed a language called <a name="%_idx_4882"></a>Conniver, which included mechanisms
for placing the search strategy under programmer control.  This proved
unwieldy, however, and <a name="%_idx_4884"></a><a name="%_idx_4886"></a>Sussman and Stallman (1975) found a more
tractable approach while investigating methods of symbolic analysis
for electrical circuits.  They developed a non-chronological
backtracking scheme that was based on tracing out the logical
dependencies connecting facts, a technique that has come to be known
as <a name="%_idx_4888"></a><em>dependency-directed backtracking</em>.  Although their method was
complex, it produced reasonably efficient programs because it did
little redundant search.  <a name="%_idx_4890"></a><a name="%_idx_4892"></a>Doyle (1979) and McAllester (1978, 1980)
generalized and clarified the methods of Stallman and Sussman,
developing a new paradigm for formulating search that is now called
<a name="%_idx_4894"></a><em>truth maintenance</em>.  Modern problem-solving systems all
use some form of truth-maintenance system as a substrate.  See <a name="%_idx_4896"></a><a name="%_idx_4898"></a>Forbus
and deKleer 1993 for a discussion of elegant ways to build
truth-maintenance systems and applications using truth maintenance.
<a name="%_idx_4900"></a><a name="%_idx_4902"></a><a name="%_idx_4904"></a>Zabih, McAllester, and
Chapman 1987 describes a nondeterministic extension to Scheme that
is based on <tt>amb</tt>; it is similar to the interpreter described in
this section, but more sophisticated, because it uses
dependency-directed backtracking rather than chronological
<a name="%_idx_4906"></a>backtracking.  Winston 1992 gives an introduction to both kinds of
backtracking.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_603"><sup><small>47</small></sup></a>
è‡ªå‹•çš„æ¢ç´¢æˆ¦ç•¥ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã¸ã®çµ±åˆã¯ã€é•·ãæ³¢ä¹±ã«å¯Œã‚“ã æ­´å²ã‚’é‡ã­ã¦ããŸã€‚
éæ±ºå®šçš„ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’ã€æ¢ç´¢ã¨è‡ªå‹•çš„ãƒãƒƒã‚¯ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°ã‚’ã¨ã‚‚ãªã†ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã®ä¸­ã«ã€<!--æ´—ç·´ã•ã‚ŒãŸ-->ç°¡æ½”ãªæ–¹æ³•ã§ã‚³ãƒ¼ãƒ‰åŒ–ã§ãã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€ã¨ã„ã†æœ€åˆã®ç¤ºå”†ã¯ã€Robert Floyd (1967) ã«ç”±æ¥ã™ã‚‹ã€‚
Carl Hewitt (1969) ã¯ã€æ˜ç¤ºçš„ã«è‡ªå‹•çš„æ™‚ç³»åˆ—é †ãƒãƒƒã‚¯ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã€Planner ã¨å‘¼ã°ã‚Œã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã‚’è€ƒæ¡ˆã—ã€çµ„ã¿è¾¼ã¿ã®æ·±ã•å„ªå…ˆæ¢ç´¢æˆ¦ç•¥ã‚’ä¸ãˆãŸã€‚
Sussman, Winograd, and Charniak (1971) ã¯ã€ã“ã®è¨€èªã®ã‚µãƒ–ã‚»ãƒƒãƒˆâ€”â€”MicroPlanner ã¨å‘¼ã°ã‚Œã‚‹â€”â€”ã‚’å®Ÿè£…ã—ã€ã“ã‚Œã¯ã€å•é¡Œè§£æ±ºã¨ãƒ­ãƒœãƒƒãƒˆè¨ˆç”»ç«‹æ¡ˆã«ãŠã‘ã‚‹ä½œæ¥­ã‚’æ”¯æ´ã™ã‚‹ã®ã«ä½¿ã‚ã‚ŒãŸã€‚
ä¼¼ãŸã‚ˆã†ãªè€ƒãˆãŒã€è«–ç†ãŠã‚ˆã³å®šç†è¨¼æ˜ã‹ã‚‰ç”Ÿã˜ãŸã®ã ãŒã€ã“ã‚Œã¯ã€Prolog ã¨ã„ã†<!--æ´—ç·´ã•ã‚ŒãŸ-->æ˜æ™°ãªè¨€èª (<a href="29_sec4_4.html#%_sec_4.4">4.4</a>ç¯€ã§è­°è«–ã™ã‚‹ã“ã¨ã«ã—ã‚ˆã†) ã®ã€ã‚¨ãƒ‡ã‚£ãƒ³ãƒãƒ©ã¨ãƒãƒ«ã‚»ã‚¤ãƒ¦ã«ãŠã‘ã‚‹èµ·æºã«ã¤ãªãŒã£ãŸã€‚
è‡ªå‹•çš„æ¢ç´¢ã«ã¨ã‚‚ãªã†ååˆ†ãªé “æŒ«ã®å¾Œã«ã€McDermott and Sussman
(1972) ã¯ã€Conniver ã¨å‘¼ã°ã‚Œã‚‹è¨€èªã‚’é–‹ç™ºã—ãŸãŒã€ã“ã‚Œã¯ã€æ¢ç´¢æˆ¦ç•¥ã‚’ãƒ—ãƒ­ã‚°ãƒ©ãƒã®åˆ¶å¾¡ã®ã‚‚ã¨ã«ç½®ããŸã‚ã®ä»•çµ„ã¿ã‚’å«ã‚“ã§ã„ãŸã€‚
ã—ã‹ã—ã€ã“ã‚Œã¯æ‰±ã„ã«ãã„ã¨åˆ†ã‹ã‚Šã€Sussman and Stallman (1975) ã¯ã€é›»æ°—å›è·¯ç”¨ã®è¨˜å·çš„è§£æã®æ–¹æ³•ã‚’èª¿ã¹ã¤ã¤ã€ã‚ˆã‚Šæ‰±ã„ã‚„ã™ã„æ‰‹æ³•ã‚’è¦‹ã¤ã‘ãŸã€‚
ã‹ã‚Œã‚‰ã¯ã€äº‹å®ŸåŒå£«ã‚’ã¤ãªãè«–ç†çš„ä¾å­˜é–¢ä¿‚ã‚’çªãæ­¢ã‚ã‚‹ã“ã¨ã«åŸºã¥ã„ãŸã€éæ™‚ç³»åˆ—çš„ãƒãƒƒã‚¯ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°ã®ä½“ç³»â€”â€”ã™ãªã‚ã¡ã€<em>ä¾å­˜é–¢ä¿‚æŒ‡å‘ã®ãƒãƒƒã‚¯ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°</em>ã¨ã—ã¦çŸ¥ã‚‰ã‚Œã‚‹ã“ã¨ã«ãªã£ãŸæŠ€æ³•â€”â€”ã‚’é–‹ç™ºã—ãŸã€‚
ã‹ã‚Œã‚‰ã®æ‰‹æ³•ã¯è¤‡é›‘ã ã£ãŸãŒã€ã‚„ã‚„å†—é•·ãªæ¢ç´¢ã‚’è¡Œã£ãŸã®ã§ã€ã¾ãšã¾ãšåŠ¹ç‡çš„ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ä½œã‚Šå‡ºã—ãŸã€‚
Doyle (1979) and McAllester (1978, 1980) ã¯ã‚¹ãƒˆãƒ¼ãƒ«ãƒãƒ³ã¨ã‚µã‚¹ãƒãƒ³ã®æ‰‹æ³•ã‚’ä¸€èˆ¬åŒ–ãƒ»æ˜ç¢ºåŒ–ã—ã€ä»Šã§ã¯<em>çœŸç†ç¶­æŒ</em>ã¨å‘¼ã°ã‚Œã‚‹ã€æ¢ç´¢ã‚’å®šå¼åŒ–ã™ã‚‹ãŸã‚ã®æ–°ãŸãªæ çµ„ã¿ã‚’ã€é–‹ç™ºã—ãŸã€‚
è¿‘ä»£çš„ãªå•é¡Œè§£æ±ºã‚·ã‚¹ãƒ†ãƒ ã¯ã€ã™ã¹ã¦ã€çœŸç†ç¶­æŒã‚·ã‚¹ãƒ†ãƒ ã®ä½•ã‚‰ã‹ã®å½¢ã‚’åŸºç›¤ã¨ã—ã¦ä½¿ã£ã¦ã„ã‚‹ã€‚
çœŸç†ç¶­æŒã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰ã™ã‚‹ãŸã‚ã®<!--æ´—ç·´ã•ã‚ŒãŸ-->ç°¡æ½”ãªæ–¹æ³•ã¨ã€çœŸç†ç¶­æŒã‚’ä½¿ã†å¿œç”¨ã¨ã«ã¤ã„ã¦ã®è­°è«–ã«é–¢ã—ã¦ã¯ã€Forbus and deKleer 1993 ã‚’å‚ç…§ã®ã“ã¨ã€‚
Zabih, McAllester, and Chapman 1987 ã§ã¯ã€<tt>amb</tt> ã«åŸºã¥ã„ãŸã€Schemeã«å¯¾ã™ã‚‹éæ±ºå®šè«–çš„æ‹¡å¼µã‚’èª¬æ˜ã—ã¦ã„ã‚‹ã€‚ã“ã‚Œã¯ã€æœ¬ç¯€ã§èª¬æ˜ã™ã‚‹ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«ä¼¼ã¦ã„ã‚‹ãŒã€æ™‚ç³»åˆ—é †ãƒãƒƒã‚¯ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°ã§ã¯ãªãã‚€ã—ã‚ä¾å­˜é–¢ä¿‚æŒ‡å‘ã®ãƒãƒƒã‚¯ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°ã‚’ä½¿ã†ã®ã§ã€ã‚ˆã‚Šç²¾å·§ã§ã‚ã‚‹ã€‚
Winston 1992 ã¯ã€åŒæ–¹ã®ç¨®é¡ã®ãƒãƒƒã‚¯ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°ã«ã¤ã„ã¦ã®åºè«–ã‚’ç¤ºã—ã¦ã„ã‚‹ã€‚
</p>


<p class="orig" lang="en"><a name="footnote_Temp_609" href="#call_footnote_Temp_609"><sup><small>48</small></sup></a> Our program uses the following procedure to determine 
if the elements of a list are distinct:
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_609"><sup><small>48</small></sup></a>
ç§ãŸã¡ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€ãƒªã‚¹ãƒˆã®è¦ç´ åŒå£«ãŒç›¸ç•°ãªã‚‹ã‹å¦ã‹ã‚’åˆ¤å®šã™ã‚‹ãŸã‚ã®ä»¥ä¸‹ã®æ‰‹ç¶šãã‚’ç”¨ã„ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_4934"></a>(define (distinct? items)
  (cond ((null? items) true)
        ((null? (cdr items)) true)
        ((member (car items) (cdr items)) false)
        (else (distinct? (cdr items)))))
</p>

<p class="orig" lang="en"><a name="%_idx_4936"></a><tt>Member</tt> is like <tt>memq</tt> except that it uses <tt>equal?</tt> instead
of <tt>eq?</tt> to test for equality.</p>

<p class="trans" lang="ja">
<tt>member</tt> ã¯ã€ç­‰ä¾¡æ€§ã‚’æ¤œæŸ»ã™ã‚‹ãŸã‚ã« <tt>eq?</tt> ã®ä»£ã‚ã‚Šã« <tt>equal?</tt> ã‚’ä½¿ã†ã€ã¨ã„ã†ç‚¹ã‚’é™¤ã„ã¦ã€<tt>memq</tt> ã¨åŒæ§˜ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_616" href="#call_footnote_Temp_616"><sup><small>49</small></sup></a> This is taken from a booklet called ``Problematical
Recreations,'' published in the 1960s by Litton Industries, where it
is attributed to the <em>Kansas State Engineer</em>.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_616"><sup><small>49</small></sup></a>
ã“ã‚Œã¯ã€1960å¹´ä»£ã«ãƒªãƒƒãƒˆãƒ³å·¥æ¥­ã«ã‚ˆã‚Šå‡ºç‰ˆã•ã‚ŒãŸã€Œé›£ã—ã„ãŠæ„‰ã—ã¿ã€ã¨å‘¼ã°ã‚Œã‚‹å°å†Šå­ã‹ã‚‰å–ã‚‰ã‚ŒãŸã‚‚ã®ã§ã€ãã®å°å†Šå­ã§ã¯ã€ã“ã‚Œã¯ã€<em>ã‚«ãƒ³ã‚¶ã‚¹å·ã®æŠ€å¸«</em>ã®ä½œã§ã‚ã‚‹ã¨ã•ã‚Œã¦ã„ã‚‹ã€‚
</p>



<p class="orig" lang="en"><a name="footnote_Temp_619" href="#call_footnote_Temp_619"><sup><small>50</small></sup></a> Here we use the convention that the first element of each list
designates the part of speech for the rest of the words in the list.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_619"><sup><small>50</small></sup></a>
ã“ã“ã§ã¯ã€å„ãƒªã‚¹ãƒˆã®æœ€åˆã®è¦ç´ ãŒã€ãã®ãƒªã‚¹ãƒˆå†…ã®æ®‹ã‚Šã®èªã®å“è©ã‚’æŒ‡å®šã™ã‚‹ã€ã¨ã„ã†æ…£ç¿’ã‚’ç”¨ã„ã¦ã„ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_620" href="#call_footnote_Temp_620"><sup><small>51</small></sup></a> Notice that <tt>parse-word</tt> uses <tt>set!</tt> to modify the
unparsed input list.  For this to work, our <tt>amb</tt> evaluator must
undo the effects of <tt>set!</tt> operations when it backtracks.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_620"><sup><small>51</small></sup></a>
<tt>parse-word</tt> ãŒ <tt>set!</tt> ã‚’ä½¿ã£ã¦ã€æ§‹æ–‡è§£æã•ã‚Œã¦ã„ãªã„å…¥åŠ›ãƒªã‚¹ãƒˆã‚’æ”¹å¤‰ã™ã‚‹ã€ã¨ã„ã†ã“ã¨ã«æ°—ã¥ã„ã¦ã»ã—ã„ã€‚
ã“ã‚ŒãŒã†ã¾ãã„ãã‚ˆã†ã«ã™ã‚‹ã«ã¯ã€ç§ãŸã¡ã® <tt>amb</tt> è©•ä¾¡å™¨ã¯ã€ãƒãƒƒã‚¯ãƒˆãƒ©ãƒƒã‚¯ã™ã‚‹ã¨ãã« <tt>set!</tt> æ“ä½œã®åŠ¹æœã‚’å–ã‚Šæ¶ˆã•ãªãã¦ã¯ãªã‚‰ãªã„ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_621" href="#call_footnote_Temp_621"><sup><small>52</small></sup></a> Observe that this
definition is recursive -- a verb may be followed by any number
of prepositional phrases.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_621"><sup><small>52</small></sup></a>
ã“ã®å®šç¾©ãŒå†å¸°çš„ã§ã‚ã‚‹â€”â€”å‹•è©ã®å¾Œã«ã¯ã€ã„ãã¤ã®å‰ç½®è©å¥ãŒç¶šã„ã¦ã„ã¦ã‚‚ã‚ˆã„â€”â€”ã“ã¨ã«æ°—ã¥ã„ã¦ã»ã—ã„ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_626" href="#call_footnote_Temp_626"><sup><small>53</small></sup></a> This kind of grammar can become arbitrarily complex, but it
<a name="%_idx_4972"></a>is only a toy as far as real language understanding is concerned.
Real natural-language understanding by computer requires an elaborate
mixture of syntactic analysis and interpretation of meaning.  On the
other hand, even toy parsers can be useful in supporting flexible
command languages for programs such as information-retrieval systems.
<a name="%_idx_4974"></a>Winston 1992 discusses computational approaches to real
language understanding and also the applications of simple grammars to
command languages.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_626"><sup><small>53</small></sup></a>
ã“ã®ç¨®ã®æ–‡æ³•ã¯ã€ä»»æ„ã«è¤‡é›‘ãªã‚‚ã®ã«ãªã‚Šå¾—ã‚‹ãŒã€ç¾å®Ÿã®è¨€èªç†è§£ã«é–¢ã™ã‚‹é™ã‚Šã€ãŠã‚‚ã¡ã‚ƒã«éããªã„ã€‚
ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã«ã‚ˆã‚‹ç¾å®Ÿã®è‡ªç„¶è¨€èªç†è§£ã«ã¯ã€æ§‹æ–‡çš„ãªåˆ†æã¨æ„å‘³ã®è§£é‡ˆã®ã€è¾¼ã¿å…¥ã£ãŸæ··åˆç‰©ãŒå¿…è¦ã§ã‚ã‚‹ã€‚
ä¸€æ–¹ã€ãŠã‚‚ã¡ã‚ƒçš„ãªæ§‹æ–‡è§£æå™¨ã§ã•ãˆã‚‚ã€æƒ…å ±æ¤œç´¢ã‚·ã‚¹ãƒ†ãƒ ã®ã‚ˆã†ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ãŸã‚ã®æŸ”è»Ÿãªã‚³ãƒãƒ³ãƒ‰è¨€èªã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã†ãˆã§ã¯ã€æœ‰ç”¨ãŸã‚Šå¾—ã‚‹ã€‚
Winston 1992 ã§ã¯ã€ç¾å®Ÿã®è¨€èªç†è§£ã¸ã®ã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã‚’ç”¨ã„ãŸæ‰‹æ³•ã«ã¤ã„ã¦è­°è«–ã—ã¦ãŠã‚Šã€ã¾ãŸã€å˜ç´”ãªæ–‡æ³•ã®ã‚³ãƒãƒ³ãƒ‰è¨€èªã¸ã®é©ç”¨ã«ã¤ã„ã¦ã‚‚è­°è«–ã—ã¦ã„ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_628" href="#call_footnote_Temp_628"><sup><small>54</small></sup></a> Although Alyssa's idea works just fine (and is
surprisingly simple), the sentences that it generates are a bit
boring -- they don't sample the possible sentences of this language in
a very interesting way.  In fact, the grammar is highly recursive in
many places, and Alyssa's technique ``falls into'' one of these recursions and
gets stuck.  See exercise <a href="#%_thm_4.50">4.50</a> for a way to deal with this.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_628"><sup><small>54</small></sup></a>
ã‚¢ãƒªãƒƒã‚µã®è€ƒãˆã¯ã€ã¾ã•ã«ç”³ã—åˆ†ãªãã†ã¾ãã„ã (ãã‚Œã«é©šãã»ã©ç°¡æ½”ã§ã‚ã‚‹) ã®ã ãŒã€ãã®è€ƒãˆã§ç”Ÿæˆã•ã‚Œã‚‹æ–‡ã¯ã€ã‚„ã‚„é€€å±ˆã§ã‚ã‚‹â€”â€”ãã‚Œã‚‰ã®æ–‡ã¯ã€ã¨ã¦ã‚‚é¢ç™½ã„æ–¹æ³•ã§ã“ã®è¨€èªã®å¯èƒ½ãªæ–‡ã®æ¨™æœ¬ã‚’æŠ½å‡ºã—ã¦ã„ã‚‹ã‚ã‘ã§ã¯ãªã„ã®ã ã€‚
å®Ÿéš›ã€æ–‡æ³•ã¯å¤šãã®å ´æ‰€ã§éå¸¸ã«å†å¸°çš„ã§ã‚ã‚Šã€ã‚¢ãƒªãƒƒã‚µã®æŠ€æ³•ã¯ã€ã“ã‚Œã‚‰ã®å†å¸°ã®ã†ã¡ã®ä¸€ã¤ã«ã€Œè½ã¡è¾¼ã¿ã€ã€ãã“ã‹ã‚‰æŠœã‘å‡ºã›ãªã„ã€‚
ã“ã‚Œã‚’æ‰±ã†ãŸã‚ã®æ–¹æ³•ã«ã¤ã„ã¦ã¯ã€ç·´ç¿’å•é¡Œ<a href="#%_thm_4.50">4.50</a>ã‚’å‚ç…§ã®ã“ã¨ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_629" href="#call_footnote_Temp_629"><sup><small>55</small></sup></a> We chose to implement the lazy evaluator in
section <a href="27_sec4_2.html#%_sec_4.2">4.2</a> as a modification of the ordinary
metacircular evaluator of section <a href="26_sec4_1.html#%_sec_4.1.1">4.1.1</a>.  In
contrast, we will base the <tt>amb</tt> evaluator on the analyzing evaluator
of section <a href="26_sec4_1.html#%_sec_4.1.7">4.1.7</a>, because the execution procedures
in that evaluator provide a convenient framework for implementing
backtracking.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_629"><sup><small>55</small></sup></a>
<a href="27_sec4_2.html#%_sec_4.2">4.2</a>ç¯€ã§ã¯ã€<a href="26_sec4_1.html#%_sec_4.1.1">4.1.1</a>ç¯€ã®æ™®é€šã®ãƒ¡ã‚¿å¾ªç’°çš„ãªè©•ä¾¡å™¨ã®æ”¹å¤‰ç‰ˆã¨ã—ã¦é…å»¶è©•ä¾¡å™¨ã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ã‚’é¸ã‚“ã ã€‚
ãã‚Œã¨ã¯å¯¾ç…§çš„ã«ã€<tt>amb</tt> è©•ä¾¡å™¨ã®åŸºç¤ã¯ã€<a href="26_sec4_1.html#%_sec_4.1.7">4.1.7</a>ç¯€ã®è§£æã‚’è¡Œã†è©•ä¾¡å™¨ã«ç½®ãã“ã¨ã«ã—ã‚ˆã†ã€‚ã¨ã„ã†ã®ã‚‚ã€ãã®è©•ä¾¡å™¨ã§ã®å®Ÿè¡Œæ‰‹ç¶šããŒã€ãƒãƒƒã‚¯ãƒˆãƒ©ãƒƒã‚¯ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã®ä¾¿åˆ©ãªæ çµ„ã¿ã‚’ä¸ãˆã¦ãã‚Œã‚‹ãŸã‚ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_632" href="#call_footnote_Temp_632"><sup><small>56</small></sup></a> We assume that the evaluator supports <tt>let</tt>
(see exercise <a href="26_sec4_1.html#%_thm_4.22">4.22</a>),
which we have used in our nondeterministic programs.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_632"><sup><small>56</small></sup></a>
<tt>let</tt> â€”â€”éæ±ºå®šçš„ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ä½¿ã£ãŸâ€”â€” (ç·´ç¿’å•é¡Œ<a href="26_sec4_1.html#%_thm_4.22">4.22</a>ã‚’å‚ç…§) ã‚’è©•ä¾¡å™¨ãŒã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ã“ã¨ã‚’ä»®å®šã—ã¦ã„ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_636" href="#call_footnote_Temp_636"><sup><small>57</small></sup></a> We didn't worry about undoing definitions, since we can
<a name="%_idx_5010"></a>assume that internal definitions are scanned out
(section <a href="26_sec4_1.html#%_sec_4.1.6">4.1.6</a>).</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_636"><sup><small>57</small></sup></a>
å®šç¾©ã‚’å–ã‚Šæ¶ˆã™ã“ã¨ã«ã¤ã„ã¦ã¯å¿ƒé…ã—ã¦ã„ãªã‹ã£ãŸã€‚ã¨ã„ã†ã®ã‚‚ã€å†…éƒ¨å®šç¾©ã¯èµ°æŸ»ã•ã‚Œå°½ãã™ (<a href="26_sec4_1.html#%_sec_4.1.6">4.1.6</a>ç¯€) ã¨ä»®å®šã§ãã‚‹ãŸã‚ã§ã‚ã‚‹ã€‚
</p>

</div>
</body>
</html>
