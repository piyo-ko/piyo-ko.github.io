<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="sicp.css" type="text/css">
<base target="_top">
<title>SICP私訳: 4.4 論理プログラミング</title>
<link rel="canonical" href="https://piyo-ko.github.io/SICP/29_sec4_4.html" />
</head>
<body>

<div class="idx-bar">
<nav>
<a href="https://twitter.com/share" class="twitter-share-button" data-lang="ja">ツイート</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
<span class="status">翻訳中</span>
[
<a href="00_cover.html">先頭へ</a> |
<a href="28_sec4_3.html">前へ</a> |
<a href="30_chap5.html">次へ</a> |
<a href="04_toc.html#%_toc_start">目次</a> |
<a href="38_index.html#%_index_start">索引</a>
] [<a href="99_about.html">この対訳版について</a> | <a href="../index.html">ホーム</a>]
[
§<a href="#%_sec_4.4">4.4</a>
§<a href="#%_sec_4.4.1">4.4.1</a>
📚<a href="#%_sec_Temp_649">&hellip;</a>
📚<a href="#%_sec_Temp_650">&hellip;</a>
📝<a href="#%_thm_4.55">4.55</a>
📚<a href="#%_sec_Temp_653">&hellip;</a>
📝<a href="#%_thm_4.56">4.56</a>
📚<a href="#%_sec_Temp_657">&hellip;</a>
📝<a href="#%_thm_4.57">4.57</a>
📝<a href="#%_thm_4.58">4.58</a>
📝<a href="#%_thm_4.59">4.59</a>
📝<a href="#%_thm_4.60">4.60</a>
📚<a href="#%_sec_Temp_664">&hellip;</a>
📝<a href="#%_thm_4.61">4.61</a>
📝<a href="#%_thm_4.62">4.62</a>
📝<a href="#%_thm_4.63">4.63</a>
§<a href="#%_sec_4.4.2">4.4.2</a>
📚<a href="#%_sec_Temp_668">&hellip;</a>
📚<a href="#%_sec_Temp_669">&hellip;</a>
🎨<a href="#%_fig_4.4">4.4</a>
📚<a href="#%_sec_Temp_671">&hellip;</a>
🎨<a href="#%_fig_4.5">4.5</a>
🎨<a href="#%_fig_4.6">4.6</a>
📚<a href="#%_sec_Temp_675">&hellip;</a>
📚<a href="#%_sec_Temp_678">&hellip;</a>
📚<a href="#%_sec_Temp_679">&hellip;</a>
📚<a href="#%_sec_Temp_681">&hellip;</a>
§<a href="#%_sec_4.4.3">4.4.3</a>
📚<a href="#%_sec_Temp_685">&hellip;</a>
📚<a href="#%_sec_Temp_687">&hellip;</a>
📝<a href="#%_thm_4.64">4.64</a>
📝<a href="#%_thm_4.65">4.65</a>
📝<a href="#%_thm_4.66">4.66</a>
📝<a href="#%_thm_4.67">4.67</a>
📝<a href="#%_thm_4.68">4.68</a>
📝<a href="#%_thm_4.69">4.69</a>
§<a href="#%_sec_4.4.4">4.4.4</a>
§<a href="#%_sec_4.4.4.1">4.4.4.1</a>
§<a href="#%_sec_4.4.4.2">4.4.4.2</a>
📚<a href="#%_sec_Temp_696">&hellip;</a>
📚<a href="#%_sec_Temp_697">&hellip;</a>
📚<a href="#%_sec_Temp_698">&hellip;</a>
§<a href="#%_sec_4.4.4.3">4.4.4.3</a>
📚<a href="#%_sec_Temp_699">&hellip;</a>
§<a href="#%_sec_4.4.4.4">4.4.4.4</a>
§<a href="#%_sec_4.4.4.5">4.4.4.5</a>
📝<a href="#%_thm_4.70">4.70</a>
§<a href="#%_sec_4.4.4.6">4.4.4.6</a>
§<a href="#%_sec_4.4.4.7">4.4.4.7</a>
§<a href="#%_sec_4.4.4.8">4.4.4.8</a>
📝<a href="#%_thm_4.71">4.71</a>
📝<a href="#%_thm_4.72">4.72</a>
📝<a href="#%_thm_4.73">4.73</a>
📝<a href="#%_thm_4.74">4.74</a>
📝<a href="#%_thm_4.75">4.75</a>
📝<a href="#%_thm_4.76">4.76</a>
📝<a href="#%_thm_4.77">4.77</a>
📝<a href="#%_thm_4.78">4.78</a>
📝<a href="#%_thm_4.79">4.79</a>
<a href="#footnotes">脚注</a>
]</nav>
</div>

<div class="main-txt">
<a name="%_sec_4.4"></a>
<h2 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_4.4">4.4  Logic Programming</a></h2>
<h2 class="trans" lang="ja">4.4 論理プログラミング</h2>

<p class="orig" lang="en">
<a name="%_idx_5028"></a>
<a name="%_idx_5030"></a><a name="%_idx_5032"></a><a name="%_idx_5034"></a><a name="%_idx_5036"></a>In chapter 1 we stressed that computer science deals with imperative
(how to) knowledge, whereas mathematics deals with declarative (what
is) knowledge.  Indeed, programming languages require that the
programmer express knowledge in a form that indicates the step-by-step
methods for solving particular problems.  On the other hand,
high-level languages provide, as part of the language implementation,
a substantial amount of methodological knowledge that frees
the user from concern with numerous details of how a specified
computation will progress.</p>

<p class="trans" lang="ja">
数学は、宣言的な (何であるか、という) 知識を扱うのに対して、計算機科学は、命令的な (どうやって、という) 知識を扱うのだ、ということを、私たちは1章で強調した。
事実、特定の問題を解くための、一歩ずつ進む段階的な方法を示す形でプログラマが知識を表現することを、プログラミング言語は要請する。
一方で、指定された計算がどうやって進行するだろうか、ということについての多くの細目に関する心配からユーザを解き放ってくれる、相当な量の方法論的知識を、高級言語は、言語実装の一部として提供している。
</p>

<p class="orig" lang="en">
Most programming languages, including Lisp, are organized around
computing the values of mathematical functions.  Expression-oriented
languages (such as Lisp, Fortran, and Algol) capitalize on the ``pun''
that an expression that describes the value of a function may also be
interpreted as a means of computing that value.  Because of this, most
programming languages are strongly biased toward unidirectional
computations (computations with well-defined inputs and outputs).
There are, however, radically different programming languages that
relax this bias.  We saw one such example in
section <a href="22_sec3_3.html#%_sec_3.3.5">3.3.5</a>, where the objects of computation were
arithmetic constraints.  In a constraint system the direction and the
order of computation are not so well specified; in carrying out a
computation the system must therefore provide more detailed ``how to''
knowledge than would be the case with an ordinary arithmetic
computation.  This does not mean, however, that the user is released
altogether from the responsibility of providing imperative knowledge.
There are many constraint networks that implement the same set of
constraints, and the user must choose from the set of mathematically
equivalent networks a suitable network to specify a particular
computation.</p>

<p class="trans" lang="ja">
Lisp を含むほとんどのプログラミング言語は、数学的関数の値を計算することを巡って組織化されている。
式指向の言語 (たとえば Lisp や Fortran や Algol など) は、関数の値を記述する式が、その値を計算する手段としても解釈されうる、という「駄洒落」に便乗している。
これが理由で、ほとんどのプログラミング言語は、一方向的な計算 (きちんと定義された入力と出力とを伴う計算) へと強く偏っている。
しかし、この偏りを緩めるような、根本的に異なるプログラミング言語が存在する。
そうした一つの例を、私たちは<a href="22_sec3_3.html#%_sec_3.3.5">3.3.5</a>節で見たわけだが、そこでは計算のオブジェクトとは算術的な制約であった。
制約システムでは、計算の方向と順序は、それほどきちんと指定されない。したがって、システムは、普通の算術計算について当てはまるであろう程度よりも詳細な、「どうやって」という知識を、計算を実行してゆく中で提供せねばらならない。
しかし、これは、命令的な知識を提供する責任からユーザが完全に解放されることを意味するわけではない。
同じ制約集合を実装する多くの制約ネットワークがあり、ユーザは、数学的には等価なネットワークの集合の中から、特定の計算を指定するのに適したネットワークを選ばねばならない。
</p>


<p class="orig" lang="en">
The nondeterministic program evaluator of
section <a href="28_sec4_3.html#%_sec_4.3">4.3</a> also moves away from the
view that programming is about constructing algorithms for computing
unidirectional functions.  In a nondeterministic language, expressions
can have more than one value, and, as a result, the computation is
<a name="%_idx_5038"></a>dealing with relations rather than with
single-valued functions.  Logic programming extends this idea by
combining a relational vision of programming with a powerful kind of
symbolic pattern matching called <em>unification</em>.<a name="call_footnote_Temp_645" href="#footnote_Temp_645"><sup><small>58</small></sup></a></p>

<p class="trans" lang="ja">
<a href="28_sec4_3.html#%_sec_4.3">4.3</a>節の非決定プログラムの評価器も、プログラミングとは一方向的な関数を計算するためのアルゴリズムを構築することについてのものなのだ、という見方から離れていっている。
非決定的言語においては、式が一つよりも多くの値を持つことが可能であり、その結果、計算は、一価関数を扱うというよりむしろ関係を扱っている。
論理プログラミングは、この考えを、プログラミングについての関係型の見方と、<em><ruby><rb>単一化</rb><rp> (</rp><rt>ユニフィケーション</rt><rp>) </rp></ruby></em>と呼ばれる強力な種類の記号的パタン・マッチングとを組み合わせることによって、拡張する<a name="call_footnote_Temp_645" href="#footnote_Temp_645"><sup><small>58</small></sup></a>。
</p>


<p class="orig" lang="en">
<a name="%_idx_5070"></a><a name="%_idx_5072"></a>This approach, when it works, can be a very powerful way to write
programs.  Part of the power comes from the fact that a single ``what
is'' fact can be used to solve a number of different problems that
would have different ``how to'' components.  As an example, consider
the <a name="%_idx_5074"></a><tt>append</tt> operation, which takes two lists as arguments and
combines their elements to form a single list.  In a procedural
language such as Lisp, we could define <tt>append</tt> in terms of the
basic list constructor <tt>cons</tt>, as we did in
section <a href="15_sec2_2.html#%_sec_2.2.1">2.2.1</a>:</p>

<p class="trans" lang="ja">
この手法は、うまくゆくときには、プログラムを書くためのとても強力な方法になれる。
その力の一部は、一つの「何なのか」という事実が、異なる「どうやって」という構成要素を持ちうる多数の異なる問題を解くのに使える、という事実に由来する。
例として、<tt>append</tt> 操作——引数として二つのリストをとって、それらの要素を結合して一つのリストを形成する——を考えてみよう。
Lispのような手続き的言語では、<a href="15_sec2_2.html#%_sec_2.2.1">2.2.1</a>節で行ったように、<tt>cons</tt> という基本的なリスト・コンストラクタを使って <tt>append</tt> を定義できるだろう。
</p>

<p class="lisp">(define (append x y)
  (if (null? x)
      y
      (cons (car x) (append (cdr x) y))))
</p>


<p class="orig" lang="en">This procedure can be regarded as a translation into Lisp of the
following two rules, the first of which covers the case where the
first list is empty and the second of which handles the case of a
nonempty list, which is a <tt>cons</tt> of two parts:</p>

<p class="trans" lang="ja">
この手続きは、以下の二つの規則のLispへの翻訳だと見なせるのだが、これら規則のうち1番目のものは、1番目のリストが空の場合を扱っており、2番目のものは、非空リスト——二つの部分の <tt>cons</tt> である——の場合を扱っている。
</p>

<ul class="orig" lang="en">
<li>For any list <tt>y</tt>, the empty list and <tt>y</tt> <tt>append</tt> to form <tt>y</tt>.</li>

<li>For any <tt>u</tt>,  <tt>v</tt>,  <tt>y</tt>, and <tt>z</tt>,
 <tt>(cons u v)</tt> and <tt>y</tt> <tt>append</tt> to form <tt>(cons u z)</tt>
if <tt>v</tt> and <tt>y</tt> <tt>append</tt> to form <tt>z</tt>.<a name="call_footnote_Temp_646" href="#footnote_Temp_646"><sup><small>59</small></sup></a></li>
</ul>

<ul class="trans" lang="ja">
<li>任意のリスト <tt>y</tt> について、空リストと <tt>y</tt> は、<tt>append</tt> して <tt>y</tt> となる。</li>
<li>任意の <tt>u</tt> と <tt>v</tt> と <tt>y</tt> と <tt>z</tt> について、もし <tt>v</tt> と <tt>y</tt> が <tt>append</tt> して <tt>z</tt> となるなら、<tt>(cons u v)</tt> と <tt>y</tt> は、<tt>append</tt> して <tt>(cons u z)</tt> となる<a href="#footnote_Temp_646"><sup><small>59</small></sup></a>。</li>
</ul>

<div class="exercise">
<table class="expl ex_comment">
<tr><th colspan="2"><tt>x</tt> が非空の場合の対応表</th></tr>
<tr><th>手続き</th><th>規則</th></tr>
<tr><td><tt>x</tt></td><td><tt>(cons u v)</tt></td></tr>
<tr><td><tt>y</tt></td><td><tt>y</tt></td></tr>
<tr><td><tt>(car x)</tt></td><td><tt>u</tt></td></tr>
<tr><td><tt>(cdr x)</tt></td><td><tt>v</tt></td></tr>
<tr><td><tt>(append (cdr x) y)</tt><br>&nbsp;</td><td><tt>(append v y)</tt> すなわち<br><tt>z</tt></td></tr>
<tr><td><tt>(append x y)</tt> すなわち<br><tt>(cons (car x) (append (cdr x) y))</tt></td><td><tt>(append (cons u v) y)</tt> すなわち<br><tt>(cons u z)</tt></td></tr>
</table>
</div>

<p class="orig" lang="en">
Using the <tt>append</tt> procedure, we can answer questions such as
</p>

<p class="trans" lang="ja">
この <tt>append</tt> の手続きを使うと、以下のような質問に答えられる。
</p>

<blockquote class="orig" lang="en">
Find the <tt>append</tt> of <tt>(a b)</tt> and <tt>(c d)</tt>.
</blockquote>

<blockquote class="trans" lang="ja">
<tt>(a b)</tt> と <tt>(c d)</tt> の <tt>append</tt> を求めよ。
</blockquote>

<p class="orig" lang="en">
But the same two rules are also sufficient for answering the following
sorts of questions, which the procedure can't answer:</p>

<p class="trans" lang="ja">
しかし、以下のような種類の質問——この手続きでは答えられないもの——に答えるためにも、同じ二つの規則で十分なのだ。
</p>

<blockquote class="orig" lang="en">
<div>
Find a list <tt>y</tt> that <tt>append</tt>s with <tt>(a b)</tt> 
to produce <tt>(a b c d)</tt>.
</div>
<br>
<div>
Find all <tt>x</tt> and <tt>y</tt> that <tt>append</tt> to form <tt>(a b c
d)</tt>.
</div>
</blockquote>

<blockquote class="trans" lang="ja">
<div>
<tt>(a b)</tt> に <tt>append</tt> して <tt>(a b c d)</tt> を作り出すような、<tt>y</tt> というリストを求めよ。
</div>
<br>
<div>
<tt>append</tt> して <tt>(a b c d)</tt> を作り出すような、すべての <tt>x</tt> と <tt>y</tt> を求めよ。
</div>
</blockquote>

<p class="orig" lang="en">
<a name="%_idx_5076"></a><a name="%_idx_5078"></a>In a logic programming language, the programmer writes an <tt>append</tt>
``procedure'' by stating the two rules about <tt>append</tt> given above.
``How to'' knowledge is provided automatically by the interpreter to
allow this single pair of rules to be used to answer all three types
of questions about <tt>append</tt>.<a name="call_footnote_Temp_647" href="#footnote_Temp_647"><sup><small>60</small></sup></a></p>

<p class="trans" lang="ja">
論理プログラミング言語では、プログラマは、上記のような <tt>append</tt> についての二つの規則を述べることによって、<tt>append</tt> の「手続き」を書く。
「どうやって」の知識は、このたった一対の規則を <tt>append</tt> についての三つすべての種類の質問に答えるのに使えるようにするよう、インタプリタによって自動的に与えられる<a href="#footnote_Temp_647"><sup><small>60</small></sup></a>。
</p>

<p class="orig" lang="en">
Contemporary logic programming languages (including the one we
implement here) have substantial deficiencies, in that their general
``how to'' methods can lead them into spurious infinite loops or other
undesirable behavior.
Logic programming is an active field of research in computer science.<a name="call_footnote_Temp_648" href="#footnote_Temp_648"><sup><small>61</small></sup></a></p>

<p class="trans" lang="ja">
現代の論理プログラミング言語 (ここで私たちが実装するものも含む) には、それら言語の一般的な「どうやって」の方法のせいでそれら言語が見かけ上の無限ループまたは他の望ましからぬ振る舞いへと陥りかねない、<!--それら言語の一般的な「どうやって」の方法が、見かけ上の無限ループまたは他の望ましからぬ振る舞いへと、それら言語を導いていきかねない-->という意味において、相当な欠陥がある。
論理プログラミングは、計算機科学における活発な研究領域である<a href="#footnote_Temp_648"><sup><small>61</small></sup></a>。
</p>




<p class="orig" lang="en">
Earlier in this chapter we explored the technology of implementing
interpreters and described the elements that are essential to an
interpreter for a Lisp-like language (indeed, to an interpreter for
any conventional language).  Now we will apply these ideas to discuss
an interpreter for a logic programming language.  We call this
<a name="%_idx_5090"></a>language the <em>query language</em>, because it is very useful for
retrieving information from data bases by formulating <a name="%_idx_5092"></a><em>queries</em>,
or questions, expressed in the language.  Even though the query
language is very different from Lisp, we will find it convenient to
describe the language in terms of the same general framework we have
been using all along: as a collection of primitive elements, together
with means of combination that enable us to combine simple elements to
create more complex elements and means of abstraction that enable us
to regard complex elements as single conceptual units.  An interpreter
for a logic programming language is considerably more complex than an
interpreter for a language like Lisp.  Nevertheless, we will see
<a name="%_idx_5094"></a>that our query-language interpreter contains many of the same elements
found in the interpreter of section <a href="26_sec4_1.html#%_sec_4.1">4.1</a>.  In particular,
there will be an ``eval'' part that classifies expressions according
to type and an ``apply'' part that implements the language's
abstraction mechanism (procedures in the case of Lisp, and <em>rules</em>
in the case of logic programming).  Also, a central role is played in
the implementation by a frame data structure, which determines the
correspondence between symbols and their associated values.  One
additional interesting aspect of our query-language implementation is
that we make substantial use of streams, which were introduced in
chapter 3.</p>

<p class="trans" lang="ja">
本章の最初の方で、私たちは、インタプリタを実装する技術を探査し、Lisp 的な言語のインタプリタにとって (実は、従来のどの言語のインタプリタにとっても) 必須の要素について記述した。
さてここからは、論理プログラミング言語のインタプリタについて議論するために、これらの考え方を適用しよう。
この言語のことを、<em>クエリ言語</em>と呼ぶ。なぜなら、この言語は、この言語で表現された<em>クエリ</em>——すなわち質問——を定式化することでデータベースから情報を検索するのに、大変有用だからである。
たとえクエリ言語が Lisp とは全然違っていてさえも、この言語を、私たちが最初からずっと使ってきている同じ一般的な枠組みで記述するのが——つまり、単純な要素同士を結合してより複雑な要素を作ることを可能にしてくれる結合手段と、複雑な要素を単一の概念的単位と見なすことを可能にしてくれる抽象化手段とを備えた、原始的要素の集まりとして、記述することが——便利だということに、私たちは気づくことになるだろう。
論理プログラミング言語のインタプリタは、Lisp のような言語のインタプリタよりも、ずっと複雑である。
それにもかかわらず、私たちのクエリ言語用インタプリタが、<a href="26_sec4_1.html#%_sec_4.1">4.1</a>節のインタプリタに見られるのと同じ要素のうちの多くを含むということを、私たちは見ることになるだろう。
とりわけ、型にしたがって式を分類する「<ruby><rb>評価</rb><rp> (</rp><rt>eval</rt><rp>) </rp></ruby>」部分と、言語の抽象化機構を実装する「<ruby><rb>適用</rb><rp> (</rp><rt>apply</rt><rp>) </rp></ruby>」部分 (Lisp の場合には手続きであり、論理プログラミングの場合には<em>規則</em>である) が存在するであろう。
また、中心的役割は、フレーム・データ構造——<ruby><rb>記号</rb><rp> (</rp><rt>シンボル</rt><rp>) </rp></ruby>とそれに関連づけられた値との対応関係を決定する——において果たされる。
私たちのクエリ言語の実装の、一つの付加的な面白い側面は、ストリーム——3章で導入したもの——を事実上利用する、という点である。
</p>

<a name="%_sec_4.4.1"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_4.4.1">4.4.1  Deductive Information Retrieval</a></h3>
<h3 class="trans" lang="ja">4.4.1 演繹的な情報検索</h3>

<p class="orig" lang="en"><a name="%_idx_5096"></a>
<a name="%_idx_5098"></a>Logic programming excels in providing interfaces to data bases for
information retrieval.  The query language we shall implement in this
chapter is designed to be used in this way.</p>

<p class="trans" lang="ja">
論理プログラミングは、情報検索用のデータベースに対するインタフェイスを提供することに秀でている。
私たちが本章で実装することになるクエリ言語は、こうした方法で使われるように設計されている。
</p>

<p class="orig" lang="en">
In order to illustrate what the query system does, we will show how it
can be used to manage the data base of personnel records for
<a name="%_idx_5100"></a>Microshaft, a thriving high-technology company in the
Boston area.  The language provides pattern-directed access to
personnel information and can also take advantage of general rules in
order to make logical deductions.</p>

<p class="trans" lang="ja">
クエリ・システムが何をするのかを例解するために、私たちは、ボストン地区の成長中のハイテク企業であるマイクロシャフト社のための人事記録のデータベースを管理するのにクエリ・システムをどのように使えるのか、ということを示そう。
この言語によって、人事情報へのパタン指向のアクセス権が提供され、また、この言語は、論理的演繹を行うために一般的規則を利用することができる。
</p>

<a name="%_sec_Temp_649"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_649">A sample data base</a></h4>
<h4 class="trans" lang="ja">サンプル・データベース</h4>

<p class="orig" lang="en">
<a name="%_idx_5102"></a>
<a name="%_idx_5104"></a><a name="%_idx_5106"></a>The personnel data base for Microshaft
contains <em>assertions</em> about company personnel.  Here is the
information about Ben Bitdiddle, the resident computer wizard:</p>

<p class="trans" lang="ja">
マイクロシャフト社の人事データベースは、会社職員についての<em><ruby><rb>言明</rb><rp> (</rp><rt>アサーション</rt><rp>) </rp></ruby></em>を含む。
ここに、専任コンピュータ魔術師のベン・ビットディドルについての情報がある。
</p>

<p class="lisp">(address (Bitdiddle Ben) (Slumerville (Ridge Road) 10))
(job (Bitdiddle Ben) (computer wizard))
(salary (Bitdiddle Ben) 60000)
</p>

<!--
<p class="exercise ex_comment">(住所 (ビットディドル ベン) (スラマーヴィル (リッジ街) 10))
(仕事 (ビットディドル ベン) (コンピュータ 魔術師))
(給与 (ビットディドル ベン) 60000)
</p>
-->

<p class="orig" lang="en">Each assertion is a list (in this case a triple) whose elements can
themselves be lists.</p>

<p class="trans" lang="ja">
各言明は、その要素自体もリストであり得るようなリスト (この例では三つ組) である。
</p>

<p class="orig" lang="en">
As resident wizard, Ben is in charge of the company's computer
division, and he supervises two programmers and one technician.  Here
is the information about them:</p>

<p class="trans" lang="ja">
専任魔術師として、ベンは、会社のコンピュータ部門に責任があり、二人のプログラマと一人の技師を指揮監督している。
ここに、その人たちについての情報がある。
</p>

<p class="lisp">(address (Hacker Alyssa P) (Cambridge (Mass Ave) 78))
(job (Hacker Alyssa P) (computer programmer))
(salary (Hacker Alyssa P) 40000)
(supervisor (Hacker Alyssa P) (Bitdiddle Ben))
(address (Fect Cy D) (Cambridge (Ames Street) 3))
(job (Fect Cy D) (computer programmer))
(salary (Fect Cy D) 35000)
(supervisor (Fect Cy D) (Bitdiddle Ben))
(address (Tweakit Lem E) (Boston (Bay State Road) 22))
(job (Tweakit Lem E) (computer technician))
(salary (Tweakit Lem E) 25000)
(supervisor (Tweakit Lem E) (Bitdiddle Ben))
</p>

<p class="orig" lang="en">There is also a programmer trainee, who is supervised by Alyssa:
</p>

<p class="trans" lang="ja">
プログラマ見習いもいて、その人はアリッサにより監督されている。
</p>

<p class="lisp">(address (Reasoner Louis) (Slumerville (Pine Tree Road) 80))
(job (Reasoner Louis) (computer programmer trainee))
(salary (Reasoner Louis) 30000)
(supervisor (Reasoner Louis) (Hacker Alyssa P))
</p>

<p class="orig" lang="en">All of these people are in the computer division, as indicated by the
word <tt>computer</tt> as the first item in their job descriptions.</p>

<p class="trans" lang="ja">
これらの人たちのすべては、仕事の記述における1番目の項目としての <tt>computer</tt> という語によって示されるとおり、コンピュータ部門にいる。
</p>

<p class="orig" lang="en">
Ben is a high-level employee.  His supervisor is the company's big
wheel himself:</p>

<p class="trans" lang="ja">
ベンは上級社員である。
彼の上司は、その人自体がこの会社の大物である。
</p>

<p class="lisp">(supervisor (Bitdiddle Ben) (Warbucks Oliver))
(address (Warbucks Oliver) (Swellesley (Top Heap Road)))
(job (Warbucks Oliver) (administration big wheel))
(salary (Warbucks Oliver) 150000)
</p>


<p class="orig" lang="en">
Besides the computer division supervised by Ben, the company has an
accounting division, consisting of a chief accountant and his
assistant:</p>

<p class="trans" lang="ja">
ベンにより監督されているコンピュータ部門のほかに、この会社には会計部門があり、主席会計士と彼の助手から構成されている。
</p>

<p class="lisp">(address (Scrooge Eben) (Weston (Shady Lane) 10))
(job (Scrooge Eben) (accounting chief accountant))
(salary (Scrooge Eben) 75000)
(supervisor (Scrooge Eben) (Warbucks Oliver))
(address (Cratchet Robert) (Allston (N Harvard Street) 16))
(job (Cratchet Robert) (accounting scrivener))
(salary (Cratchet Robert) 18000)
(supervisor (Cratchet Robert) (Scrooge Eben))
</p>


<p class="orig" lang="en">There is also a secretary for the big wheel:</p>

<p class="trans" lang="ja">
大物のための秘書もいる。
</p>

<p class="lisp">(address (Aull DeWitt) (Slumerville (Onion Square) 5))
(job (Aull DeWitt) (administration secretary))
(salary (Aull DeWitt) 25000)
(supervisor (Aull DeWitt) (Warbucks Oliver))
</p>

<p class="orig" lang="en">
The data base also contains assertions about which kinds of jobs can
be done by people holding other kinds of jobs.  For instance, a
computer wizard can do the jobs of both a computer programmer and a
computer technician:</p>

<p class="trans" lang="ja">
このデータベースは、他の仕事を抱えている人たちによってどの種類の仕事をなし得るのか、ということについての言明も含む。
たとえば、コンピュータ魔術師は、コンピュータ・プログラマとコンピュータ技師の双方の仕事を行うことができる。
</p>

<p class="lisp">(can-do-job (computer wizard) (computer programmer))
(can-do-job (computer wizard) (computer technician))
</p>

<p class="orig" lang="en">A computer programmer could fill in for a trainee:
</p>

<p class="trans" lang="ja">
コンピュータ・プログラマは、見習いの代わりができるだろう。
</p>

<p class="lisp">(can-do-job (computer programmer)
            (computer programmer trainee))
</p>

<p class="orig" lang="en"><a name="%_idx_5108"></a>Also, as is well known,
</p>

<p class="trans" lang="ja">
また、以下のことはよく知られているとおりである<span class="note"> (ここは笑うところだよ)</span>。
</p>

<p class="lisp">(can-do-job (administration secretary)
            (administration big wheel))
</p>

<p class="extra">
ここから先は Prolog で答え合わせをしながら読むといいかな、と思う (とりあえず GNU Prolog を使う)。
そこで、以下のような記述を含む<a href="personnel_db.pl">ファイル</a> (<tt>personnel_db.pl</tt>) を作った。なお、このファイルには後出の規則も含めてある。
</p>

<p class="extra_code"><span class="ex_comment">% GNU Prologでは、同じ述語を連続して (まとめて) 記述しておかないと
% 「discontiguous predicate address/2 - clause ignored」
% のようなエラーが出るので、それを回避するためのおまじない。</span>
:- discontiguous(address/2, job/2, salary/2, supervisor/2, can_do_job/2).

address(['Bitdiddle', 'Ben'], ['Slumerville', ['Ridge', 'Road'], 10]).
job(['Bitdiddle', 'Ben'], [computer, wizard]).
salary(['Bitdiddle', 'Ben'], 60000).

address(['Hacker', 'Alyssa', 'P'], ['Cambridge', ['Mass', 'Ave'], 78]).
job(['Hacker', 'Alyssa', 'P'], [computer, programmer]).
salary(['Hacker', 'Alyssa', 'P'], 40000).
supervisor(['Hacker', 'Alyssa', 'P'], ['Bitdiddle', 'Ben']).

address(['Fect', 'Cy', 'D'], ['Cambridge', ['Ames', 'Street'], 3]).
job(['Fect', 'Cy', 'D'], [computer, programmer]).
salary(['Fect', 'Cy', 'D'], 35000).
supervisor(['Fect', 'Cy', 'D'], ['Bitdiddle', 'Ben']).

address(['Tweakit', 'Lem', 'E'], ['Boston', ['Bay', 'State', 'Road'], 22]).
job(['Tweakit', 'Lem', 'E'], [computer, technician]).
salary(['Tweakit', 'Lem', 'E'], 25000).
supervisor(['Tweakit', 'Lem', 'E'], ['Bitdiddle', 'Ben']).

address(['Reasoner', 'Louis'], ['Slumerville', ['Pine', 'Tree', 'Road'], 80]).
job(['Reasoner', 'Louis'], [computer, programmer, trainee]).
salary(['Reasoner', 'Louis'], 30000).
supervisor(['Reasoner', 'Louis'], ['Hacker', 'Alyssa', 'P']).

supervisor(['Bitdiddle', 'Ben'], ['Warbucks', 'Oliver']).

address(['Warbucks', 'Oliver'], ['Swellesley', ['Top', 'Heap', 'Road']]).
job(['Warbucks', 'Oliver'], [administration, big, wheel]).
salary(['Warbucks', 'Oliver'], 150000).

address(['Scrooge', 'Eben'], ['Weston', ['Shady', 'Lane'], 10]).
job(['Scrooge', 'Eben'], [accounting, chief, accountant]).
salary(['Scrooge', 'Eben'], 75000).
supervisor(['Scrooge', 'Eben'], ['Warbucks', 'Oliver']).

address(['Cratchet', 'Robert'], ['Allston', ['N', 'Harvard', 'Street'], 16]).
job(['Cratchet', 'Robert'], [accounting, scrivener]).
salary(['Cratchet', 'Robert'], 18000).
supervisor(['Cratchet', 'Robert'], ['Scrooge', 'Eben']).

address(['Aull', 'DeWitt'], ['Slumerville', ['Onion', 'Square'], 5]).
job(['Aull', 'DeWitt'], [administration, secretary]).
salary(['Aull', 'DeWitt'], 25000).
supervisor(['Aull', 'DeWitt'], ['Warbucks', 'Oliver']).

can_do_job([computer, wizard], [computer, programmer]).
can_do_job([computer, wizard], [computer, technician]).
can_do_job([computer, programmer], [computer, programmer, trainee]).
can_do_job([administration, secretary], [administration, big, wheel]).
</p>

<p class="extra">以下のように実行し、ファイルを読み込む。
<br>
<tt>$ gprolog<br>
| ?- consult('personnel_db.pl').</tt> 
<br>
ここから先は、クエリを打ち込むと答えが出てくる。
あるいは、
<br>
<tt>$ gprolog --consult-file personnel_db.pl</tt>
<br>
としてもよい。
</p>

<a name="%_sec_Temp_650"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_650">Simple queries</a></h4>
<h4 class="trans" lang="ja">単純クエリ</h4>


<p class="orig" lang="en">
<a name="%_idx_5110"></a>
The query language allows users to retrieve information from the data
base by posing queries in response to the system's prompt.  For
example, to find all computer programmers one can say</p>

<p class="trans" lang="ja">
クエリ言語によって、ユーザは、システムのプロンプトに応答してクエリを提示することでデータベースから情報を検索することが可能となる。
たとえば、すべてのコンピュータ・プログラマを見つけるために、次のように言うことができる。
</p>

<p class="lisp"><i>;;; Query input:</i>
(job ?x (computer programmer))
</p>

<p class="orig" lang="en">The system will respond with the following items:</p>

<p class="trans" lang="ja">
システムは、以下の項目でもって応答するだろう。
</p>

<p class="lisp"><i>;;; Query results:</i>
(job (Hacker Alyssa P) (computer programmer))
(job (Fect Cy D) (computer programmer))
</p>

<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。</span>
| ?- job(X, [computer, programmer]).

X = ['Hacker','Alyssa','P'] ? ;

X = ['Fect','Cy','D'] ? ;

no</p>

<p class="orig" lang="en">
<a name="%_idx_5112"></a>The input query specifies that we are looking for entries in the data
base that match a certain <em>pattern</em>.  In this example, the pattern
specifies entries consisting of three items, of which the first is the
literal symbol <tt>job</tt>, the second can be anything, and the third is
the literal list <tt>(computer programmer)</tt>.  The ``anything'' that
can be the second item in the matching list is specified by a <a name="%_idx_5114"></a><em>pattern variable</em>, <tt>?x</tt>.  The general form of a pattern variable
is a symbol, taken to be the name of the variable, preceded by a
question mark.  We will see below why it is useful to specify names
for pattern variables rather than just putting <tt>?</tt> into patterns
to represent ``anything.''  The system responds to a simple query by
showing all entries in the data base that match the specified pattern.</p>

<p class="trans" lang="ja">
入力クエリは、ある<em>パタン</em>に合致する、データベース内のエントリを探しているところなのだ、ということを指定している。
この例では、そのパタンは、3項目からなるエントリを指定しており、それら3項目のうち、1番目は <tt>job</tt> というリテラル記号であり、2番目は<!-- 任意のものであってよく -->何でもよく、3番目は <tt>(computer programmer)</tt> というリテラル・リストである。
マッチング・リストにおける2番目の項目になり得る「<!-- 任意のもの -->何か」は、<em>パタン変数</em>により、すなわち、<tt>?x</tt> により、指定されている。
パタン変数の一般形は、疑問符が先に付いていて、変数の名前としてとられるべき、記号である。
「<!-- 任意のもの -->何か」を表現するのに、単に <tt>?</tt> をパタンの中に置くのではなく、<!--むしろ-->パタン変数の名前を指定することが、なぜ有用なのかは、後に分かるだろう。
単純クエリに対して、システムは、指定されたパタンに合致する、データベース内の全エントリを示すことによって、応答する。
</p>

<p class="orig" lang="en">
A pattern can have more than one variable.  For example, the query
</p>

<p class="trans" lang="ja">
パタンは、変数を一つより多く含み得る。たとえば、以下のクエリは、
</p>

<p class="lisp">(address ?x ?y)
</p>

<p class="orig" lang="en">will list all the employees' addresses.</p>

<p class="trans" lang="ja">
全職員の住所を列挙するだろう。
</p>

<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。</span>
| ?- address(X, Y).

X = ['Bitdiddle','Ben']
Y = ['Slumerville',['Ridge','Road'],10] ? ;

X = ['Hacker','Alyssa','P']
Y = ['Cambridge',['Mass','Ave'],78] ? ;

X = ['Fect','Cy','D']
Y = ['Cambridge',['Ames','Street'],3] ? ;

X = ['Tweakit','Lem','E']
Y = ['Boston',['Bay','State','Road'],22] ? ;

X = ['Reasoner','Louis']
Y = ['Slumerville',['Pine','Tree','Road'],80] ? ;

X = ['Warbucks','Oliver']
Y = ['Swellesley',['Top','Heap','Road']] ? ;

X = ['Scrooge','Eben']
Y = ['Weston',['Shady','Lane'],10] ? ;

X = ['Cratchet','Robert']
Y = ['Allston',['N','Harvard','Street'],16] ? ;

X = ['Aull','DeWitt']
Y = ['Slumerville',['Onion','Square'],5]

(1 ms) yes</p>

<p class="orig" lang="en">
A pattern can have no variables, in which case the query simply
determines whether that pattern is an entry in the data base.  If so,
there will be one match; if not, there will be no matches.</p>

<p class="trans" lang="ja">
パタンに変数がないこともあり得て、その場合、クエリは単に、そのパタンがデータベース内のエントリであるかどうかを判定する。
もしそうなら<span class="note"> (そのパタンがデータベース内のエントリであるならば)</span>、一つの一致があるだろうし、そうでなければ、何も一致がないだろう。
</p>


<p class="orig" lang="en">
The same pattern variable can appear more than once in a query,
specifying that the same ``anything'' must appear in each position.
This is why variables have names.  For example,</p>

<p class="trans" lang="ja">
同じ「何か」が各位置に現れなくてはならない、と指定するために、同じパタン変数がクエリ内に一度より多く現れることも可能である。
これが、変数に名前がついている理由である。
たとえば、
</p>

<p class="lisp">(supervisor ?x ?x)
</p>

<p class="orig" lang="en">finds all people who supervise themselves (though there are no such
assertions in our sample data base).</p>

<p class="trans" lang="ja">
は、自分自身を指揮監督しているすべての人たちを見つける (私たちのサンプル・データベースにはそういう言明は存在しないけれども)。
</p>

<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。</span>
| ?- supervisor(X, X).

no
</p>

<p class="orig" lang="en">
The query
</p>

<p class="trans" lang="ja">
以下のクエリは、
</p>

<p class="lisp">(job ?x (computer ?type))
</p>

<p class="orig" lang="en">matches all job entries whose third item is a two-element list whose
first item is <tt>computer</tt>:</p>

<p class="trans" lang="ja">
1番目の項目が <tt>computer</tt> であるような2要素リストを3番目の項目としている、すべての仕事エントリに、合致する。
</p>

<p class="lisp">(job (Bitdiddle Ben) (computer wizard))
(job (Hacker Alyssa P) (computer programmer))
(job (Fect Cy D) (computer programmer))
(job (Tweakit Lem E) (computer technician))
</p>

<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。</span>
| ?- job(X, [computer, Type]).

Type = wizard
X = ['Bitdiddle','Ben'] ? ;

Type = programmer
X = ['Hacker','Alyssa','P'] ? ;

Type = programmer
X = ['Fect','Cy','D'] ? ;

Type = technician
X = ['Tweakit','Lem','E'] ? ;

(1 ms) no
</p>

<p class="orig" lang="en">This same pattern does <em>not</em> match
</p>

<p class="trans" lang="ja">
この同じパタンは、以下のものには合致<em>しない</em>。
</p>

<p class="lisp">(job (Reasoner Louis) (computer programmer trainee))
</p>



<p class="orig" lang="en">because the third item in the entry is a list of three elements, and
the pattern's third item specifies that there should be two elements.
If we wanted to change the pattern so that the third item could be any
list beginning with <tt>computer</tt>, we could specify<a name="%_idx_5116"></a><a name="call_footnote_Temp_651" href="#footnote_Temp_651"><sup><small>62</small></sup></a></p>

<p class="trans" lang="ja">
なぜなら、このエントリの3番目の項目は、3個の要素からなるリストであり、かつ、上記パタンの3番目の項目は、2個の要素があるべき旨を指定しているからである。
もし、3番目の項目が <tt>computer</tt> から始まる任意のリストであってもよいように、パタンを変更したかったら、次のように指定できるだろう<a href="#footnote_Temp_651"><sup><small>62</small></sup></a>。
</p>

<p class="lisp">(job ?x (computer . ?type))
</p>

<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。</span>
| ?- job(X, [computer | Type]).

Type = [wizard]
X = ['Bitdiddle','Ben'] ? ;

Type = [programmer]
X = ['Hacker','Alyssa','P'] ? ;

Type = [programmer]
X = ['Fect','Cy','D'] ? ;

Type = [technician]
X = ['Tweakit','Lem','E'] ? ;

Type = [programmer,trainee]
X = ['Reasoner','Louis'] ? ;

no</p>

<p class="orig" lang="en">For example,
</p>

<p class="trans" lang="ja">
たとえば、
</p>

<p class="lisp">(computer . ?type)
</p>

<p class="orig" lang="en">matches the data</p>

<p class="trans" lang="ja">
は、次のデータに合致し、
</p>

<p class="lisp">(computer programmer trainee)
</p>


<p class="orig" lang="en">with <tt>?type</tt> as the list <tt>(programmer trainee)</tt>.  It also
matches the data</p>

<p class="trans" lang="ja">
その際、<tt>?type</tt> は <tt>(programmer trainee)</tt> というリストである。
これは、次のデータにも合致し、
</p>

<p class="lisp">(computer programmer)
</p>

<p class="orig" lang="en">with <tt>?type</tt> as the list <tt>(programmer)</tt>, and matches the data</p>

<p class="trans" lang="ja">
その際、<tt>?type</tt> は <tt>(programmer)</tt> というリストである。また、以下のデータにも合致し、
</p>

<p class="lisp">(computer)
</p>

<p class="orig" lang="en">
with <tt>?type</tt> as the empty list <tt>()</tt>.
</p>

<p class="trans" lang="ja">
その際、<tt>?type</tt> は空リスト <tt>()</tt> である。
</p>


<p class="orig" lang="en">
We can describe the query language's processing of simple queries as
follows:</p>

<p class="trans" lang="ja">
このクエリ言語の、単純クエリの処理は、次のように記述できる。
</p>


<ul class="orig" lang="en">
<li>The system finds all assignments to variables in the query
<a name="%_idx_5118"></a>pattern that <em>satisfy</em> the pattern -- that is, all sets of values
for the variables such that if the pattern variables are <a name="%_idx_5120"></a><em>instantiated with</em> (replaced by) the values, the result is in the data
base.</li>

<li>The system responds to the query by listing all instantiations of the
query pattern with the variable assignments that satisfy it.</li>
</ul>

<ul class="trans" lang="ja">
<li>パタンを<em>満たす</em>ような、クエリ・パタン内の変数へのすべての<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>——つまり、もしパタン変数がその値<em>でインスタンス化された</em> (その値に置き換えられた) としたら、その結果はデータベース内にあるよ、というような、変数に対する値の集合すべて——を、システムは見つける。</li>
<li>クエリ・パタンを満たす変数<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>での、クエリ・パタンのすべての<ruby><rb>インスタンス化</rb><rp> (</rp><rt>具体例</rt><rp>) </rp></ruby>を列挙することによって、システムはクエリに応答する。</li>
</ul>

<p class="orig" lang="en">
Note that if the pattern has no variables, the query reduces to a
determination of whether that pattern is in the data base.  If so, the
empty assignment, which assigns no values to variables, satisfies that
pattern for that data base.</p>

<p class="trans" lang="ja">
もしパタンに変数がなければ、クエリは、そのパタンがデータベース内にあるか否かという判定へと帰着するのだ、ということに注意してほしい。
もし<span class="note"> (そのパタンがデータベース内に) </span>あれば、空の<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>——変数に何の値も割り当てない——が、そのデータベースについての当該パタンを満たす。
</p>


<p class="orig" lang="en">
<a name="%_thm_4.55"></a>
<b>Exercise 4.55.</b>  Give simple queries that retrieve the following information from the
data base:</p>

<p class="trans" lang="ja">
<b>練習問題4.55.</b> データベースから以下の情報を検索する単純クエリを示せ。
</p>

<ol class="orig alph" lang="en">
<li>all people supervised by Ben Bitdiddle;</li>
<li>the names and jobs of all people in the accounting division;</li>
<li>the names and addresses of all people who live 
in Slumerville.</li>
</ol>

<ol class="trans alph" lang="ja">
<li>ベン・ビットディドルにより指揮監督されているすべての人たち</li>
<li>会計部門のすべての人たちの名前と仕事</li>
<li>スラマーヴィルに住んでいるすべての人たちの名前と住所</li>
</ol>

<p class="exercise"><span class="ex_comment">; a</span>
(supervisor ?name (Bitdiddle Ben))</p>

<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。</span>
| ?- supervisor(Name, ['Bitdiddle', 'Ben']).

Name = ['Hacker','Alyssa','P'] ? ;

Name = ['Fect','Cy','D'] ? ;

Name = ['Tweakit','Lem','E'] ? ;

no</p>

<p class="exercise"><span class="ex_comment">; b</span>
(job ?name (accounting . ?type))</p>

<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。</span>
| ?- job(Name, [accounting | Type]).

Name = ['Scrooge','Eben']
Type = [chief,accountant] ? ;

Name = ['Cratchet','Robert']
Type = [scrivener] ? ;

(1 ms) no</p>

<p class="exercise"><span class="ex_comment">; c</span>
(address ?name (Slumerville . ?x))
</p>

<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。</span>
| ?- address(Name, ['Slumerville' | X]).

Name = ['Bitdiddle','Ben']
X = [['Ridge','Road'],10] ? ;

Name = ['Reasoner','Louis']
X = [['Pine','Tree','Road'],80] ? ;

Name = ['Aull','DeWitt']
X = [['Onion','Square'],5]

yes</p>

<a name="%_sec_Temp_653"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_653">Compound queries</a></h4>
<h4 class="trans" lang="ja">複合クエリ</h4>

<p class="orig" lang="en">
<a name="%_idx_5122"></a>
Simple queries form the primitive operations of the query language.
In order to form compound operations, the query language provides
means of combination.  One thing that makes the query language a logic
programming language is that the means of combination mirror the means
of combination used in forming logical expressions: <tt>and</tt>, <tt>or</tt>, and <tt>not</tt>.  (Here <tt>and</tt>, <tt>or</tt>, and <tt>not</tt> are not
the Lisp primitives, but rather operations built into the query
language.)</p>

<p class="trans" lang="ja">
単純クエリは、クエリ言語の原始的演算を形成している。
複合的演算を形成するために、クエリ言語は結合手段を提供する。
クエリ言語を論理プログラミング言語たらしめる一つの事柄は、その結合手段が、論理式を形成するのに使われる結合手段——すなわち、<tt>and</tt> と <tt>or</tt> と <tt>not</tt>——を反映していることである (ここでの <tt>and</tt> と <tt>or</tt> と <tt>not</tt> は、Lispのプリミティブではなくて、クエリ言語に組み込まれている演算である)。
</p>

<p class="orig" lang="en">
<a name="%_idx_5124"></a>We can use <tt>and</tt> as follows to find the addresses of all the
computer programmers:</p>

<p class="trans" lang="ja">
コンピュータ・プログラマ全員の住所を求めるために、<tt>and</tt> を次のように使うことができる。
</p>

<p class="lisp">(and (job ?person (computer programmer))
     (address ?person ?where))
</p>

<p class="orig" lang="en">The resulting output is
</p>

<p class="trans" lang="ja">
その結果得られる出力は、以下のとおりだ。
</p>

<p class="lisp">(and (job (Hacker Alyssa P) (computer programmer))
     (address (Hacker Alyssa P) (Cambridge (Mass Ave) 78)))
(and (job (Fect Cy D) (computer programmer))
     (address (Fect Cy D) (Cambridge (Ames Street) 3)))
</p>

<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。</span>
| ?- job(Person, [computer, programmer]), address(Person, Where).

Person = ['Hacker','Alyssa','P']
Where = ['Cambridge',['Mass','Ave'],78] ? ;

Person = ['Fect','Cy','D']
Where = ['Cambridge',['Ames','Street'],3] ? ;

(1 ms) no</p>

<p class="orig" lang="en"><a name="%_idx_5126"></a>In general,
</p>

<p class="trans" lang="ja">
一般に、</p>

<p class="lisp">(and &lt;<em>query<sub>1</sub></em>&gt; &lt;<em>query<sub>2</sub></em>&gt; <tt>...</tt> &lt;<em>query<sub><em>n</em></sub></em>&gt;)
</p>

<p class="orig" lang="en">is satisfied by all sets of values for the pattern variables that
simultaneously satisfy &lt;<em>query<sub>1</sub></em>&gt; <tt>...</tt> &lt;<em>query<sub><em>n</em></sub></em>&gt;.</p>

<p class="trans" lang="ja">
は、
&lt;<em class="en">query<sub>1</sub></em>&gt; <tt>...</tt> 
&lt;<em class="en">query<sub>n</sub></em>&gt;
を同時に満たすような、パタン変数に対する値の集合のすべてによって、満たされる。
</p>

<p class="orig" lang="en">
As for simple queries, the system processes a compound query by
finding all assignments to the pattern variables that satisfy the
query, then displaying instantiations of the query with those values.</p>

<p class="trans" lang="ja">
単純クエリ<!-- については -->についてと同様に、システムは、複合クエリを、そのクエリを満たすパタン変数へのすべての<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>を求めることによって、処理し、それから、それらの値を使ってのクエリのインスタンス化を表示する。
</p>

<p class="orig" lang="en">
<a name="%_idx_5128"></a>Another means of constructing compound queries is through <tt>or</tt>.
For example,</p>

<p class="trans" lang="ja">
複合クエリを構築するもう一つの手段は、<tt>or</tt> によるものである。
たとえば、
</p>

<p class="lisp">(or (supervisor ?x (Bitdiddle Ben))
    (supervisor ?x (Hacker Alyssa P)))
</p>

<p class="orig" lang="en">
will find all employees supervised by Ben Bitdiddle or Alyssa P.
Hacker:</p>

<p class="trans" lang="ja">
は、ベン・ビットディドルまたはアリッサ・P・ハッカによって指揮監督されているすべての職員を見つけ出すだろう。
</p>

<p class="lisp">(or (supervisor (Hacker Alyssa P) (Bitdiddle Ben))
    (supervisor (Hacker Alyssa P) (Hacker Alyssa P)))
(or (supervisor (Fect Cy D) (Bitdiddle Ben))
    (supervisor (Fect Cy D) (Hacker Alyssa P)))
(or (supervisor (Tweakit Lem E) (Bitdiddle Ben))
    (supervisor (Tweakit Lem E) (Hacker Alyssa P)))
(or (supervisor (Reasoner Louis) (Bitdiddle Ben))
    (supervisor (Reasoner Louis) (Hacker Alyssa P)))
</p>

<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。</span>
| ?- supervisor(X, ['Bitdiddle', 'Ben']); supervisor(X, ['Hacker', 'Alyssa', 'P']).

X = ['Hacker','Alyssa','P'] ? ;

X = ['Fect','Cy','D'] ? ;

X = ['Tweakit','Lem','E'] ? ;

X = ['Reasoner','Louis'] ? ;

(1 ms) no</p>

<p class="orig" lang="en">In general,
</p>

<p class="trans" lang="ja">
一般に、
</p>

<p class="lisp">(or &lt;<em>query<sub>1</sub></em>&gt; &lt;<em>query<sub>2</sub></em>&gt; <tt>...</tt> &lt;<em>query<sub><em>n</em></sub></em>&gt;)
</p>

<p class="orig" lang="en">is satisfied by all sets of values for the pattern variables that
satisfy at least one of &lt;<em>query<sub>1</sub></em>&gt; <tt>...</tt> &lt;<em>query<sub><em>n</em></sub></em>&gt;.</p>

<p class="trans" lang="ja">
は、
&lt;<em class="en">query<sub>1</sub></em>&gt; <tt>...</tt> 
&lt;<em class="en">query<sub>n</sub></em>&gt;
のうち少なくとも一つを満たすような、パタン変数に対する値の集合のすべてによって、満たされる。 
</p>

<p class="orig" lang="en">
<a name="%_idx_5130"></a>Compound queries can also be formed with <tt>not</tt>. For example,
</p>

<p class="trans" lang="ja">
複合クエリは、<tt>not</tt> を用いて形成されることもあり得る。
たとえば、
</p>

<p class="lisp">(and (supervisor ?x (Bitdiddle Ben))
     (not (job ?x (computer programmer))))
</p>

<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。</span>
| ?- supervisor(X, ['Bitdiddle', 'Ben']), \+(job(X, [computer, programmer])).

X = ['Tweakit','Lem','E'] ? ;

no</p>

<p class="orig" lang="en">finds all people supervised by Ben Bitdiddle who are not computer
programmers.  In general,</p>

<p class="trans" lang="ja">
は、ベン・ビットディドルにより指揮監督される、コンピュータ・プログラマではない、すべての人たちを見つけ出す。
一般に、
</p>


<p class="lisp">(not &lt;<em>query<sub>1</sub></em>&gt;)
</p>

<p class="orig" lang="en">is satisfied by all assignments to the pattern variables that do not
satisfy &lt;<em>query<sub>1</sub></em>&gt;.<a name="call_footnote_Temp_654" href="#footnote_Temp_654"><sup><small>63</small></sup></a></p>

<p class="trans" lang="ja">
は、
&lt;<em class="en">query<sub>1</sub></em>&gt;
を満たさないような、パタン変数に対する<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>のすべてによって、満たされる<a href="#footnote_Temp_654"><sup><small>63</small></sup></a>。
</p>


<p class="orig" lang="en">
<a name="%_idx_5132"></a>The final combining form is called <tt>lisp-value</tt>.  When <tt>lisp-value</tt> is the first element of a pattern, it specifies that the
next element is a Lisp predicate to be applied to the rest of the
(instantiated) elements as arguments.  In general,</p>

<p class="trans" lang="ja">
最後の結合形式は、<tt>lisp-value</tt> と呼ばれる。
<tt>lisp-value</tt> がパタンの第1要素であるとき、これは、その次の要素が、残りの (インスタンス化された) 要素を引数として適用されるべき Lisp 述語である、ということを指定している。
一般に、
</p>

<p class="lisp">(lisp-value &lt;<em>predicate</em>&gt; &lt;<em>arg<sub>1</sub></em>&gt; <tt>...</tt> &lt;<em>arg<sub><em>n</em></sub></em>&gt;)
</p>

<p class="orig" lang="en">will be satisfied by assignments to the pattern variables for which the
&lt;<em>predicate</em>&gt; applied to the instantiated
&lt;<em>arg<sub>1</sub></em>&gt; <tt>...</tt> &lt;<em>arg<sub><em>n</em></sub></em>&gt;
is true.  For example, to find all people whose salary is greater than
$30,000 we could write<a name="call_footnote_Temp_655" href="#footnote_Temp_655"><sup><small>64</small></sup></a></p>

<p class="trans" lang="ja">
は、インスタンス化された
&lt;<em class="en">arg<sub>1</sub></em>&gt; <tt>...</tt> 
&lt;<em class="en">arg<sub>n</sub></em>&gt;
に適用された
&lt;<em class="en">predicate</em>&gt; 
が真となるような、パタン変数に対する<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>によって、満たされるだろう。
たとえば、給与が3万ドルを超えるようなすべての人たちを見つけるには、次のように書けるだろう<a href="#footnote_Temp_655"><sup><small>64</small></sup></a>。
</p>

<p class="lisp">(and (salary ?person ?amount)
     (lisp-value &gt; ?amount 30000))
</p>

<p class="extra_code"><span class="ex_comment">% Prolog で擬似的に真似すると以下のとおり。</span>
| ?- salary(Person, Amount), Amount > 30000.

Amount = 60000
Person = ['Bitdiddle','Ben'] ? ;

Amount = 40000
Person = ['Hacker','Alyssa','P'] ? ;

Amount = 35000
Person = ['Fect','Cy','D'] ? ;

Amount = 150000
Person = ['Warbucks','Oliver'] ? ;

Amount = 75000
Person = ['Scrooge','Eben'] ? ;

(1 ms) no</p>

<p class="orig" lang="en">
<a name="%_thm_4.56"></a>
<b>Exercise 4.56.</b>  Formulate compound queries that retrieve the following information:</p>

<p class="trans" lang="ja">
<b>練習問題4.56.</b> 以下の情報を検索する複合クエリを定式化せよ。
</p>

<ol class="orig alph" lang="en">
<li>the names of all people who are supervised by Ben Bitdiddle, together
with their addresses;</li>

<li>all people whose salary is less than Ben Bitdiddle's, together with
their salary and Ben Bitdiddle's salary;</li>

<li>all people who are supervised by someone who is not in the computer
division, together with the supervisor's name and job.</li>
</ol>

<ol class="trans alph" lang="ja">
<li>ベン・ビットディドルにより指揮監督されているすべての人たちの名前を、その人たちの住所と一緒に。</li>
<li>ベン・ビットディドルよりも給与が低いすべての人たちを、その人たちの給与およびベン・ビットディドルの給与と一緒に。</li>
<li>コンピュータ部門にいない誰かによって指揮監督されているすべての人たちを、<!-- 上司 -->指揮監督者の名前および仕事と一緒に。</li>
</ol>

<p class="exercise"><span class="ex_comment">; a</span>
(and (supervisor ?who (Bitdiddle Ben))
     (address ?who ?where))</p>

<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。</span>
| ?- supervisor(Who, ['Bitdiddle', 'Ben']), address(Who, Where).

Where = ['Cambridge',['Mass','Ave'],78]
Who = ['Hacker','Alyssa','P'] ? ;

Where = ['Cambridge',['Ames','Street'],3]
Who = ['Fect','Cy','D'] ? ;

Where = ['Boston',['Bay','State','Road'],22]
Who = ['Tweakit','Lem','E'] ? ;

(1 ms) no</p>

<p class="exercise"><span class="ex_comment">; b</span>
(and (salary ?person ?amount)
     (salary (Bitdiddle Ben) ?amount-of-Ben)
     (lisp-value &lt; ?amount ?amount-of-Ben))</p>

<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。</span>
| ?- salary(Person, Amount), salary(['Bitdiddle', 'Ben'], Amount_of_Ben), Amount < Amount_of_Ben.

Amount = 40000
Amount_of_Ben = 60000
Person = ['Hacker','Alyssa','P'] ? ;

Amount = 35000
Amount_of_Ben = 60000
Person = ['Fect','Cy','D'] ? ;

Amount = 25000
Amount_of_Ben = 60000
Person = ['Tweakit','Lem','E'] ? ;

Amount = 30000
Amount_of_Ben = 60000
Person = ['Reasoner','Louis'] ? ;

Amount = 18000
Amount_of_Ben = 60000
Person = ['Cratchet','Robert'] ? ;

Amount = 25000
Amount_of_Ben = 60000
Person = ['Aull','DeWitt'] ? ;

(1 ms) no</p>

<p class="exercise"><span class="ex_comment">; c</span>
(and (supervisor ?who ?boss)
     (not (job ?boss (computer . ?x)))
     (job ?boss ?job-of-boss))

<span class="ex_comment">; 以下のように書きたくなるが、
;「等価性の検査に lisp-value を使うな」と<a  href="#footnote_Temp_655">脚注64</a>にあるので、
; 上記のような回答案にしてみた。</span>
(and (supervisor ?who ?boss)
     (job ?boss (?division ?job-detail))
     (not (lisp-value = ?division 'computer)))
</p>

<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。</span>
| ?- supervisor(Who, Boss), \+(job(Boss, [computer | X])), job(Boss, Job_of_Boss).

Boss = ['Warbucks','Oliver']
Job_of_Boss = [administration,big,wheel]
Who = ['Bitdiddle','Ben'] ? ;

Boss = ['Warbucks','Oliver']
Job_of_Boss = [administration,big,wheel]
Who = ['Scrooge','Eben'] ? ;

Boss = ['Scrooge','Eben']
Job_of_Boss = [accounting,chief,accountant]
Who = ['Cratchet','Robert'] ? ;

Boss = ['Warbucks','Oliver']
Job_of_Boss = [administration,big,wheel]
Who = ['Aull','DeWitt'] ? ;

(1 ms) no</p>

<a name="%_sec_Temp_657"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_657">Rules</a></h4>
<h4 class="trans" lang="ja">規則</h4>


<p class="orig" lang="en">
<a name="%_idx_5136"></a>
<a name="%_idx_5138"></a>In addition to primitive queries and compound queries, the query
language provides means for abstracting queries.  These are given by
<em>rules</em>.  The rule</p>

<p class="trans" lang="ja">
原始的クエリと複合クエリに加えて、クエリ言語は、クエリを抽象化する手段を提供する。
これらは、<em>規則</em>により与えられる。
以下の規則は、
</p>

<p class="lisp"><a name="%_idx_5140"></a>(rule (lives-near ?person-1 ?person-2)
      (and (address ?person-1 (?town . ?rest-1))
           (address ?person-2 (?town . ?rest-2))
           (not (same ?person-1 ?person-2))))
</p>

<p class="orig" lang="en">specifies that two people live near each other if they live in the
same town.  The final <tt>not</tt> clause prevents the rule from saying
that all people live near themselves.  The <tt>same</tt> relation is
defined by a very simple rule:<a name="call_footnote_Temp_658" href="#footnote_Temp_658"><sup><small>65</small></sup></a></p>

<p class="trans" lang="ja">
二人の人は、もし同じ町に住んでいれば、お互いに近くに住んでいるのだ、と規定している。
最後の <tt>not</tt> 節は、すべての人は自分の近くに住んでいる、と規則が述べるのを防いでいる。
<tt>same</tt> 関係は、とても単純な規則により定義される<a href="#footnote_Temp_658"><sup><small>65</small></sup></a>。
</p>

<p class="lisp"><a name="%_idx_5142"></a>(rule (same ?x ?x))
</p>

<p class="extra_code"><span class="ex_comment">% 上記の二つの規則は、Prolog だと以下のとおり。</span>
lives_near(Person_1, Person_2) :- 
    address(Person_1, [Town | Rest_1]),
    address(Person_2, [Town | Rest_2]),
    \+(same(Rest_1, Rest_2)).
same(X, X).
</p>

<p class="orig" lang="en">
The following rule declares that a person is a ``wheel'' in an
organization if he supervises someone who is in turn a supervisor:</p>

<p class="trans" lang="ja">
以下の規則は、次のように宣言している。すなわち、人は、もし誰かを指揮監督していて、その誰かがまたさらに指揮監督者であるならば、組織における「大物」である、と。
</p>

<p class="lisp"><a name="%_idx_5144"></a>(rule (wheel ?person)
      (and (supervisor ?middle-manager ?person)
           (supervisor ?x ?middle-manager)))
</p>

<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。</span>
wheel(Person) :- 
    supervisor(Middle_manager, Person), 
    supervisor(X, Middle_manager).
</p>

<p class="orig" lang="en">
The general form of a rule is
</p>

<p class="trans" lang="ja">
規則の一般形は、
</p>

<p class="lisp">(rule &lt;<em>conclusion</em>&gt; &lt;<em>body</em>&gt;)
</p>

<p class="orig" lang="en">where &lt;<em>conclusion</em>&gt; is a pattern and &lt;<em>body</em>&gt; is any
query.<a name="call_footnote_Temp_659" href="#footnote_Temp_659"><sup><small>66</small></sup></a> We can think
of a rule as representing a large (even infinite) set of assertions,
namely all instantiations of the rule conclusion with variable
assignments that satisfy the rule body.  When we described simple
queries (patterns), we said that an assignment to variables satisfies
a pattern if the instantiated pattern is in the data base.  But the
pattern needn't be explicitly in the data base as an assertion.  It
<a name="%_idx_5148"></a>can be an implicit assertion implied by a rule.  For example, the
query
</p>

<p class="trans" lang="ja">
であり、ここで、&lt;<em class="en">conclusion</em>&gt; (帰結部) はパタンであり、&lt;<em class="en">body</em>&gt; (本体) は任意のクエリである<a href="#footnote_Temp_659"><sup><small>66</small></sup></a>。
規則のことを、言明の多数通りの (無限通りでさえある) 組——すなわち、規則本体を満たすような変数<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>での、規則帰結部のすべてのインスタンス化——を表しているものと、見なすことが可能である。
単純クエリ (パタン) を説明したときに、私たちは、もしインスタンス化されたパタンがデータベース内にあれば、変数への<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>はパタンを満たす、と言った。
しかし、パタンは、言明のように明示的にデータベース内にある必要はない。
それは、規則によって暗示される暗黙的な言明であり得る。
たとえば、以下のクエリは、
</p>

<p class="lisp">(lives-near ?x (Bitdiddle Ben))
</p>

<p class="orig" lang="en">results in
</p>

<p class="trans" lang="ja">
以下のような結果になる。
</p>

<p class="lisp">(lives-near (Reasoner Louis) (Bitdiddle Ben))
(lives-near (Aull DeWitt) (Bitdiddle Ben))
</p>

<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。</span>
| ?- lives_near(X, ['Bitdiddle', 'Ben']).

X = ['Reasoner','Louis'] ? ;

X = ['Aull','DeWitt'] ? ;

(1 ms) no
</p>

<p class="orig" lang="en">To find all computer programmers who live near Ben Bitdiddle, we can
ask
</p>

<p class="trans" lang="ja">
ベン・ビットディドルの近くに住んでいるすべてのプログラマを見つけるために、次のように尋ねることができる。
</p>

<p class="lisp">(and (job ?x (computer programmer))
     (lives-near ?x (Bitdiddle Ben)))
</p>

<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。</span>
| ?- job(X, [computer, programmer]), lives_near(X, ['Bitdiddle', 'Ben']).

no
</p>

<p class="orig" lang="en">
<a name="%_idx_5150"></a>As in the case of compound procedures, rules can be used as parts of
other rules (as we saw with the <tt>lives-near</tt> rule above)
or even be defined recursively.  For instance, the rule
</p>

<p class="trans" lang="ja">
複合手続きの場合と同様に、規則を、(上記の <tt>lives-near</tt> の規則について見たとおり) 他の規則の一部として使うことができるし、あるいは、再帰的に定義することすらできる。
たとえば、次の規則は、
</p>

<p class="lisp"><a name="%_idx_5152"></a>(rule (outranked-by ?staff-person ?boss)
      (or (supervisor ?staff-person ?boss)
          (and (supervisor ?staff-person ?middle-manager)
               (outranked-by ?middle-manager ?boss))))
</p>

<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。</span>
outranked_by(Staff_person, Boss) :-
    supervisor(Staff_person, Boss);
    (supervisor(Staff_person, Middle_manager), 
     outranked_by(Middle_manager, Boss)).
</p>

<p class="orig" lang="en">says that a staff person is outranked by a boss in the organization if
the boss is the person's supervisor or (recursively) if the person's
supervisor is outranked by the boss.</p>

<p class="trans" lang="ja">
組織内では、ある職員と上役について、その上役がその職員の指揮監督者である場合、または、(再帰的に) その職員の指揮監督者よりもその上役の方が高い地位にある場合は、その職員よりもその上役の方が高い地位にある、と言っている。
</p>


<p class="orig" lang="en">
<a name="%_thm_4.57"></a>
<b>Exercise 4.57.</b>  Define a rule that says that person 1 can replace person 2 if either
person 1 does the same job as person 2 or someone who does person 1's
job can also do person 2's job, and if person 1 and person 2 are not
the same person. Using your rule, give queries that find the
following:</p>

<p class="trans" lang="ja">
<b>練習問題4.57.</b> 人物1 が人物2 と同じ仕事をしているか、または、人物1 と同じ仕事をしている誰かが人物2 の仕事もできる場合、かつ、人物1 と人物2 が同一人物ではない場合に、人物1 が人物2 の代わりを務められる、と述べる規則を、定義せよ。
君の規則を使って、以下のものを見つけるクエリを示せ。
</p>

<ol class="orig alph" lang="en">
<li>all people who can replace Cy D. Fect;</li>

<li>all people who can replace someone who is being paid more than they
are, together with the two salaries.</li>
</ol>

<ol class="trans alph" lang="ja">
<li>サイ・D・フェクトの代わりができる、すべての人たち。</li>
<li>自分より高い給与をもらっている誰かの代わりを務められる、すべての人たちを、それら二人の給与とともに。</li>
</ol>

<p class="exercise"><span class="ex_comment">; 規則の定義</span>
(rule (can-replace ?persson1 ?person2)
  (and
    (or
       <span class="ex_comment">; 人物1 と人物2 が同じ仕事 (?job1) をしている。</span>
      (and (job ?person1 ?job1) (job ?person2 ?job1))
       <span class="ex_comment">; 人物1 がしている仕事 (?job1) をしている人は一般的に、</span>
       <span class="ex_comment">; 人物2 がしている仕事 (?job2) を行うことが可能である。</span>
      (and (job ?person1 ?job1) (job ?person2 ?job2) (can-do-job ?job1 ?job2)))
     <span class="ex_comment">; 人物1 と人物2 は別人である。</span>
    (not (same ?person1 ?person2))))
</p>

<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。</span>
can_replace(Person1, Person2) :-
    ( (job(Person1, Job1), job(Person2, Job1)) ;
      (job(Person1, Job1), job(Person2, Job2), can_do_job(Job1, Job2)) ),
    \+(same(Person1, Person2)).
</p>

<p class="exercise"><span class="ex_comment">; a</span>
(can-replace ?who (Fect Cy D))
</p>
<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。</span>
| ?- can_replace(Who, ['Fect', 'Cy', 'D']).

Who = ['Hacker','Alyssa','P'] ? ;

Who = ['Bitdiddle','Ben'] ? ;

no
</p>

<p class="exercise"><span class="ex_comment">; b</span>
(and (can-replace ?who ?more-paid-person)
     (salary ?who ?s1) (salary ?more-paid-person ?s2)
     (lisp-value &lt; ?s1 ?s2))
</p>
<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。</span>
| ?- can_replace(Who, More_Paid_Person), salary(Who, S1), salary(More_Paid_Person, S2), S1 < S2.

More_Paid_Person = ['Hacker','Alyssa','P']
S1 = 35000
S2 = 40000
Who = ['Fect','Cy','D'] ? ;

More_Paid_Person = ['Warbucks','Oliver']
S1 = 25000
S2 = 150000
Who = ['Aull','DeWitt'] ? ;

(1 ms) no
</p>

<p class="orig" lang="en">
<a name="%_thm_4.58"></a>
<b>Exercise 4.58.</b>  Define a rule that says that a person is a ``big shot'' in a division
if the person works in the division but does not have a supervisor who
works in the division.
</p>

<p class="trans" lang="ja">
<b>練習問題4.58.</b> もし、ある人がある部門で働いているものの、当人には当該部門で働く指揮監督者がいなければ、その人は当該部門における「お偉方」である、と述べる規則を、定義せよ。
</p>

<p class="exercise"><span class="ex_comment">; 二つの場合があるので、二つの規則に分けて記述する。

; ある人 (?who) には指揮監督者 (?supervisor) がいるけれど、指揮監督者は別部門に属している。</span>
(rule (is-big-shot ?who ?division1)
  (and (job ?who (?division1 . ?j1))
       (supervisor ?who ?supervisor)
       (job ?supervisor (?division2 . ?j2))
       (not (same ?divison1 ?division2))))

<span class="ex_comment">; ある人 (?who) は実在していて、どこかの部門 (?div) で働いているのだが、
; そもそもこの人には (同部門であれ別部門であれ) 指揮監督者 (?someone-else)などいない。</span>
(rule (is-big-shot ?who ?div)
  (and (job ?who (?div . ?j)) (not (supervisor ?who ?someone-else))))
</p>
<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。</span>
is_big_shot(Who, Division1) :-
    job(Who, [Division1 |_]), supervisor(Who, Supervisor),
    job(Supervisor, [Division2 |_]), \+(same(Division1, Division2)).
is_big_shot(Who, Div) :-
    job(Who, [Div |_]), \+(supervisor(Who, Someone_else)).

<span class="ex_comment">% クエリを実行してみると以下のとおり。</span>
| ?- is_big_shot(Who, Div).

Div = computer
Who = ['Bitdiddle','Ben'] ? ;

Div = accounting
Who = ['Scrooge','Eben'] ? ;

Div = administration
Who = ['Warbucks','Oliver'] ? ;

no
</p>

<p class="orig" lang="en">
<a name="%_thm_4.59"></a>
<b>Exercise 4.59.</b>  Ben Bitdiddle has missed one meeting too many.
Fearing that his habit of forgetting meetings could cost him his
job, Ben decides to do something about it.  He adds all the weekly
meetings of the firm to the Microshaft data base by
asserting the following:
</p>

<p class="trans" lang="ja">
<b>練習問題4.59.</b> ベン・ビットディドルは、これまで会議に出席しそこねることがちょっと多すぎた。
会議を忘れるという自分の癖は、厄介事を自分にもたらしかねない、と懸念して、ベンは、これに関して何かしよう、と決意する。
以下のように言明することによって、彼は、会社の毎週の会議をすべて、マイクロシャフト社のデータベースに加える。
</p>

<p class="lisp">(meeting accounting (Monday 9am))
(meeting administration (Monday 10am))
(meeting computer (Wednesday 3pm))
(meeting administration (Friday 1pm))
</p>
<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。</span>
meeting(accounting, ['Monday', '9am']).
meeting(administration, ['Monday', '10am']).
meeting(computer, ['Wednesday', '3pm']).
meeting(administration, ['Friday', '1pm']).
</p>

<p class="orig" lang="en">Each of the above assertions is for a meeting of an entire division.
Ben also adds an entry for the company-wide meeting that spans all the
divisions.  All of the company's employees attend this meeting.
</p>

<p class="trans" lang="ja">
上記の言明のそれぞれは、部門全体の会議についてのものである。
ベンは、全部門にまたがる全社的会議についてのエントリも加える。
会社の全従業員がこの会議に出席する。
</p>

<p class="lisp">(meeting whole-company (Wednesday 4pm))
</p>
<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。</span>
meeting(whole_company, ['Wednesday', '4pm']).
</p>

<ol class="orig alph" lang="en">
<li>On Friday morning, Ben wants to query the data base for all the meetings
that occur that day.  What query should he use?</li>
</ol>

<ol class="trans alph" lang="ja">
<li>金曜日の朝、ベンは、その日にある全部の会議について、データベースに質問したいと思う。
彼はどのようなクエリを使うべきだろう?</li>
</ol>

<p class="exercise">(meeting ?div (Friday ?time))</p>
<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。</span>
| ?- meeting(Div, ['Friday', Time]).

Div = administration
Time = '1pm' ? ;

no
</p>

<ol class="orig alph" start="2" lang="en">
<li>Alyssa P. Hacker is unimpressed.  She thinks it would be much more
useful to be able to ask for her meetings by specifying her name.  So
she designs a rule that says that a person's meetings include all <tt>whole-company</tt> meetings plus all meetings of that person's division.
Fill in the body of Alyssa's rule.</li>
</ol>

<ol class="trans alph" start="2" lang="ja">
<li>アリッサ・P・ハッカは、感心できないな、と思っている。
彼女は、自分の名前を指定することで自分の会議について求めることができれば、もっとずっと有用だろうに、と考えている。
そこで彼女は、次のように述べる規則を設計する。すなわち、ある人の会議とは、<tt>whole-company</tt> のすべての会議と、その人の部門のすべての会議とを含むのだ、と。
アリッサの規則の本体を埋めよ。</li>
</ol>

<p class="lisp">(rule (meeting-time ?person ?day-and-time)
      &lt;<em>rule-body</em>&gt;)
</p>

<p class="exercise">(rule (meeting-time ?person ?day-and-time)
  (or (meeting whole-company ?day-and-time)
      (and (job ?person (?division . ?x)) (meeting ?division ?day-and-time))))
</p>
<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。</span>
meeting_time(Person, Day_and_Time) :-
    meeting(whole_company, Day_and_Time) ;
    job(Person, [Division |_]), meeting(Division, Day_and_Time).
</p>

<ol class="orig alph" start="3" lang="en">
<li>Alyssa arrives at work on Wednesday morning and wonders what meetings she 
has to attend that day.  Having defined the above rule,
what query should she make to find this out?</li>
</ol>

<ol class="trans alph" start="3" lang="ja">
<li>アリッサは、水曜日の朝に職場に着く。そして、この日に自分はどの会議に出席せねばならないんだっけ、と考える。
上記の規則を定義済みだとして、彼女がこれについて知るためには、どのようなクエリを作るべきだろうか?</li>
</ol>

<p class="exercise"><span class="ex_comment">; 何時に会議があるか、だけでなくて、
; その会議がどこの部署のものか、を知りたいかと思って、and で二つをつないでみた。</span>
(and (meeting-time (Hacker Alyssa P) (Wednesday . ?time))
     (meeting ?div (Wednesday . ?time)))</p>
<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。</span>
| ?- meeting_time(['Hacker','Alyssa','P'], ['Wednesday' | Time]), 
meeting(Div, ['Wednesday' | Time]).

Div = whole_company
Time = ['4pm'] ? ;

Div = computer
Time = ['3pm'] ? ;

(1 ms) no
</p>

<p class="orig" lang="en">
<a name="%_thm_4.60"></a>
<b>Exercise 4.60.</b>  <a name="%_idx_5154"></a>By giving the query
</p>

<p class="trans" lang="ja">
<b>練習問題4.60.</b> 次のクエリを与えることで、
</p>

<p class="lisp">(lives-near ?person (Hacker Alyssa P))
</p>
<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。</span>
| ?- lives_near(Person, ['Hacker','Alyssa','P']).

Person = ['Fect','Cy','D'] ? ;

no
</p>

<p class="orig" lang="en">Alyssa P. Hacker is able to find people who live near her, with whom
she can ride to work.  On the other hand, when she tries to find all
pairs of people who live near each other by querying</p>

<p class="trans" lang="ja">
アリッサ・P・ハッカは、自分の近所に住んでいる人たち——自動車に相乗りして通勤できる相手——を見つけられる。
その一方で、彼女は、お互いの近所に住んでいるすべての二人組を、以下のように質問することで見つけようとしたときに、
</p>

<p class="lisp">(lives-near ?person-1 ?person-2)
</p>

<p class="orig" lang="en">she notices that each pair of people who live near each other is
listed twice; for example,</p>

<p class="trans" lang="ja">
お互いの近所に住んでいる二人組の各々が二度列挙されている、ということに気づく。
たとえば、以下のように。
</p>

<p class="lisp">(lives-near (Hacker Alyssa P) (Fect Cy D))
(lives-near (Fect Cy D) (Hacker Alyssa P))
</p>
<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。</span>
| ?- lives_near(Person_1, Person_2).

Person_1 = ['Bitdiddle','Ben']
Person_2 = ['Reasoner','Louis'] ? ;

Person_1 = ['Bitdiddle','Ben']
Person_2 = ['Aull','DeWitt'] ? ;

Person_1 = ['Hacker','Alyssa','P']
Person_2 = ['Fect','Cy','D'] ? ;

Person_1 = ['Fect','Cy','D']
Person_2 = ['Hacker','Alyssa','P'] ? ;

Person_1 = ['Reasoner','Louis']
Person_2 = ['Bitdiddle','Ben'] ? ;

Person_1 = ['Reasoner','Louis']
Person_2 = ['Aull','DeWitt'] ? ;

Person_1 = ['Aull','DeWitt']
Person_2 = ['Bitdiddle','Ben'] ? ;

Person_1 = ['Aull','DeWitt']
Person_2 = ['Reasoner','Louis'] ? ;

(1 ms) no
</p>

<p class="orig" lang="en">Why does this happen?
Is there a way to find a list of people who live near each other, in
which each pair appears only once?  Explain.
</p>

<p class="trans" lang="ja">
なぜこういうことが起きるのか?
お互いの近所に住んでいる人たちの一覧を見つけつつ、そこでは各組が一度だけ現れている、といった方法は存在するだろうか?
説明せよ。
</p>

<p class="exercise"><span class="ex_comment"><a href="#%_idx_5140"><tt>lives-near</tt> の定義</a>は、二人の人物に関してまったく対称である。よって、
もしAさんとBさんが近所に住んでいれば (AさんとBさんは別人とする)、

  * <tt>?person-1</tt> というパタン変数にAさん (の氏名) が代入され、かつ、
    <tt>?person-2</tt> というパタン変数にBさん (の氏名) が代入される、というインスタンス化と、

  * <tt>?person-1</tt> というパタン変数にBさん (の氏名) が代入され、かつ、
    <tt>?person-2</tt> というパタン変数にAさん (の氏名) が代入される、というインスタンス化

のそれぞれによって、<tt>lives-near</tt> は満たされる。したがって、上記のように、
どの「ご近所二人組」も二度出現してしまう。

これを防ぐには、<tt>lives-near</tt> の本体に、<tt>and</tt> でつなげて条件を追加すればよい 
(または、<tt>lives-near</tt> に <tt>and</tt> で別の条件をつないだ、ラッパ的な規則ないしクエリを作ればよい)。
つまり対称性を壊せばよい。
具体的には、氏名同士の間に (文字列の辞書順とかで適当に) 順序関係を定義してやって、
<tt>?person-1</tt> は <tt>?person-2</tt> よりも「順序」が前だ、という条件を加えればよい。
もしその「順序」を、「&le; 的な関係」ではなくて「&lt; 的な関係」として定義するなら、
<tt>(not (same ?person-1 ?person-2))</tt> は省略可能となる。

……とまあ、理屈の上ではそうなんだが、記号 (シンボル) 同士の間に順序付けを
するような組み込み述語ってあったかな? あるいは、シンボル名を表現する文字列を
取得するような組み込み関数とか (それで文字列同士の大小比較に持ち込む)。
ちょっと実際の実装までは考えていない。

[追記] <a href="http://practical-scheme.net/gauche/index-j.html">Gauche</a>の<a href="http://practical-scheme.net/gauche/man/?l=ja&p=eq-compare"><tt>eq-compare</tt></a>を使う手がありそう。
あるいは、<a href="http://practical-scheme.net/gauche/man/?l=ja&p=symbol->string"><tt>symbol-&gt;string</tt></a>と<a href="http://practical-scheme.net/gauche/man/?l=ja&p=string>?"><tt>string&lt;?</tt></a>の合わせ技かな。
</span></p>

<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。
% 2通りの方法 (規則の本体を書き換える方法と、ラッパ規則を作る方法) を示す。</span>
lives_near_ver2(Person_1, Person_2) :- 
    address(Person_1, [Town | Rest_1]),
    address(Person_2, [Town | Rest_2]),
    Person_1 @&lt; Person_2.
lives_near_ver3(Person_1, Person_2) :- 
    lives_near(Person_1, Person_2), Person_1 @&lt; Person_2.

<span class="ex_comment">% クエリを実行してみると以下のとおり。</span>
| ?- lives_near_ver2(A, B).

A = ['Bitdiddle','Ben']
B = ['Reasoner','Louis'] ? ;

A = ['Fect','Cy','D']
B = ['Hacker','Alyssa','P'] ? ;

A = ['Aull','DeWitt']
B = ['Bitdiddle','Ben'] ? ;

A = ['Aull','DeWitt']
B = ['Reasoner','Louis'] ? ;

no
| ?- lives_near_ver3(A, B).

A = ['Bitdiddle','Ben']
B = ['Reasoner','Louis'] ? ;

A = ['Fect','Cy','D']
B = ['Hacker','Alyssa','P'] ? ;

A = ['Aull','DeWitt']
B = ['Bitdiddle','Ben'] ? ;

A = ['Aull','DeWitt']
B = ['Reasoner','Louis'] ? ;

(1 ms) no
</p>

<a name="%_sec_Temp_664"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_664">Logic as programs</a></h4>
<h4 class="trans" lang="ja">プログラムとしての論理</h4>

<p class="orig" lang="en">
<a name="%_idx_5156"></a>
We can regard a rule as a kind of logical implication: <em>If</em> an
assignment of values to pattern variables satisfies the body, <em>then</em> it satisfies the conclusion.  Consequently, we can regard the
query language as having the ability to perform <em>logical
deductions</em> based upon the rules.  As an example, consider the <tt>append</tt> operation described at the beginning of
section <a href="#%_sec_4.4">4.4</a>.  As we said, <tt>append</tt> can be
characterized by the following two rules:</p>

<p class="trans" lang="ja">
規則を、一種の論理的含意と見なすこともできる。つまり、<em>もし</em>パタン変数に対する値の<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>が本体を満たす<em>なら</em>、その<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>は帰結部を満たす、という論理的含意である。
その結果、クエリ言語を、規則に基づく<em>論理的演繹</em>を実行する能力を備えたものと見なせる。
例として、<a href="#%_sec_4.4">4.4</a>節の最初で説明した <tt>append</tt> の演算を考えてみよ。
言ったとおり、以下の二つの規則により <tt>append</tt> を特徴づけることができる。
</p>

<ul class="orig" lang="en">
<li>For any list <tt>y</tt>, the empty list and <tt>y</tt> <tt>append</tt> to form <tt>y</tt>.</li>

<li>For any <tt>u</tt>,  <tt>v</tt>,  <tt>y</tt>, and <tt>z</tt>,
 <tt>(cons u v)</tt> and <tt>y</tt> <tt>append</tt> to form <tt>(cons u z)</tt>
if <tt>v</tt> and <tt>y</tt> <tt>append</tt> to form <tt>z</tt>.</li>
</ul>

<ul class="trans" lang="ja">
<li>任意のリスト <tt>y</tt> について、空リストと <tt>y</tt> は、<tt>append</tt> して <tt>y</tt> となる。</li>
<li>任意の <tt>u</tt> と <tt>v</tt> と <tt>y</tt> と <tt>z</tt> について、もし <tt>v</tt> と <tt>y</tt> が <tt>append</tt> して <tt>z</tt> となるなら、<tt>(cons u v)</tt> と <tt>y</tt> は、<tt>append</tt> して <tt>(cons u z)</tt> となる。</li>
</ul>

<p class="orig" lang="en">
To express this in our query language, we define two rules for a
relation
</p>

<p class="trans" lang="ja">
私たちのクエリ言語でこれを表すには、以下の関係について二つの規則を定義する。
</p>

<p class="lisp">(append-to-form x y z)</p>

<p class="orig" lang="en">which we can interpret to mean ``<tt>x</tt> and <tt>y</tt> <tt>append</tt> to
form <tt>z</tt>'':</p>

<p class="trans" lang="ja">
なおこれは、「<tt>x</tt> と <tt>y</tt> は <tt>append</tt> して <tt>z</tt> となる」を意味するものと解釈できる。
</p>

<p class="lisp"><a name="%_idx_5158"></a>(rule (append-to-form () ?y ?y))
(rule (append-to-form (?u . ?v) ?y (?u . ?z))
      (append-to-form ?v ?y ?z))
</p>
<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。</span>
append_to_form([], Y, Y).
append_to_form([U | V], Y, [U | Z]) :- append_to_form(V, Y, Z).

<span class="ex_comment">% プロンプトに対して以下のように [user]. と打ち込んでから
% | ?- [user].
% 上記の規則を入力し、終わったら Control+D を入力する。
% そうすると、定義した規則を使ったクエリを実行できるようになる。</span>
</p>

<p class="orig" lang="en"><a name="%_idx_5160"></a>The first rule has no body, which means that the conclusion holds for
any value of <tt>?y</tt>.  Note how the second rule makes use of
<a name="%_idx_5162"></a>dotted-tail notation to name the <tt>car</tt> and <tt>cdr</tt> of a list.</p>

<p class="trans" lang="ja">
1番目の規則には本体がなく、そのことは、<tt>?y</tt> の任意の値に対して帰結部が成り立つことを意味する。
どのようにして2番目の規則が、末尾にドットがついた記法を利用してリストの <tt>car</tt> と <tt>cdr</tt> を名付けているのか、ということに注意してほしい。
</p>

<p class="orig" lang="en">
Given these two rules, we can formulate queries that compute the <tt>append</tt> of two lists:
</p>

<p class="trans" lang="ja">
これら二つの規則が与えられると、二つのリストの <tt>append</tt> を計算するクエリを定式化できる。
</p>

<p class="lisp"><i>;;; Query input:</i>
(append-to-form (a b) (c d) ?z)
<i>;;; Query results:</i>
(append-to-form (a b) (c d) (a b c d))
</p>
<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。</span>
|? append_to_form([a, b], [c, d], Z).

Z = [a,b,c,d]

yes
</p>

<p class="orig" lang="en">What is more striking, we can use the same rules to ask the question
``Which list, when <tt>append</tt>ed to <tt>(a b)</tt>, yields <tt>(a b c d)</tt>?''
This is done as follows:
</p>

<p class="trans" lang="ja">
さらに素晴らしいことには、「<tt>(a b)</tt> に <tt>append</tt> された場合に <tt>(a b c d)</tt> を作り出すのはどのリストか?」という質問に答えるのに、同じ規則を使えるのである。
これは、次のように行われる。
</p>

<p class="lisp"><i>;;; Query input:</i>
(append-to-form (a b) ?y (a b c d))
<i>;;; Query results:</i>
(append-to-form (a b) (c d) (a b c d))
</p>
<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。</span>
| ?- append_to_form([a, b], Y, [a, b, c, d]).

Y = [c,d]

yes
</p>

<p class="orig" lang="en">We can also ask for all pairs of lists that <tt>append</tt> to form <tt>(a b c d)</tt>:
</p>

<p class="trans" lang="ja">
<tt>append</tt> して <tt>(a b c d)</tt> になるような、リスト同士の対をすべて求めることもできる。
</p>

<p class="lisp"><i>;;; Query input:</i>
(append-to-form ?x ?y (a b c d))
<i>;;; Query results:</i>
(append-to-form () (a b c d) (a b c d))
(append-to-form (a) (b c d) (a b c d))
(append-to-form (a b) (c d) (a b c d))
(append-to-form (a b c) (d) (a b c d))
(append-to-form (a b c d) () (a b c d))
</p>
<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。</span>
| ?- append_to_form(X, Y, [a, b, c, d]).

X = []
Y = [a,b,c,d] ? ;

X = [a]
Y = [b,c,d] ? ;

X = [a,b]
Y = [c,d] ? ;

X = [a,b,c]
Y = [d] ? ;

X = [a,b,c,d]
Y = [] ? ;

(1 ms) no
</p>

<p class="orig" lang="en">
The query system may seem to exhibit quite a bit of intelligence in
using the rules to deduce the answers to the queries above.  Actually,
as we will see in the next section, the system is following a
well-determined algorithm in unraveling the rules.  Unfortunately,
although the system works impressively in the <tt>append</tt> case, the
general methods may break down in more complex cases, as we will see
in section <a href="#%_sec_4.4.3">4.4.3</a>.</p>

<p class="trans" lang="ja">
クエリ・システムは、上記のクエリへの答えを演繹するのに規則を用いる際に、かなりの知性を示すように見えるかもしれない。
実際、次の節で見るように、このシステムは、諸規則を解きほぐす際に、きちんと定められたアルゴリズムに従っている。
しかしあいにく、<tt>append</tt> の場合にはシステムが印象的にうまく動くとは言え、より複雑な場合では、<a href="#%_sec_4.4.3">4.4.3</a>節で見ることになるように、一般的な方法ではうまくいかないかもしれない。
</p>


<p class="orig" lang="en">
<a name="%_thm_4.61"></a>
<b>Exercise 4.61.</b>  The following rules implement a <tt>next-to</tt> relation that finds
adjacent elements of a list:
</p>

<p class="trans" lang="ja">
<b>練習問題4.61.</b> 以下の規則は、リストのうちの隣り合う要素を見つけ出す、<tt>next-to</tt> という関係を実装している。
</p>

<p class="lisp"><a name="%_idx_5164"></a>(rule (?x next-to ?y in (?x ?y . ?u)))

(rule (?x next-to ?y in (?v . ?z))
      (?x next-to ?y in ?z))
</p>
<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。

% | ?- [user].
% としてから以下を入力し、入力後、Control+D を押す。</span>
next_to(X, Y, [X, Y | U]).
next_to(X, Y, [V | Z]) :- next_to(X, Y, Z).
</p>

<p class="orig" lang="en">What will the response be to the following queries?
</p>

<p class="trans" lang="ja">
以下のクエリに対して、応答はどうなるだろうか?
</p>

<p class="lisp">(?x next-to ?y in (1 (2 3) 4))

(?x next-to 1 in (2 1 3 1))
</p>

<p class="exercise">(1 next-to (2 3) in (1 (2 3) 4))
((2 3) next-to 4 in (1 (2 3) 4))

(2 next-to 1 in (2 1 3 1))
(3 next-to 1 in (2 1 3 1))
</p>
<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。
% 1番目のクエリ</span>
| ?- next_to(X, Y, [1, [2, 3], 4]).

X = 1
Y = [2,3] ? ;

X = [2,3]
Y = 4 ? ;

no

<span class="ex_comment">% 2番目のクエリ</span>
| ?- next_to(X, 1, [2, 1, 3, 1]).

X = 2 ? ;

X = 3 ? ;

no
</p>

<p class="orig" lang="en">
<a name="%_thm_4.62"></a>
<b>Exercise 4.62.</b>  <a name="%_idx_5166"></a>Define rules to implement the <tt>last-pair</tt> operation of
exercise <a href="15_sec2_2.html#%_thm_2.17">2.17</a>, which returns a list containing the last
element of a nonempty list.  Check your rules on queries such as
<tt>(last-pair (3) ?x)</tt>, <tt>(last-pair (1 2 3) ?x)</tt>, and <tt>(last-pair (2 ?x) (3))</tt>.
Do your rules work correctly on queries such as <tt>(last-pair ?x (3))</tt> ?
</p>

<p class="trans" lang="ja">
<b>練習問題4.62.</b> 練習問題<a href="15_sec2_2.html#%_thm_2.17">2.17</a>の <tt>last-pair</tt> 演算——非空リストの最後の要素を含むリストを返す——を実装するための規則を定義せよ。
<tt>(last-pair (3) ?x)</tt> や <tt>(last-pair (1 2 3) ?x)</tt> や <tt>(last-pair (2 ?x) (3))</tt> といったクエリについて、君の規則を点検してみたまえ。
<tt>(last-pair ?x (3))</tt> のようなクエリに対して、君の規則は正しく動くかな?
</p>

<p class="exercise"><span class="ex_comment">; 第1引数は非空リスト。第2引数はその中の最後の要素を含むリスト。</span>
(last-pair (?last) (?last))
(rule (last-pair (?x . ?y) ?last)
      (last-pair ?y ?last))
</p>
<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。

% | ?- [user].
% としてから以下を入力し、入力後、Control+D を押す。</span>
last_pair([Last], [Last]).
last_pair([X | Y], Last) :- last_pair(Y, Last).
</p>

<p class="exercise"><span class="ex_comment">(last-pair (3) ?x) は、1番目の規則を使うと、(?last) が (3) で、?x が (?last) つまり (3) 
になる。よって、(last-pair (3) (3)) という応答が得られる。
</p>
<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。</span>
| ?- last_pair([3], X).

X = [3] ? ;

(1 ms) no
</p>

<p class="exercise"><span class="ex_comment">(last-pair (1 2 3) ?x) は、2番目の規則を使って、(last-pair (2 3) ?x) を解くことに
帰着される。今度はこれを2番目の規則を使って解くことになり、それは、
(last-pair (3) ?x) を解くことに帰着される。これは、上記のとおり、1番目の規則で
解くことになり、?x が (3) になる。
というわけで、(last-pair (1 2 3) ?x) の ?x も (3) と解かれる。
つまり、(last-pair (1 2 3) (3)) という応答が得られる。
</p>
<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。</span>
| ?- last_pair([1, 2, 3], X).

X = [3] ? ;

no
</p>

<p class="exercise"><span class="ex_comment">(last-pair (2 ?x) (3)) は、2番目の規則を使って、(last-pair (?x) (3)) を解くことに
帰着される。今度はこれを1番目の規則を使って解くことになるから、?x が 3 に
なる。よって、(last-pair (2 3) (3)) という応答が得られる。
</p>
<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。</span>
| ?- last_pair([2, X], [3]).

X = 3 ? ;

no
</p>

<p class="exercise"><span class="ex_comment">(last-pair ?x (3)) に対しては、1番目の規則から、?x が (3) という結果が得られる
(?last が 3 になり、?x が ?last になるから)。
つまり、(last-pair (3) (3)) という応答が得られる。
でも、意味的に考えると、?x は、最後の要素が 3 でありさえすれば、どんな長さ
でも良いし、最後の要素以外は任意である。つまり、?x に該当するリストは、
無限にあるということ。
これらの無限に存在し得るリストは、クエリ・システムの実装によっては、
(last-pair (? 3) (3))
(last-pair (? ? 3) (3))
(last-pair (? ? ? 3) (3))
   :
   :
みたいな、不定のパタン変数を含む形で順に得られるかもしれないが、
まあ、どうだろうね……?
</p>
<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。</span>
| ?- last_pair(X, [3]).

X = [3] ? ;

X = [_,3] ? ;

X = [_,_,3] ? ;

X = [_,_,_,3] ? ;

X = [_,_,_,_,3] ? ;

X = [_,_,_,_,_,3] ? 

(1 ms) yes
<span class="ex_comment">% きりがないので、<tt>X = [_,_,_,_,_,3] ?</tt> のところで
% リターンを押して中断した。</span>
</p>

<p class="orig" lang="en">
<a name="%_thm_4.63"></a>
<b>Exercise 4.63.</b>  <a name="%_idx_5168"></a><a name="%_idx_5170"></a>The following data base (see Genesis 4) traces the genealogy of the
descendants of Ada back to Adam, by way of Cain:</p>

<p class="trans" lang="ja">
<b>練習問題4.63.</b> 以下のデータベース (創世記4章を参照) は、カインを通じてアダムにまで遡る、アダの子孫の系図をなぞっている。
</p>

<p class="lisp">(son Adam Cain)
(son Cain Enoch)
(son Enoch Irad)
(son Irad Mehujael)
(son Mehujael Methushael)
(son Methushael Lamech)
(wife Lamech Ada)
(son Ada Jabal)
(son Ada Jubal)
</p>
<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。
% なお、以下の記述を含む<a href="bible_db.pl">ファイル</a> (<tt>bible_db.pl</tt>) を作ってある。
% このファイルには、後出の規則も含めてある。</span>
son('Adam', 'Cain').
son('Cain', 'Enoch').
son('Enoch', 'Irad').
son('Irad', 'Mehujael').
son('Mehujael', 'Methushael').
son('Methushael', 'Lamech').
wife('Lamech', 'Ada').
son('Ada', 'Jabal').
son('Ada', 'Jubal').
</p>


<p class="orig" lang="en">Formulate rules such as ``If <em>S</em> is the son of <em>F</em>, and <em>F</em> is the son of <em>G</em>, then <em>S</em> is the grandson of <em>G</em>''
and ``If <em>W</em> is the wife of <em>M</em>, and <em>S</em> is the son of
<em>W</em>, then <em>S</em> is the son of <em>M</em>'' (which was supposedly
more true in biblical times than today) that will enable the query
system to find the grandson of Cain; the sons of Lamech; the grandsons
of Methushael.
(See exercise <a href="#%_thm_4.69">4.69</a> for some rules to
deduce more complicated relationships.)
</p>

<p class="trans" lang="ja">
カインの孫息子や、レメクの息子たちや、メトサエルの孫息子たちをクエリ・システムが見つけられるようにするであろう、
「もし <em class="en">S</em> が <em class="en">F</em> の息子であり、かつ、 <em class="en">F</em> が <em class="en">G</em> の息子であるならば、 <em class="en">S</em> は <em class="en">G</em> の孫息子である」
および
「もし <em class="en">W</em> が <em class="en">M</em> の妻であり、かつ、 <em class="en">S</em> が <em class="en">W</em> の息子であるならば、 <em class="en">S</em> は <em class="en">M</em> の息子である」
(これは、おそらくは、聖書の時代においては現代よりも真実性があった)
のような規則を、定式化せよ
(より込み入った関係を演繹するためのいくつかの規則については、練習問題<a href="#%_thm_4.69">4.69</a>を参照)。
</p>

<p class="exercise">(rule (grandson ?G ?S)
      (and (son ?G ?F) (son ?F ?S)))

(rule (son ?M ?S)
      (and (wife ?M ?W) (son ?W ?S)))

<span class="inline-aa">
アダム─カイン─エノク─イラデ─メホヤエル─メトサエル─レメク
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　├─┬ヤバル
　　　　　　　　　　　　　　　　　　　　　　　　　　　　アダ　└ユバル

</span></p>
<p class="extra_code"><span class="ex_comment">% Prolog だと以下のとおり。</span>
grandson(G, S) :- son(G, F), son(F, S).
son(M, S) :- wife(M, W), son(W, S).

<span class="ex_comment">% クエリの実行例</span>
| ?- grandson('Cain', Grandson).

Grandson = 'Irad' ? ;

no
| ?- son('Lamech', Son).

Son = 'Jabal' ? ;

Son = 'Jubal' ? ;

no
| ?- grandson('Methushael', Grandson).

Grandson = 'Jabal' ? ;

Grandson = 'Jubal' ? ;

(1 ms) no
</p>

<a name="%_sec_4.4.2"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_4.4.2">4.4.2  How the Query System Works</a></h3>
<h3 class="trans" lang="ja">4.4.2 クエリ・システムはどう動くのか</h3>


<p class="orig" lang="en"><a name="%_idx_5172"></a>
In section <a href="#%_sec_4.4.4">4.4.4</a> we will present an
implementation of the query interpreter as a collection of procedures.
In this section we give an overview that explains the general
structure of the system independent of low-level implementation
details.  After describing the implementation of the interpreter, we
will be in a position to understand some of its limitations and some
of the subtle ways in which the query language's logical operations
differ from the operations of mathematical logic.</p>

<p class="trans" lang="ja">
<a href="#%_sec_4.4.4">4.4.4</a>節で、クエリ・インタプリタの実装を、手続きの集まりとして提示しよう。
本節では、低水準の実装の詳細とは独立な、システムの全般的な構造を説明する概要を示す。
インタプリタの実装を説明した後には、私たちは、その限界のうちのいくらかと、クエリ言語の論理演算が数学的論理の演算とは異なっている微妙な点のうちのいくらかについて、理解できる立場にいることだろう。
</p>

<p class="orig" lang="en">
It should be apparent that the query evaluator must perform some kind
of search in order to match queries against facts and rules in the
data base.  One way to do this would be to implement the query system
as a nondeterministic program, using the <tt>amb</tt> evaluator of
section <a href="28_sec4_3.html#%_sec_4.3">4.3</a> (see
exercise <a href="#%_thm_4.78">4.78</a>).  Another possibility is to manage
the search with the aid of streams.  Our implementation follows this
second approach.</p>

<p class="trans" lang="ja">
データベース中の事実および規則に対してクエリを一致させるために、クエリ評価器がある種の探索を実行せねばならない、ということは明白なはずである。
この探索を行うための一つの方法は、<a href="28_sec4_3.html#%_sec_4.3">4.3</a>節の <tt>amb</tt> 評価器を使って、非決定的なプログラムとしてクエリ・システムを実装することであろう (練習問題<a href="#%_thm_4.78">4.78</a>を参照)。
もう一つの可能性は、ストリームの助けを借りて、なんとかうまく探索を行うことだ。
私たちの実装は、この2番目の手法に従っている。
</p>

<p class="orig" lang="en">
The query system is organized around two central operations called
<em>pattern matching</em> and <em>unification</em>.  We first describe
pattern matching and explain how this operation, together with the
organization of information in terms of streams of frames, enables us
to implement both simple and compound queries.  We next discuss
unification, a generalization of pattern matching needed to implement
rules.  Finally, we show how the entire query interpreter fits
together through a procedure that classifies expressions in a manner
analogous to the way <tt>eval</tt> classifies expressions for the
interpreter described in section <a href="26_sec4_1.html#%_sec_4.1">4.1</a>.</p>

<p class="trans" lang="ja">
クエリ・システムは、<em>パタン・マッチング</em>と<em><ruby><rb>単一化</rb><rp> (</rp><rt>ユニフィケーション</rt><rp>) </rp></ruby></em>と呼ばれる、二つの中心的な操作を巡って組織化されている。
最初に、パタン・マッチングについて説明する。そして、この操作が、フレームのストリームを用いた情報の組織化とあいまって、どのようにして単純クエリと複合クエリの双方を実装できるようにしてくれるのか、ということを説明する。
次に、ユニフィケーション——すなわち、規則を実装するのに必要とされる、パタン・マッチングの一般化——について議論する。
最後に、どのようにしてクエリ・インタプリタ全体が、<a href="26_sec4_1.html#%_sec_4.1">4.1</a>節で説明したインタプリタのために <tt>eval</tt> が式を分類した方法と類似のやり方で式を分類する手続きを通じて、うまくまとまるのか、ということを示す。
</p>

<a name="%_sec_Temp_668"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_668">Pattern matching</a></h4>
<h4 class="trans" lang="ja">パタン・マッチング</h4>

<p class="orig" lang="en">
<a name="%_idx_5174"></a><a name="%_idx_5176"></a>
A <em>pattern matcher</em> is a program that tests whether some datum
fits a specified pattern.  For example, the data list <tt>((a b) c (a
b))</tt> matches the pattern <tt>(?x c ?x)</tt> with the pattern variable
<tt>?x</tt> bound to <tt>(a b)</tt>.  The same data list matches the pattern
<tt>(?x ?y ?z)</tt> with <tt>?x</tt> and <tt>?z</tt> both bound to <tt>(a b)</tt>
and <tt>?y</tt> bound to <tt>c</tt>.  It also matches the pattern <tt>((?x ?y) c (?x ?y))</tt> with <tt>?x</tt> bound to <tt>a</tt> and <tt>?y</tt> bound
to <tt>b</tt>.  However, it does not match the pattern <tt>(?x a ?y)</tt>,
since that pattern specifies a list whose second element is the symbol
<tt>a</tt>.</p>

<p class="trans" lang="ja">
<em>パタン・マッチャ</em>は、あるデータが、指定されたパタンに合うかどうかを調べるプログラムである。
たとえば、<tt>((a b) c (a b))</tt> は <tt>(?x c ?x)</tt> というパタンにマッチし、その際、<tt>?x</tt> というパタン変数は <tt>(a b)</tt> に束縛される。
同じデータリストは、<tt>(?x ?y ?z)</tt> というパタンにマッチし、その際、<tt>?x</tt> と <tt>?z</tt> は両方とも <tt>(a b)</tt> に束縛され、<tt>?y</tt> は <tt>c</tt> に束縛される。
これは、<tt>((?x ?y) c (?x ?y))</tt> というパタンにもマッチし、その際、<tt>?x</tt> は <tt>a</tt> に束縛され、<tt>?y</tt> は <tt>b</tt> に束縛される。
しかし、これは <tt>(?x a ?y)</tt> というパタンにはマッチしない。なぜなら、このパタンは、第2要素が <tt>a</tt> という<ruby><rb>記号</rb><rp> (</rp><rt>シンボル</rt><rp>) </rp></ruby>であるようなリストを指定しているためである。
</p>


<p class="orig" lang="en">
<a name="%_idx_5178"></a><a name="%_idx_5180"></a>The pattern matcher used by the query system takes as inputs a
pattern, a datum, and a <em>frame</em> that specifies bindings for
various pattern variables.  It checks whether the datum matches the
pattern in a way that is consistent with the bindings already in the
frame.  If so, it returns the given frame augmented by any bindings
that may have been determined by the match.  Otherwise, it indicates
that the match has failed.</p>

<p class="trans" lang="ja">
クエリ・システムにより使われるパタン・マッチャは、入力として、パタンと、データと、種々のパタン変数に対する束縛を指定する<em>フレーム</em>をとる。
パタン・マッチャは、フレーム内に既にある束縛と整合性のある方法でデータがパタンと合致するかどうかを、調べる。
もし合致すれば、パタン・マッチャは、そのマッチにより拡張された、与えられたフレームを返す。
それ以外の場合、パタン・マッチャは、マッチが失敗した旨を示す。
</p>

<p class="orig" lang="en">
For example, using the pattern <tt>(?x ?y ?x)</tt> to match <tt>(a b a)</tt>
given an empty frame will return a frame specifying that <tt>?x</tt> is
bound to <tt>a</tt> and <tt>?y</tt> is bound to <tt>b</tt>.  Trying the match
with the same pattern, the same datum, and a frame specifying that
<tt>?y</tt> is bound to <tt>a</tt> will fail.  Trying the match with the
same pattern, the same datum, and a frame in which <tt>?y</tt> is bound
to <tt>b</tt> and <tt>?x</tt> is unbound will return the given frame
augmented by a binding of <tt>?x</tt> to <tt>a</tt>.</p>

<p class="trans" lang="ja">
たとえば、空フレームが与えられたとして、<tt>(?x ?y ?x)</tt> というパタンを使って、<tt>(a b a)</tt> と<ruby><rb>一致</rb><rp> (</rp><rt>マッチ</rt><rp>) </rp></ruby>させると、<tt>?x</tt> が <tt>a</tt> に束縛されており、かつ、<tt>?y</tt> が <tt>b</tt> に束縛されている、と指定するフレームが返されるだろう。
同じパタンと、同じデータと、<tt>?y</tt> が <tt>a</tt> に束縛されていると指定するフレームとを使って、そのマッチを試してみると、失敗するだろう。
同じパタンと、同じデータと、<tt>?y</tt> が <tt>b</tt> に束縛されていて <tt>?x</tt> が束縛されていないフレームとを使って、そのマッチを試してみると、<tt>?x</tt> の <tt>a</tt> への束縛によって拡張された、与えられたフレームを返すだろう。
</p>


<p class="orig" lang="en">
<a name="%_idx_5182"></a>The pattern matcher is all the mechanism that is needed to process
simple queries that don't involve rules.  For instance, to process the
query</p>

<p class="trans" lang="ja">
<!--パタン・マッチャは、規則を含まない単純クエリを処理するのに必要な仕組みのすべてである。-->
規則を含まない単純クエリを処理するのに必要な仕組みは、ただパタン・マッチャのみである。
たとえば、以下のクエリを処理するには、
</p>

<p class="lisp">(job ?x (computer programmer))
</p>

<p class="orig" lang="en">we scan through all assertions in the data base and select those that
match the pattern with respect to an initially empty frame.  For each
match we find, we use the frame returned by the match to instantiate
the pattern with a value for <tt>?x</tt>.
</p>


<p class="trans" lang="ja">
データベース内のすべての言明を走査し、最初は空のフレームに関して、パタンと合う言明を選ぶ。
見つけたそれぞれのマッチについて、そのマッチにより返されたフレームを使って、<tt>?x</tt> に対する値でパタンをインスタンス化する。
</p>

<a name="%_sec_Temp_669"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_669">Streams of frames</a></h4>
<h4 class="trans" lang="ja">フレームのストリーム</h4>

<p class="orig" lang="en">
<a name="%_idx_5184"></a><a name="%_idx_5186"></a>
The testing of patterns against frames is organized through the use of
streams.  Given a single frame, the matching process runs through the
data-base entries one by one.  For each data-base entry, the matcher
generates either a special symbol indicating that the match has failed
or an extension to the frame.  The results for all the data-base
entries are collected into a stream, which is passed through a filter
to weed out the failures.  The result is a stream of all the frames
that extend the given frame via a match to some assertion in the data
base.<a name="call_footnote_Temp_670" href="#footnote_Temp_670"><sup><small>67</small></sup></a></p>

<p class="trans" lang="ja">
フレームに対してパタンを試すことは、ストリームの使用を通じて体系化される。
一つのフレームが与えられると、マッチング・プロセスは、データベースのエントリを一つずつざっと点検してゆく。
データベースのエントリそれぞれについて、マッチャは、マッチが失敗したことを示す特殊記号か、フレームの拡張の、いずれかを生成する。
データベースのエントリすべてに対する結果が集められてストリームにされ、そのストリームは、失敗を取り除くためのフィルタを通して、受け渡される。
その結果は、データベース内の何らかの言明に対する<ruby><rb>一致</rb><rp> (</rp><rt>マッチ</rt><rp>) </rp></ruby>を介して、与えられたフレームを拡張するようなすべてのフレームからなる、ストリームである<a name="call_footnote_Temp_670" href="#footnote_Temp_670"><sup><small>67</small></sup></a>。
</p>

<p class="orig" lang="en">
In our system, a query takes an input stream of frames and performs
the above matching operation for every frame in the stream, as
indicated in figure <a href="#%_fig_4.4">4.4</a>.  That is, for each frame in
the input stream, the query generates a new stream consisting of all
extensions to that frame by matches to assertions in the data base.
All these streams are then combined to form one huge stream, which
contains all possible extensions of every frame in the input stream.
This stream is the output of the query.</p>

<p class="trans" lang="ja">
図<a href="#%_fig_4.4">4.4</a>に示すように、私たちのシステムでは、クエリが、フレームの入力ストリームをとり、ストリーム内のすべてのフレームについて上記のマッチング操作を実行する。
つまり、入力ストリーム内の各フレームについて、クエリは、データベース内の言明との<ruby><rb>一致</rb><rp> (</rp><rt>マッチ</rt><rp>) </rp></ruby>による、当該フレームに対するすべての拡張からなる、新たなストリームを生成する。
それから、すべてのこれらのストリームは、結合されて一つの大きなストリームとなるのだが、それは、入力ストリーム内のすべてのフレームの、あり得るすべての拡張を含む。
このストリームが、そのクエリの出力である。
</p>

<figure>
<a name="%_fig_4.4"></a>
<img src="ch4-Z-G-4.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 4.4:</b>  A query processes a stream of frames.</figcaption>
<figcaption class="trans" lang="ja"><b>図4.4:</b> クエリがフレームのストリームを処理する</figcaption>
</figure>


<p class="orig" lang="en">
<a name="%_idx_5194"></a>To answer a simple query, we use the query with an input stream
consisting of a single empty frame.  The resulting output stream
contains all extensions to the empty frame (that is, all answers to
our query).  This stream of frames is then used to generate a stream
of copies of the original query pattern with the variables
instantiated by the values in each frame, and this is the stream that
is finally printed.</p>

<p class="trans" lang="ja">
単純クエリに応えるためには、単一の空フレームからなる入力ストリームとともに、そのクエリを使う。
結果として生じる出力ストリームは、空フレームに対するすべての拡張 (つまり、我らがクエリに対するすべての答え) を含む。
このフレームのストリームは、それから、各フレーム内の値によって変数がインスタンス化された元のクエリ・パタンのコピーからなるストリームを生成するのに使われ、これ <span class="note">(こうして生成されたストリーム)</span> が、最後に印字されるストリームである。
</p>

<a name="%_sec_Temp_671"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_671">Compound queries</a></h4>
<h4 class="trans" lang="ja">複合クエリ</h4>

<p class="orig" lang="en">
<a name="%_idx_5196"></a>
The real elegance of the stream-of-frames implementation is evident
when we deal with compound queries.  The processing of compound
queries makes use of the ability of our matcher to demand that a match
<a name="%_idx_5198"></a>be consistent with a specified frame.  For example, to handle the <tt>and</tt> of two queries, such as</p>

<p class="trans" lang="ja">
フレームのストリームを使った実装の真の洗練ぶりは、複合クエリを扱うときに明らかとなる。指定されたフレームに対して整合性が取れているように、とマッチに対して要求できる、私たちのマッチャの能力を、複合クエリの処理では利用する。
たとえば、以下のような二つのクエリの <tt>and</tt> を扱うには
</p>

<p class="lisp">(and (can-do-job ?x (computer programmer trainee))
     (job ?person ?x))
</p>

<p class="orig" lang="en">(informally, ``Find all people who can do the job of a computer
programmer trainee''), we first find all entries that match the
pattern</p>

<p class="trans" lang="ja">
(これは、くだけた言い方をするなら、「コンピュータ・プログラマ見習いの仕事ができる、すべての人たちを求めよ」である)、まず以下のパタンに合致するすべてのエントリを求める。
</p>

<p class="lisp">(can-do-job ?x (computer programmer trainee))
</p>

<p class="orig" lang="en">This produces a stream of frames, each of which contains a binding for
<tt>?x</tt>.  Then for each frame in the stream we find all entries that
match</p>

<p class="trans" lang="ja">
これはフレームのストリームを作り出し、それらフレームの各々は、<tt>?x</tt> に対する束縛を含む。
そして、ストリーム内の各フレームについて、以下に合致するすべてのエントリを求める
</p>

<p class="lisp">(job ?person ?x)
</p>

<p class="orig" lang="en">in a way that is consistent with the given binding for <tt>?x</tt>.  Each
such match will produce a frame containing bindings for <tt>?x</tt> and
<tt>?person</tt>.  The <tt>and</tt> of two queries can be viewed as a series
combination of the two component queries, as shown in
figure <a href="#%_fig_4.5">4.5</a>.  The frames that pass through the first
query filter are filtered and further extended by the second query.</p>

<p class="trans" lang="ja">
—— <tt>?x</tt> に対する、与えられた束縛と整合性の取れた方法で合致する、すべてのエントリを求めるのである。
そのような各マッチは、<tt>?x</tt> と <tt>?person</tt> に対する束縛を含むフレームを作り出すだろう。
二つのクエリの <tt>and</tt> は、図 <a href="#%_fig_4.5">4.5</a>に示されるように、二つの成分クエリの直列の結合だと見なせる。
1番目のクエリのフィルタを通るフレームが、2番目のクエリにより、さらにフィルタにかけられ、拡張されるのである。
</p>


<figure>
<a name="%_fig_4.5"></a>
<img src="ch4-Z-G-5.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 4.5:</b>  The <tt>and</tt> combination of two queries is
produced by operating on the stream of frames in series.</figcaption>
<figcaption class="trans" lang="ja"><b>図4.5:</b> 二つのクエリの <tt>and</tt> 結合は、フレームのストリームに対して直列に操作を加えることにより、作り出される。</figcaption>
</figure>

<p class="orig" lang="en">
<a name="%_idx_5200"></a>Figure <a href="#%_fig_4.6">4.6</a> shows the analogous method for computing the
<tt>or</tt> of two queries as a parallel combination of the two component
queries.  The input stream of frames is extended separately by each
query.  The two resulting streams are then merged to produce the final
output stream.</p>

<p class="trans" lang="ja">
図<a href="#%_fig_4.6">4.6</a>は、二つのクエリの <tt>or</tt> を二つの成分クエリの並列な結合として計算するための、類似の方法を示している。
入力された、フレームのストリームは、それぞれのクエリによって別々に拡張される。
結果として生じる二つのストリームは、その後、併合されて最終出力ストリームを作り出す。
</p>

<figure>
<a name="%_fig_4.6"></a>
<img src="ch4-Z-G-6.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 4.6:</b>  The <tt>or</tt> combination of two queries is produced by 
operating on the stream of frames in parallel and merging the
results.</figcaption>
<figcaption class="trans" lang="ja"><b>図4.6: 二つのクエリの <tt>or</tt> 結合は、フレームのストリームに対して並列に操作を加え、その結果同士を併合することによって、作り出される。</b></figcaption>
</figure>


<p class="orig" lang="en">
<a name="%_idx_5202"></a>Even from this high-level description, it is apparent that the
processing of compound queries can be slow.
For example, since a query may produce more than one output frame for
each input frame, and each query in an <tt>and</tt> gets its input frames
from the previous query, an <tt>and</tt> query could, in the worst case,
have to perform a number of matches that is exponential in the number
of queries (see exercise <a href="#%_thm_4.76">4.76</a>).<a name="call_footnote_Temp_672" href="#footnote_Temp_672"><sup><small>68</small></sup></a>
Though systems for handling only simple queries are quite practical,
dealing with complex queries is extremely difficult.<a name="call_footnote_Temp_673" href="#footnote_Temp_673"><sup><small>69</small></sup></a></p>

<p class="trans" lang="ja">
この高いレベルの記述からですら、複合クエリの処理が遅くなり得ることは明白だ。
たとえば、クエリは、各入力フレームに対して一つよりも多い出力フレームを作り出すことがあるので、そしてまた、<tt>and</tt> 内の各クエリは、自身の入力フレームを前のクエリから取得するので、最悪の場合、<tt>and</tt> クエリは、クエリの数に対して指数関数的な回数のマッチを実行せねばならない、ということになり兼ねない (練習問題<a href="#%_thm_4.76">4.76</a>を参照)<a href="#footnote_Temp_672"><sup><small>68</small></sup></a>。
単純なクエリのみを扱うシステムはとても現実的だが、複雑なクエリを扱うことは非常に困難である<a href="#footnote_Temp_673"><sup><small>69</small></sup></a>。
</p>

<p class="orig" lang="en">
<a name="%_idx_5204"></a>From the stream-of-frames viewpoint, the <tt>not</tt> of some query acts
as a filter that removes all frames for which the query can be
satisfied.  For instance, given the pattern</p>

<p class="trans" lang="ja">
フレームのストリームの観点からは、ある種のクエリの <tt>not</tt> は、そのクエリを満たせるすべてのフレームを取り除くフィルタとして振る舞う。
たとえば、以下のパタンが与えられると、
</p>

<p class="lisp">(not (job ?x (computer programmer)))
</p>

<p class="orig" lang="en">we attempt, for each frame in the input stream, to produce extension
frames that satisfy <tt>(job ?x (computer programmer))</tt>.  We remove
from the input stream all frames for which such extensions exist.  The
result is a stream consisting of only those frames in which the
binding for <tt>?x</tt> does not satisfy <tt>(job ?x (computer
programmer))</tt>.  For example, in processing the query</p>

<p class="trans" lang="ja">
入力ストリーム中の各フレームに対して、
<tt>(job ?x (computer programmer))</tt>
を満たす拡張フレームを作り出そうと試みる。
そうした拡張が存在するようなすべてのフレームを、入力ストリームから取り除く。
その結果は、<tt>?x</tt> に対する束縛が
<tt>(job ?x (computer programmer))</tt>
を満たさないようなフレームのみからなるストリームである。
たとえば、以下のクエリを処理する際に、
</p>

<p class="lisp">(and (supervisor ?x ?y)
     (not (job ?x (computer programmer))))
</p>

<p class="orig" lang="en">the first clause will generate frames with bindings for <tt>?x</tt> and
<tt>?y</tt>.  The <tt>not</tt> clause will then filter
these by removing all frames in which the binding for <tt>?x</tt>
satisfies the restriction that <tt>?x</tt> is a computer
programmer.<a name="call_footnote_Temp_674" href="#footnote_Temp_674"><sup><small>70</small></sup></a></p>

<p class="trans" lang="ja">
1番目の節は、<tt>?x</tt> と <tt>?y</tt> に対する束縛を有するフレームを生成するだろう。
それから、<tt>not</tt> 節がこれらフレームをフィルタにかけるだろう—— <tt>?x</tt> はコンピュータ・プログラマだという制約を、<tt>?x</tt> に対する束縛が満たしているようなすべてのフレームを取り除くことによって<a href="#footnote_Temp_674"><sup><small>70</small></sup></a>。
</p>

<p class="orig" lang="en">
<a name="%_idx_5206"></a>The <tt>lisp-value</tt> special form is implemented as a similar filter
on frame streams.  We use each frame in the stream to instantiate any
variables in the pattern, then apply the Lisp predicate.  We remove
from the input stream all frames for which the predicate fails.
</p>

<p class="trans" lang="ja">
<tt>lisp-value</tt> 特殊形式は、フレーム・ストリームに対する類似のフィルタとして実装される。
パタン内の任意の変数をインスタンス化するのに、私たちは、ストリーム内の各フレームを用い、それから、Lisp 述語を適用する。
述語が失敗するようなすべてのフレームを、私たちは入力ストリームから取り除く。
</p>


<a name="%_sec_Temp_675"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_675">Unification</a></h4>
<h4 class="trans" lang="ja">ユニフィケーション</h4>

<p class="orig" lang="en">
<a name="%_idx_5208"></a><a name="%_idx_5210"></a>
In order to handle rules in the query language, we must be able to
find the rules whose conclusions match a given query pattern.  Rule
conclusions are like assertions except that they can contain
variables, so we will need a generalization of pattern
matching -- called <em>unification</em> -- in which both the ``pattern''
and the ``datum'' may contain variables.</p>

<p class="trans" lang="ja">
クエリ言語での規則を扱うためには、与えられたクエリ・パタンに帰結部が合致するような規則を求めることができなくてはならない。
規則の帰結部は、変数を含むことができるという点を除いて言明と似ており、したがって、「パタン」と「データ」の双方が変数を含むことのあり得る、パタン・マッチングの一般化——<em>ユニフィケーション</em>と呼ばれる——が、必要となるだろう。
</p>

<p class="orig" lang="en">
A unifier takes two patterns, each containing constants and variables,
and determines whether it is possible to assign values to the
variables that will make the two patterns equal.  If so, it returns a
frame containing these bindings.  For example, unifying <tt>(?x a
?y)</tt> and <tt>(?y ?z a)</tt> will specify a frame in which <tt>?x</tt>, 
<tt>?y</tt>, and <tt>?z</tt> must all be bound to <tt>a</tt>.  On the other
hand, unifying <tt>(?x ?y a)</tt> and <tt>(?x b ?y)</tt> will fail, because
there is no value for <tt>?y</tt> that can make the two patterns equal.
(For the second elements of the patterns to be equal, <tt>?y</tt> would
have to be <tt>b</tt>; however, for the third elements to be equal, <tt>?y</tt> would have to be <tt>a</tt>.)  The unifier used in the query system,
like the pattern matcher, takes a frame as input and performs
unifications that are consistent with this frame.</p>

<p class="trans" lang="ja">
<ruby><rb>統一器</rb><rp> (</rp><rt>ユニファイア</rt><rp>) </rp></ruby>は、二つのパタン——その各々は定数と変数を含む——をとり、そして、二つのパタンを等価にするように値を変数に<ruby><rb>代入する</rb><rp> (</rp><rt>わりあてる</rt><rp>) </rp></ruby>ことが可能かどうかを、判定する。<!-- <span class="note">(ここの that は so that の略)</span> -->
もし可能なら、ユニファイアは、これらの束縛を含むフレームを返す。
たとえば、<tt>(?x a ?y)</tt> と <tt>(?y ?z a)</tt> を<ruby><rb>統一</rb><rp> (</rp><rt>ユニファイ</rt><rp>) </rp></ruby>することで、<tt>?x</tt> と <tt>?y</tt> と <tt>?z</tt> のすべてが <tt>a</tt> に束縛されているはずのフレームを指定することになるだろう。
他方、<tt>(?x ?y a)</tt> と <tt>(?x b ?y)</tt> のユニファイは失敗するだろう。なぜなら、二つのパタンを等しくすることの可能な、<tt>?y</tt> に対する値は存在しないためである (パタンの2番目の要素を等しくするためには、<tt>?y</tt> は <tt>b</tt> でなくてはならないだろう。しかし、3番目の要素を等しくするためには、<tt>?y</tt> は <tt>a</tt> でなくてはならないだろう)。
クエリ・システムで使われるユニファイアは、パタン・マッチャと同様に、入力としてフレームをとり、このフレームと整合性のとれたユニフィケーションを実行する。
</p>

<p class="orig" lang="en">
The unification algorithm is the most technically difficult part of
the query system.  With complex patterns, performing unification may
seem to require deduction.  To unify <tt>(?x ?x)</tt> and <tt>((a ?y c)
(a b ?z))</tt>, for example, the algorithm must infer that <tt>?x</tt> should
be <tt>(a b c)</tt>,   <tt>?y</tt> should be <tt>b</tt>, and <tt>?z</tt> should
be <tt>c</tt>.  We may think of this process as solving a set of
equations among the pattern components.  In general, these are
simultaneous equations, which may require substantial manipulation to
solve.<a name="call_footnote_Temp_676" href="#footnote_Temp_676"><sup><small>71</small></sup></a>  For example, unifying <tt>(?x
?x)</tt> and <tt>((a ?y c) (a b ?z))</tt> may be thought of as specifying the
simultaneous equations</p>

<p class="trans" lang="ja">
ユニフィケーション・アルゴリズムは、クエリ・システムのうちで最も技術的に困難な部分である。
複雑なパタンがある場合、ユニフィケーションの実行は、演繹を必要とするように見えるかもしれない。
たとえば、<tt>(?x ?x)</tt> と <tt>((a ?y c) (a b ?z))</tt> をユニファイするには、アルゴリズムは、 <tt>?x</tt> が <tt>(a b c)</tt> である筈、かつ、<tt>?y</tt> が <tt>b</tt> である筈、かつ、<tt>?z</tt> が <tt>c</tt> である筈、と推測せねばならない。
このプロセスは、パタン成分同士の間の方程式の集合を解くことだと見なせる。
一般に、これらは連立方程式であり、特には相当な操作が必要となる場合がある<a href="#footnote_Temp_676"><sup><small>71</small></sup></a>。
たとえば、<tt>(?x ?x)</tt> と <tt>((a ?y c) (a b ?z))</tt> をユニファイすることを、以下の連立方程式を指定することだと見なしてもよい。
</p>

<p class="lisp">?x  =  (a ?y c)
?x  =  (a b ?z)
</p>

<p class="orig" lang="en">These equations imply that</p>

<p class="trans" lang="ja">
これらの方程式は、以下を暗示しており、
</p>

<p class="lisp">(a ?y c)  =  (a b ?z)
</p>

<p class="orig" lang="en">which in turn implies that</p>

<p class="trans" lang="ja">
これが、今度は以下を暗示しており、
</p>

<p class="lisp">a  =  a, ?y  =  b, c  =  ?z,
</p>

<p class="orig" lang="en">and hence that</p>

<p class="trans" lang="ja">
したがって、以下も暗示している。
</p>

<p class="lisp">?x  =  (a b c)
</p>

<p class="orig" lang="en">
<a name="%_idx_5212"></a><a name="%_idx_5214"></a>In a successful pattern match, all pattern variables become bound, and
the values to which they are bound contain only constants.  This is
also true of all the examples of unification we have seen so far.  In
general, however, a successful unification may not completely
determine the variable values; some variables may remain unbound and
others may be bound to values that contain variables.</p>

<p class="trans" lang="ja">
成功するパタン・マッチでは、すべてのパタン変数が束縛されるようになり、それらのパタン変数が束縛される値は、定数のみを含む。
このことは、これまでに私たちが見てきたユニフィケーションのすべての例に当てはまる。
しかし、一般には、成功するユニフィケーションが変数の値を完全に決定するとは限らない。いくつかの変数は、束縛されないままかもしれず、他の変数も、変数を含む値に束縛されているかもしれない。
</p>

<p class="orig" lang="en">
Consider the unification of <tt>(?x a)</tt> and <tt>((b ?y) ?z)</tt>.  We
can deduce that <tt>?x  =  (b ?y)</tt> and <tt>a  =  ?z</tt>, but we cannot
further solve for <tt>?x</tt> or <tt>?y</tt>.  The unification doesn't fail,
since it is certainly possible to make the two patterns equal by
assigning values to <tt>?x</tt> and <tt>?y</tt>.  Since this match in no way
restricts the values <tt>?y</tt> can take on, no binding for <tt>?y</tt> is
put into the result frame.  The match does, however, restrict the
value of <tt>?x</tt>.  Whatever value <tt>?y</tt> has, <tt>?x</tt> must be <tt>(b ?y)</tt>.  A binding of <tt>?x</tt> to the pattern <tt>(b ?y)</tt> is thus
put into the frame.  If a value for <tt>?y</tt> is later determined and
added to the frame (by a pattern match or unification that is required
to be consistent with this frame), the previously bound <tt>?x</tt> will
refer to this value.<a name="call_footnote_Temp_677" href="#footnote_Temp_677"><sup><small>72</small></sup></a>
</p>

<p class="trans" lang="ja">
<tt>(?x a)</tt> と <tt>((b ?y) ?z)</tt> のユニフィケーションを考えよう。
<tt>?x = (b ?y)</tt> かつ <tt>a = ?z</tt> だと演繹できるが、<tt>?x</tt> についても <tt>?y</tt> についてもさらに解くことはできない。
<tt>?x</tt> と <tt>?y</tt> に値を<ruby><rb>代入する</rb><rp> (</rp><rt>わりあてる</rt><rp>) </rp></ruby>ことで二つのパタンを等しくすることが確かに可能なので、ユニフィケーションは失敗しない。
このマッチは、<tt>?y</tt> が帯びることのできる値を決して制限しないので、<tt>?y</tt> に対する束縛は何も結果フレームに表現されない。
しかし、マッチは、確かに <tt>?x</tt> の値を制限する。
<tt>?y</tt> がいかなる値を持とうと、<tt>?x</tt> は <tt>(b ?y)</tt> でなくてはならないのだ。
<tt>(b ?y)</tt> というパタンへの <tt>?x</tt> の束縛は、したがって、フレームに表現される。
もし後に、(このフレームと整合性が取れていることを要求されるような、パタン・マッチまたはユニフィケーションによって) <tt>?y</tt> に対する値が決定され、フレームに追加されたら、先に束縛された <tt>?x</tt> は、この値を参照するだろう <a href="#footnote_Temp_677"><sup><small>72</small></sup></a>。
</p>

<a name="%_sec_Temp_678"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_678">Applying rules</a></h4>
<h4 class="trans" lang="ja">規則を適用する</h4>

<p class="orig" lang="en">
<a name="%_idx_5216"></a>
Unification is the key to the component of the query system that makes
inferences from rules. To see how this is accomplished, consider
processing a query that involves applying a rule, such as</p>

<p class="trans" lang="ja">
ユニフィケーションは、規則から推論を行う、クエリ・システムの構成要素への、鍵である。
これをどのように達成するのかを見るために、以下のような、規則の適用を伴う、クエリの処理について考えよう。
</p>

<p class="lisp">(lives-near ?x (Hacker Alyssa P))
</p>

<p class="orig" lang="en">To process this query, we first use the ordinary pattern-match
procedure described above to see if there are any assertions in the
data base that match this pattern.  (There will not be any in this
case, since our data base includes no direct assertions about who
lives near whom.)  The next step is to attempt to unify the query
pattern with the conclusion of each rule.  We find that the pattern
unifies with the conclusion of the rule</p>

<p class="trans" lang="ja">
このクエリを処理するには、まず、このパタンに合致する言明が何かデータベース内にあるかどうかを見るために、上記のような通常のパタン・マッチ手続きを使う
(この場合は何もないだろう。なぜなら、誰が誰の近くに住んでいるかについての直接的言明を、私たちのデータベースは何も含んでいないためである)。
次の段階は、クエリ・パタンを各規則の帰結部とユニファイすることを試みることである。
このパタンが、以下の規則の帰結部とユニファイする、ということが分かり、
</p>

<p class="lisp">(rule (lives-near ?person-1 ?person-2)
      (and (address ?person-1 (?town . ?rest-1))
           (address ?person-2 (?town . ?rest-2))
           (not (same ?person-1 ?person-2))))
</p>

<p class="orig" lang="en">resulting in a frame specifying that <tt>?person-2</tt> is bound
to <tt>(Hacker Alyssa P)</tt> and that <tt>?x</tt> should be bound to (have
the same value as) <tt>?person-1</tt>.  Now, relative to this frame, we
evaluate the compound query given by the body of the rule.  Successful
matches will extend this frame by providing a binding for <tt>?person-1</tt>, and consequently a value for <tt>?x</tt>, which we can use to
instantiate the original query pattern.</p>

<p class="trans" lang="ja">
これは、<tt>?person-2</tt> が <tt>(Hacker Alyssa P)</tt> に束縛されていて <tt>?x</tt> は <tt>?person-1</tt> に束縛される (これと同じ値を有する) べきである、と指定するフレームを結果としてもたらすものである。
さてここで、このフレームに関して、私たちは、規則の本体部により与えられた構成要素クエリを評価する。
うまくいくマッチは、<tt>?person-1</tt> に対する束縛を、そしてその結果として <tt>?x</tt> に対する値——元のクエリ・パタンをインスタンス化するのに使える——を、与えることによって、このフレームを拡張するだろう。
</p>

<p class="orig" lang="en">
In general, the query evaluator uses the following method to apply a
rule when trying to establish a query pattern in a frame that
specifies bindings for some of the pattern variables:</p>

<p class="trans" lang="ja">
一般に、クエリ評価器は、パタン変数のうちの一部に対する束縛を指定するフレーム内でクエリ・パタンを成立させようと試みる際に、以下の方法を使って規則を適用する。
</p>

<ul class="orig" lang="en">
<li>Unify the query with the conclusion of the rule to form, if
successful, an extension of the original frame.</li>

<li>Relative to the extended frame, evaluate the query formed by
the body of the rule.</li>
</ul>

<ul class="trans" lang="ja">
<li>クエリを規則の帰結部とユニファイして、もしそれがうまくいけば、元のフレームの拡張を形成せよ。</li>
<li>拡張されたフレームに関して、規則の本体部により形成されるクエリを評価せよ。</li>
</ul>

<p class="orig" lang="en">
<a name="%_idx_5218"></a>Notice how similar this is to the method for applying a procedure in
the <tt>eval</tt>/<tt>apply</tt> evaluator for Lisp:
</p>

<p class="trans" lang="ja">
これが、Lisp用の <tt>eval</tt>/<tt>apply</tt> 評価器において手続きを適用する方法と、いかに似ているのか、ということに気づいてほしい。
</p>

<ul class="orig" lang="en">
<li>Bind the procedure's parameters to its arguments to form a
frame that extends the original procedure environment.</li>

<li>Relative to the extended environment, evaluate the expression
formed by the body of the procedure.</li>
</ul>

<ul class="trans" lang="ja">
<li>手続きの仮引数を実引数に束縛して、元の手続き環境を拡張するフレームを形成せよ。</li>
<li>拡張された環境に関して、手続きの本体部により形成される式を評価せよ。</li>
</ul>

<p class="orig" lang="en">
The similarity between the two evaluators should come as no surprise.
Just as procedure definitions are the means of abstraction in Lisp,
rule definitions are the means of abstraction in the query language.
In each case, we unwind the abstraction by creating appropriate
bindings and evaluating the rule or procedure body relative to these.
</p>

<p class="trans" lang="ja">
二つの評価器の類似性は、何の驚きでもないはずだ。
手続き定義がLispにおける抽象化の手段であるのとちょうど同じように、規則定義はクエリ言語における抽象化の手段である。
それぞれの場合において、私たちは、適切な束縛を作り出すことと、これらの束縛に関して規則または手続きの本体を評価することによって、抽象化を解きほぐすのだ。
</p>

<a name="%_sec_Temp_679"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_679">Simple queries</a></h4>
<h4 class="trans" lang="ja">単純クエリ</h4>

<p class="orig" lang="en">
<a name="%_idx_5220"></a>
We saw earlier in this section how to evaluate simple queries in the
absence of rules.  Now that we have seen how to apply rules, we can
describe how to evaluate simple queries by using both rules and
assertions.</p>

<p class="trans" lang="ja">
本節の初めの方では、規則なしで単純クエリをどのようにして評価するのかを見た。
今や私たちは、規則をどのように適用するのかを既に見た訳なので、規則と言明の双方を用いることで単純クエリをどのようにして評価するのか、ということを記述できる。
</p>

<p class="orig" lang="en">
Given the query pattern and a stream of frames, we produce, for each
frame in the input stream, two streams:</p>

<p class="trans" lang="ja">
クエリ・パタンと、フレームのストリームとを与えられると、私たちは、入力ストリーム内の各フレームについて、次の二つのストリームを作り出す。
</p>

<ul class="orig" lang="en">
<li>a stream of extended frames obtained by matching the pattern
against all assertions in the data base (using the pattern matcher),
and</li>

<li>a stream of extended frames obtained by applying all
possible rules (using the unifier).<a name="call_footnote_Temp_680" href="#footnote_Temp_680"><sup><small>73</small></sup></a></li>
</ul>

<ul class="trans" lang="ja">
<li>データベース内のすべての言明に対してパタンをマッチさせることによって得られる、拡張されたフレームからなる、ストリーム。</li>
<li>すべての可能な規則を (ユニファイアを用いて) 適用することによって得られる、拡張されたフレームからなる、ストリーム<a href="#footnote_Temp_680"><sup><small>73</small></sup></a>。</li>
</ul>

<p class="orig" lang="en">
Appending these two streams produces a stream that consists of all the
ways that the given pattern can be satisfied consistent with the
original frame.  These streams (one for each frame in the input
stream) are now all combined to form one large stream, which therefore
consists of all the ways that any of the frames in the original input
stream can be extended to produce a match with the given pattern.</p>

<p class="trans" lang="ja">
これら二通りのストリームをつなげることで、元のフレームと整合性を保ちつつも与えられたパタンを満たせるような、すべての方法からなるストリームが、作り出される。
これらのストリーム (入力ストリーム内の各フレームにつき、一つある) は、今や、すべてが結合されて、一つの巨大なストリームを形成し、したがってその巨大なストリームは、元の入力ストリーム内のフレームのうちのどれかを、与えられたパタンとのマッチを作り出すように拡張することが可能な、すべての方法からなる。
</p>


<a name="%_sec_Temp_681"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_681">The query evaluator and the driver loop</a></h4>
<h4 class="trans" lang="ja">クエリの評価器とドライバ・ループ</h4>

<p class="orig" lang="en">
<a name="%_idx_5226"></a>
Despite the complexity of the underlying matching operations, the
system is organized much like an evaluator for any language.  The
procedure that coordinates the matching operations is called <a name="%_idx_5228"></a><a name="%_idx_5230"></a><tt>qeval</tt>, and it plays a role analogous to that of the <tt>eval</tt>
procedure for Lisp.  <tt>Qeval</tt> takes as inputs a query and a stream
of frames.  Its output is a stream of frames, corresponding to
successful matches to the query pattern, that extend some frame in the
input stream, as indicated in figure <a href="#%_fig_4.4">4.4</a>.  Like
<tt>eval</tt>, <tt>qeval</tt> classifies the different types of expressions
(queries) and dispatches to an appropriate procedure for each.  There
is a procedure for each special form (<tt>and</tt>, <tt>or</tt>, <tt>not</tt>,
and <tt>lisp-value</tt>) and one for simple queries.</p>

<p class="trans" lang="ja">
根底にあるマッチング演算の複雑さにもかかわらず、システムは、任意の言語の評価器とほとんど同様に体系化されている。
マッチング演算を調整する手続きは <tt>qeval</tt> と呼ばれ、これは、Lispに対する <tt>eval</tt> 手続きの役割と似た役割を果たす。
<tt>qeval</tt> は、クエリと、フレームのストリームとを、入力としてとる。
これの出力は、図<a href="#%_fig_4.4">4.4</a>に示したように、入力ストリーム内の何らかのフレームを拡張するようなフレームのストリーム——クエリ・パタンに対する、成功したマッチに対応している——である。
<tt>eval</tt> と同様に <tt>qeval</tt> も、異なる種類の式 (クエリ) を分類し、それぞれについて、適切な手続きへの振り分けを行う。
各特殊形式  (<tt>and</tt> と <tt>or</tt> と <tt>not</tt> と <tt>lisp-value</tt>) に対して手続きがあり、単純クエリに対して一つの手続きがある。
</p>

<p class="orig" lang="en">
<a name="%_idx_5232"></a><a name="%_idx_5234"></a>The driver loop, which is analogous to the <tt>driver-loop</tt> procedure
for the other evaluators in this chapter, reads queries from the
terminal.  For each query, it calls <tt>qeval</tt> with the query and a
stream that consists of a single empty frame.  This will produce the
stream of all possible matches (all possible extensions to the empty
frame).  For each frame in the resulting stream, it instantiates the
original query using the values of the variables found in the frame.
This stream of instantiated queries is then printed.<a name="call_footnote_Temp_682" href="#footnote_Temp_682"><sup><small>74</small></sup></a></p>

<p class="trans" lang="ja">
ドライバ・ループは、本章での別の評価器用の <tt>driver-loop</tt> 手続きと似ているのだが、これは、クエリを端末から読み込む。
各クエリに対して、ドライバ・ループは、当該クエリと、単一の空フレームからなるストリームとともに、<tt>qeval</tt> を呼び出す。
これは、すべての可能なマッチ (空フレームに対する、すべての可能な拡張) のストリームを作り出すだろう。
結果として生じるストリームの中の各フレームについて、ドライバ・ループは、当該フレーム内で見つかる変数の値を用いて、元のクエリをインスタンス化する。
インスタンス化されたクエリの、このストリームが、それから印字される <a href="#footnote_Temp_682"><sup><small>74</small></sup></a>。
</p>

<p class="orig" lang="en">
<a name="%_idx_5240"></a><a name="%_idx_5242"></a>The driver also checks for the special command <tt>assert!</tt>, which
signals that the input is not a query but rather an assertion or rule
to be added to the data base.  For instance,</p>

<p class="trans" lang="ja">
ドライバは、<tt>assert!</tt> という特殊命令——入力がクエリではなくて、むしろデータベースに追加されるべき言明または規則なのだ、と合図をよこして知らせる——も、確認する。
たとえば、以下のようなものである。
</p>

<p class="lisp">(assert! (job (Bitdiddle Ben) (computer wizard)))
(assert! (rule (wheel ?person)
               (and (supervisor ?middle-manager ?person)
                    (supervisor ?x ?middle-manager))))
</p>

<a name="%_sec_4.4.3"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_4.4.3">4.4.3  Is Logic Programming Mathematical Logic?</a></h3>
<h3 class="trans" lang="ja">4.4.3 論理プログラミングは数学的論理なのか?</h3>


<p class="orig" lang="en"><a name="%_idx_5244"></a><a name="%_idx_5246"></a>
The means of combination used in the query language may at first seem
identical to the operations <tt>and</tt>, <tt>or</tt>, and <tt>not</tt> of
mathematical logic, and the application of query-language rules is in
fact accomplished through a legitimate method of
<a name="%_idx_5248"></a>inference.<a name="call_footnote_Temp_683" href="#footnote_Temp_683"><sup><small>75</small></sup></a> This identification of the query language with mathematical
logic is not really valid, though, because the query language provides
a <a name="%_idx_5252"></a><em>control structure</em> that interprets the logical statements
procedurally.  We can often take advantage of this control structure.
For example, to find all of the supervisors of programmers we could
formulate a query in either of two logically equivalent forms:</p>

<p class="trans" lang="ja">
クエリ言語で使われる結合手段は、最初は、数学的論理の <tt>and</tt> と <tt>or</tt> と <tt>not</tt> という演算と同一なように見えるかもしれないし、クエリ言語の規則の適用は、実際、推論の正当な方法を通じて達成される<a href="#footnote_Temp_683"><sup><small>75</small></sup></a>。
しかし、このようにクエリ言語を数学的論理と同一視することは、現実には、妥当ではない。なぜなら、クエリ言語は、論理的な<ruby><rb>文</rb><rp> (</rp><rt>ステートメント</rt><rp>) </rp></ruby>を手続き的に解釈する<em>制御構造</em>を提供するからである。
私たちはしばしばこの制御構造を利用することができる。
たとえば、プログラマたちのすべての上司を見つけるには、論理的に等価な二つの形のいずれかで、クエリを定式化することができるだろう。
</p>


<p class="lisp">(and (job ?x (computer programmer))
     (supervisor ?x ?y))
</p>

<p class="orig" lang="en">or
</p>

<p class="trans" lang="ja">
または
</p>


<p class="lisp">(and (supervisor ?x ?y)
     (job ?x (computer programmer)))
</p>

<p class="orig" lang="en"><a name="%_idx_5254"></a>If a company has many more supervisors than programmers (the usual
case), it is better to use the first form rather than the second
because the data base must be scanned for each intermediate result
(frame) produced by the first clause of the <tt>and</tt>.</p>

<p class="trans" lang="ja">
もしプログラマよりもずっと多くの上司たちが会社にいるなら (通常の場合)、2番目の形ではなく、1番目の形を使う方が良い。なぜなら、<tt>and</tt> の最初の節によって作り出されるそれぞれの中間結果 (フレーム) について、データベースを走査しなくてはならないからだ。
</p>

<p class="orig" lang="en">
<a name="%_idx_5256"></a><a name="%_idx_5258"></a>The aim of logic programming is to provide the programmer with
techniques for decomposing a computational problem into two separate
problems: ``what'' is to be computed, and ``how'' this should be
computed.  This is accomplished by selecting a subset of the
statements of mathematical logic that is powerful enough to be able to
describe anything one might want to compute, yet weak enough to have a
controllable procedural interpretation.  The intention here is that,
on the one hand, a program specified in a logic programming language
should be an effective program that can be carried out by a computer.
Control (``how'' to compute) is effected by using the order of
evaluation of the language.  We should be able to arrange the order of
clauses and the order of subgoals within each clause so that the
computation is done in an order deemed to be effective and efficient.
At the same time, we should be able to view the result of the
computation (``what'' to compute) as a simple consequence of the laws
of logic.</p>

<p class="trans" lang="ja">
論理プログラミングの目的は、計算にまつわる問題を、二つの別々の問題——「何を」計算すべきなのかということと、これを「どのようにして」計算すべきなのかということ——へと分解するための技法を、プログラマに提供することである。
これは、人が計算したがるかもしれないものを何でも記述可能であるために十分なほど強力だが、それでも、制御可能な手続き的解釈があるという程度には十分に弱いような、数学的論理の<ruby><rb>文</rb><rp> (</rp><rt>ステートメント</rt><rp>) </rp></ruby>の部分集合を選ぶことによって、達成される。
ここでの意図は、こうである。すなわち、一方では、論理プログラミング言語で詳細を記述されるプログラムは、コンピュータによって実行できるような、有効なプログラムであるべきである。
制御 (「どうやって」計算するか) は、言語の評価の順序を利用することで、達成される。
有効かつ効率的だと思われる順序で計算が行われるように、私たちは、節の順序と、それぞれの節の中の下位目標の順序を、整えることができるべきである。
同時に、私たちは、計算の結果 (「何を」計算すべきか) を、論理の法則の簡単な結果として見ることができるべきなのだ。
</p>

<p class="orig" lang="en">
Our query language can be regarded as just such a procedurally
interpretable subset of mathematical logic.  An assertion represents a
simple fact (an atomic proposition).  A rule represents the
implication that the rule conclusion holds for those cases where the
rule body holds.  A rule has a natural procedural interpretation: To
establish the conclusion of the rule, establish the body of the rule.
Rules, therefore, specify computations.  However, because rules can
also be regarded as statements of mathematical logic, we can justify
any ``inference'' accomplished by a logic program by asserting that
the same result could be obtained by working entirely within
mathematical logic.<a name="call_footnote_Temp_684" href="#footnote_Temp_684"><sup><small>76</small></sup></a></p>

<p class="trans" lang="ja">
私たちのクエリ言語は、まさに、数学的論理の、手続き的に解釈可能な部分集合だと見なせる。
言明は、単純な事実 (原始的な命題) を表す。
規則は、当該規則の本体部が成り立つ場合には当該規則の帰結部が成り立つ、という含意を表す。
規則には自然な手続き的解釈がある。つまり、その規則の帰結部を成り立たせるためには、その規則の本体部を成り立たせよ、というものだ。
したがって、規則は、計算の明細を規定している。
しかし、規則を数学的論理の文と見なすこともできるので、私たちは、論理プログラムにより達成される、どの「推論」も、正当化できる——完全に数学的論理の範囲内で作業することによっても、同じ結果が得られるだろう、と主張することによって<a href="#footnote_Temp_684"><sup><small>76</small></sup></a>。
</p>

<a name="%_sec_Temp_685"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_685">Infinite loops</a></h4>
<h4 class="trans" lang="ja">無限ループ</h4>

<p class="orig" lang="en">
<a name="%_idx_5260"></a>
A consequence of the procedural interpretation of logic programs is
that it is possible to construct hopelessly inefficient programs for
solving certain problems.  An extreme case of inefficiency occurs when
the system falls into infinite loops in making deductions.  As a
simple example, suppose we are setting up a data base of famous
marriages, including</p>

<p class="trans" lang="ja">
論理プログラムの手続き的解釈からくる結論は、ある種の問題を解くための絶望的に非効率なプログラムを構築することが可能だ、ということである。
演繹を行う際にシステムが無限ループに陥る場合に、非効率性の極端な事例が生じる。
単純な例として、以下のものを含む、有名な婚姻のデータベースを設定しているところだとしよう。
</p>


<a name="%_idx_5262"></a>
<p class="lisp">(assert! (married Minnie Mickey))
</p>

<p class="orig" lang="en">If we now ask</p>

<p class="trans" lang="ja">
もし、いま以下のように尋ねると、
</p>

<p class="lisp">(married Mickey ?who)
</p>

<p class="orig" lang="en">we will get no response, because the system doesn't know that if <em>A</em>
is married to <em>B</em>, then <em>B</em> is married to <em>A</em>.  So we assert the rule</p>

<p class="trans" lang="ja">
私たちは何の応答も得ないだろう。なぜなら、もし <em class="en">A</em> が <em class="en">B</em> と結婚しているなら <em class="en">B</em> は <em class="en">A</em> と結婚している、ということをシステムは知らないためである。
そこで、私たちは以下の規則を言明し、
</p>

<p class="lisp">(assert! (rule (married ?x ?y)
               (married ?y ?x)))
</p>

<p class="orig" lang="en">and again query</p>

<p class="trans" lang="ja">
再び以下のように尋ねる。
</p>

<p class="lisp">(married Mickey ?who)
</p>

<p class="orig" lang="en">
Unfortunately, this will drive the system into an infinite loop, as
follows:</p>

<p class="trans" lang="ja">
あいにく、これは、以下のようにシステムを無限ループに追いやるだろう。
</p>

<ul class="orig" lang="en">
<li>The system finds that the <tt>married</tt> rule is applicable;
that is, the rule conclusion <tt>(married ?x ?y)</tt> successfully
unifies with the query pattern <tt>(married Mickey ?who)</tt> to produce
a frame in which <tt>?x</tt> is bound to <tt>Mickey</tt> and <tt>?y</tt> is
bound to <tt>?who</tt>.  So the interpreter proceeds to evaluate the rule
body <tt>(married ?y ?x)</tt> in this frame -- in effect, to process the
query <tt>(married ?who Mickey)</tt>.</li>

<li>One answer appears directly as an assertion in the data
base: <tt>(married Minnie Mickey)</tt>.</li>

<li>The <tt>married</tt> rule is also applicable, so the
interpreter again evaluates the rule body, which this time is
equivalent to <tt>(married Mickey ?who)</tt>.</li>
</ul>

<ul class="trans" lang="ja">
<li>システムは、<tt>married</tt> の規則が適用可能だと気づく。つまり、 <tt>(married ?x ?y)</tt> という規則帰結部が <tt>(married Mickey ?who)</tt> というクエリ・パタンとうまくユニファイして、フレーム—— <tt>?x</tt> が <tt>Mickey</tt> に束縛されており、かつ、<tt>?y</tt> が <tt>?who</tt> に束縛されているフレーム——を作り出す。
するとインタプリタは、このフレームの中で <tt>(married ?y ?x)</tt> という規則本体部を評価し始める——事実上は、<tt>(married ?who Mickey)</tt> というクエリを処理しだすという訳だ。</li>
<li>データベース内に、言明として直接的に一つの答えが現れている。つまり、<tt>(married Minnie Mickey)</tt> である。</li>
<li><tt>married</tt> の規則も適用可能であり、したがって、インタプリタは、再び規則本体部を評価するのだが、これは今度は <tt>(married Mickey ?who)</tt> と等価である。</li>
</ul>


<p class="orig" lang="en">
The system is now in an infinite loop.  Indeed, whether the system
will find the simple answer <tt>(married Minnie Mickey)</tt> before it
goes into the loop depends on implementation details concerning the
order in which the system checks the items in the data base.  This is
a very simple example of the kinds of loops that can occur.
Collections of interrelated rules can lead to loops that are much
harder to anticipate, and the appearance of a loop can depend on the order
of clauses in an <tt>and</tt> (see exercise <a href="#%_thm_4.64">4.64</a>)
or on low-level details concerning the order in which the system
processes queries.<a name="call_footnote_Temp_686" href="#footnote_Temp_686"><sup><small>77</small></sup></a>
</p>

<p class="trans" lang="ja">
システムは今や無限ループの中にいる。
実際、システムがループに入る前に <tt>(married Minnie Mickey)</tt> という単純な答えを見つけるかどうかは、システムがデータベース内の項目を調べる順序に関する、実装の詳細に依存する。
これは、起こり得るループの種類のうちの、非常に単純な例である。
互いに関連し合う規則の集まりは、予見するのがもっとずっと困難なループを引き起こし得るし、ループの出現は、<tt>and</tt> の中の節の順序に (練習問題<a href="#%_thm_4.64">4.64</a>を参照)、または、システムがクエリを処理する順序に関する低水準の詳細に、依存し得る<a href="#footnote_Temp_686"><sup><small>77</small></sup></a>。
</p>

<a name="%_sec_Temp_687"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_687">Problems with <tt>not</tt></a></h4>
<h4 class="trans" lang="ja"><tt>not</tt> にまつわる問題</h4>


<p class="orig" lang="en">
<a name="%_idx_5266"></a>
<a name="%_idx_5268"></a>Another quirk in the query system concerns <tt>not</tt>.  Given the data
base of section <a href="#%_sec_4.4.1">4.4.1</a>, consider the
following two queries:</p>

<p class="trans" lang="ja">
クエリ・システムにおける、もう一つの奇抜さは、<tt>not</tt> に関する。
<a href="#%_sec_4.4.1">4.4.1</a>節のデータベースが与えられたとして、以下の二つのクエリを考えよう。
</p>

<p class="lisp">(and (supervisor ?x ?y)
     (not (job ?x (computer programmer))))
(and (not (job ?x (computer programmer)))
     (supervisor ?x ?y))
</p>



<p class="orig" lang="en">These two queries do not produce the same result.  The first query
begins by finding all entries in the data base that match <tt>(supervisor ?x ?y)</tt>, and then filters the resulting frames by removing
the ones in which the value of <tt>?x</tt> satisfies <tt>(job ?x
(computer programmer))</tt>.  The second query begins by filtering the
incoming frames to remove those that can satisfy <tt>(job ?x
(computer programmer))</tt>.  Since the only incoming frame is empty, it
checks the data base to see if there are any patterns that satisfy
<tt>(job ?x (computer programmer))</tt>.  Since there generally are
entries of this form, the <tt>not</tt> clause filters out the empty frame
and returns an empty stream of frames.  Consequently, the entire
compound query returns an empty stream.</p>

<p class="trans" lang="ja">
これら二つのクエリは、同じ結果を生み出さない。
1番目のクエリは、<tt>(supervisor ?x ?y)</tt> に合致する、データベース内の全エントリを見つけることから取りかかり、その後、結果としてできたフレームを、<tt>?x</tt> の値が <tt>(job ?x (computer programmer))</tt> を満たすものを除くことにより、フィルタにかける。
2番目のクエリは、入力されてくるフレームをフィルタにかけて、<tt>(job ?x (computer programmer))</tt> を満たせるものを除くことから、取りかかる。
入力されてくる唯一のフレームは空なので、<tt>(job ?x (computer programmer))</tt> を満たすパタンが何かあるかどうかを知るために、データベースを調べる。
大抵はこの形のエントリがあるので、<tt>not</tt> 節は、空フレームをフィルタで除去し、フレームの空ストリームを返す。
その結果、複合クエリ全体は、空ストリームを返す。
</p>

<p class="orig" lang="en">
The trouble is that our implementation of <tt>not</tt> really is meant to
serve as a filter on values for the variables.  If a <tt>not</tt> clause
is processed with a frame in which some of the variables remain
unbound (as does <tt>?x</tt> in the example above), the system will
produce unexpected results. Similar problems occur with the use of
<a name="%_idx_5270"></a><tt>lisp-value</tt> -- the Lisp predicate can't work if some of its
arguments are unbound.  See exercise <a href="#%_thm_4.77">4.77</a>.</p>

<p class="trans" lang="ja">
厄介な点は、私たちの <tt>not</tt> の実装が、現実には、変数の値に対するフィルタとして働くようにはなっていない点である。
もし <tt>not</tt> 節が、(上記の例において <tt>?x</tt> がそうであったように) 変数のうちの一部が束縛されていないまま残っているようなフレームと一緒に処理されると、システムは、予期せぬ結果を生み出す。
似たような問題は、<tt>lisp-value</tt> を使用するときにも起こる—— Lisp の述語は、その引数のうちの一部が束縛されていない場合には、うまく動作できないのだ。
練習問題<a href="#%_thm_4.77">4.77</a>を参照のこと。
</p>



<p class="orig" lang="en">
There is also a much more serious way in which the <tt>not</tt> of the
query language differs from the <tt>not</tt> of mathematical logic.  In
logic, we interpret the statement ``not <em>P</em>'' to mean that <em>P</em> is not
true.  In the query system, however, ``not <em>P</em>'' means that <em>P</em> is not
deducible from the knowledge in the data base.  For example, given the
personnel data base of section <a href="#%_sec_4.4.1">4.4.1</a>, the
system would happily deduce all sorts of <tt>not</tt> statements, such as
that Ben Bitdiddle is not a baseball fan, that it is not raining
outside, and that 2 + 2 is not 4.<a name="call_footnote_Temp_688" href="#footnote_Temp_688"><sup><small>78</small></sup></a> In other words, the <tt>not</tt>
of logic programming languages reflects the so-called <a name="%_idx_5272"></a><em>closed
world assumption</em> that all relevant information has been included in
the data base.<a name="call_footnote_Temp_689" href="#footnote_Temp_689"><sup><small>79</small></sup></a>
</p>

<p class="trans" lang="ja">
クエリ言語の <tt>not</tt> が数学的な論理の <tt>not</tt> と異なっている、もっとずっと深刻な点もある。
論理学では、「not <em class="en">P</em>」という<ruby><rb>文</rb><rp> (</rp><rt>ステートメント</rt><rp>) </rp></ruby>を、<em class="en">P</em> が真でないことを意味するものと解釈する。
しかし、クエリ・システムでは、「not <em class="en">P</em>」は、データベース内の知識からは <em class="en">P</em> が<!--演繹可能ではない-->演繹できないことを意味するのだ。
たとえば、<a href="#%_sec_4.4.1">4.4.1</a>節での人事データベースが与えられると、システムは、ベン・ビットディドルが野球ファンではない、とか、外では雨が降っていない、とか、2+2 は 4 ではない、というような、あらゆる種類の <tt>not</tt> 文を、運よく演繹するであろう<a href="#footnote_Temp_688"><sup><small>78</small></sup></a>。
換言すれば、論理プログラミング言語の <tt>not</tt> は、関連性のある全情報がデータベース内にすでに含められているのだ、という、いわゆる<em>閉世界仮説</em>を反映しているのである<a href="#footnote_Temp_689"><sup><small>79</small></sup></a>。
</p>

<a name="%_thm_4.64"></a>
<p class="orig" lang="en"><b>Exercise 4.64.</b>  <a name="%_idx_5276"></a>Louis Reasoner mistakenly deletes the <tt>outranked-by</tt> rule
(section <a href="#%_sec_4.4.1">4.4.1</a>) from the data base.  When
he realizes this, he quickly reinstalls it.  Unfortunately, he makes a
slight change in the rule, and types it in as</p>

<p class="trans" lang="ja">
<b>練習問題4.64.</b> ルイス・リーズナは、間違えてデータベースから <a href="#%_idx_5152"><tt>outranked-by</tt> の規則</a> (<a href="#%_sec_4.4.1">4.4.1</a> 節) を削除してしまう。
このことに気づくと、彼は素早くこの規則を再び組み入れる。
あいにく、彼は規則にちょっとした変更を加えてしまい、それを以下のように打ち込む。
</p>

<p class="lisp">(rule (outranked-by ?staff-person ?boss)
      (or (supervisor ?staff-person ?boss)
          (and (outranked-by ?middle-manager ?boss)
               (supervisor ?staff-person ?middle-manager))))
</p>

<p class="orig" lang="en">Just after Louis types this information into the system, DeWitt
Aull comes by to find out who outranks Ben Bitdiddle. He issues
the query</p>

<p class="trans" lang="ja">
ルイスがこの情報をシステムに打ち込んだすぐ後に、誰がベン・ビットディドルより上の職位にあるのかを知るために、ドゥウィット・オールが立ち寄る。
ドゥウィットは以下のクエリを発行する。
</p>

<p class="lisp">(outranked-by (Bitdiddle Ben) ?who)
</p>

<p class="orig" lang="en">After answering, the system goes into an infinite loop.  Explain why.
</p>

<p class="trans" lang="ja">
回答した後、システムは、無限ループに陥る。なぜなのかを説明せよ。
</p>

<p class="exercise"><span class="ex_comment">まず確認しておくと、ルイスは、and の二つの引数の順序を逆にした。

さて、システムは、まず、データベースにある</span>
(supervisor (Bitdiddle Ben) (Warbucks Oliver))
<span class="ex_comment">という言明を見つける。これが or の一つ目の引数のパタンにマッチする。よって、システムは</span>
(outranked-by (Bitdiddle Ben) (Warbucks Oliver))
<span class="ex_comment">という回答を返す。が、その後、ルイスの変更のせいで、以下のように、
outranked-by の再帰的な呼び出しが無限に深まるループにはまり込んでしまう
(つまり、(☆1)を打ち込むと、(☆2)の出力は得られるが、(☆3)以下が実行されていく
無限ループにはまり、<del>(*)は実行されず、ということ</del>)。</span>

outranked-by (☆1)
 |
 +-- supervisor (☆2)
 OR
 +-- outranked-by (☆3) --AND-- supervisor (*)
      |
      +-- supervisor (☆4)
      OR
      +-- outranked-by (☆5) --AND-- supervisor (*)
           |
           +-- supervisor (☆6)
           OR
           +-- outranked-by (☆7) --AND-- supervisor(*)
                |
                :

<span class="ex_comment">と、雑に考えたんだが、どうだろう。</span></p>
<p class="extra_code"><span class="ex_comment">% Prologでこれをなぞってみる。

% まず人事DB (規則込み) の読み込み。</span>
| ?- consult('personnel_db.pl').
<span class="ex_comment">% (出力は省略)</span>

<span class="ex_comment">% outranked_by の定義を上書きする。</span>
| ?- [user].
compiling user for byte code...
outranked_by(Staff_person, Boss) :-
    supervisor(Staff_person, Boss);
    (outranked_by(Middle_manager, Boss),
     supervisor(Staff_person, Middle_manager)).

user compiled, 5 lines read - 709 bytes written, 44124 ms
warning: user:1: redefining procedure outranked_by/2
<span class="ex_comment">% (もうちょっと出力があったが、それは省略)</span>

<span class="ex_comment">% ちゃんと再定義されたか確認したい場合</span>
| ?- listing.
<span class="ex_comment">% (出力は省略)</span>

<span class="ex_comment">% トレースできるようにします。</span>
| ?- trace.
The debugger will first creep -- showing everything (trace)

yes
{trace}

<span class="ex_comment">% それでは、いざ実行。
% (以下は、実際の出力にコメントを追記したもの。
%    [呼び出し番号] [直接の先祖を示す番号] [ポート:] [ゴール] ?
%  というのが元の出力である。)</span>

| ?- outranked_by(['Bitdiddle', 'Ben'], Who).
      1    1  Call: outranked_by(['Bitdiddle','Ben'],_283) ? <span class="ex_comment">% (☆1)</span>
      2    2  Call: supervisor(['Bitdiddle','Ben'],_283) ? <span class="ex_comment">% (☆2)</span>
      2    2  Exit: supervisor(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      1    1  Exit: outranked_by(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 

Who = ['Warbucks','Oliver'] ? ;
<span class="ex_comment">% ここまでは簡単。再帰なしで判明するパタン。</span>

<span class="ex_comment">% 上の行でセミコロンを入力したので、別の解を探し始める。
% 実際は、ベンより上位の人間はオリバーだけなので、別の解など存在しないのだが、
% 以下の通り、探索が無限ループに陥ってしまう。</span>
      1    1  Redo: outranked_by(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      2    2  Redo: supervisor(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      2    2  Fail: supervisor(['Bitdiddle','Ben'],_283) ? 
<span class="ex_comment">% supervisor(['Bitdiddle','Ben'], Who) にマッチするものはもうないので、Fail となった。
% というわけで、再帰呼び出し定義の方でマッチするものを探しにいく。つまり、
% WhoがBossにユニファイされている状態で、
% outranked_by(Middle_manager, Boss), supervisor(['Bitdiddle','Ben'], Middle_manager)
% にマッチするものを、探しにいく。</span>
      2    2  Call: outranked_by(_352,_283) ? <span class="ex_comment">% (☆3)</span>
      3    3  Call: supervisor(_376,_283) ? 
      3    3  Exit: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      2    2  Exit: outranked_by(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ?
<span class="ex_comment">% AND結合された一つ目の述語を満たす解は、上の行のとおり見つかったが……</span>
      4    2  Call: supervisor(['Bitdiddle','Ben'],['Hacker','Alyssa','P']) ? 
      4    2  Fail: supervisor(['Bitdiddle','Ben'],['Hacker','Alyssa','P']) ? 
<span class="ex_comment">% その解は、二つ目の述語を満たさないと判明する。
% というわけで、AND結合された一つ目の述語を満たす別の解を探すと……</span>
      2    2  Redo: outranked_by(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      3    3  Redo: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      3    3  Exit: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      2    2  Exit: outranked_by(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
<span class="ex_comment">% 上の行のとおり解が見つかるが……</span>
      4    2  Call: supervisor(['Bitdiddle','Ben'],['Fect','Cy','D']) ? 
      4    2  Fail: supervisor(['Bitdiddle','Ben'],['Fect','Cy','D']) ? 
<span class="ex_comment">% その解は、二つ目の述語を満たさないと判明する。
% というわけで、AND結合された一つ目の述語を満たす別の解を探すと……</span>
      2    2  Redo: outranked_by(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      3    3  Redo: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      3    3  Exit: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      2    2  Exit: outranked_by(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
<span class="ex_comment">% 上の行のとおり解が見つかるが……</span>
      4    2  Call: supervisor(['Bitdiddle','Ben'],['Tweakit','Lem','E']) ? 
      4    2  Fail: supervisor(['Bitdiddle','Ben'],['Tweakit','Lem','E']) ? 
<span class="ex_comment">% その解は、二つ目の述語を満たさないと判明する。
% というわけで、AND結合された一つ目の述語を満たす別の解を探すと……</span>
      2    2  Redo: outranked_by(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      3    3  Redo: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      3    3  Exit: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      2    2  Exit: outranked_by(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
<span class="ex_comment">% 上の行のとおり解が見つかるが……</span>
      4    2  Call: supervisor(['Bitdiddle','Ben'],['Reasoner','Louis']) ? 
      4    2  Fail: supervisor(['Bitdiddle','Ben'],['Reasoner','Louis']) ? 
<span class="ex_comment">% その解は、二つ目の述語を満たさないと判明する。
% というわけで、AND結合された一つ目の述語を満たす別の解を探すと……</span>
      2    2  Redo: outranked_by(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      3    3  Redo: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      3    3  Exit: supervisor(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      2    2  Exit: outranked_by(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
<span class="ex_comment">% 上の行のとおり解が見つかるが……</span>
      4    2  Call: supervisor(['Bitdiddle','Ben'],['Bitdiddle','Ben']) ? 
      4    2  Fail: supervisor(['Bitdiddle','Ben'],['Bitdiddle','Ben']) ? 
<span class="ex_comment">% その解は、二つ目の述語を満たさないと判明する。
% というわけで、AND結合された一つ目の述語を満たす別の解を探すと……</span>
      2    2  Redo: outranked_by(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      3    3  Redo: supervisor(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      3    3  Exit: supervisor(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      2    2  Exit: outranked_by(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
<span class="ex_comment">% 上の行のとおり解が見つかるが……</span>
      4    2  Call: supervisor(['Bitdiddle','Ben'],['Scrooge','Eben']) ? 
      4    2  Fail: supervisor(['Bitdiddle','Ben'],['Scrooge','Eben']) ? 
<span class="ex_comment">% その解は、二つ目の述語を満たさないと判明する。
% というわけで、AND結合された一つ目の述語を満たす別の解を探すと……</span>
      2    2  Redo: outranked_by(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      3    3  Redo: supervisor(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      3    3  Exit: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      2    2  Exit: outranked_by(['Cratchet','Robert'],['Scrooge','Eben']) ? 
<span class="ex_comment">% 上の行のとおり解が見つかるが……</span>
      4    2  Call: supervisor(['Bitdiddle','Ben'],['Cratchet','Robert']) ? 
      4    2  Fail: supervisor(['Bitdiddle','Ben'],['Cratchet','Robert']) ? 
<span class="ex_comment">% その解は、二つ目の述語を満たさないと判明する。
% というわけで、AND結合された一つ目の述語を満たす別の解を探すと……</span>
      2    2  Redo: outranked_by(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      3    3  Redo: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      3    3  Exit: supervisor(['Aull','DeWitt'],['Warbucks','Oliver']) ? 
      2    2  Exit: outranked_by(['Aull','DeWitt'],['Warbucks','Oliver']) ? 
<span class="ex_comment">% 上の行のとおり解が見つかるが……</span>
      4    2  Call: supervisor(['Bitdiddle','Ben'],['Aull','DeWitt']) ? 
      4    2  Fail: supervisor(['Bitdiddle','Ben'],['Aull','DeWitt']) ? 
      2    2  Redo: outranked_by(['Aull','DeWitt'],['Warbucks','Oliver']) ? 
<span class="ex_comment">% その解は、二つ目の述語を満たさないと判明する。
% というわけで、AND結合された一つ目の述語を満たす別の解を探す訳だが、
% ここで、</span>
      3    3  Call: outranked_by(_376,_283) ? 
      4    4  Call: supervisor(_400,_283) ? 
      4    4  Exit: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      3    3  Exit: outranked_by(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      5    3  Call: supervisor(_436,['Hacker','Alyssa','P']) ? 
      5    3  Exit: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      2    2  Exit: outranked_by(['Reasoner','Louis'],['Bitdiddle','Ben']) ? 
      6    2  Call: supervisor(['Bitdiddle','Ben'],['Reasoner','Louis']) ? 
      6    2  Fail: supervisor(['Bitdiddle','Ben'],['Reasoner','Louis']) ? 
      2    2  Redo: outranked_by(['Reasoner','Louis'],['Bitdiddle','Ben']) ? 
      5    3  Redo: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      5    3  Fail: supervisor(_424,['Hacker','Alyssa','P']) ? 
      3    3  Redo: outranked_by(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      4    4  Redo: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      4    4  Exit: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      3    3  Exit: outranked_by(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      5    3  Call: supervisor(_436,['Fect','Cy','D']) ? 
      5    3  Fail: supervisor(_424,['Fect','Cy','D']) ? 
      3    3  Redo: outranked_by(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      4    4  Redo: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      4    4  Exit: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      3    3  Exit: outranked_by(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      5    3  Call: supervisor(_436,['Tweakit','Lem','E']) ? 
      5    3  Fail: supervisor(_424,['Tweakit','Lem','E']) ? 
      3    3  Redo: outranked_by(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      4    4  Redo: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      4    4  Exit: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      3    3  Exit: outranked_by(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      5    3  Call: supervisor(_436,['Reasoner','Louis']) ? 
      5    3  Fail: supervisor(_424,['Reasoner','Louis']) ? 
      3    3  Redo: outranked_by(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      4    4  Redo: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      4    4  Exit: supervisor(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      3    3  Exit: outranked_by(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      5    3  Call: supervisor(_434,['Bitdiddle','Ben']) ? 
      5    3  Exit: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      2    2  Exit: outranked_by(['Hacker','Alyssa','P'],['Warbucks','Oliver']) ? 
      6    2  Call: supervisor(['Bitdiddle','Ben'],['Hacker','Alyssa','P']) ? 
      6    2  Fail: supervisor(['Bitdiddle','Ben'],['Hacker','Alyssa','P']) ? 
      2    2  Redo: outranked_by(['Hacker','Alyssa','P'],['Warbucks','Oliver']) ? 
      5    3  Redo: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      5    3  Exit: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      2    2  Exit: outranked_by(['Fect','Cy','D'],['Warbucks','Oliver']) ? 
      6    2  Call: supervisor(['Bitdiddle','Ben'],['Fect','Cy','D']) ? 
      6    2  Fail: supervisor(['Bitdiddle','Ben'],['Fect','Cy','D']) ? 
      2    2  Redo: outranked_by(['Fect','Cy','D'],['Warbucks','Oliver']) ? 
      5    3  Redo: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      5    3  Exit: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      2    2  Exit: outranked_by(['Tweakit','Lem','E'],['Warbucks','Oliver']) ? 
      6    2  Call: supervisor(['Bitdiddle','Ben'],['Tweakit','Lem','E']) ? 
      6    2  Fail: supervisor(['Bitdiddle','Ben'],['Tweakit','Lem','E']) ? 
      2    2  Redo: outranked_by(['Tweakit','Lem','E'],['Warbucks','Oliver']) ? 
      5    3  Redo: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      5    3  Fail: supervisor(_422,['Bitdiddle','Ben']) ? 
      3    3  Redo: outranked_by(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      4    4  Redo: supervisor(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      4    4  Exit: supervisor(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      3    3  Exit: outranked_by(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      5    3  Call: supervisor(_434,['Scrooge','Eben']) ? 
      5    3  Exit: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      2    2  Exit: outranked_by(['Cratchet','Robert'],['Warbucks','Oliver']) ? 
      6    2  Call: supervisor(['Bitdiddle','Ben'],['Cratchet','Robert']) ? 
      6    2  Fail: supervisor(['Bitdiddle','Ben'],['Cratchet','Robert']) ? 
      2    2  Redo: outranked_by(['Cratchet','Robert'],['Warbucks','Oliver']) ? 
      5    3  Redo: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      5    3  Fail: supervisor(_422,['Scrooge','Eben']) ? 
      3    3  Redo: outranked_by(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      4    4  Redo: supervisor(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      4    4  Exit: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      3    3  Exit: outranked_by(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      5    3  Call: supervisor(_434,['Cratchet','Robert']) ? 
      5    3  Fail: supervisor(_422,['Cratchet','Robert']) ? 
      3    3  Redo: outranked_by(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      4    4  Redo: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      4    4  Exit: supervisor(['Aull','DeWitt'],['Warbucks','Oliver']) ? 
      3    3  Exit: outranked_by(['Aull','DeWitt'],['Warbucks','Oliver']) ? 
      5    3  Call: supervisor(_434,['Aull','DeWitt']) ? 
      5    3  Fail: supervisor(_422,['Aull','DeWitt']) ? 
      3    3  Redo: outranked_by(['Aull','DeWitt'],['Warbucks','Oliver']) ? 
      4    4  Call: outranked_by(_400,_283) ? 
      5    5  Call: supervisor(_424,_283) ? 
      5    5  Exit: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      4    4  Exit: outranked_by(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      6    4  Call: supervisor(_460,['Hacker','Alyssa','P']) ? 
      6    4  Exit: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      3    3  Exit: outranked_by(['Reasoner','Louis'],['Bitdiddle','Ben']) ? 
      7    3  Call: supervisor(_490,['Reasoner','Louis']) ? 
      7    3  Fail: supervisor(_478,['Reasoner','Louis']) ? 
      3    3  Redo: outranked_by(['Reasoner','Louis'],['Bitdiddle','Ben']) ? 
      6    4  Redo: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      6    4  Fail: supervisor(_448,['Hacker','Alyssa','P']) ? 
      4    4  Redo: outranked_by(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      5    5  Redo: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      5    5  Exit: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      4    4  Exit: outranked_by(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      6    4  Call: supervisor(_460,['Fect','Cy','D']) ? 
      6    4  Fail: supervisor(_448,['Fect','Cy','D']) ? 
      4    4  Redo: outranked_by(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      5    5  Redo: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      5    5  Exit: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      4    4  Exit: outranked_by(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      6    4  Call: supervisor(_460,['Tweakit','Lem','E']) ? 
      6    4  Fail: supervisor(_448,['Tweakit','Lem','E']) ? 
      4    4  Redo: outranked_by(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      5    5  Redo: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      5    5  Exit: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      4    4  Exit: outranked_by(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      6    4  Call: supervisor(_460,['Reasoner','Louis']) ? 
      6    4  Fail: supervisor(_448,['Reasoner','Louis']) ? 
      4    4  Redo: outranked_by(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      5    5  Redo: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      5    5  Exit: supervisor(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      4    4  Exit: outranked_by(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      6    4  Call: supervisor(_458,['Bitdiddle','Ben']) ? 
      6    4  Exit: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      3    3  Exit: outranked_by(['Hacker','Alyssa','P'],['Warbucks','Oliver']) ? 
      7    3  Call: supervisor(_490,['Hacker','Alyssa','P']) ? 
      7    3  Exit: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      2    2  Exit: outranked_by(['Reasoner','Louis'],['Warbucks','Oliver']) ? 
      8    2  Call: supervisor(['Bitdiddle','Ben'],['Reasoner','Louis']) ? 
      8    2  Fail: supervisor(['Bitdiddle','Ben'],['Reasoner','Louis']) ? 
      2    2  Redo: outranked_by(['Reasoner','Louis'],['Warbucks','Oliver']) ? 
      7    3  Redo: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      7    3  Fail: supervisor(_478,['Hacker','Alyssa','P']) ? 
      3    3  Redo: outranked_by(['Hacker','Alyssa','P'],['Warbucks','Oliver']) ? 
      6    4  Redo: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      6    4  Exit: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      3    3  Exit: outranked_by(['Fect','Cy','D'],['Warbucks','Oliver']) ? 
      7    3  Call: supervisor(_490,['Fect','Cy','D']) ? 
      7    3  Fail: supervisor(_478,['Fect','Cy','D']) ? 
      3    3  Redo: outranked_by(['Fect','Cy','D'],['Warbucks','Oliver']) ? 
      6    4  Redo: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      6    4  Exit: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      3    3  Exit: outranked_by(['Tweakit','Lem','E'],['Warbucks','Oliver']) ? 
      7    3  Call: supervisor(_490,['Tweakit','Lem','E']) ? 
      7    3  Fail: supervisor(_478,['Tweakit','Lem','E']) ? 
      3    3  Redo: outranked_by(['Tweakit','Lem','E'],['Warbucks','Oliver']) ? 
      6    4  Redo: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      6    4  Fail: supervisor(_446,['Bitdiddle','Ben']) ? 
      4    4  Redo: outranked_by(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      5    5  Redo: supervisor(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      5    5  Exit: supervisor(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      4    4  Exit: outranked_by(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      6    4  Call: supervisor(_458,['Scrooge','Eben']) ? 
      6    4  Exit: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      3    3  Exit: outranked_by(['Cratchet','Robert'],['Warbucks','Oliver']) ? 
      7    3  Call: supervisor(_488,['Cratchet','Robert']) ? 
      7    3  Fail: supervisor(_476,['Cratchet','Robert']) ? 
      3    3  Redo: outranked_by(['Cratchet','Robert'],['Warbucks','Oliver']) ? 
      6    4  Redo: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      6    4  Fail: supervisor(_446,['Scrooge','Eben']) ? 
      4    4  Redo: outranked_by(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      5    5  Redo: supervisor(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      5    5  Exit: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      4    4  Exit: outranked_by(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      6    4  Call: supervisor(_458,['Cratchet','Robert']) ? 
      6    4  Fail: supervisor(_446,['Cratchet','Robert']) ? 
      4    4  Redo: outranked_by(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      5    5  Redo: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      5    5  Exit: supervisor(['Aull','DeWitt'],['Warbucks','Oliver']) ? 
      4    4  Exit: outranked_by(['Aull','DeWitt'],['Warbucks','Oliver']) ? 
      6    4  Call: supervisor(_458,['Aull','DeWitt']) ? 
      6    4  Fail: supervisor(_446,['Aull','DeWitt']) ? 
      4    4  Redo: outranked_by(['Aull','DeWitt'],['Warbucks','Oliver']) ? 
      5    5  Call: outranked_by(_424,_283) ? 
      6    6  Call: supervisor(_448,_283) ? 
      6    6  Exit: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      5    5  Exit: outranked_by(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      7    5  Call: supervisor(_484,['Hacker','Alyssa','P']) ? 
      7    5  Exit: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      4    4  Exit: outranked_by(['Reasoner','Louis'],['Bitdiddle','Ben']) ? 
      8    4  Call: supervisor(_514,['Reasoner','Louis']) ? 
      8    4  Fail: supervisor(_502,['Reasoner','Louis']) ? 
      4    4  Redo: outranked_by(['Reasoner','Louis'],['Bitdiddle','Ben']) ? 
      7    5  Redo: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      7    5  Fail: supervisor(_472,['Hacker','Alyssa','P']) ? 
      5    5  Redo: outranked_by(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      6    6  Redo: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      6    6  Exit: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      5    5  Exit: outranked_by(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      7    5  Call: supervisor(_484,['Fect','Cy','D']) ? 
      7    5  Fail: supervisor(_472,['Fect','Cy','D']) ? 
      5    5  Redo: outranked_by(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      6    6  Redo: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      6    6  Exit: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      5    5  Exit: outranked_by(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      7    5  Call: supervisor(_484,['Tweakit','Lem','E']) ? 
      7    5  Fail: supervisor(_472,['Tweakit','Lem','E']) ? 
      5    5  Redo: outranked_by(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      6    6  Redo: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      6    6  Exit: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      5    5  Exit: outranked_by(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      7    5  Call: supervisor(_484,['Reasoner','Louis']) ? 
      7    5  Fail: supervisor(_472,['Reasoner','Louis']) ? 
      5    5  Redo: outranked_by(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      6    6  Redo: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      6    6  Exit: supervisor(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      5    5  Exit: outranked_by(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      7    5  Call: supervisor(_482,['Bitdiddle','Ben']) ? 
      7    5  Exit: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      4    4  Exit: outranked_by(['Hacker','Alyssa','P'],['Warbucks','Oliver']) ? 
      8    4  Call: supervisor(_514,['Hacker','Alyssa','P']) ? 
      8    4  Exit: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      3    3  Exit: outranked_by(['Reasoner','Louis'],['Warbucks','Oliver']) ? 
      9    3  Call: supervisor(_544,['Reasoner','Louis']) ? 
      9    3  Fail: supervisor(_532,['Reasoner','Louis']) ? 
      3    3  Redo: outranked_by(['Reasoner','Louis'],['Warbucks','Oliver']) ? 
      8    4  Redo: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      8    4  Fail: supervisor(_502,['Hacker','Alyssa','P']) ? 
      4    4  Redo: outranked_by(['Hacker','Alyssa','P'],['Warbucks','Oliver']) ? 
      7    5  Redo: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      7    5  Exit: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      4    4  Exit: outranked_by(['Fect','Cy','D'],['Warbucks','Oliver']) ? 
      8    4  Call: supervisor(_514,['Fect','Cy','D']) ? 
      8    4  Fail: supervisor(_502,['Fect','Cy','D']) ? 
      4    4  Redo: outranked_by(['Fect','Cy','D'],['Warbucks','Oliver']) ? 
      7    5  Redo: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      7    5  Exit: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      4    4  Exit: outranked_by(['Tweakit','Lem','E'],['Warbucks','Oliver']) ? 
      8    4  Call: supervisor(_514,['Tweakit','Lem','E']) ? 
      8    4  Fail: supervisor(_502,['Tweakit','Lem','E']) ? 
      4    4  Redo: outranked_by(['Tweakit','Lem','E'],['Warbucks','Oliver']) ? 
      7    5  Redo: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      7    5  Fail: supervisor(_470,['Bitdiddle','Ben']) ? 
      5    5  Redo: outranked_by(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      6    6  Redo: supervisor(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      6    6  Exit: supervisor(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      5    5  Exit: outranked_by(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      7    5  Call: supervisor(_482,['Scrooge','Eben']) ? 
      7    5  Exit: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      4    4  Exit: outranked_by(['Cratchet','Robert'],['Warbucks','Oliver']) ? 
      8    4  Call: supervisor(_512,['Cratchet','Robert']) ? 
      8    4  Fail: supervisor(_500,['Cratchet','Robert']) ? 
      4    4  Redo: outranked_by(['Cratchet','Robert'],['Warbucks','Oliver']) ? 
      7    5  Redo: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      7    5  Fail: supervisor(_470,['Scrooge','Eben']) ? 
      5    5  Redo: outranked_by(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      6    6  Redo: supervisor(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      6    6  Exit: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      5    5  Exit: outranked_by(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      7    5  Call: supervisor(_482,['Cratchet','Robert']) ? 
      7    5  Fail: supervisor(_470,['Cratchet','Robert']) ? 
      5    5  Redo: outranked_by(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      6    6  Redo: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      6    6  Exit: supervisor(['Aull','DeWitt'],['Warbucks','Oliver']) ? 
      5    5  Exit: outranked_by(['Aull','DeWitt'],['Warbucks','Oliver']) ? 
      7    5  Call: supervisor(_482,['Aull','DeWitt']) ? 
      7    5  Fail: supervisor(_470,['Aull','DeWitt']) ? 
      5    5  Redo: outranked_by(['Aull','DeWitt'],['Warbucks','Oliver']) ? 
      6    6  Call: outranked_by(_448,_283) ? 
      7    7  Call: supervisor(_472,_283) ? 
      7    7  Exit: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      6    6  Exit: outranked_by(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      8    6  Call: supervisor(_508,['Hacker','Alyssa','P']) ? 
      8    6  Exit: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      5    5  Exit: outranked_by(['Reasoner','Louis'],['Bitdiddle','Ben']) ? 
      9    5  Call: supervisor(_538,['Reasoner','Louis']) ? 
      9    5  Fail: supervisor(_526,['Reasoner','Louis']) ? 
      5    5  Redo: outranked_by(['Reasoner','Louis'],['Bitdiddle','Ben']) ? 
      8    6  Redo: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      8    6  Fail: supervisor(_496,['Hacker','Alyssa','P']) ? 
      6    6  Redo: outranked_by(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      7    7  Redo: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      7    7  Exit: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      6    6  Exit: outranked_by(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      8    6  Call: supervisor(_508,['Fect','Cy','D']) ? 
      8    6  Fail: supervisor(_496,['Fect','Cy','D']) ? 
      6    6  Redo: outranked_by(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      7    7  Redo: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      7    7  Exit: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      6    6  Exit: outranked_by(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      8    6  Call: supervisor(_508,['Tweakit','Lem','E']) ? 
      8    6  Fail: supervisor(_496,['Tweakit','Lem','E']) ? 
      6    6  Redo: outranked_by(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      7    7  Redo: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      7    7  Exit: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      6    6  Exit: outranked_by(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      8    6  Call: supervisor(_508,['Reasoner','Louis']) ? 
      8    6  Fail: supervisor(_496,['Reasoner','Louis']) ? 
      6    6  Redo: outranked_by(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      7    7  Redo: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      7    7  Exit: supervisor(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      6    6  Exit: outranked_by(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      8    6  Call: supervisor(_506,['Bitdiddle','Ben']) ? 
      8    6  Exit: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      5    5  Exit: outranked_by(['Hacker','Alyssa','P'],['Warbucks','Oliver']) ? 
      9    5  Call: supervisor(_538,['Hacker','Alyssa','P']) ? 
      9    5  Exit: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      4    4  Exit: outranked_by(['Reasoner','Louis'],['Warbucks','Oliver']) ? 
     10    4  Call: supervisor(_568,['Reasoner','Louis']) ? 
     10    4  Fail: supervisor(_556,['Reasoner','Louis']) ? 
      4    4  Redo: outranked_by(['Reasoner','Louis'],['Warbucks','Oliver']) ? 
      9    5  Redo: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      9    5  Fail: supervisor(_526,['Hacker','Alyssa','P']) ? 
      5    5  Redo: outranked_by(['Hacker','Alyssa','P'],['Warbucks','Oliver']) ? 
      8    6  Redo: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      8    6  Exit: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      5    5  Exit: outranked_by(['Fect','Cy','D'],['Warbucks','Oliver']) ? 
      9    5  Call: supervisor(_538,['Fect','Cy','D']) ? 
      9    5  Fail: supervisor(_526,['Fect','Cy','D']) ? 
      5    5  Redo: outranked_by(['Fect','Cy','D'],['Warbucks','Oliver']) ? 
      8    6  Redo: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      8    6  Exit: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      5    5  Exit: outranked_by(['Tweakit','Lem','E'],['Warbucks','Oliver']) ? 
      9    5  Call: supervisor(_538,['Tweakit','Lem','E']) ? 
      9    5  Fail: supervisor(_526,['Tweakit','Lem','E']) ? 
      5    5  Redo: outranked_by(['Tweakit','Lem','E'],['Warbucks','Oliver']) ? 
      8    6  Redo: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      8    6  Fail: supervisor(_494,['Bitdiddle','Ben']) ? 
      6    6  Redo: outranked_by(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      7    7  Redo: supervisor(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      7    7  Exit: supervisor(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      6    6  Exit: outranked_by(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      8    6  Call: supervisor(_506,['Scrooge','Eben']) ? 
      8    6  Exit: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      5    5  Exit: outranked_by(['Cratchet','Robert'],['Warbucks','Oliver']) ? 
      9    5  Call: supervisor(_536,['Cratchet','Robert']) ? 
      9    5  Fail: supervisor(_524,['Cratchet','Robert']) ? 
      5    5  Redo: outranked_by(['Cratchet','Robert'],['Warbucks','Oliver']) ? 
      8    6  Redo: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      8    6  Fail: supervisor(_494,['Scrooge','Eben']) ? 
      6    6  Redo: outranked_by(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      7    7  Redo: supervisor(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      7    7  Exit: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      6    6  Exit: outranked_by(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      8    6  Call: supervisor(_506,['Cratchet','Robert']) ? 
      8    6  Fail: supervisor(_494,['Cratchet','Robert']) ? 
      6    6  Redo: outranked_by(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      7    7  Redo: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      7    7  Exit: supervisor(['Aull','DeWitt'],['Warbucks','Oliver']) ? 
      6    6  Exit: outranked_by(['Aull','DeWitt'],['Warbucks','Oliver']) ? 
      8    6  Call: supervisor(_506,['Aull','DeWitt']) ? 
      8    6  Fail: supervisor(_494,['Aull','DeWitt']) ? 
      6    6  Redo: outranked_by(['Aull','DeWitt'],['Warbucks','Oliver']) ? 
      7    7  Call: outranked_by(_472,_283) ? 
      8    8  Call: supervisor(_496,_283) ? 
      8    8  Exit: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      7    7  Exit: outranked_by(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      9    7  Call: supervisor(_532,['Hacker','Alyssa','P']) ? 
      9    7  Exit: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      6    6  Exit: outranked_by(['Reasoner','Louis'],['Bitdiddle','Ben']) ? 
     10    6  Call: supervisor(_562,['Reasoner','Louis']) ? 
     10    6  Fail: supervisor(_550,['Reasoner','Louis']) ? 
      6    6  Redo: outranked_by(['Reasoner','Louis'],['Bitdiddle','Ben']) ? 
      9    7  Redo: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      9    7  Fail: supervisor(_520,['Hacker','Alyssa','P']) ? 
      7    7  Redo: outranked_by(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      8    8  Redo: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      8    8  Exit: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      7    7  Exit: outranked_by(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      9    7  Call: supervisor(_532,['Fect','Cy','D']) ? 
      9    7  Fail: supervisor(_520,['Fect','Cy','D']) ? 
      7    7  Redo: outranked_by(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      8    8  Redo: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      8    8  Exit: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      7    7  Exit: outranked_by(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      9    7  Call: supervisor(_532,['Tweakit','Lem','E']) ? 
      9    7  Fail: supervisor(_520,['Tweakit','Lem','E']) ? 
      7    7  Redo: outranked_by(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      8    8  Redo: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      8    8  Exit: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      7    7  Exit: outranked_by(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      9    7  Call: supervisor(_532,['Reasoner','Louis']) ? 
      9    7  Fail: supervisor(_520,['Reasoner','Louis']) ? 
      7    7  Redo: outranked_by(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      8    8  Redo: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      8    8  Exit: supervisor(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      7    7  Exit: outranked_by(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      9    7  Call: supervisor(_530,['Bitdiddle','Ben']) ? 
      9    7  Exit: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      6    6  Exit: outranked_by(['Hacker','Alyssa','P'],['Warbucks','Oliver']) ? 
     10    6  Call: supervisor(_562,['Hacker','Alyssa','P']) ? 
     10    6  Exit: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      5    5  Exit: outranked_by(['Reasoner','Louis'],['Warbucks','Oliver']) ? 
     11    5  Call: supervisor(_592,['Reasoner','Louis']) ? 
     11    5  Fail: supervisor(_580,['Reasoner','Louis']) ? 
      5    5  Redo: outranked_by(['Reasoner','Louis'],['Warbucks','Oliver']) ? 
     10    6  Redo: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
     10    6  Fail: supervisor(_550,['Hacker','Alyssa','P']) ? 
      6    6  Redo: outranked_by(['Hacker','Alyssa','P'],['Warbucks','Oliver']) ? 
      9    7  Redo: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      9    7  Exit: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      6    6  Exit: outranked_by(['Fect','Cy','D'],['Warbucks','Oliver']) ? 
     10    6  Call: supervisor(_562,['Fect','Cy','D']) ? 
     10    6  Fail: supervisor(_550,['Fect','Cy','D']) ? 
      6    6  Redo: outranked_by(['Fect','Cy','D'],['Warbucks','Oliver']) ? 
      9    7  Redo: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      9    7  Exit: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      6    6  Exit: outranked_by(['Tweakit','Lem','E'],['Warbucks','Oliver']) ? 
     10    6  Call: supervisor(_562,['Tweakit','Lem','E']) ? 
     10    6  Fail: supervisor(_550,['Tweakit','Lem','E']) ? 
      6    6  Redo: outranked_by(['Tweakit','Lem','E'],['Warbucks','Oliver']) ? 
      9    7  Redo: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      9    7  Fail: supervisor(_518,['Bitdiddle','Ben']) ? 
      7    7  Redo: outranked_by(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      8    8  Redo: supervisor(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      8    8  Exit: supervisor(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      8    8  Exit: supervisor(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      7    7  Exit: outranked_by(['Scrooge','Eben'],['Warbucks','Oliver']) ? a
</p>

<p class="orig" lang="en">
<a name="%_thm_4.65"></a>
<b>Exercise 4.65.</b>  <a name="%_idx_5278"></a>Cy D. Fect, looking forward to the day when he will rise in the
organization, gives a query to find all the wheels
(using the <tt>wheel</tt> rule of section <a href="#%_sec_4.4.1">4.4.1</a>):</p>

<p class="trans" lang="ja">
<b>練習問題4.65.</b> サイ・D・フェクトは、組織内で昇格する日を楽しみにしていて、大物たちすべてを見つけるために (<a href="#%_sec_4.4.1">4.4.1</a>節の <a href="#%_idx_5144"><tt>wheel</tt> の規則</a>を使って) クエリを与える。
</p>

<p class="lisp">(wheel ?who)
</p>

<p class="orig" lang="en">To his surprise, the system responds</p>

<p class="trans" lang="ja">
彼が驚いたことには、システムは次のように応答するのだ。
</p>

<p class="lisp"><i>;;; Query results:</i>
(wheel (Warbucks Oliver))
(wheel (Bitdiddle Ben))
(wheel (Warbucks Oliver))
(wheel (Warbucks Oliver))
(wheel (Warbucks Oliver))
</p>

<p class="orig" lang="en">Why is Oliver Warbucks listed four times?
</p>

<p class="trans" lang="ja">
なぜオリバー・ウォーバックスが4回列挙されているのだろう?
</p>

<p class="exercise"><span class="ex_comment">まず、wheel の規則の本体の and 節の中の</span>
(supervisor ?middle-manager ?person)
<span class="ex_comment">にマッチする言明として、以下のものが見つかる。便宜上、番号を振っておく。
これらの言明の第2引数が、「大物」の候補ということ。</span>

(supervisor (Hacker Alyssa P) (Bitdiddle Ben))    <span class="ex_comment">(1)</span>
(supervisor (Fect Cy D) (Bitdiddle Ben))          <span class="ex_comment">(2)</span>
(supervisor (Tweakit Lem E) (Bitdiddle Ben))      <span class="ex_comment">(3)</span>
(supervisor (Reasoner Louis) (Hacker Alyssa P))   <span class="ex_comment">(4)</span>
(supervisor (Bitdiddle Ben) (Warbucks Oliver))    <span class="ex_comment">(5)</span>
(supervisor (Scrooge Eben) (Warbucks Oliver))     <span class="ex_comment">(6)</span>
(supervisor (Cratchet Robert) (Scrooge Eben))     <span class="ex_comment">(7)</span>
(supervisor (Aull DeWitt) (Warbucks Oliver))      <span class="ex_comment">(8)</span>

<span class="ex_comment">図で示すと、以下の通りの上下関係。</span>
Warbucks Oliver
  |
  +-- Bitdiddle Ben
  |     |
  |     +-- Hacker Alyssa P
  |     |     |
  |     |     +-- Reasoner Louis
  |     |
  |     +-- Fect Cy D
  |     +-- Tweakit Lem E
  |
  +-- Scrooge Eben
  |     |
  |     +-- Cratchet Robert
  |
  +-- Aull DeWitt

<span class="ex_comment">wheel の規則は、誰かの二段上の人を wheel (大物) と定義しているわけだから、
  * アリッサの二段上にいる職員としての、オリバー
  * ルイスの二段上にいる職員としての、ベン
  * サイの二段上にいる職員としての、オリバー
  * レムの二段上にいる職員としての、オリバー
  * ロバートの二段上にいる職員としての、オリバー
が答えとして出てくる。ということで、応答にはオリバーが4回含まれる。

実際、上記(1)〜(7)それぞれによって変数が束縛されてできた各フレームで、</span>
(supervisor ?x ?middle-manager)
<span class="ex_comment">にマッチする言明は、以下のとおりである。
  * (1)からできたフレームでは、(4)がマッチする。よって、ベンは大物。
  * (2)、(3)、(4)の各々からできたフレームでは、このパタンにマッチするものがない。
  * (5)からできたフレームでは、(1)、(2)、(3)がマッチする。
    よって、オリバーは大物。また、三つにマッチしたので、オリバーは3回、応答に出現する。
  * (6)からできたフレームでは、(7)がマッチする。よって、オリバーは大物。
  * (7)、(8)の各々からできたフレームでは、マッチするものがない。
</span></p>

<p class="extra_code"><span class="ex_comment">% <a href="#%_thm_4.64">練習問題4.64</a>と同様にトレースを行ってみる。</span>
| ?- wheel(Who).
      1    1  Call: wheel(_279) ? 
      2    2  Call: supervisor(_347,_279) ? 
      2    2  Exit: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      3    2  Call: supervisor(_344,['Hacker','Alyssa','P']) ? 
      3    2  Exit: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      1    1  Exit: wheel(['Bitdiddle','Ben']) ? 

Who = ['Bitdiddle','Ben'] ? ;
<span class="ex_comment">% ルイス→アリッサ→ベン</span>

      1    1  Redo: wheel(['Bitdiddle','Ben']) ? 
      3    2  Redo: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      3    2  Fail: supervisor(_344,['Hacker','Alyssa','P']) ? 
      2    2  Redo: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      2    2  Exit: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      3    2  Call: supervisor(_344,['Fect','Cy','D']) ? 
      3    2  Fail: supervisor(_344,['Fect','Cy','D']) ? 
      2    2  Redo: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      2    2  Exit: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      3    2  Call: supervisor(_344,['Tweakit','Lem','E']) ? 
      3    2  Fail: supervisor(_344,['Tweakit','Lem','E']) ? 
      2    2  Redo: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      2    2  Exit: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      3    2  Call: supervisor(_344,['Reasoner','Louis']) ? 
      3    2  Fail: supervisor(_344,['Reasoner','Louis']) ? 
      2    2  Redo: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      2    2  Exit: supervisor(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      3    2  Call: supervisor(_342,['Bitdiddle','Ben']) ? 
      3    2  Exit: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      1    1  Exit: wheel(['Warbucks','Oliver']) ? 

Who = ['Warbucks','Oliver'] ? ;
<span class="ex_comment">% </span>

      1    1  Redo: wheel(['Warbucks','Oliver']) ? 
      3    2  Redo: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      3    2  Exit: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      1    1  Exit: wheel(['Warbucks','Oliver']) ? 

Who = ['Warbucks','Oliver'] ? ;
<span class="ex_comment">% </span>

      1    1  Redo: wheel(['Warbucks','Oliver']) ? 
      3    2  Redo: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      3    2  Exit: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      1    1  Exit: wheel(['Warbucks','Oliver']) ? 

Who = ['Warbucks','Oliver'] ? ;
<span class="ex_comment">% </span>

      1    1  Redo: wheel(['Warbucks','Oliver']) ? 
      3    2  Redo: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      3    2  Fail: supervisor(_342,['Bitdiddle','Ben']) ? 
      2    2  Redo: supervisor(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      2    2  Exit: supervisor(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      3    2  Call: supervisor(_342,['Scrooge','Eben']) ? 
      3    2  Exit: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      1    1  Exit: wheel(['Warbucks','Oliver']) ? 

Who = ['Warbucks','Oliver'] ? ;
<span class="ex_comment">% </span>

      1    1  Redo: wheel(['Warbucks','Oliver']) ? 
      3    2  Redo: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      3    2  Fail: supervisor(_342,['Scrooge','Eben']) ? 
      2    2  Redo: supervisor(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      2    2  Exit: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      3    2  Call: supervisor(_342,['Cratchet','Robert']) ? 
      3    2  Fail: supervisor(_342,['Cratchet','Robert']) ? 
      2    2  Redo: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      2    2  Exit: supervisor(['Aull','DeWitt'],['Warbucks','Oliver']) ? 
      3    2  Call: supervisor(_342,['Aull','DeWitt']) ? 
      3    2  Fail: supervisor(_342,['Aull','DeWitt']) ? 
      1    1  Fail: wheel(_279) ? 

(4 ms) no
<span class="ex_comment">% これ以上の解はないと分かったので、これで終わり。</span>
</p>

<p class="orig" lang="en">
<a name="%_thm_4.66"></a>
<b>Exercise 4.66.</b>  <a name="%_idx_5280"></a>Ben has been generalizing the query system to provide statistics
about the company.  For example, to find the total salaries of all the
computer programmers one will be able to say</p>

<p class="trans" lang="ja">
<b>練習問題4.66.</b> ベンは、会社についての統計値を提供するために、クエリ・システムの一般化をずっと行っている。
たとえば、コンピュータ・プログラマ全員の給与総額を知るためには、以下のように述べることが可能となることだろう。
</p>

<p class="lisp">(sum ?amount
     (and (job ?x (computer programmer))
          (salary ?x ?amount)))
</p>

<p class="orig" lang="en">In general, Ben's new system allows expressions of the form</p>

<p class="trans" lang="ja">
一般に、ベンの新システムは、以下の形の式を許し、
</p>

<p class="lisp">(accumulation-function &lt;<em>variable</em>&gt;
                       &lt;<em>query pattern</em>&gt;)
</p>

<p class="orig" lang="en">where <tt>accumulation-function</tt> can be things like <tt>sum</tt>,  
<tt>average</tt>, or <tt>maximum</tt>.  Ben reasons that it should be a
cinch to implement this.  He will simply feed the query pattern to
<tt>qeval</tt>.  This will produce a stream of frames.  He will then pass
this stream through a mapping function that extracts the value of the
designated variable from each frame in the stream and feed the
resulting stream of values to the accumulation function.  Just as Ben
completes the implementation and is about to try it out, Cy walks by,
still puzzling over the <tt>wheel</tt> query result in
exercise <a href="#%_thm_4.65">4.65</a>.  When Cy shows Ben the system's
response, Ben groans, ``Oh, no, my simple accumulation scheme won't
work!''</p>

<p class="trans" lang="ja">
ここで、<tt>accumulation-function</tt> は、<tt>sum</tt> や、<tt>average</tt> や、あるいは <tt>maximum</tt> のようなものとすることができる。
ベンは、これを実装するのは朝飯前のはずだ、と推測する。
彼は、単純にクエリ・パタンを <tt>qeval</tt> へと与えるだろう。
これは、フレームのストリームを作り出すだろう。
彼は、それから、ストリーム内の各フレームから指定された変数の値を抽出するマッピング関数を通じて、このストリームを受け渡し、そして、結果として得られる値のストリームを、累積関数に与えるだろう。
ベンがちょうど実装を完了して、まさにその実装を試してみようとするときに、サイが通りかかったのだが、サイは、練習問題<a href="#%_thm_4.65">4.65</a>での <tt>wheel</tt> のクエリの結果に、まだ頭を悩ませている。
サイがベンにシステムの応答を見せると、ベンは「あちゃー、僕の単純な累積のやり方はうまくいかないよ!」とうめく。
</p>

<p class="orig" lang="en">
What has Ben just realized?  Outline a method he can use to
salvage the situation.
</p>

<p class="trans" lang="ja">
ちょうど今、ベンは何に気づいたところなのだろう?
状況を救い出すために彼が使える方法について、概要を述べよ。
</p>

<p class="exercise"><span class="ex_comment">練習問題<a href="#%_thm_4.65">4.65</a>でオリバーが4回出現したことを考慮すると、
もし、上記のベンの実装で</span>
(sum ?amount (and (wheel ?x) (salary ?x ?amount)))
<span class="ex_comment">とすると、所望の「大物たちの給与総額」は得られず、オリバーの給与が4回数えられてしまう。

つまり、クエリに <tt>or</tt> が含まれていなくてさえも、
  * ある一つのクエリ (たとえば (wheel ?x) ) と、
  * その中の一つの変数 (たとえば ?x) と、
  * そのクエリを満たすような、その変数に対する特定の一つの値 (たとえば (Warbucks Oliver) )
の組み合わせを導き出すようなフレームが、複数存在する場合がある、ということ。
多分、ベンはそのことに気づいたところなのだろう。

解決策は、累積関数に値のストリームを与える前に、このストリームから、重複した値を
取り除くこと。そして、値の重複のないストリームを、累積関数に与えること
(具体的にどう実装するかはともかくとして)。
</p>


<p class="orig" lang="en">
<a name="%_thm_4.67"></a>
<b>Exercise 4.67.</b>  <a name="%_idx_5282"></a><a name="%_idx_5284"></a>Devise a way to install a loop detector in the query system so as to
avoid the kinds of simple loops illustrated in the text and in
exercise <a href="#%_thm_4.64">4.64</a>.  The general idea is that the
system should maintain some sort of history of its current chain of
deductions and should not begin processing a query that it is already
working on.  Describe what kind of information (patterns and frames)
is included in this history, and how the check should be made.  (After
you study the details of the query-system implementation in
section <a href="#%_sec_4.4.4">4.4.4</a>, you may want to
modify the system to include your loop detector.)
</p>

<p class="trans" lang="ja">
<b>練習問題4.67.</b> 本文と練習問題<a href="#%_thm_4.64">4.64</a>において例示されている単純なループの類を避けるように、クエリ・システム内にループ検出器を組み入れる方法を、考案せよ。
一般的な考え方は、システムは自分の現在の演繹の連鎖についての、ある種の履歴を維持すべきであり、かつ、そのシステムが既に<!-- それについて作業したことのある -->作業対象としているクエリを、処理し始めるべきではない、というものだ。
どのような種類の情報 (パタンとフレーム) がこの履歴に含まれるのか、そして、どのようにして確認が行われるべきなのか、ということを説明せよ (君は、クエリ・システムの実装の詳細について<a href="#%_sec_4.4.4">4.4.4</a>節で研究した後、自分のループ検出器を含めるようにシステムを改変したいと思うかもしれないね)。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_4.68"></a>
<b>Exercise 4.68.</b>  <a name="%_idx_5286"></a>Define rules to implement the <tt>reverse</tt> operation of
exercise <a href="15_sec2_2.html#%_thm_2.18">2.18</a>, which returns a list containing the same
elements as a given list in reverse order.  (Hint: Use <tt>append-to-form</tt>.)
Can your rules answer both
<tt>(reverse (1 2 3) ?x)</tt> and <tt>(reverse ?x (1 2 3))</tt> ?
</p>

<p class="trans" lang="ja">
<b>練習問題4.68.</b> 練習問題<a href="15_sec2_2.html#%_thm_2.18">2.18</a>の <tt>reverse</tt> 演算——与えられたリストと同じ要素を逆順で含むリストを返す——を実装するための規則を定義せよ (ヒント: <a href="#%_idx_5158"><tt>append-to-form</tt></a> を使え)。
君の規則は、<tt>(reverse (1 2 3) ?x)</tt> と <tt>(reverse ?x (1 2 3))</tt> の両方に答えられるかな?
</p>

<p class="exercise"><span class="ex_comment">; とりあえず、以下の定義をクエリ言語に翻訳しようかな。</span>
(define (reverse arg-list)
  (if (or (null? arg-list) (null? (cdr arg-list)))
      arg-list
      (append (reverse (cdr arg-list)) (list (car arg-list)))))

<span class="ex_comment">; 場合分けにしたがって、規則を書き並べてみた。</span>
(rule (reverse () ()))
(rule (reverse (?x) (?x)))
(rule (reverse (?given-car . ?given-cdr) ?reversed-list)
      (and (reverse ?given-cdr ?reversed-cdr)
           (append-to-form ?reversed-cdr (?given-car) ?reversed-list)))

<span class="ex_comment">; このような定義でうまく動くのかを考える。
(a) (reverse (1 2 3) ?x) は、3番目の規則にマッチする。
    ここで、「?given-car が 1 に束縛され、?given-cdr が (2 3) に束縛され、
    ?reversed-list が ?x に束縛されたフレーム」(F1 とする) ができる。
(b) 次は F1 での (reverse (2 3) ?reversed-cdr) のユニフィケーションだが、
    これも3番目の規則にマッチする。変数の名前が同じなのでややこしいが、
    F1 に対する子フレーム (F2 とする) の側では、?given-car が 2 に束縛され、
    ?given-cdr が (3) に束縛され、?reversed-list は F1 での ?reversed-cdr に
    束縛される。
(c) すると今度は F2 での (reverse (3) ?reversed-cdr) のユニフィケーションだが、
    これは2番目の規則にマッチし、(この規則における) ?x が 3 に束縛される。
    そして、F2における ?reversed-cdr が (3) に束縛される。
(d) 次は、and 節の2番目のクエリについての、F2 でのユニフィケーション。
     つまり、(append-to-form (3) (2) ?reversed-list) のユニフィケーションを行う。
     append-to-form 内部の途中経過は省略すると、これにより、?reversed-list が
     (3 2) に束縛される。
(e) よって、(and (reverse (3) (3)) (append-to-form (3) (2) (3 2))) だから、
     F2 において (reverse (2 3) (3 2)) という結果が得られる。
(f) また、F2 の ?reversed-list は F1 での ?reversed-cdr に束縛されているから、
    次は、F1 での (append-to-form (3 2) (1) ?reversed-list) のユニフィケーション。
    append-to-form 内部の途中経過は省略すると、これにより、?reversed-list が
    (3 2 1) に束縛される。
(g) すでに (a) で述べたように、F1 においては ?reversed-list が ?x に束縛されて
    いるから、つまりは (reverse (1 2 3) ?x) の ?x は (3 2 1) だということ。
    ちゃんと解けた。

(h) では逆に、(reverse ?x (1 2 3)) というクエリだったらどうなるか。
    これは3番目の規則にマッチする。そして、「(?given-car . ?given-cdr) という
    対が ?x に束縛され、?reversed-list が (1 2 3) に束縛されたフレーム」
    (G1 とする) ができる。
(i) 次は G1 でのユニフィケーションだが、
    ……と、ここで思ったが、2番目の規則があると無限ループ行きかもしれない。
    ちゃんと考えないと分からないが、なんか危険な気がするな。
</span></p>

<p class="orig" lang="en">
<a name="%_thm_4.69"></a>
<b>Exercise 4.69.</b>  Beginning with the data base and the rules you formulated in
exercise <a href="#%_thm_4.63">4.63</a>, devise a rule for adding ``greats'' to
a grandson relationship. This should enable the system to deduce that
Irad is the great-grandson of Adam, or that Jabal and Jubal are
the great-great-great-great-great-grandsons of Adam.  (Hint: Represent
the fact about Irad, for example, as <tt>((great grandson) Adam
Irad)</tt>.  Write rules that determine if a list ends in the word
<tt>grandson</tt>.  Use this to express a rule that allows one to derive
the relationship <tt>((great .  ?rel) ?x ?y)</tt>, where <tt>?rel</tt> is a
list ending in <tt>grandson</tt>.)
Check your rules on queries such as
<tt>((great grandson) ?g ?ggs)</tt> and <tt>(?relationship Adam Irad)</tt>.
</p>

<p class="trans" lang="ja">
<b>練習問題4.69.</b> 練習問題<a href="#%_thm_4.63">4.63</a>で君が定式化したデータベースと規則から始めて、孫息子関係に<!-- 「<ruby><rb>曾</rb><rp> (</rp><rt>ひ</rt><rp>) </rp></ruby>」 -->「一世代離れた (great-)」を付け加えるための規則を、考案せよ。
これによって、システムが、イラデはアダムの曾孫である、とか、あるいは、ヤバルとユバルはアダムの<ruby><rb>仍孫</rb><rp> (</rp><rt>じょうそん</rt><rp>) </rp></ruby>である、と演繹することができるようになるはずだ
(ヒント: たとえばイラデについての事実を、<tt>((great grandson) Adam Irad)</tt> と表現せよ。<tt>grandson</tt> という語でリストが終わっているかどうかを判定する規則を書け。これを用いて、<tt>((great .  ?rel) ?x ?y)</tt> という関係を導出できるようにする規則を表せ。なおここで、<tt>?rel</tt> は <tt>grandson</tt> で終わるリストである)。
<tt>((great grandson) ?g ?ggs)</tt> や <tt>(?relationship Adam Irad)</tt> のようなクエリに対して、君の規則を確認せよ。
</p>

<p class="exercise">

<span class="inline-aa">
　　　　　子　　　孫　　曾孫　　　玄孫　　　　来孫　　　昆孫　　<ruby><rb>仍孫</rb><rp> (</rp><rt>じょうそん</rt><rp>) </rp></ruby>

アダム─カイン─エノク─イラデ─メホヤエル─メトサエル─レメク
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　├─┬ヤバル
　　　　　　　　　　　　　　　　　　　　　　　　　　　　アダ　└ユバル

</span>

<span class="ex_comment">
</span></p>

<a name="%_sec_4.4.4"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_4.4.4">4.4.4  Implementing the Query System</a></h3>
<h3 class="trans" lang="ja">4.4.4 クエリ・システムを実装する</h3>

<p class="orig" lang="en">Section <a href="#%_sec_4.4.2">4.4.2</a> described how the query system
works. Now we fill in the details by presenting a complete
implementation of the system.</p>

<p class="trans" lang="ja">
<a href="#%_sec_4.4.2">4.4.2</a>節では、クエリ・システムがどう動くのかを説明した。
今や、私たちは、システムの完全な実装を提示することにより、詳細を埋める。
</p>

<a name="%_sec_4.4.4.1"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_4.4.4.1">4.4.4.1  The Driver Loop and Instantiation</a></h4>
<h4 class="trans" lang="ja">4.4.4.1 ドライバ・ループとインスタンス化</h4>


<p class="orig" lang="en">
<a name="%_idx_5288"></a><a name="%_idx_5290"></a>The driver loop for the query system repeatedly reads input
expressions.  If the expression is a rule or assertion to be added to
the data base, then the information is added.  Otherwise the
expression is assumed to be a query.  The driver passes this query to
the evaluator <tt>qeval</tt> together with an initial frame stream
consisting of a single empty frame.  The result of the evaluation is a
stream of frames generated by satisfying the query with variable
values found in the data base.  These frames are used to form a new
stream consisting of copies of the original query in which the
variables are instantiated with values supplied by the stream of
frames, and this final stream is printed at the terminal:</p>

<p class="trans" lang="ja">
クエリ・システムのためのドライバ・ループは、繰り返し、入力された式を読む。
もし式が、データベースに追加すべき規則か言明だったら、その情報が追加される。
それ以外の場合、その式は、クエリだと想定される。
ドライバは、このクエリを、単一の空フレームからなる初期フレーム・ストリームと一緒に、<tt>qeval</tt> という評価器へと渡す。
評価の結果は、データベース内で見つかった変数値でクエリを満たすことにより生成される、フレームのストリームである。
これらのフレームは、フレームのストリームにより与えられる値で変数がインスタンス化された状態の元のクエリの複製からなる、新たなストリームを形成するのに使われる。そして、この最終的なストリームが、端末に印字される。
</p>

<p class="lisp"><a name="%_idx_5292"></a>(define input-prompt &quot;;;; Query input:&quot;)
(define output-prompt &quot;;;; Query results:&quot;)
<a name="%_idx_5294"></a>(define (query-driver-loop)
  (prompt-for-input input-prompt)
  (let ((q (query-syntax-process (read))))
    (cond ((assertion-to-be-added? q)
           (add-rule-or-assertion! (add-assertion-body q))
           (newline)
           (display &quot;Assertion added to data base.&quot;)
           (query-driver-loop))
          (else
           (newline)
           (display output-prompt)
           (display-stream
            (stream-map
             (lambda (frame)
               (instantiate q
                            frame
                            (lambda (v f)
                              (contract-question-mark v))))
             (qeval q (singleton-stream '()))))
           (query-driver-loop)))))
</p>

<p class="orig" lang="en"><a name="%_idx_5296"></a>Here, as in the other evaluators in this chapter, we use an abstract
syntax for the expressions of the query language.
The implementation of the expression syntax, including the predicate
<tt>assertion-to-be-added?</tt> and the selector <tt>add-assertion-body</tt>,
is given in section <a href="#%_sec_4.4.4.7">4.4.4.7</a>.
<tt>Add-rule-or-assertion!</tt> is defined in section <a href="#%_sec_4.4.4.5">4.4.4.5</a>.</p>

<p class="trans" lang="ja">
ここで、本章の他の評価器におけるのと同様に、クエリ言語の式のための抽象的<ruby><rb>文法</rb><rp> (</rp><rt>シンタックス</rt><rp>) </rp></ruby>を使う。
式の文法の実装—— <tt>assertion-to-be-added?</tt> という述語と <tt>add-assertion-body</tt> というセレクタを含む——は、<a href="#%_sec_4.4.4.7">4.4.4.7</a>節で与えられる。
<tt>add-rule-or-assertion!</tt> は<a href="#%_sec_4.4.4.5">4.4.4.5</a>節で定義される。
</p>

<p class="orig" lang="en">
Before doing any processing on an input expression, the driver loop
transforms it syntactically into a form that makes the processing more
efficient.  This involves changing the <a name="%_idx_5298"></a><a name="%_idx_5300"></a>representation of pattern
variables.  When the query is instantiated, any variables that remain
unbound are transformed back to the input representation before being
printed.  These transformations are performed by the two procedures
<tt>query-syntax-process</tt> and <tt>contract-question-mark</tt>
(section  <a href="#%_sec_4.4.4.7">4.4.4.7</a>).</p>

<p class="trans" lang="ja">
入力された式に対して何か処理を行う前に、ドライバ・ループは、その式を、処理をより効率的にする形式へと、文法的に変形する。
これは、パタン変数の表現を変更することを含む。
クエリがインスタンス化されるとき、束縛されていないままで残っているどの変数も、印字される前には、変形されて、入力された表現へと戻される。
これらの変形は、<tt>query-syntax-process</tt> と <tt>contract-question-mark</tt> という二つの手続きにより実行される (<a href="#%_sec_4.4.4.7">4.4.4.7</a>節)。
</p>

<p class="orig" lang="en">
<a name="%_idx_5302"></a>To instantiate an expression, we copy it, replacing any variables in
the expression by their values in a given frame.  The values are
themselves instantiated, since they could contain variables (for
example, if <tt>?x</tt> in <tt>exp</tt> is bound to <tt>?y</tt> as the result
of unification and <tt>?y</tt> is in turn bound to 5).  The action to
take if a variable cannot be instantiated is given by a procedural
argument to <tt>instantiate</tt>.</p>

<p class="trans" lang="ja">
式をインスタンス化するには、その式をコピーし、その際、その式の中のどの変数も、与えられたフレーム内での当該変数の値に置換する。
値は、それ自体がインスタンス化され<!--てい-->る。というのも、それらの値は、変数を含み得るからだ (たとえば、<tt>exp</tt> の中の <tt>?x</tt> がユニフィケーションの結果として <tt>?y</tt> に束縛されており、そして今度は <tt>?y</tt> が 5 に束縛されている場合などに)。
変数をインスタンス化できなかったら<!-- 取るべき行動 -->行うべき動作は、<tt>instantiate</tt> に対する手続き的引数により、提示される。
</p>

<p class="lisp"><a name="%_idx_5304"></a>(define (instantiate exp frame unbound-var-handler)
  (define (copy exp)
    (cond ((var? exp)
           (let ((binding (binding-in-frame exp frame)))
             (if binding
                 (copy (binding-value binding))
                 (unbound-var-handler exp frame))))
          ((pair? exp)
           (cons (copy (car exp)) (copy (cdr exp))))
          (else exp)))
  (copy exp))
</p>

<p class="orig" lang="en">The procedures that manipulate bindings are defined in
section <a href="#%_sec_4.4.4.8">4.4.4.8</a>.
</p>

<p class="trans" lang="ja">
束縛を操作する手続きは、<a href="#%_sec_4.4.4.8">4.4.4.8</a>節で定義される。
</p>


<a name="%_sec_4.4.4.2"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_4.4.4.2">4.4.4.2  The Evaluator</a></h4>
<h4 class="trans" lang="ja">4.4.4.2 評価器</h4>

<p class="orig" lang="en">
<a name="%_idx_5306"></a>The <tt>qeval</tt> procedure, called by the <tt>query-driver-loop</tt>, is
the basic evaluator of the query system.  It takes as inputs a query
and a stream of frames, and it returns a stream of extended frames.
It identifies special forms by a <a name="%_idx_5308"></a>data-directed dispatch using <tt>get</tt> and <tt>put</tt>, just as we did in implementing generic operations
in chapter 2.  Any query that is not identified as a special form is
assumed to be a simple query, to be processed by <tt>simple-query</tt>.</p>

<p class="trans" lang="ja">
<tt>qeval</tt> 手続き—— <tt>query-driver-loop</tt> により呼び出される——は、クエリ・システムの基本的評価器である。
これは、クエリと、フレームのストリームとを、入力としてとり、拡張したフレームのストリームを返す。
これは、2章で総称的演算を実装する際に行ったのとちょうど同様に、<tt>get</tt> と <tt>put</tt> を用いたデータ指向の<ruby><rb>割り振り</rb><rp> (</rp><rt>ディスパッチ</rt><rp>) </rp></ruby>により、特殊形式を識別する。
特殊形式として識別されないクエリはどれも、<tt>simple-query</tt> により処理されるべき単純クエリである、と想定される。
</p>

<p class="lisp"><a name="%_idx_5310"></a>(define (qeval query frame-stream)
  (let ((qproc (get (type query) 'qeval)))
    (if qproc
        (qproc (contents query) frame-stream)
        (simple-query query frame-stream))))
</p>

<p class="orig" lang="en"><tt>Type</tt> and <tt>contents</tt>, defined in section <a href="#%_sec_4.4.4.7">4.4.4.7</a>,
implement the abstract syntax of the special forms.</p>

<p class="trans" lang="ja">
<a href="#%_sec_4.4.4.7">4.4.4.7</a>節で定義した、<tt>type</tt> と <tt>contents</tt> が、特殊形式の抽象的な構文を実装する。
</p>

<a name="%_sec_Temp_696"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_696">Simple queries</a></h4>
<h4 class="trans" lang="ja">単純クエリ</h4>

<p class="orig" lang="en">
<a name="%_idx_5312"></a>
The <tt>simple-query</tt> procedure handles simple queries.  It takes as
arguments a simple query (a pattern) together with a stream of frames,
and it returns the stream formed by extending each frame by all
data-base matches of the query.</p>

<p class="trans" lang="ja">
<tt>simple-query</tt> 手続きは、単純クエリを取り扱う。
これは、単純クエリ (パタン) を、フレームのストリームとともに引数として取り、そのクエリの、データベース上でのすべてのマッチによって、各フレームを拡張することで形成される、ストリームを返す。
</p>

<p class="lisp"><a name="%_idx_5314"></a>(define (simple-query query-pattern frame-stream)
  (stream-flatmap
   (lambda (frame)
     (stream-append-delayed
      (find-assertions query-pattern frame)
      (delay (apply-rules query-pattern frame))))
   frame-stream))
</p>

<p class="orig" lang="en">
For each frame in the input stream, we use <tt>find-assertions</tt>
(section <a href="#%_sec_4.4.4.3">4.4.4.3</a>) to match the pattern against all
assertions in the data base, producing a stream of extended frames,
and we use <tt>apply-rules</tt> (section <a href="#%_sec_4.4.4.4">4.4.4.4</a>) to apply
all possible rules, producing another stream of extended frames.
These two streams are combined (using <tt>stream-append-delayed</tt>,
section <a href="#%_sec_4.4.4.6">4.4.4.6</a>) to make a stream of all the ways that
the given pattern can be satisfied consistent with the original frame
(see exercise <a href="#%_thm_4.71">4.71</a>).  The streams for the
individual input frames are combined using <tt>stream-flatmap</tt>
(section <a href="#%_sec_4.4.4.6">4.4.4.6</a>) to form one large stream of all the
ways that any of the frames in the original input stream can be
extended to produce a match with the given pattern.</p>

<p class="trans" lang="ja">
入力ストリーム内の各フレームについて、<tt>find-assertions</tt> (<a href="#%_sec_4.4.4.3">4.4.4.3</a>節) を使って、データベース内のすべての言明に対して当該パタンをマッチさせ、拡張したフレームのストリームを作り出すとともに、<tt>apply-rules</tt> (<a href="#%_sec_4.4.4.4">4.4.4.4</a>節) を使って、すべてのあり得る規則を適用して、拡張したフレームのもう一つ別のストリームを作り出す。
これら二つのストリームを (<a href="#%_sec_4.4.4.6">4.4.4.6</a>節の <tt>stream-append-delayed</tt> を用いて) 結合して、元のフレームと整合性を保ちつつ所与のパタンを満たせるようなすべての方法のストリームを作る (練習問題<a href="#%_thm_4.71">4.71</a>を参照)。
<!-- 元の入力ストリーム内のフレームのいずれかを、所与のパタンとのマッチを作り出すように拡張することができるような、すべての方法からなる一つの大きなストリームを形成するように、個々の入力フレームに対するストリームを、<tt>stream-flatmap</tt> (<a href="#%_sec_4.4.4.6">4.4.4.6</a>節) を用いて結合する。 -->
個々の入力フレームに対するストリームを、<tt>stream-flatmap</tt> (<a href="#%_sec_4.4.4.6">4.4.4.6</a>節) を用いて結合し、所与のパタンとのマッチを作り出すように元の入力ストリーム内のフレームのいずれかを拡張することができるようなすべての方法からなる、一つの大きなストリームを形成する。
</p>

<a name="%_sec_Temp_697"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_697">Compound queries</a></h4>
<h4 class="trans" lang="ja">複合クエリ</h4>

<p class="orig" lang="en">
<a name="%_idx_5316"></a>
<a name="%_idx_5318"></a><tt>And</tt> queries are handled as illustrated in
figure <a href="#%_fig_4.5">4.5</a> by the <tt>conjoin</tt> procedure.  <tt>Conjoin</tt> takes as inputs the conjuncts and the frame stream and
returns the stream of extended frames.  First, <tt>conjoin</tt> processes
the stream of frames to find the stream of all possible frame extensions
that satisfy the first query in the conjunction.  Then, using this as the new
frame stream, it recursively applies <tt>conjoin</tt> to the rest of the
queries.</p>

<p class="trans" lang="ja">
<tt>and</tt> クエリは、図<a href="#%_fig_4.5">4.5</a>に示されているとおり、<tt>conjoin</tt> 手続きにより取り扱われる。
<tt>conjoin</tt> は、連言肢とフレーム・ストリームとを入力として取り、拡張したフレームのストリームを返す。
<!-- まず、<tt>conjoin</tt> は、連言の中で最初のクエリを満たすような、すべてのあり得るフレーム拡張のストリームを見つけるために、フレームのストリームを処理する。
 -->
まず、<tt>conjoin</tt> は、フレームのストリームを処理して、連言の中で最初のクエリを満たすようなすべてのあり得るフレーム拡張のストリームを見つける。
それから、これ<span class="note"> (この見つけたストリーム) </span>を新たなフレーム・ストリームとして用いて、<tt>conjoin</tt> は、クエリの残りの部分に <tt>conjoin</tt> を再帰的に適用する。
</p>

<p class="lisp"><a name="%_idx_5320"></a>(define (conjoin conjuncts frame-stream)
  (if (empty-conjunction? conjuncts)
      frame-stream
      (conjoin (rest-conjuncts conjuncts)
               (qeval (first-conjunct conjuncts)
                      frame-stream))))
</p>

<p class="orig" lang="en">The expression
</p>

<p class="trans" lang="ja">
次の式は、
</p>

<p class="lisp">(put 'and 'qeval conjoin)
</p>

<p class="orig" lang="en">sets up <tt>qeval</tt> to dispatch to <tt>conjoin</tt> when an <tt>and</tt>
form is encountered.</p>

<p class="trans" lang="ja">
<tt>and</tt> 形式に遭遇したときに <tt>conjoin</tt> へと<ruby><rb>振り分け</rb><rp> (</rp><rt>ディスパッチ</rt><rp>) </rp></ruby>を行うように、<tt>qeval</tt> を設定する。
</p>

<p class="orig" lang="en">
<a name="%_idx_5322"></a><tt>Or</tt> queries are handled similarly, as shown in
figure <a href="#%_fig_4.6">4.6</a>.  The output streams for the various
disjuncts of the <tt>or</tt> are computed separately and merged using the
<tt>interleave-delayed</tt> procedure from section <a href="#%_sec_4.4.4.6">4.4.4.6</a>.
(See exercises <a href="#%_thm_4.71">4.71</a> and <a href="#%_thm_4.72">4.72</a>.)</p>

<p class="trans" lang="ja">
<tt>or</tt> クエリも同様に、図<a href="#%_fig_4.6">4.6</a>に示すように取り扱われる。
<tt>or</tt> の様々な選言肢に対する出力ストリームを、別々に計算し、<a href="#%_sec_4.4.4.6">4.4.4.6</a>節の <tt>interleave-delayed</tt> 手続きを用いて合併する (練習問題<a href="#%_thm_4.71">4.71</a>と練習問題<a href="#%_thm_4.72">4.72</a>を参照)。
</p>

<p class="lisp"><a name="%_idx_5324"></a>(define (disjoin disjuncts frame-stream)
  (if (empty-disjunction? disjuncts)
      the-empty-stream
      (interleave-delayed
       (qeval (first-disjunct disjuncts) frame-stream)
       (delay (disjoin (rest-disjuncts disjuncts)
                       frame-stream)))))
(put 'or 'qeval disjoin)
</p>

<p class="orig" lang="en">The predicates and selectors for the syntax of conjuncts and disjuncts
are given in section <a href="#%_sec_4.4.4.7">4.4.4.7</a>.</p>

<p class="trans" lang="ja">
連言肢や選言肢の構文についての、述語やセレクタは、<a href="#%_sec_4.4.4.7">4.4.4.7</a>節で与えられる。
</p>

<a name="%_sec_Temp_698"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_698">Filters</a></h4>
<h4 class="trans" lang="ja">フィルタ</h4>

<p class="orig" lang="en">
<a name="%_idx_5326"></a><tt>Not</tt> is handled by the method outlined in
section <a href="#%_sec_4.4.2">4.4.2</a>.  We attempt to extend each frame in
the input stream to satisfy the query being negated, and we include a
given frame in the output stream only if it cannot be extended.</p>

<p class="trans" lang="ja">
<tt>not</tt> は、<a href="#%_sec_4.4.2">4.4.2</a>節で概要を述べた手法によって、取り扱われる。
私たちは、入力ストリーム中の各フレームを、否定されているクエリを満たすように拡張しようと試み、そして、与えられたフレームを拡張できなかったときにのみ、与えられたフレームを出力ストリームに含める。
</p>

<p class="lisp"><a name="%_idx_5328"></a>(define (negate operands frame-stream)
  (stream-flatmap
   (lambda (frame)
     (if (stream-null? (qeval (negated-query operands)
                              (singleton-stream frame)))
         (singleton-stream frame)
         the-empty-stream))
   frame-stream))
(put 'not 'qeval negate)
</p>

<p class="orig" lang="en">
<a name="%_idx_5330"></a><tt>Lisp-value</tt> is a filter similar to <tt>not</tt>.  Each frame in the
stream is used to instantiate the variables in the pattern, the
indicated predicate is applied, and the frames for which the predicate
returns false are filtered out of the input stream.  An error results
if there are unbound pattern variables.</p>

<p class="trans" lang="ja">
<tt>lisp-value</tt> は、<tt>not</tt> に似たフィルタである。
パタン内の変数をインスタンス化するのにストリーム中の各フレームが使われ、示された述語が適用され、述語が偽を返すようなフレームが入力ストリームからフィルタにより除去される。
もし束縛されていないパタン変数があれば、エラーが生じる。
</p>

<p class="lisp"><a name="%_idx_5332"></a>(define (lisp-value call frame-stream)
  (stream-flatmap
   (lambda (frame)
     (if (execute
          (instantiate
           call
           frame
           (lambda (v f)
             (error &quot;Unknown pat var -- LISP-VALUE&quot; v))))
         (singleton-stream frame)
         the-empty-stream))
   frame-stream))
(put 'lisp-value 'qeval lisp-value)
</p>

<p class="orig" lang="en">
<tt>Execute</tt>, which applies the predicate to the arguments, must <tt>eval</tt> the predicate expression to get the procedure to apply.
However, it must not evaluate the arguments, since they are already
the actual arguments, not expressions whose evaluation (in Lisp) will
produce the arguments.  Note that <tt>execute</tt> is implemented using
<a name="%_idx_5334"></a><tt>eval</tt> and <tt>apply</tt> from the underlying Lisp system.</p>

<p class="trans" lang="ja">
<tt>execute</tt> ——述語を引数に適用する——は、適用すべき手続きを得るために、述語の式を <tt>eval</tt> せねばならない。
しかし、<tt>execute</tt> は、引数を評価してはならない。というのも、引数はすでに実際の引数なのであって、(Lisp での) 評価が引数を作り出すであろうような式なのではないからだ。
根底にある Lisp システムでの <tt>eval</tt> と <tt>apply</tt> を使って <tt>execute</tt> が実装される、ということに注意してほしい。
</p>

<p class="lisp">(define (execute exp)
  (apply (eval (predicate exp) user-initial-environment)
         (args exp)))
</p>

<p class="orig" lang="en">
The <tt>always-true</tt> special form provides for a query that is always
satisfied.  It ignores its contents (normally empty) and simply passes
through all the frames in the input stream.  <tt>Always-true</tt> is used
by the <tt>rule-body</tt> selector (section <a href="#%_sec_4.4.4.7">4.4.4.7</a>)
<a name="%_idx_5336"></a>to provide bodies for rules that were
defined without bodies (that is, rules whose conclusions are always
satisfied).</p>

<p class="trans" lang="ja">
<tt>always-true</tt> という特殊形式は、常に満たされるクエリを与える。
これは、自分の中身 (普通は空) を無視して、単純に入力ストリーム内の全フレームを通す。
<tt>always-true</tt> は、本体なしで定義された規則 (つまり、帰結部が常に満たされるような規則) に本体を与えるために、<tt>rule-body</tt> セレクタ (<a href="#%_sec_4.4.4.7">4.4.4.7</a>節) によって使われる。
</p>

<p class="lisp"><a name="%_idx_5338"></a>(define (always-true ignore frame-stream) frame-stream)
(put 'always-true 'qeval always-true)
</p>

<p class="orig" lang="en">The selectors that define the syntax of <tt>not</tt> and <tt>lisp-value</tt>
are given in section <a href="#%_sec_4.4.4.7">4.4.4.7</a>.
</p>

<p class="trans" lang="ja">
<tt>not</tt> と <tt>lisp-value</tt> の構文を定義するセレクタは、<a href="#%_sec_4.4.4.7">4.4.4.7</a>節で与えられる。
</p>

<a name="%_sec_4.4.4.3"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_4.4.4.3">4.4.4.3  Finding Assertions by Pattern Matching</a></h4>
<h4 class="trans" lang="ja">4.4.4.3 パタン・マッチングにより<ruby><rb>言明</rb><rp> (</rp><rt>アサーション</rt><rp>) </rp></ruby>を見つける</h4>

<p class="orig" lang="en">
<a name="%_idx_5340"></a><a name="%_idx_5342"></a><tt>Find-assertions</tt>, called by <tt>simple-query</tt>
(section <a href="#%_sec_4.4.4.2">4.4.4.2</a>), takes as input a pattern and a frame.
It returns a stream of frames, each extending the given one by a
data-base match of the given pattern.  It uses <tt>fetch-assertions</tt>
(section <a href="#%_sec_4.4.4.5">4.4.4.5</a>) to get a stream of all the assertions in
the data base that should be checked for a match against the pattern
and the frame.  The reason for <tt>fetch-assertions</tt> here is that we
can often apply simple tests that will eliminate many of the entries
in the data base from the pool of candidates for a successful match.
The system would still work if we eliminated <tt>fetch-assertions</tt>
and simply checked a stream of all assertions in the data base, but
the computation would be less efficient because we would need to make
many more calls to the matcher.</p>

<p class="trans" lang="ja">
<tt>find-assertions</tt>  —— <tt>simple-query</tt> (<a href="#%_sec_4.4.4.2">4.4.4.2</a>節) により呼び出される——は、パタンとフレームを入力としてとる。
<tt>find-assertions</tt> はフレームのストリームを返すのだが、それらフレームの各々は、与えられたパタンの、データベース上でのマッチによって、与えられたフレームを拡張するものである。
<tt>find-assertions</tt> は、<tt>fetch-assertions</tt> (<a href="#%_sec_4.4.4.5">4.4.4.5</a>節) を用いて、パタンとフレームに対するマッチがあるかを調べるべき、データベース内のすべての言明からなる、ストリームを得る。
ここで <tt>fetch-assertions</tt> を使う理由は、成功するマッチの候補の蓄えからデータベース内のエントリの多くを削除するであろう、単純な検査を適用できることが、よくあるためである。
もし <tt>fetch-assertions</tt> を削除して、単純にデータベース内のすべての言明のストリームを調べたとしても、システムは依然として機能するだろうが、もっとたくさんの回数、マッチャの呼び出しを行う必要があるだろうから、計算の効率性は落ちるだろう。
</p>

<p class="lisp"><a name="%_idx_5344"></a>(define (find-assertions pattern frame)
  (stream-flatmap (lambda (datum)
                    (check-an-assertion datum pattern frame))
                  (fetch-assertions pattern frame)))
</p>

<p class="orig" lang="en">
<tt>Check-an-assertion</tt> takes as arguments a pattern, a data object
(assertion), and a frame and returns either a one-element stream
containing the extended frame or <tt>the-empty-stream</tt> if the match
fails.</p>

<p class="trans" lang="ja">
<tt>check-an-assertion</tt> は、引数として、パタンとデータ・オブジェクト (言明) とフレームをとり、拡張したフレームを含む一要素のストリームか、もしくは、マッチが失敗した場合には <tt>the-empty-stream</tt> を返す。
</p>

<p class="lisp">(define (check-an-assertion assertion query-pat query-frame)
  (let ((match-result
         (pattern-match query-pat assertion query-frame)))
    (if (eq? match-result 'failed)
        the-empty-stream
        (singleton-stream match-result))))
</p>

<p class="orig" lang="en">The basic pattern matcher returns either the symbol <tt>failed</tt> or an
extension of the given frame.  The basic idea of the matcher is to
check the pattern against the data, element by element, accumulating
bindings for the pattern variables.  If the pattern and the data
object are the same, the match succeeds and we return the frame of
bindings accumulated so far.  Otherwise, if the pattern is a variable
we extend the current frame by binding the variable to the data, so
long as this is consistent with the bindings already in the frame.  If
the pattern and the data are both pairs, we (recursively) match the
<tt>car</tt> of the pattern against the <tt>car</tt> of the data to produce
a frame; in this frame we then match the <tt>cdr</tt> of the pattern
against the <tt>cdr</tt> of the data.  If none of these cases are
applicable, the match fails and we return the symbol <tt>failed</tt>.</p>

<p class="trans" lang="ja">
基本的パタン・マッチャは、<tt>failed</tt> という記号か、または、与えられたフレームの拡張を返す。
マッチャの基本的な考え方は、パタン変数に対する束縛を蓄積しながら、データに対してパタンを要素ごとに調べる、というものである。
もしパタンとデータ・オブジェクトが等しければ、マッチは成功し、これまでのところ蓄積された束縛のフレームを返す。
それ以外の場合、もしパタンが変数なら、その変数をデータに束縛することで現在のフレームを拡張する——これが、フレーム内に既にある束縛と整合性が取れている限りは。
もしパタンとデータの双方が対であれば、(再帰的に) パタンの <tt>car</tt> をデータの <tt>car</tt> に対してマッチさせて、フレームを作り出す。このフレームにおいて、その後、パタンの <tt>cdr</tt> をデータの <tt>cdr</tt> に対してマッチさせる。
これらの場合のどれも当てはまらなければ、マッチは失敗し、<tt>failed</tt> という記号を返す。
</p>

<p class="lisp"><a name="%_idx_5346"></a>(define (pattern-match pat dat frame)
  (cond ((eq? frame 'failed) 'failed)
        ((equal? pat dat) frame)
        ((var? pat) (extend-if-consistent pat dat frame))
        ((and (pair? pat) (pair? dat))
         (pattern-match (cdr pat)
                        (cdr dat)
                        (pattern-match (car pat)
                                       (car dat)
                                       frame)))
        (else 'failed)))
</p>

<p class="orig" lang="en">
Here is the procedure that extends a frame by adding a new binding, if
this is consistent with the bindings already in the frame:</p>

<p class="trans" lang="ja">
新たな束縛を——もしこれが、フレーム内に既にある束縛と整合性が取れていれば——加えることで、フレームを拡張する手続きを、ここに示す。
</p>

<p class="lisp"><a name="%_idx_5348"></a>(define (extend-if-consistent var dat frame)
  (let ((binding (binding-in-frame var frame)))
    (if binding
        (pattern-match (binding-value binding) dat frame)
        (extend var dat frame))))
</p>

<p class="orig" lang="en">If there is no binding for the variable in the frame, we simply add
the binding of the variable to the data.  Otherwise we match, in the
frame, the data against the value of the variable in the frame.  If
the stored value contains only constants, as it must if it was stored
during pattern matching by <tt>extend-if-consistent</tt>, then the match
simply tests whether the stored and new values are the same.  If so,
it returns the unmodified frame; if not, it returns a failure
indication.  The stored value may, however, contain pattern variables
if it was stored during unification (see section <a href="#%_sec_4.4.4.4">4.4.4.4</a>).
The recursive match of the stored pattern against the new data will add or
check bindings for the variables in this pattern.  For example,
suppose we have a frame in which <tt>?x</tt> is bound to <tt>(f ?y)</tt> and
<tt>?y</tt> is unbound, and we wish to augment this frame by a binding of
<tt>?x</tt> to <tt>(f b)</tt>.  We look up <tt>?x</tt> and find that it is
bound to <tt>(f ?y)</tt>.  This leads us to match <tt>(f ?y)</tt> against
the proposed new value <tt>(f b)</tt> in the same frame.  Eventually
this match extends the frame by adding a binding of <tt>?y</tt> to <tt>b</tt>.  <tt>?X</tt> remains bound to <tt>(f ?y)</tt>.  We never modify a stored
binding and we never store more than one binding for a given variable.</p>

<p class="trans" lang="ja">
そのフレーム内のその変数についての束縛が、もし存在しなければ、そのデータへのその変数の束縛を、ただ加えるだけである。
それ以外の場合、そのフレーム内で、そのフレーム内のその変数の値に対して、そのデータをマッチさせる。
もし、格納されている値が定数のみを含むなら——もしその値が、<tt>extend-if-consistent</tt> によるパタン・マッチングの間に格納されたのであれば、きっとそうなる筈だが——そのマッチは、単に、格納されている値と新たな値が等しいかどうかを調べるだけである。
もし等しければ、変更しないままのフレームを返す。もし等しくなければ、失敗の印を返す。
しかし、格納されている値は、もしそれがユニフィケーションの間に格納されたのであれば、パタン変数を含むこともあり得る (<a href="#%_sec_4.4.4.4">4.4.4.4</a>節を参照)。
格納されているパタンの、新たなデータに対する再帰的マッチは、このパタン内の変数についての束縛を加えたり、または調べたりするだろう。
たとえば、<tt>?x</tt> が <tt>(f ?y)</tt> に束縛されており、かつ、<tt>?y</tt> が束縛されていないようなフレームがあるものとして、このフレームを、<tt>?x</tt> の <tt>(f b)</tt> への束縛によって拡大したいのだとしよう。
私たちは、<tt>x?</tt> を調べ、そして、<tt>x?</tt> が <tt>(f ?y)</tt> に束縛されていると分かる。
このことにより私たちは、<tt>(f b)</tt> という提案された新たな値に対して、<tt>(f ?y)</tt> を同一フレーム内でマッチさせるように、仕向けられる。
最終的に、このマッチは、<tt>?y</tt> の <tt>b</tt> への束縛を加えることでフレームを拡張する。
<tt>x?</tt> は <tt>(f ?y)</tt> に束縛されたままである。
私たちは、格納されている束縛を決して変更しないし、与えられた変数について一つよりも多くの束縛を格納することも、決してしない。
</p>

<p class="orig" lang="en">
The procedures used by <tt>extend-if-consistent</tt> to manipulate
bindings are defined in section <a href="#%_sec_4.4.4.8">4.4.4.8</a>.</p>

<p class="trans" lang="ja">
束縛を操作するために <tt>extend-if-consistent</tt> により使われる手続きは、<a href="#%_sec_4.4.4.8">4.4.4.8</a>節で定義される。
</p>

<a name="%_sec_Temp_699"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_699">Patterns with dotted tails</a></h4>
<h4 class="trans" lang="ja">ドットの付いた末尾があるパタン</h4>

<p class="orig" lang="en">
<a name="%_idx_5350"></a>
If a pattern contains a dot followed by a pattern variable, the
pattern variable matches the rest of the data list (rather than the
next element of the data list), just as one would expect with the
dotted-tail notation described in exercise <a href="15_sec2_2.html#%_thm_2.20">2.20</a>.
Although the pattern matcher we have just implemented doesn't look for
dots, it does behave as we want.  This is because the Lisp <tt>read</tt>
primitive, which is used by <tt>query-driver-loop</tt> to read the query
and represent it as a list structure, treats dots in a special way.</p>

<p class="trans" lang="ja">
もしパタンが、パタン変数が後に続いているドットを含むなら、そのパタン変数は、(データ・リストの次の要素ではなく) データ・リストの残りの部分にマッチする——ちょうど、練習問題<a href="15_sec2_2.html#%_thm_2.20">2.20</a>で説明した、末尾にドットがついた記法を使って、人が予期するであろうとおりに。
私たちが実装したばかりのパタン・マッチャは、ドットを探すわけではないが、私たちが望むとおりにふるまう。
これは、Lisp により <tt>read</tt> されたプリミティブ——クエリを読んでそれをリスト構造として表現するために <tt>query-driver-loop</tt> によって使われる——が、ドットを特別な方法で扱うからである。
</p>

<p class="orig" lang="en">
<a name="%_idx_5352"></a><a name="%_idx_5354"></a>When <tt>read</tt> sees a dot, instead of making the next item be the
next element of a list (the <tt>car</tt> of a <tt>cons</tt> whose <tt>cdr</tt>
will be the rest of the list) it makes the next item be the <tt>cdr</tt>
of the list structure.  For example, the list structure produced by
<tt>read</tt> for the pattern <tt>(computer ?type)</tt> could be constructed
by evaluating the expression <tt>(cons 'computer (cons '?type '()))</tt>,
and that for <tt>(computer . ?type)</tt> could be constructed by
evaluating the expression <tt>(cons 'computer '?type)</tt>.</p>

<p class="trans" lang="ja">
<tt>read</tt> は、ドット<!-- を見る -->に出会うと、次の項目を、リストの次の要素とする (<tt>cdr</tt> がそのリストの残りの部分となるであろうような <tt>cons</tt> の、<tt>car</tt> とする) 代わりに、次の項目をリスト構造の <tt>cdr</tt> とする。
たとえば、<tt>(computer ?type)</tt> というパタンに対して <tt>read</tt> により作り出されるリスト構造は、<tt>(cons 'computer (cons '?type '()))</tt> という式を評価することによって構築できるだろうし、<tt>(computer . ?type)</tt> に対するものは、<tt>(cons 'computer '?type)</tt> という式を評価することによって構築できるだろう。
<span class="note"><br>(入り組んでいて分かりづらいのだけれど、多分、次のような意図だと思う。
たとえば、<tt>(computer . ?type)</tt> のドットを見ると、ドットの「次の項目」である <tt>?type</tt> を、リストの次の要素とする——つまり、<tt>(computer ?type)</tt> と構築する——ということはしない。すなわち、ドットの「次の項目」である <tt>?type</tt> を、「その <tt>cdr</tt> が、(その <tt>(computer ?type)</tt> という)『リスト』の『残りの部分』たる <tt>()</tt> となるような <tt>cons</tt> の、<tt>car</tt>」にしたりはしない (要するに、<tt>?type</tt> を、<tt>(?type)</tt> という <tt>cons</tt> の <tt>car</tt> にはしない)。その代わり、ドットの「次の項目」である <tt>?type</tt> を、リスト構造の <tt>cdr</tt> として、<tt>(computer . ?type)</tt> というドット対を構築する。 )</span>
</p>

<p class="orig" lang="en">
Thus, as <tt>pattern-match</tt> recursively compares <tt>car</tt>s and <tt>cdr</tt>s of a data list and a pattern that had a dot, it eventually
matches the variable after the dot (which is a <tt>cdr</tt> of the
pattern) against a sublist of the data list, binding the variable to
that list.  For example, matching the pattern <tt>(computer . ?type)</tt> against
<tt>(computer programmer trainee)</tt> will match <tt>?type</tt> against the
list <tt>(programmer trainee)</tt>.
</p>

<p class="trans" lang="ja">
このようにして、<tt>pattern-match</tt> は、データ・リストとドットのあったパタンとの <tt>car</tt> 同士および <tt>cdr</tt> 同士を再帰的に比較するので、最終的に、ドットの後の変数 (パタンの <tt>cdr</tt>) をデータ・リストの部分リストに対してマッチさせ、その変数をそのリストに束縛する。
たとえば、<tt>(computer . ?type)</tt> というパタンを <tt>(computer programmer trainee)</tt> に対してマッチさせることで、<tt>(programmer trainee)</tt> というリストに対して <tt>?type</tt> をマッチさせることになるだろう。
</p>

<a name="%_sec_4.4.4.4"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_4.4.4.4">4.4.4.4  Rules and Unification</a></h4>
<h4 class="trans" lang="ja">4.4.4.4 規則とユニフィケーション</h4>

<p class="orig" lang="en">
<a name="%_idx_5356"></a><tt>Apply-rules</tt> is the rule analog of <tt>find-assertions</tt>
(section <a href="#%_sec_4.4.4.3">4.4.4.3</a>).  It
takes as input a pattern and a frame, and it forms a stream of
extension frames by applying rules from the data base.  <tt>Stream-flatmap</tt> maps <tt>apply-a-rule</tt> down the stream of possibly
applicable rules (selected by <tt>fetch-rules</tt>, section <a href="#%_sec_4.4.4.5">4.4.4.5</a>)
and combines the resulting streams of frames.</p>

<p class="trans" lang="ja">
<tt>apply-rules</tt> は、<tt>find-assertions</tt> (<a href="#%_sec_4.4.4.3">4.4.4.3</a>節)の、規則版の類似物である。
これは、入力としてパタンとフレームをとり、規則を適用することによってデータベースから拡張フレームのストリームを形成する。
<tt>stream-flatmap</tt> は、もしかすると適用可能な規則 (<a href="#%_sec_4.4.4.5">4.4.4.5</a>節の <tt>fetch-rules</tt> により選択される) のストリームに対して <tt>apply-a-rule</tt> をマップし、結果として生じるフレームのストリーム同士を結合する。

</p>

<p class="lisp"><a name="%_idx_5358"></a>(define (apply-rules pattern frame)
  (stream-flatmap (lambda (rule)
                    (apply-a-rule rule pattern frame))
                  (fetch-rules pattern frame)))
</p>

<p class="orig" lang="en">
<tt>Apply-a-rule</tt> applies rules using the method outlined in
section <a href="#%_sec_4.4.2">4.4.2</a>.  It first augments its argument
frame by unifying the rule conclusion with the pattern in the given
frame.  If this succeeds, it evaluates the rule body in this new
frame.</p>

<p class="trans" lang="ja">
<tt>apply-a-rule</tt> は、<a href="#%_sec_4.4.2">4.4.2</a>節で概要を述べた方法を用いて、規則を適用する。
これは、まず、規則の帰結部を、与えられたフレーム内のパタンとユニファイすることによって、自身の引数のフレームを拡張する。
もしこれが成功すれば、<tt>apply-a-rule</tt> は、規則の本体部をこの新たなフレームにおいて評価する。
</p>

<p class="orig" lang="en">
Before any of this happens, however, the program renames all the
variables in the rule with unique new names.  The reason for this is
to prevent the variables for different rule applications from becoming
confused with each other.  For instance, if two rules both use a
variable named <tt>?x</tt>, then each one may add a binding for <tt>?x</tt>
to the frame when it is applied.  These two <tt>?x</tt>'s have nothing to
do with each other, and we should not be fooled into thinking that the
two bindings must be consistent.  Rather than rename variables, we
could devise a more clever environment structure; however, the
renaming approach we have chosen here is the most straightforward,
even if not the most efficient.  (See
exercise <a href="#%_thm_4.79">4.79</a>.)  Here is the <tt>apply-a-rule</tt>
procedure:</p>

<p class="trans" lang="ja">
しかし、こうしたことのいずれかが起こる前に、プログラムは、規則内のすべての変数を、一意な新しい名前を使ってリネームする。
こうする理由は、異なる規則適用についての変数同士が、お互いと混同されるようになることを防ぐためである。
たとえば、二つの規則がどちらも <tt>?x</tt> と名付けられた変数を用いていれば、それぞれの規則が、その規則が適用された際に、<tt>?x</tt> に対する束縛をフレームに追加するかもしれない。
これら二つの <tt>?x</tt> はお互いに無関係であり、私たちは、二つの束縛は整合性が取れていなくてはならないと考えるように騙されたりすべきではない。
変数をリネームするのでなく、むしろ、私たちは、より賢い環境構造を考案することもできるであろう。しかし、ここで選択した、リネームするという手法は、もっとも効率的という訳ではないとしても、もっとも分かりやすいものである (練習問題<a href="#%_thm_4.79">4.79</a>を参照)。
<tt>apply-a-rule</tt> 手続きをここに示す。
</p>

<p class="lisp">(define (apply-a-rule rule query-pattern query-frame)
  (let ((clean-rule (rename-variables-in rule)))
    (let ((unify-result
           (unify-match query-pattern
                        (conclusion clean-rule)
                        query-frame)))
      (if (eq? unify-result 'failed)
          the-empty-stream
          (qeval (rule-body clean-rule)
                 (singleton-stream unify-result))))))
</p>

<p class="orig" lang="en">The selectors <tt>rule-body</tt> and <tt>conclusion</tt> that extract parts
of a rule are defined in section <a href="#%_sec_4.4.4.7">4.4.4.7</a>.</p>

<p class="trans" lang="ja">
規則の一部を抽出する <tt>rule-body</tt> および <tt>conclusion</tt> というセレクタは、<a href="#%_sec_4.4.4.7">4.4.4.7</a>節で定義される。
</p>

<p class="orig" lang="en">
We generate unique variable names by associating a unique identifier
(such as a number) with each rule application and combining this
identifier with the original variable names.  For example, if the
rule-application identifier is 7, we might change each <tt>?x</tt> in
the rule to <tt>?x-7</tt> and each <tt>?y</tt> in the rule to <tt>?y-7</tt>.
(<tt>Make-new-variable</tt> and <tt>new-rule-application-id</tt> are
included with the syntax procedures in section <a href="#%_sec_4.4.4.7">4.4.4.7</a>.)</p>

<p class="trans" lang="ja">
(番号などの) 一意な識別子をそれぞれの規則適用と対応づけて、この識別子を元の変数名と結合することによって、私たちは、一意な変数名を生成する。
たとえば、規則適用の識別子が 7 であれば、その規則内のそれぞれの <tt>?x</tt> を <tt>?x-7</tt> に変更するかもしれないし、その規則内のそれぞれの <tt>?y</tt> を <tt>?y-7</tt> に変更するかもしれない (<tt>make-new-variable</tt> と <tt>new-rule-application-id</tt> は、<a href="#%_sec_4.4.4.7">4.4.4.7</a>節の文法手続きに含まれている)。
</p>

<p class="lisp">(define (rename-variables-in rule)
  (let ((rule-application-id (new-rule-application-id)))
    (define (tree-walk exp)
      (cond ((var? exp)
             (make-new-variable exp rule-application-id))
            ((pair? exp)
             (cons (tree-walk (car exp))
                   (tree-walk (cdr exp))))
            (else exp)))
    (tree-walk rule)))
</p>

<p class="orig" lang="en">
<a name="%_idx_5360"></a><a name="%_idx_5362"></a>The unification algorithm is implemented as a procedure that takes as
inputs two patterns and a frame and returns either the extended frame
or the symbol <tt>failed</tt>.
The unifier is like the pattern matcher except that it is
symmetrical -- variables are allowed on both sides of the match.
<tt>Unify-match</tt> is basically the same as <tt>pattern-match</tt>,
except that there is extra code (marked ``<tt>***</tt>'' below) to handle
the case where the object on the right side of the match is a variable.</p>

<p class="trans" lang="ja">
二つのパタンと一つのフレームとを入力としてとり、拡張したフレームか、<tt>failed</tt> という記号の、いずれかを返すような手続きとして、ユニフィケーション・アルゴリズムは実装される。
ユニファイアは、対称的だ——変数がマッチの両側で許される——という点を除いては、パタン・マッチャと似ている。
<tt>unify-match</tt> は、基本的には <tt>pattern-match</tt> と同じである——ただし、マッチの右側にあるオブジェクトが変数である、という場合を扱うための、追加のコード (以下では &ldquo;<tt>***</tt>&rdquo; という印がついている) が存在する、という点を除いて。
</p>

<p class="lisp"><a name="%_idx_5364"></a>(define (unify-match p1 p2 frame)
  (cond ((eq? frame 'failed) 'failed)
        ((equal? p1 p2) frame)
        ((var? p1) (extend-if-possible p1 p2 frame))
        ((var? p2) (extend-if-possible p2 p1 frame))  <em>; ***</em>
        ((and (pair? p1) (pair? p2))
         (unify-match (cdr p1)
                      (cdr p2)
                      (unify-match (car p1)
                                   (car p2)
                                   frame)))
        (else 'failed)))
</p>

<p class="orig" lang="en">
In unification, as in one-sided pattern matching, we want to accept a
proposed extension of the frame only if it is consistent with existing
bindings.  The procedure <tt>extend-if-possible</tt> used in unification
is the same as the <tt>extend-if-consistent</tt> used in pattern matching
except for two special checks, marked ``<tt>***</tt>'' in the program
below.  In the first case, if the variable we are trying to match is
not bound, but the value we are trying to match it with
is itself a (different) variable, it is
necessary to check to see if the value is bound, and if so, to match
its value.  If both parties to the match are unbound, we may bind
either to the other.</p>

<p class="trans" lang="ja">
ユニフィケーションでは、片側だけのパタン・マッチングにおけるのと同様に、既存の束縛と整合性が取れている場合にのみ、フレームの、提案された拡張を受け入れるようにしたい。
ユニフィケーションで使われる <tt>extend-if-possible</tt> という手続きは、下記のプログラムにおいて &ldquo;<tt>***</tt>&rdquo; という印のついた二つの特別な検査を除いて、パタン・マッチングで使われる <tt>extend-if-consistent</tt> と同じである。
1番目の場合では、もし、マッチさせようとしている変数が束縛されていないものの、その変数にマッチさせようとしている値それ自体が (別の) 変数なのであれば、その値が束縛されているかどうかを調べる必要があり、もし束縛されていれば、その値とマッチさせる必要がある。
もし、マッチに対する双方の側が未束縛なら、どちらかを他方に束縛してもよい。
</p>

<p class="orig" lang="en">
The second check deals with attempts to bind a variable to a pattern
that includes that variable.  Such a situation can occur whenever a
variable is repeated in both patterns.  Consider, for example,
unifying the two patterns <tt>(?x ?x)</tt> and <tt>(?y
&lt;<em>expression involving <tt>?y</tt></em>&gt;)</tt> in a frame where both <tt>?x</tt>
and <tt>?y</tt> are unbound.  First <tt>?x</tt> is matched
against <tt>?y</tt>, making a binding of <tt>?x</tt> to <tt>?y</tt>.  Next, the same <tt>?x</tt> is matched against the given expression
involving <tt>?y</tt>.
Since <tt>?x</tt> is already bound to <tt>?y</tt>, this
results in matching <tt>?y</tt> against the expression.
If we think of the
unifier as finding a set of values for the pattern variables that make
the patterns the same, then these patterns imply instructions to find
a <tt>?y</tt> such that <tt>?y</tt> is equal to the expression involving <tt>?y</tt>.
There is no general method for solving such
equations, so we reject such bindings; these cases are recognized by
the predicate <tt>depends-on?</tt>.<a name="call_footnote_Temp_700" href="#footnote_Temp_700"><sup><small>80</small></sup></a>
On the other hand, we do not want to reject attempts
to bind a variable to itself.  For example, consider unifying <tt>(?x ?x)</tt>
and <tt>(?y ?y)</tt>.  The second attempt to bind <tt>?x</tt> to <tt>?y</tt> matches <tt>?y</tt> (the stored value of <tt>?x</tt>) against <tt>?y</tt>
(the new value of <tt>?x</tt>).  This is taken care of by the <tt>equal?</tt> clause
of <tt>unify-match</tt>.</p>

<p class="trans" lang="ja">
2番目の検査は、変数を、その変数を含むパタンへと束縛する試みを取り扱う。
そうした状況は、変数が双方のパタンで繰り返される場合にはいつでも起こり得る。
たとえば、<tt>?x</tt> と <tt>?y</tt> の双方が束縛されていないフレームにおいて、<tt>(?x ?x)</tt> および <tt>(?y &lt;<em class="en"><tt>?y</tt> を含む式</em>&gt;)</tt> という二つのパタンをユニファイすることを、考えよう。
まず、<tt>?x</tt> を <tt>?y</tt> に対してマッチさせ、<tt>?x</tt> の <tt>?y</tt> への束縛を作り出す。
次に、<tt>?y</tt> を含む、与えられた式に対して、同じ<tt>?x</tt> をマッチさせる。
<tt>?x</tt> は既に <tt>?y</tt> に束縛されているから、これは、<tt>?y</tt> を当該の式に対してマッチさせるという結果になる。
もし、ユニファイアのことを、パタン同士を等しくするような、パタン変数に対する値の集合を求めているのだと見なすなら、これらのパタン同士は、<tt>?y</tt> を含む式に <tt>?y</tt> が等しくなるような <tt>?y</tt> を求めよ、という命令を暗示する。
そうした方程式を解くための一般的手法は存在せず、それゆえ、私たちは、そういった束縛を拒絶する。これらの場合は、<tt>depends-on?</tt> という述語によって認識される<a href="#footnote_Temp_700"><sup><small>80</small></sup></a>。
一方、変数をその変数自身に束縛する試みは、拒絶したくない。
たとえば、<tt>(?x ?x)</tt> と <tt>(?y ?y)</tt> をユニファイすることを考えよう。
<tt>?x</tt> を <tt>?y</tt> に束縛しようという2回目の試みは、<tt>?y</tt> (<tt>?x</tt> の、格納された値) を、<tt>?y</tt> (<tt>?x</tt> の新たな値) に対してマッチさせる。
これは、<tt>unify-match</tt> の <tt>equal?</tt> によって処理される。
</p>

<p class="lisp"><a name="%_idx_5370"></a>(define (extend-if-possible var val frame)
  (let ((binding (binding-in-frame var frame)))
    (cond (binding
           (unify-match
            (binding-value binding) val frame))
          ((var? val)                      <em>; ***</em>
           (let ((binding (binding-in-frame val frame)))
             (if binding
                 (unify-match
                  var (binding-value binding) frame)
                 (extend var val frame))))
          ((depends-on? val var frame)     <em>; ***</em>
           'failed)
          (else (extend var val frame)))))
</p>

<p class="orig" lang="en">
<tt>Depends-on?</tt> is a predicate that tests whether an expression
proposed to be the value of a pattern variable depends on the variable.
This must be done relative to the current frame because the expression
may contain occurrences of a variable that already has a value that
depends on our test variable.  The structure of <tt>depends-on?</tt> is a
simple recursive tree walk in which we substitute for the values of
variables whenever necessary.</p>

<p class="trans" lang="ja">
<tt>depends-on?</tt> は、あるパタン変数の値となるべきだと提案されている式が、その変数に依存するか否かを検査する。
これは、現在のフレームに関して行われなくてはならない。なぜなら、テスト変数に依存する値を既に有しているような変数の出現を、その式が含んでいるかもしれないからである。
<tt>depends-on?</tt> の構造は、必要なときはいつでも変数の値を置き換えるような、単純で再帰的な木の<ruby><rb>歩道</rb><rp> (</rp><rt>ウォーク</rt><rp>) </rp></ruby>である。
</p>

<p class="lisp">(define (depends-on? exp var frame)
  (define (tree-walk e)
    (cond ((var? e)
           (if (equal? var e)
               true
               (let ((b (binding-in-frame e frame)))
                 (if b
                     (tree-walk (binding-value b))
                     false))))
          ((pair? e)
           (or (tree-walk (car e))
               (tree-walk (cdr e))))
          (else false)))
  (tree-walk exp))
</p>

<a name="%_sec_4.4.4.5"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_4.4.4.5">4.4.4.5  Maintaining the Data Base</a></h4>
<h4 class="trans" lang="ja">4.4.4.5 データベースを保守する</h4>

<p class="orig" lang="en">
<a name="%_idx_5372"></a>
<a name="%_idx_5374"></a><a name="%_idx_5376"></a>One important problem in designing logic programming languages is that
of arranging things so that as few irrelevant data-base entries as
possible will be examined in checking a given pattern.  In our
system, in addition to storing all assertions in one big stream,
we store all assertions whose <tt>car</tt>s are constant symbols
in separate streams, in a table indexed by the symbol.  To fetch an
assertion that may match a pattern, we first check to see if the <tt>car</tt> of the pattern is a constant symbol.  If so, we return (to be
tested using the matcher) all the stored assertions that have the same
<tt>car</tt>.  If the pattern's <tt>car</tt> is not a constant symbol, we
return all the stored assertions.  Cleverer methods could also take
advantage of information in the frame, or try also to optimize the
case where the <tt>car</tt> of the pattern is not a constant symbol.  We
avoid building our criteria for indexing (using the <tt>car</tt>,
handling only the case of constant symbols) into the program; instead
we call on predicates and selectors that embody our criteria.</p>

<p class="trans" lang="ja">
論理プログラミング言語を設計する際の一つの重要な問題は、与えられたパタンを調べる際には、無関係なデータベース・エントリはできるだけ少数のものだけを検討すれば済むように、物事を整えておく、という問題である。
私たちのシステムでは、一つの大きなストリームの中にすべての言明を格納することに加えて、<tt>car</tt> が定数記号であるようなすべての言明を、その記号により索引づけがなされた表の中の別々のストリームに格納する。
パタンにマッチするかもしれない言明を取ってくるには、まず、そのパタンの <tt>car</tt> が定数記号か否かを調べる。
もしそうであれば、同じ <tt>car</tt> を有する、すべての格納されている言明を、(マッチャを用いて検査されるようにするために) 返す。
もし、パタンの <tt>car</tt> が定数記号でなければ、すべての格納されている言明を返す。
より賢い方法であれば、フレーム内の情報をも利用できるであろうし、あるいは、パタンの <tt>car</tt> が定数記号でない場合をも最適化しようと試みることもできるだろう。
私たちは、(<tt>car</tt> を用いた、定数記号の場合だけを扱う) 索引づけのための、自分の基準を構築することを避け、その代わり、自分の基準を具現化するような、述語とセレクタを頼りにしている。
</p>

<p class="lisp">(define THE-ASSERTIONS the-empty-stream)
<a name="%_idx_5378"></a>(define (fetch-assertions pattern frame)
  (if (use-index? pattern)
      (get-indexed-assertions pattern)
      (get-all-assertions)))
(define (get-all-assertions) THE-ASSERTIONS)
(define (get-indexed-assertions pattern)
  (get-stream (index-key-of pattern) 'assertion-stream))
</p>

<p class="orig" lang="en"><tt>Get-stream</tt> looks up a stream in the table and returns an empty
stream if nothing is stored there.</p>

<p class="trans" lang="ja">
<tt>get-stream</tt> は、表にあるストリームを調べて、もしそこに何も格納されていなければ、空ストリームを返す。
</p>

<p class="lisp">(define (get-stream key1 key2)
  (let ((s (get key1 key2)))
    (if s s the-empty-stream)))
</p>

<p class="orig" lang="en">
Rules are stored similarly, using the <tt>car</tt> of the rule
conclusion.  Rule conclusions are arbitrary patterns, however, so they
differ from assertions in that they can contain variables.  A pattern
whose <tt>car</tt> is a constant symbol can match rules whose conclusions
start with a variable as well as rules whose conclusions have the same
<tt>car</tt>.  Thus, when fetching rules that might match a pattern whose
<tt>car</tt> is a constant symbol we fetch all rules whose conclusions
start with a variable as well as those whose conclusions have the same
<tt>car</tt> as the pattern.  For this purpose we store all rules whose
conclusions start with a variable in a separate stream in our table,
indexed by the symbol <tt>?</tt>.</p>

<p class="trans" lang="ja">
規則も同様に、規則帰結部の <tt>car</tt> を利用して、格納される。
しかし、規則帰結部は任意のパタンであり、そのため、規則帰結部は、変数を含むことができるという点で、言明とは異なる。
<tt>car</tt> が定数記号であるようなパタンは、帰結部が変数で始まる規則にマッチし得るし、帰結部が同じ <tt>car</tt> を有しているような規則にもマッチし得る。
よって、<tt>car</tt> が定数記号であるようなパタンとマッチするかもしれない規則を取ってくるときには、帰結部が変数で始まるすべての規則と、そのパタンと同じ <tt>car</tt> を帰結部が有している規則とを、取ってくる。
この目的のため、私たちは、帰結部が変数で始まるすべての規則を、表の中の別のストリーム—— <tt>?</tt> という記号により索引づけされたもの——に格納する。
</p>

<p class="lisp">(define THE-RULES the-empty-stream)
<a name="%_idx_5380"></a>(define (fetch-rules pattern frame)
  (if (use-index? pattern)
      (get-indexed-rules pattern)
      (get-all-rules)))
(define (get-all-rules) THE-RULES)
(define (get-indexed-rules pattern)
  (stream-append
   (get-stream (index-key-of pattern) 'rule-stream)
   (get-stream '? 'rule-stream)))
</p>

<p class="orig" lang="en">
<tt>Add-rule-or-assertion!</tt> is used by <tt>query-driver-loop</tt> to
add assertions and rules to the data base.  Each item is stored in the
index, if appropriate, and in a stream of all assertions or rules in
the data base.</p>

<p class="trans" lang="ja">
<tt>add-rule-or-assertion!</tt> は、データベースに言明や規則を追加するために、<tt>query-driver-loop</tt> により使われる。
各項目は、それが妥当な場合には索引に格納されるとともに、データベース内の全言明または全規則のストリームに格納される。
</p>


<p class="lisp"><a name="%_idx_5382"></a>(define (add-rule-or-assertion! assertion)
  (if (rule? assertion)
      (add-rule! assertion)
      (add-assertion! assertion)))
(define (add-assertion! assertion)
  (store-assertion-in-index assertion)
  (let ((old-assertions THE-ASSERTIONS))
    (set! THE-ASSERTIONS
          (cons-stream assertion old-assertions))
    'ok))
(define (add-rule! rule)
  (store-rule-in-index rule)
  (let ((old-rules THE-RULES))
    (set! THE-RULES (cons-stream rule old-rules))
    'ok))
</p>

<p class="orig" lang="en">
To actually store an assertion or a rule, we check to see if it can be
indexed.  If so, we store it in the appropriate stream.</p>

<p class="trans" lang="ja">
実際に言明または規則を格納するためには、その言明または規則を索引づけられるかどうかを調べる。
もし索引づけられるなら、その言明または規則を適切なストリームに格納する。
</p>

<p class="lisp">(define (store-assertion-in-index assertion)
  (if (indexable? assertion)
      (let ((key (index-key-of assertion)))
        (let ((current-assertion-stream
               (get-stream key 'assertion-stream)))
          (put key
               'assertion-stream
               (cons-stream assertion
                            current-assertion-stream))))))
(define (store-rule-in-index rule)
  (let ((pattern (conclusion rule)))
    (if (indexable? pattern)
        (let ((key (index-key-of pattern)))
          (let ((current-rule-stream
                 (get-stream key 'rule-stream)))
            (put key
                 'rule-stream
                 (cons-stream rule
                              current-rule-stream)))))))
</p>

<p class="orig" lang="en">
The following procedures define how the data-base index is used.  A
pattern (an assertion or a rule conclusion) will be stored in the
table if it starts with a variable or a constant symbol.</p>

<p class="trans" lang="ja">
以下の手続きは、データベースの索引がどのように使われるのかを定義している。
パタン (言明または規則帰結部) は、変数または定数記号から始まる場合、表に格納されるだろう。
</p>

<p class="lisp">(define (indexable? pat)
  (or (constant-symbol? (car pat))
      (var? (car pat))))
</p>

<p class="orig" lang="en">The key under which a pattern is stored in the table is either <tt>?</tt> (if it starts with a variable) or the constant symbol with which
it starts.</p>

<p class="trans" lang="ja">
表内でそのキーのもとにパタンが格納される、というキーは、<tt>?</tt> (そのパタンが変数から始まる場合) か、または、そのパタンの始まりの定数記号である。
</p>


<p class="lisp">(define (index-key-of pat)
  (let ((key (car pat)))
    (if (var? key) '? key)))
</p>

<p class="orig" lang="en">The index will be used to retrieve items that might match a pattern if
the pattern starts with a constant symbol.</p>

<p class="trans" lang="ja">
パタンが定数記号から始まる場合に、そのパタンにマッチするかもしれない項目を取り出すために、索引が使われるだろう。
</p>

<p class="lisp">(define (use-index? pat)
  (constant-symbol? (car pat)))
</p>

<p class="orig" lang="en">
<a name="%_thm_4.70"></a>
<b>Exercise 4.70.</b>  What is the purpose of the <tt>let</tt> bindings in the procedures <tt>add-assertion!</tt> and <tt>add-rule!</tt> ?  What would be wrong with the
following implementation of <tt>add-assertion!</tt> ?
Hint: Recall the definition of the infinite stream of ones in
section <a href="24_sec3_5.html#%_sec_3.5.2">3.5.2</a>: <tt>(define ones (cons-stream 1 ones))</tt>.</p>

<p class="trans" lang="ja">
<b>練習問題4.70.</b> <tt>add-assertion!</tt> および <tt>add-rule!</tt> という手続きにおける <tt>let</tt> 束縛の目的は何だろうか?
<tt>add-assertion!</tt> の以下の実装の、何が不具合なのだろうか?
ヒント: <a href="24_sec3_5.html#%_sec_3.5.2">3.5.2</a>節の、1の無限ストリームの定義、すなわち、
<tt>(define ones (cons-stream 1 ones))</tt>
を、思い出せ。
</p>

<p class="lisp">(define (add-assertion! assertion)
  (store-assertion-in-index assertion)
  (set! THE-ASSERTIONS
        (cons-stream assertion THE-ASSERTIONS))
  'ok)
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_4.4.4.6"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_4.4.4.6">4.4.4.6  Stream Operations</a></h4>
<h4 class="trans" lang="ja">4.4.4.6 ストリーム演算</h4>

<p class="orig" lang="en">
<a name="%_idx_5384"></a>
The query system uses a few stream operations that were not presented
in chapter 3.</p>

<p class="trans" lang="ja">
クエリ・システムは、3章では提示されなかった少数のストリーム演算を用いる。
</p>

<p class="orig" lang="en">
<tt>Stream-append-delayed</tt> and <tt>interleave-delayed</tt>
are just like <tt>stream-append</tt> and <tt>interleave</tt>
(section <a href="24_sec3_5.html#%_sec_3.5.3">3.5.3</a>),
except that they take a delayed argument (like the <tt>integral</tt>
procedure in section <a href="24_sec3_5.html#%_sec_3.5.4">3.5.4</a>).
This postpones looping in some cases (see exercise <a href="#%_thm_4.71">4.71</a>).</p>

<p class="trans" lang="ja">
<tt>stream-append-delayed</tt> および <tt>interleave-delayed</tt> は、まさに <tt>stream-append</tt> および <tt>interleave</tt> (<a href="24_sec3_5.html#%_sec_3.5.3">3.5.3</a>節) に似ている——ただし、(<a href="24_sec3_5.html#%_sec_3.5.4">3.5.4</a>節の <tt>integral</tt> 手続きと同様に) 遅延させた引数をとる、という点は除いて。
これは、ある種の場合においてループを遅延させる (練習問題<a href="#%_thm_4.71">4.71</a>を参照)。
</p>

<p class="lisp"><a name="%_idx_5386"></a>(define (stream-append-delayed s1 delayed-s2)
  (if (stream-null? s1)
      (force delayed-s2)
      (cons-stream
       (stream-car s1)
       (stream-append-delayed (stream-cdr s1) delayed-s2))))
<a name="%_idx_5388"></a>(define (interleave-delayed s1 delayed-s2)
  (if (stream-null? s1)
      (force delayed-s2)
      (cons-stream
       (stream-car s1)
       (interleave-delayed (force delayed-s2)
                           (delay (stream-cdr s1))))))
</p>

<p class="orig" lang="en">
<tt>Stream-flatmap</tt>, which is used throughout the query evaluator to
map a procedure over a stream of frames and combine the resulting
streams of frames, is the stream analog of the <tt>flatmap</tt> procedure
introduced for ordinary lists in section <a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a>.
Unlike ordinary <tt>flatmap</tt>, however, we accumulate the streams with
an interleaving process, rather than simply appending them (see
exercises <a href="#%_thm_4.72">4.72</a> and  <a href="#%_thm_4.73">4.73</a>).</p>

<p class="trans" lang="ja">
<tt>stream-flatmap</tt> ——フレームのストリームに対して手続きをマップして、結果として生じる、フレームのストリーム同士を結合するために、クエリ評価器の全体にわたって使われる——は、<a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a>節で普通のリストに関して導入した <tt>flatmap</tt> 手続きの、ストリーム版の類似物である。
しかし、普通の <tt>flatmap</tt> とは違って、単純にストリーム同士を繋げるのではなく、間に挟まるプロセスとともにストリームを蓄積する (練習問題<a href="#%_thm_4.72">4.72</a>と練習問題<a href="#%_thm_4.73">4.73</a>を参照)。
</p>

<p class="lisp"><a name="%_idx_5390"></a>(define (stream-flatmap proc s)
  (flatten-stream (stream-map proc s)))
<a name="%_idx_5392"></a>(define (flatten-stream stream)
  (if (stream-null? stream)
      the-empty-stream
      (interleave-delayed
       (stream-car stream)
       (delay (flatten-stream (stream-cdr stream))))))
</p>

<p class="orig" lang="en">
The evaluator also uses the following simple procedure
to generate a stream consisting of a single element:</p>

<p class="trans" lang="ja">
評価器は、単一要素からなるストリームを生成するために、以下の単純な手続きも用いる。
</p>

<p class="lisp"><a name="%_idx_5394"></a>(define (singleton-stream x)
  (cons-stream x the-empty-stream))
</p>

<a name="%_sec_4.4.4.7"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_4.4.4.7">4.4.4.7  Query Syntax Procedures</a></h4>
<h4 class="trans" lang="ja">4.4.4.7 クエリの文法手続き</h4>

<p class="orig" lang="en">
<a name="%_idx_5396"></a>
<tt>Type</tt> and <tt>contents</tt>, used by <tt>qeval</tt>
(section <a href="#%_sec_4.4.4.2">4.4.4.2</a>), specify that a
special form is identified by the symbol in its <tt>car</tt>.
They are the same as the <tt>type-tag</tt> and <tt>contents</tt> procedures in
section <a href="17_sec2_4.html#%_sec_2.4.2">2.4.2</a>, except for the error message.</p>

<p class="trans" lang="ja">
<tt>tyoe</tt> と <tt>contents</tt> —— <tt>qeval</tt> により使われる (<a href="#%_sec_4.4.4.2">4.4.4.2</a>節) ——は、特殊形式はその <tt>car</tt> にある記号により識別されるのだ、ということを規定している。
これらは、エラー・メッセージ以外は、<a href="17_sec2_4.html#%_sec_2.4.2">2.4.2</a>節の <tt>type-tag</tt> 手続きおよび <tt>contents</tt> 手続きと同じである。
</p>

<p class="lisp">(define (type exp)
  (if (pair? exp)
      (car exp)
      (error &quot;Unknown expression TYPE&quot; exp)))
(define (contents exp)
  (if (pair? exp)
      (cdr exp)
      (error &quot;Unknown expression CONTENTS&quot; exp)))
</p>

<p class="orig" lang="en">
The following procedures, used by <tt>query-driver-loop</tt>
(in section <a href="#%_sec_4.4.4.1">4.4.4.1</a>), specify
that rules and assertions are added to the data base by expressions of
the form <tt>(assert! &lt;<em>rule-or-assertion</em>&gt;):</tt></p>

<p class="trans" lang="ja">
以下の手続き—— (<a href="#%_sec_4.4.4.1">4.4.4.1</a>節における) <tt>query-driver-loop</tt> により使われる——は、規則や言明が、
<tt>(assert! &lt;<em class="en">rule-or-assertion</em>&gt;)</tt>
という形の式によってデータベースに追加される、ということを規定している。
</p>

<p class="lisp">(define (assertion-to-be-added? exp)
  (eq? (type exp) 'assert!))
(define (add-assertion-body exp)
  (car (contents exp)))
</p>

<p class="orig" lang="en">
Here are the syntax definitions for the <tt>and</tt>,  <tt>or</tt>,  <tt>not</tt>, and <tt>lisp-value</tt> special forms
(section <a href="#%_sec_4.4.4.2">4.4.4.2</a>):</p>

<p class="trans" lang="ja">
<tt>and</tt> と <tt>or</tt> と <tt>not</tt> と <tt>lisp-value</tt> という特殊形式 (<a href="#%_sec_4.4.4.2">4.4.4.2</a>節) についての文法定義を、ここに示す。
</p>

<p class="lisp">(define (empty-conjunction? exps) (null? exps))
(define (first-conjunct exps) (car exps))
(define (rest-conjuncts exps) (cdr exps))
(define (empty-disjunction? exps) (null? exps))
(define (first-disjunct exps) (car exps))
(define (rest-disjuncts exps) (cdr exps))
(define (negated-query exps) (car exps))
(define (predicate exps) (car exps))
(define (args exps) (cdr exps))
</p>

<p class="orig" lang="en">
The following three procedures define the syntax of rules:</p>

<p class="trans" lang="ja">
以下の三つの手続きは、規則の文法を定義している。
</p>

<p class="lisp">(define (rule? statement)
  (tagged-list? statement 'rule))
(define (conclusion rule) (cadr rule))
(define (rule-body rule)
  (if (null? (cddr rule))
      '(always-true)
      (caddr rule)))
</p>

<p class="orig" lang="en">
<a name="%_idx_5398"></a><a name="%_idx_5400"></a><tt>Query-driver-loop</tt> (section <a href="#%_sec_4.4.4.1">4.4.4.1</a>)
calls <tt>query-syntax-process</tt> to
transform pattern variables in the expression, which have the form
<tt>?symbol</tt>, into the internal format <tt>(? symbol)</tt>.  That is to
say, a pattern such as <tt>(job ?x ?y)</tt> is actually represented
internally by the system as <tt>(job (? x) (? y))</tt>.  This increases
the efficiency of query processing, since it means that the system can
check to see if an expression is a pattern variable by checking
whether the <tt>car</tt> of the expression is the symbol <tt>?</tt>, rather
than having to extract characters from the symbol.  The syntax
transformation is accomplished by the following
procedure:<a name="call_footnote_Temp_702" href="#footnote_Temp_702"><sup><small>81</small></sup></a></p>

<p class="trans" lang="ja">
<tt>query-driver-loop</tt> (<a href="#%_sec_4.4.4.1">4.4.4.1</a>節) は、式の中のパタン変数—— <tt>?symbol</tt> という形である——を、<tt>(? symbol)</tt> という内部形式へと変形するために、<tt>query-syntax-process</tt> を呼び出す。
つまり、<tt>(job ?x ?y)</tt> のようなパタンは、実際のところ、内部的にはシステムにより <tt>(job (? x) (? y))</tt> のように表現されるわけだ。
これは、クエリ処理の効率性を向上させる。というのも、これは、記号から文字を抽出しなくてはならないのではなくて、むしろ、式の <tt>car</tt> が <tt>?</tt> という記号か否かを調べることで、その式がパタン変数か否かをシステムが調べられる、ということを意味するからである。
文法変形は以下の手続きにより達成される href="#footnote_Temp_702"><sup><small>81</small></sup></a>。
</p>

<p class="lisp">(define (query-syntax-process exp)
  (map-over-symbols expand-question-mark exp))
<a name="%_idx_5412"></a>(define (map-over-symbols proc exp)
  (cond ((pair? exp)
         (cons (map-over-symbols proc (car exp))
               (map-over-symbols proc (cdr exp))))
        ((symbol? exp) (proc exp))
        (else exp)))
(define (expand-question-mark symbol)
  (let ((chars (symbol-&gt;string symbol)))
    (if (string=? (substring chars 0 1) &quot;?&quot;)
        (list '?
              (string-&gt;symbol
               (substring chars 1 (string-length chars))))
        symbol)))
</p>

<p class="orig" lang="en">
Once the variables are transformed in this way, the variables in a
pattern are lists starting with <tt>?</tt>,
and the constant symbols (which need to be recognized for
data-base indexing, section <a href="#%_sec_4.4.4.5">4.4.4.5</a>) are just the symbols.</p>

<p class="trans" lang="ja">
一旦この方法で変数が変形されると、パタン内の変数は <tt>?</tt> で始まるリストであり、定数記号 (<a href="#%_sec_4.4.4.5">4.4.4.5</a>節のとおり、データベースの索引づけのために、認識されねばならない) はただの記号である。
</p>

<p class="lisp">(define (var? exp)
  (tagged-list? exp '?))
(define (constant-symbol? exp) (symbol? exp))
</p>

<p class="orig" lang="en">
Unique variables are constructed during rule application
(in section <a href="#%_sec_4.4.4.4">4.4.4.4</a>) by means of
the following procedures.  The unique identifier for a rule
application is a number, which is incremented each time a rule is
applied.</p>

<p class="trans" lang="ja">
(<a href="#%_sec_4.4.4.4">4.4.4.4</a>節での) 規則適用の間に、以下の手続きを用いて、一意な変数が構築される。
規則適用に対する一意な識別子は番号であり、これは、規則が適用されるたびにインクリメントされる。
</p>


<p class="lisp">(define rule-counter 0)
(define (new-rule-application-id)
  (set! rule-counter (+ 1 rule-counter))
  rule-counter)
(define (make-new-variable var rule-application-id)
  (cons '? (cons rule-application-id (cdr var))))
</p>

<p class="orig" lang="en">
When <tt>query-driver-loop</tt> instantiates the query to print the
answer, it converts any unbound pattern variables back to the right
form for printing, using</p>

<p class="trans" lang="ja">
<tt>query-driver-loop</tt> は、クエリをインスタンス化して答えを印字するとき、束縛されていないどのパタン変数をも、印字用の正しい形式へ戻すように、以下を用いて変換する。
</p>

<p class="lisp">(define (contract-question-mark variable)
  (string-&gt;symbol
   (string-append &quot;?&quot; 
     (if (number? (cadr variable))
         (string-append (symbol-&gt;string (caddr variable))
                        &quot;-&quot;
                        (number-&gt;string (cadr variable)))
         (symbol-&gt;string (cadr variable))))))
</p>

<a name="%_sec_4.4.4.8"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_4.4.4.8">4.4.4.8  Frames and Bindings</a></h4>
<h4 class="trans" lang="ja">4.4.4.8 フレームと束縛</h4>

<p class="orig" lang="en">
<a name="%_idx_5414"></a><a name="%_idx_5416"></a>Frames are represented as lists of bindings, which are
variable-value pairs:</p>

<p class="trans" lang="ja">
フレームは、束縛——変数と値の対——のリストとして、表現される。
</p>

<p class="lisp">(define (make-binding variable value)
  (cons variable value))
(define (binding-variable binding)
  (car binding))
(define (binding-value binding)
  (cdr binding))
(define (binding-in-frame variable frame)
  (assoc variable frame))
(define (extend variable value frame)
  (cons (make-binding variable value) frame))
</p>

<p class="extra" id="translating">**ここから</p>
<p class="orig" lang="en">
<a name="%_thm_4.71"></a>
<b>Exercise 4.71.</b>  Louis Reasoner wonders why the <tt>simple-query</tt> and <tt>disjoin</tt>
procedures (section <a href="#%_sec_4.4.4.2">4.4.4.2</a>) are implemented using
explicit <tt>delay</tt> operations, rather than being defined as follows:</p>

<p class="trans" lang="ja">
<b>練習問題4.71.</b> ルイス・リーズナは、
</p>

<p class="lisp">(define (simple-query query-pattern frame-stream)
  (stream-flatmap
   (lambda (frame)
     (stream-append (find-assertions query-pattern frame)
                    (apply-rules query-pattern frame)))
   frame-stream))
(define (disjoin disjuncts frame-stream)
  (if (empty-disjunction? disjuncts)
      the-empty-stream
      (interleave
       (qeval (first-disjunct disjuncts) frame-stream)
       (disjoin (rest-disjuncts disjuncts) frame-stream))))
</p>

<p class="orig" lang="en">Can you give examples of queries where these simpler definitions would
lead to undesirable behavior?
</p>

<p class="trans" lang="ja">
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_4.72"></a>
<b>Exercise 4.72.</b>  Why do <tt>disjoin</tt> and <tt>stream-flatmap</tt> interleave the
streams rather than simply append them?  Give examples that illustrate
why interleaving works better.  (Hint: Why did we use <tt>interleave</tt> in
section <a href="24_sec3_5.html#%_sec_3.5.3">3.5.3</a>?)
</p>

<p class="trans" lang="ja">
<b>練習問題4.72.</b> 
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_4.73"></a>
<b>Exercise 4.73.</b>  Why does <tt>flatten-stream</tt> use <tt>delay</tt> explicitly?
What would be wrong with defining it as follows:
</p>


<p class="trans" lang="ja">
<b>練習問題4.73.</b> 
</p>

<p class="lisp">(define (flatten-stream stream)
  (if (stream-null? stream)
      the-empty-stream
      (interleave
       (stream-car stream)
       (flatten-stream (stream-cdr stream)))))
</p>

<p class="exercise"><span class="ex_comment">
</span></p>


<p class="orig" lang="en">
<a name="%_thm_4.74"></a>
<b>Exercise 4.74.</b>  <a name="%_idx_5418"></a>Alyssa P. Hacker proposes to use a simpler version of <tt>stream-flatmap</tt>
in <tt>negate</tt>, <tt>lisp-value</tt>, and <tt>find-assertions</tt>.
She observes that the procedure that is mapped over the frame stream
in these cases always produces either the empty stream or a singleton
stream, so no interleaving is needed when combining these streams.</p>

<p class="trans" lang="ja">
<b>練習問題4.74.</b> 
</p>

<ol class="orig alph" start="1" lang="en">
<li>Fill in the missing expressions in Alyssa's program.</li>
</ol>

<ol class="trans alph" start="1" lang="ja">
<li></li>
</ol>

<p class="lisp">(define (simple-stream-flatmap proc s)
  (simple-flatten (stream-map proc s)))

(define (simple-flatten stream)
  (stream-map &lt;<em>??</em>&gt;
              (stream-filter &lt;<em>??</em>&gt; stream)))
</p>

<ol class="orig alph" start="2" lang="en">
<li>Does the query system's behavior change if we change it in this way?</li>
</ol>

<ol class="trans alph" start="2" lang="ja">
<li></li>
</ol>

<p class="exercise"><span class="ex_comment">
</span></p>


<p class="orig" lang="en">
<a name="%_thm_4.75"></a>
<b>Exercise 4.75.</b>  <a name="%_idx_5420"></a><a name="%_idx_5422"></a><a name="%_idx_5424"></a>Implement for the query language a new special form called <tt>unique</tt>.  <tt>Unique</tt> should succeed if there is precisely one item
in the data base satisfying a specified query.  For example,</p>

<p class="trans" lang="ja">
<b>練習問題4.75.</b> 
</p>

<p class="lisp">(unique (job ?x (computer wizard)))
</p>

<p class="orig" lang="en">should print the one-item stream</p>

<p class="trans" lang="ja">
</p>

<p class="lisp">(unique (job (Bitdiddle Ben) (computer wizard)))
</p>

<p class="orig" lang="en">since Ben is the only computer wizard, and</p>

<p class="trans" lang="ja">
</p>

<p class="lisp">(unique (job ?x (computer programmer)))
</p>

<p class="orig" lang="en">should print the empty stream, since there is more than one computer
programmer.  Moreover,</p>

<p class="trans" lang="ja">
</p>

<p class="lisp">(and (job ?x ?j) (unique (job ?anyone ?j)))
</p>

<p class="orig" lang="en">should list all the jobs that are filled by only one person, and the
people who fill them.</p>

<p class="trans" lang="ja">
</p>

<p class="orig" lang="en">
There are two parts to implementing <tt>unique</tt>.  The first is to
write a procedure that handles this special form, and the second is to make
<tt>qeval</tt> dispatch to that procedure.  The second part is trivial,
since <tt>qeval</tt> does its dispatching in a data-directed way.  If
your procedure is called <tt>uniquely-asserted</tt>, all you need to do
is</p>

<p class="trans" lang="ja">
</p>

<p class="lisp">(put 'unique 'qeval uniquely-asserted)
</p>

<p class="orig" lang="en">and <tt>qeval</tt> will dispatch to this procedure for every query whose
<tt>type</tt> (<tt>car</tt>) is the symbol <tt>unique</tt>.</p>

<p class="trans" lang="ja">
</p>

<p class="orig" lang="en">
The real problem is to write the procedure <tt>uniquely-asserted</tt>.
This should take as input the <tt>contents</tt> (<tt>cdr</tt>) of the <tt>unique</tt> query, together with a stream of frames.  For each frame in
the stream, it should use <tt>qeval</tt> to find the stream of all
extensions to the frame that satisfy the given query.  Any stream that
does not have exactly one item in it should be eliminated.  The
remaining streams should be passed back to be accumulated into one big
stream that is the result of the <tt>unique</tt> query.  This is similar
to the implementation of the <tt>not</tt> special form.</p>

<p class="trans" lang="ja">
</p>

<p class="orig" lang="en">
Test your implementation by forming a query that lists all people who
supervise precisely one person.
</p>

<p class="trans" lang="ja">
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_4.76"></a>
<b>Exercise 4.76.</b>  <a name="%_idx_5426"></a><a name="%_idx_5428"></a><a name="%_idx_5430"></a>Our implementation of <tt>and</tt> as a series combination of queries
(figure <a href="#%_fig_4.5">4.5</a>) is elegant, but it is inefficient because in
processing the second query of the <tt>and</tt> we must scan the data
base for each frame produced by the first query.  If the data base has
<em>N</em> elements, and a typical query produces a number of output frames
proportional to <em>N</em> (say <em>N</em>/<em>k</em>), then scanning the data base for each
frame produced by the first query will require <em>N</em><sup>2</sup>/<em>k</em> calls to the
pattern matcher.  Another approach would be to process the two clauses
of the <tt>and</tt> separately, then look for all pairs of output frames
that are compatible.  If each query produces <em>N</em>/<em>k</em> output frames, then
this means that we must perform <em>N</em><sup>2</sup>/<em>k</em><sup>2</sup> compatibility checks -- a
factor of <em>k</em> fewer than the number of matches required in our current
method.</p>

<p class="trans" lang="ja">
<b>練習問題4.76.</b> 
</p>

<p class="orig" lang="en">
Devise an implementation of <tt>and</tt> that uses this strategy.  You
must implement a procedure that takes two frames as inputs, checks
whether the bindings in the frames are compatible, and, if so,
produces a frame that merges the two sets of bindings.  This operation
is similar to unification.
</p>

<p class="trans" lang="ja">
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_4.77"></a>
<b>Exercise 4.77.</b>  <a name="%_idx_5432"></a><a name="%_idx_5434"></a><a name="%_idx_5436"></a><a name="%_idx_5438"></a><a name="%_idx_5440"></a>In section <a href="#%_sec_4.4.3">4.4.3</a> we saw that <tt>not</tt> and <tt>lisp-value</tt> can cause the query language to give ``wrong'' answers if
these filtering operations are applied to frames in which variables
are unbound.  Devise a way to fix this shortcoming.  One idea is to
perform the filtering in a ``delayed'' manner by appending to the
frame a ``promise'' to filter that is fulfilled only when enough
variables have been bound to make the operation possible.  We could
wait to perform filtering until all other operations have been
performed.  However, for efficiency's sake, we would like to perform
filtering as soon as possible so as to cut down on the number of
intermediate frames generated.
</p>

<p class="trans" lang="ja">
<b>練習問題4.77.</b> 
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_4.78"></a>
<b>Exercise 4.78.</b>  <a name="%_idx_5442"></a>Redesign the query language as a nondeterministic program to be
implemented using the evaluator of
section <a href="28_sec4_3.html#%_sec_4.3">4.3</a>, rather than as a stream
process.  In this approach, each query will produce a single answer
(rather than the stream of all answers) and the user can type <tt>try-again</tt> to see more answers.  You should find that much of the
mechanism we built in this section is subsumed by nondeterministic
search and backtracking.  You will probably also find, however, that
your new query language has subtle differences in behavior from the
one implemented here.  Can you find examples that illustrate this
difference?
</p>

<p class="trans" lang="ja">
<b>練習問題4.78.</b> 
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_4.79"></a>
<b>Exercise 4.79.</b>  <a name="%_idx_5444"></a><a name="%_idx_5446"></a>When we implemented the Lisp evaluator in section <a href="26_sec4_1.html#%_sec_4.1">4.1</a>,
we saw how to use local environments to avoid name conflicts between
the parameters of procedures.  For example, in evaluating</p>

<p class="trans" lang="ja">
<b>練習問題4.79.</b> 
</p>

<p class="lisp">(define (square x)
  (* x x))
(define (sum-of-squares x y)
  (+ (square x) (square y)))
(sum-of-squares 3 4)
</p>

<p class="orig" lang="en">there is no confusion between the <tt>x</tt> in <tt>square</tt> and the <tt>x</tt>
in <tt>sum-of-squares</tt>, because we evaluate the body of each
procedure in an environment that is specially constructed to contain
bindings for the local variables.  In the query system, we used a
different strategy to avoid name conflicts in applying rules.  Each
time we apply a rule we rename the variables with new names that are
guaranteed to be unique.  The analogous strategy for the Lisp
evaluator would be to do away with local environments and simply
rename the variables in the body of a procedure each time we apply the
procedure.</p>

<p class="trans" lang="ja">
</p>

<p class="orig" lang="en">
<a name="%_idx_5448"></a><a name="%_idx_5450"></a><a name="%_idx_5452"></a><a name="%_idx_5454"></a>Implement for the query language a rule-application method that uses
environments rather than renaming.  See if you can build on your
environment structure to create constructs in the query language for
dealing with large systems, such as the rule analog of
block-structured procedures.  Can you relate any of this to the
problem of making deductions in a context (e.g., ``If I supposed that
<em>P</em> were true, then I would be able to deduce <em>A</em> and <em>B</em>.'') as a
method of problem solving?  (This problem is open-ended.  A good
answer is probably worth a Ph.D.)</p>


<p class="trans" lang="ja">
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="footnotes"></a>
<hr>
<p class="orig" lang="en"><a name="footnote_Temp_645" href="#call_footnote_Temp_645"><sup><small>58</small></sup></a> Logic programming has grown out of a long
<a name="%_idx_5040"></a><a name="%_idx_5042"></a>history of research in automatic theorem proving.  Early
theorem-proving programs could accomplish very little, because they
exhaustively searched the space of possible proofs.  The major
breakthrough that made such a search plausible was the discovery in
the early 1960s of the <a name="%_idx_5044"></a><em>unification algorithm</em> and the <a name="%_idx_5046"></a><em>resolution principle</em> (Robinson 1965).  Resolution was used, for
example, by <a name="%_idx_5048"></a><a name="%_idx_5050"></a>Green and Raphael (1968) (see also Green 1969) as the
basis for a deductive question-answering system.  During most of this
period, researchers concentrated on algorithms that are guaranteed to
find a proof if one exists.  Such algorithms were difficult to control
and to direct toward a proof.  <a name="%_idx_5052"></a>Hewitt (1969) recognized the
possibility of merging the control structure of a programming language
with the operations of a logic-manipulation system, leading to the
work in automatic search mentioned in section <a href="28_sec4_3.html#%_sec_4.3.1">4.3.1</a>
(footnote <a href="28_sec4_3.html#footnote_Temp_603">47</a>).  At the same time that this was being done,
<a name="%_idx_5054"></a>Colmerauer, in Marseille, was developing rule-based systems for
manipulating natural language (see Colmerauer et al. 1973).  He
invented a programming language called <a name="%_idx_5056"></a>Prolog for representing those
rules.  <a name="%_idx_5058"></a>Kowalski (1973; 1979), in Edinburgh, recognized that execution
of a Prolog program could be interpreted as proving theorems (using a
proof technique called linear <a name="%_idx_5060"></a>Horn-clause resolution).  The merging of
the last two strands led to the logic-programming movement.  Thus, in
assigning credit for the development of logic programming, the French
can point to Prolog's genesis at the <a name="%_idx_5062"></a>University of Marseille, while
the British can highlight the work at the <a name="%_idx_5064"></a>University of Edinburgh.
According to people at <a name="%_idx_5066"></a>MIT, logic programming was developed by these
groups in an attempt to figure out what Hewitt was talking about in
his brilliant but impenetrable Ph.D. thesis.  For a history of logic
<a name="%_idx_5068"></a>programming, see Robinson 1983.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_645"><sup><small>58</small></sup></a> 
論理プログラミングは、自動定理証明についての研究の長い歴史の中から、成長してきた。
初期の定理証明プログラムは、可能な証明の空間を網羅的に探索したので、ほんのわずかのことしか達成できなかった。
そうした探索を見込みのあるものにした主要な<ruby><rb>大躍進</rb><rp> (</rp><rt>ブレークスルー</rt><rp>) </rp></ruby>は、1960年代初期における、<em>ユニフィケーション・アルゴリズム</em>と<em>導出原理</em> (Robinson 1965) の発見であった。
たとえば、Green and Raphael (1968) (Green 1969 も参照) によって、導出は、演繹的な質問回答システムの基礎として使われた。
この期間のほとんどにおいて、研究者たちは、もし一つでも証明が存在していれば証明を見つけることが保証されたアルゴリズムに専念した。
そうしたアルゴリズムは、制御しづらかったし、証明へと向かわせづらかった。
Hewitt (1969) は、プログラミング言語の制御構造を論理操作システムの演算と合わせる、という可能性を認識し、それは、<a href="28_sec4_3.html#%_sec_4.3.1">4.3.1</a>節で言及した自動探索についての業績につながった (脚注<a href="28_sec4_3.html#footnote_Temp_603">47</a>)。
これがなされたのと同時に、マルセイユで Colmerauer が、自然言語を操作するための、<ruby><rb>規則に基づく</rb><rp> (</rp><rt>ルール・ベースの</rt><rp>) </rp></ruby>システムを開発していた (Colmerauer et al. 1973 を参照)。
彼は、それらの規則を表現するための、Prolog と呼ばれるプログラミング言語を発明した。
エディンバラでは、Kowalski (1973; 1979) が、Prolog プログラムの実行は、定義を証明しているものなのだと解釈できる、ということを認識した (線形ホーン節導出と呼ばれる証明技術を使った)。
最後の二つの要素を合わせることで、論理プログラミングの進展へとつながった。
このようにして、論理プログラミングの発展に対する功績を割り当ててゆく中では、イギリス人がエディンバラ大学での業績を強調できるのに対し、フランス人はマルセイユ大学における Prolog の創世記を指し示すことができる。
MIT の人たちによれば、論理プログラミングは、ヒューウィットが輝かしくも理解不能な彼の博士論文で何について語っていたのかを闡明しようとして、これらのグループによって開発されたのだ。
論理プログラミングの歴史については、Robinson 1983 を参照のこと。
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_646" href="#call_footnote_Temp_646"><sup><small>59</small></sup></a> To
see the correspondence between the rules and the procedure, let <tt>x</tt> in the procedure (where <tt>x</tt> is nonempty) correspond to <tt>(cons u v)</tt> in the rule.  Then <tt>z</tt> in the rule corresponds to the
<tt>append</tt> of <tt>(cdr x)</tt> and <tt>y</tt>.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_646"><sup><small>59</small></sup></a> 
規則と手続きとの間の対応関係を見るためには、手続き中の <tt>x</tt> (ただし <tt>x</tt> は非空) が規則中の <tt>(cons u v)</tt> に対応するものとせよ。
すると、規則中の <tt>z</tt> は、<tt>(cdr x)</tt> と <tt>y</tt> の <tt>append</tt> に対応する。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_647" href="#call_footnote_Temp_647"><sup><small>60</small></sup></a> This certainly does not
relieve the user of the entire problem of how to compute the answer.
There are many different mathematically equivalent sets of rules for
formulating the <tt>append</tt> relation, only some of which can be
turned into effective devices for computing in any direction.  In
addition, sometimes ``what is'' information gives no clue ``how to''
compute an answer.  For example, consider the problem of computing the
<em>y</em> such that <em>y</em><sup>2</sup>  =  <em>x</em>.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_647"><sup><small>60</small></sup></a>
なるほど、これは、答えをどのように計算するのかという問題全体から、ユーザを解放してくれる、というわけではない。
<tt>append</tt> 関係を定式化するための、数学的には等価な多くの異なる規則集合が存在するが、<!--それらのうちのいくつかだけしか、いずれかの方向に計算するための有効な道具だとは判明し得ないのだ。-->それらのうちの一部しか、どの方向であれ、計算するための有効な道具にはなり得ないのだ。
さらに、「何であるか」という情報は、ときとして、「どうやって」答えを計算するのか、について何の手がかりも与えてくれない。
たとえば、
<span class="math"><em class="en">y</em><sup>2</sup>  =  <em class="en">x</em></span>
であるような <em class="en">y</em> を計算する問題を考えたまえ。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_648" href="#call_footnote_Temp_648"><sup><small>61</small></sup></a> Interest in logic programming peaked
<a name="%_idx_5080"></a><a name="%_idx_5082"></a><a name="%_idx_5084"></a>during the early 80s when the Japanese government began an ambitious
project aimed at building superfast computers optimized to run logic
programming languages.  The speed of such computers was to be measured
in LIPS (Logical Inferences Per Second) rather than the usual FLOPS
(FLoating-point Operations Per Second).  Although the project
succeeded in developing hardware and software as originally planned,
the international computer industry moved in a different direction.
See <a name="%_idx_5086"></a><a name="%_idx_5088"></a>Feigenbaum and Shrobe 1993 for an overview evaluation of the
Japanese project.  The logic programming community has also moved on
to consider relational programming based on techniques other than
simple pattern matching, such as the ability to deal with numerical
constraints such as the ones illustrated in the constraint-propagation
system of section <a href="22_sec3_3.html#%_sec_3.3.5">3.3.5</a>.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_648"><sup><small>61</small></sup></a>
論理プログラミング言語を実行するために最適化された超高速コンピュータを構築することを目標にした野心的なプロジェクトを日本政府が開始した1980年代の始めに、論理プログラミングへの関心は最高潮に達した。
そうしたコンピュータの速度は、FLOPS (1秒あたりの浮動小数点数演算回数) ではなく、むしろ、LIPS (1秒あたりの論理推論回数) で計測されるべきであった。
プロジェクトは、当初計画されたようなハードウェアとソフトウェアを開発することに成功したのだが、国際的なコンピュータ産業は、別の方向へと動いた。
日本のプロジェクトの概要的評価については、Feigenbaum and Shrobe 1993 を参照のこと。
論理プログラミング界も、<a href="22_sec3_3.html#%_sec_3.3.5">3.3.5</a>節の制約伝播システムにおいて例示したもののような数量的制約を扱う能力など、単純なパタン・マッチングではない技法に基づく<ruby><rb>関係</rb><rp> (</rp><rt>リレーショナル</rt><rp>) </rp></ruby>プログラミングを考慮するように、進歩してきた。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_651" href="#call_footnote_Temp_651"><sup><small>62</small></sup></a> This uses the dotted-tail notation introduced in
exercise <a href="15_sec2_2.html#%_thm_2.20">2.20</a>.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_651"><sup><small>62</small></sup></a>
これは、練習問題<a href="15_sec2_2.html#%_thm_2.20">2.20</a>で導入した、末尾にドットがついた記法を使っている。
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_654" href="#call_footnote_Temp_654"><sup><small>63</small></sup></a> Actually, this description of <tt>not</tt> is valid only for simple cases.  The real behavior of <tt>not</tt>
is more complex.  We will examine <tt>not</tt>'s peculiarities in
sections <a href="#%_sec_4.4.2">4.4.2</a> and <a href="#%_sec_4.4.3">4.4.3</a>.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_654"><sup><small>63</small></sup></a>
実際は、<tt>not</tt> についてのこの記述は、単純な場合についてのみ妥当である。
<tt>not</tt> の現実の振る舞いは、もっと複雑だ。
<tt>not</tt> の妙な性質については、<a href="#%_sec_4.4.2">4.4.2</a>節と<a href="#%_sec_4.4.3">4.4.3</a>節で吟味しよう。
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_655" href="#call_footnote_Temp_655"><sup><small>64</small></sup></a> <tt>Lisp-value</tt> should be used only to perform an operation not
<a name="%_idx_5134"></a>provided in the query language.  In particular, it should not
be used to test equality (since that is what the matching in the
query language is designed to do) or inequality (since that can
be done with the <tt>same</tt> rule shown below).</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_655"><sup><small>64</small></sup></a>
<tt>lisp-value</tt> は、クエリ言語では提供されていない演算を実行するためにだけ使われるべきである。
特に、等価性を検査するためにこれを使うべきではないし (なぜなら、それこそが、クエリ言語におけるマッチングがそれを行うべく設計されている対象の事柄だからである)、あるいは、不等価性を検査するためにも使うべきではない (なぜなら、それは、後に示す <tt>same</tt> 規則を使って行われるからである)。
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_658" href="#call_footnote_Temp_658"><sup><small>65</small></sup></a> Notice that we do not need <tt>same</tt> in order to make two things be
the same: We just use the same pattern variable for each -- in effect,
we have one thing instead of two things in the first place.  For
example, see <tt>?town</tt> in the <tt>lives-near</tt> rule and <tt>?middle-manager</tt> in the <tt>wheel</tt> rule below.
<tt>Same</tt> is useful when we want to force two things to be
different, such as <tt>?person-1</tt> and <tt>?person-2</tt> in the <tt>lives-near</tt> rule.  Although using the same pattern variable in two
parts of a query forces the same value to appear in both places, using
different pattern variables does not force different values to appear.
(The values assigned to different pattern variables may be the same or
different.)</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_658"><sup><small>65</small></sup></a>
二つのものを同一とするためには、<tt>same</tt> を必要とはしないのだ、ということに注意せよ。それぞれについて同じパタン変数を使いさえすればよいのだ。実際、そもそもは、二つのものではなく、一つのものがある訳だ。
たとえば、<tt>lives-near</tt> の規則における <tt>?town</tt> や、以下の <tt>wheel</tt> の規則における <tt>?middle-manager</tt> を参照せよ。
<tt>same</tt> は、<tt>lives-near</tt> の規則における <tt>?person-1</tt> と <tt>?person-2</tt> のように、二つのものを強制的に異なるものとしたい場合に、有用である。
クエリの二つの部分で同じパタン変数を使うことは、同じ値が両方の場所に現れることを強いるが、異なるパタン変数を使うことは、異なる値が現れることを強いる訳ではない (異なるパタン変数に<ruby><rb>代入された</rb><rp> (</rp><rt>わりあてられた</rt><rp>) </rp></ruby>値は、同じかもしれないし、あるいは、違うかもしれないのだ)。
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_659" href="#call_footnote_Temp_659"><sup><small>66</small></sup></a> We will also allow rules without bodies, as in <tt><a name="%_idx_5146"></a>same</tt>, and we will interpret such a rule to mean that the rule
conclusion is satisfied by any values of the variables.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_659"><sup><small>66</small></sup></a>
<tt>same</tt> に見られるような、本体のない規則も許可しよう。そして、そういった規則を、変数の任意の値によって当該規則の帰結が満たされることを意味するものとして、解釈しよう。
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_670" href="#call_footnote_Temp_670"><sup><small>67</small></sup></a> Because matching is generally very expensive, we would
<a name="%_idx_5188"></a>like to avoid applying the full matcher to every element of the data
base.  This is usually arranged by breaking up the process into a
fast, coarse match and the final match.  The coarse match filters the
data base to produce a small set of candidates for the final match.
With care, we can arrange our data base so that some of the work of
coarse matching can be done when the data base is constructed rather
<a name="%_idx_5190"></a><a name="%_idx_5192"></a>then when we want to select the candidates.  This is called <em>indexing</em> the data base.  There is a vast technology built around
data-base-indexing schemes.  Our implementation, described in
section <a href="#%_sec_4.4.4">4.4.4</a>, contains a
simple-minded form of such an optimization.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_670"><sup><small>67</small></sup></a>
マッチングは一般的にはとても高くつくので、データベースのどの要素に対しても完全なマッチャを適用することは避けたい。
これ<span class="note"> (完全なマッチャの適用を避けること) </span>の手筈は、普通、プロセスを、高速で粗いマッチと最終的なマッチへと分解することにより、整えられる。
粗いマッチは、データベースをフィルタにかけて、最終的なマッチに対する候補の小さな集合を作り出す。
注意すれば、私たちは、候補を選択したいときではなくデータベースが構築されるときに粗いマッチングの作業のうちのいくらかを行えるように、自分のデータベースを整えられる。
これは、データベースの<em><ruby><rb>索引づけ</rb><rp> (</rp><rt>インデクシング</rt><rp>) </rp></ruby></em>と呼ばれる。
データベースのインデクシング方式をめぐって構築された、おびただしい技術がある。
私たちの実装は、<a href="#%_sec_4.4.4">4.4.4</a>節で説明するが、そうした最適化の単純な形を含んでいる。
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_672" href="#call_footnote_Temp_672"><sup><small>68</small></sup></a> But this kind of exponential explosion is not common in <tt>and</tt>
queries because the added conditions tend to reduce rather than expand
the number of frames produced.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_672"><sup><small>68</small></sup></a>
しかし、この種の指数関数的爆発は、<tt>and</tt> クエリでよくあることではない。なぜなら、追加される条件は、作り出されるフレームの数を増やすより、むしろ減らす傾向があるためである。
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_673" href="#call_footnote_Temp_673"><sup><small>69</small></sup></a> There is a large literature on data-base-management
systems that is concerned with how to handle complex queries
efficiently.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_673"><sup><small>69</small></sup></a>
複雑なクエリを効率よく扱う方法に関する、データベース管理システムについての大量の文献がある。
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_674" href="#call_footnote_Temp_674"><sup><small>70</small></sup></a> There is a subtle difference between this filter
implementation of <tt>not</tt> and the usual meaning of <tt>not</tt> in
mathematical logic.  See section <a href="#%_sec_4.4.3">4.4.3</a>.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_674"><sup><small>70</small></sup></a>
<tt>not</tt> についての、このフィルタ式の実装と、数学的論理における <tt>not</tt> の通常の意味との間には、微妙な差異がある。
<a href="#%_sec_4.4.3">4.4.3</a>節を参照のこと。
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_676" href="#call_footnote_Temp_676"><sup><small>71</small></sup></a> In one-sided pattern matching, all the equations that
contain pattern variables are explicit and already solved for the
unknown (the pattern variable).</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_676"><sup><small>71</small></sup></a>
一方的なパタン・マッチングにおいては、パタン変数を含むすべての方程式は、陽であり<span class="note"> (陽関数の「陽」)</span>、かつ、未知数 (パタン変数) について既に解かれている。
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_677" href="#call_footnote_Temp_677"><sup><small>72</small></sup></a> Another way to think of unification is that it generates the most
general pattern that is a specialization of the two input patterns.
That is, the unification of <tt>(?x a)</tt> and <tt>((b ?y) ?z)</tt> is <tt>((b ?y) a)</tt>, and the unification of <tt>(?x a ?y)</tt> and <tt>(?y ?z
a)</tt>, discussed above, is <tt>(a a a)</tt>.
For our implementation, it is more convenient to think of the result
of unification as a frame rather than a pattern.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_677"><sup><small>72</small></sup></a>
ユニフィケーションのことを考える別の方法は、二つの入力パタンの特殊化であるような最も一般的なパタンをユニフィケーションが生成する、というものである。
つまり、<tt>(?x a)</tt> と <tt>((b ?y) ?z)</tt> のユニフィケーションは <tt>((b ?y) a)</tt> であり、<tt>(?x a ?y)</tt> と <tt>(?y ?z a)</tt> のユニフィケーション——上記で議論したもの——は <tt>(a a a)</tt> である。
私たちの実装にとっては、ユニフィケーションの結果を、パタンでなくフレームと見なすことが、より便利である。
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_680" href="#call_footnote_Temp_680"><sup><small>73</small></sup></a> Since unification is a
<a name="%_idx_5222"></a><a name="%_idx_5224"></a>generalization of matching, we could simplify the system by using the
unifier to produce both streams.  Treating the easy case with the
simple matcher, however, illustrates how matching (as opposed to
full-blown unification) can be useful in its own right.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_680"><sup><small>73</small></sup></a>
ユニフィケーションはマッチングの一般化なので、私たちは、双方のストリームを作り出すのにユニファイアを使うことによって、システムを簡素化できただろう。
しかし、単純なマッチャで簡単な場合を取り扱うことで、(本格的ユニフィケーションではなく) マッチングがそれ自体の能力でどのように有益たり得るのか、ということが例示されるのだ。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_682" href="#call_footnote_Temp_682"><sup><small>74</small></sup></a> The reason we use streams (rather than lists) of frames is that the
<a name="%_idx_5236"></a><a name="%_idx_5238"></a>recursive application of rules can generate
infinite numbers of values that satisfy a query.  The delayed
evaluation embodied in streams is crucial here: The system will print
responses one by one as they are generated, regardless of whether
there are a finite or infinite number of responses.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_682"><sup><small>74</small></sup></a>
フレームの (リストでなく) ストリームを使う理由は、規則の再帰的適用が、クエリを満たす無限個の値を生成する可能性があるためである。
ストリームにおいて具現化されている遅延評価が、ここでは必要不可欠なのだ。
有限個の応答があるのか、それとも無限個の応答があるのか、ということに関係なく、システムは、応答が生成されるのにつれて、応答を一つずつ印字するだろう。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_683" href="#call_footnote_Temp_683"><sup><small>75</small></sup></a> That a particular method of inference is
legitimate is not a trivial assertion.  One must prove that if one
starts with true premises, only true conclusions can be derived.  The
method of inference represented by rule applications is <a name="%_idx_5250"></a><em>modus
ponens</em>, the familiar method of inference that says that if <em>A</em> is
true and <em>A implies B</em> is true, then we may conclude that <em>B</em>
is true.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_683"><sup><small>75</small></sup></a>
推論の特定の手法が正当である、ということは、瑣末な主張ではない。
人は、もし真の前提から開始するなら真の結論のみを導出できる、ということを証明せねばならない。
規則適用により表される推論の手法は、<em class="en">modus ponens</em> ——もし <em class="en">A</em> が真であり、かつ、<em class="en">B</em> が真であることを <em class="en">A</em> が<em>含意する</em>ならば、<em class="en">B</em> が真だと結論づけてよい、と述べる、おなじみの推論手法——である。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_684" href="#call_footnote_Temp_684"><sup><small>76</small></sup></a> We must qualify this statement by
agreeing that, in speaking of the ``inference'' accomplished by a
logic program, we assume that the computation terminates.
Unfortunately, even this qualified statement is false for our
implementation of the query language (and also false for programs in
Prolog and most other current logic programming languages) because of
our use of <tt>not</tt> and <tt>lisp-value</tt>.  As we will describe below,
the <tt>not</tt> implemented in the query language is not always
consistent with the <tt>not</tt> of mathematical logic, and <tt>lisp-value</tt> introduces additional complications.  We could implement a
language consistent with mathematical logic by simply removing <tt>not</tt> and <tt>lisp-value</tt> from the language and agreeing to write
programs using only simple queries, <tt>and</tt>, and <tt>or</tt>.  However,
this would greatly restrict the expressive power of the language.  One
of the major concerns of research in logic programming is to find ways
to achieve more consistency with mathematical logic without unduly
sacrificing expressive power.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_684"><sup><small>76</small></sup></a>
私たちは、この陳述を和らげねばならない——論理プログラムにより達成される「推論」に言及する際に、私たちは、計算が終了すると想定している、と同意することによって。
あいにく、この和らげた陳述でさえも、私たちが <tt>not</tt> と <tt>lisp-value</tt> を使うせいで、クエリ言語の私たちによる実装にとっては、偽である (そしてまた、Prolog や、他のほとんどの現在の論理プログラミング言語で書かれたプログラムにとっても、偽である)。
この後に述べるとおり、クエリ言語で実装される <tt>not</tt> は、常に数学的論理の <tt>not</tt> と整合性があるわけではないし、<tt>lisp-value</tt> はさらなるややこしさをもたらす。
単に、言語から <tt>not</tt> と <tt>lisp-value</tt> を取り除くとともに、単純クエリと <tt>and</tt> と <tt>or</tt> のみを使ってプログラムを書くことに同意することによって、私たちは、数学的論理と整合性のある言語を実装できたであろう。
しかし、これは言語の表現力を非常に制限してしまう。
論理プログラミングにおける研究の主要な関心事のうちの一つは、過度に表現力を犠牲にすることなく、数学的論理とのさらなる整合性を達成する方法を、見つけ出すことである。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_686" href="#call_footnote_Temp_686"><sup><small>77</small></sup></a> This is not a problem of the logic but one of the
procedural interpretation of the logic provided by our interpreter.
We could write an interpreter that would not fall into a loop here.
For example, we could enumerate all the proofs derivable from our
assertions and our rules in a breadth-first rather than a depth-first
order.  However, such a system makes it more difficult to take
advantage of the order of deductions in our programs.  One attempt to
build sophisticated control into such a program is described in
<a name="%_idx_5264"></a>deKleer et al. 1977.  Another technique, which does not lead to such
serious control problems, is to put in special knowledge, such as
detectors for particular kinds of loops
(exercise <a href="#%_thm_4.67">4.67</a>).  However, there can be no
general scheme for reliably preventing a system from going down
infinite paths in performing deductions.  Imagine a diabolical rule of
the form ``To show <em>P</em>(<em>x</em>) is true, show that <em>P</em>(<em>f</em>(<em>x</em>)) is true,'' for
some suitably chosen function <em>f</em>.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_686"><sup><small>77</small></sup></a>
これは論理の問題ではなく、私たちのインタプリタにより提供される、論理の手続き的解釈の問題である。
ここではループに陥らないだろう、というインタプリタを、私たちは書くことができるだろう。
例えば、私たちは、自分の言明と規則から導出可能なすべての証明を、深さ優先順ではなく幅優先順で、数え上げることができるだろう。
しかし、そうしたシステムは、私たちのプログラムでの演繹の順序を利用することを、より困難にしてしまう。
そうしたプログラムの中に洗練された制御を組み込むための一つの試みは、deKleer et al. 1977 に説明されている。
もう一つ別の技法は、そういう深刻な制御の問題を引き起こさないものなのだが、特定の種類のループに対する検出器のような、特殊な知識を提示することである (練習問題<a href="#%_thm_4.67">4.67</a>)。
しかし、システムが演繹を実行する際に無限の経路を降りてゆくのを、期待どおりに防ぐための一般的な体系など、あり得ない。
ある適切に選ばれた <em class="en">f</em> という関数について、
「<em class="en">P</em>(<em class="en">x</em>) が真だと示すためには、<em class="en">P</em>(<em class="en">f</em>(<em class="en">x</em>)) が真だと示せ」
という形式の、邪悪な規則を想像してみたまえ。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_688" href="#call_footnote_Temp_688"><sup><small>78</small></sup></a> Consider the query <tt>(not (baseball-fan (Bitdiddle Ben)))</tt>.  The system finds that <tt>(baseball-fan (Bitdiddle Ben))</tt> is not in the data base, so the empty
frame does not satisfy the pattern and is not filtered out of the
initial stream of frames.  The result of the query is thus the empty
frame, which is used to instantiate the input query to produce <tt>(not (baseball-fan (Bitdiddle Ben)))</tt>.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_688"><sup><small>78</small></sup></a>
<tt>(not (baseball-fan (Bitdiddle Ben)))</tt> というクエリを考えよう。
システムは、<tt>(baseball-fan (Bitdiddle Ben))</tt> がデータベース内に存在しないと知り、よって、空フレームは、このパタンを満たさず、フレームの初期ストリームから除外されない。
したがって、クエリの結果は空フレームであり、この空フレームは、入力クエリをインスタンス化して <tt>(not (baseball-fan (Bitdiddle Ben)))</tt> を作り出すのに使われる。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_689" href="#call_footnote_Temp_689"><sup><small>79</small></sup></a> A discussion and justification of this
<a name="%_idx_5274"></a>treatment of <tt>not</tt> can be found in the article by Clark (1978).</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_689"><sup><small>79</small></sup></a>
<tt>not</tt> のこうした取り扱いについての議論と正当化は、Clark (1978) による論文に見いだすことができる。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_700" href="#call_footnote_Temp_700"><sup><small>80</small></sup></a> In general, unifying <tt>?y</tt> with an expression involving
<a name="%_idx_5366"></a><tt>?y</tt> would require our being able to find a fixed point of the
equation <tt>?y</tt>  =  &lt;<em>expression involving <tt>?y</tt></em>&gt;.  It is
sometimes possible to syntactically form an expression that appears to
be the solution.  For example, <tt>?y</tt>  =  <tt>(f ?y)</tt> seems to have
the fixed point <tt>(f (f (f <tt>...</tt> )))</tt>, which we can produce by
beginning with the expression <tt>(f ?y)</tt> and repeatedly substituting
<tt>(f ?y)</tt> for <tt>?y</tt>.  Unfortunately, not every such equation has
a meaningful fixed point.  The issues that arise here are similar to
the issues of manipulating <a name="%_idx_5368"></a>infinite series in mathematics.  For
example, we know that 2 is the solution to the equation <em>y</em>  =  1  +  <em>y</em>/2.
Beginning with the expression 1  +  <em>y</em>/2 and repeatedly substituting 1
 +  <em>y</em>/2 for <em>y</em> gives
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_700"><sup><small>80</small></sup></a>
</p>


<figure><img src="ch4-Z-G-7.gif" border="0"></figure>

<p class="orig" lang="en">which leads to</p>

<p class="trans" lang="ja">
</p>

<figure><img src="ch4-Z-G-8.gif" border="0"></figure>

<p class="orig" lang="en">However, if we try the same manipulation beginning with the
observation that  - 1 is the solution to the equation <em>y</em>  =  1  +  2<em>y</em>, we
obtain
</p>

<p class="trans" lang="ja">
</p>

<figure><img src="ch4-Z-G-9.gif" border="0"></figure>


<p class="orig" lang="en">which leads to </p>


<p class="trans" lang="ja">
</p>

<figure><img src="ch4-Z-G-10.gif" border="0"></figure>

<p class="orig" lang="en">Although the formal manipulations used in deriving these two equations
are identical, the first result is a valid assertion about infinite
series but the second is not.  Similarly, for our unification results,
reasoning with an arbitrary syntactically constructed expression may
lead to errors. </p>


<p class="trans" lang="ja">
</p>

<p class="orig" lang="en"><a name="footnote_Temp_702" href="#call_footnote_Temp_702"><sup><small>81</small></sup></a> Most Lisp systems give the user the ability to
modify the ordinary <tt>read</tt> procedure to perform such
transformations by defining <a name="%_idx_5402"></a><a name="%_idx_5404"></a><a name="%_idx_5406"></a><a name="%_idx_5408"></a><em>reader macro characters</em>.  Quoted
expressions are already handled in this way: The reader automatically
translates <tt>'expression</tt> into <tt>(quote expression)</tt> before the
evaluator sees it.  We could arrange for <tt>?expression</tt> to be
transformed into <tt>(? expression)</tt> in the same way; however, for
the sake of clarity we have included the transformation procedure here
explicitly.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_702"><sup><small>81</small></sup></a>
</p>

<p class="orig" lang="en">
<a name="%_idx_5410"></a><tt>Expand-question-mark</tt> and <tt>contract-question-mark</tt> use
several procedures with <tt>string</tt> in their names.
These are Scheme primitives.</p>

<p class="trans" lang="ja">
</p>

</div>
</body>
</html>
