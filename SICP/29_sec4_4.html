<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="sicp.css" type="text/css">
<base target="_top">
<title>SICPç§è¨³: 4.4 è«–ç†ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°</title>
<link rel="canonical" href="https://piyo-ko.github.io/SICP/29_sec4_4.html" />
</head>
<body>

<div class="idx-bar">
<nav>
<a href="https://twitter.com/share" class="twitter-share-button" data-lang="ja">ãƒ„ã‚¤ãƒ¼ãƒˆ</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
<span class="status">ç¿»è¨³ä¸­</span>
[
<a href="00_cover.html">å…ˆé ­ã¸</a> |
<a href="28_sec4_3.html">å‰ã¸</a> |
<a href="30_chap5.html">æ¬¡ã¸</a> |
<a href="04_toc.html#%_toc_start">ç›®æ¬¡</a> |
<a href="38_index.html#%_index_start">ç´¢å¼•</a>
] [<a href="99_about.html">ã“ã®å¯¾è¨³ç‰ˆã«ã¤ã„ã¦</a> | <a href="../index.html">ãƒ›ãƒ¼ãƒ </a>]
[
Â§<a href="#%_sec_4.4">4.4</a>
Â§<a href="#%_sec_4.4.1">4.4.1</a>
ğŸ“š<a href="#%_sec_Temp_649">&hellip;</a>
ğŸ“š<a href="#%_sec_Temp_650">&hellip;</a>
ğŸ“<a href="#%_thm_4.55">4.55</a>
ğŸ“š<a href="#%_sec_Temp_653">&hellip;</a>
ğŸ“<a href="#%_thm_4.56">4.56</a>
ğŸ“š<a href="#%_sec_Temp_657">&hellip;</a>
ğŸ“<a href="#%_thm_4.57">4.57</a>
ğŸ“<a href="#%_thm_4.58">4.58</a>
ğŸ“<a href="#%_thm_4.59">4.59</a>
ğŸ“<a href="#%_thm_4.60">4.60</a>
ğŸ“š<a href="#%_sec_Temp_664">&hellip;</a>
ğŸ“<a href="#%_thm_4.61">4.61</a>
ğŸ“<a href="#%_thm_4.62">4.62</a>
ğŸ“<a href="#%_thm_4.63">4.63</a>
Â§<a href="#%_sec_4.4.2">4.4.2</a>
ğŸ“š<a href="#%_sec_Temp_668">&hellip;</a>
ğŸ“š<a href="#%_sec_Temp_669">&hellip;</a>
ğŸ¨<a href="#%_fig_4.4">4.4</a>
ğŸ“š<a href="#%_sec_Temp_671">&hellip;</a>
ğŸ¨<a href="#%_fig_4.5">4.5</a>
ğŸ¨<a href="#%_fig_4.6">4.6</a>
ğŸ“š<a href="#%_sec_Temp_675">&hellip;</a>
ğŸ“š<a href="#%_sec_Temp_678">&hellip;</a>
ğŸ“š<a href="#%_sec_Temp_679">&hellip;</a>
ğŸ“š<a href="#%_sec_Temp_681">&hellip;</a>
Â§<a href="#%_sec_4.4.3">4.4.3</a>
ğŸ“š<a href="#%_sec_Temp_685">&hellip;</a>
ğŸ“š<a href="#%_sec_Temp_687">&hellip;</a>
ğŸ“<a href="#%_thm_4.64">4.64</a>
ğŸ“<a href="#%_thm_4.65">4.65</a>
ğŸ“<a href="#%_thm_4.66">4.66</a>
ğŸ“<a href="#%_thm_4.67">4.67</a>
ğŸ“<a href="#%_thm_4.68">4.68</a>
ğŸ“<a href="#%_thm_4.69">4.69</a>
Â§<a href="#%_sec_4.4.4">4.4.4</a>
Â§<a href="#%_sec_4.4.4.1">4.4.4.1</a>
Â§<a href="#%_sec_4.4.4.2">4.4.4.2</a>
ğŸ“š<a href="#%_sec_Temp_696">&hellip;</a>
ğŸ“š<a href="#%_sec_Temp_697">&hellip;</a>
ğŸ“š<a href="#%_sec_Temp_698">&hellip;</a>
Â§<a href="#%_sec_4.4.4.3">4.4.4.3</a>
ğŸ“š<a href="#%_sec_Temp_699">&hellip;</a>
Â§<a href="#%_sec_4.4.4.4">4.4.4.4</a>
Â§<a href="#%_sec_4.4.4.5">4.4.4.5</a>
ğŸ“<a href="#%_thm_4.70">4.70</a>
Â§<a href="#%_sec_4.4.4.6">4.4.4.6</a>
Â§<a href="#%_sec_4.4.4.7">4.4.4.7</a>
Â§<a href="#%_sec_4.4.4.8">4.4.4.8</a>
ğŸ“<a href="#%_thm_4.71">4.71</a>
ğŸ“<a href="#%_thm_4.72">4.72</a>
ğŸ“<a href="#%_thm_4.73">4.73</a>
ğŸ“<a href="#%_thm_4.74">4.74</a>
ğŸ“<a href="#%_thm_4.75">4.75</a>
ğŸ“<a href="#%_thm_4.76">4.76</a>
ğŸ“<a href="#%_thm_4.77">4.77</a>
ğŸ“<a href="#%_thm_4.78">4.78</a>
ğŸ“<a href="#%_thm_4.79">4.79</a>
<a href="#footnotes">è„šæ³¨</a>
]</nav>
</div>

<div class="main-txt">
<a name="%_sec_4.4"></a>
<h2 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_4.4">4.4  Logic Programming</a></h2>
<h2 class="trans" lang="ja">4.4 è«–ç†ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°</h2>

<p class="orig" lang="en">
<a name="%_idx_5028"></a>
<a name="%_idx_5030"></a><a name="%_idx_5032"></a><a name="%_idx_5034"></a><a name="%_idx_5036"></a>In chapter 1 we stressed that computer science deals with imperative
(how to) knowledge, whereas mathematics deals with declarative (what
is) knowledge.  Indeed, programming languages require that the
programmer express knowledge in a form that indicates the step-by-step
methods for solving particular problems.  On the other hand,
high-level languages provide, as part of the language implementation,
a substantial amount of methodological knowledge that frees
the user from concern with numerous details of how a specified
computation will progress.</p>

<p class="trans" lang="ja">
æ•°å­¦ã¯ã€å®£è¨€çš„ãª (ä½•ã§ã‚ã‚‹ã‹ã€ã¨ã„ã†) çŸ¥è­˜ã‚’æ‰±ã†ã®ã«å¯¾ã—ã¦ã€è¨ˆç®—æ©Ÿç§‘å­¦ã¯ã€å‘½ä»¤çš„ãª (ã©ã†ã‚„ã£ã¦ã€ã¨ã„ã†) çŸ¥è­˜ã‚’æ‰±ã†ã®ã ã€ã¨ã„ã†ã“ã¨ã‚’ã€ç§ãŸã¡ã¯1ç« ã§å¼·èª¿ã—ãŸã€‚
äº‹å®Ÿã€ç‰¹å®šã®å•é¡Œã‚’è§£ããŸã‚ã®ã€ä¸€æ­©ãšã¤é€²ã‚€æ®µéšçš„ãªæ–¹æ³•ã‚’ç¤ºã™å½¢ã§ãƒ—ãƒ­ã‚°ãƒ©ãƒãŒçŸ¥è­˜ã‚’è¡¨ç¾ã™ã‚‹ã“ã¨ã‚’ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã¯è¦è«‹ã™ã‚‹ã€‚
ä¸€æ–¹ã§ã€æŒ‡å®šã•ã‚ŒãŸè¨ˆç®—ãŒã©ã†ã‚„ã£ã¦é€²è¡Œã™ã‚‹ã ã‚ã†ã‹ã€ã¨ã„ã†ã“ã¨ã«ã¤ã„ã¦ã®å¤šãã®ç´°ç›®ã«é–¢ã™ã‚‹å¿ƒé…ã‹ã‚‰ãƒ¦ãƒ¼ã‚¶ã‚’è§£ãæ”¾ã£ã¦ãã‚Œã‚‹ã€ç›¸å½“ãªé‡ã®æ–¹æ³•è«–çš„çŸ¥è­˜ã‚’ã€é«˜ç´šè¨€èªã¯ã€è¨€èªå®Ÿè£…ã®ä¸€éƒ¨ã¨ã—ã¦æä¾›ã—ã¦ã„ã‚‹ã€‚
</p>

<p class="orig" lang="en">
Most programming languages, including Lisp, are organized around
computing the values of mathematical functions.  Expression-oriented
languages (such as Lisp, Fortran, and Algol) capitalize on the ``pun''
that an expression that describes the value of a function may also be
interpreted as a means of computing that value.  Because of this, most
programming languages are strongly biased toward unidirectional
computations (computations with well-defined inputs and outputs).
There are, however, radically different programming languages that
relax this bias.  We saw one such example in
section <a href="22_sec3_3.html#%_sec_3.3.5">3.3.5</a>, where the objects of computation were
arithmetic constraints.  In a constraint system the direction and the
order of computation are not so well specified; in carrying out a
computation the system must therefore provide more detailed ``how to''
knowledge than would be the case with an ordinary arithmetic
computation.  This does not mean, however, that the user is released
altogether from the responsibility of providing imperative knowledge.
There are many constraint networks that implement the same set of
constraints, and the user must choose from the set of mathematically
equivalent networks a suitable network to specify a particular
computation.</p>

<p class="trans" lang="ja">
Lisp ã‚’å«ã‚€ã»ã¨ã‚“ã©ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã¯ã€æ•°å­¦çš„é–¢æ•°ã®å€¤ã‚’è¨ˆç®—ã™ã‚‹ã“ã¨ã‚’å·¡ã£ã¦çµ„ç¹”åŒ–ã•ã‚Œã¦ã„ã‚‹ã€‚
å¼æŒ‡å‘ã®è¨€èª (ãŸã¨ãˆã° Lisp ã‚„ Fortran ã‚„ Algol ãªã©) ã¯ã€é–¢æ•°ã®å€¤ã‚’è¨˜è¿°ã™ã‚‹å¼ãŒã€ãã®å€¤ã‚’è¨ˆç®—ã™ã‚‹æ‰‹æ®µã¨ã—ã¦ã‚‚è§£é‡ˆã•ã‚Œã†ã‚‹ã€ã¨ã„ã†ã€Œé§„æ´’è½ã€ã«ä¾¿ä¹—ã—ã¦ã„ã‚‹ã€‚
ã“ã‚ŒãŒç†ç”±ã§ã€ã»ã¨ã‚“ã©ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã¯ã€ä¸€æ–¹å‘çš„ãªè¨ˆç®— (ãã¡ã‚“ã¨å®šç¾©ã•ã‚ŒãŸå…¥åŠ›ã¨å‡ºåŠ›ã¨ã‚’ä¼´ã†è¨ˆç®—) ã¸ã¨å¼·ãåã£ã¦ã„ã‚‹ã€‚
ã—ã‹ã—ã€ã“ã®åã‚Šã‚’ç·©ã‚ã‚‹ã‚ˆã†ãªã€æ ¹æœ¬çš„ã«ç•°ãªã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªãŒå­˜åœ¨ã™ã‚‹ã€‚
ãã†ã—ãŸä¸€ã¤ã®ä¾‹ã‚’ã€ç§ãŸã¡ã¯<a href="22_sec3_3.html#%_sec_3.3.5">3.3.5</a>ç¯€ã§è¦‹ãŸã‚ã‘ã ãŒã€ãã“ã§ã¯è¨ˆç®—ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã¯ç®—è¡“çš„ãªåˆ¶ç´„ã§ã‚ã£ãŸã€‚
åˆ¶ç´„ã‚·ã‚¹ãƒ†ãƒ ã§ã¯ã€è¨ˆç®—ã®æ–¹å‘ã¨é †åºã¯ã€ãã‚Œã»ã©ãã¡ã‚“ã¨æŒ‡å®šã•ã‚Œãªã„ã€‚ã—ãŸãŒã£ã¦ã€ã‚·ã‚¹ãƒ†ãƒ ã¯ã€æ™®é€šã®ç®—è¡“è¨ˆç®—ã«ã¤ã„ã¦å½“ã¦ã¯ã¾ã‚‹ã§ã‚ã‚ã†ç¨‹åº¦ã‚ˆã‚Šã‚‚è©³ç´°ãªã€ã€Œã©ã†ã‚„ã£ã¦ã€ã¨ã„ã†çŸ¥è­˜ã‚’ã€è¨ˆç®—ã‚’å®Ÿè¡Œã—ã¦ã‚†ãä¸­ã§æä¾›ã›ã­ã°ã‚‰ãªã‚‰ãªã„ã€‚
ã—ã‹ã—ã€ã“ã‚Œã¯ã€å‘½ä»¤çš„ãªçŸ¥è­˜ã‚’æä¾›ã™ã‚‹è²¬ä»»ã‹ã‚‰ãƒ¦ãƒ¼ã‚¶ãŒå®Œå…¨ã«è§£æ”¾ã•ã‚Œã‚‹ã“ã¨ã‚’æ„å‘³ã™ã‚‹ã‚ã‘ã§ã¯ãªã„ã€‚
åŒã˜åˆ¶ç´„é›†åˆã‚’å®Ÿè£…ã™ã‚‹å¤šãã®åˆ¶ç´„ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãŒã‚ã‚Šã€ãƒ¦ãƒ¼ã‚¶ã¯ã€æ•°å­¦çš„ã«ã¯ç­‰ä¾¡ãªãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã®é›†åˆã®ä¸­ã‹ã‚‰ã€ç‰¹å®šã®è¨ˆç®—ã‚’æŒ‡å®šã™ã‚‹ã®ã«é©ã—ãŸãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚’é¸ã°ã­ã°ãªã‚‰ãªã„ã€‚
</p>


<p class="orig" lang="en">
The nondeterministic program evaluator of
section <a href="28_sec4_3.html#%_sec_4.3">4.3</a> also moves away from the
view that programming is about constructing algorithms for computing
unidirectional functions.  In a nondeterministic language, expressions
can have more than one value, and, as a result, the computation is
<a name="%_idx_5038"></a>dealing with relations rather than with
single-valued functions.  Logic programming extends this idea by
combining a relational vision of programming with a powerful kind of
symbolic pattern matching called <em>unification</em>.<a name="call_footnote_Temp_645" href="#footnote_Temp_645"><sup><small>58</small></sup></a></p>

<p class="trans" lang="ja">
<a href="28_sec4_3.html#%_sec_4.3">4.3</a>ç¯€ã®éæ±ºå®šãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®è©•ä¾¡å™¨ã‚‚ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã¨ã¯ä¸€æ–¹å‘çš„ãªé–¢æ•°ã‚’è¨ˆç®—ã™ã‚‹ãŸã‚ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’æ§‹ç¯‰ã™ã‚‹ã“ã¨ã«ã¤ã„ã¦ã®ã‚‚ã®ãªã®ã ã€ã¨ã„ã†è¦‹æ–¹ã‹ã‚‰é›¢ã‚Œã¦ã„ã£ã¦ã„ã‚‹ã€‚
éæ±ºå®šçš„è¨€èªã«ãŠã„ã¦ã¯ã€å¼ãŒä¸€ã¤ã‚ˆã‚Šã‚‚å¤šãã®å€¤ã‚’æŒã¤ã“ã¨ãŒå¯èƒ½ã§ã‚ã‚Šã€ãã®çµæœã€è¨ˆç®—ã¯ã€ä¸€ä¾¡é–¢æ•°ã‚’æ‰±ã†ã¨ã„ã†ã‚ˆã‚Šã‚€ã—ã‚é–¢ä¿‚ã‚’æ‰±ã£ã¦ã„ã‚‹ã€‚
è«–ç†ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã¯ã€ã“ã®è€ƒãˆã‚’ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã«ã¤ã„ã¦ã®é–¢ä¿‚å‹ã®è¦‹æ–¹ã¨ã€<em><ruby><rb>å˜ä¸€åŒ–</rb><rp> (</rp><rt>ãƒ¦ãƒ‹ãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³</rt><rp>) </rp></ruby></em>ã¨å‘¼ã°ã‚Œã‚‹å¼·åŠ›ãªç¨®é¡ã®è¨˜å·çš„ãƒ‘ã‚¿ãƒ³ãƒ»ãƒãƒƒãƒãƒ³ã‚°ã¨ã‚’çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€æ‹¡å¼µã™ã‚‹<a name="call_footnote_Temp_645" href="#footnote_Temp_645"><sup><small>58</small></sup></a>ã€‚
</p>


<p class="orig" lang="en">
<a name="%_idx_5070"></a><a name="%_idx_5072"></a>This approach, when it works, can be a very powerful way to write
programs.  Part of the power comes from the fact that a single ``what
is'' fact can be used to solve a number of different problems that
would have different ``how to'' components.  As an example, consider
the <a name="%_idx_5074"></a><tt>append</tt> operation, which takes two lists as arguments and
combines their elements to form a single list.  In a procedural
language such as Lisp, we could define <tt>append</tt> in terms of the
basic list constructor <tt>cons</tt>, as we did in
section <a href="15_sec2_2.html#%_sec_2.2.1">2.2.1</a>:</p>

<p class="trans" lang="ja">
ã“ã®æ‰‹æ³•ã¯ã€ã†ã¾ãã‚†ãã¨ãã«ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ããŸã‚ã®ã¨ã¦ã‚‚å¼·åŠ›ãªæ–¹æ³•ã«ãªã‚Œã‚‹ã€‚
ãã®åŠ›ã®ä¸€éƒ¨ã¯ã€ä¸€ã¤ã®ã€Œä½•ãªã®ã‹ã€ã¨ã„ã†äº‹å®ŸãŒã€ç•°ãªã‚‹ã€Œã©ã†ã‚„ã£ã¦ã€ã¨ã„ã†æ§‹æˆè¦ç´ ã‚’æŒã¡ã†ã‚‹å¤šæ•°ã®ç•°ãªã‚‹å•é¡Œã‚’è§£ãã®ã«ä½¿ãˆã‚‹ã€ã¨ã„ã†äº‹å®Ÿã«ç”±æ¥ã™ã‚‹ã€‚
ä¾‹ã¨ã—ã¦ã€<tt>append</tt> æ“ä½œâ€”â€”å¼•æ•°ã¨ã—ã¦äºŒã¤ã®ãƒªã‚¹ãƒˆã‚’ã¨ã£ã¦ã€ãã‚Œã‚‰ã®è¦ç´ ã‚’çµåˆã—ã¦ä¸€ã¤ã®ãƒªã‚¹ãƒˆã‚’å½¢æˆã™ã‚‹â€”â€”ã‚’è€ƒãˆã¦ã¿ã‚ˆã†ã€‚
Lispã®ã‚ˆã†ãªæ‰‹ç¶šãçš„è¨€èªã§ã¯ã€<a href="15_sec2_2.html#%_sec_2.2.1">2.2.1</a>ç¯€ã§è¡Œã£ãŸã‚ˆã†ã«ã€<tt>cons</tt> ã¨ã„ã†åŸºæœ¬çš„ãªãƒªã‚¹ãƒˆãƒ»ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’ä½¿ã£ã¦ <tt>append</tt> ã‚’å®šç¾©ã§ãã‚‹ã ã‚ã†ã€‚
</p>

<p class="lisp">(define (append x y)
  (if (null? x)
      y
      (cons (car x) (append (cdr x) y))))
</p>


<p class="orig" lang="en">This procedure can be regarded as a translation into Lisp of the
following two rules, the first of which covers the case where the
first list is empty and the second of which handles the case of a
nonempty list, which is a <tt>cons</tt> of two parts:</p>

<p class="trans" lang="ja">
ã“ã®æ‰‹ç¶šãã¯ã€ä»¥ä¸‹ã®äºŒã¤ã®è¦å‰‡ã®Lispã¸ã®ç¿»è¨³ã ã¨è¦‹ãªã›ã‚‹ã®ã ãŒã€ã“ã‚Œã‚‰è¦å‰‡ã®ã†ã¡1ç•ªç›®ã®ã‚‚ã®ã¯ã€1ç•ªç›®ã®ãƒªã‚¹ãƒˆãŒç©ºã®å ´åˆã‚’æ‰±ã£ã¦ãŠã‚Šã€2ç•ªç›®ã®ã‚‚ã®ã¯ã€éç©ºãƒªã‚¹ãƒˆâ€”â€”äºŒã¤ã®éƒ¨åˆ†ã® <tt>cons</tt> ã§ã‚ã‚‹â€”â€”ã®å ´åˆã‚’æ‰±ã£ã¦ã„ã‚‹ã€‚
</p>

<ul class="orig" lang="en">
<li>For any list <tt>y</tt>, the empty list and <tt>y</tt> <tt>append</tt> to form <tt>y</tt>.</li>

<li>For any <tt>u</tt>,  <tt>v</tt>,  <tt>y</tt>, and <tt>z</tt>,
 <tt>(cons u v)</tt> and <tt>y</tt> <tt>append</tt> to form <tt>(cons u z)</tt>
if <tt>v</tt> and <tt>y</tt> <tt>append</tt> to form <tt>z</tt>.<a name="call_footnote_Temp_646" href="#footnote_Temp_646"><sup><small>59</small></sup></a></li>
</ul>

<ul class="trans" lang="ja">
<li>ä»»æ„ã®ãƒªã‚¹ãƒˆ <tt>y</tt> ã«ã¤ã„ã¦ã€ç©ºãƒªã‚¹ãƒˆã¨ <tt>y</tt> ã¯ã€<tt>append</tt> ã—ã¦ <tt>y</tt> ã¨ãªã‚‹ã€‚</li>
<li>ä»»æ„ã® <tt>u</tt> ã¨ <tt>v</tt> ã¨ <tt>y</tt> ã¨ <tt>z</tt> ã«ã¤ã„ã¦ã€ã‚‚ã— <tt>v</tt> ã¨ <tt>y</tt> ãŒ <tt>append</tt> ã—ã¦ <tt>z</tt> ã¨ãªã‚‹ãªã‚‰ã€<tt>(cons u v)</tt> ã¨ <tt>y</tt> ã¯ã€<tt>append</tt> ã—ã¦ <tt>(cons u z)</tt> ã¨ãªã‚‹<a href="#footnote_Temp_646"><sup><small>59</small></sup></a>ã€‚</li>
</ul>

<div class="exercise">
<table class="expl ex_comment">
<tr><th colspan="2"><tt>x</tt> ãŒéç©ºã®å ´åˆã®å¯¾å¿œè¡¨</th></tr>
<tr><th>æ‰‹ç¶šã</th><th>è¦å‰‡</th></tr>
<tr><td><tt>x</tt></td><td><tt>(cons u v)</tt></td></tr>
<tr><td><tt>y</tt></td><td><tt>y</tt></td></tr>
<tr><td><tt>(car x)</tt></td><td><tt>u</tt></td></tr>
<tr><td><tt>(cdr x)</tt></td><td><tt>v</tt></td></tr>
<tr><td><tt>(append (cdr x) y)</tt><br>&nbsp;</td><td><tt>(append v y)</tt> ã™ãªã‚ã¡<br><tt>z</tt></td></tr>
<tr><td><tt>(append x y)</tt> ã™ãªã‚ã¡<br><tt>(cons (car x) (append (cdr x) y))</tt></td><td><tt>(append (cons u v) y)</tt> ã™ãªã‚ã¡<br><tt>(cons u z)</tt></td></tr>
</table>
</div>

<p class="orig" lang="en">
Using the <tt>append</tt> procedure, we can answer questions such as
</p>

<p class="trans" lang="ja">
ã“ã® <tt>append</tt> ã®æ‰‹ç¶šãã‚’ä½¿ã†ã¨ã€ä»¥ä¸‹ã®ã‚ˆã†ãªè³ªå•ã«ç­”ãˆã‚‰ã‚Œã‚‹ã€‚
</p>

<blockquote class="orig" lang="en">
Find the <tt>append</tt> of <tt>(a b)</tt> and <tt>(c d)</tt>.
</blockquote>

<blockquote class="trans" lang="ja">
<tt>(a b)</tt> ã¨ <tt>(c d)</tt> ã® <tt>append</tt> ã‚’æ±‚ã‚ã‚ˆã€‚
</blockquote>

<p class="orig" lang="en">
But the same two rules are also sufficient for answering the following
sorts of questions, which the procedure can't answer:</p>

<p class="trans" lang="ja">
ã—ã‹ã—ã€ä»¥ä¸‹ã®ã‚ˆã†ãªç¨®é¡ã®è³ªå•â€”â€”ã“ã®æ‰‹ç¶šãã§ã¯ç­”ãˆã‚‰ã‚Œãªã„ã‚‚ã®â€”â€”ã«ç­”ãˆã‚‹ãŸã‚ã«ã‚‚ã€åŒã˜äºŒã¤ã®è¦å‰‡ã§ååˆ†ãªã®ã ã€‚
</p>

<blockquote class="orig" lang="en">
<div>
Find a list <tt>y</tt> that <tt>append</tt>s with <tt>(a b)</tt> 
to produce <tt>(a b c d)</tt>.
</div>
<br>
<div>
Find all <tt>x</tt> and <tt>y</tt> that <tt>append</tt> to form <tt>(a b c
d)</tt>.
</div>
</blockquote>

<blockquote class="trans" lang="ja">
<div>
<tt>(a b)</tt> ã« <tt>append</tt> ã—ã¦ <tt>(a b c d)</tt> ã‚’ä½œã‚Šå‡ºã™ã‚ˆã†ãªã€<tt>y</tt> ã¨ã„ã†ãƒªã‚¹ãƒˆã‚’æ±‚ã‚ã‚ˆã€‚
</div>
<br>
<div>
<tt>append</tt> ã—ã¦ <tt>(a b c d)</tt> ã‚’ä½œã‚Šå‡ºã™ã‚ˆã†ãªã€ã™ã¹ã¦ã® <tt>x</tt> ã¨ <tt>y</tt> ã‚’æ±‚ã‚ã‚ˆã€‚
</div>
</blockquote>

<p class="orig" lang="en">
<a name="%_idx_5076"></a><a name="%_idx_5078"></a>In a logic programming language, the programmer writes an <tt>append</tt>
``procedure'' by stating the two rules about <tt>append</tt> given above.
``How to'' knowledge is provided automatically by the interpreter to
allow this single pair of rules to be used to answer all three types
of questions about <tt>append</tt>.<a name="call_footnote_Temp_647" href="#footnote_Temp_647"><sup><small>60</small></sup></a></p>

<p class="trans" lang="ja">
è«–ç†ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã§ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒã¯ã€ä¸Šè¨˜ã®ã‚ˆã†ãª <tt>append</tt> ã«ã¤ã„ã¦ã®äºŒã¤ã®è¦å‰‡ã‚’è¿°ã¹ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€<tt>append</tt> ã®ã€Œæ‰‹ç¶šãã€ã‚’æ›¸ãã€‚
ã€Œã©ã†ã‚„ã£ã¦ã€ã®çŸ¥è­˜ã¯ã€ã“ã®ãŸã£ãŸä¸€å¯¾ã®è¦å‰‡ã‚’ <tt>append</tt> ã«ã¤ã„ã¦ã®ä¸‰ã¤ã™ã¹ã¦ã®ç¨®é¡ã®è³ªå•ã«ç­”ãˆã‚‹ã®ã«ä½¿ãˆã‚‹ã‚ˆã†ã«ã™ã‚‹ã‚ˆã†ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«ã‚ˆã£ã¦è‡ªå‹•çš„ã«ä¸ãˆã‚‰ã‚Œã‚‹<a href="#footnote_Temp_647"><sup><small>60</small></sup></a>ã€‚
</p>

<p class="orig" lang="en">
Contemporary logic programming languages (including the one we
implement here) have substantial deficiencies, in that their general
``how to'' methods can lead them into spurious infinite loops or other
undesirable behavior.
Logic programming is an active field of research in computer science.<a name="call_footnote_Temp_648" href="#footnote_Temp_648"><sup><small>61</small></sup></a></p>

<p class="trans" lang="ja">
ç¾ä»£ã®è«–ç†ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èª (ã“ã“ã§ç§ãŸã¡ãŒå®Ÿè£…ã™ã‚‹ã‚‚ã®ã‚‚å«ã‚€) ã«ã¯ã€ãã‚Œã‚‰è¨€èªã®ä¸€èˆ¬çš„ãªã€Œã©ã†ã‚„ã£ã¦ã€ã®æ–¹æ³•ã®ã›ã„ã§ãã‚Œã‚‰è¨€èªãŒè¦‹ã‹ã‘ä¸Šã®ç„¡é™ãƒ«ãƒ¼ãƒ—ã¾ãŸã¯ä»–ã®æœ›ã¾ã—ã‹ã‚‰ã¬æŒ¯ã‚‹èˆã„ã¸ã¨é™¥ã‚Šã‹ã­ãªã„ã€<!--ãã‚Œã‚‰è¨€èªã®ä¸€èˆ¬çš„ãªã€Œã©ã†ã‚„ã£ã¦ã€ã®æ–¹æ³•ãŒã€è¦‹ã‹ã‘ä¸Šã®ç„¡é™ãƒ«ãƒ¼ãƒ—ã¾ãŸã¯ä»–ã®æœ›ã¾ã—ã‹ã‚‰ã¬æŒ¯ã‚‹èˆã„ã¸ã¨ã€ãã‚Œã‚‰è¨€èªã‚’å°ã„ã¦ã„ãã‹ã­ãªã„-->ã¨ã„ã†æ„å‘³ã«ãŠã„ã¦ã€ç›¸å½“ãªæ¬ é™¥ãŒã‚ã‚‹ã€‚
è«–ç†ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã¯ã€è¨ˆç®—æ©Ÿç§‘å­¦ã«ãŠã‘ã‚‹æ´»ç™ºãªç ”ç©¶é ˜åŸŸã§ã‚ã‚‹<a href="#footnote_Temp_648"><sup><small>61</small></sup></a>ã€‚
</p>




<p class="orig" lang="en">
Earlier in this chapter we explored the technology of implementing
interpreters and described the elements that are essential to an
interpreter for a Lisp-like language (indeed, to an interpreter for
any conventional language).  Now we will apply these ideas to discuss
an interpreter for a logic programming language.  We call this
<a name="%_idx_5090"></a>language the <em>query language</em>, because it is very useful for
retrieving information from data bases by formulating <a name="%_idx_5092"></a><em>queries</em>,
or questions, expressed in the language.  Even though the query
language is very different from Lisp, we will find it convenient to
describe the language in terms of the same general framework we have
been using all along: as a collection of primitive elements, together
with means of combination that enable us to combine simple elements to
create more complex elements and means of abstraction that enable us
to regard complex elements as single conceptual units.  An interpreter
for a logic programming language is considerably more complex than an
interpreter for a language like Lisp.  Nevertheless, we will see
<a name="%_idx_5094"></a>that our query-language interpreter contains many of the same elements
found in the interpreter of section <a href="26_sec4_1.html#%_sec_4.1">4.1</a>.  In particular,
there will be an ``eval'' part that classifies expressions according
to type and an ``apply'' part that implements the language's
abstraction mechanism (procedures in the case of Lisp, and <em>rules</em>
in the case of logic programming).  Also, a central role is played in
the implementation by a frame data structure, which determines the
correspondence between symbols and their associated values.  One
additional interesting aspect of our query-language implementation is
that we make substantial use of streams, which were introduced in
chapter 3.</p>

<p class="trans" lang="ja">
æœ¬ç« ã®æœ€åˆã®æ–¹ã§ã€ç§ãŸã¡ã¯ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã‚’å®Ÿè£…ã™ã‚‹æŠ€è¡“ã‚’æ¢æŸ»ã—ã€Lisp çš„ãªè¨€èªã®ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«ã¨ã£ã¦ (å®Ÿã¯ã€å¾“æ¥ã®ã©ã®è¨€èªã®ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«ã¨ã£ã¦ã‚‚) å¿…é ˆã®è¦ç´ ã«ã¤ã„ã¦è¨˜è¿°ã—ãŸã€‚
ã•ã¦ã“ã“ã‹ã‚‰ã¯ã€è«–ç†ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã®ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«ã¤ã„ã¦è­°è«–ã™ã‚‹ãŸã‚ã«ã€ã“ã‚Œã‚‰ã®è€ƒãˆæ–¹ã‚’é©ç”¨ã—ã‚ˆã†ã€‚
ã“ã®è¨€èªã®ã“ã¨ã‚’ã€<em>ã‚¯ã‚¨ãƒªè¨€èª</em>ã¨å‘¼ã¶ã€‚ãªãœãªã‚‰ã€ã“ã®è¨€èªã¯ã€ã“ã®è¨€èªã§è¡¨ç¾ã•ã‚ŒãŸ<em>ã‚¯ã‚¨ãƒª</em>â€”â€”ã™ãªã‚ã¡è³ªå•â€”â€”ã‚’å®šå¼åŒ–ã™ã‚‹ã“ã¨ã§ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‹ã‚‰æƒ…å ±ã‚’æ¤œç´¢ã™ã‚‹ã®ã«ã€å¤§å¤‰æœ‰ç”¨ã ã‹ã‚‰ã§ã‚ã‚‹ã€‚
ãŸã¨ãˆã‚¯ã‚¨ãƒªè¨€èªãŒ Lisp ã¨ã¯å…¨ç„¶é•ã£ã¦ã„ã¦ã•ãˆã‚‚ã€ã“ã®è¨€èªã‚’ã€ç§ãŸã¡ãŒæœ€åˆã‹ã‚‰ãšã£ã¨ä½¿ã£ã¦ãã¦ã„ã‚‹åŒã˜ä¸€èˆ¬çš„ãªæ çµ„ã¿ã§è¨˜è¿°ã™ã‚‹ã®ãŒâ€”â€”ã¤ã¾ã‚Šã€å˜ç´”ãªè¦ç´ åŒå£«ã‚’çµåˆã—ã¦ã‚ˆã‚Šè¤‡é›‘ãªè¦ç´ ã‚’ä½œã‚‹ã“ã¨ã‚’å¯èƒ½ã«ã—ã¦ãã‚Œã‚‹çµåˆæ‰‹æ®µã¨ã€è¤‡é›‘ãªè¦ç´ ã‚’å˜ä¸€ã®æ¦‚å¿µçš„å˜ä½ã¨è¦‹ãªã™ã“ã¨ã‚’å¯èƒ½ã«ã—ã¦ãã‚Œã‚‹æŠ½è±¡åŒ–æ‰‹æ®µã¨ã‚’å‚™ãˆãŸã€åŸå§‹çš„è¦ç´ ã®é›†ã¾ã‚Šã¨ã—ã¦ã€è¨˜è¿°ã™ã‚‹ã“ã¨ãŒâ€”â€”ä¾¿åˆ©ã ã¨ã„ã†ã“ã¨ã«ã€ç§ãŸã¡ã¯æ°—ã¥ãã“ã¨ã«ãªã‚‹ã ã‚ã†ã€‚
è«–ç†ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã®ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã¯ã€Lisp ã®ã‚ˆã†ãªè¨€èªã®ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã‚ˆã‚Šã‚‚ã€ãšã£ã¨è¤‡é›‘ã§ã‚ã‚‹ã€‚
ãã‚Œã«ã‚‚ã‹ã‹ã‚ã‚‰ãšã€ç§ãŸã¡ã®ã‚¯ã‚¨ãƒªè¨€èªç”¨ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒã€<a href="26_sec4_1.html#%_sec_4.1">4.1</a>ç¯€ã®ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«è¦‹ã‚‰ã‚Œã‚‹ã®ã¨åŒã˜è¦ç´ ã®ã†ã¡ã®å¤šãã‚’å«ã‚€ã¨ã„ã†ã“ã¨ã‚’ã€ç§ãŸã¡ã¯è¦‹ã‚‹ã“ã¨ã«ãªã‚‹ã ã‚ã†ã€‚
ã¨ã‚Šã‚ã‘ã€å‹ã«ã—ãŸãŒã£ã¦å¼ã‚’åˆ†é¡ã™ã‚‹ã€Œ<ruby><rb>è©•ä¾¡</rb><rp> (</rp><rt>eval</rt><rp>) </rp></ruby>ã€éƒ¨åˆ†ã¨ã€è¨€èªã®æŠ½è±¡åŒ–æ©Ÿæ§‹ã‚’å®Ÿè£…ã™ã‚‹ã€Œ<ruby><rb>é©ç”¨</rb><rp> (</rp><rt>apply</rt><rp>) </rp></ruby>ã€éƒ¨åˆ† (Lisp ã®å ´åˆã«ã¯æ‰‹ç¶šãã§ã‚ã‚Šã€è«–ç†ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®å ´åˆã«ã¯<em>è¦å‰‡</em>ã§ã‚ã‚‹) ãŒå­˜åœ¨ã™ã‚‹ã§ã‚ã‚ã†ã€‚
ã¾ãŸã€ä¸­å¿ƒçš„å½¹å‰²ã¯ã€ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ»ãƒ‡ãƒ¼ã‚¿æ§‹é€ â€”â€”<ruby><rb>è¨˜å·</rb><rp> (</rp><rt>ã‚·ãƒ³ãƒœãƒ«</rt><rp>) </rp></ruby>ã¨ãã‚Œã«é–¢é€£ã¥ã‘ã‚‰ã‚ŒãŸå€¤ã¨ã®å¯¾å¿œé–¢ä¿‚ã‚’æ±ºå®šã™ã‚‹â€”â€”ã«ãŠã„ã¦æœãŸã•ã‚Œã‚‹ã€‚
ç§ãŸã¡ã®ã‚¯ã‚¨ãƒªè¨€èªã®å®Ÿè£…ã®ã€ä¸€ã¤ã®ä»˜åŠ çš„ãªé¢ç™½ã„å´é¢ã¯ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ â€”â€”3ç« ã§å°å…¥ã—ãŸã‚‚ã®â€”â€”ã‚’äº‹å®Ÿä¸Šåˆ©ç”¨ã™ã‚‹ã€ã¨ã„ã†ç‚¹ã§ã‚ã‚‹ã€‚
</p>

<a name="%_sec_4.4.1"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_4.4.1">4.4.1  Deductive Information Retrieval</a></h3>
<h3 class="trans" lang="ja">4.4.1 æ¼”ç¹¹çš„ãªæƒ…å ±æ¤œç´¢</h3>

<p class="orig" lang="en"><a name="%_idx_5096"></a>
<a name="%_idx_5098"></a>Logic programming excels in providing interfaces to data bases for
information retrieval.  The query language we shall implement in this
chapter is designed to be used in this way.</p>

<p class="trans" lang="ja">
è«–ç†ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã¯ã€æƒ…å ±æ¤œç´¢ç”¨ã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«å¯¾ã™ã‚‹ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ã‚¤ã‚¹ã‚’æä¾›ã™ã‚‹ã“ã¨ã«ç§€ã§ã¦ã„ã‚‹ã€‚
ç§ãŸã¡ãŒæœ¬ç« ã§å®Ÿè£…ã™ã‚‹ã“ã¨ã«ãªã‚‹ã‚¯ã‚¨ãƒªè¨€èªã¯ã€ã“ã†ã—ãŸæ–¹æ³•ã§ä½¿ã‚ã‚Œã‚‹ã‚ˆã†ã«è¨­è¨ˆã•ã‚Œã¦ã„ã‚‹ã€‚
</p>

<p class="orig" lang="en">
In order to illustrate what the query system does, we will show how it
can be used to manage the data base of personnel records for
<a name="%_idx_5100"></a>Microshaft, a thriving high-technology company in the
Boston area.  The language provides pattern-directed access to
personnel information and can also take advantage of general rules in
order to make logical deductions.</p>

<p class="trans" lang="ja">
ã‚¯ã‚¨ãƒªãƒ»ã‚·ã‚¹ãƒ†ãƒ ãŒä½•ã‚’ã™ã‚‹ã®ã‹ã‚’ä¾‹è§£ã™ã‚‹ãŸã‚ã«ã€ç§ãŸã¡ã¯ã€ãƒœã‚¹ãƒˆãƒ³åœ°åŒºã®æˆé•·ä¸­ã®ãƒã‚¤ãƒ†ã‚¯ä¼æ¥­ã§ã‚ã‚‹ãƒã‚¤ã‚¯ãƒ­ã‚·ãƒ£ãƒ•ãƒˆç¤¾ã®ãŸã‚ã®äººäº‹è¨˜éŒ²ã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’ç®¡ç†ã™ã‚‹ã®ã«ã‚¯ã‚¨ãƒªãƒ»ã‚·ã‚¹ãƒ†ãƒ ã‚’ã©ã®ã‚ˆã†ã«ä½¿ãˆã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’ç¤ºãã†ã€‚
ã“ã®è¨€èªã«ã‚ˆã£ã¦ã€äººäº‹æƒ…å ±ã¸ã®ãƒ‘ã‚¿ãƒ³æŒ‡å‘ã®ã‚¢ã‚¯ã‚»ã‚¹æ¨©ãŒæä¾›ã•ã‚Œã€ã¾ãŸã€ã“ã®è¨€èªã¯ã€è«–ç†çš„æ¼”ç¹¹ã‚’è¡Œã†ãŸã‚ã«ä¸€èˆ¬çš„è¦å‰‡ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
</p>

<a name="%_sec_Temp_649"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_649">A sample data base</a></h4>
<h4 class="trans" lang="ja">ã‚µãƒ³ãƒ—ãƒ«ãƒ»ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹</h4>

<p class="orig" lang="en">
<a name="%_idx_5102"></a>
<a name="%_idx_5104"></a><a name="%_idx_5106"></a>The personnel data base for Microshaft
contains <em>assertions</em> about company personnel.  Here is the
information about Ben Bitdiddle, the resident computer wizard:</p>

<p class="trans" lang="ja">
ãƒã‚¤ã‚¯ãƒ­ã‚·ãƒ£ãƒ•ãƒˆç¤¾ã®äººäº‹ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã¯ã€ä¼šç¤¾è·å“¡ã«ã¤ã„ã¦ã®<em><ruby><rb>è¨€æ˜</rb><rp> (</rp><rt>ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³</rt><rp>) </rp></ruby></em>ã‚’å«ã‚€ã€‚
ã“ã“ã«ã€å°‚ä»»ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿é­”è¡“å¸«ã®ãƒ™ãƒ³ãƒ»ãƒ“ãƒƒãƒˆãƒ‡ã‚£ãƒ‰ãƒ«ã«ã¤ã„ã¦ã®æƒ…å ±ãŒã‚ã‚‹ã€‚
</p>

<p class="lisp">(address (Bitdiddle Ben) (Slumerville (Ridge Road) 10))
(job (Bitdiddle Ben) (computer wizard))
(salary (Bitdiddle Ben) 60000)
</p>

<!--
<p class="exercise ex_comment">(ä½æ‰€ (ãƒ“ãƒƒãƒˆãƒ‡ã‚£ãƒ‰ãƒ« ãƒ™ãƒ³) (ã‚¹ãƒ©ãƒãƒ¼ãƒ´ã‚£ãƒ« (ãƒªãƒƒã‚¸è¡—) 10))
(ä»•äº‹ (ãƒ“ãƒƒãƒˆãƒ‡ã‚£ãƒ‰ãƒ« ãƒ™ãƒ³) (ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ é­”è¡“å¸«))
(çµ¦ä¸ (ãƒ“ãƒƒãƒˆãƒ‡ã‚£ãƒ‰ãƒ« ãƒ™ãƒ³) 60000)
</p>
-->

<p class="orig" lang="en">Each assertion is a list (in this case a triple) whose elements can
themselves be lists.</p>

<p class="trans" lang="ja">
å„è¨€æ˜ã¯ã€ãã®è¦ç´ è‡ªä½“ã‚‚ãƒªã‚¹ãƒˆã§ã‚ã‚Šå¾—ã‚‹ã‚ˆã†ãªãƒªã‚¹ãƒˆ (ã“ã®ä¾‹ã§ã¯ä¸‰ã¤çµ„) ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
As resident wizard, Ben is in charge of the company's computer
division, and he supervises two programmers and one technician.  Here
is the information about them:</p>

<p class="trans" lang="ja">
å°‚ä»»é­”è¡“å¸«ã¨ã—ã¦ã€ãƒ™ãƒ³ã¯ã€ä¼šç¤¾ã®ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿éƒ¨é–€ã«è²¬ä»»ãŒã‚ã‚Šã€äºŒäººã®ãƒ—ãƒ­ã‚°ãƒ©ãƒã¨ä¸€äººã®æŠ€å¸«ã‚’æŒ‡æ®ç›£ç£ã—ã¦ã„ã‚‹ã€‚
ã“ã“ã«ã€ãã®äººãŸã¡ã«ã¤ã„ã¦ã®æƒ…å ±ãŒã‚ã‚‹ã€‚
</p>

<p class="lisp">(address (Hacker Alyssa P) (Cambridge (Mass Ave) 78))
(job (Hacker Alyssa P) (computer programmer))
(salary (Hacker Alyssa P) 40000)
(supervisor (Hacker Alyssa P) (Bitdiddle Ben))
(address (Fect Cy D) (Cambridge (Ames Street) 3))
(job (Fect Cy D) (computer programmer))
(salary (Fect Cy D) 35000)
(supervisor (Fect Cy D) (Bitdiddle Ben))
(address (Tweakit Lem E) (Boston (Bay State Road) 22))
(job (Tweakit Lem E) (computer technician))
(salary (Tweakit Lem E) 25000)
(supervisor (Tweakit Lem E) (Bitdiddle Ben))
</p>

<p class="orig" lang="en">There is also a programmer trainee, who is supervised by Alyssa:
</p>

<p class="trans" lang="ja">
ãƒ—ãƒ­ã‚°ãƒ©ãƒè¦‹ç¿’ã„ã‚‚ã„ã¦ã€ãã®äººã¯ã‚¢ãƒªãƒƒã‚µã«ã‚ˆã‚Šç›£ç£ã•ã‚Œã¦ã„ã‚‹ã€‚
</p>

<p class="lisp">(address (Reasoner Louis) (Slumerville (Pine Tree Road) 80))
(job (Reasoner Louis) (computer programmer trainee))
(salary (Reasoner Louis) 30000)
(supervisor (Reasoner Louis) (Hacker Alyssa P))
</p>

<p class="orig" lang="en">All of these people are in the computer division, as indicated by the
word <tt>computer</tt> as the first item in their job descriptions.</p>

<p class="trans" lang="ja">
ã“ã‚Œã‚‰ã®äººãŸã¡ã®ã™ã¹ã¦ã¯ã€ä»•äº‹ã®è¨˜è¿°ã«ãŠã‘ã‚‹1ç•ªç›®ã®é …ç›®ã¨ã—ã¦ã® <tt>computer</tt> ã¨ã„ã†èªã«ã‚ˆã£ã¦ç¤ºã•ã‚Œã‚‹ã¨ãŠã‚Šã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿éƒ¨é–€ã«ã„ã‚‹ã€‚
</p>

<p class="orig" lang="en">
Ben is a high-level employee.  His supervisor is the company's big
wheel himself:</p>

<p class="trans" lang="ja">
ãƒ™ãƒ³ã¯ä¸Šç´šç¤¾å“¡ã§ã‚ã‚‹ã€‚
å½¼ã®ä¸Šå¸ã¯ã€ãã®äººè‡ªä½“ãŒã“ã®ä¼šç¤¾ã®å¤§ç‰©ã§ã‚ã‚‹ã€‚
</p>

<p class="lisp">(supervisor (Bitdiddle Ben) (Warbucks Oliver))
(address (Warbucks Oliver) (Swellesley (Top Heap Road)))
(job (Warbucks Oliver) (administration big wheel))
(salary (Warbucks Oliver) 150000)
</p>


<p class="orig" lang="en">
Besides the computer division supervised by Ben, the company has an
accounting division, consisting of a chief accountant and his
assistant:</p>

<p class="trans" lang="ja">
ãƒ™ãƒ³ã«ã‚ˆã‚Šç›£ç£ã•ã‚Œã¦ã„ã‚‹ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿éƒ¨é–€ã®ã»ã‹ã«ã€ã“ã®ä¼šç¤¾ã«ã¯ä¼šè¨ˆéƒ¨é–€ãŒã‚ã‚Šã€ä¸»å¸­ä¼šè¨ˆå£«ã¨å½¼ã®åŠ©æ‰‹ã‹ã‚‰æ§‹æˆã•ã‚Œã¦ã„ã‚‹ã€‚
</p>

<p class="lisp">(address (Scrooge Eben) (Weston (Shady Lane) 10))
(job (Scrooge Eben) (accounting chief accountant))
(salary (Scrooge Eben) 75000)
(supervisor (Scrooge Eben) (Warbucks Oliver))
(address (Cratchet Robert) (Allston (N Harvard Street) 16))
(job (Cratchet Robert) (accounting scrivener))
(salary (Cratchet Robert) 18000)
(supervisor (Cratchet Robert) (Scrooge Eben))
</p>


<p class="orig" lang="en">There is also a secretary for the big wheel:</p>

<p class="trans" lang="ja">
å¤§ç‰©ã®ãŸã‚ã®ç§˜æ›¸ã‚‚ã„ã‚‹ã€‚
</p>

<p class="lisp">(address (Aull DeWitt) (Slumerville (Onion Square) 5))
(job (Aull DeWitt) (administration secretary))
(salary (Aull DeWitt) 25000)
(supervisor (Aull DeWitt) (Warbucks Oliver))
</p>

<p class="orig" lang="en">
The data base also contains assertions about which kinds of jobs can
be done by people holding other kinds of jobs.  For instance, a
computer wizard can do the jobs of both a computer programmer and a
computer technician:</p>

<p class="trans" lang="ja">
ã“ã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã¯ã€ä»–ã®ä»•äº‹ã‚’æŠ±ãˆã¦ã„ã‚‹äººãŸã¡ã«ã‚ˆã£ã¦ã©ã®ç¨®é¡ã®ä»•äº‹ã‚’ãªã—å¾—ã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã«ã¤ã„ã¦ã®è¨€æ˜ã‚‚å«ã‚€ã€‚
ãŸã¨ãˆã°ã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿é­”è¡“å¸«ã¯ã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ»ãƒ—ãƒ­ã‚°ãƒ©ãƒã¨ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿æŠ€å¸«ã®åŒæ–¹ã®ä»•äº‹ã‚’è¡Œã†ã“ã¨ãŒã§ãã‚‹ã€‚
</p>

<p class="lisp">(can-do-job (computer wizard) (computer programmer))
(can-do-job (computer wizard) (computer technician))
</p>

<p class="orig" lang="en">A computer programmer could fill in for a trainee:
</p>

<p class="trans" lang="ja">
ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ»ãƒ—ãƒ­ã‚°ãƒ©ãƒã¯ã€è¦‹ç¿’ã„ã®ä»£ã‚ã‚ŠãŒã§ãã‚‹ã ã‚ã†ã€‚
</p>

<p class="lisp">(can-do-job (computer programmer)
            (computer programmer trainee))
</p>

<p class="orig" lang="en"><a name="%_idx_5108"></a>Also, as is well known,
</p>

<p class="trans" lang="ja">
ã¾ãŸã€ä»¥ä¸‹ã®ã“ã¨ã¯ã‚ˆãçŸ¥ã‚‰ã‚Œã¦ã„ã‚‹ã¨ãŠã‚Šã§ã‚ã‚‹<span class="note"> (ã“ã“ã¯ç¬‘ã†ã¨ã“ã‚ã ã‚ˆ)</span>ã€‚
</p>

<p class="lisp">(can-do-job (administration secretary)
            (administration big wheel))
</p>

<p class="extra">
ã“ã“ã‹ã‚‰å…ˆã¯ Prolog ã§ç­”ãˆåˆã‚ã›ã‚’ã—ãªãŒã‚‰èª­ã‚€ã¨ã„ã„ã‹ãªã€ã¨æ€ã† (ã¨ã‚Šã‚ãˆãš GNU Prolog ã‚’ä½¿ã†)ã€‚
ãã“ã§ã€ä»¥ä¸‹ã®ã‚ˆã†ãªè¨˜è¿°ã‚’å«ã‚€<a href="personnel_db.pl">ãƒ•ã‚¡ã‚¤ãƒ«</a> (<tt>personnel_db.pl</tt>) ã‚’ä½œã£ãŸã€‚ãªãŠã€ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã«ã¯å¾Œå‡ºã®è¦å‰‡ã‚‚å«ã‚ã¦ã‚ã‚‹ã€‚
</p>

<p class="extra_code"><span class="ex_comment">% GNU Prologã§ã¯ã€åŒã˜è¿°èªã‚’é€£ç¶šã—ã¦ (ã¾ã¨ã‚ã¦) è¨˜è¿°ã—ã¦ãŠã‹ãªã„ã¨
% ã€Œdiscontiguous predicate address/2 - clause ignoredã€
% ã®ã‚ˆã†ãªã‚¨ãƒ©ãƒ¼ãŒå‡ºã‚‹ã®ã§ã€ãã‚Œã‚’å›é¿ã™ã‚‹ãŸã‚ã®ãŠã¾ã˜ãªã„ã€‚</span>
:- discontiguous(address/2, job/2, salary/2, supervisor/2, can_do_job/2).

address(['Bitdiddle', 'Ben'], ['Slumerville', ['Ridge', 'Road'], 10]).
job(['Bitdiddle', 'Ben'], [computer, wizard]).
salary(['Bitdiddle', 'Ben'], 60000).

address(['Hacker', 'Alyssa', 'P'], ['Cambridge', ['Mass', 'Ave'], 78]).
job(['Hacker', 'Alyssa', 'P'], [computer, programmer]).
salary(['Hacker', 'Alyssa', 'P'], 40000).
supervisor(['Hacker', 'Alyssa', 'P'], ['Bitdiddle', 'Ben']).

address(['Fect', 'Cy', 'D'], ['Cambridge', ['Ames', 'Street'], 3]).
job(['Fect', 'Cy', 'D'], [computer, programmer]).
salary(['Fect', 'Cy', 'D'], 35000).
supervisor(['Fect', 'Cy', 'D'], ['Bitdiddle', 'Ben']).

address(['Tweakit', 'Lem', 'E'], ['Boston', ['Bay', 'State', 'Road'], 22]).
job(['Tweakit', 'Lem', 'E'], [computer, technician]).
salary(['Tweakit', 'Lem', 'E'], 25000).
supervisor(['Tweakit', 'Lem', 'E'], ['Bitdiddle', 'Ben']).

address(['Reasoner', 'Louis'], ['Slumerville', ['Pine', 'Tree', 'Road'], 80]).
job(['Reasoner', 'Louis'], [computer, programmer, trainee]).
salary(['Reasoner', 'Louis'], 30000).
supervisor(['Reasoner', 'Louis'], ['Hacker', 'Alyssa', 'P']).

supervisor(['Bitdiddle', 'Ben'], ['Warbucks', 'Oliver']).

address(['Warbucks', 'Oliver'], ['Swellesley', ['Top', 'Heap', 'Road']]).
job(['Warbucks', 'Oliver'], [administration, big, wheel]).
salary(['Warbucks', 'Oliver'], 150000).

address(['Scrooge', 'Eben'], ['Weston', ['Shady', 'Lane'], 10]).
job(['Scrooge', 'Eben'], [accounting, chief, accountant]).
salary(['Scrooge', 'Eben'], 75000).
supervisor(['Scrooge', 'Eben'], ['Warbucks', 'Oliver']).

address(['Cratchet', 'Robert'], ['Allston', ['N', 'Harvard', 'Street'], 16]).
job(['Cratchet', 'Robert'], [accounting, scrivener]).
salary(['Cratchet', 'Robert'], 18000).
supervisor(['Cratchet', 'Robert'], ['Scrooge', 'Eben']).

address(['Aull', 'DeWitt'], ['Slumerville', ['Onion', 'Square'], 5]).
job(['Aull', 'DeWitt'], [administration, secretary]).
salary(['Aull', 'DeWitt'], 25000).
supervisor(['Aull', 'DeWitt'], ['Warbucks', 'Oliver']).

can_do_job([computer, wizard], [computer, programmer]).
can_do_job([computer, wizard], [computer, technician]).
can_do_job([computer, programmer], [computer, programmer, trainee]).
can_do_job([administration, secretary], [administration, big, wheel]).
</p>

<p class="extra">ä»¥ä¸‹ã®ã‚ˆã†ã«å®Ÿè¡Œã—ã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€ã€‚
<br>
<tt>$ gprolog<br>
| ?- consult('personnel_db.pl').</tt> 
<br>
ã“ã“ã‹ã‚‰å…ˆã¯ã€ã‚¯ã‚¨ãƒªã‚’æ‰“ã¡è¾¼ã‚€ã¨ç­”ãˆãŒå‡ºã¦ãã‚‹ã€‚
ã‚ã‚‹ã„ã¯ã€
<br>
<tt>$ gprolog --consult-file personnel_db.pl</tt>
<br>
ã¨ã—ã¦ã‚‚ã‚ˆã„ã€‚
</p>

<a name="%_sec_Temp_650"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_650">Simple queries</a></h4>
<h4 class="trans" lang="ja">å˜ç´”ã‚¯ã‚¨ãƒª</h4>


<p class="orig" lang="en">
<a name="%_idx_5110"></a>
The query language allows users to retrieve information from the data
base by posing queries in response to the system's prompt.  For
example, to find all computer programmers one can say</p>

<p class="trans" lang="ja">
ã‚¯ã‚¨ãƒªè¨€èªã«ã‚ˆã£ã¦ã€ãƒ¦ãƒ¼ã‚¶ã¯ã€ã‚·ã‚¹ãƒ†ãƒ ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã«å¿œç­”ã—ã¦ã‚¯ã‚¨ãƒªã‚’æç¤ºã™ã‚‹ã“ã¨ã§ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‹ã‚‰æƒ…å ±ã‚’æ¤œç´¢ã™ã‚‹ã“ã¨ãŒå¯èƒ½ã¨ãªã‚‹ã€‚
ãŸã¨ãˆã°ã€ã™ã¹ã¦ã®ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ»ãƒ—ãƒ­ã‚°ãƒ©ãƒã‚’è¦‹ã¤ã‘ã‚‹ãŸã‚ã«ã€æ¬¡ã®ã‚ˆã†ã«è¨€ã†ã“ã¨ãŒã§ãã‚‹ã€‚
</p>

<p class="lisp"><i>;;; Query input:</i>
(job ?x (computer programmer))
</p>

<p class="orig" lang="en">The system will respond with the following items:</p>

<p class="trans" lang="ja">
ã‚·ã‚¹ãƒ†ãƒ ã¯ã€ä»¥ä¸‹ã®é …ç›®ã§ã‚‚ã£ã¦å¿œç­”ã™ã‚‹ã ã‚ã†ã€‚
</p>

<p class="lisp"><i>;;; Query results:</i>
(job (Hacker Alyssa P) (computer programmer))
(job (Fect Cy D) (computer programmer))
</p>

<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
| ?- job(X, [computer, programmer]).

X = ['Hacker','Alyssa','P'] ? ;

X = ['Fect','Cy','D'] ? ;

no</p>

<p class="orig" lang="en">
<a name="%_idx_5112"></a>The input query specifies that we are looking for entries in the data
base that match a certain <em>pattern</em>.  In this example, the pattern
specifies entries consisting of three items, of which the first is the
literal symbol <tt>job</tt>, the second can be anything, and the third is
the literal list <tt>(computer programmer)</tt>.  The ``anything'' that
can be the second item in the matching list is specified by a <a name="%_idx_5114"></a><em>pattern variable</em>, <tt>?x</tt>.  The general form of a pattern variable
is a symbol, taken to be the name of the variable, preceded by a
question mark.  We will see below why it is useful to specify names
for pattern variables rather than just putting <tt>?</tt> into patterns
to represent ``anything.''  The system responds to a simple query by
showing all entries in the data base that match the specified pattern.</p>

<p class="trans" lang="ja">
å…¥åŠ›ã‚¯ã‚¨ãƒªã¯ã€ã‚ã‚‹<em>ãƒ‘ã‚¿ãƒ³</em>ã«åˆè‡´ã™ã‚‹ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å†…ã®ã‚¨ãƒ³ãƒˆãƒªã‚’æ¢ã—ã¦ã„ã‚‹ã¨ã“ã‚ãªã®ã ã€ã¨ã„ã†ã“ã¨ã‚’æŒ‡å®šã—ã¦ã„ã‚‹ã€‚
ã“ã®ä¾‹ã§ã¯ã€ãã®ãƒ‘ã‚¿ãƒ³ã¯ã€3é …ç›®ã‹ã‚‰ãªã‚‹ã‚¨ãƒ³ãƒˆãƒªã‚’æŒ‡å®šã—ã¦ãŠã‚Šã€ãã‚Œã‚‰3é …ç›®ã®ã†ã¡ã€1ç•ªç›®ã¯ <tt>job</tt> ã¨ã„ã†ãƒªãƒ†ãƒ©ãƒ«è¨˜å·ã§ã‚ã‚Šã€2ç•ªç›®ã¯<!-- ä»»æ„ã®ã‚‚ã®ã§ã‚ã£ã¦ã‚ˆã -->ä½•ã§ã‚‚ã‚ˆãã€3ç•ªç›®ã¯ <tt>(computer programmer)</tt> ã¨ã„ã†ãƒªãƒ†ãƒ©ãƒ«ãƒ»ãƒªã‚¹ãƒˆã§ã‚ã‚‹ã€‚
ãƒãƒƒãƒãƒ³ã‚°ãƒ»ãƒªã‚¹ãƒˆã«ãŠã‘ã‚‹2ç•ªç›®ã®é …ç›®ã«ãªã‚Šå¾—ã‚‹ã€Œ<!-- ä»»æ„ã®ã‚‚ã® -->ä½•ã‹ã€ã¯ã€<em>ãƒ‘ã‚¿ãƒ³å¤‰æ•°</em>ã«ã‚ˆã‚Šã€ã™ãªã‚ã¡ã€<tt>?x</tt> ã«ã‚ˆã‚Šã€æŒ‡å®šã•ã‚Œã¦ã„ã‚‹ã€‚
ãƒ‘ã‚¿ãƒ³å¤‰æ•°ã®ä¸€èˆ¬å½¢ã¯ã€ç–‘å•ç¬¦ãŒå…ˆã«ä»˜ã„ã¦ã„ã¦ã€å¤‰æ•°ã®åå‰ã¨ã—ã¦ã¨ã‚‰ã‚Œã‚‹ã¹ãã€è¨˜å·ã§ã‚ã‚‹ã€‚
ã€Œ<!-- ä»»æ„ã®ã‚‚ã® -->ä½•ã‹ã€ã‚’è¡¨ç¾ã™ã‚‹ã®ã«ã€å˜ã« <tt>?</tt> ã‚’ãƒ‘ã‚¿ãƒ³ã®ä¸­ã«ç½®ãã®ã§ã¯ãªãã€<!--ã‚€ã—ã‚-->ãƒ‘ã‚¿ãƒ³å¤‰æ•°ã®åå‰ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ãŒã€ãªãœæœ‰ç”¨ãªã®ã‹ã¯ã€å¾Œã«åˆ†ã‹ã‚‹ã ã‚ã†ã€‚
å˜ç´”ã‚¯ã‚¨ãƒªã«å¯¾ã—ã¦ã€ã‚·ã‚¹ãƒ†ãƒ ã¯ã€æŒ‡å®šã•ã‚ŒãŸãƒ‘ã‚¿ãƒ³ã«åˆè‡´ã™ã‚‹ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å†…ã®å…¨ã‚¨ãƒ³ãƒˆãƒªã‚’ç¤ºã™ã“ã¨ã«ã‚ˆã£ã¦ã€å¿œç­”ã™ã‚‹ã€‚
</p>

<p class="orig" lang="en">
A pattern can have more than one variable.  For example, the query
</p>

<p class="trans" lang="ja">
ãƒ‘ã‚¿ãƒ³ã¯ã€å¤‰æ•°ã‚’ä¸€ã¤ã‚ˆã‚Šå¤šãå«ã¿å¾—ã‚‹ã€‚ãŸã¨ãˆã°ã€ä»¥ä¸‹ã®ã‚¯ã‚¨ãƒªã¯ã€
</p>

<p class="lisp">(address ?x ?y)
</p>

<p class="orig" lang="en">will list all the employees' addresses.</p>

<p class="trans" lang="ja">
å…¨è·å“¡ã®ä½æ‰€ã‚’åˆ—æŒ™ã™ã‚‹ã ã‚ã†ã€‚
</p>

<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
| ?- address(X, Y).

X = ['Bitdiddle','Ben']
Y = ['Slumerville',['Ridge','Road'],10] ? ;

X = ['Hacker','Alyssa','P']
Y = ['Cambridge',['Mass','Ave'],78] ? ;

X = ['Fect','Cy','D']
Y = ['Cambridge',['Ames','Street'],3] ? ;

X = ['Tweakit','Lem','E']
Y = ['Boston',['Bay','State','Road'],22] ? ;

X = ['Reasoner','Louis']
Y = ['Slumerville',['Pine','Tree','Road'],80] ? ;

X = ['Warbucks','Oliver']
Y = ['Swellesley',['Top','Heap','Road']] ? ;

X = ['Scrooge','Eben']
Y = ['Weston',['Shady','Lane'],10] ? ;

X = ['Cratchet','Robert']
Y = ['Allston',['N','Harvard','Street'],16] ? ;

X = ['Aull','DeWitt']
Y = ['Slumerville',['Onion','Square'],5]

(1 ms) yes</p>

<p class="orig" lang="en">
A pattern can have no variables, in which case the query simply
determines whether that pattern is an entry in the data base.  If so,
there will be one match; if not, there will be no matches.</p>

<p class="trans" lang="ja">
ãƒ‘ã‚¿ãƒ³ã«å¤‰æ•°ãŒãªã„ã“ã¨ã‚‚ã‚ã‚Šå¾—ã¦ã€ãã®å ´åˆã€ã‚¯ã‚¨ãƒªã¯å˜ã«ã€ãã®ãƒ‘ã‚¿ãƒ³ãŒãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å†…ã®ã‚¨ãƒ³ãƒˆãƒªã§ã‚ã‚‹ã‹ã©ã†ã‹ã‚’åˆ¤å®šã™ã‚‹ã€‚
ã‚‚ã—ãã†ãªã‚‰<span class="note"> (ãã®ãƒ‘ã‚¿ãƒ³ãŒãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å†…ã®ã‚¨ãƒ³ãƒˆãƒªã§ã‚ã‚‹ãªã‚‰ã°)</span>ã€ä¸€ã¤ã®ä¸€è‡´ãŒã‚ã‚‹ã ã‚ã†ã—ã€ãã†ã§ãªã‘ã‚Œã°ã€ä½•ã‚‚ä¸€è‡´ãŒãªã„ã ã‚ã†ã€‚
</p>


<p class="orig" lang="en">
The same pattern variable can appear more than once in a query,
specifying that the same ``anything'' must appear in each position.
This is why variables have names.  For example,</p>

<p class="trans" lang="ja">
åŒã˜ã€Œä½•ã‹ã€ãŒå„ä½ç½®ã«ç¾ã‚Œãªãã¦ã¯ãªã‚‰ãªã„ã€ã¨æŒ‡å®šã™ã‚‹ãŸã‚ã«ã€åŒã˜ãƒ‘ã‚¿ãƒ³å¤‰æ•°ãŒã‚¯ã‚¨ãƒªå†…ã«ä¸€åº¦ã‚ˆã‚Šå¤šãç¾ã‚Œã‚‹ã“ã¨ã‚‚å¯èƒ½ã§ã‚ã‚‹ã€‚
ã“ã‚ŒãŒã€å¤‰æ•°ã«åå‰ãŒã¤ã„ã¦ã„ã‚‹ç†ç”±ã§ã‚ã‚‹ã€‚
ãŸã¨ãˆã°ã€
</p>

<p class="lisp">(supervisor ?x ?x)
</p>

<p class="orig" lang="en">finds all people who supervise themselves (though there are no such
assertions in our sample data base).</p>

<p class="trans" lang="ja">
ã¯ã€è‡ªåˆ†è‡ªèº«ã‚’æŒ‡æ®ç›£ç£ã—ã¦ã„ã‚‹ã™ã¹ã¦ã®äººãŸã¡ã‚’è¦‹ã¤ã‘ã‚‹ (ç§ãŸã¡ã®ã‚µãƒ³ãƒ—ãƒ«ãƒ»ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ã¯ãã†ã„ã†è¨€æ˜ã¯å­˜åœ¨ã—ãªã„ã‘ã‚Œã©ã‚‚)ã€‚
</p>

<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
| ?- supervisor(X, X).

no
</p>

<p class="orig" lang="en">
The query
</p>

<p class="trans" lang="ja">
ä»¥ä¸‹ã®ã‚¯ã‚¨ãƒªã¯ã€
</p>

<p class="lisp">(job ?x (computer ?type))
</p>

<p class="orig" lang="en">matches all job entries whose third item is a two-element list whose
first item is <tt>computer</tt>:</p>

<p class="trans" lang="ja">
1ç•ªç›®ã®é …ç›®ãŒ <tt>computer</tt> ã§ã‚ã‚‹ã‚ˆã†ãª2è¦ç´ ãƒªã‚¹ãƒˆã‚’3ç•ªç›®ã®é …ç›®ã¨ã—ã¦ã„ã‚‹ã€ã™ã¹ã¦ã®ä»•äº‹ã‚¨ãƒ³ãƒˆãƒªã«ã€åˆè‡´ã™ã‚‹ã€‚
</p>

<p class="lisp">(job (Bitdiddle Ben) (computer wizard))
(job (Hacker Alyssa P) (computer programmer))
(job (Fect Cy D) (computer programmer))
(job (Tweakit Lem E) (computer technician))
</p>

<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
| ?- job(X, [computer, Type]).

Type = wizard
X = ['Bitdiddle','Ben'] ? ;

Type = programmer
X = ['Hacker','Alyssa','P'] ? ;

Type = programmer
X = ['Fect','Cy','D'] ? ;

Type = technician
X = ['Tweakit','Lem','E'] ? ;

(1 ms) no
</p>

<p class="orig" lang="en">This same pattern does <em>not</em> match
</p>

<p class="trans" lang="ja">
ã“ã®åŒã˜ãƒ‘ã‚¿ãƒ³ã¯ã€ä»¥ä¸‹ã®ã‚‚ã®ã«ã¯åˆè‡´<em>ã—ãªã„</em>ã€‚
</p>

<p class="lisp">(job (Reasoner Louis) (computer programmer trainee))
</p>



<p class="orig" lang="en">because the third item in the entry is a list of three elements, and
the pattern's third item specifies that there should be two elements.
If we wanted to change the pattern so that the third item could be any
list beginning with <tt>computer</tt>, we could specify<a name="%_idx_5116"></a><a name="call_footnote_Temp_651" href="#footnote_Temp_651"><sup><small>62</small></sup></a></p>

<p class="trans" lang="ja">
ãªãœãªã‚‰ã€ã“ã®ã‚¨ãƒ³ãƒˆãƒªã®3ç•ªç›®ã®é …ç›®ã¯ã€3å€‹ã®è¦ç´ ã‹ã‚‰ãªã‚‹ãƒªã‚¹ãƒˆã§ã‚ã‚Šã€ã‹ã¤ã€ä¸Šè¨˜ãƒ‘ã‚¿ãƒ³ã®3ç•ªç›®ã®é …ç›®ã¯ã€2å€‹ã®è¦ç´ ãŒã‚ã‚‹ã¹ãæ—¨ã‚’æŒ‡å®šã—ã¦ã„ã‚‹ã‹ã‚‰ã§ã‚ã‚‹ã€‚
ã‚‚ã—ã€3ç•ªç›®ã®é …ç›®ãŒ <tt>computer</tt> ã‹ã‚‰å§‹ã¾ã‚‹ä»»æ„ã®ãƒªã‚¹ãƒˆã§ã‚ã£ã¦ã‚‚ã‚ˆã„ã‚ˆã†ã«ã€ãƒ‘ã‚¿ãƒ³ã‚’å¤‰æ›´ã—ãŸã‹ã£ãŸã‚‰ã€æ¬¡ã®ã‚ˆã†ã«æŒ‡å®šã§ãã‚‹ã ã‚ã†<a href="#footnote_Temp_651"><sup><small>62</small></sup></a>ã€‚
</p>

<p class="lisp">(job ?x (computer . ?type))
</p>

<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
| ?- job(X, [computer | Type]).

Type = [wizard]
X = ['Bitdiddle','Ben'] ? ;

Type = [programmer]
X = ['Hacker','Alyssa','P'] ? ;

Type = [programmer]
X = ['Fect','Cy','D'] ? ;

Type = [technician]
X = ['Tweakit','Lem','E'] ? ;

Type = [programmer,trainee]
X = ['Reasoner','Louis'] ? ;

no</p>

<p class="orig" lang="en">For example,
</p>

<p class="trans" lang="ja">
ãŸã¨ãˆã°ã€
</p>

<p class="lisp">(computer . ?type)
</p>

<p class="orig" lang="en">matches the data</p>

<p class="trans" lang="ja">
ã¯ã€æ¬¡ã®ãƒ‡ãƒ¼ã‚¿ã«åˆè‡´ã—ã€
</p>

<p class="lisp">(computer programmer trainee)
</p>


<p class="orig" lang="en">with <tt>?type</tt> as the list <tt>(programmer trainee)</tt>.  It also
matches the data</p>

<p class="trans" lang="ja">
ãã®éš›ã€<tt>?type</tt> ã¯ <tt>(programmer trainee)</tt> ã¨ã„ã†ãƒªã‚¹ãƒˆã§ã‚ã‚‹ã€‚
ã“ã‚Œã¯ã€æ¬¡ã®ãƒ‡ãƒ¼ã‚¿ã«ã‚‚åˆè‡´ã—ã€
</p>

<p class="lisp">(computer programmer)
</p>

<p class="orig" lang="en">with <tt>?type</tt> as the list <tt>(programmer)</tt>, and matches the data</p>

<p class="trans" lang="ja">
ãã®éš›ã€<tt>?type</tt> ã¯ <tt>(programmer)</tt> ã¨ã„ã†ãƒªã‚¹ãƒˆã§ã‚ã‚‹ã€‚ã¾ãŸã€ä»¥ä¸‹ã®ãƒ‡ãƒ¼ã‚¿ã«ã‚‚åˆè‡´ã—ã€
</p>

<p class="lisp">(computer)
</p>

<p class="orig" lang="en">
with <tt>?type</tt> as the empty list <tt>()</tt>.
</p>

<p class="trans" lang="ja">
ãã®éš›ã€<tt>?type</tt> ã¯ç©ºãƒªã‚¹ãƒˆ <tt>()</tt> ã§ã‚ã‚‹ã€‚
</p>


<p class="orig" lang="en">
We can describe the query language's processing of simple queries as
follows:</p>

<p class="trans" lang="ja">
ã“ã®ã‚¯ã‚¨ãƒªè¨€èªã®ã€å˜ç´”ã‚¯ã‚¨ãƒªã®å‡¦ç†ã¯ã€æ¬¡ã®ã‚ˆã†ã«è¨˜è¿°ã§ãã‚‹ã€‚
</p>


<ul class="orig" lang="en">
<li>The system finds all assignments to variables in the query
<a name="%_idx_5118"></a>pattern that <em>satisfy</em> the pattern -- that is, all sets of values
for the variables such that if the pattern variables are <a name="%_idx_5120"></a><em>instantiated with</em> (replaced by) the values, the result is in the data
base.</li>

<li>The system responds to the query by listing all instantiations of the
query pattern with the variable assignments that satisfy it.</li>
</ul>

<ul class="trans" lang="ja">
<li>ãƒ‘ã‚¿ãƒ³ã‚’<em>æº€ãŸã™</em>ã‚ˆã†ãªã€ã‚¯ã‚¨ãƒªãƒ»ãƒ‘ã‚¿ãƒ³å†…ã®å¤‰æ•°ã¸ã®ã™ã¹ã¦ã®<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>â€”â€”ã¤ã¾ã‚Šã€ã‚‚ã—ãƒ‘ã‚¿ãƒ³å¤‰æ•°ãŒãã®å€¤<em>ã§ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã•ã‚ŒãŸ</em> (ãã®å€¤ã«ç½®ãæ›ãˆã‚‰ã‚ŒãŸ) ã¨ã—ãŸã‚‰ã€ãã®çµæœã¯ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å†…ã«ã‚ã‚‹ã‚ˆã€ã¨ã„ã†ã‚ˆã†ãªã€å¤‰æ•°ã«å¯¾ã™ã‚‹å€¤ã®é›†åˆã™ã¹ã¦â€”â€”ã‚’ã€ã‚·ã‚¹ãƒ†ãƒ ã¯è¦‹ã¤ã‘ã‚‹ã€‚</li>
<li>ã‚¯ã‚¨ãƒªãƒ»ãƒ‘ã‚¿ãƒ³ã‚’æº€ãŸã™å¤‰æ•°<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã§ã®ã€ã‚¯ã‚¨ãƒªãƒ»ãƒ‘ã‚¿ãƒ³ã®ã™ã¹ã¦ã®<ruby><rb>ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–</rb><rp> (</rp><rt>å…·ä½“ä¾‹</rt><rp>) </rp></ruby>ã‚’åˆ—æŒ™ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€ã‚·ã‚¹ãƒ†ãƒ ã¯ã‚¯ã‚¨ãƒªã«å¿œç­”ã™ã‚‹ã€‚</li>
</ul>

<p class="orig" lang="en">
Note that if the pattern has no variables, the query reduces to a
determination of whether that pattern is in the data base.  If so, the
empty assignment, which assigns no values to variables, satisfies that
pattern for that data base.</p>

<p class="trans" lang="ja">
ã‚‚ã—ãƒ‘ã‚¿ãƒ³ã«å¤‰æ•°ãŒãªã‘ã‚Œã°ã€ã‚¯ã‚¨ãƒªã¯ã€ãã®ãƒ‘ã‚¿ãƒ³ãŒãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å†…ã«ã‚ã‚‹ã‹å¦ã‹ã¨ã„ã†åˆ¤å®šã¸ã¨å¸°ç€ã™ã‚‹ã®ã ã€ã¨ã„ã†ã“ã¨ã«æ³¨æ„ã—ã¦ã»ã—ã„ã€‚
ã‚‚ã—<span class="note"> (ãã®ãƒ‘ã‚¿ãƒ³ãŒãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å†…ã«) </span>ã‚ã‚Œã°ã€ç©ºã®<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>â€”â€”å¤‰æ•°ã«ä½•ã®å€¤ã‚‚å‰²ã‚Šå½“ã¦ãªã„â€”â€”ãŒã€ãã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ã¤ã„ã¦ã®å½“è©²ãƒ‘ã‚¿ãƒ³ã‚’æº€ãŸã™ã€‚
</p>


<p class="orig" lang="en">
<a name="%_thm_4.55"></a>
<b>Exercise 4.55.</b>  Give simple queries that retrieve the following information from the
data base:</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.55.</b> ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‹ã‚‰ä»¥ä¸‹ã®æƒ…å ±ã‚’æ¤œç´¢ã™ã‚‹å˜ç´”ã‚¯ã‚¨ãƒªã‚’ç¤ºã›ã€‚
</p>

<ol class="orig alph" lang="en">
<li>all people supervised by Ben Bitdiddle;</li>
<li>the names and jobs of all people in the accounting division;</li>
<li>the names and addresses of all people who live 
in Slumerville.</li>
</ol>

<ol class="trans alph" lang="ja">
<li>ãƒ™ãƒ³ãƒ»ãƒ“ãƒƒãƒˆãƒ‡ã‚£ãƒ‰ãƒ«ã«ã‚ˆã‚ŠæŒ‡æ®ç›£ç£ã•ã‚Œã¦ã„ã‚‹ã™ã¹ã¦ã®äººãŸã¡</li>
<li>ä¼šè¨ˆéƒ¨é–€ã®ã™ã¹ã¦ã®äººãŸã¡ã®åå‰ã¨ä»•äº‹</li>
<li>ã‚¹ãƒ©ãƒãƒ¼ãƒ´ã‚£ãƒ«ã«ä½ã‚“ã§ã„ã‚‹ã™ã¹ã¦ã®äººãŸã¡ã®åå‰ã¨ä½æ‰€</li>
</ol>

<p class="exercise"><span class="ex_comment">; a</span>
(supervisor ?name (Bitdiddle Ben))</p>

<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
| ?- supervisor(Name, ['Bitdiddle', 'Ben']).

Name = ['Hacker','Alyssa','P'] ? ;

Name = ['Fect','Cy','D'] ? ;

Name = ['Tweakit','Lem','E'] ? ;

no</p>

<p class="exercise"><span class="ex_comment">; b</span>
(job ?name (accounting . ?type))</p>

<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
| ?- job(Name, [accounting | Type]).

Name = ['Scrooge','Eben']
Type = [chief,accountant] ? ;

Name = ['Cratchet','Robert']
Type = [scrivener] ? ;

(1 ms) no</p>

<p class="exercise"><span class="ex_comment">; c</span>
(address ?name (Slumerville . ?x))
</p>

<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
| ?- address(Name, ['Slumerville' | X]).

Name = ['Bitdiddle','Ben']
X = [['Ridge','Road'],10] ? ;

Name = ['Reasoner','Louis']
X = [['Pine','Tree','Road'],80] ? ;

Name = ['Aull','DeWitt']
X = [['Onion','Square'],5]

yes</p>

<a name="%_sec_Temp_653"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_653">Compound queries</a></h4>
<h4 class="trans" lang="ja">è¤‡åˆã‚¯ã‚¨ãƒª</h4>

<p class="orig" lang="en">
<a name="%_idx_5122"></a>
Simple queries form the primitive operations of the query language.
In order to form compound operations, the query language provides
means of combination.  One thing that makes the query language a logic
programming language is that the means of combination mirror the means
of combination used in forming logical expressions: <tt>and</tt>, <tt>or</tt>, and <tt>not</tt>.  (Here <tt>and</tt>, <tt>or</tt>, and <tt>not</tt> are not
the Lisp primitives, but rather operations built into the query
language.)</p>

<p class="trans" lang="ja">
å˜ç´”ã‚¯ã‚¨ãƒªã¯ã€ã‚¯ã‚¨ãƒªè¨€èªã®åŸå§‹çš„æ¼”ç®—ã‚’å½¢æˆã—ã¦ã„ã‚‹ã€‚
è¤‡åˆçš„æ¼”ç®—ã‚’å½¢æˆã™ã‚‹ãŸã‚ã«ã€ã‚¯ã‚¨ãƒªè¨€èªã¯çµåˆæ‰‹æ®µã‚’æä¾›ã™ã‚‹ã€‚
ã‚¯ã‚¨ãƒªè¨€èªã‚’è«–ç†ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªãŸã‚‰ã—ã‚ã‚‹ä¸€ã¤ã®äº‹æŸ„ã¯ã€ãã®çµåˆæ‰‹æ®µãŒã€è«–ç†å¼ã‚’å½¢æˆã™ã‚‹ã®ã«ä½¿ã‚ã‚Œã‚‹çµåˆæ‰‹æ®µâ€”â€”ã™ãªã‚ã¡ã€<tt>and</tt> ã¨ <tt>or</tt> ã¨ <tt>not</tt>â€”â€”ã‚’åæ˜ ã—ã¦ã„ã‚‹ã“ã¨ã§ã‚ã‚‹ (ã“ã“ã§ã® <tt>and</tt> ã¨ <tt>or</tt> ã¨ <tt>not</tt> ã¯ã€Lispã®ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã§ã¯ãªãã¦ã€ã‚¯ã‚¨ãƒªè¨€èªã«çµ„ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹æ¼”ç®—ã§ã‚ã‚‹)ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_5124"></a>We can use <tt>and</tt> as follows to find the addresses of all the
computer programmers:</p>

<p class="trans" lang="ja">
ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ»ãƒ—ãƒ­ã‚°ãƒ©ãƒå…¨å“¡ã®ä½æ‰€ã‚’æ±‚ã‚ã‚‹ãŸã‚ã«ã€<tt>and</tt> ã‚’æ¬¡ã®ã‚ˆã†ã«ä½¿ã†ã“ã¨ãŒã§ãã‚‹ã€‚
</p>

<p class="lisp">(and (job ?person (computer programmer))
     (address ?person ?where))
</p>

<p class="orig" lang="en">The resulting output is
</p>

<p class="trans" lang="ja">
ãã®çµæœå¾—ã‚‰ã‚Œã‚‹å‡ºåŠ›ã¯ã€ä»¥ä¸‹ã®ã¨ãŠã‚Šã ã€‚
</p>

<p class="lisp">(and (job (Hacker Alyssa P) (computer programmer))
     (address (Hacker Alyssa P) (Cambridge (Mass Ave) 78)))
(and (job (Fect Cy D) (computer programmer))
     (address (Fect Cy D) (Cambridge (Ames Street) 3)))
</p>

<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
| ?- job(Person, [computer, programmer]), address(Person, Where).

Person = ['Hacker','Alyssa','P']
Where = ['Cambridge',['Mass','Ave'],78] ? ;

Person = ['Fect','Cy','D']
Where = ['Cambridge',['Ames','Street'],3] ? ;

(1 ms) no</p>

<p class="orig" lang="en"><a name="%_idx_5126"></a>In general,
</p>

<p class="trans" lang="ja">
ä¸€èˆ¬ã«ã€</p>

<p class="lisp">(and &lt;<em>query<sub>1</sub></em>&gt; &lt;<em>query<sub>2</sub></em>&gt; <tt>...</tt> &lt;<em>query<sub><em>n</em></sub></em>&gt;)
</p>

<p class="orig" lang="en">is satisfied by all sets of values for the pattern variables that
simultaneously satisfy &lt;<em>query<sub>1</sub></em>&gt; <tt>...</tt> &lt;<em>query<sub><em>n</em></sub></em>&gt;.</p>

<p class="trans" lang="ja">
ã¯ã€
&lt;<em class="en">query<sub>1</sub></em>&gt; <tt>...</tt> 
&lt;<em class="en">query<sub>n</sub></em>&gt;
ã‚’åŒæ™‚ã«æº€ãŸã™ã‚ˆã†ãªã€ãƒ‘ã‚¿ãƒ³å¤‰æ•°ã«å¯¾ã™ã‚‹å€¤ã®é›†åˆã®ã™ã¹ã¦ã«ã‚ˆã£ã¦ã€æº€ãŸã•ã‚Œã‚‹ã€‚
</p>

<p class="orig" lang="en">
As for simple queries, the system processes a compound query by
finding all assignments to the pattern variables that satisfy the
query, then displaying instantiations of the query with those values.</p>

<p class="trans" lang="ja">
å˜ç´”ã‚¯ã‚¨ãƒª<!-- ã«ã¤ã„ã¦ã¯ -->ã«ã¤ã„ã¦ã¨åŒæ§˜ã«ã€ã‚·ã‚¹ãƒ†ãƒ ã¯ã€è¤‡åˆã‚¯ã‚¨ãƒªã‚’ã€ãã®ã‚¯ã‚¨ãƒªã‚’æº€ãŸã™ãƒ‘ã‚¿ãƒ³å¤‰æ•°ã¸ã®ã™ã¹ã¦ã®<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã‚’æ±‚ã‚ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€å‡¦ç†ã—ã€ãã‚Œã‹ã‚‰ã€ãã‚Œã‚‰ã®å€¤ã‚’ä½¿ã£ã¦ã®ã‚¯ã‚¨ãƒªã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã‚’è¡¨ç¤ºã™ã‚‹ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_5128"></a>Another means of constructing compound queries is through <tt>or</tt>.
For example,</p>

<p class="trans" lang="ja">
è¤‡åˆã‚¯ã‚¨ãƒªã‚’æ§‹ç¯‰ã™ã‚‹ã‚‚ã†ä¸€ã¤ã®æ‰‹æ®µã¯ã€<tt>or</tt> ã«ã‚ˆã‚‹ã‚‚ã®ã§ã‚ã‚‹ã€‚
ãŸã¨ãˆã°ã€
</p>

<p class="lisp">(or (supervisor ?x (Bitdiddle Ben))
    (supervisor ?x (Hacker Alyssa P)))
</p>

<p class="orig" lang="en">
will find all employees supervised by Ben Bitdiddle or Alyssa P.
Hacker:</p>

<p class="trans" lang="ja">
ã¯ã€ãƒ™ãƒ³ãƒ»ãƒ“ãƒƒãƒˆãƒ‡ã‚£ãƒ‰ãƒ«ã¾ãŸã¯ã‚¢ãƒªãƒƒã‚µãƒ»Pãƒ»ãƒãƒƒã‚«ã«ã‚ˆã£ã¦æŒ‡æ®ç›£ç£ã•ã‚Œã¦ã„ã‚‹ã™ã¹ã¦ã®è·å“¡ã‚’è¦‹ã¤ã‘å‡ºã™ã ã‚ã†ã€‚
</p>

<p class="lisp">(or (supervisor (Hacker Alyssa P) (Bitdiddle Ben))
    (supervisor (Hacker Alyssa P) (Hacker Alyssa P)))
(or (supervisor (Fect Cy D) (Bitdiddle Ben))
    (supervisor (Fect Cy D) (Hacker Alyssa P)))
(or (supervisor (Tweakit Lem E) (Bitdiddle Ben))
    (supervisor (Tweakit Lem E) (Hacker Alyssa P)))
(or (supervisor (Reasoner Louis) (Bitdiddle Ben))
    (supervisor (Reasoner Louis) (Hacker Alyssa P)))
</p>

<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
| ?- supervisor(X, ['Bitdiddle', 'Ben']); supervisor(X, ['Hacker', 'Alyssa', 'P']).

X = ['Hacker','Alyssa','P'] ? ;

X = ['Fect','Cy','D'] ? ;

X = ['Tweakit','Lem','E'] ? ;

X = ['Reasoner','Louis'] ? ;

(1 ms) no</p>

<p class="orig" lang="en">In general,
</p>

<p class="trans" lang="ja">
ä¸€èˆ¬ã«ã€
</p>

<p class="lisp">(or &lt;<em>query<sub>1</sub></em>&gt; &lt;<em>query<sub>2</sub></em>&gt; <tt>...</tt> &lt;<em>query<sub><em>n</em></sub></em>&gt;)
</p>

<p class="orig" lang="en">is satisfied by all sets of values for the pattern variables that
satisfy at least one of &lt;<em>query<sub>1</sub></em>&gt; <tt>...</tt> &lt;<em>query<sub><em>n</em></sub></em>&gt;.</p>

<p class="trans" lang="ja">
ã¯ã€
&lt;<em class="en">query<sub>1</sub></em>&gt; <tt>...</tt> 
&lt;<em class="en">query<sub>n</sub></em>&gt;
ã®ã†ã¡å°‘ãªãã¨ã‚‚ä¸€ã¤ã‚’æº€ãŸã™ã‚ˆã†ãªã€ãƒ‘ã‚¿ãƒ³å¤‰æ•°ã«å¯¾ã™ã‚‹å€¤ã®é›†åˆã®ã™ã¹ã¦ã«ã‚ˆã£ã¦ã€æº€ãŸã•ã‚Œã‚‹ã€‚ 
</p>

<p class="orig" lang="en">
<a name="%_idx_5130"></a>Compound queries can also be formed with <tt>not</tt>. For example,
</p>

<p class="trans" lang="ja">
è¤‡åˆã‚¯ã‚¨ãƒªã¯ã€<tt>not</tt> ã‚’ç”¨ã„ã¦å½¢æˆã•ã‚Œã‚‹ã“ã¨ã‚‚ã‚ã‚Šå¾—ã‚‹ã€‚
ãŸã¨ãˆã°ã€
</p>

<p class="lisp">(and (supervisor ?x (Bitdiddle Ben))
     (not (job ?x (computer programmer))))
</p>

<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
| ?- supervisor(X, ['Bitdiddle', 'Ben']), \+(job(X, [computer, programmer])).

X = ['Tweakit','Lem','E'] ? ;

no</p>

<p class="orig" lang="en">finds all people supervised by Ben Bitdiddle who are not computer
programmers.  In general,</p>

<p class="trans" lang="ja">
ã¯ã€ãƒ™ãƒ³ãƒ»ãƒ“ãƒƒãƒˆãƒ‡ã‚£ãƒ‰ãƒ«ã«ã‚ˆã‚ŠæŒ‡æ®ç›£ç£ã•ã‚Œã‚‹ã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ»ãƒ—ãƒ­ã‚°ãƒ©ãƒã§ã¯ãªã„ã€ã™ã¹ã¦ã®äººãŸã¡ã‚’è¦‹ã¤ã‘å‡ºã™ã€‚
ä¸€èˆ¬ã«ã€
</p>


<p class="lisp">(not &lt;<em>query<sub>1</sub></em>&gt;)
</p>

<p class="orig" lang="en">is satisfied by all assignments to the pattern variables that do not
satisfy &lt;<em>query<sub>1</sub></em>&gt;.<a name="call_footnote_Temp_654" href="#footnote_Temp_654"><sup><small>63</small></sup></a></p>

<p class="trans" lang="ja">
ã¯ã€
&lt;<em class="en">query<sub>1</sub></em>&gt;
ã‚’æº€ãŸã•ãªã„ã‚ˆã†ãªã€ãƒ‘ã‚¿ãƒ³å¤‰æ•°ã«å¯¾ã™ã‚‹<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã®ã™ã¹ã¦ã«ã‚ˆã£ã¦ã€æº€ãŸã•ã‚Œã‚‹<a href="#footnote_Temp_654"><sup><small>63</small></sup></a>ã€‚
</p>


<p class="orig" lang="en">
<a name="%_idx_5132"></a>The final combining form is called <tt>lisp-value</tt>.  When <tt>lisp-value</tt> is the first element of a pattern, it specifies that the
next element is a Lisp predicate to be applied to the rest of the
(instantiated) elements as arguments.  In general,</p>

<p class="trans" lang="ja">
æœ€å¾Œã®çµåˆå½¢å¼ã¯ã€<tt>lisp-value</tt> ã¨å‘¼ã°ã‚Œã‚‹ã€‚
<tt>lisp-value</tt> ãŒãƒ‘ã‚¿ãƒ³ã®ç¬¬1è¦ç´ ã§ã‚ã‚‹ã¨ãã€ã“ã‚Œã¯ã€ãã®æ¬¡ã®è¦ç´ ãŒã€æ®‹ã‚Šã® (ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã•ã‚ŒãŸ) è¦ç´ ã‚’å¼•æ•°ã¨ã—ã¦é©ç”¨ã•ã‚Œã‚‹ã¹ã Lisp è¿°èªã§ã‚ã‚‹ã€ã¨ã„ã†ã“ã¨ã‚’æŒ‡å®šã—ã¦ã„ã‚‹ã€‚
ä¸€èˆ¬ã«ã€
</p>

<p class="lisp">(lisp-value &lt;<em>predicate</em>&gt; &lt;<em>arg<sub>1</sub></em>&gt; <tt>...</tt> &lt;<em>arg<sub><em>n</em></sub></em>&gt;)
</p>

<p class="orig" lang="en">will be satisfied by assignments to the pattern variables for which the
&lt;<em>predicate</em>&gt; applied to the instantiated
&lt;<em>arg<sub>1</sub></em>&gt; <tt>...</tt> &lt;<em>arg<sub><em>n</em></sub></em>&gt;
is true.  For example, to find all people whose salary is greater than
$30,000 we could write<a name="call_footnote_Temp_655" href="#footnote_Temp_655"><sup><small>64</small></sup></a></p>

<p class="trans" lang="ja">
ã¯ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã•ã‚ŒãŸ
&lt;<em class="en">arg<sub>1</sub></em>&gt; <tt>...</tt> 
&lt;<em class="en">arg<sub>n</sub></em>&gt;
ã«é©ç”¨ã•ã‚ŒãŸ
&lt;<em class="en">predicate</em>&gt; 
ãŒçœŸã¨ãªã‚‹ã‚ˆã†ãªã€ãƒ‘ã‚¿ãƒ³å¤‰æ•°ã«å¯¾ã™ã‚‹<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã«ã‚ˆã£ã¦ã€æº€ãŸã•ã‚Œã‚‹ã ã‚ã†ã€‚
ãŸã¨ãˆã°ã€çµ¦ä¸ãŒ3ä¸‡ãƒ‰ãƒ«ã‚’è¶…ãˆã‚‹ã‚ˆã†ãªã™ã¹ã¦ã®äººãŸã¡ã‚’è¦‹ã¤ã‘ã‚‹ã«ã¯ã€æ¬¡ã®ã‚ˆã†ã«æ›¸ã‘ã‚‹ã ã‚ã†<a href="#footnote_Temp_655"><sup><small>64</small></sup></a>ã€‚
</p>

<p class="lisp">(and (salary ?person ?amount)
     (lisp-value &gt; ?amount 30000))
</p>

<p class="extra_code"><span class="ex_comment">% Prolog ã§æ“¬ä¼¼çš„ã«çœŸä¼¼ã™ã‚‹ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
| ?- salary(Person, Amount), Amount > 30000.

Amount = 60000
Person = ['Bitdiddle','Ben'] ? ;

Amount = 40000
Person = ['Hacker','Alyssa','P'] ? ;

Amount = 35000
Person = ['Fect','Cy','D'] ? ;

Amount = 150000
Person = ['Warbucks','Oliver'] ? ;

Amount = 75000
Person = ['Scrooge','Eben'] ? ;

(1 ms) no</p>

<p class="orig" lang="en">
<a name="%_thm_4.56"></a>
<b>Exercise 4.56.</b>  Formulate compound queries that retrieve the following information:</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.56.</b> ä»¥ä¸‹ã®æƒ…å ±ã‚’æ¤œç´¢ã™ã‚‹è¤‡åˆã‚¯ã‚¨ãƒªã‚’å®šå¼åŒ–ã›ã‚ˆã€‚
</p>

<ol class="orig alph" lang="en">
<li>the names of all people who are supervised by Ben Bitdiddle, together
with their addresses;</li>

<li>all people whose salary is less than Ben Bitdiddle's, together with
their salary and Ben Bitdiddle's salary;</li>

<li>all people who are supervised by someone who is not in the computer
division, together with the supervisor's name and job.</li>
</ol>

<ol class="trans alph" lang="ja">
<li>ãƒ™ãƒ³ãƒ»ãƒ“ãƒƒãƒˆãƒ‡ã‚£ãƒ‰ãƒ«ã«ã‚ˆã‚ŠæŒ‡æ®ç›£ç£ã•ã‚Œã¦ã„ã‚‹ã™ã¹ã¦ã®äººãŸã¡ã®åå‰ã‚’ã€ãã®äººãŸã¡ã®ä½æ‰€ã¨ä¸€ç·’ã«ã€‚</li>
<li>ãƒ™ãƒ³ãƒ»ãƒ“ãƒƒãƒˆãƒ‡ã‚£ãƒ‰ãƒ«ã‚ˆã‚Šã‚‚çµ¦ä¸ãŒä½ã„ã™ã¹ã¦ã®äººãŸã¡ã‚’ã€ãã®äººãŸã¡ã®çµ¦ä¸ãŠã‚ˆã³ãƒ™ãƒ³ãƒ»ãƒ“ãƒƒãƒˆãƒ‡ã‚£ãƒ‰ãƒ«ã®çµ¦ä¸ã¨ä¸€ç·’ã«ã€‚</li>
<li>ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿éƒ¨é–€ã«ã„ãªã„èª°ã‹ã«ã‚ˆã£ã¦æŒ‡æ®ç›£ç£ã•ã‚Œã¦ã„ã‚‹ã™ã¹ã¦ã®äººãŸã¡ã‚’ã€<!-- ä¸Šå¸ -->æŒ‡æ®ç›£ç£è€…ã®åå‰ãŠã‚ˆã³ä»•äº‹ã¨ä¸€ç·’ã«ã€‚</li>
</ol>

<p class="exercise"><span class="ex_comment">; a</span>
(and (supervisor ?who (Bitdiddle Ben))
     (address ?who ?where))</p>

<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
| ?- supervisor(Who, ['Bitdiddle', 'Ben']), address(Who, Where).

Where = ['Cambridge',['Mass','Ave'],78]
Who = ['Hacker','Alyssa','P'] ? ;

Where = ['Cambridge',['Ames','Street'],3]
Who = ['Fect','Cy','D'] ? ;

Where = ['Boston',['Bay','State','Road'],22]
Who = ['Tweakit','Lem','E'] ? ;

(1 ms) no</p>

<p class="exercise"><span class="ex_comment">; b</span>
(and (salary ?person ?amount)
     (salary (Bitdiddle Ben) ?amount-of-Ben)
     (lisp-value &lt; ?amount ?amount-of-Ben))</p>

<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
| ?- salary(Person, Amount), salary(['Bitdiddle', 'Ben'], Amount_of_Ben), Amount < Amount_of_Ben.

Amount = 40000
Amount_of_Ben = 60000
Person = ['Hacker','Alyssa','P'] ? ;

Amount = 35000
Amount_of_Ben = 60000
Person = ['Fect','Cy','D'] ? ;

Amount = 25000
Amount_of_Ben = 60000
Person = ['Tweakit','Lem','E'] ? ;

Amount = 30000
Amount_of_Ben = 60000
Person = ['Reasoner','Louis'] ? ;

Amount = 18000
Amount_of_Ben = 60000
Person = ['Cratchet','Robert'] ? ;

Amount = 25000
Amount_of_Ben = 60000
Person = ['Aull','DeWitt'] ? ;

(1 ms) no</p>

<p class="exercise"><span class="ex_comment">; c</span>
(and (supervisor ?who ?boss)
     (not (job ?boss (computer . ?x)))
     (job ?boss ?job-of-boss))

<span class="ex_comment">; ä»¥ä¸‹ã®ã‚ˆã†ã«æ›¸ããŸããªã‚‹ãŒã€
;ã€Œç­‰ä¾¡æ€§ã®æ¤œæŸ»ã« lisp-value ã‚’ä½¿ã†ãªã€ã¨<a  href="#footnote_Temp_655">è„šæ³¨64</a>ã«ã‚ã‚‹ã®ã§ã€
; ä¸Šè¨˜ã®ã‚ˆã†ãªå›ç­”æ¡ˆã«ã—ã¦ã¿ãŸã€‚</span>
(and (supervisor ?who ?boss)
     (job ?boss (?division ?job-detail))
     (not (lisp-value = ?division 'computer)))
</p>

<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
| ?- supervisor(Who, Boss), \+(job(Boss, [computer | X])), job(Boss, Job_of_Boss).

Boss = ['Warbucks','Oliver']
Job_of_Boss = [administration,big,wheel]
Who = ['Bitdiddle','Ben'] ? ;

Boss = ['Warbucks','Oliver']
Job_of_Boss = [administration,big,wheel]
Who = ['Scrooge','Eben'] ? ;

Boss = ['Scrooge','Eben']
Job_of_Boss = [accounting,chief,accountant]
Who = ['Cratchet','Robert'] ? ;

Boss = ['Warbucks','Oliver']
Job_of_Boss = [administration,big,wheel]
Who = ['Aull','DeWitt'] ? ;

(1 ms) no</p>

<a name="%_sec_Temp_657"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_657">Rules</a></h4>
<h4 class="trans" lang="ja">è¦å‰‡</h4>


<p class="orig" lang="en">
<a name="%_idx_5136"></a>
<a name="%_idx_5138"></a>In addition to primitive queries and compound queries, the query
language provides means for abstracting queries.  These are given by
<em>rules</em>.  The rule</p>

<p class="trans" lang="ja">
åŸå§‹çš„ã‚¯ã‚¨ãƒªã¨è¤‡åˆã‚¯ã‚¨ãƒªã«åŠ ãˆã¦ã€ã‚¯ã‚¨ãƒªè¨€èªã¯ã€ã‚¯ã‚¨ãƒªã‚’æŠ½è±¡åŒ–ã™ã‚‹æ‰‹æ®µã‚’æä¾›ã™ã‚‹ã€‚
ã“ã‚Œã‚‰ã¯ã€<em>è¦å‰‡</em>ã«ã‚ˆã‚Šä¸ãˆã‚‰ã‚Œã‚‹ã€‚
ä»¥ä¸‹ã®è¦å‰‡ã¯ã€
</p>

<p class="lisp"><a name="%_idx_5140"></a>(rule (lives-near ?person-1 ?person-2)
      (and (address ?person-1 (?town . ?rest-1))
           (address ?person-2 (?town . ?rest-2))
           (not (same ?person-1 ?person-2))))
</p>

<p class="orig" lang="en">specifies that two people live near each other if they live in the
same town.  The final <tt>not</tt> clause prevents the rule from saying
that all people live near themselves.  The <tt>same</tt> relation is
defined by a very simple rule:<a name="call_footnote_Temp_658" href="#footnote_Temp_658"><sup><small>65</small></sup></a></p>

<p class="trans" lang="ja">
äºŒäººã®äººã¯ã€ã‚‚ã—åŒã˜ç”ºã«ä½ã‚“ã§ã„ã‚Œã°ã€ãŠäº’ã„ã«è¿‘ãã«ä½ã‚“ã§ã„ã‚‹ã®ã ã€ã¨è¦å®šã—ã¦ã„ã‚‹ã€‚
æœ€å¾Œã® <tt>not</tt> ç¯€ã¯ã€ã™ã¹ã¦ã®äººã¯è‡ªåˆ†ã®è¿‘ãã«ä½ã‚“ã§ã„ã‚‹ã€ã¨è¦å‰‡ãŒè¿°ã¹ã‚‹ã®ã‚’é˜²ã„ã§ã„ã‚‹ã€‚
<tt>same</tt> é–¢ä¿‚ã¯ã€ã¨ã¦ã‚‚å˜ç´”ãªè¦å‰‡ã«ã‚ˆã‚Šå®šç¾©ã•ã‚Œã‚‹<a href="#footnote_Temp_658"><sup><small>65</small></sup></a>ã€‚
</p>

<p class="lisp"><a name="%_idx_5142"></a>(rule (same ?x ?x))
</p>

<p class="extra_code"><span class="ex_comment">% ä¸Šè¨˜ã®äºŒã¤ã®è¦å‰‡ã¯ã€Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
lives_near(Person_1, Person_2) :- 
    address(Person_1, [Town | Rest_1]),
    address(Person_2, [Town | Rest_2]),
    \+(same(Rest_1, Rest_2)).
same(X, X).
</p>

<p class="orig" lang="en">
The following rule declares that a person is a ``wheel'' in an
organization if he supervises someone who is in turn a supervisor:</p>

<p class="trans" lang="ja">
ä»¥ä¸‹ã®è¦å‰‡ã¯ã€æ¬¡ã®ã‚ˆã†ã«å®£è¨€ã—ã¦ã„ã‚‹ã€‚ã™ãªã‚ã¡ã€äººã¯ã€ã‚‚ã—èª°ã‹ã‚’æŒ‡æ®ç›£ç£ã—ã¦ã„ã¦ã€ãã®èª°ã‹ãŒã¾ãŸã•ã‚‰ã«æŒ‡æ®ç›£ç£è€…ã§ã‚ã‚‹ãªã‚‰ã°ã€çµ„ç¹”ã«ãŠã‘ã‚‹ã€Œå¤§ç‰©ã€ã§ã‚ã‚‹ã€ã¨ã€‚
</p>

<p class="lisp"><a name="%_idx_5144"></a>(rule (wheel ?person)
      (and (supervisor ?middle-manager ?person)
           (supervisor ?x ?middle-manager)))
</p>

<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
wheel(Person) :- 
    supervisor(Middle_manager, Person), 
    supervisor(X, Middle_manager).
</p>

<p class="orig" lang="en">
The general form of a rule is
</p>

<p class="trans" lang="ja">
è¦å‰‡ã®ä¸€èˆ¬å½¢ã¯ã€
</p>

<p class="lisp">(rule &lt;<em>conclusion</em>&gt; &lt;<em>body</em>&gt;)
</p>

<p class="orig" lang="en">where &lt;<em>conclusion</em>&gt; is a pattern and &lt;<em>body</em>&gt; is any
query.<a name="call_footnote_Temp_659" href="#footnote_Temp_659"><sup><small>66</small></sup></a> We can think
of a rule as representing a large (even infinite) set of assertions,
namely all instantiations of the rule conclusion with variable
assignments that satisfy the rule body.  When we described simple
queries (patterns), we said that an assignment to variables satisfies
a pattern if the instantiated pattern is in the data base.  But the
pattern needn't be explicitly in the data base as an assertion.  It
<a name="%_idx_5148"></a>can be an implicit assertion implied by a rule.  For example, the
query
</p>

<p class="trans" lang="ja">
ã§ã‚ã‚Šã€ã“ã“ã§ã€&lt;<em class="en">conclusion</em>&gt; (å¸°çµéƒ¨) ã¯ãƒ‘ã‚¿ãƒ³ã§ã‚ã‚Šã€&lt;<em class="en">body</em>&gt; (æœ¬ä½“) ã¯ä»»æ„ã®ã‚¯ã‚¨ãƒªã§ã‚ã‚‹<a href="#footnote_Temp_659"><sup><small>66</small></sup></a>ã€‚
è¦å‰‡ã®ã“ã¨ã‚’ã€è¨€æ˜ã®å¤šæ•°é€šã‚Šã® (ç„¡é™é€šã‚Šã§ã•ãˆã‚ã‚‹) çµ„â€”â€”ã™ãªã‚ã¡ã€è¦å‰‡æœ¬ä½“ã‚’æº€ãŸã™ã‚ˆã†ãªå¤‰æ•°<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã§ã®ã€è¦å‰‡å¸°çµéƒ¨ã®ã™ã¹ã¦ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–â€”â€”ã‚’è¡¨ã—ã¦ã„ã‚‹ã‚‚ã®ã¨ã€è¦‹ãªã™ã“ã¨ãŒå¯èƒ½ã§ã‚ã‚‹ã€‚
å˜ç´”ã‚¯ã‚¨ãƒª (ãƒ‘ã‚¿ãƒ³) ã‚’èª¬æ˜ã—ãŸã¨ãã«ã€ç§ãŸã¡ã¯ã€ã‚‚ã—ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã•ã‚ŒãŸãƒ‘ã‚¿ãƒ³ãŒãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å†…ã«ã‚ã‚Œã°ã€å¤‰æ•°ã¸ã®<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã¯ãƒ‘ã‚¿ãƒ³ã‚’æº€ãŸã™ã€ã¨è¨€ã£ãŸã€‚
ã—ã‹ã—ã€ãƒ‘ã‚¿ãƒ³ã¯ã€è¨€æ˜ã®ã‚ˆã†ã«æ˜ç¤ºçš„ã«ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å†…ã«ã‚ã‚‹å¿…è¦ã¯ãªã„ã€‚
ãã‚Œã¯ã€è¦å‰‡ã«ã‚ˆã£ã¦æš—ç¤ºã•ã‚Œã‚‹æš—é»™çš„ãªè¨€æ˜ã§ã‚ã‚Šå¾—ã‚‹ã€‚
ãŸã¨ãˆã°ã€ä»¥ä¸‹ã®ã‚¯ã‚¨ãƒªã¯ã€
</p>

<p class="lisp">(lives-near ?x (Bitdiddle Ben))
</p>

<p class="orig" lang="en">results in
</p>

<p class="trans" lang="ja">
ä»¥ä¸‹ã®ã‚ˆã†ãªçµæœã«ãªã‚‹ã€‚
</p>

<p class="lisp">(lives-near (Reasoner Louis) (Bitdiddle Ben))
(lives-near (Aull DeWitt) (Bitdiddle Ben))
</p>

<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
| ?- lives_near(X, ['Bitdiddle', 'Ben']).

X = ['Reasoner','Louis'] ? ;

X = ['Aull','DeWitt'] ? ;

(1 ms) no
</p>

<p class="orig" lang="en">To find all computer programmers who live near Ben Bitdiddle, we can
ask
</p>

<p class="trans" lang="ja">
ãƒ™ãƒ³ãƒ»ãƒ“ãƒƒãƒˆãƒ‡ã‚£ãƒ‰ãƒ«ã®è¿‘ãã«ä½ã‚“ã§ã„ã‚‹ã™ã¹ã¦ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒã‚’è¦‹ã¤ã‘ã‚‹ãŸã‚ã«ã€æ¬¡ã®ã‚ˆã†ã«å°‹ã­ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
</p>

<p class="lisp">(and (job ?x (computer programmer))
     (lives-near ?x (Bitdiddle Ben)))
</p>

<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
| ?- job(X, [computer, programmer]), lives_near(X, ['Bitdiddle', 'Ben']).

no
</p>

<p class="orig" lang="en">
<a name="%_idx_5150"></a>As in the case of compound procedures, rules can be used as parts of
other rules (as we saw with the <tt>lives-near</tt> rule above)
or even be defined recursively.  For instance, the rule
</p>

<p class="trans" lang="ja">
è¤‡åˆæ‰‹ç¶šãã®å ´åˆã¨åŒæ§˜ã«ã€è¦å‰‡ã‚’ã€(ä¸Šè¨˜ã® <tt>lives-near</tt> ã®è¦å‰‡ã«ã¤ã„ã¦è¦‹ãŸã¨ãŠã‚Š) ä»–ã®è¦å‰‡ã®ä¸€éƒ¨ã¨ã—ã¦ä½¿ã†ã“ã¨ãŒã§ãã‚‹ã—ã€ã‚ã‚‹ã„ã¯ã€å†å¸°çš„ã«å®šç¾©ã™ã‚‹ã“ã¨ã™ã‚‰ã§ãã‚‹ã€‚
ãŸã¨ãˆã°ã€æ¬¡ã®è¦å‰‡ã¯ã€
</p>

<p class="lisp"><a name="%_idx_5152"></a>(rule (outranked-by ?staff-person ?boss)
      (or (supervisor ?staff-person ?boss)
          (and (supervisor ?staff-person ?middle-manager)
               (outranked-by ?middle-manager ?boss))))
</p>

<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
outranked_by(Staff_person, Boss) :-
    supervisor(Staff_person, Boss);
    (supervisor(Staff_person, Middle_manager), 
     outranked_by(Middle_manager, Boss)).
</p>

<p class="orig" lang="en">says that a staff person is outranked by a boss in the organization if
the boss is the person's supervisor or (recursively) if the person's
supervisor is outranked by the boss.</p>

<p class="trans" lang="ja">
çµ„ç¹”å†…ã§ã¯ã€ã‚ã‚‹è·å“¡ã¨ä¸Šå½¹ã«ã¤ã„ã¦ã€ãã®ä¸Šå½¹ãŒãã®è·å“¡ã®æŒ‡æ®ç›£ç£è€…ã§ã‚ã‚‹å ´åˆã€ã¾ãŸã¯ã€(å†å¸°çš„ã«) ãã®è·å“¡ã®æŒ‡æ®ç›£ç£è€…ã‚ˆã‚Šã‚‚ãã®ä¸Šå½¹ã®æ–¹ãŒé«˜ã„åœ°ä½ã«ã‚ã‚‹å ´åˆã¯ã€ãã®è·å“¡ã‚ˆã‚Šã‚‚ãã®ä¸Šå½¹ã®æ–¹ãŒé«˜ã„åœ°ä½ã«ã‚ã‚‹ã€ã¨è¨€ã£ã¦ã„ã‚‹ã€‚
</p>


<p class="orig" lang="en">
<a name="%_thm_4.57"></a>
<b>Exercise 4.57.</b>  Define a rule that says that person 1 can replace person 2 if either
person 1 does the same job as person 2 or someone who does person 1's
job can also do person 2's job, and if person 1 and person 2 are not
the same person. Using your rule, give queries that find the
following:</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.57.</b> äººç‰©1 ãŒäººç‰©2 ã¨åŒã˜ä»•äº‹ã‚’ã—ã¦ã„ã‚‹ã‹ã€ã¾ãŸã¯ã€äººç‰©1 ã¨åŒã˜ä»•äº‹ã‚’ã—ã¦ã„ã‚‹èª°ã‹ãŒäººç‰©2 ã®ä»•äº‹ã‚‚ã§ãã‚‹å ´åˆã€ã‹ã¤ã€äººç‰©1 ã¨äººç‰©2 ãŒåŒä¸€äººç‰©ã§ã¯ãªã„å ´åˆã«ã€äººç‰©1 ãŒäººç‰©2 ã®ä»£ã‚ã‚Šã‚’å‹™ã‚ã‚‰ã‚Œã‚‹ã€ã¨è¿°ã¹ã‚‹è¦å‰‡ã‚’ã€å®šç¾©ã›ã‚ˆã€‚
å›ã®è¦å‰‡ã‚’ä½¿ã£ã¦ã€ä»¥ä¸‹ã®ã‚‚ã®ã‚’è¦‹ã¤ã‘ã‚‹ã‚¯ã‚¨ãƒªã‚’ç¤ºã›ã€‚
</p>

<ol class="orig alph" lang="en">
<li>all people who can replace Cy D. Fect;</li>

<li>all people who can replace someone who is being paid more than they
are, together with the two salaries.</li>
</ol>

<ol class="trans alph" lang="ja">
<li>ã‚µã‚¤ãƒ»Dãƒ»ãƒ•ã‚§ã‚¯ãƒˆã®ä»£ã‚ã‚ŠãŒã§ãã‚‹ã€ã™ã¹ã¦ã®äººãŸã¡ã€‚</li>
<li>è‡ªåˆ†ã‚ˆã‚Šé«˜ã„çµ¦ä¸ã‚’ã‚‚ã‚‰ã£ã¦ã„ã‚‹èª°ã‹ã®ä»£ã‚ã‚Šã‚’å‹™ã‚ã‚‰ã‚Œã‚‹ã€ã™ã¹ã¦ã®äººãŸã¡ã‚’ã€ãã‚Œã‚‰äºŒäººã®çµ¦ä¸ã¨ã¨ã‚‚ã«ã€‚</li>
</ol>

<p class="exercise"><span class="ex_comment">; è¦å‰‡ã®å®šç¾©</span>
(rule (can-replace ?persson1 ?person2)
  (and
    (or
       <span class="ex_comment">; äººç‰©1 ã¨äººç‰©2 ãŒåŒã˜ä»•äº‹ (?job1) ã‚’ã—ã¦ã„ã‚‹ã€‚</span>
      (and (job ?person1 ?job1) (job ?person2 ?job1))
       <span class="ex_comment">; äººç‰©1 ãŒã—ã¦ã„ã‚‹ä»•äº‹ (?job1) ã‚’ã—ã¦ã„ã‚‹äººã¯ä¸€èˆ¬çš„ã«ã€</span>
       <span class="ex_comment">; äººç‰©2 ãŒã—ã¦ã„ã‚‹ä»•äº‹ (?job2) ã‚’è¡Œã†ã“ã¨ãŒå¯èƒ½ã§ã‚ã‚‹ã€‚</span>
      (and (job ?person1 ?job1) (job ?person2 ?job2) (can-do-job ?job1 ?job2)))
     <span class="ex_comment">; äººç‰©1 ã¨äººç‰©2 ã¯åˆ¥äººã§ã‚ã‚‹ã€‚</span>
    (not (same ?person1 ?person2))))
</p>

<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
can_replace(Person1, Person2) :-
    ( (job(Person1, Job1), job(Person2, Job1)) ;
      (job(Person1, Job1), job(Person2, Job2), can_do_job(Job1, Job2)) ),
    \+(same(Person1, Person2)).
</p>

<p class="exercise"><span class="ex_comment">; a</span>
(can-replace ?who (Fect Cy D))
</p>
<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
| ?- can_replace(Who, ['Fect', 'Cy', 'D']).

Who = ['Hacker','Alyssa','P'] ? ;

Who = ['Bitdiddle','Ben'] ? ;

no
</p>

<p class="exercise"><span class="ex_comment">; b</span>
(and (can-replace ?who ?more-paid-person)
     (salary ?who ?s1) (salary ?more-paid-person ?s2)
     (lisp-value &lt; ?s1 ?s2))
</p>
<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
| ?- can_replace(Who, More_Paid_Person), salary(Who, S1), salary(More_Paid_Person, S2), S1 < S2.

More_Paid_Person = ['Hacker','Alyssa','P']
S1 = 35000
S2 = 40000
Who = ['Fect','Cy','D'] ? ;

More_Paid_Person = ['Warbucks','Oliver']
S1 = 25000
S2 = 150000
Who = ['Aull','DeWitt'] ? ;

(1 ms) no
</p>

<p class="orig" lang="en">
<a name="%_thm_4.58"></a>
<b>Exercise 4.58.</b>  Define a rule that says that a person is a ``big shot'' in a division
if the person works in the division but does not have a supervisor who
works in the division.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.58.</b> ã‚‚ã—ã€ã‚ã‚‹äººãŒã‚ã‚‹éƒ¨é–€ã§åƒã„ã¦ã„ã‚‹ã‚‚ã®ã®ã€å½“äººã«ã¯å½“è©²éƒ¨é–€ã§åƒãæŒ‡æ®ç›£ç£è€…ãŒã„ãªã‘ã‚Œã°ã€ãã®äººã¯å½“è©²éƒ¨é–€ã«ãŠã‘ã‚‹ã€ŒãŠå‰æ–¹ã€ã§ã‚ã‚‹ã€ã¨è¿°ã¹ã‚‹è¦å‰‡ã‚’ã€å®šç¾©ã›ã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment">; äºŒã¤ã®å ´åˆãŒã‚ã‚‹ã®ã§ã€äºŒã¤ã®è¦å‰‡ã«åˆ†ã‘ã¦è¨˜è¿°ã™ã‚‹ã€‚

; ã‚ã‚‹äºº (?who) ã«ã¯æŒ‡æ®ç›£ç£è€… (?supervisor) ãŒã„ã‚‹ã‘ã‚Œã©ã€æŒ‡æ®ç›£ç£è€…ã¯åˆ¥éƒ¨é–€ã«å±ã—ã¦ã„ã‚‹ã€‚</span>
(rule (is-big-shot ?who ?division1)
  (and (job ?who (?division1 . ?j1))
       (supervisor ?who ?supervisor)
       (job ?supervisor (?division2 . ?j2))
       (not (same ?divison1 ?division2))))

<span class="ex_comment">; ã‚ã‚‹äºº (?who) ã¯å®Ÿåœ¨ã—ã¦ã„ã¦ã€ã©ã“ã‹ã®éƒ¨é–€ (?div) ã§åƒã„ã¦ã„ã‚‹ã®ã ãŒã€
; ãã‚‚ãã‚‚ã“ã®äººã«ã¯ (åŒéƒ¨é–€ã§ã‚ã‚Œåˆ¥éƒ¨é–€ã§ã‚ã‚Œ) æŒ‡æ®ç›£ç£è€… (?someone-else)ãªã©ã„ãªã„ã€‚</span>
(rule (is-big-shot ?who ?div)
  (and (job ?who (?div . ?j)) (not (supervisor ?who ?someone-else))))
</p>
<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
is_big_shot(Who, Division1) :-
    job(Who, [Division1 |_]), supervisor(Who, Supervisor),
    job(Supervisor, [Division2 |_]), \+(same(Division1, Division2)).
is_big_shot(Who, Div) :-
    job(Who, [Div |_]), \+(supervisor(Who, Someone_else)).

<span class="ex_comment">% ã‚¯ã‚¨ãƒªã‚’å®Ÿè¡Œã—ã¦ã¿ã‚‹ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
| ?- is_big_shot(Who, Div).

Div = computer
Who = ['Bitdiddle','Ben'] ? ;

Div = accounting
Who = ['Scrooge','Eben'] ? ;

Div = administration
Who = ['Warbucks','Oliver'] ? ;

no
</p>

<p class="orig" lang="en">
<a name="%_thm_4.59"></a>
<b>Exercise 4.59.</b>  Ben Bitdiddle has missed one meeting too many.
Fearing that his habit of forgetting meetings could cost him his
job, Ben decides to do something about it.  He adds all the weekly
meetings of the firm to the Microshaft data base by
asserting the following:
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.59.</b> ãƒ™ãƒ³ãƒ»ãƒ“ãƒƒãƒˆãƒ‡ã‚£ãƒ‰ãƒ«ã¯ã€ã“ã‚Œã¾ã§ä¼šè­°ã«å‡ºå¸­ã—ãã“ã­ã‚‹ã“ã¨ãŒã¡ã‚‡ã£ã¨å¤šã™ããŸã€‚
ä¼šè­°ã‚’å¿˜ã‚Œã‚‹ã¨ã„ã†è‡ªåˆ†ã®ç™–ã¯ã€å„ä»‹äº‹ã‚’è‡ªåˆ†ã«ã‚‚ãŸã‚‰ã—ã‹ã­ãªã„ã€ã¨æ‡¸å¿µã—ã¦ã€ãƒ™ãƒ³ã¯ã€ã“ã‚Œã«é–¢ã—ã¦ä½•ã‹ã—ã‚ˆã†ã€ã¨æ±ºæ„ã™ã‚‹ã€‚
ä»¥ä¸‹ã®ã‚ˆã†ã«è¨€æ˜ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€å½¼ã¯ã€ä¼šç¤¾ã®æ¯é€±ã®ä¼šè­°ã‚’ã™ã¹ã¦ã€ãƒã‚¤ã‚¯ãƒ­ã‚·ãƒ£ãƒ•ãƒˆç¤¾ã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«åŠ ãˆã‚‹ã€‚
</p>

<p class="lisp">(meeting accounting (Monday 9am))
(meeting administration (Monday 10am))
(meeting computer (Wednesday 3pm))
(meeting administration (Friday 1pm))
</p>
<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
meeting(accounting, ['Monday', '9am']).
meeting(administration, ['Monday', '10am']).
meeting(computer, ['Wednesday', '3pm']).
meeting(administration, ['Friday', '1pm']).
</p>

<p class="orig" lang="en">Each of the above assertions is for a meeting of an entire division.
Ben also adds an entry for the company-wide meeting that spans all the
divisions.  All of the company's employees attend this meeting.
</p>

<p class="trans" lang="ja">
ä¸Šè¨˜ã®è¨€æ˜ã®ãã‚Œãã‚Œã¯ã€éƒ¨é–€å…¨ä½“ã®ä¼šè­°ã«ã¤ã„ã¦ã®ã‚‚ã®ã§ã‚ã‚‹ã€‚
ãƒ™ãƒ³ã¯ã€å…¨éƒ¨é–€ã«ã¾ãŸãŒã‚‹å…¨ç¤¾çš„ä¼šè­°ã«ã¤ã„ã¦ã®ã‚¨ãƒ³ãƒˆãƒªã‚‚åŠ ãˆã‚‹ã€‚
ä¼šç¤¾ã®å…¨å¾“æ¥­å“¡ãŒã“ã®ä¼šè­°ã«å‡ºå¸­ã™ã‚‹ã€‚
</p>

<p class="lisp">(meeting whole-company (Wednesday 4pm))
</p>
<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
meeting(whole_company, ['Wednesday', '4pm']).
</p>

<ol class="orig alph" lang="en">
<li>On Friday morning, Ben wants to query the data base for all the meetings
that occur that day.  What query should he use?</li>
</ol>

<ol class="trans alph" lang="ja">
<li>é‡‘æ›œæ—¥ã®æœã€ãƒ™ãƒ³ã¯ã€ãã®æ—¥ã«ã‚ã‚‹å…¨éƒ¨ã®ä¼šè­°ã«ã¤ã„ã¦ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«è³ªå•ã—ãŸã„ã¨æ€ã†ã€‚
å½¼ã¯ã©ã®ã‚ˆã†ãªã‚¯ã‚¨ãƒªã‚’ä½¿ã†ã¹ãã ã‚ã†?</li>
</ol>

<p class="exercise">(meeting ?div (Friday ?time))</p>
<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
| ?- meeting(Div, ['Friday', Time]).

Div = administration
Time = '1pm' ? ;

no
</p>

<ol class="orig alph" start="2" lang="en">
<li>Alyssa P. Hacker is unimpressed.  She thinks it would be much more
useful to be able to ask for her meetings by specifying her name.  So
she designs a rule that says that a person's meetings include all <tt>whole-company</tt> meetings plus all meetings of that person's division.
Fill in the body of Alyssa's rule.</li>
</ol>

<ol class="trans alph" start="2" lang="ja">
<li>ã‚¢ãƒªãƒƒã‚µãƒ»Pãƒ»ãƒãƒƒã‚«ã¯ã€æ„Ÿå¿ƒã§ããªã„ãªã€ã¨æ€ã£ã¦ã„ã‚‹ã€‚
å½¼å¥³ã¯ã€è‡ªåˆ†ã®åå‰ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ã§è‡ªåˆ†ã®ä¼šè­°ã«ã¤ã„ã¦æ±‚ã‚ã‚‹ã“ã¨ãŒã§ãã‚Œã°ã€ã‚‚ã£ã¨ãšã£ã¨æœ‰ç”¨ã ã‚ã†ã«ã€ã¨è€ƒãˆã¦ã„ã‚‹ã€‚
ãã“ã§å½¼å¥³ã¯ã€æ¬¡ã®ã‚ˆã†ã«è¿°ã¹ã‚‹è¦å‰‡ã‚’è¨­è¨ˆã™ã‚‹ã€‚ã™ãªã‚ã¡ã€ã‚ã‚‹äººã®ä¼šè­°ã¨ã¯ã€<tt>whole-company</tt> ã®ã™ã¹ã¦ã®ä¼šè­°ã¨ã€ãã®äººã®éƒ¨é–€ã®ã™ã¹ã¦ã®ä¼šè­°ã¨ã‚’å«ã‚€ã®ã ã€ã¨ã€‚
ã‚¢ãƒªãƒƒã‚µã®è¦å‰‡ã®æœ¬ä½“ã‚’åŸ‹ã‚ã‚ˆã€‚</li>
</ol>

<p class="lisp">(rule (meeting-time ?person ?day-and-time)
      &lt;<em>rule-body</em>&gt;)
</p>

<p class="exercise">(rule (meeting-time ?person ?day-and-time)
  (or (meeting whole-company ?day-and-time)
      (and (job ?person (?division . ?x)) (meeting ?division ?day-and-time))))
</p>
<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
meeting_time(Person, Day_and_Time) :-
    meeting(whole_company, Day_and_Time) ;
    job(Person, [Division |_]), meeting(Division, Day_and_Time).
</p>

<ol class="orig alph" start="3" lang="en">
<li>Alyssa arrives at work on Wednesday morning and wonders what meetings she 
has to attend that day.  Having defined the above rule,
what query should she make to find this out?</li>
</ol>

<ol class="trans alph" start="3" lang="ja">
<li>ã‚¢ãƒªãƒƒã‚µã¯ã€æ°´æ›œæ—¥ã®æœã«è·å ´ã«ç€ãã€‚ãã—ã¦ã€ã“ã®æ—¥ã«è‡ªåˆ†ã¯ã©ã®ä¼šè­°ã«å‡ºå¸­ã›ã­ã°ãªã‚‰ãªã„ã‚“ã ã£ã‘ã€ã¨è€ƒãˆã‚‹ã€‚
ä¸Šè¨˜ã®è¦å‰‡ã‚’å®šç¾©æ¸ˆã¿ã ã¨ã—ã¦ã€å½¼å¥³ãŒã“ã‚Œã«ã¤ã„ã¦çŸ¥ã‚‹ãŸã‚ã«ã¯ã€ã©ã®ã‚ˆã†ãªã‚¯ã‚¨ãƒªã‚’ä½œã‚‹ã¹ãã ã‚ã†ã‹?</li>
</ol>

<p class="exercise"><span class="ex_comment">; ä½•æ™‚ã«ä¼šè­°ãŒã‚ã‚‹ã‹ã€ã ã‘ã§ãªãã¦ã€
; ãã®ä¼šè­°ãŒã©ã“ã®éƒ¨ç½²ã®ã‚‚ã®ã‹ã€ã‚’çŸ¥ã‚ŠãŸã„ã‹ã¨æ€ã£ã¦ã€and ã§äºŒã¤ã‚’ã¤ãªã„ã§ã¿ãŸã€‚</span>
(and (meeting-time (Hacker Alyssa P) (Wednesday . ?time))
     (meeting ?div (Wednesday . ?time)))</p>
<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
| ?- meeting_time(['Hacker','Alyssa','P'], ['Wednesday' | Time]), 
meeting(Div, ['Wednesday' | Time]).

Div = whole_company
Time = ['4pm'] ? ;

Div = computer
Time = ['3pm'] ? ;

(1 ms) no
</p>

<p class="orig" lang="en">
<a name="%_thm_4.60"></a>
<b>Exercise 4.60.</b>  <a name="%_idx_5154"></a>By giving the query
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.60.</b> æ¬¡ã®ã‚¯ã‚¨ãƒªã‚’ä¸ãˆã‚‹ã“ã¨ã§ã€
</p>

<p class="lisp">(lives-near ?person (Hacker Alyssa P))
</p>
<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
| ?- lives_near(Person, ['Hacker','Alyssa','P']).

Person = ['Fect','Cy','D'] ? ;

no
</p>

<p class="orig" lang="en">Alyssa P. Hacker is able to find people who live near her, with whom
she can ride to work.  On the other hand, when she tries to find all
pairs of people who live near each other by querying</p>

<p class="trans" lang="ja">
ã‚¢ãƒªãƒƒã‚µãƒ»Pãƒ»ãƒãƒƒã‚«ã¯ã€è‡ªåˆ†ã®è¿‘æ‰€ã«ä½ã‚“ã§ã„ã‚‹äººãŸã¡â€”â€”è‡ªå‹•è»Šã«ç›¸ä¹—ã‚Šã—ã¦é€šå‹¤ã§ãã‚‹ç›¸æ‰‹â€”â€”ã‚’è¦‹ã¤ã‘ã‚‰ã‚Œã‚‹ã€‚
ãã®ä¸€æ–¹ã§ã€å½¼å¥³ã¯ã€ãŠäº’ã„ã®è¿‘æ‰€ã«ä½ã‚“ã§ã„ã‚‹ã™ã¹ã¦ã®äºŒäººçµ„ã‚’ã€ä»¥ä¸‹ã®ã‚ˆã†ã«è³ªå•ã™ã‚‹ã“ã¨ã§è¦‹ã¤ã‘ã‚ˆã†ã¨ã—ãŸã¨ãã«ã€
</p>

<p class="lisp">(lives-near ?person-1 ?person-2)
</p>

<p class="orig" lang="en">she notices that each pair of people who live near each other is
listed twice; for example,</p>

<p class="trans" lang="ja">
ãŠäº’ã„ã®è¿‘æ‰€ã«ä½ã‚“ã§ã„ã‚‹äºŒäººçµ„ã®å„ã€…ãŒäºŒåº¦åˆ—æŒ™ã•ã‚Œã¦ã„ã‚‹ã€ã¨ã„ã†ã“ã¨ã«æ°—ã¥ãã€‚
ãŸã¨ãˆã°ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ã€‚
</p>

<p class="lisp">(lives-near (Hacker Alyssa P) (Fect Cy D))
(lives-near (Fect Cy D) (Hacker Alyssa P))
</p>
<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
| ?- lives_near(Person_1, Person_2).

Person_1 = ['Bitdiddle','Ben']
Person_2 = ['Reasoner','Louis'] ? ;

Person_1 = ['Bitdiddle','Ben']
Person_2 = ['Aull','DeWitt'] ? ;

Person_1 = ['Hacker','Alyssa','P']
Person_2 = ['Fect','Cy','D'] ? ;

Person_1 = ['Fect','Cy','D']
Person_2 = ['Hacker','Alyssa','P'] ? ;

Person_1 = ['Reasoner','Louis']
Person_2 = ['Bitdiddle','Ben'] ? ;

Person_1 = ['Reasoner','Louis']
Person_2 = ['Aull','DeWitt'] ? ;

Person_1 = ['Aull','DeWitt']
Person_2 = ['Bitdiddle','Ben'] ? ;

Person_1 = ['Aull','DeWitt']
Person_2 = ['Reasoner','Louis'] ? ;

(1 ms) no
</p>

<p class="orig" lang="en">Why does this happen?
Is there a way to find a list of people who live near each other, in
which each pair appears only once?  Explain.
</p>

<p class="trans" lang="ja">
ãªãœã“ã†ã„ã†ã“ã¨ãŒèµ·ãã‚‹ã®ã‹?
ãŠäº’ã„ã®è¿‘æ‰€ã«ä½ã‚“ã§ã„ã‚‹äººãŸã¡ã®ä¸€è¦§ã‚’è¦‹ã¤ã‘ã¤ã¤ã€ãã“ã§ã¯å„çµ„ãŒä¸€åº¦ã ã‘ç¾ã‚Œã¦ã„ã‚‹ã€ã¨ã„ã£ãŸæ–¹æ³•ã¯å­˜åœ¨ã™ã‚‹ã ã‚ã†ã‹?
èª¬æ˜ã›ã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment"><a href="#%_idx_5140"><tt>lives-near</tt> ã®å®šç¾©</a>ã¯ã€äºŒäººã®äººç‰©ã«é–¢ã—ã¦ã¾ã£ãŸãå¯¾ç§°ã§ã‚ã‚‹ã€‚ã‚ˆã£ã¦ã€
ã‚‚ã—Aã•ã‚“ã¨Bã•ã‚“ãŒè¿‘æ‰€ã«ä½ã‚“ã§ã„ã‚Œã° (Aã•ã‚“ã¨Bã•ã‚“ã¯åˆ¥äººã¨ã™ã‚‹)ã€

  * <tt>?person-1</tt> ã¨ã„ã†ãƒ‘ã‚¿ãƒ³å¤‰æ•°ã«Aã•ã‚“ (ã®æ°å) ãŒä»£å…¥ã•ã‚Œã€ã‹ã¤ã€
    <tt>?person-2</tt> ã¨ã„ã†ãƒ‘ã‚¿ãƒ³å¤‰æ•°ã«Bã•ã‚“ (ã®æ°å) ãŒä»£å…¥ã•ã‚Œã‚‹ã€ã¨ã„ã†ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã¨ã€

  * <tt>?person-1</tt> ã¨ã„ã†ãƒ‘ã‚¿ãƒ³å¤‰æ•°ã«Bã•ã‚“ (ã®æ°å) ãŒä»£å…¥ã•ã‚Œã€ã‹ã¤ã€
    <tt>?person-2</tt> ã¨ã„ã†ãƒ‘ã‚¿ãƒ³å¤‰æ•°ã«Aã•ã‚“ (ã®æ°å) ãŒä»£å…¥ã•ã‚Œã‚‹ã€ã¨ã„ã†ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–

ã®ãã‚Œãã‚Œã«ã‚ˆã£ã¦ã€<tt>lives-near</tt> ã¯æº€ãŸã•ã‚Œã‚‹ã€‚ã—ãŸãŒã£ã¦ã€ä¸Šè¨˜ã®ã‚ˆã†ã«ã€
ã©ã®ã€Œã”è¿‘æ‰€äºŒäººçµ„ã€ã‚‚äºŒåº¦å‡ºç¾ã—ã¦ã—ã¾ã†ã€‚

ã“ã‚Œã‚’é˜²ãã«ã¯ã€<tt>lives-near</tt> ã®æœ¬ä½“ã«ã€<tt>and</tt> ã§ã¤ãªã’ã¦æ¡ä»¶ã‚’è¿½åŠ ã™ã‚Œã°ã‚ˆã„ 
(ã¾ãŸã¯ã€<tt>lives-near</tt> ã« <tt>and</tt> ã§åˆ¥ã®æ¡ä»¶ã‚’ã¤ãªã„ã ã€ãƒ©ãƒƒãƒ‘çš„ãªè¦å‰‡ãªã„ã—ã‚¯ã‚¨ãƒªã‚’ä½œã‚Œã°ã‚ˆã„)ã€‚
ã¤ã¾ã‚Šå¯¾ç§°æ€§ã‚’å£Šã›ã°ã‚ˆã„ã€‚
å…·ä½“çš„ã«ã¯ã€æ°ååŒå£«ã®é–“ã« (æ–‡å­—åˆ—ã®è¾æ›¸é †ã¨ã‹ã§é©å½“ã«) é †åºé–¢ä¿‚ã‚’å®šç¾©ã—ã¦ã‚„ã£ã¦ã€
<tt>?person-1</tt> ã¯ <tt>?person-2</tt> ã‚ˆã‚Šã‚‚ã€Œé †åºã€ãŒå‰ã ã€ã¨ã„ã†æ¡ä»¶ã‚’åŠ ãˆã‚Œã°ã‚ˆã„ã€‚
ã‚‚ã—ãã®ã€Œé †åºã€ã‚’ã€ã€Œ&le; çš„ãªé–¢ä¿‚ã€ã§ã¯ãªãã¦ã€Œ&lt; çš„ãªé–¢ä¿‚ã€ã¨ã—ã¦å®šç¾©ã™ã‚‹ãªã‚‰ã€
<tt>(not (same ?person-1 ?person-2))</tt> ã¯çœç•¥å¯èƒ½ã¨ãªã‚‹ã€‚

â€¦â€¦ã¨ã¾ã‚ã€ç†å±ˆã®ä¸Šã§ã¯ãã†ãªã‚“ã ãŒã€è¨˜å· (ã‚·ãƒ³ãƒœãƒ«) åŒå£«ã®é–“ã«é †åºä»˜ã‘ã‚’
ã™ã‚‹ã‚ˆã†ãªçµ„ã¿è¾¼ã¿è¿°èªã£ã¦ã‚ã£ãŸã‹ãª? ã‚ã‚‹ã„ã¯ã€ã‚·ãƒ³ãƒœãƒ«åã‚’è¡¨ç¾ã™ã‚‹æ–‡å­—åˆ—ã‚’
å–å¾—ã™ã‚‹ã‚ˆã†ãªçµ„ã¿è¾¼ã¿é–¢æ•°ã¨ã‹ (ãã‚Œã§æ–‡å­—åˆ—åŒå£«ã®å¤§å°æ¯”è¼ƒã«æŒã¡è¾¼ã‚€)ã€‚
ã¡ã‚‡ã£ã¨å®Ÿéš›ã®å®Ÿè£…ã¾ã§ã¯è€ƒãˆã¦ã„ãªã„ã€‚

[è¿½è¨˜] <a href="http://practical-scheme.net/gauche/index-j.html">Gauche</a>ã®<a href="http://practical-scheme.net/gauche/man/?l=ja&p=eq-compare"><tt>eq-compare</tt></a>ã‚’ä½¿ã†æ‰‹ãŒã‚ã‚Šãã†ã€‚
ã‚ã‚‹ã„ã¯ã€<a href="http://practical-scheme.net/gauche/man/?l=ja&p=symbol->string"><tt>symbol-&gt;string</tt></a>ã¨<a href="http://practical-scheme.net/gauche/man/?l=ja&p=string>?"><tt>string&lt;?</tt></a>ã®åˆã‚ã›æŠ€ã‹ãªã€‚
</span></p>

<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚
% 2é€šã‚Šã®æ–¹æ³• (è¦å‰‡ã®æœ¬ä½“ã‚’æ›¸ãæ›ãˆã‚‹æ–¹æ³•ã¨ã€ãƒ©ãƒƒãƒ‘è¦å‰‡ã‚’ä½œã‚‹æ–¹æ³•) ã‚’ç¤ºã™ã€‚</span>
lives_near_ver2(Person_1, Person_2) :- 
    address(Person_1, [Town | Rest_1]),
    address(Person_2, [Town | Rest_2]),
    Person_1 @&lt; Person_2.
lives_near_ver3(Person_1, Person_2) :- 
    lives_near(Person_1, Person_2), Person_1 @&lt; Person_2.

<span class="ex_comment">% ã‚¯ã‚¨ãƒªã‚’å®Ÿè¡Œã—ã¦ã¿ã‚‹ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
| ?- lives_near_ver2(A, B).

A = ['Bitdiddle','Ben']
B = ['Reasoner','Louis'] ? ;

A = ['Fect','Cy','D']
B = ['Hacker','Alyssa','P'] ? ;

A = ['Aull','DeWitt']
B = ['Bitdiddle','Ben'] ? ;

A = ['Aull','DeWitt']
B = ['Reasoner','Louis'] ? ;

no
| ?- lives_near_ver3(A, B).

A = ['Bitdiddle','Ben']
B = ['Reasoner','Louis'] ? ;

A = ['Fect','Cy','D']
B = ['Hacker','Alyssa','P'] ? ;

A = ['Aull','DeWitt']
B = ['Bitdiddle','Ben'] ? ;

A = ['Aull','DeWitt']
B = ['Reasoner','Louis'] ? ;

(1 ms) no
</p>

<a name="%_sec_Temp_664"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_664">Logic as programs</a></h4>
<h4 class="trans" lang="ja">ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¨ã—ã¦ã®è«–ç†</h4>

<p class="orig" lang="en">
<a name="%_idx_5156"></a>
We can regard a rule as a kind of logical implication: <em>If</em> an
assignment of values to pattern variables satisfies the body, <em>then</em> it satisfies the conclusion.  Consequently, we can regard the
query language as having the ability to perform <em>logical
deductions</em> based upon the rules.  As an example, consider the <tt>append</tt> operation described at the beginning of
section <a href="#%_sec_4.4">4.4</a>.  As we said, <tt>append</tt> can be
characterized by the following two rules:</p>

<p class="trans" lang="ja">
è¦å‰‡ã‚’ã€ä¸€ç¨®ã®è«–ç†çš„å«æ„ã¨è¦‹ãªã™ã“ã¨ã‚‚ã§ãã‚‹ã€‚ã¤ã¾ã‚Šã€<em>ã‚‚ã—</em>ãƒ‘ã‚¿ãƒ³å¤‰æ•°ã«å¯¾ã™ã‚‹å€¤ã®<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ãŒæœ¬ä½“ã‚’æº€ãŸã™<em>ãªã‚‰</em>ã€ãã®<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã¯å¸°çµéƒ¨ã‚’æº€ãŸã™ã€ã¨ã„ã†è«–ç†çš„å«æ„ã§ã‚ã‚‹ã€‚
ãã®çµæœã€ã‚¯ã‚¨ãƒªè¨€èªã‚’ã€è¦å‰‡ã«åŸºã¥ã<em>è«–ç†çš„æ¼”ç¹¹</em>ã‚’å®Ÿè¡Œã™ã‚‹èƒ½åŠ›ã‚’å‚™ãˆãŸã‚‚ã®ã¨è¦‹ãªã›ã‚‹ã€‚
ä¾‹ã¨ã—ã¦ã€<a href="#%_sec_4.4">4.4</a>ç¯€ã®æœ€åˆã§èª¬æ˜ã—ãŸ <tt>append</tt> ã®æ¼”ç®—ã‚’è€ƒãˆã¦ã¿ã‚ˆã€‚
è¨€ã£ãŸã¨ãŠã‚Šã€ä»¥ä¸‹ã®äºŒã¤ã®è¦å‰‡ã«ã‚ˆã‚Š <tt>append</tt> ã‚’ç‰¹å¾´ã¥ã‘ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
</p>

<ul class="orig" lang="en">
<li>For any list <tt>y</tt>, the empty list and <tt>y</tt> <tt>append</tt> to form <tt>y</tt>.</li>

<li>For any <tt>u</tt>,  <tt>v</tt>,  <tt>y</tt>, and <tt>z</tt>,
 <tt>(cons u v)</tt> and <tt>y</tt> <tt>append</tt> to form <tt>(cons u z)</tt>
if <tt>v</tt> and <tt>y</tt> <tt>append</tt> to form <tt>z</tt>.</li>
</ul>

<ul class="trans" lang="ja">
<li>ä»»æ„ã®ãƒªã‚¹ãƒˆ <tt>y</tt> ã«ã¤ã„ã¦ã€ç©ºãƒªã‚¹ãƒˆã¨ <tt>y</tt> ã¯ã€<tt>append</tt> ã—ã¦ <tt>y</tt> ã¨ãªã‚‹ã€‚</li>
<li>ä»»æ„ã® <tt>u</tt> ã¨ <tt>v</tt> ã¨ <tt>y</tt> ã¨ <tt>z</tt> ã«ã¤ã„ã¦ã€ã‚‚ã— <tt>v</tt> ã¨ <tt>y</tt> ãŒ <tt>append</tt> ã—ã¦ <tt>z</tt> ã¨ãªã‚‹ãªã‚‰ã€<tt>(cons u v)</tt> ã¨ <tt>y</tt> ã¯ã€<tt>append</tt> ã—ã¦ <tt>(cons u z)</tt> ã¨ãªã‚‹ã€‚</li>
</ul>

<p class="orig" lang="en">
To express this in our query language, we define two rules for a
relation
</p>

<p class="trans" lang="ja">
ç§ãŸã¡ã®ã‚¯ã‚¨ãƒªè¨€èªã§ã“ã‚Œã‚’è¡¨ã™ã«ã¯ã€ä»¥ä¸‹ã®é–¢ä¿‚ã«ã¤ã„ã¦äºŒã¤ã®è¦å‰‡ã‚’å®šç¾©ã™ã‚‹ã€‚
</p>

<p class="lisp">(append-to-form x y z)</p>

<p class="orig" lang="en">which we can interpret to mean ``<tt>x</tt> and <tt>y</tt> <tt>append</tt> to
form <tt>z</tt>'':</p>

<p class="trans" lang="ja">
ãªãŠã“ã‚Œã¯ã€ã€Œ<tt>x</tt> ã¨ <tt>y</tt> ã¯ <tt>append</tt> ã—ã¦ <tt>z</tt> ã¨ãªã‚‹ã€ã‚’æ„å‘³ã™ã‚‹ã‚‚ã®ã¨è§£é‡ˆã§ãã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_5158"></a>(rule (append-to-form () ?y ?y))
(rule (append-to-form (?u . ?v) ?y (?u . ?z))
      (append-to-form ?v ?y ?z))
</p>
<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
append_to_form([], Y, Y).
append_to_form([U | V], Y, [U | Z]) :- append_to_form(V, Y, Z).

<span class="ex_comment">% ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã«å¯¾ã—ã¦ä»¥ä¸‹ã®ã‚ˆã†ã« [user]. ã¨æ‰“ã¡è¾¼ã‚“ã§ã‹ã‚‰
% | ?- [user].
% ä¸Šè¨˜ã®è¦å‰‡ã‚’å…¥åŠ›ã—ã€çµ‚ã‚ã£ãŸã‚‰ Control+D ã‚’å…¥åŠ›ã™ã‚‹ã€‚
% ãã†ã™ã‚‹ã¨ã€å®šç¾©ã—ãŸè¦å‰‡ã‚’ä½¿ã£ãŸã‚¯ã‚¨ãƒªã‚’å®Ÿè¡Œã§ãã‚‹ã‚ˆã†ã«ãªã‚‹ã€‚</span>
</p>

<p class="orig" lang="en"><a name="%_idx_5160"></a>The first rule has no body, which means that the conclusion holds for
any value of <tt>?y</tt>.  Note how the second rule makes use of
<a name="%_idx_5162"></a>dotted-tail notation to name the <tt>car</tt> and <tt>cdr</tt> of a list.</p>

<p class="trans" lang="ja">
1ç•ªç›®ã®è¦å‰‡ã«ã¯æœ¬ä½“ãŒãªãã€ãã®ã“ã¨ã¯ã€<tt>?y</tt> ã®ä»»æ„ã®å€¤ã«å¯¾ã—ã¦å¸°çµéƒ¨ãŒæˆã‚Šç«‹ã¤ã“ã¨ã‚’æ„å‘³ã™ã‚‹ã€‚
ã©ã®ã‚ˆã†ã«ã—ã¦2ç•ªç›®ã®è¦å‰‡ãŒã€æœ«å°¾ã«ãƒ‰ãƒƒãƒˆãŒã¤ã„ãŸè¨˜æ³•ã‚’åˆ©ç”¨ã—ã¦ãƒªã‚¹ãƒˆã® <tt>car</tt> ã¨ <tt>cdr</tt> ã‚’åä»˜ã‘ã¦ã„ã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã«æ³¨æ„ã—ã¦ã»ã—ã„ã€‚
</p>

<p class="orig" lang="en">
Given these two rules, we can formulate queries that compute the <tt>append</tt> of two lists:
</p>

<p class="trans" lang="ja">
ã“ã‚Œã‚‰äºŒã¤ã®è¦å‰‡ãŒä¸ãˆã‚‰ã‚Œã‚‹ã¨ã€äºŒã¤ã®ãƒªã‚¹ãƒˆã® <tt>append</tt> ã‚’è¨ˆç®—ã™ã‚‹ã‚¯ã‚¨ãƒªã‚’å®šå¼åŒ–ã§ãã‚‹ã€‚
</p>

<p class="lisp"><i>;;; Query input:</i>
(append-to-form (a b) (c d) ?z)
<i>;;; Query results:</i>
(append-to-form (a b) (c d) (a b c d))
</p>
<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
|? append_to_form([a, b], [c, d], Z).

Z = [a,b,c,d]

yes
</p>

<p class="orig" lang="en">What is more striking, we can use the same rules to ask the question
``Which list, when <tt>append</tt>ed to <tt>(a b)</tt>, yields <tt>(a b c d)</tt>?''
This is done as follows:
</p>

<p class="trans" lang="ja">
ã•ã‚‰ã«ç´ æ™´ã‚‰ã—ã„ã“ã¨ã«ã¯ã€ã€Œ<tt>(a b)</tt> ã« <tt>append</tt> ã•ã‚ŒãŸå ´åˆã« <tt>(a b c d)</tt> ã‚’ä½œã‚Šå‡ºã™ã®ã¯ã©ã®ãƒªã‚¹ãƒˆã‹?ã€ã¨ã„ã†è³ªå•ã«ç­”ãˆã‚‹ã®ã«ã€åŒã˜è¦å‰‡ã‚’ä½¿ãˆã‚‹ã®ã§ã‚ã‚‹ã€‚
ã“ã‚Œã¯ã€æ¬¡ã®ã‚ˆã†ã«è¡Œã‚ã‚Œã‚‹ã€‚
</p>

<p class="lisp"><i>;;; Query input:</i>
(append-to-form (a b) ?y (a b c d))
<i>;;; Query results:</i>
(append-to-form (a b) (c d) (a b c d))
</p>
<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
| ?- append_to_form([a, b], Y, [a, b, c, d]).

Y = [c,d]

yes
</p>

<p class="orig" lang="en">We can also ask for all pairs of lists that <tt>append</tt> to form <tt>(a b c d)</tt>:
</p>

<p class="trans" lang="ja">
<tt>append</tt> ã—ã¦ <tt>(a b c d)</tt> ã«ãªã‚‹ã‚ˆã†ãªã€ãƒªã‚¹ãƒˆåŒå£«ã®å¯¾ã‚’ã™ã¹ã¦æ±‚ã‚ã‚‹ã“ã¨ã‚‚ã§ãã‚‹ã€‚
</p>

<p class="lisp"><i>;;; Query input:</i>
(append-to-form ?x ?y (a b c d))
<i>;;; Query results:</i>
(append-to-form () (a b c d) (a b c d))
(append-to-form (a) (b c d) (a b c d))
(append-to-form (a b) (c d) (a b c d))
(append-to-form (a b c) (d) (a b c d))
(append-to-form (a b c d) () (a b c d))
</p>
<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
| ?- append_to_form(X, Y, [a, b, c, d]).

X = []
Y = [a,b,c,d] ? ;

X = [a]
Y = [b,c,d] ? ;

X = [a,b]
Y = [c,d] ? ;

X = [a,b,c]
Y = [d] ? ;

X = [a,b,c,d]
Y = [] ? ;

(1 ms) no
</p>

<p class="orig" lang="en">
The query system may seem to exhibit quite a bit of intelligence in
using the rules to deduce the answers to the queries above.  Actually,
as we will see in the next section, the system is following a
well-determined algorithm in unraveling the rules.  Unfortunately,
although the system works impressively in the <tt>append</tt> case, the
general methods may break down in more complex cases, as we will see
in section <a href="#%_sec_4.4.3">4.4.3</a>.</p>

<p class="trans" lang="ja">
ã‚¯ã‚¨ãƒªãƒ»ã‚·ã‚¹ãƒ†ãƒ ã¯ã€ä¸Šè¨˜ã®ã‚¯ã‚¨ãƒªã¸ã®ç­”ãˆã‚’æ¼”ç¹¹ã™ã‚‹ã®ã«è¦å‰‡ã‚’ç”¨ã„ã‚‹éš›ã«ã€ã‹ãªã‚Šã®çŸ¥æ€§ã‚’ç¤ºã™ã‚ˆã†ã«è¦‹ãˆã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚
å®Ÿéš›ã€æ¬¡ã®ç¯€ã§è¦‹ã‚‹ã‚ˆã†ã«ã€ã“ã®ã‚·ã‚¹ãƒ†ãƒ ã¯ã€è«¸è¦å‰‡ã‚’è§£ãã»ãã™éš›ã«ã€ãã¡ã‚“ã¨å®šã‚ã‚‰ã‚ŒãŸã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã«å¾“ã£ã¦ã„ã‚‹ã€‚
ã—ã‹ã—ã‚ã„ã«ãã€<tt>append</tt> ã®å ´åˆã«ã¯ã‚·ã‚¹ãƒ†ãƒ ãŒå°è±¡çš„ã«ã†ã¾ãå‹•ãã¨ã¯è¨€ãˆã€ã‚ˆã‚Šè¤‡é›‘ãªå ´åˆã§ã¯ã€<a href="#%_sec_4.4.3">4.4.3</a>ç¯€ã§è¦‹ã‚‹ã“ã¨ã«ãªã‚‹ã‚ˆã†ã«ã€ä¸€èˆ¬çš„ãªæ–¹æ³•ã§ã¯ã†ã¾ãã„ã‹ãªã„ã‹ã‚‚ã—ã‚Œãªã„ã€‚
</p>


<p class="orig" lang="en">
<a name="%_thm_4.61"></a>
<b>Exercise 4.61.</b>  The following rules implement a <tt>next-to</tt> relation that finds
adjacent elements of a list:
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.61.</b> ä»¥ä¸‹ã®è¦å‰‡ã¯ã€ãƒªã‚¹ãƒˆã®ã†ã¡ã®éš£ã‚Šåˆã†è¦ç´ ã‚’è¦‹ã¤ã‘å‡ºã™ã€<tt>next-to</tt> ã¨ã„ã†é–¢ä¿‚ã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_5164"></a>(rule (?x next-to ?y in (?x ?y . ?u)))

(rule (?x next-to ?y in (?v . ?z))
      (?x next-to ?y in ?z))
</p>
<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚

% | ?- [user].
% ã¨ã—ã¦ã‹ã‚‰ä»¥ä¸‹ã‚’å…¥åŠ›ã—ã€å…¥åŠ›å¾Œã€Control+D ã‚’æŠ¼ã™ã€‚</span>
next_to(X, Y, [X, Y | U]).
next_to(X, Y, [V | Z]) :- next_to(X, Y, Z).
</p>

<p class="orig" lang="en">What will the response be to the following queries?
</p>

<p class="trans" lang="ja">
ä»¥ä¸‹ã®ã‚¯ã‚¨ãƒªã«å¯¾ã—ã¦ã€å¿œç­”ã¯ã©ã†ãªã‚‹ã ã‚ã†ã‹?
</p>

<p class="lisp">(?x next-to ?y in (1 (2 3) 4))

(?x next-to 1 in (2 1 3 1))
</p>

<p class="exercise">(1 next-to (2 3) in (1 (2 3) 4))
((2 3) next-to 4 in (1 (2 3) 4))

(2 next-to 1 in (2 1 3 1))
(3 next-to 1 in (2 1 3 1))
</p>
<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚
% 1ç•ªç›®ã®ã‚¯ã‚¨ãƒª</span>
| ?- next_to(X, Y, [1, [2, 3], 4]).

X = 1
Y = [2,3] ? ;

X = [2,3]
Y = 4 ? ;

no

<span class="ex_comment">% 2ç•ªç›®ã®ã‚¯ã‚¨ãƒª</span>
| ?- next_to(X, 1, [2, 1, 3, 1]).

X = 2 ? ;

X = 3 ? ;

no
</p>

<p class="orig" lang="en">
<a name="%_thm_4.62"></a>
<b>Exercise 4.62.</b>  <a name="%_idx_5166"></a>Define rules to implement the <tt>last-pair</tt> operation of
exercise <a href="15_sec2_2.html#%_thm_2.17">2.17</a>, which returns a list containing the last
element of a nonempty list.  Check your rules on queries such as
<tt>(last-pair (3) ?x)</tt>, <tt>(last-pair (1 2 3) ?x)</tt>, and <tt>(last-pair (2 ?x) (3))</tt>.
Do your rules work correctly on queries such as <tt>(last-pair ?x (3))</tt> ?
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.62.</b> ç·´ç¿’å•é¡Œ<a href="15_sec2_2.html#%_thm_2.17">2.17</a>ã® <tt>last-pair</tt> æ¼”ç®—â€”â€”éç©ºãƒªã‚¹ãƒˆã®æœ€å¾Œã®è¦ç´ ã‚’å«ã‚€ãƒªã‚¹ãƒˆã‚’è¿”ã™â€”â€”ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã®è¦å‰‡ã‚’å®šç¾©ã›ã‚ˆã€‚
<tt>(last-pair (3) ?x)</tt> ã‚„ <tt>(last-pair (1 2 3) ?x)</tt> ã‚„ <tt>(last-pair (2 ?x) (3))</tt> ã¨ã„ã£ãŸã‚¯ã‚¨ãƒªã«ã¤ã„ã¦ã€å›ã®è¦å‰‡ã‚’ç‚¹æ¤œã—ã¦ã¿ãŸã¾ãˆã€‚
<tt>(last-pair ?x (3))</tt> ã®ã‚ˆã†ãªã‚¯ã‚¨ãƒªã«å¯¾ã—ã¦ã€å›ã®è¦å‰‡ã¯æ­£ã—ãå‹•ãã‹ãª?
</p>

<p class="exercise"><span class="ex_comment">; ç¬¬1å¼•æ•°ã¯éç©ºãƒªã‚¹ãƒˆã€‚ç¬¬2å¼•æ•°ã¯ãã®ä¸­ã®æœ€å¾Œã®è¦ç´ ã‚’å«ã‚€ãƒªã‚¹ãƒˆã€‚</span>
(last-pair (?last) (?last))
(rule (last-pair (?x . ?y) ?last)
      (last-pair ?y ?last))
</p>
<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚

% | ?- [user].
% ã¨ã—ã¦ã‹ã‚‰ä»¥ä¸‹ã‚’å…¥åŠ›ã—ã€å…¥åŠ›å¾Œã€Control+D ã‚’æŠ¼ã™ã€‚</span>
last_pair([Last], [Last]).
last_pair([X | Y], Last) :- last_pair(Y, Last).
</p>

<p class="exercise"><span class="ex_comment">(last-pair (3) ?x) ã¯ã€1ç•ªç›®ã®è¦å‰‡ã‚’ä½¿ã†ã¨ã€(?last) ãŒ (3) ã§ã€?x ãŒ (?last) ã¤ã¾ã‚Š (3) 
ã«ãªã‚‹ã€‚ã‚ˆã£ã¦ã€(last-pair (3) (3)) ã¨ã„ã†å¿œç­”ãŒå¾—ã‚‰ã‚Œã‚‹ã€‚
</p>
<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
| ?- last_pair([3], X).

X = [3] ? ;

(1 ms) no
</p>

<p class="exercise"><span class="ex_comment">(last-pair (1 2 3) ?x) ã¯ã€2ç•ªç›®ã®è¦å‰‡ã‚’ä½¿ã£ã¦ã€(last-pair (2 3) ?x) ã‚’è§£ãã“ã¨ã«
å¸°ç€ã•ã‚Œã‚‹ã€‚ä»Šåº¦ã¯ã“ã‚Œã‚’2ç•ªç›®ã®è¦å‰‡ã‚’ä½¿ã£ã¦è§£ãã“ã¨ã«ãªã‚Šã€ãã‚Œã¯ã€
(last-pair (3) ?x) ã‚’è§£ãã“ã¨ã«å¸°ç€ã•ã‚Œã‚‹ã€‚ã“ã‚Œã¯ã€ä¸Šè¨˜ã®ã¨ãŠã‚Šã€1ç•ªç›®ã®è¦å‰‡ã§
è§£ãã“ã¨ã«ãªã‚Šã€?x ãŒ (3) ã«ãªã‚‹ã€‚
ã¨ã„ã†ã‚ã‘ã§ã€(last-pair (1 2 3) ?x) ã® ?x ã‚‚ (3) ã¨è§£ã‹ã‚Œã‚‹ã€‚
ã¤ã¾ã‚Šã€(last-pair (1 2 3) (3)) ã¨ã„ã†å¿œç­”ãŒå¾—ã‚‰ã‚Œã‚‹ã€‚
</p>
<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
| ?- last_pair([1, 2, 3], X).

X = [3] ? ;

no
</p>

<p class="exercise"><span class="ex_comment">(last-pair (2 ?x) (3)) ã¯ã€2ç•ªç›®ã®è¦å‰‡ã‚’ä½¿ã£ã¦ã€(last-pair (?x) (3)) ã‚’è§£ãã“ã¨ã«
å¸°ç€ã•ã‚Œã‚‹ã€‚ä»Šåº¦ã¯ã“ã‚Œã‚’1ç•ªç›®ã®è¦å‰‡ã‚’ä½¿ã£ã¦è§£ãã“ã¨ã«ãªã‚‹ã‹ã‚‰ã€?x ãŒ 3 ã«
ãªã‚‹ã€‚ã‚ˆã£ã¦ã€(last-pair (2 3) (3)) ã¨ã„ã†å¿œç­”ãŒå¾—ã‚‰ã‚Œã‚‹ã€‚
</p>
<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
| ?- last_pair([2, X], [3]).

X = 3 ? ;

no
</p>

<p class="exercise"><span class="ex_comment">(last-pair ?x (3)) ã«å¯¾ã—ã¦ã¯ã€1ç•ªç›®ã®è¦å‰‡ã‹ã‚‰ã€?x ãŒ (3) ã¨ã„ã†çµæœãŒå¾—ã‚‰ã‚Œã‚‹
(?last ãŒ 3 ã«ãªã‚Šã€?x ãŒ ?last ã«ãªã‚‹ã‹ã‚‰)ã€‚
ã¤ã¾ã‚Šã€(last-pair (3) (3)) ã¨ã„ã†å¿œç­”ãŒå¾—ã‚‰ã‚Œã‚‹ã€‚
ã§ã‚‚ã€æ„å‘³çš„ã«è€ƒãˆã‚‹ã¨ã€?x ã¯ã€æœ€å¾Œã®è¦ç´ ãŒ 3 ã§ã‚ã‚Šã•ãˆã™ã‚Œã°ã€ã©ã‚“ãªé•·ã•
ã§ã‚‚è‰¯ã„ã—ã€æœ€å¾Œã®è¦ç´ ä»¥å¤–ã¯ä»»æ„ã§ã‚ã‚‹ã€‚ã¤ã¾ã‚Šã€?x ã«è©²å½“ã™ã‚‹ãƒªã‚¹ãƒˆã¯ã€
ç„¡é™ã«ã‚ã‚‹ã¨ã„ã†ã“ã¨ã€‚
ã“ã‚Œã‚‰ã®ç„¡é™ã«å­˜åœ¨ã—å¾—ã‚‹ãƒªã‚¹ãƒˆã¯ã€ã‚¯ã‚¨ãƒªãƒ»ã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…ã«ã‚ˆã£ã¦ã¯ã€
(last-pair (? 3) (3))
(last-pair (? ? 3) (3))
(last-pair (? ? ? 3) (3))
   :
   :
ã¿ãŸã„ãªã€ä¸å®šã®ãƒ‘ã‚¿ãƒ³å¤‰æ•°ã‚’å«ã‚€å½¢ã§é †ã«å¾—ã‚‰ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œãªã„ãŒã€
ã¾ã‚ã€ã©ã†ã ã‚ã†ã­â€¦â€¦?
</p>
<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
| ?- last_pair(X, [3]).

X = [3] ? ;

X = [_,3] ? ;

X = [_,_,3] ? ;

X = [_,_,_,3] ? ;

X = [_,_,_,_,3] ? ;

X = [_,_,_,_,_,3] ? 

(1 ms) yes
<span class="ex_comment">% ãã‚ŠãŒãªã„ã®ã§ã€<tt>X = [_,_,_,_,_,3] ?</tt> ã®ã¨ã“ã‚ã§
% ãƒªã‚¿ãƒ¼ãƒ³ã‚’æŠ¼ã—ã¦ä¸­æ–­ã—ãŸã€‚</span>
</p>

<p class="orig" lang="en">
<a name="%_thm_4.63"></a>
<b>Exercise 4.63.</b>  <a name="%_idx_5168"></a><a name="%_idx_5170"></a>The following data base (see Genesis 4) traces the genealogy of the
descendants of Ada back to Adam, by way of Cain:</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.63.</b> ä»¥ä¸‹ã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ (å‰µä¸–è¨˜4ç« ã‚’å‚ç…§) ã¯ã€ã‚«ã‚¤ãƒ³ã‚’é€šã˜ã¦ã‚¢ãƒ€ãƒ ã«ã¾ã§é¡ã‚‹ã€ã‚¢ãƒ€ã®å­å­«ã®ç³»å›³ã‚’ãªãã£ã¦ã„ã‚‹ã€‚
</p>

<p class="lisp">(son Adam Cain)
(son Cain Enoch)
(son Enoch Irad)
(son Irad Mehujael)
(son Mehujael Methushael)
(son Methushael Lamech)
(wife Lamech Ada)
(son Ada Jabal)
(son Ada Jubal)
</p>
<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚
% ãªãŠã€ä»¥ä¸‹ã®è¨˜è¿°ã‚’å«ã‚€<a href="bible_db.pl">ãƒ•ã‚¡ã‚¤ãƒ«</a> (<tt>bible_db.pl</tt>) ã‚’ä½œã£ã¦ã‚ã‚‹ã€‚
% ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã«ã¯ã€å¾Œå‡ºã®è¦å‰‡ã‚‚å«ã‚ã¦ã‚ã‚‹ã€‚</span>
son('Adam', 'Cain').
son('Cain', 'Enoch').
son('Enoch', 'Irad').
son('Irad', 'Mehujael').
son('Mehujael', 'Methushael').
son('Methushael', 'Lamech').
wife('Lamech', 'Ada').
son('Ada', 'Jabal').
son('Ada', 'Jubal').
</p>


<p class="orig" lang="en">Formulate rules such as ``If <em>S</em> is the son of <em>F</em>, and <em>F</em> is the son of <em>G</em>, then <em>S</em> is the grandson of <em>G</em>''
and ``If <em>W</em> is the wife of <em>M</em>, and <em>S</em> is the son of
<em>W</em>, then <em>S</em> is the son of <em>M</em>'' (which was supposedly
more true in biblical times than today) that will enable the query
system to find the grandson of Cain; the sons of Lamech; the grandsons
of Methushael.
(See exercise <a href="#%_thm_4.69">4.69</a> for some rules to
deduce more complicated relationships.)
</p>

<p class="trans" lang="ja">
ã‚«ã‚¤ãƒ³ã®å­«æ¯å­ã‚„ã€ãƒ¬ãƒ¡ã‚¯ã®æ¯å­ãŸã¡ã‚„ã€ãƒ¡ãƒˆã‚µã‚¨ãƒ«ã®å­«æ¯å­ãŸã¡ã‚’ã‚¯ã‚¨ãƒªãƒ»ã‚·ã‚¹ãƒ†ãƒ ãŒè¦‹ã¤ã‘ã‚‰ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹ã§ã‚ã‚ã†ã€
ã€Œã‚‚ã— <em class="en">S</em> ãŒ <em class="en">F</em> ã®æ¯å­ã§ã‚ã‚Šã€ã‹ã¤ã€ <em class="en">F</em> ãŒ <em class="en">G</em> ã®æ¯å­ã§ã‚ã‚‹ãªã‚‰ã°ã€ <em class="en">S</em> ã¯ <em class="en">G</em> ã®å­«æ¯å­ã§ã‚ã‚‹ã€
ãŠã‚ˆã³
ã€Œã‚‚ã— <em class="en">W</em> ãŒ <em class="en">M</em> ã®å¦»ã§ã‚ã‚Šã€ã‹ã¤ã€ <em class="en">S</em> ãŒ <em class="en">W</em> ã®æ¯å­ã§ã‚ã‚‹ãªã‚‰ã°ã€ <em class="en">S</em> ã¯ <em class="en">M</em> ã®æ¯å­ã§ã‚ã‚‹ã€
(ã“ã‚Œã¯ã€ãŠãã‚‰ãã¯ã€è–æ›¸ã®æ™‚ä»£ã«ãŠã„ã¦ã¯ç¾ä»£ã‚ˆã‚Šã‚‚çœŸå®Ÿæ€§ãŒã‚ã£ãŸ)
ã®ã‚ˆã†ãªè¦å‰‡ã‚’ã€å®šå¼åŒ–ã›ã‚ˆ
(ã‚ˆã‚Šè¾¼ã¿å…¥ã£ãŸé–¢ä¿‚ã‚’æ¼”ç¹¹ã™ã‚‹ãŸã‚ã®ã„ãã¤ã‹ã®è¦å‰‡ã«ã¤ã„ã¦ã¯ã€ç·´ç¿’å•é¡Œ<a href="#%_thm_4.69">4.69</a>ã‚’å‚ç…§)ã€‚
</p>

<p class="exercise">(rule (grandson ?G ?S)
      (and (son ?G ?F) (son ?F ?S)))

(rule (son ?M ?S)
      (and (wife ?M ?W) (son ?W ?S)))

<span class="inline-aa">
ã‚¢ãƒ€ãƒ â”€ã‚«ã‚¤ãƒ³â”€ã‚¨ãƒã‚¯â”€ã‚¤ãƒ©ãƒ‡â”€ãƒ¡ãƒ›ãƒ¤ã‚¨ãƒ«â”€ãƒ¡ãƒˆã‚µã‚¨ãƒ«â”€ãƒ¬ãƒ¡ã‚¯
ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€â”œâ”€â”¬ãƒ¤ãƒãƒ«
ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã‚¢ãƒ€ã€€â””ãƒ¦ãƒãƒ«

</span></p>
<p class="extra_code"><span class="ex_comment">% Prolog ã ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
grandson(G, S) :- son(G, F), son(F, S).
son(M, S) :- wife(M, W), son(W, S).

<span class="ex_comment">% ã‚¯ã‚¨ãƒªã®å®Ÿè¡Œä¾‹</span>
| ?- grandson('Cain', Grandson).

Grandson = 'Irad' ? ;

no
| ?- son('Lamech', Son).

Son = 'Jabal' ? ;

Son = 'Jubal' ? ;

no
| ?- grandson('Methushael', Grandson).

Grandson = 'Jabal' ? ;

Grandson = 'Jubal' ? ;

(1 ms) no
</p>

<a name="%_sec_4.4.2"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_4.4.2">4.4.2  How the Query System Works</a></h3>
<h3 class="trans" lang="ja">4.4.2 ã‚¯ã‚¨ãƒªãƒ»ã‚·ã‚¹ãƒ†ãƒ ã¯ã©ã†å‹•ãã®ã‹</h3>


<p class="orig" lang="en"><a name="%_idx_5172"></a>
In section <a href="#%_sec_4.4.4">4.4.4</a> we will present an
implementation of the query interpreter as a collection of procedures.
In this section we give an overview that explains the general
structure of the system independent of low-level implementation
details.  After describing the implementation of the interpreter, we
will be in a position to understand some of its limitations and some
of the subtle ways in which the query language's logical operations
differ from the operations of mathematical logic.</p>

<p class="trans" lang="ja">
<a href="#%_sec_4.4.4">4.4.4</a>ç¯€ã§ã€ã‚¯ã‚¨ãƒªãƒ»ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã®å®Ÿè£…ã‚’ã€æ‰‹ç¶šãã®é›†ã¾ã‚Šã¨ã—ã¦æç¤ºã—ã‚ˆã†ã€‚
æœ¬ç¯€ã§ã¯ã€ä½æ°´æº–ã®å®Ÿè£…ã®è©³ç´°ã¨ã¯ç‹¬ç«‹ãªã€ã‚·ã‚¹ãƒ†ãƒ ã®å…¨èˆ¬çš„ãªæ§‹é€ ã‚’èª¬æ˜ã™ã‚‹æ¦‚è¦ã‚’ç¤ºã™ã€‚
ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã®å®Ÿè£…ã‚’èª¬æ˜ã—ãŸå¾Œã«ã¯ã€ç§ãŸã¡ã¯ã€ãã®é™ç•Œã®ã†ã¡ã®ã„ãã‚‰ã‹ã¨ã€ã‚¯ã‚¨ãƒªè¨€èªã®è«–ç†æ¼”ç®—ãŒæ•°å­¦çš„è«–ç†ã®æ¼”ç®—ã¨ã¯ç•°ãªã£ã¦ã„ã‚‹å¾®å¦™ãªç‚¹ã®ã†ã¡ã®ã„ãã‚‰ã‹ã«ã¤ã„ã¦ã€ç†è§£ã§ãã‚‹ç«‹å ´ã«ã„ã‚‹ã“ã¨ã ã‚ã†ã€‚
</p>

<p class="orig" lang="en">
It should be apparent that the query evaluator must perform some kind
of search in order to match queries against facts and rules in the
data base.  One way to do this would be to implement the query system
as a nondeterministic program, using the <tt>amb</tt> evaluator of
section <a href="28_sec4_3.html#%_sec_4.3">4.3</a> (see
exercise <a href="#%_thm_4.78">4.78</a>).  Another possibility is to manage
the search with the aid of streams.  Our implementation follows this
second approach.</p>

<p class="trans" lang="ja">
ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ä¸­ã®äº‹å®ŸãŠã‚ˆã³è¦å‰‡ã«å¯¾ã—ã¦ã‚¯ã‚¨ãƒªã‚’ä¸€è‡´ã•ã›ã‚‹ãŸã‚ã«ã€ã‚¯ã‚¨ãƒªè©•ä¾¡å™¨ãŒã‚ã‚‹ç¨®ã®æ¢ç´¢ã‚’å®Ÿè¡Œã›ã­ã°ãªã‚‰ãªã„ã€ã¨ã„ã†ã“ã¨ã¯æ˜ç™½ãªã¯ãšã§ã‚ã‚‹ã€‚
ã“ã®æ¢ç´¢ã‚’è¡Œã†ãŸã‚ã®ä¸€ã¤ã®æ–¹æ³•ã¯ã€<a href="28_sec4_3.html#%_sec_4.3">4.3</a>ç¯€ã® <tt>amb</tt> è©•ä¾¡å™¨ã‚’ä½¿ã£ã¦ã€éæ±ºå®šçš„ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¨ã—ã¦ã‚¯ã‚¨ãƒªãƒ»ã‚·ã‚¹ãƒ†ãƒ ã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ã§ã‚ã‚ã† (ç·´ç¿’å•é¡Œ<a href="#%_thm_4.78">4.78</a>ã‚’å‚ç…§)ã€‚
ã‚‚ã†ä¸€ã¤ã®å¯èƒ½æ€§ã¯ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®åŠ©ã‘ã‚’å€Ÿã‚Šã¦ã€ãªã‚“ã¨ã‹ã†ã¾ãæ¢ç´¢ã‚’è¡Œã†ã“ã¨ã ã€‚
ç§ãŸã¡ã®å®Ÿè£…ã¯ã€ã“ã®2ç•ªç›®ã®æ‰‹æ³•ã«å¾“ã£ã¦ã„ã‚‹ã€‚
</p>

<p class="orig" lang="en">
The query system is organized around two central operations called
<em>pattern matching</em> and <em>unification</em>.  We first describe
pattern matching and explain how this operation, together with the
organization of information in terms of streams of frames, enables us
to implement both simple and compound queries.  We next discuss
unification, a generalization of pattern matching needed to implement
rules.  Finally, we show how the entire query interpreter fits
together through a procedure that classifies expressions in a manner
analogous to the way <tt>eval</tt> classifies expressions for the
interpreter described in section <a href="26_sec4_1.html#%_sec_4.1">4.1</a>.</p>

<p class="trans" lang="ja">
ã‚¯ã‚¨ãƒªãƒ»ã‚·ã‚¹ãƒ†ãƒ ã¯ã€<em>ãƒ‘ã‚¿ãƒ³ãƒ»ãƒãƒƒãƒãƒ³ã‚°</em>ã¨<em><ruby><rb>å˜ä¸€åŒ–</rb><rp> (</rp><rt>ãƒ¦ãƒ‹ãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³</rt><rp>) </rp></ruby></em>ã¨å‘¼ã°ã‚Œã‚‹ã€äºŒã¤ã®ä¸­å¿ƒçš„ãªæ“ä½œã‚’å·¡ã£ã¦çµ„ç¹”åŒ–ã•ã‚Œã¦ã„ã‚‹ã€‚
æœ€åˆã«ã€ãƒ‘ã‚¿ãƒ³ãƒ»ãƒãƒƒãƒãƒ³ã‚°ã«ã¤ã„ã¦èª¬æ˜ã™ã‚‹ã€‚ãã—ã¦ã€ã“ã®æ“ä½œãŒã€ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ç”¨ã„ãŸæƒ…å ±ã®çµ„ç¹”åŒ–ã¨ã‚ã„ã¾ã£ã¦ã€ã©ã®ã‚ˆã†ã«ã—ã¦å˜ç´”ã‚¯ã‚¨ãƒªã¨è¤‡åˆã‚¯ã‚¨ãƒªã®åŒæ–¹ã‚’å®Ÿè£…ã§ãã‚‹ã‚ˆã†ã«ã—ã¦ãã‚Œã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’èª¬æ˜ã™ã‚‹ã€‚
æ¬¡ã«ã€ãƒ¦ãƒ‹ãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³â€”â€”ã™ãªã‚ã¡ã€è¦å‰‡ã‚’å®Ÿè£…ã™ã‚‹ã®ã«å¿…è¦ã¨ã•ã‚Œã‚‹ã€ãƒ‘ã‚¿ãƒ³ãƒ»ãƒãƒƒãƒãƒ³ã‚°ã®ä¸€èˆ¬åŒ–â€”â€”ã«ã¤ã„ã¦è­°è«–ã™ã‚‹ã€‚
æœ€å¾Œã«ã€ã©ã®ã‚ˆã†ã«ã—ã¦ã‚¯ã‚¨ãƒªãƒ»ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿å…¨ä½“ãŒã€<a href="26_sec4_1.html#%_sec_4.1">4.1</a>ç¯€ã§èª¬æ˜ã—ãŸã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã®ãŸã‚ã« <tt>eval</tt> ãŒå¼ã‚’åˆ†é¡ã—ãŸæ–¹æ³•ã¨é¡ä¼¼ã®ã‚„ã‚Šæ–¹ã§å¼ã‚’åˆ†é¡ã™ã‚‹æ‰‹ç¶šãã‚’é€šã˜ã¦ã€ã†ã¾ãã¾ã¨ã¾ã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’ç¤ºã™ã€‚
</p>

<a name="%_sec_Temp_668"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_668">Pattern matching</a></h4>
<h4 class="trans" lang="ja">ãƒ‘ã‚¿ãƒ³ãƒ»ãƒãƒƒãƒãƒ³ã‚°</h4>

<p class="orig" lang="en">
<a name="%_idx_5174"></a><a name="%_idx_5176"></a>
A <em>pattern matcher</em> is a program that tests whether some datum
fits a specified pattern.  For example, the data list <tt>((a b) c (a
b))</tt> matches the pattern <tt>(?x c ?x)</tt> with the pattern variable
<tt>?x</tt> bound to <tt>(a b)</tt>.  The same data list matches the pattern
<tt>(?x ?y ?z)</tt> with <tt>?x</tt> and <tt>?z</tt> both bound to <tt>(a b)</tt>
and <tt>?y</tt> bound to <tt>c</tt>.  It also matches the pattern <tt>((?x ?y) c (?x ?y))</tt> with <tt>?x</tt> bound to <tt>a</tt> and <tt>?y</tt> bound
to <tt>b</tt>.  However, it does not match the pattern <tt>(?x a ?y)</tt>,
since that pattern specifies a list whose second element is the symbol
<tt>a</tt>.</p>

<p class="trans" lang="ja">
<em>ãƒ‘ã‚¿ãƒ³ãƒ»ãƒãƒƒãƒãƒ£</em>ã¯ã€ã‚ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã€æŒ‡å®šã•ã‚ŒãŸãƒ‘ã‚¿ãƒ³ã«åˆã†ã‹ã©ã†ã‹ã‚’èª¿ã¹ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã‚ã‚‹ã€‚
ãŸã¨ãˆã°ã€<tt>((a b) c (a b))</tt> ã¯ <tt>(?x c ?x)</tt> ã¨ã„ã†ãƒ‘ã‚¿ãƒ³ã«ãƒãƒƒãƒã—ã€ãã®éš›ã€<tt>?x</tt> ã¨ã„ã†ãƒ‘ã‚¿ãƒ³å¤‰æ•°ã¯ <tt>(a b)</tt> ã«æŸç¸›ã•ã‚Œã‚‹ã€‚
åŒã˜ãƒ‡ãƒ¼ã‚¿ãƒªã‚¹ãƒˆã¯ã€<tt>(?x ?y ?z)</tt> ã¨ã„ã†ãƒ‘ã‚¿ãƒ³ã«ãƒãƒƒãƒã—ã€ãã®éš›ã€<tt>?x</tt> ã¨ <tt>?z</tt> ã¯ä¸¡æ–¹ã¨ã‚‚ <tt>(a b)</tt> ã«æŸç¸›ã•ã‚Œã€<tt>?y</tt> ã¯ <tt>c</tt> ã«æŸç¸›ã•ã‚Œã‚‹ã€‚
ã“ã‚Œã¯ã€<tt>((?x ?y) c (?x ?y))</tt> ã¨ã„ã†ãƒ‘ã‚¿ãƒ³ã«ã‚‚ãƒãƒƒãƒã—ã€ãã®éš›ã€<tt>?x</tt> ã¯ <tt>a</tt> ã«æŸç¸›ã•ã‚Œã€<tt>?y</tt> ã¯ <tt>b</tt> ã«æŸç¸›ã•ã‚Œã‚‹ã€‚
ã—ã‹ã—ã€ã“ã‚Œã¯ <tt>(?x a ?y)</tt> ã¨ã„ã†ãƒ‘ã‚¿ãƒ³ã«ã¯ãƒãƒƒãƒã—ãªã„ã€‚ãªãœãªã‚‰ã€ã“ã®ãƒ‘ã‚¿ãƒ³ã¯ã€ç¬¬2è¦ç´ ãŒ <tt>a</tt> ã¨ã„ã†<ruby><rb>è¨˜å·</rb><rp> (</rp><rt>ã‚·ãƒ³ãƒœãƒ«</rt><rp>) </rp></ruby>ã§ã‚ã‚‹ã‚ˆã†ãªãƒªã‚¹ãƒˆã‚’æŒ‡å®šã—ã¦ã„ã‚‹ãŸã‚ã§ã‚ã‚‹ã€‚
</p>


<p class="orig" lang="en">
<a name="%_idx_5178"></a><a name="%_idx_5180"></a>The pattern matcher used by the query system takes as inputs a
pattern, a datum, and a <em>frame</em> that specifies bindings for
various pattern variables.  It checks whether the datum matches the
pattern in a way that is consistent with the bindings already in the
frame.  If so, it returns the given frame augmented by any bindings
that may have been determined by the match.  Otherwise, it indicates
that the match has failed.</p>

<p class="trans" lang="ja">
ã‚¯ã‚¨ãƒªãƒ»ã‚·ã‚¹ãƒ†ãƒ ã«ã‚ˆã‚Šä½¿ã‚ã‚Œã‚‹ãƒ‘ã‚¿ãƒ³ãƒ»ãƒãƒƒãƒãƒ£ã¯ã€å…¥åŠ›ã¨ã—ã¦ã€ãƒ‘ã‚¿ãƒ³ã¨ã€ãƒ‡ãƒ¼ã‚¿ã¨ã€ç¨®ã€…ã®ãƒ‘ã‚¿ãƒ³å¤‰æ•°ã«å¯¾ã™ã‚‹æŸç¸›ã‚’æŒ‡å®šã™ã‚‹<em>ãƒ•ãƒ¬ãƒ¼ãƒ </em>ã‚’ã¨ã‚‹ã€‚
ãƒ‘ã‚¿ãƒ³ãƒ»ãƒãƒƒãƒãƒ£ã¯ã€ãƒ•ãƒ¬ãƒ¼ãƒ å†…ã«æ—¢ã«ã‚ã‚‹æŸç¸›ã¨æ•´åˆæ€§ã®ã‚ã‚‹æ–¹æ³•ã§ãƒ‡ãƒ¼ã‚¿ãŒãƒ‘ã‚¿ãƒ³ã¨åˆè‡´ã™ã‚‹ã‹ã©ã†ã‹ã‚’ã€èª¿ã¹ã‚‹ã€‚
ã‚‚ã—åˆè‡´ã™ã‚Œã°ã€ãƒ‘ã‚¿ãƒ³ãƒ»ãƒãƒƒãƒãƒ£ã¯ã€ãã®ãƒãƒƒãƒã«ã‚ˆã‚Šæ‹¡å¼µã•ã‚ŒãŸã€ä¸ãˆã‚‰ã‚ŒãŸãƒ•ãƒ¬ãƒ¼ãƒ ã‚’è¿”ã™ã€‚
ãã‚Œä»¥å¤–ã®å ´åˆã€ãƒ‘ã‚¿ãƒ³ãƒ»ãƒãƒƒãƒãƒ£ã¯ã€ãƒãƒƒãƒãŒå¤±æ•—ã—ãŸæ—¨ã‚’ç¤ºã™ã€‚
</p>

<p class="orig" lang="en">
For example, using the pattern <tt>(?x ?y ?x)</tt> to match <tt>(a b a)</tt>
given an empty frame will return a frame specifying that <tt>?x</tt> is
bound to <tt>a</tt> and <tt>?y</tt> is bound to <tt>b</tt>.  Trying the match
with the same pattern, the same datum, and a frame specifying that
<tt>?y</tt> is bound to <tt>a</tt> will fail.  Trying the match with the
same pattern, the same datum, and a frame in which <tt>?y</tt> is bound
to <tt>b</tt> and <tt>?x</tt> is unbound will return the given frame
augmented by a binding of <tt>?x</tt> to <tt>a</tt>.</p>

<p class="trans" lang="ja">
ãŸã¨ãˆã°ã€ç©ºãƒ•ãƒ¬ãƒ¼ãƒ ãŒä¸ãˆã‚‰ã‚ŒãŸã¨ã—ã¦ã€<tt>(?x ?y ?x)</tt> ã¨ã„ã†ãƒ‘ã‚¿ãƒ³ã‚’ä½¿ã£ã¦ã€<tt>(a b a)</tt> ã¨<ruby><rb>ä¸€è‡´</rb><rp> (</rp><rt>ãƒãƒƒãƒ</rt><rp>) </rp></ruby>ã•ã›ã‚‹ã¨ã€<tt>?x</tt> ãŒ <tt>a</tt> ã«æŸç¸›ã•ã‚Œã¦ãŠã‚Šã€ã‹ã¤ã€<tt>?y</tt> ãŒ <tt>b</tt> ã«æŸç¸›ã•ã‚Œã¦ã„ã‚‹ã€ã¨æŒ‡å®šã™ã‚‹ãƒ•ãƒ¬ãƒ¼ãƒ ãŒè¿”ã•ã‚Œã‚‹ã ã‚ã†ã€‚
åŒã˜ãƒ‘ã‚¿ãƒ³ã¨ã€åŒã˜ãƒ‡ãƒ¼ã‚¿ã¨ã€<tt>?y</tt> ãŒ <tt>a</tt> ã«æŸç¸›ã•ã‚Œã¦ã„ã‚‹ã¨æŒ‡å®šã™ã‚‹ãƒ•ãƒ¬ãƒ¼ãƒ ã¨ã‚’ä½¿ã£ã¦ã€ãã®ãƒãƒƒãƒã‚’è©¦ã—ã¦ã¿ã‚‹ã¨ã€å¤±æ•—ã™ã‚‹ã ã‚ã†ã€‚
åŒã˜ãƒ‘ã‚¿ãƒ³ã¨ã€åŒã˜ãƒ‡ãƒ¼ã‚¿ã¨ã€<tt>?y</tt> ãŒ <tt>b</tt> ã«æŸç¸›ã•ã‚Œã¦ã„ã¦ <tt>?x</tt> ãŒæŸç¸›ã•ã‚Œã¦ã„ãªã„ãƒ•ãƒ¬ãƒ¼ãƒ ã¨ã‚’ä½¿ã£ã¦ã€ãã®ãƒãƒƒãƒã‚’è©¦ã—ã¦ã¿ã‚‹ã¨ã€<tt>?x</tt> ã® <tt>a</tt> ã¸ã®æŸç¸›ã«ã‚ˆã£ã¦æ‹¡å¼µã•ã‚ŒãŸã€ä¸ãˆã‚‰ã‚ŒãŸãƒ•ãƒ¬ãƒ¼ãƒ ã‚’è¿”ã™ã ã‚ã†ã€‚
</p>


<p class="orig" lang="en">
<a name="%_idx_5182"></a>The pattern matcher is all the mechanism that is needed to process
simple queries that don't involve rules.  For instance, to process the
query</p>

<p class="trans" lang="ja">
<!--ãƒ‘ã‚¿ãƒ³ãƒ»ãƒãƒƒãƒãƒ£ã¯ã€è¦å‰‡ã‚’å«ã¾ãªã„å˜ç´”ã‚¯ã‚¨ãƒªã‚’å‡¦ç†ã™ã‚‹ã®ã«å¿…è¦ãªä»•çµ„ã¿ã®ã™ã¹ã¦ã§ã‚ã‚‹ã€‚-->
è¦å‰‡ã‚’å«ã¾ãªã„å˜ç´”ã‚¯ã‚¨ãƒªã‚’å‡¦ç†ã™ã‚‹ã®ã«å¿…è¦ãªä»•çµ„ã¿ã¯ã€ãŸã ãƒ‘ã‚¿ãƒ³ãƒ»ãƒãƒƒãƒãƒ£ã®ã¿ã§ã‚ã‚‹ã€‚
ãŸã¨ãˆã°ã€ä»¥ä¸‹ã®ã‚¯ã‚¨ãƒªã‚’å‡¦ç†ã™ã‚‹ã«ã¯ã€
</p>

<p class="lisp">(job ?x (computer programmer))
</p>

<p class="orig" lang="en">we scan through all assertions in the data base and select those that
match the pattern with respect to an initially empty frame.  For each
match we find, we use the frame returned by the match to instantiate
the pattern with a value for <tt>?x</tt>.
</p>


<p class="trans" lang="ja">
ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å†…ã®ã™ã¹ã¦ã®è¨€æ˜ã‚’èµ°æŸ»ã—ã€æœ€åˆã¯ç©ºã®ãƒ•ãƒ¬ãƒ¼ãƒ ã«é–¢ã—ã¦ã€ãƒ‘ã‚¿ãƒ³ã¨åˆã†è¨€æ˜ã‚’é¸ã¶ã€‚
è¦‹ã¤ã‘ãŸãã‚Œãã‚Œã®ãƒãƒƒãƒã«ã¤ã„ã¦ã€ãã®ãƒãƒƒãƒã«ã‚ˆã‚Šè¿”ã•ã‚ŒãŸãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ä½¿ã£ã¦ã€<tt>?x</tt> ã«å¯¾ã™ã‚‹å€¤ã§ãƒ‘ã‚¿ãƒ³ã‚’ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã™ã‚‹ã€‚
</p>

<a name="%_sec_Temp_669"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_669">Streams of frames</a></h4>
<h4 class="trans" lang="ja">ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ </h4>

<p class="orig" lang="en">
<a name="%_idx_5184"></a><a name="%_idx_5186"></a>
The testing of patterns against frames is organized through the use of
streams.  Given a single frame, the matching process runs through the
data-base entries one by one.  For each data-base entry, the matcher
generates either a special symbol indicating that the match has failed
or an extension to the frame.  The results for all the data-base
entries are collected into a stream, which is passed through a filter
to weed out the failures.  The result is a stream of all the frames
that extend the given frame via a match to some assertion in the data
base.<a name="call_footnote_Temp_670" href="#footnote_Temp_670"><sup><small>67</small></sup></a></p>

<p class="trans" lang="ja">
ãƒ•ãƒ¬ãƒ¼ãƒ ã«å¯¾ã—ã¦ãƒ‘ã‚¿ãƒ³ã‚’è©¦ã™ã“ã¨ã¯ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®ä½¿ç”¨ã‚’é€šã˜ã¦ä½“ç³»åŒ–ã•ã‚Œã‚‹ã€‚
ä¸€ã¤ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãŒä¸ãˆã‚‰ã‚Œã‚‹ã¨ã€ãƒãƒƒãƒãƒ³ã‚°ãƒ»ãƒ—ãƒ­ã‚»ã‚¹ã¯ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ã‚¨ãƒ³ãƒˆãƒªã‚’ä¸€ã¤ãšã¤ã–ã£ã¨ç‚¹æ¤œã—ã¦ã‚†ãã€‚
ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ã‚¨ãƒ³ãƒˆãƒªãã‚Œãã‚Œã«ã¤ã„ã¦ã€ãƒãƒƒãƒãƒ£ã¯ã€ãƒãƒƒãƒãŒå¤±æ•—ã—ãŸã“ã¨ã‚’ç¤ºã™ç‰¹æ®Šè¨˜å·ã‹ã€ãƒ•ãƒ¬ãƒ¼ãƒ ã®æ‹¡å¼µã®ã€ã„ãšã‚Œã‹ã‚’ç”Ÿæˆã™ã‚‹ã€‚
ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ã‚¨ãƒ³ãƒˆãƒªã™ã¹ã¦ã«å¯¾ã™ã‚‹çµæœãŒé›†ã‚ã‚‰ã‚Œã¦ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«ã•ã‚Œã€ãã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¯ã€å¤±æ•—ã‚’å–ã‚Šé™¤ããŸã‚ã®ãƒ•ã‚£ãƒ«ã‚¿ã‚’é€šã—ã¦ã€å—ã‘æ¸¡ã•ã‚Œã‚‹ã€‚
ãã®çµæœã¯ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å†…ã®ä½•ã‚‰ã‹ã®è¨€æ˜ã«å¯¾ã™ã‚‹<ruby><rb>ä¸€è‡´</rb><rp> (</rp><rt>ãƒãƒƒãƒ</rt><rp>) </rp></ruby>ã‚’ä»‹ã—ã¦ã€ä¸ãˆã‚‰ã‚ŒãŸãƒ•ãƒ¬ãƒ¼ãƒ ã‚’æ‹¡å¼µã™ã‚‹ã‚ˆã†ãªã™ã¹ã¦ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰ãªã‚‹ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã§ã‚ã‚‹<a name="call_footnote_Temp_670" href="#footnote_Temp_670"><sup><small>67</small></sup></a>ã€‚
</p>

<p class="orig" lang="en">
In our system, a query takes an input stream of frames and performs
the above matching operation for every frame in the stream, as
indicated in figure <a href="#%_fig_4.4">4.4</a>.  That is, for each frame in
the input stream, the query generates a new stream consisting of all
extensions to that frame by matches to assertions in the data base.
All these streams are then combined to form one huge stream, which
contains all possible extensions of every frame in the input stream.
This stream is the output of the query.</p>

<p class="trans" lang="ja">
å›³<a href="#%_fig_4.4">4.4</a>ã«ç¤ºã™ã‚ˆã†ã«ã€ç§ãŸã¡ã®ã‚·ã‚¹ãƒ†ãƒ ã§ã¯ã€ã‚¯ã‚¨ãƒªãŒã€ãƒ•ãƒ¬ãƒ¼ãƒ ã®å…¥åŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ã¨ã‚Šã€ã‚¹ãƒˆãƒªãƒ¼ãƒ å†…ã®ã™ã¹ã¦ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã«ã¤ã„ã¦ä¸Šè¨˜ã®ãƒãƒƒãƒãƒ³ã‚°æ“ä½œã‚’å®Ÿè¡Œã™ã‚‹ã€‚
ã¤ã¾ã‚Šã€å…¥åŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ å†…ã®å„ãƒ•ãƒ¬ãƒ¼ãƒ ã«ã¤ã„ã¦ã€ã‚¯ã‚¨ãƒªã¯ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å†…ã®è¨€æ˜ã¨ã®<ruby><rb>ä¸€è‡´</rb><rp> (</rp><rt>ãƒãƒƒãƒ</rt><rp>) </rp></ruby>ã«ã‚ˆã‚‹ã€å½“è©²ãƒ•ãƒ¬ãƒ¼ãƒ ã«å¯¾ã™ã‚‹ã™ã¹ã¦ã®æ‹¡å¼µã‹ã‚‰ãªã‚‹ã€æ–°ãŸãªã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ç”Ÿæˆã™ã‚‹ã€‚
ãã‚Œã‹ã‚‰ã€ã™ã¹ã¦ã®ã“ã‚Œã‚‰ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¯ã€çµåˆã•ã‚Œã¦ä¸€ã¤ã®å¤§ããªã‚¹ãƒˆãƒªãƒ¼ãƒ ã¨ãªã‚‹ã®ã ãŒã€ãã‚Œã¯ã€å…¥åŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ å†…ã®ã™ã¹ã¦ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã€ã‚ã‚Šå¾—ã‚‹ã™ã¹ã¦ã®æ‹¡å¼µã‚’å«ã‚€ã€‚
ã“ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒã€ãã®ã‚¯ã‚¨ãƒªã®å‡ºåŠ›ã§ã‚ã‚‹ã€‚
</p>

<figure>
<a name="%_fig_4.4"></a>
<img src="ch4-Z-G-4.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 4.4:</b>  A query processes a stream of frames.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³4.4:</b> ã‚¯ã‚¨ãƒªãŒãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å‡¦ç†ã™ã‚‹</figcaption>
</figure>


<p class="orig" lang="en">
<a name="%_idx_5194"></a>To answer a simple query, we use the query with an input stream
consisting of a single empty frame.  The resulting output stream
contains all extensions to the empty frame (that is, all answers to
our query).  This stream of frames is then used to generate a stream
of copies of the original query pattern with the variables
instantiated by the values in each frame, and this is the stream that
is finally printed.</p>

<p class="trans" lang="ja">
å˜ç´”ã‚¯ã‚¨ãƒªã«å¿œãˆã‚‹ãŸã‚ã«ã¯ã€å˜ä¸€ã®ç©ºãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰ãªã‚‹å…¥åŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¨ã¨ã‚‚ã«ã€ãã®ã‚¯ã‚¨ãƒªã‚’ä½¿ã†ã€‚
çµæœã¨ã—ã¦ç”Ÿã˜ã‚‹å‡ºåŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¯ã€ç©ºãƒ•ãƒ¬ãƒ¼ãƒ ã«å¯¾ã™ã‚‹ã™ã¹ã¦ã®æ‹¡å¼µ (ã¤ã¾ã‚Šã€æˆ‘ã‚‰ãŒã‚¯ã‚¨ãƒªã«å¯¾ã™ã‚‹ã™ã¹ã¦ã®ç­”ãˆ) ã‚’å«ã‚€ã€‚
ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¯ã€ãã‚Œã‹ã‚‰ã€å„ãƒ•ãƒ¬ãƒ¼ãƒ å†…ã®å€¤ã«ã‚ˆã£ã¦å¤‰æ•°ãŒã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã•ã‚ŒãŸå…ƒã®ã‚¯ã‚¨ãƒªãƒ»ãƒ‘ã‚¿ãƒ³ã®ã‚³ãƒ”ãƒ¼ã‹ã‚‰ãªã‚‹ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ç”Ÿæˆã™ã‚‹ã®ã«ä½¿ã‚ã‚Œã€ã“ã‚Œ <span class="note">(ã“ã†ã—ã¦ç”Ÿæˆã•ã‚ŒãŸã‚¹ãƒˆãƒªãƒ¼ãƒ )</span> ãŒã€æœ€å¾Œã«å°å­—ã•ã‚Œã‚‹ã‚¹ãƒˆãƒªãƒ¼ãƒ ã§ã‚ã‚‹ã€‚
</p>

<a name="%_sec_Temp_671"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_671">Compound queries</a></h4>
<h4 class="trans" lang="ja">è¤‡åˆã‚¯ã‚¨ãƒª</h4>

<p class="orig" lang="en">
<a name="%_idx_5196"></a>
The real elegance of the stream-of-frames implementation is evident
when we deal with compound queries.  The processing of compound
queries makes use of the ability of our matcher to demand that a match
<a name="%_idx_5198"></a>be consistent with a specified frame.  For example, to handle the <tt>and</tt> of two queries, such as</p>

<p class="trans" lang="ja">
ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½¿ã£ãŸå®Ÿè£…ã®çœŸã®æ´—ç·´ã¶ã‚Šã¯ã€è¤‡åˆã‚¯ã‚¨ãƒªã‚’æ‰±ã†ã¨ãã«æ˜ã‚‰ã‹ã¨ãªã‚‹ã€‚æŒ‡å®šã•ã‚ŒãŸãƒ•ãƒ¬ãƒ¼ãƒ ã«å¯¾ã—ã¦æ•´åˆæ€§ãŒå–ã‚Œã¦ã„ã‚‹ã‚ˆã†ã«ã€ã¨ãƒãƒƒãƒã«å¯¾ã—ã¦è¦æ±‚ã§ãã‚‹ã€ç§ãŸã¡ã®ãƒãƒƒãƒãƒ£ã®èƒ½åŠ›ã‚’ã€è¤‡åˆã‚¯ã‚¨ãƒªã®å‡¦ç†ã§ã¯åˆ©ç”¨ã™ã‚‹ã€‚
ãŸã¨ãˆã°ã€ä»¥ä¸‹ã®ã‚ˆã†ãªäºŒã¤ã®ã‚¯ã‚¨ãƒªã® <tt>and</tt> ã‚’æ‰±ã†ã«ã¯
</p>

<p class="lisp">(and (can-do-job ?x (computer programmer trainee))
     (job ?person ?x))
</p>

<p class="orig" lang="en">(informally, ``Find all people who can do the job of a computer
programmer trainee''), we first find all entries that match the
pattern</p>

<p class="trans" lang="ja">
(ã“ã‚Œã¯ã€ãã ã‘ãŸè¨€ã„æ–¹ã‚’ã™ã‚‹ãªã‚‰ã€ã€Œã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ»ãƒ—ãƒ­ã‚°ãƒ©ãƒè¦‹ç¿’ã„ã®ä»•äº‹ãŒã§ãã‚‹ã€ã™ã¹ã¦ã®äººãŸã¡ã‚’æ±‚ã‚ã‚ˆã€ã§ã‚ã‚‹)ã€ã¾ãšä»¥ä¸‹ã®ãƒ‘ã‚¿ãƒ³ã«åˆè‡´ã™ã‚‹ã™ã¹ã¦ã®ã‚¨ãƒ³ãƒˆãƒªã‚’æ±‚ã‚ã‚‹ã€‚
</p>

<p class="lisp">(can-do-job ?x (computer programmer trainee))
</p>

<p class="orig" lang="en">This produces a stream of frames, each of which contains a binding for
<tt>?x</tt>.  Then for each frame in the stream we find all entries that
match</p>

<p class="trans" lang="ja">
ã“ã‚Œã¯ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½œã‚Šå‡ºã—ã€ãã‚Œã‚‰ãƒ•ãƒ¬ãƒ¼ãƒ ã®å„ã€…ã¯ã€<tt>?x</tt> ã«å¯¾ã™ã‚‹æŸç¸›ã‚’å«ã‚€ã€‚
ãã—ã¦ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ å†…ã®å„ãƒ•ãƒ¬ãƒ¼ãƒ ã«ã¤ã„ã¦ã€ä»¥ä¸‹ã«åˆè‡´ã™ã‚‹ã™ã¹ã¦ã®ã‚¨ãƒ³ãƒˆãƒªã‚’æ±‚ã‚ã‚‹
</p>

<p class="lisp">(job ?person ?x)
</p>

<p class="orig" lang="en">in a way that is consistent with the given binding for <tt>?x</tt>.  Each
such match will produce a frame containing bindings for <tt>?x</tt> and
<tt>?person</tt>.  The <tt>and</tt> of two queries can be viewed as a series
combination of the two component queries, as shown in
figure <a href="#%_fig_4.5">4.5</a>.  The frames that pass through the first
query filter are filtered and further extended by the second query.</p>

<p class="trans" lang="ja">
â€”â€” <tt>?x</tt> ã«å¯¾ã™ã‚‹ã€ä¸ãˆã‚‰ã‚ŒãŸæŸç¸›ã¨æ•´åˆæ€§ã®å–ã‚ŒãŸæ–¹æ³•ã§åˆè‡´ã™ã‚‹ã€ã™ã¹ã¦ã®ã‚¨ãƒ³ãƒˆãƒªã‚’æ±‚ã‚ã‚‹ã®ã§ã‚ã‚‹ã€‚
ãã®ã‚ˆã†ãªå„ãƒãƒƒãƒã¯ã€<tt>?x</tt> ã¨ <tt>?person</tt> ã«å¯¾ã™ã‚‹æŸç¸›ã‚’å«ã‚€ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ä½œã‚Šå‡ºã™ã ã‚ã†ã€‚
äºŒã¤ã®ã‚¯ã‚¨ãƒªã® <tt>and</tt> ã¯ã€å›³ <a href="#%_fig_4.5">4.5</a>ã«ç¤ºã•ã‚Œã‚‹ã‚ˆã†ã«ã€äºŒã¤ã®æˆåˆ†ã‚¯ã‚¨ãƒªã®ç›´åˆ—ã®çµåˆã ã¨è¦‹ãªã›ã‚‹ã€‚
1ç•ªç›®ã®ã‚¯ã‚¨ãƒªã®ãƒ•ã‚£ãƒ«ã‚¿ã‚’é€šã‚‹ãƒ•ãƒ¬ãƒ¼ãƒ ãŒã€2ç•ªç›®ã®ã‚¯ã‚¨ãƒªã«ã‚ˆã‚Šã€ã•ã‚‰ã«ãƒ•ã‚£ãƒ«ã‚¿ã«ã‹ã‘ã‚‰ã‚Œã€æ‹¡å¼µã•ã‚Œã‚‹ã®ã§ã‚ã‚‹ã€‚
</p>


<figure>
<a name="%_fig_4.5"></a>
<img src="ch4-Z-G-5.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 4.5:</b>  The <tt>and</tt> combination of two queries is
produced by operating on the stream of frames in series.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³4.5:</b> äºŒã¤ã®ã‚¯ã‚¨ãƒªã® <tt>and</tt> çµåˆã¯ã€ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«å¯¾ã—ã¦ç›´åˆ—ã«æ“ä½œã‚’åŠ ãˆã‚‹ã“ã¨ã«ã‚ˆã‚Šã€ä½œã‚Šå‡ºã•ã‚Œã‚‹ã€‚</figcaption>
</figure>

<p class="orig" lang="en">
<a name="%_idx_5200"></a>Figure <a href="#%_fig_4.6">4.6</a> shows the analogous method for computing the
<tt>or</tt> of two queries as a parallel combination of the two component
queries.  The input stream of frames is extended separately by each
query.  The two resulting streams are then merged to produce the final
output stream.</p>

<p class="trans" lang="ja">
å›³<a href="#%_fig_4.6">4.6</a>ã¯ã€äºŒã¤ã®ã‚¯ã‚¨ãƒªã® <tt>or</tt> ã‚’äºŒã¤ã®æˆåˆ†ã‚¯ã‚¨ãƒªã®ä¸¦åˆ—ãªçµåˆã¨ã—ã¦è¨ˆç®—ã™ã‚‹ãŸã‚ã®ã€é¡ä¼¼ã®æ–¹æ³•ã‚’ç¤ºã—ã¦ã„ã‚‹ã€‚
å…¥åŠ›ã•ã‚ŒãŸã€ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¯ã€ãã‚Œãã‚Œã®ã‚¯ã‚¨ãƒªã«ã‚ˆã£ã¦åˆ¥ã€…ã«æ‹¡å¼µã•ã‚Œã‚‹ã€‚
çµæœã¨ã—ã¦ç”Ÿã˜ã‚‹äºŒã¤ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¯ã€ãã®å¾Œã€ä½µåˆã•ã‚Œã¦æœ€çµ‚å‡ºåŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½œã‚Šå‡ºã™ã€‚
</p>

<figure>
<a name="%_fig_4.6"></a>
<img src="ch4-Z-G-6.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 4.6:</b>  The <tt>or</tt> combination of two queries is produced by 
operating on the stream of frames in parallel and merging the
results.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³4.6: äºŒã¤ã®ã‚¯ã‚¨ãƒªã® <tt>or</tt> çµåˆã¯ã€ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«å¯¾ã—ã¦ä¸¦åˆ—ã«æ“ä½œã‚’åŠ ãˆã€ãã®çµæœåŒå£«ã‚’ä½µåˆã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€ä½œã‚Šå‡ºã•ã‚Œã‚‹ã€‚</b></figcaption>
</figure>


<p class="orig" lang="en">
<a name="%_idx_5202"></a>Even from this high-level description, it is apparent that the
processing of compound queries can be slow.
For example, since a query may produce more than one output frame for
each input frame, and each query in an <tt>and</tt> gets its input frames
from the previous query, an <tt>and</tt> query could, in the worst case,
have to perform a number of matches that is exponential in the number
of queries (see exercise <a href="#%_thm_4.76">4.76</a>).<a name="call_footnote_Temp_672" href="#footnote_Temp_672"><sup><small>68</small></sup></a>
Though systems for handling only simple queries are quite practical,
dealing with complex queries is extremely difficult.<a name="call_footnote_Temp_673" href="#footnote_Temp_673"><sup><small>69</small></sup></a></p>

<p class="trans" lang="ja">
ã“ã®é«˜ã„ãƒ¬ãƒ™ãƒ«ã®è¨˜è¿°ã‹ã‚‰ã§ã™ã‚‰ã€è¤‡åˆã‚¯ã‚¨ãƒªã®å‡¦ç†ãŒé…ããªã‚Šå¾—ã‚‹ã“ã¨ã¯æ˜ç™½ã ã€‚
ãŸã¨ãˆã°ã€ã‚¯ã‚¨ãƒªã¯ã€å„å…¥åŠ›ãƒ•ãƒ¬ãƒ¼ãƒ ã«å¯¾ã—ã¦ä¸€ã¤ã‚ˆã‚Šã‚‚å¤šã„å‡ºåŠ›ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ä½œã‚Šå‡ºã™ã“ã¨ãŒã‚ã‚‹ã®ã§ã€ãã—ã¦ã¾ãŸã€<tt>and</tt> å†…ã®å„ã‚¯ã‚¨ãƒªã¯ã€è‡ªèº«ã®å…¥åŠ›ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’å‰ã®ã‚¯ã‚¨ãƒªã‹ã‚‰å–å¾—ã™ã‚‹ã®ã§ã€æœ€æ‚ªã®å ´åˆã€<tt>and</tt> ã‚¯ã‚¨ãƒªã¯ã€ã‚¯ã‚¨ãƒªã®æ•°ã«å¯¾ã—ã¦æŒ‡æ•°é–¢æ•°çš„ãªå›æ•°ã®ãƒãƒƒãƒã‚’å®Ÿè¡Œã›ã­ã°ãªã‚‰ãªã„ã€ã¨ã„ã†ã“ã¨ã«ãªã‚Šå…¼ã­ãªã„ (ç·´ç¿’å•é¡Œ<a href="#%_thm_4.76">4.76</a>ã‚’å‚ç…§)<a href="#footnote_Temp_672"><sup><small>68</small></sup></a>ã€‚
å˜ç´”ãªã‚¯ã‚¨ãƒªã®ã¿ã‚’æ‰±ã†ã‚·ã‚¹ãƒ†ãƒ ã¯ã¨ã¦ã‚‚ç¾å®Ÿçš„ã ãŒã€è¤‡é›‘ãªã‚¯ã‚¨ãƒªã‚’æ‰±ã†ã“ã¨ã¯éå¸¸ã«å›°é›£ã§ã‚ã‚‹<a href="#footnote_Temp_673"><sup><small>69</small></sup></a>ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_5204"></a>From the stream-of-frames viewpoint, the <tt>not</tt> of some query acts
as a filter that removes all frames for which the query can be
satisfied.  For instance, given the pattern</p>

<p class="trans" lang="ja">
ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®è¦³ç‚¹ã‹ã‚‰ã¯ã€ã‚ã‚‹ç¨®ã®ã‚¯ã‚¨ãƒªã® <tt>not</tt> ã¯ã€ãã®ã‚¯ã‚¨ãƒªã‚’æº€ãŸã›ã‚‹ã™ã¹ã¦ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’å–ã‚Šé™¤ããƒ•ã‚£ãƒ«ã‚¿ã¨ã—ã¦æŒ¯ã‚‹èˆã†ã€‚
ãŸã¨ãˆã°ã€ä»¥ä¸‹ã®ãƒ‘ã‚¿ãƒ³ãŒä¸ãˆã‚‰ã‚Œã‚‹ã¨ã€
</p>

<p class="lisp">(not (job ?x (computer programmer)))
</p>

<p class="orig" lang="en">we attempt, for each frame in the input stream, to produce extension
frames that satisfy <tt>(job ?x (computer programmer))</tt>.  We remove
from the input stream all frames for which such extensions exist.  The
result is a stream consisting of only those frames in which the
binding for <tt>?x</tt> does not satisfy <tt>(job ?x (computer
programmer))</tt>.  For example, in processing the query</p>

<p class="trans" lang="ja">
å…¥åŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ ä¸­ã®å„ãƒ•ãƒ¬ãƒ¼ãƒ ã«å¯¾ã—ã¦ã€
<tt>(job ?x (computer programmer))</tt>
ã‚’æº€ãŸã™æ‹¡å¼µãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ä½œã‚Šå‡ºãã†ã¨è©¦ã¿ã‚‹ã€‚
ãã†ã—ãŸæ‹¡å¼µãŒå­˜åœ¨ã™ã‚‹ã‚ˆã†ãªã™ã¹ã¦ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ã€å…¥åŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‹ã‚‰å–ã‚Šé™¤ãã€‚
ãã®çµæœã¯ã€<tt>?x</tt> ã«å¯¾ã™ã‚‹æŸç¸›ãŒ
<tt>(job ?x (computer programmer))</tt>
ã‚’æº€ãŸã•ãªã„ã‚ˆã†ãªãƒ•ãƒ¬ãƒ¼ãƒ ã®ã¿ã‹ã‚‰ãªã‚‹ã‚¹ãƒˆãƒªãƒ¼ãƒ ã§ã‚ã‚‹ã€‚
ãŸã¨ãˆã°ã€ä»¥ä¸‹ã®ã‚¯ã‚¨ãƒªã‚’å‡¦ç†ã™ã‚‹éš›ã«ã€
</p>

<p class="lisp">(and (supervisor ?x ?y)
     (not (job ?x (computer programmer))))
</p>

<p class="orig" lang="en">the first clause will generate frames with bindings for <tt>?x</tt> and
<tt>?y</tt>.  The <tt>not</tt> clause will then filter
these by removing all frames in which the binding for <tt>?x</tt>
satisfies the restriction that <tt>?x</tt> is a computer
programmer.<a name="call_footnote_Temp_674" href="#footnote_Temp_674"><sup><small>70</small></sup></a></p>

<p class="trans" lang="ja">
1ç•ªç›®ã®ç¯€ã¯ã€<tt>?x</tt> ã¨ <tt>?y</tt> ã«å¯¾ã™ã‚‹æŸç¸›ã‚’æœ‰ã™ã‚‹ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ç”Ÿæˆã™ã‚‹ã ã‚ã†ã€‚
ãã‚Œã‹ã‚‰ã€<tt>not</tt> ç¯€ãŒã“ã‚Œã‚‰ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ãƒ•ã‚£ãƒ«ã‚¿ã«ã‹ã‘ã‚‹ã ã‚ã†â€”â€” <tt>?x</tt> ã¯ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ»ãƒ—ãƒ­ã‚°ãƒ©ãƒã ã¨ã„ã†åˆ¶ç´„ã‚’ã€<tt>?x</tt> ã«å¯¾ã™ã‚‹æŸç¸›ãŒæº€ãŸã—ã¦ã„ã‚‹ã‚ˆã†ãªã™ã¹ã¦ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’å–ã‚Šé™¤ãã“ã¨ã«ã‚ˆã£ã¦<a href="#footnote_Temp_674"><sup><small>70</small></sup></a>ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_5206"></a>The <tt>lisp-value</tt> special form is implemented as a similar filter
on frame streams.  We use each frame in the stream to instantiate any
variables in the pattern, then apply the Lisp predicate.  We remove
from the input stream all frames for which the predicate fails.
</p>

<p class="trans" lang="ja">
<tt>lisp-value</tt> ç‰¹æ®Šå½¢å¼ã¯ã€ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ»ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«å¯¾ã™ã‚‹é¡ä¼¼ã®ãƒ•ã‚£ãƒ«ã‚¿ã¨ã—ã¦å®Ÿè£…ã•ã‚Œã‚‹ã€‚
ãƒ‘ã‚¿ãƒ³å†…ã®ä»»æ„ã®å¤‰æ•°ã‚’ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã™ã‚‹ã®ã«ã€ç§ãŸã¡ã¯ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ å†…ã®å„ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ç”¨ã„ã€ãã‚Œã‹ã‚‰ã€Lisp è¿°èªã‚’é©ç”¨ã™ã‚‹ã€‚
è¿°èªãŒå¤±æ•—ã™ã‚‹ã‚ˆã†ãªã™ã¹ã¦ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ã€ç§ãŸã¡ã¯å…¥åŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‹ã‚‰å–ã‚Šé™¤ãã€‚
</p>


<a name="%_sec_Temp_675"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_675">Unification</a></h4>
<h4 class="trans" lang="ja">ãƒ¦ãƒ‹ãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³</h4>

<p class="orig" lang="en">
<a name="%_idx_5208"></a><a name="%_idx_5210"></a>
In order to handle rules in the query language, we must be able to
find the rules whose conclusions match a given query pattern.  Rule
conclusions are like assertions except that they can contain
variables, so we will need a generalization of pattern
matching -- called <em>unification</em> -- in which both the ``pattern''
and the ``datum'' may contain variables.</p>

<p class="trans" lang="ja">
ã‚¯ã‚¨ãƒªè¨€èªã§ã®è¦å‰‡ã‚’æ‰±ã†ãŸã‚ã«ã¯ã€ä¸ãˆã‚‰ã‚ŒãŸã‚¯ã‚¨ãƒªãƒ»ãƒ‘ã‚¿ãƒ³ã«å¸°çµéƒ¨ãŒåˆè‡´ã™ã‚‹ã‚ˆã†ãªè¦å‰‡ã‚’æ±‚ã‚ã‚‹ã“ã¨ãŒã§ããªãã¦ã¯ãªã‚‰ãªã„ã€‚
è¦å‰‡ã®å¸°çµéƒ¨ã¯ã€å¤‰æ•°ã‚’å«ã‚€ã“ã¨ãŒã§ãã‚‹ã¨ã„ã†ç‚¹ã‚’é™¤ã„ã¦è¨€æ˜ã¨ä¼¼ã¦ãŠã‚Šã€ã—ãŸãŒã£ã¦ã€ã€Œãƒ‘ã‚¿ãƒ³ã€ã¨ã€Œãƒ‡ãƒ¼ã‚¿ã€ã®åŒæ–¹ãŒå¤‰æ•°ã‚’å«ã‚€ã“ã¨ã®ã‚ã‚Šå¾—ã‚‹ã€ãƒ‘ã‚¿ãƒ³ãƒ»ãƒãƒƒãƒãƒ³ã‚°ã®ä¸€èˆ¬åŒ–â€”â€”<em>ãƒ¦ãƒ‹ãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³</em>ã¨å‘¼ã°ã‚Œã‚‹â€”â€”ãŒã€å¿…è¦ã¨ãªã‚‹ã ã‚ã†ã€‚
</p>

<p class="orig" lang="en">
A unifier takes two patterns, each containing constants and variables,
and determines whether it is possible to assign values to the
variables that will make the two patterns equal.  If so, it returns a
frame containing these bindings.  For example, unifying <tt>(?x a
?y)</tt> and <tt>(?y ?z a)</tt> will specify a frame in which <tt>?x</tt>, 
<tt>?y</tt>, and <tt>?z</tt> must all be bound to <tt>a</tt>.  On the other
hand, unifying <tt>(?x ?y a)</tt> and <tt>(?x b ?y)</tt> will fail, because
there is no value for <tt>?y</tt> that can make the two patterns equal.
(For the second elements of the patterns to be equal, <tt>?y</tt> would
have to be <tt>b</tt>; however, for the third elements to be equal, <tt>?y</tt> would have to be <tt>a</tt>.)  The unifier used in the query system,
like the pattern matcher, takes a frame as input and performs
unifications that are consistent with this frame.</p>

<p class="trans" lang="ja">
<ruby><rb>çµ±ä¸€å™¨</rb><rp> (</rp><rt>ãƒ¦ãƒ‹ãƒ•ã‚¡ã‚¤ã‚¢</rt><rp>) </rp></ruby>ã¯ã€äºŒã¤ã®ãƒ‘ã‚¿ãƒ³â€”â€”ãã®å„ã€…ã¯å®šæ•°ã¨å¤‰æ•°ã‚’å«ã‚€â€”â€”ã‚’ã¨ã‚Šã€ãã—ã¦ã€äºŒã¤ã®ãƒ‘ã‚¿ãƒ³ã‚’ç­‰ä¾¡ã«ã™ã‚‹ã‚ˆã†ã«å€¤ã‚’å¤‰æ•°ã«<ruby><rb>ä»£å…¥ã™ã‚‹</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦ã‚‹</rt><rp>) </rp></ruby>ã“ã¨ãŒå¯èƒ½ã‹ã©ã†ã‹ã‚’ã€åˆ¤å®šã™ã‚‹ã€‚<!-- <span class="note">(ã“ã“ã® that ã¯ so that ã®ç•¥)</span> -->
ã‚‚ã—å¯èƒ½ãªã‚‰ã€ãƒ¦ãƒ‹ãƒ•ã‚¡ã‚¤ã‚¢ã¯ã€ã“ã‚Œã‚‰ã®æŸç¸›ã‚’å«ã‚€ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’è¿”ã™ã€‚
ãŸã¨ãˆã°ã€<tt>(?x a ?y)</tt> ã¨ <tt>(?y ?z a)</tt> ã‚’<ruby><rb>çµ±ä¸€</rb><rp> (</rp><rt>ãƒ¦ãƒ‹ãƒ•ã‚¡ã‚¤</rt><rp>) </rp></ruby>ã™ã‚‹ã“ã¨ã§ã€<tt>?x</tt> ã¨ <tt>?y</tt> ã¨ <tt>?z</tt> ã®ã™ã¹ã¦ãŒ <tt>a</tt> ã«æŸç¸›ã•ã‚Œã¦ã„ã‚‹ã¯ãšã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ã«ãªã‚‹ã ã‚ã†ã€‚
ä»–æ–¹ã€<tt>(?x ?y a)</tt> ã¨ <tt>(?x b ?y)</tt> ã®ãƒ¦ãƒ‹ãƒ•ã‚¡ã‚¤ã¯å¤±æ•—ã™ã‚‹ã ã‚ã†ã€‚ãªãœãªã‚‰ã€äºŒã¤ã®ãƒ‘ã‚¿ãƒ³ã‚’ç­‰ã—ãã™ã‚‹ã“ã¨ã®å¯èƒ½ãªã€<tt>?y</tt> ã«å¯¾ã™ã‚‹å€¤ã¯å­˜åœ¨ã—ãªã„ãŸã‚ã§ã‚ã‚‹ (ãƒ‘ã‚¿ãƒ³ã®2ç•ªç›®ã®è¦ç´ ã‚’ç­‰ã—ãã™ã‚‹ãŸã‚ã«ã¯ã€<tt>?y</tt> ã¯ <tt>b</tt> ã§ãªãã¦ã¯ãªã‚‰ãªã„ã ã‚ã†ã€‚ã—ã‹ã—ã€3ç•ªç›®ã®è¦ç´ ã‚’ç­‰ã—ãã™ã‚‹ãŸã‚ã«ã¯ã€<tt>?y</tt> ã¯ <tt>a</tt> ã§ãªãã¦ã¯ãªã‚‰ãªã„ã ã‚ã†)ã€‚
ã‚¯ã‚¨ãƒªãƒ»ã‚·ã‚¹ãƒ†ãƒ ã§ä½¿ã‚ã‚Œã‚‹ãƒ¦ãƒ‹ãƒ•ã‚¡ã‚¤ã‚¢ã¯ã€ãƒ‘ã‚¿ãƒ³ãƒ»ãƒãƒƒãƒãƒ£ã¨åŒæ§˜ã«ã€å…¥åŠ›ã¨ã—ã¦ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ã¨ã‚Šã€ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã¨æ•´åˆæ€§ã®ã¨ã‚ŒãŸãƒ¦ãƒ‹ãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œã™ã‚‹ã€‚
</p>

<p class="orig" lang="en">
The unification algorithm is the most technically difficult part of
the query system.  With complex patterns, performing unification may
seem to require deduction.  To unify <tt>(?x ?x)</tt> and <tt>((a ?y c)
(a b ?z))</tt>, for example, the algorithm must infer that <tt>?x</tt> should
be <tt>(a b c)</tt>,   <tt>?y</tt> should be <tt>b</tt>, and <tt>?z</tt> should
be <tt>c</tt>.  We may think of this process as solving a set of
equations among the pattern components.  In general, these are
simultaneous equations, which may require substantial manipulation to
solve.<a name="call_footnote_Temp_676" href="#footnote_Temp_676"><sup><small>71</small></sup></a>  For example, unifying <tt>(?x
?x)</tt> and <tt>((a ?y c) (a b ?z))</tt> may be thought of as specifying the
simultaneous equations</p>

<p class="trans" lang="ja">
ãƒ¦ãƒ‹ãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ»ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯ã€ã‚¯ã‚¨ãƒªãƒ»ã‚·ã‚¹ãƒ†ãƒ ã®ã†ã¡ã§æœ€ã‚‚æŠ€è¡“çš„ã«å›°é›£ãªéƒ¨åˆ†ã§ã‚ã‚‹ã€‚
è¤‡é›‘ãªãƒ‘ã‚¿ãƒ³ãŒã‚ã‚‹å ´åˆã€ãƒ¦ãƒ‹ãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®å®Ÿè¡Œã¯ã€æ¼”ç¹¹ã‚’å¿…è¦ã¨ã™ã‚‹ã‚ˆã†ã«è¦‹ãˆã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚
ãŸã¨ãˆã°ã€<tt>(?x ?x)</tt> ã¨ <tt>((a ?y c) (a b ?z))</tt> ã‚’ãƒ¦ãƒ‹ãƒ•ã‚¡ã‚¤ã™ã‚‹ã«ã¯ã€ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯ã€ <tt>?x</tt> ãŒ <tt>(a b c)</tt> ã§ã‚ã‚‹ç­ˆã€ã‹ã¤ã€<tt>?y</tt> ãŒ <tt>b</tt> ã§ã‚ã‚‹ç­ˆã€ã‹ã¤ã€<tt>?z</tt> ãŒ <tt>c</tt> ã§ã‚ã‚‹ç­ˆã€ã¨æ¨æ¸¬ã›ã­ã°ãªã‚‰ãªã„ã€‚
ã“ã®ãƒ—ãƒ­ã‚»ã‚¹ã¯ã€ãƒ‘ã‚¿ãƒ³æˆåˆ†åŒå£«ã®é–“ã®æ–¹ç¨‹å¼ã®é›†åˆã‚’è§£ãã“ã¨ã ã¨è¦‹ãªã›ã‚‹ã€‚
ä¸€èˆ¬ã«ã€ã“ã‚Œã‚‰ã¯é€£ç«‹æ–¹ç¨‹å¼ã§ã‚ã‚Šã€ç‰¹ã«ã¯ç›¸å½“ãªæ“ä½œãŒå¿…è¦ã¨ãªã‚‹å ´åˆãŒã‚ã‚‹<a href="#footnote_Temp_676"><sup><small>71</small></sup></a>ã€‚
ãŸã¨ãˆã°ã€<tt>(?x ?x)</tt> ã¨ <tt>((a ?y c) (a b ?z))</tt> ã‚’ãƒ¦ãƒ‹ãƒ•ã‚¡ã‚¤ã™ã‚‹ã“ã¨ã‚’ã€ä»¥ä¸‹ã®é€£ç«‹æ–¹ç¨‹å¼ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ã ã¨è¦‹ãªã—ã¦ã‚‚ã‚ˆã„ã€‚
</p>

<p class="lisp">?x  =  (a ?y c)
?x  =  (a b ?z)
</p>

<p class="orig" lang="en">These equations imply that</p>

<p class="trans" lang="ja">
ã“ã‚Œã‚‰ã®æ–¹ç¨‹å¼ã¯ã€ä»¥ä¸‹ã‚’æš—ç¤ºã—ã¦ãŠã‚Šã€
</p>

<p class="lisp">(a ?y c)  =  (a b ?z)
</p>

<p class="orig" lang="en">which in turn implies that</p>

<p class="trans" lang="ja">
ã“ã‚ŒãŒã€ä»Šåº¦ã¯ä»¥ä¸‹ã‚’æš—ç¤ºã—ã¦ãŠã‚Šã€
</p>

<p class="lisp">a  =  a, ?y  =  b, c  =  ?z,
</p>

<p class="orig" lang="en">and hence that</p>

<p class="trans" lang="ja">
ã—ãŸãŒã£ã¦ã€ä»¥ä¸‹ã‚‚æš—ç¤ºã—ã¦ã„ã‚‹ã€‚
</p>

<p class="lisp">?x  =  (a b c)
</p>

<p class="orig" lang="en">
<a name="%_idx_5212"></a><a name="%_idx_5214"></a>In a successful pattern match, all pattern variables become bound, and
the values to which they are bound contain only constants.  This is
also true of all the examples of unification we have seen so far.  In
general, however, a successful unification may not completely
determine the variable values; some variables may remain unbound and
others may be bound to values that contain variables.</p>

<p class="trans" lang="ja">
æˆåŠŸã™ã‚‹ãƒ‘ã‚¿ãƒ³ãƒ»ãƒãƒƒãƒã§ã¯ã€ã™ã¹ã¦ã®ãƒ‘ã‚¿ãƒ³å¤‰æ•°ãŒæŸç¸›ã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã€ãã‚Œã‚‰ã®ãƒ‘ã‚¿ãƒ³å¤‰æ•°ãŒæŸç¸›ã•ã‚Œã‚‹å€¤ã¯ã€å®šæ•°ã®ã¿ã‚’å«ã‚€ã€‚
ã“ã®ã“ã¨ã¯ã€ã“ã‚Œã¾ã§ã«ç§ãŸã¡ãŒè¦‹ã¦ããŸãƒ¦ãƒ‹ãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ã™ã¹ã¦ã®ä¾‹ã«å½“ã¦ã¯ã¾ã‚‹ã€‚
ã—ã‹ã—ã€ä¸€èˆ¬ã«ã¯ã€æˆåŠŸã™ã‚‹ãƒ¦ãƒ‹ãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒå¤‰æ•°ã®å€¤ã‚’å®Œå…¨ã«æ±ºå®šã™ã‚‹ã¨ã¯é™ã‚‰ãªã„ã€‚ã„ãã¤ã‹ã®å¤‰æ•°ã¯ã€æŸç¸›ã•ã‚Œãªã„ã¾ã¾ã‹ã‚‚ã—ã‚Œãšã€ä»–ã®å¤‰æ•°ã‚‚ã€å¤‰æ•°ã‚’å«ã‚€å€¤ã«æŸç¸›ã•ã‚Œã¦ã„ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚
</p>

<p class="orig" lang="en">
Consider the unification of <tt>(?x a)</tt> and <tt>((b ?y) ?z)</tt>.  We
can deduce that <tt>?x  =  (b ?y)</tt> and <tt>a  =  ?z</tt>, but we cannot
further solve for <tt>?x</tt> or <tt>?y</tt>.  The unification doesn't fail,
since it is certainly possible to make the two patterns equal by
assigning values to <tt>?x</tt> and <tt>?y</tt>.  Since this match in no way
restricts the values <tt>?y</tt> can take on, no binding for <tt>?y</tt> is
put into the result frame.  The match does, however, restrict the
value of <tt>?x</tt>.  Whatever value <tt>?y</tt> has, <tt>?x</tt> must be <tt>(b ?y)</tt>.  A binding of <tt>?x</tt> to the pattern <tt>(b ?y)</tt> is thus
put into the frame.  If a value for <tt>?y</tt> is later determined and
added to the frame (by a pattern match or unification that is required
to be consistent with this frame), the previously bound <tt>?x</tt> will
refer to this value.<a name="call_footnote_Temp_677" href="#footnote_Temp_677"><sup><small>72</small></sup></a>
</p>

<p class="trans" lang="ja">
<tt>(?x a)</tt> ã¨ <tt>((b ?y) ?z)</tt> ã®ãƒ¦ãƒ‹ãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’è€ƒãˆã‚ˆã†ã€‚
<tt>?x = (b ?y)</tt> ã‹ã¤ <tt>a = ?z</tt> ã ã¨æ¼”ç¹¹ã§ãã‚‹ãŒã€<tt>?x</tt> ã«ã¤ã„ã¦ã‚‚ <tt>?y</tt> ã«ã¤ã„ã¦ã‚‚ã•ã‚‰ã«è§£ãã“ã¨ã¯ã§ããªã„ã€‚
<tt>?x</tt> ã¨ <tt>?y</tt> ã«å€¤ã‚’<ruby><rb>ä»£å…¥ã™ã‚‹</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦ã‚‹</rt><rp>) </rp></ruby>ã“ã¨ã§äºŒã¤ã®ãƒ‘ã‚¿ãƒ³ã‚’ç­‰ã—ãã™ã‚‹ã“ã¨ãŒç¢ºã‹ã«å¯èƒ½ãªã®ã§ã€ãƒ¦ãƒ‹ãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯å¤±æ•—ã—ãªã„ã€‚
ã“ã®ãƒãƒƒãƒã¯ã€<tt>?y</tt> ãŒå¸¯ã³ã‚‹ã“ã¨ã®ã§ãã‚‹å€¤ã‚’æ±ºã—ã¦åˆ¶é™ã—ãªã„ã®ã§ã€<tt>?y</tt> ã«å¯¾ã™ã‚‹æŸç¸›ã¯ä½•ã‚‚çµæœãƒ•ãƒ¬ãƒ¼ãƒ ã«è¡¨ç¾ã•ã‚Œãªã„ã€‚
ã—ã‹ã—ã€ãƒãƒƒãƒã¯ã€ç¢ºã‹ã« <tt>?x</tt> ã®å€¤ã‚’åˆ¶é™ã™ã‚‹ã€‚
<tt>?y</tt> ãŒã„ã‹ãªã‚‹å€¤ã‚’æŒã¨ã†ã¨ã€<tt>?x</tt> ã¯ <tt>(b ?y)</tt> ã§ãªãã¦ã¯ãªã‚‰ãªã„ã®ã ã€‚
<tt>(b ?y)</tt> ã¨ã„ã†ãƒ‘ã‚¿ãƒ³ã¸ã® <tt>?x</tt> ã®æŸç¸›ã¯ã€ã—ãŸãŒã£ã¦ã€ãƒ•ãƒ¬ãƒ¼ãƒ ã«è¡¨ç¾ã•ã‚Œã‚‹ã€‚
ã‚‚ã—å¾Œã«ã€(ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã¨æ•´åˆæ€§ãŒå–ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’è¦æ±‚ã•ã‚Œã‚‹ã‚ˆã†ãªã€ãƒ‘ã‚¿ãƒ³ãƒ»ãƒãƒƒãƒã¾ãŸã¯ãƒ¦ãƒ‹ãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«ã‚ˆã£ã¦) <tt>?y</tt> ã«å¯¾ã™ã‚‹å€¤ãŒæ±ºå®šã•ã‚Œã€ãƒ•ãƒ¬ãƒ¼ãƒ ã«è¿½åŠ ã•ã‚ŒãŸã‚‰ã€å…ˆã«æŸç¸›ã•ã‚ŒãŸ <tt>?x</tt> ã¯ã€ã“ã®å€¤ã‚’å‚ç…§ã™ã‚‹ã ã‚ã† <a href="#footnote_Temp_677"><sup><small>72</small></sup></a>ã€‚
</p>

<a name="%_sec_Temp_678"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_678">Applying rules</a></h4>
<h4 class="trans" lang="ja">è¦å‰‡ã‚’é©ç”¨ã™ã‚‹</h4>

<p class="orig" lang="en">
<a name="%_idx_5216"></a>
Unification is the key to the component of the query system that makes
inferences from rules. To see how this is accomplished, consider
processing a query that involves applying a rule, such as</p>

<p class="trans" lang="ja">
ãƒ¦ãƒ‹ãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯ã€è¦å‰‡ã‹ã‚‰æ¨è«–ã‚’è¡Œã†ã€ã‚¯ã‚¨ãƒªãƒ»ã‚·ã‚¹ãƒ†ãƒ ã®æ§‹æˆè¦ç´ ã¸ã®ã€éµã§ã‚ã‚‹ã€‚
ã“ã‚Œã‚’ã©ã®ã‚ˆã†ã«é”æˆã™ã‚‹ã®ã‹ã‚’è¦‹ã‚‹ãŸã‚ã«ã€ä»¥ä¸‹ã®ã‚ˆã†ãªã€è¦å‰‡ã®é©ç”¨ã‚’ä¼´ã†ã€ã‚¯ã‚¨ãƒªã®å‡¦ç†ã«ã¤ã„ã¦è€ƒãˆã‚ˆã†ã€‚
</p>

<p class="lisp">(lives-near ?x (Hacker Alyssa P))
</p>

<p class="orig" lang="en">To process this query, we first use the ordinary pattern-match
procedure described above to see if there are any assertions in the
data base that match this pattern.  (There will not be any in this
case, since our data base includes no direct assertions about who
lives near whom.)  The next step is to attempt to unify the query
pattern with the conclusion of each rule.  We find that the pattern
unifies with the conclusion of the rule</p>

<p class="trans" lang="ja">
ã“ã®ã‚¯ã‚¨ãƒªã‚’å‡¦ç†ã™ã‚‹ã«ã¯ã€ã¾ãšã€ã“ã®ãƒ‘ã‚¿ãƒ³ã«åˆè‡´ã™ã‚‹è¨€æ˜ãŒä½•ã‹ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å†…ã«ã‚ã‚‹ã‹ã©ã†ã‹ã‚’è¦‹ã‚‹ãŸã‚ã«ã€ä¸Šè¨˜ã®ã‚ˆã†ãªé€šå¸¸ã®ãƒ‘ã‚¿ãƒ³ãƒ»ãƒãƒƒãƒæ‰‹ç¶šãã‚’ä½¿ã†
(ã“ã®å ´åˆã¯ä½•ã‚‚ãªã„ã ã‚ã†ã€‚ãªãœãªã‚‰ã€èª°ãŒèª°ã®è¿‘ãã«ä½ã‚“ã§ã„ã‚‹ã‹ã«ã¤ã„ã¦ã®ç›´æ¥çš„è¨€æ˜ã‚’ã€ç§ãŸã¡ã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã¯ä½•ã‚‚å«ã‚“ã§ã„ãªã„ãŸã‚ã§ã‚ã‚‹)ã€‚
æ¬¡ã®æ®µéšã¯ã€ã‚¯ã‚¨ãƒªãƒ»ãƒ‘ã‚¿ãƒ³ã‚’å„è¦å‰‡ã®å¸°çµéƒ¨ã¨ãƒ¦ãƒ‹ãƒ•ã‚¡ã‚¤ã™ã‚‹ã“ã¨ã‚’è©¦ã¿ã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚
ã“ã®ãƒ‘ã‚¿ãƒ³ãŒã€ä»¥ä¸‹ã®è¦å‰‡ã®å¸°çµéƒ¨ã¨ãƒ¦ãƒ‹ãƒ•ã‚¡ã‚¤ã™ã‚‹ã€ã¨ã„ã†ã“ã¨ãŒåˆ†ã‹ã‚Šã€
</p>

<p class="lisp">(rule (lives-near ?person-1 ?person-2)
      (and (address ?person-1 (?town . ?rest-1))
           (address ?person-2 (?town . ?rest-2))
           (not (same ?person-1 ?person-2))))
</p>

<p class="orig" lang="en">resulting in a frame specifying that <tt>?person-2</tt> is bound
to <tt>(Hacker Alyssa P)</tt> and that <tt>?x</tt> should be bound to (have
the same value as) <tt>?person-1</tt>.  Now, relative to this frame, we
evaluate the compound query given by the body of the rule.  Successful
matches will extend this frame by providing a binding for <tt>?person-1</tt>, and consequently a value for <tt>?x</tt>, which we can use to
instantiate the original query pattern.</p>

<p class="trans" lang="ja">
ã“ã‚Œã¯ã€<tt>?person-2</tt> ãŒ <tt>(Hacker Alyssa P)</tt> ã«æŸç¸›ã•ã‚Œã¦ã„ã¦ <tt>?x</tt> ã¯ <tt>?person-1</tt> ã«æŸç¸›ã•ã‚Œã‚‹ (ã“ã‚Œã¨åŒã˜å€¤ã‚’æœ‰ã™ã‚‹) ã¹ãã§ã‚ã‚‹ã€ã¨æŒ‡å®šã™ã‚‹ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’çµæœã¨ã—ã¦ã‚‚ãŸã‚‰ã™ã‚‚ã®ã§ã‚ã‚‹ã€‚
ã•ã¦ã“ã“ã§ã€ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã«é–¢ã—ã¦ã€ç§ãŸã¡ã¯ã€è¦å‰‡ã®æœ¬ä½“éƒ¨ã«ã‚ˆã‚Šä¸ãˆã‚‰ã‚ŒãŸæ§‹æˆè¦ç´ ã‚¯ã‚¨ãƒªã‚’è©•ä¾¡ã™ã‚‹ã€‚
ã†ã¾ãã„ããƒãƒƒãƒã¯ã€<tt>?person-1</tt> ã«å¯¾ã™ã‚‹æŸç¸›ã‚’ã€ãã—ã¦ãã®çµæœã¨ã—ã¦ <tt>?x</tt> ã«å¯¾ã™ã‚‹å€¤â€”â€”å…ƒã®ã‚¯ã‚¨ãƒªãƒ»ãƒ‘ã‚¿ãƒ³ã‚’ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã™ã‚‹ã®ã«ä½¿ãˆã‚‹â€”â€”ã‚’ã€ä¸ãˆã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’æ‹¡å¼µã™ã‚‹ã ã‚ã†ã€‚
</p>

<p class="orig" lang="en">
In general, the query evaluator uses the following method to apply a
rule when trying to establish a query pattern in a frame that
specifies bindings for some of the pattern variables:</p>

<p class="trans" lang="ja">
ä¸€èˆ¬ã«ã€ã‚¯ã‚¨ãƒªè©•ä¾¡å™¨ã¯ã€ãƒ‘ã‚¿ãƒ³å¤‰æ•°ã®ã†ã¡ã®ä¸€éƒ¨ã«å¯¾ã™ã‚‹æŸç¸›ã‚’æŒ‡å®šã™ã‚‹ãƒ•ãƒ¬ãƒ¼ãƒ å†…ã§ã‚¯ã‚¨ãƒªãƒ»ãƒ‘ã‚¿ãƒ³ã‚’æˆç«‹ã•ã›ã‚ˆã†ã¨è©¦ã¿ã‚‹éš›ã«ã€ä»¥ä¸‹ã®æ–¹æ³•ã‚’ä½¿ã£ã¦è¦å‰‡ã‚’é©ç”¨ã™ã‚‹ã€‚
</p>

<ul class="orig" lang="en">
<li>Unify the query with the conclusion of the rule to form, if
successful, an extension of the original frame.</li>

<li>Relative to the extended frame, evaluate the query formed by
the body of the rule.</li>
</ul>

<ul class="trans" lang="ja">
<li>ã‚¯ã‚¨ãƒªã‚’è¦å‰‡ã®å¸°çµéƒ¨ã¨ãƒ¦ãƒ‹ãƒ•ã‚¡ã‚¤ã—ã¦ã€ã‚‚ã—ãã‚ŒãŒã†ã¾ãã„ã‘ã°ã€å…ƒã®ãƒ•ãƒ¬ãƒ¼ãƒ ã®æ‹¡å¼µã‚’å½¢æˆã›ã‚ˆã€‚</li>
<li>æ‹¡å¼µã•ã‚ŒãŸãƒ•ãƒ¬ãƒ¼ãƒ ã«é–¢ã—ã¦ã€è¦å‰‡ã®æœ¬ä½“éƒ¨ã«ã‚ˆã‚Šå½¢æˆã•ã‚Œã‚‹ã‚¯ã‚¨ãƒªã‚’è©•ä¾¡ã›ã‚ˆã€‚</li>
</ul>

<p class="orig" lang="en">
<a name="%_idx_5218"></a>Notice how similar this is to the method for applying a procedure in
the <tt>eval</tt>/<tt>apply</tt> evaluator for Lisp:
</p>

<p class="trans" lang="ja">
ã“ã‚ŒãŒã€Lispç”¨ã® <tt>eval</tt>/<tt>apply</tt> è©•ä¾¡å™¨ã«ãŠã„ã¦æ‰‹ç¶šãã‚’é©ç”¨ã™ã‚‹æ–¹æ³•ã¨ã€ã„ã‹ã«ä¼¼ã¦ã„ã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã«æ°—ã¥ã„ã¦ã»ã—ã„ã€‚
</p>

<ul class="orig" lang="en">
<li>Bind the procedure's parameters to its arguments to form a
frame that extends the original procedure environment.</li>

<li>Relative to the extended environment, evaluate the expression
formed by the body of the procedure.</li>
</ul>

<ul class="trans" lang="ja">
<li>æ‰‹ç¶šãã®ä»®å¼•æ•°ã‚’å®Ÿå¼•æ•°ã«æŸç¸›ã—ã¦ã€å…ƒã®æ‰‹ç¶šãç’°å¢ƒã‚’æ‹¡å¼µã™ã‚‹ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’å½¢æˆã›ã‚ˆã€‚</li>
<li>æ‹¡å¼µã•ã‚ŒãŸç’°å¢ƒã«é–¢ã—ã¦ã€æ‰‹ç¶šãã®æœ¬ä½“éƒ¨ã«ã‚ˆã‚Šå½¢æˆã•ã‚Œã‚‹å¼ã‚’è©•ä¾¡ã›ã‚ˆã€‚</li>
</ul>

<p class="orig" lang="en">
The similarity between the two evaluators should come as no surprise.
Just as procedure definitions are the means of abstraction in Lisp,
rule definitions are the means of abstraction in the query language.
In each case, we unwind the abstraction by creating appropriate
bindings and evaluating the rule or procedure body relative to these.
</p>

<p class="trans" lang="ja">
äºŒã¤ã®è©•ä¾¡å™¨ã®é¡ä¼¼æ€§ã¯ã€ä½•ã®é©šãã§ã‚‚ãªã„ã¯ãšã ã€‚
æ‰‹ç¶šãå®šç¾©ãŒLispã«ãŠã‘ã‚‹æŠ½è±¡åŒ–ã®æ‰‹æ®µã§ã‚ã‚‹ã®ã¨ã¡ã‚‡ã†ã©åŒã˜ã‚ˆã†ã«ã€è¦å‰‡å®šç¾©ã¯ã‚¯ã‚¨ãƒªè¨€èªã«ãŠã‘ã‚‹æŠ½è±¡åŒ–ã®æ‰‹æ®µã§ã‚ã‚‹ã€‚
ãã‚Œãã‚Œã®å ´åˆã«ãŠã„ã¦ã€ç§ãŸã¡ã¯ã€é©åˆ‡ãªæŸç¸›ã‚’ä½œã‚Šå‡ºã™ã“ã¨ã¨ã€ã“ã‚Œã‚‰ã®æŸç¸›ã«é–¢ã—ã¦è¦å‰‡ã¾ãŸã¯æ‰‹ç¶šãã®æœ¬ä½“ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€æŠ½è±¡åŒ–ã‚’è§£ãã»ãã™ã®ã ã€‚
</p>

<a name="%_sec_Temp_679"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_679">Simple queries</a></h4>
<h4 class="trans" lang="ja">å˜ç´”ã‚¯ã‚¨ãƒª</h4>

<p class="orig" lang="en">
<a name="%_idx_5220"></a>
We saw earlier in this section how to evaluate simple queries in the
absence of rules.  Now that we have seen how to apply rules, we can
describe how to evaluate simple queries by using both rules and
assertions.</p>

<p class="trans" lang="ja">
æœ¬ç¯€ã®åˆã‚ã®æ–¹ã§ã¯ã€è¦å‰‡ãªã—ã§å˜ç´”ã‚¯ã‚¨ãƒªã‚’ã©ã®ã‚ˆã†ã«ã—ã¦è©•ä¾¡ã™ã‚‹ã®ã‹ã‚’è¦‹ãŸã€‚
ä»Šã‚„ç§ãŸã¡ã¯ã€è¦å‰‡ã‚’ã©ã®ã‚ˆã†ã«é©ç”¨ã™ã‚‹ã®ã‹ã‚’æ—¢ã«è¦‹ãŸè¨³ãªã®ã§ã€è¦å‰‡ã¨è¨€æ˜ã®åŒæ–¹ã‚’ç”¨ã„ã‚‹ã“ã¨ã§å˜ç´”ã‚¯ã‚¨ãƒªã‚’ã©ã®ã‚ˆã†ã«ã—ã¦è©•ä¾¡ã™ã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’è¨˜è¿°ã§ãã‚‹ã€‚
</p>

<p class="orig" lang="en">
Given the query pattern and a stream of frames, we produce, for each
frame in the input stream, two streams:</p>

<p class="trans" lang="ja">
ã‚¯ã‚¨ãƒªãƒ»ãƒ‘ã‚¿ãƒ³ã¨ã€ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¨ã‚’ä¸ãˆã‚‰ã‚Œã‚‹ã¨ã€ç§ãŸã¡ã¯ã€å…¥åŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ å†…ã®å„ãƒ•ãƒ¬ãƒ¼ãƒ ã«ã¤ã„ã¦ã€æ¬¡ã®äºŒã¤ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½œã‚Šå‡ºã™ã€‚
</p>

<ul class="orig" lang="en">
<li>a stream of extended frames obtained by matching the pattern
against all assertions in the data base (using the pattern matcher),
and</li>

<li>a stream of extended frames obtained by applying all
possible rules (using the unifier).<a name="call_footnote_Temp_680" href="#footnote_Temp_680"><sup><small>73</small></sup></a></li>
</ul>

<ul class="trans" lang="ja">
<li>ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å†…ã®ã™ã¹ã¦ã®è¨€æ˜ã«å¯¾ã—ã¦ãƒ‘ã‚¿ãƒ³ã‚’ãƒãƒƒãƒã•ã›ã‚‹ã“ã¨ã«ã‚ˆã£ã¦å¾—ã‚‰ã‚Œã‚‹ã€æ‹¡å¼µã•ã‚ŒãŸãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰ãªã‚‹ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã€‚</li>
<li>ã™ã¹ã¦ã®å¯èƒ½ãªè¦å‰‡ã‚’ (ãƒ¦ãƒ‹ãƒ•ã‚¡ã‚¤ã‚¢ã‚’ç”¨ã„ã¦) é©ç”¨ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦å¾—ã‚‰ã‚Œã‚‹ã€æ‹¡å¼µã•ã‚ŒãŸãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰ãªã‚‹ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ <a href="#footnote_Temp_680"><sup><small>73</small></sup></a>ã€‚</li>
</ul>

<p class="orig" lang="en">
Appending these two streams produces a stream that consists of all the
ways that the given pattern can be satisfied consistent with the
original frame.  These streams (one for each frame in the input
stream) are now all combined to form one large stream, which therefore
consists of all the ways that any of the frames in the original input
stream can be extended to produce a match with the given pattern.</p>

<p class="trans" lang="ja">
ã“ã‚Œã‚‰äºŒé€šã‚Šã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ã¤ãªã’ã‚‹ã“ã¨ã§ã€å…ƒã®ãƒ•ãƒ¬ãƒ¼ãƒ ã¨æ•´åˆæ€§ã‚’ä¿ã¡ã¤ã¤ã‚‚ä¸ãˆã‚‰ã‚ŒãŸãƒ‘ã‚¿ãƒ³ã‚’æº€ãŸã›ã‚‹ã‚ˆã†ãªã€ã™ã¹ã¦ã®æ–¹æ³•ã‹ã‚‰ãªã‚‹ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒã€ä½œã‚Šå‡ºã•ã‚Œã‚‹ã€‚
ã“ã‚Œã‚‰ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ  (å…¥åŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ å†…ã®å„ãƒ•ãƒ¬ãƒ¼ãƒ ã«ã¤ãã€ä¸€ã¤ã‚ã‚‹) ã¯ã€ä»Šã‚„ã€ã™ã¹ã¦ãŒçµåˆã•ã‚Œã¦ã€ä¸€ã¤ã®å·¨å¤§ãªã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å½¢æˆã—ã€ã—ãŸãŒã£ã¦ãã®å·¨å¤§ãªã‚¹ãƒˆãƒªãƒ¼ãƒ ã¯ã€å…ƒã®å…¥åŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ å†…ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã†ã¡ã®ã©ã‚Œã‹ã‚’ã€ä¸ãˆã‚‰ã‚ŒãŸãƒ‘ã‚¿ãƒ³ã¨ã®ãƒãƒƒãƒã‚’ä½œã‚Šå‡ºã™ã‚ˆã†ã«æ‹¡å¼µã™ã‚‹ã“ã¨ãŒå¯èƒ½ãªã€ã™ã¹ã¦ã®æ–¹æ³•ã‹ã‚‰ãªã‚‹ã€‚
</p>


<a name="%_sec_Temp_681"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_681">The query evaluator and the driver loop</a></h4>
<h4 class="trans" lang="ja">ã‚¯ã‚¨ãƒªã®è©•ä¾¡å™¨ã¨ãƒ‰ãƒ©ã‚¤ãƒãƒ»ãƒ«ãƒ¼ãƒ—</h4>

<p class="orig" lang="en">
<a name="%_idx_5226"></a>
Despite the complexity of the underlying matching operations, the
system is organized much like an evaluator for any language.  The
procedure that coordinates the matching operations is called <a name="%_idx_5228"></a><a name="%_idx_5230"></a><tt>qeval</tt>, and it plays a role analogous to that of the <tt>eval</tt>
procedure for Lisp.  <tt>Qeval</tt> takes as inputs a query and a stream
of frames.  Its output is a stream of frames, corresponding to
successful matches to the query pattern, that extend some frame in the
input stream, as indicated in figure <a href="#%_fig_4.4">4.4</a>.  Like
<tt>eval</tt>, <tt>qeval</tt> classifies the different types of expressions
(queries) and dispatches to an appropriate procedure for each.  There
is a procedure for each special form (<tt>and</tt>, <tt>or</tt>, <tt>not</tt>,
and <tt>lisp-value</tt>) and one for simple queries.</p>

<p class="trans" lang="ja">
æ ¹åº•ã«ã‚ã‚‹ãƒãƒƒãƒãƒ³ã‚°æ¼”ç®—ã®è¤‡é›‘ã•ã«ã‚‚ã‹ã‹ã‚ã‚‰ãšã€ã‚·ã‚¹ãƒ†ãƒ ã¯ã€ä»»æ„ã®è¨€èªã®è©•ä¾¡å™¨ã¨ã»ã¨ã‚“ã©åŒæ§˜ã«ä½“ç³»åŒ–ã•ã‚Œã¦ã„ã‚‹ã€‚
ãƒãƒƒãƒãƒ³ã‚°æ¼”ç®—ã‚’èª¿æ•´ã™ã‚‹æ‰‹ç¶šãã¯ <tt>qeval</tt> ã¨å‘¼ã°ã‚Œã€ã“ã‚Œã¯ã€Lispã«å¯¾ã™ã‚‹ <tt>eval</tt> æ‰‹ç¶šãã®å½¹å‰²ã¨ä¼¼ãŸå½¹å‰²ã‚’æœãŸã™ã€‚
<tt>qeval</tt> ã¯ã€ã‚¯ã‚¨ãƒªã¨ã€ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¨ã‚’ã€å…¥åŠ›ã¨ã—ã¦ã¨ã‚‹ã€‚
ã“ã‚Œã®å‡ºåŠ›ã¯ã€å›³<a href="#%_fig_4.4">4.4</a>ã«ç¤ºã—ãŸã‚ˆã†ã«ã€å…¥åŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ å†…ã®ä½•ã‚‰ã‹ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’æ‹¡å¼µã™ã‚‹ã‚ˆã†ãªãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ â€”â€”ã‚¯ã‚¨ãƒªãƒ»ãƒ‘ã‚¿ãƒ³ã«å¯¾ã™ã‚‹ã€æˆåŠŸã—ãŸãƒãƒƒãƒã«å¯¾å¿œã—ã¦ã„ã‚‹â€”â€”ã§ã‚ã‚‹ã€‚
<tt>eval</tt> ã¨åŒæ§˜ã« <tt>qeval</tt> ã‚‚ã€ç•°ãªã‚‹ç¨®é¡ã®å¼ (ã‚¯ã‚¨ãƒª) ã‚’åˆ†é¡ã—ã€ãã‚Œãã‚Œã«ã¤ã„ã¦ã€é©åˆ‡ãªæ‰‹ç¶šãã¸ã®æŒ¯ã‚Šåˆ†ã‘ã‚’è¡Œã†ã€‚
å„ç‰¹æ®Šå½¢å¼  (<tt>and</tt> ã¨ <tt>or</tt> ã¨ <tt>not</tt> ã¨ <tt>lisp-value</tt>) ã«å¯¾ã—ã¦æ‰‹ç¶šããŒã‚ã‚Šã€å˜ç´”ã‚¯ã‚¨ãƒªã«å¯¾ã—ã¦ä¸€ã¤ã®æ‰‹ç¶šããŒã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_5232"></a><a name="%_idx_5234"></a>The driver loop, which is analogous to the <tt>driver-loop</tt> procedure
for the other evaluators in this chapter, reads queries from the
terminal.  For each query, it calls <tt>qeval</tt> with the query and a
stream that consists of a single empty frame.  This will produce the
stream of all possible matches (all possible extensions to the empty
frame).  For each frame in the resulting stream, it instantiates the
original query using the values of the variables found in the frame.
This stream of instantiated queries is then printed.<a name="call_footnote_Temp_682" href="#footnote_Temp_682"><sup><small>74</small></sup></a></p>

<p class="trans" lang="ja">
ãƒ‰ãƒ©ã‚¤ãƒãƒ»ãƒ«ãƒ¼ãƒ—ã¯ã€æœ¬ç« ã§ã®åˆ¥ã®è©•ä¾¡å™¨ç”¨ã® <tt>driver-loop</tt> æ‰‹ç¶šãã¨ä¼¼ã¦ã„ã‚‹ã®ã ãŒã€ã“ã‚Œã¯ã€ã‚¯ã‚¨ãƒªã‚’ç«¯æœ«ã‹ã‚‰èª­ã¿è¾¼ã‚€ã€‚
å„ã‚¯ã‚¨ãƒªã«å¯¾ã—ã¦ã€ãƒ‰ãƒ©ã‚¤ãƒãƒ»ãƒ«ãƒ¼ãƒ—ã¯ã€å½“è©²ã‚¯ã‚¨ãƒªã¨ã€å˜ä¸€ã®ç©ºãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰ãªã‚‹ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¨ã¨ã‚‚ã«ã€<tt>qeval</tt> ã‚’å‘¼ã³å‡ºã™ã€‚
ã“ã‚Œã¯ã€ã™ã¹ã¦ã®å¯èƒ½ãªãƒãƒƒãƒ (ç©ºãƒ•ãƒ¬ãƒ¼ãƒ ã«å¯¾ã™ã‚‹ã€ã™ã¹ã¦ã®å¯èƒ½ãªæ‹¡å¼µ) ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½œã‚Šå‡ºã™ã ã‚ã†ã€‚
çµæœã¨ã—ã¦ç”Ÿã˜ã‚‹ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®ä¸­ã®å„ãƒ•ãƒ¬ãƒ¼ãƒ ã«ã¤ã„ã¦ã€ãƒ‰ãƒ©ã‚¤ãƒãƒ»ãƒ«ãƒ¼ãƒ—ã¯ã€å½“è©²ãƒ•ãƒ¬ãƒ¼ãƒ å†…ã§è¦‹ã¤ã‹ã‚‹å¤‰æ•°ã®å€¤ã‚’ç”¨ã„ã¦ã€å…ƒã®ã‚¯ã‚¨ãƒªã‚’ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã™ã‚‹ã€‚
ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã•ã‚ŒãŸã‚¯ã‚¨ãƒªã®ã€ã“ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒã€ãã‚Œã‹ã‚‰å°å­—ã•ã‚Œã‚‹ <a href="#footnote_Temp_682"><sup><small>74</small></sup></a>ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_5240"></a><a name="%_idx_5242"></a>The driver also checks for the special command <tt>assert!</tt>, which
signals that the input is not a query but rather an assertion or rule
to be added to the data base.  For instance,</p>

<p class="trans" lang="ja">
ãƒ‰ãƒ©ã‚¤ãƒã¯ã€<tt>assert!</tt> ã¨ã„ã†ç‰¹æ®Šå‘½ä»¤â€”â€”å…¥åŠ›ãŒã‚¯ã‚¨ãƒªã§ã¯ãªãã¦ã€ã‚€ã—ã‚ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«è¿½åŠ ã•ã‚Œã‚‹ã¹ãè¨€æ˜ã¾ãŸã¯è¦å‰‡ãªã®ã ã€ã¨åˆå›³ã‚’ã‚ˆã“ã—ã¦çŸ¥ã‚‰ã›ã‚‹â€”â€”ã‚‚ã€ç¢ºèªã™ã‚‹ã€‚
ãŸã¨ãˆã°ã€ä»¥ä¸‹ã®ã‚ˆã†ãªã‚‚ã®ã§ã‚ã‚‹ã€‚
</p>

<p class="lisp">(assert! (job (Bitdiddle Ben) (computer wizard)))
(assert! (rule (wheel ?person)
               (and (supervisor ?middle-manager ?person)
                    (supervisor ?x ?middle-manager))))
</p>

<a name="%_sec_4.4.3"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_4.4.3">4.4.3  Is Logic Programming Mathematical Logic?</a></h3>
<h3 class="trans" lang="ja">4.4.3 è«–ç†ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã¯æ•°å­¦çš„è«–ç†ãªã®ã‹?</h3>


<p class="orig" lang="en"><a name="%_idx_5244"></a><a name="%_idx_5246"></a>
The means of combination used in the query language may at first seem
identical to the operations <tt>and</tt>, <tt>or</tt>, and <tt>not</tt> of
mathematical logic, and the application of query-language rules is in
fact accomplished through a legitimate method of
<a name="%_idx_5248"></a>inference.<a name="call_footnote_Temp_683" href="#footnote_Temp_683"><sup><small>75</small></sup></a> This identification of the query language with mathematical
logic is not really valid, though, because the query language provides
a <a name="%_idx_5252"></a><em>control structure</em> that interprets the logical statements
procedurally.  We can often take advantage of this control structure.
For example, to find all of the supervisors of programmers we could
formulate a query in either of two logically equivalent forms:</p>

<p class="trans" lang="ja">
ã‚¯ã‚¨ãƒªè¨€èªã§ä½¿ã‚ã‚Œã‚‹çµåˆæ‰‹æ®µã¯ã€æœ€åˆã¯ã€æ•°å­¦çš„è«–ç†ã® <tt>and</tt> ã¨ <tt>or</tt> ã¨ <tt>not</tt> ã¨ã„ã†æ¼”ç®—ã¨åŒä¸€ãªã‚ˆã†ã«è¦‹ãˆã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã—ã€ã‚¯ã‚¨ãƒªè¨€èªã®è¦å‰‡ã®é©ç”¨ã¯ã€å®Ÿéš›ã€æ¨è«–ã®æ­£å½“ãªæ–¹æ³•ã‚’é€šã˜ã¦é”æˆã•ã‚Œã‚‹<a href="#footnote_Temp_683"><sup><small>75</small></sup></a>ã€‚
ã—ã‹ã—ã€ã“ã®ã‚ˆã†ã«ã‚¯ã‚¨ãƒªè¨€èªã‚’æ•°å­¦çš„è«–ç†ã¨åŒä¸€è¦–ã™ã‚‹ã“ã¨ã¯ã€ç¾å®Ÿã«ã¯ã€å¦¥å½“ã§ã¯ãªã„ã€‚ãªãœãªã‚‰ã€ã‚¯ã‚¨ãƒªè¨€èªã¯ã€è«–ç†çš„ãª<ruby><rb>æ–‡</rb><rp> (</rp><rt>ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆ</rt><rp>) </rp></ruby>ã‚’æ‰‹ç¶šãçš„ã«è§£é‡ˆã™ã‚‹<em>åˆ¶å¾¡æ§‹é€ </em>ã‚’æä¾›ã™ã‚‹ã‹ã‚‰ã§ã‚ã‚‹ã€‚
ç§ãŸã¡ã¯ã—ã°ã—ã°ã“ã®åˆ¶å¾¡æ§‹é€ ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
ãŸã¨ãˆã°ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒãŸã¡ã®ã™ã¹ã¦ã®ä¸Šå¸ã‚’è¦‹ã¤ã‘ã‚‹ã«ã¯ã€è«–ç†çš„ã«ç­‰ä¾¡ãªäºŒã¤ã®å½¢ã®ã„ãšã‚Œã‹ã§ã€ã‚¯ã‚¨ãƒªã‚’å®šå¼åŒ–ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã ã‚ã†ã€‚
</p>


<p class="lisp">(and (job ?x (computer programmer))
     (supervisor ?x ?y))
</p>

<p class="orig" lang="en">or
</p>

<p class="trans" lang="ja">
ã¾ãŸã¯
</p>


<p class="lisp">(and (supervisor ?x ?y)
     (job ?x (computer programmer)))
</p>

<p class="orig" lang="en"><a name="%_idx_5254"></a>If a company has many more supervisors than programmers (the usual
case), it is better to use the first form rather than the second
because the data base must be scanned for each intermediate result
(frame) produced by the first clause of the <tt>and</tt>.</p>

<p class="trans" lang="ja">
ã‚‚ã—ãƒ—ãƒ­ã‚°ãƒ©ãƒã‚ˆã‚Šã‚‚ãšã£ã¨å¤šãã®ä¸Šå¸ãŸã¡ãŒä¼šç¤¾ã«ã„ã‚‹ãªã‚‰ (é€šå¸¸ã®å ´åˆ)ã€2ç•ªç›®ã®å½¢ã§ã¯ãªãã€1ç•ªç›®ã®å½¢ã‚’ä½¿ã†æ–¹ãŒè‰¯ã„ã€‚ãªãœãªã‚‰ã€<tt>and</tt> ã®æœ€åˆã®ç¯€ã«ã‚ˆã£ã¦ä½œã‚Šå‡ºã•ã‚Œã‚‹ãã‚Œãã‚Œã®ä¸­é–“çµæœ (ãƒ•ãƒ¬ãƒ¼ãƒ ) ã«ã¤ã„ã¦ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’èµ°æŸ»ã—ãªãã¦ã¯ãªã‚‰ãªã„ã‹ã‚‰ã ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_5256"></a><a name="%_idx_5258"></a>The aim of logic programming is to provide the programmer with
techniques for decomposing a computational problem into two separate
problems: ``what'' is to be computed, and ``how'' this should be
computed.  This is accomplished by selecting a subset of the
statements of mathematical logic that is powerful enough to be able to
describe anything one might want to compute, yet weak enough to have a
controllable procedural interpretation.  The intention here is that,
on the one hand, a program specified in a logic programming language
should be an effective program that can be carried out by a computer.
Control (``how'' to compute) is effected by using the order of
evaluation of the language.  We should be able to arrange the order of
clauses and the order of subgoals within each clause so that the
computation is done in an order deemed to be effective and efficient.
At the same time, we should be able to view the result of the
computation (``what'' to compute) as a simple consequence of the laws
of logic.</p>

<p class="trans" lang="ja">
è«–ç†ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®ç›®çš„ã¯ã€è¨ˆç®—ã«ã¾ã¤ã‚ã‚‹å•é¡Œã‚’ã€äºŒã¤ã®åˆ¥ã€…ã®å•é¡Œâ€”â€”ã€Œä½•ã‚’ã€è¨ˆç®—ã™ã¹ããªã®ã‹ã¨ã„ã†ã“ã¨ã¨ã€ã“ã‚Œã‚’ã€Œã©ã®ã‚ˆã†ã«ã—ã¦ã€è¨ˆç®—ã™ã¹ããªã®ã‹ã¨ã„ã†ã“ã¨â€”â€”ã¸ã¨åˆ†è§£ã™ã‚‹ãŸã‚ã®æŠ€æ³•ã‚’ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒã«æä¾›ã™ã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚
ã“ã‚Œã¯ã€äººãŒè¨ˆç®—ã—ãŸãŒã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã‚‚ã®ã‚’ä½•ã§ã‚‚è¨˜è¿°å¯èƒ½ã§ã‚ã‚‹ãŸã‚ã«ååˆ†ãªã»ã©å¼·åŠ›ã ãŒã€ãã‚Œã§ã‚‚ã€åˆ¶å¾¡å¯èƒ½ãªæ‰‹ç¶šãçš„è§£é‡ˆãŒã‚ã‚‹ã¨ã„ã†ç¨‹åº¦ã«ã¯ååˆ†ã«å¼±ã„ã‚ˆã†ãªã€æ•°å­¦çš„è«–ç†ã®<ruby><rb>æ–‡</rb><rp> (</rp><rt>ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆ</rt><rp>) </rp></ruby>ã®éƒ¨åˆ†é›†åˆã‚’é¸ã¶ã“ã¨ã«ã‚ˆã£ã¦ã€é”æˆã•ã‚Œã‚‹ã€‚
ã“ã“ã§ã®æ„å›³ã¯ã€ã“ã†ã§ã‚ã‚‹ã€‚ã™ãªã‚ã¡ã€ä¸€æ–¹ã§ã¯ã€è«–ç†ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã§è©³ç´°ã‚’è¨˜è¿°ã•ã‚Œã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã«ã‚ˆã£ã¦å®Ÿè¡Œã§ãã‚‹ã‚ˆã†ãªã€æœ‰åŠ¹ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã‚ã‚‹ã¹ãã§ã‚ã‚‹ã€‚
åˆ¶å¾¡ (ã€Œã©ã†ã‚„ã£ã¦ã€è¨ˆç®—ã™ã‚‹ã‹) ã¯ã€è¨€èªã®è©•ä¾¡ã®é †åºã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ã§ã€é”æˆã•ã‚Œã‚‹ã€‚
æœ‰åŠ¹ã‹ã¤åŠ¹ç‡çš„ã ã¨æ€ã‚ã‚Œã‚‹é †åºã§è¨ˆç®—ãŒè¡Œã‚ã‚Œã‚‹ã‚ˆã†ã«ã€ç§ãŸã¡ã¯ã€ç¯€ã®é †åºã¨ã€ãã‚Œãã‚Œã®ç¯€ã®ä¸­ã®ä¸‹ä½ç›®æ¨™ã®é †åºã‚’ã€æ•´ãˆã‚‹ã“ã¨ãŒã§ãã‚‹ã¹ãã§ã‚ã‚‹ã€‚
åŒæ™‚ã«ã€ç§ãŸã¡ã¯ã€è¨ˆç®—ã®çµæœ (ã€Œä½•ã‚’ã€è¨ˆç®—ã™ã¹ãã‹) ã‚’ã€è«–ç†ã®æ³•å‰‡ã®ç°¡å˜ãªçµæœã¨ã—ã¦è¦‹ã‚‹ã“ã¨ãŒã§ãã‚‹ã¹ããªã®ã ã€‚
</p>

<p class="orig" lang="en">
Our query language can be regarded as just such a procedurally
interpretable subset of mathematical logic.  An assertion represents a
simple fact (an atomic proposition).  A rule represents the
implication that the rule conclusion holds for those cases where the
rule body holds.  A rule has a natural procedural interpretation: To
establish the conclusion of the rule, establish the body of the rule.
Rules, therefore, specify computations.  However, because rules can
also be regarded as statements of mathematical logic, we can justify
any ``inference'' accomplished by a logic program by asserting that
the same result could be obtained by working entirely within
mathematical logic.<a name="call_footnote_Temp_684" href="#footnote_Temp_684"><sup><small>76</small></sup></a></p>

<p class="trans" lang="ja">
ç§ãŸã¡ã®ã‚¯ã‚¨ãƒªè¨€èªã¯ã€ã¾ã•ã«ã€æ•°å­¦çš„è«–ç†ã®ã€æ‰‹ç¶šãçš„ã«è§£é‡ˆå¯èƒ½ãªéƒ¨åˆ†é›†åˆã ã¨è¦‹ãªã›ã‚‹ã€‚
è¨€æ˜ã¯ã€å˜ç´”ãªäº‹å®Ÿ (åŸå§‹çš„ãªå‘½é¡Œ) ã‚’è¡¨ã™ã€‚
è¦å‰‡ã¯ã€å½“è©²è¦å‰‡ã®æœ¬ä½“éƒ¨ãŒæˆã‚Šç«‹ã¤å ´åˆã«ã¯å½“è©²è¦å‰‡ã®å¸°çµéƒ¨ãŒæˆã‚Šç«‹ã¤ã€ã¨ã„ã†å«æ„ã‚’è¡¨ã™ã€‚
è¦å‰‡ã«ã¯è‡ªç„¶ãªæ‰‹ç¶šãçš„è§£é‡ˆãŒã‚ã‚‹ã€‚ã¤ã¾ã‚Šã€ãã®è¦å‰‡ã®å¸°çµéƒ¨ã‚’æˆã‚Šç«‹ãŸã›ã‚‹ãŸã‚ã«ã¯ã€ãã®è¦å‰‡ã®æœ¬ä½“éƒ¨ã‚’æˆã‚Šç«‹ãŸã›ã‚ˆã€ã¨ã„ã†ã‚‚ã®ã ã€‚
ã—ãŸãŒã£ã¦ã€è¦å‰‡ã¯ã€è¨ˆç®—ã®æ˜ç´°ã‚’è¦å®šã—ã¦ã„ã‚‹ã€‚
ã—ã‹ã—ã€è¦å‰‡ã‚’æ•°å­¦çš„è«–ç†ã®æ–‡ã¨è¦‹ãªã™ã“ã¨ã‚‚ã§ãã‚‹ã®ã§ã€ç§ãŸã¡ã¯ã€è«–ç†ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ã‚ˆã‚Šé”æˆã•ã‚Œã‚‹ã€ã©ã®ã€Œæ¨è«–ã€ã‚‚ã€æ­£å½“åŒ–ã§ãã‚‹â€”â€”å®Œå…¨ã«æ•°å­¦çš„è«–ç†ã®ç¯„å›²å†…ã§ä½œæ¥­ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã‚‚ã€åŒã˜çµæœãŒå¾—ã‚‰ã‚Œã‚‹ã ã‚ã†ã€ã¨ä¸»å¼µã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦<a href="#footnote_Temp_684"><sup><small>76</small></sup></a>ã€‚
</p>

<a name="%_sec_Temp_685"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_685">Infinite loops</a></h4>
<h4 class="trans" lang="ja">ç„¡é™ãƒ«ãƒ¼ãƒ—</h4>

<p class="orig" lang="en">
<a name="%_idx_5260"></a>
A consequence of the procedural interpretation of logic programs is
that it is possible to construct hopelessly inefficient programs for
solving certain problems.  An extreme case of inefficiency occurs when
the system falls into infinite loops in making deductions.  As a
simple example, suppose we are setting up a data base of famous
marriages, including</p>

<p class="trans" lang="ja">
è«–ç†ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®æ‰‹ç¶šãçš„è§£é‡ˆã‹ã‚‰ãã‚‹çµè«–ã¯ã€ã‚ã‚‹ç¨®ã®å•é¡Œã‚’è§£ããŸã‚ã®çµ¶æœ›çš„ã«éåŠ¹ç‡ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ§‹ç¯‰ã™ã‚‹ã“ã¨ãŒå¯èƒ½ã ã€ã¨ã„ã†ã“ã¨ã§ã‚ã‚‹ã€‚
æ¼”ç¹¹ã‚’è¡Œã†éš›ã«ã‚·ã‚¹ãƒ†ãƒ ãŒç„¡é™ãƒ«ãƒ¼ãƒ—ã«é™¥ã‚‹å ´åˆã«ã€éåŠ¹ç‡æ€§ã®æ¥µç«¯ãªäº‹ä¾‹ãŒç”Ÿã˜ã‚‹ã€‚
å˜ç´”ãªä¾‹ã¨ã—ã¦ã€ä»¥ä¸‹ã®ã‚‚ã®ã‚’å«ã‚€ã€æœ‰åãªå©šå§»ã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’è¨­å®šã—ã¦ã„ã‚‹ã¨ã“ã‚ã ã¨ã—ã‚ˆã†ã€‚
</p>


<a name="%_idx_5262"></a>
<p class="lisp">(assert! (married Minnie Mickey))
</p>

<p class="orig" lang="en">If we now ask</p>

<p class="trans" lang="ja">
ã‚‚ã—ã€ã„ã¾ä»¥ä¸‹ã®ã‚ˆã†ã«å°‹ã­ã‚‹ã¨ã€
</p>

<p class="lisp">(married Mickey ?who)
</p>

<p class="orig" lang="en">we will get no response, because the system doesn't know that if <em>A</em>
is married to <em>B</em>, then <em>B</em> is married to <em>A</em>.  So we assert the rule</p>

<p class="trans" lang="ja">
ç§ãŸã¡ã¯ä½•ã®å¿œç­”ã‚‚å¾—ãªã„ã ã‚ã†ã€‚ãªãœãªã‚‰ã€ã‚‚ã— <em class="en">A</em> ãŒ <em class="en">B</em> ã¨çµå©šã—ã¦ã„ã‚‹ãªã‚‰ <em class="en">B</em> ã¯ <em class="en">A</em> ã¨çµå©šã—ã¦ã„ã‚‹ã€ã¨ã„ã†ã“ã¨ã‚’ã‚·ã‚¹ãƒ†ãƒ ã¯çŸ¥ã‚‰ãªã„ãŸã‚ã§ã‚ã‚‹ã€‚
ãã“ã§ã€ç§ãŸã¡ã¯ä»¥ä¸‹ã®è¦å‰‡ã‚’è¨€æ˜ã—ã€
</p>

<p class="lisp">(assert! (rule (married ?x ?y)
               (married ?y ?x)))
</p>

<p class="orig" lang="en">and again query</p>

<p class="trans" lang="ja">
å†ã³ä»¥ä¸‹ã®ã‚ˆã†ã«å°‹ã­ã‚‹ã€‚
</p>

<p class="lisp">(married Mickey ?who)
</p>

<p class="orig" lang="en">
Unfortunately, this will drive the system into an infinite loop, as
follows:</p>

<p class="trans" lang="ja">
ã‚ã„ã«ãã€ã“ã‚Œã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ã‚·ã‚¹ãƒ†ãƒ ã‚’ç„¡é™ãƒ«ãƒ¼ãƒ—ã«è¿½ã„ã‚„ã‚‹ã ã‚ã†ã€‚
</p>

<ul class="orig" lang="en">
<li>The system finds that the <tt>married</tt> rule is applicable;
that is, the rule conclusion <tt>(married ?x ?y)</tt> successfully
unifies with the query pattern <tt>(married Mickey ?who)</tt> to produce
a frame in which <tt>?x</tt> is bound to <tt>Mickey</tt> and <tt>?y</tt> is
bound to <tt>?who</tt>.  So the interpreter proceeds to evaluate the rule
body <tt>(married ?y ?x)</tt> in this frame -- in effect, to process the
query <tt>(married ?who Mickey)</tt>.</li>

<li>One answer appears directly as an assertion in the data
base: <tt>(married Minnie Mickey)</tt>.</li>

<li>The <tt>married</tt> rule is also applicable, so the
interpreter again evaluates the rule body, which this time is
equivalent to <tt>(married Mickey ?who)</tt>.</li>
</ul>

<ul class="trans" lang="ja">
<li>ã‚·ã‚¹ãƒ†ãƒ ã¯ã€<tt>married</tt> ã®è¦å‰‡ãŒé©ç”¨å¯èƒ½ã ã¨æ°—ã¥ãã€‚ã¤ã¾ã‚Šã€ <tt>(married ?x ?y)</tt> ã¨ã„ã†è¦å‰‡å¸°çµéƒ¨ãŒ <tt>(married Mickey ?who)</tt> ã¨ã„ã†ã‚¯ã‚¨ãƒªãƒ»ãƒ‘ã‚¿ãƒ³ã¨ã†ã¾ããƒ¦ãƒ‹ãƒ•ã‚¡ã‚¤ã—ã¦ã€ãƒ•ãƒ¬ãƒ¼ãƒ â€”â€” <tt>?x</tt> ãŒ <tt>Mickey</tt> ã«æŸç¸›ã•ã‚Œã¦ãŠã‚Šã€ã‹ã¤ã€<tt>?y</tt> ãŒ <tt>?who</tt> ã«æŸç¸›ã•ã‚Œã¦ã„ã‚‹ãƒ•ãƒ¬ãƒ¼ãƒ â€”â€”ã‚’ä½œã‚Šå‡ºã™ã€‚
ã™ã‚‹ã¨ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã¯ã€ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã®ä¸­ã§ <tt>(married ?y ?x)</tt> ã¨ã„ã†è¦å‰‡æœ¬ä½“éƒ¨ã‚’è©•ä¾¡ã—å§‹ã‚ã‚‹â€”â€”äº‹å®Ÿä¸Šã¯ã€<tt>(married ?who Mickey)</tt> ã¨ã„ã†ã‚¯ã‚¨ãƒªã‚’å‡¦ç†ã—ã ã™ã¨ã„ã†è¨³ã ã€‚</li>
<li>ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å†…ã«ã€è¨€æ˜ã¨ã—ã¦ç›´æ¥çš„ã«ä¸€ã¤ã®ç­”ãˆãŒç¾ã‚Œã¦ã„ã‚‹ã€‚ã¤ã¾ã‚Šã€<tt>(married Minnie Mickey)</tt> ã§ã‚ã‚‹ã€‚</li>
<li><tt>married</tt> ã®è¦å‰‡ã‚‚é©ç”¨å¯èƒ½ã§ã‚ã‚Šã€ã—ãŸãŒã£ã¦ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã¯ã€å†ã³è¦å‰‡æœ¬ä½“éƒ¨ã‚’è©•ä¾¡ã™ã‚‹ã®ã ãŒã€ã“ã‚Œã¯ä»Šåº¦ã¯ <tt>(married Mickey ?who)</tt> ã¨ç­‰ä¾¡ã§ã‚ã‚‹ã€‚</li>
</ul>


<p class="orig" lang="en">
The system is now in an infinite loop.  Indeed, whether the system
will find the simple answer <tt>(married Minnie Mickey)</tt> before it
goes into the loop depends on implementation details concerning the
order in which the system checks the items in the data base.  This is
a very simple example of the kinds of loops that can occur.
Collections of interrelated rules can lead to loops that are much
harder to anticipate, and the appearance of a loop can depend on the order
of clauses in an <tt>and</tt> (see exercise <a href="#%_thm_4.64">4.64</a>)
or on low-level details concerning the order in which the system
processes queries.<a name="call_footnote_Temp_686" href="#footnote_Temp_686"><sup><small>77</small></sup></a>
</p>

<p class="trans" lang="ja">
ã‚·ã‚¹ãƒ†ãƒ ã¯ä»Šã‚„ç„¡é™ãƒ«ãƒ¼ãƒ—ã®ä¸­ã«ã„ã‚‹ã€‚
å®Ÿéš›ã€ã‚·ã‚¹ãƒ†ãƒ ãŒãƒ«ãƒ¼ãƒ—ã«å…¥ã‚‹å‰ã« <tt>(married Minnie Mickey)</tt> ã¨ã„ã†å˜ç´”ãªç­”ãˆã‚’è¦‹ã¤ã‘ã‚‹ã‹ã©ã†ã‹ã¯ã€ã‚·ã‚¹ãƒ†ãƒ ãŒãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å†…ã®é …ç›®ã‚’èª¿ã¹ã‚‹é †åºã«é–¢ã™ã‚‹ã€å®Ÿè£…ã®è©³ç´°ã«ä¾å­˜ã™ã‚‹ã€‚
ã“ã‚Œã¯ã€èµ·ã“ã‚Šå¾—ã‚‹ãƒ«ãƒ¼ãƒ—ã®ç¨®é¡ã®ã†ã¡ã®ã€éå¸¸ã«å˜ç´”ãªä¾‹ã§ã‚ã‚‹ã€‚
äº’ã„ã«é–¢é€£ã—åˆã†è¦å‰‡ã®é›†ã¾ã‚Šã¯ã€äºˆè¦‹ã™ã‚‹ã®ãŒã‚‚ã£ã¨ãšã£ã¨å›°é›£ãªãƒ«ãƒ¼ãƒ—ã‚’å¼•ãèµ·ã“ã—å¾—ã‚‹ã—ã€ãƒ«ãƒ¼ãƒ—ã®å‡ºç¾ã¯ã€<tt>and</tt> ã®ä¸­ã®ç¯€ã®é †åºã« (ç·´ç¿’å•é¡Œ<a href="#%_thm_4.64">4.64</a>ã‚’å‚ç…§)ã€ã¾ãŸã¯ã€ã‚·ã‚¹ãƒ†ãƒ ãŒã‚¯ã‚¨ãƒªã‚’å‡¦ç†ã™ã‚‹é †åºã«é–¢ã™ã‚‹ä½æ°´æº–ã®è©³ç´°ã«ã€ä¾å­˜ã—å¾—ã‚‹<a href="#footnote_Temp_686"><sup><small>77</small></sup></a>ã€‚
</p>

<a name="%_sec_Temp_687"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_687">Problems with <tt>not</tt></a></h4>
<h4 class="trans" lang="ja"><tt>not</tt> ã«ã¾ã¤ã‚ã‚‹å•é¡Œ</h4>


<p class="orig" lang="en">
<a name="%_idx_5266"></a>
<a name="%_idx_5268"></a>Another quirk in the query system concerns <tt>not</tt>.  Given the data
base of section <a href="#%_sec_4.4.1">4.4.1</a>, consider the
following two queries:</p>

<p class="trans" lang="ja">
ã‚¯ã‚¨ãƒªãƒ»ã‚·ã‚¹ãƒ†ãƒ ã«ãŠã‘ã‚‹ã€ã‚‚ã†ä¸€ã¤ã®å¥‡æŠœã•ã¯ã€<tt>not</tt> ã«é–¢ã™ã‚‹ã€‚
<a href="#%_sec_4.4.1">4.4.1</a>ç¯€ã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãŒä¸ãˆã‚‰ã‚ŒãŸã¨ã—ã¦ã€ä»¥ä¸‹ã®äºŒã¤ã®ã‚¯ã‚¨ãƒªã‚’è€ƒãˆã‚ˆã†ã€‚
</p>

<p class="lisp">(and (supervisor ?x ?y)
     (not (job ?x (computer programmer))))
(and (not (job ?x (computer programmer)))
     (supervisor ?x ?y))
</p>



<p class="orig" lang="en">These two queries do not produce the same result.  The first query
begins by finding all entries in the data base that match <tt>(supervisor ?x ?y)</tt>, and then filters the resulting frames by removing
the ones in which the value of <tt>?x</tt> satisfies <tt>(job ?x
(computer programmer))</tt>.  The second query begins by filtering the
incoming frames to remove those that can satisfy <tt>(job ?x
(computer programmer))</tt>.  Since the only incoming frame is empty, it
checks the data base to see if there are any patterns that satisfy
<tt>(job ?x (computer programmer))</tt>.  Since there generally are
entries of this form, the <tt>not</tt> clause filters out the empty frame
and returns an empty stream of frames.  Consequently, the entire
compound query returns an empty stream.</p>

<p class="trans" lang="ja">
ã“ã‚Œã‚‰äºŒã¤ã®ã‚¯ã‚¨ãƒªã¯ã€åŒã˜çµæœã‚’ç”Ÿã¿å‡ºã•ãªã„ã€‚
1ç•ªç›®ã®ã‚¯ã‚¨ãƒªã¯ã€<tt>(supervisor ?x ?y)</tt> ã«åˆè‡´ã™ã‚‹ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å†…ã®å…¨ã‚¨ãƒ³ãƒˆãƒªã‚’è¦‹ã¤ã‘ã‚‹ã“ã¨ã‹ã‚‰å–ã‚Šã‹ã‹ã‚Šã€ãã®å¾Œã€çµæœã¨ã—ã¦ã§ããŸãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ã€<tt>?x</tt> ã®å€¤ãŒ <tt>(job ?x (computer programmer))</tt> ã‚’æº€ãŸã™ã‚‚ã®ã‚’é™¤ãã“ã¨ã«ã‚ˆã‚Šã€ãƒ•ã‚£ãƒ«ã‚¿ã«ã‹ã‘ã‚‹ã€‚
2ç•ªç›®ã®ã‚¯ã‚¨ãƒªã¯ã€å…¥åŠ›ã•ã‚Œã¦ãã‚‹ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ãƒ•ã‚£ãƒ«ã‚¿ã«ã‹ã‘ã¦ã€<tt>(job ?x (computer programmer))</tt> ã‚’æº€ãŸã›ã‚‹ã‚‚ã®ã‚’é™¤ãã“ã¨ã‹ã‚‰ã€å–ã‚Šã‹ã‹ã‚‹ã€‚
å…¥åŠ›ã•ã‚Œã¦ãã‚‹å”¯ä¸€ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã¯ç©ºãªã®ã§ã€<tt>(job ?x (computer programmer))</tt> ã‚’æº€ãŸã™ãƒ‘ã‚¿ãƒ³ãŒä½•ã‹ã‚ã‚‹ã‹ã©ã†ã‹ã‚’çŸ¥ã‚‹ãŸã‚ã«ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’èª¿ã¹ã‚‹ã€‚
å¤§æŠµã¯ã“ã®å½¢ã®ã‚¨ãƒ³ãƒˆãƒªãŒã‚ã‚‹ã®ã§ã€<tt>not</tt> ç¯€ã¯ã€ç©ºãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ãƒ•ã‚£ãƒ«ã‚¿ã§é™¤å»ã—ã€ãƒ•ãƒ¬ãƒ¼ãƒ ã®ç©ºã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’è¿”ã™ã€‚
ãã®çµæœã€è¤‡åˆã‚¯ã‚¨ãƒªå…¨ä½“ã¯ã€ç©ºã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’è¿”ã™ã€‚
</p>

<p class="orig" lang="en">
The trouble is that our implementation of <tt>not</tt> really is meant to
serve as a filter on values for the variables.  If a <tt>not</tt> clause
is processed with a frame in which some of the variables remain
unbound (as does <tt>?x</tt> in the example above), the system will
produce unexpected results. Similar problems occur with the use of
<a name="%_idx_5270"></a><tt>lisp-value</tt> -- the Lisp predicate can't work if some of its
arguments are unbound.  See exercise <a href="#%_thm_4.77">4.77</a>.</p>

<p class="trans" lang="ja">
å„ä»‹ãªç‚¹ã¯ã€ç§ãŸã¡ã® <tt>not</tt> ã®å®Ÿè£…ãŒã€ç¾å®Ÿã«ã¯ã€å¤‰æ•°ã®å€¤ã«å¯¾ã™ã‚‹ãƒ•ã‚£ãƒ«ã‚¿ã¨ã—ã¦åƒãã‚ˆã†ã«ã¯ãªã£ã¦ã„ãªã„ç‚¹ã§ã‚ã‚‹ã€‚
ã‚‚ã— <tt>not</tt> ç¯€ãŒã€(ä¸Šè¨˜ã®ä¾‹ã«ãŠã„ã¦ <tt>?x</tt> ãŒãã†ã§ã‚ã£ãŸã‚ˆã†ã«) å¤‰æ•°ã®ã†ã¡ã®ä¸€éƒ¨ãŒæŸç¸›ã•ã‚Œã¦ã„ãªã„ã¾ã¾æ®‹ã£ã¦ã„ã‚‹ã‚ˆã†ãªãƒ•ãƒ¬ãƒ¼ãƒ ã¨ä¸€ç·’ã«å‡¦ç†ã•ã‚Œã‚‹ã¨ã€ã‚·ã‚¹ãƒ†ãƒ ã¯ã€äºˆæœŸã›ã¬çµæœã‚’ç”Ÿã¿å‡ºã™ã€‚
ä¼¼ãŸã‚ˆã†ãªå•é¡Œã¯ã€<tt>lisp-value</tt> ã‚’ä½¿ç”¨ã™ã‚‹ã¨ãã«ã‚‚èµ·ã“ã‚‹â€”â€” Lisp ã®è¿°èªã¯ã€ãã®å¼•æ•°ã®ã†ã¡ã®ä¸€éƒ¨ãŒæŸç¸›ã•ã‚Œã¦ã„ãªã„å ´åˆã«ã¯ã€ã†ã¾ãå‹•ä½œã§ããªã„ã®ã ã€‚
ç·´ç¿’å•é¡Œ<a href="#%_thm_4.77">4.77</a>ã‚’å‚ç…§ã®ã“ã¨ã€‚
</p>



<p class="orig" lang="en">
There is also a much more serious way in which the <tt>not</tt> of the
query language differs from the <tt>not</tt> of mathematical logic.  In
logic, we interpret the statement ``not <em>P</em>'' to mean that <em>P</em> is not
true.  In the query system, however, ``not <em>P</em>'' means that <em>P</em> is not
deducible from the knowledge in the data base.  For example, given the
personnel data base of section <a href="#%_sec_4.4.1">4.4.1</a>, the
system would happily deduce all sorts of <tt>not</tt> statements, such as
that Ben Bitdiddle is not a baseball fan, that it is not raining
outside, and that 2 + 2 is not 4.<a name="call_footnote_Temp_688" href="#footnote_Temp_688"><sup><small>78</small></sup></a> In other words, the <tt>not</tt>
of logic programming languages reflects the so-called <a name="%_idx_5272"></a><em>closed
world assumption</em> that all relevant information has been included in
the data base.<a name="call_footnote_Temp_689" href="#footnote_Temp_689"><sup><small>79</small></sup></a>
</p>

<p class="trans" lang="ja">
ã‚¯ã‚¨ãƒªè¨€èªã® <tt>not</tt> ãŒæ•°å­¦çš„ãªè«–ç†ã® <tt>not</tt> ã¨ç•°ãªã£ã¦ã„ã‚‹ã€ã‚‚ã£ã¨ãšã£ã¨æ·±åˆ»ãªç‚¹ã‚‚ã‚ã‚‹ã€‚
è«–ç†å­¦ã§ã¯ã€ã€Œnot <em class="en">P</em>ã€ã¨ã„ã†<ruby><rb>æ–‡</rb><rp> (</rp><rt>ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆ</rt><rp>) </rp></ruby>ã‚’ã€<em class="en">P</em> ãŒçœŸã§ãªã„ã“ã¨ã‚’æ„å‘³ã™ã‚‹ã‚‚ã®ã¨è§£é‡ˆã™ã‚‹ã€‚
ã—ã‹ã—ã€ã‚¯ã‚¨ãƒªãƒ»ã‚·ã‚¹ãƒ†ãƒ ã§ã¯ã€ã€Œnot <em class="en">P</em>ã€ã¯ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å†…ã®çŸ¥è­˜ã‹ã‚‰ã¯ <em class="en">P</em> ãŒ<!--æ¼”ç¹¹å¯èƒ½ã§ã¯ãªã„-->æ¼”ç¹¹ã§ããªã„ã“ã¨ã‚’æ„å‘³ã™ã‚‹ã®ã ã€‚
ãŸã¨ãˆã°ã€<a href="#%_sec_4.4.1">4.4.1</a>ç¯€ã§ã®äººäº‹ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãŒä¸ãˆã‚‰ã‚Œã‚‹ã¨ã€ã‚·ã‚¹ãƒ†ãƒ ã¯ã€ãƒ™ãƒ³ãƒ»ãƒ“ãƒƒãƒˆãƒ‡ã‚£ãƒ‰ãƒ«ãŒé‡çƒãƒ•ã‚¡ãƒ³ã§ã¯ãªã„ã€ã¨ã‹ã€å¤–ã§ã¯é›¨ãŒé™ã£ã¦ã„ãªã„ã€ã¨ã‹ã€2+2 ã¯ 4 ã§ã¯ãªã„ã€ã¨ã„ã†ã‚ˆã†ãªã€ã‚ã‚‰ã‚†ã‚‹ç¨®é¡ã® <tt>not</tt> æ–‡ã‚’ã€é‹ã‚ˆãæ¼”ç¹¹ã™ã‚‹ã§ã‚ã‚ã†<a href="#footnote_Temp_688"><sup><small>78</small></sup></a>ã€‚
æ›è¨€ã™ã‚Œã°ã€è«–ç†ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã® <tt>not</tt> ã¯ã€é–¢é€£æ€§ã®ã‚ã‚‹å…¨æƒ…å ±ãŒãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å†…ã«ã™ã§ã«å«ã‚ã‚‰ã‚Œã¦ã„ã‚‹ã®ã ã€ã¨ã„ã†ã€ã„ã‚ã‚†ã‚‹<em>é–‰ä¸–ç•Œä»®èª¬</em>ã‚’åæ˜ ã—ã¦ã„ã‚‹ã®ã§ã‚ã‚‹<a href="#footnote_Temp_689"><sup><small>79</small></sup></a>ã€‚
</p>

<a name="%_thm_4.64"></a>
<p class="orig" lang="en"><b>Exercise 4.64.</b>  <a name="%_idx_5276"></a>Louis Reasoner mistakenly deletes the <tt>outranked-by</tt> rule
(section <a href="#%_sec_4.4.1">4.4.1</a>) from the data base.  When
he realizes this, he quickly reinstalls it.  Unfortunately, he makes a
slight change in the rule, and types it in as</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.64.</b> ãƒ«ã‚¤ã‚¹ãƒ»ãƒªãƒ¼ã‚ºãƒŠã¯ã€é–“é•ãˆã¦ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‹ã‚‰ <a href="#%_idx_5152"><tt>outranked-by</tt> ã®è¦å‰‡</a> (<a href="#%_sec_4.4.1">4.4.1</a> ç¯€) ã‚’å‰Šé™¤ã—ã¦ã—ã¾ã†ã€‚
ã“ã®ã“ã¨ã«æ°—ã¥ãã¨ã€å½¼ã¯ç´ æ—©ãã“ã®è¦å‰‡ã‚’å†ã³çµ„ã¿å…¥ã‚Œã‚‹ã€‚
ã‚ã„ã«ãã€å½¼ã¯è¦å‰‡ã«ã¡ã‚‡ã£ã¨ã—ãŸå¤‰æ›´ã‚’åŠ ãˆã¦ã—ã¾ã„ã€ãã‚Œã‚’ä»¥ä¸‹ã®ã‚ˆã†ã«æ‰“ã¡è¾¼ã‚€ã€‚
</p>

<p class="lisp">(rule (outranked-by ?staff-person ?boss)
      (or (supervisor ?staff-person ?boss)
          (and (outranked-by ?middle-manager ?boss)
               (supervisor ?staff-person ?middle-manager))))
</p>

<p class="orig" lang="en">Just after Louis types this information into the system, DeWitt
Aull comes by to find out who outranks Ben Bitdiddle. He issues
the query</p>

<p class="trans" lang="ja">
ãƒ«ã‚¤ã‚¹ãŒã“ã®æƒ…å ±ã‚’ã‚·ã‚¹ãƒ†ãƒ ã«æ‰“ã¡è¾¼ã‚“ã ã™ãå¾Œã«ã€èª°ãŒãƒ™ãƒ³ãƒ»ãƒ“ãƒƒãƒˆãƒ‡ã‚£ãƒ‰ãƒ«ã‚ˆã‚Šä¸Šã®è·ä½ã«ã‚ã‚‹ã®ã‹ã‚’çŸ¥ã‚‹ãŸã‚ã«ã€ãƒ‰ã‚¥ã‚¦ã‚£ãƒƒãƒˆãƒ»ã‚ªãƒ¼ãƒ«ãŒç«‹ã¡å¯„ã‚‹ã€‚
ãƒ‰ã‚¥ã‚¦ã‚£ãƒƒãƒˆã¯ä»¥ä¸‹ã®ã‚¯ã‚¨ãƒªã‚’ç™ºè¡Œã™ã‚‹ã€‚
</p>

<p class="lisp">(outranked-by (Bitdiddle Ben) ?who)
</p>

<p class="orig" lang="en">After answering, the system goes into an infinite loop.  Explain why.
</p>

<p class="trans" lang="ja">
å›ç­”ã—ãŸå¾Œã€ã‚·ã‚¹ãƒ†ãƒ ã¯ã€ç„¡é™ãƒ«ãƒ¼ãƒ—ã«é™¥ã‚‹ã€‚ãªãœãªã®ã‹ã‚’èª¬æ˜ã›ã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment">ã¾ãšç¢ºèªã—ã¦ãŠãã¨ã€ãƒ«ã‚¤ã‚¹ã¯ã€and ã®äºŒã¤ã®å¼•æ•°ã®é †åºã‚’é€†ã«ã—ãŸã€‚

ã•ã¦ã€ã‚·ã‚¹ãƒ†ãƒ ã¯ã€ã¾ãšã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ã‚ã‚‹</span>
(supervisor (Bitdiddle Ben) (Warbucks Oliver))
<span class="ex_comment">ã¨ã„ã†è¨€æ˜ã‚’è¦‹ã¤ã‘ã‚‹ã€‚ã“ã‚ŒãŒ or ã®ä¸€ã¤ç›®ã®å¼•æ•°ã®ãƒ‘ã‚¿ãƒ³ã«ãƒãƒƒãƒã™ã‚‹ã€‚ã‚ˆã£ã¦ã€ã‚·ã‚¹ãƒ†ãƒ ã¯</span>
(outranked-by (Bitdiddle Ben) (Warbucks Oliver))
<span class="ex_comment">ã¨ã„ã†å›ç­”ã‚’è¿”ã™ã€‚ãŒã€ãã®å¾Œã€ãƒ«ã‚¤ã‚¹ã®å¤‰æ›´ã®ã›ã„ã§ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ã€
outranked-by ã®å†å¸°çš„ãªå‘¼ã³å‡ºã—ãŒç„¡é™ã«æ·±ã¾ã‚‹ãƒ«ãƒ¼ãƒ—ã«ã¯ã¾ã‚Šè¾¼ã‚“ã§ã—ã¾ã†
(ã¤ã¾ã‚Šã€(â˜†1)ã‚’æ‰“ã¡è¾¼ã‚€ã¨ã€(â˜†2)ã®å‡ºåŠ›ã¯å¾—ã‚‰ã‚Œã‚‹ãŒã€(â˜†3)ä»¥ä¸‹ãŒå®Ÿè¡Œã•ã‚Œã¦ã„ã
ç„¡é™ãƒ«ãƒ¼ãƒ—ã«ã¯ã¾ã‚Šã€<del>(*)ã¯å®Ÿè¡Œã•ã‚Œãšã€ã¨ã„ã†ã“ã¨</del>)ã€‚</span>

outranked-by (â˜†1)
 |
 +-- supervisor (â˜†2)
 OR
 +-- outranked-by (â˜†3) --AND-- supervisor (*)
      |
      +-- supervisor (â˜†4)
      OR
      +-- outranked-by (â˜†5) --AND-- supervisor (*)
           |
           +-- supervisor (â˜†6)
           OR
           +-- outranked-by (â˜†7) --AND-- supervisor(*)
                |
                :

<span class="ex_comment">ã¨ã€é›‘ã«è€ƒãˆãŸã‚“ã ãŒã€ã©ã†ã ã‚ã†ã€‚</span></p>
<p class="extra_code"><span class="ex_comment">% Prologã§ã“ã‚Œã‚’ãªãã£ã¦ã¿ã‚‹ã€‚

% ã¾ãšäººäº‹DB (è¦å‰‡è¾¼ã¿) ã®èª­ã¿è¾¼ã¿ã€‚</span>
| ?- consult('personnel_db.pl').
<span class="ex_comment">% (å‡ºåŠ›ã¯çœç•¥)</span>

<span class="ex_comment">% outranked_by ã®å®šç¾©ã‚’ä¸Šæ›¸ãã™ã‚‹ã€‚</span>
| ?- [user].
compiling user for byte code...
outranked_by(Staff_person, Boss) :-
    supervisor(Staff_person, Boss);
    (outranked_by(Middle_manager, Boss),
     supervisor(Staff_person, Middle_manager)).

user compiled, 5 lines read - 709 bytes written, 44124 ms
warning: user:1: redefining procedure outranked_by/2
<span class="ex_comment">% (ã‚‚ã†ã¡ã‚‡ã£ã¨å‡ºåŠ›ãŒã‚ã£ãŸãŒã€ãã‚Œã¯çœç•¥)</span>

<span class="ex_comment">% ã¡ã‚ƒã‚“ã¨å†å®šç¾©ã•ã‚ŒãŸã‹ç¢ºèªã—ãŸã„å ´åˆ</span>
| ?- listing.
<span class="ex_comment">% (å‡ºåŠ›ã¯çœç•¥)</span>

<span class="ex_comment">% ãƒˆãƒ¬ãƒ¼ã‚¹ã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚</span>
| ?- trace.
The debugger will first creep -- showing everything (trace)

yes
{trace}

<span class="ex_comment">% ãã‚Œã§ã¯ã€ã„ã–å®Ÿè¡Œã€‚
% (ä»¥ä¸‹ã¯ã€å®Ÿéš›ã®å‡ºåŠ›ã«ã‚³ãƒ¡ãƒ³ãƒˆã‚’è¿½è¨˜ã—ãŸã‚‚ã®ã€‚
%    [å‘¼ã³å‡ºã—ç•ªå·] [ç›´æ¥ã®å…ˆç¥–ã‚’ç¤ºã™ç•ªå·] [ãƒãƒ¼ãƒˆ:] [ã‚´ãƒ¼ãƒ«] ?
%  ã¨ã„ã†ã®ãŒå…ƒã®å‡ºåŠ›ã§ã‚ã‚‹ã€‚)</span>

| ?- outranked_by(['Bitdiddle', 'Ben'], Who).
      1    1  Call: outranked_by(['Bitdiddle','Ben'],_283) ? <span class="ex_comment">% (â˜†1)</span>
      2    2  Call: supervisor(['Bitdiddle','Ben'],_283) ? <span class="ex_comment">% (â˜†2)</span>
      2    2  Exit: supervisor(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      1    1  Exit: outranked_by(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 

Who = ['Warbucks','Oliver'] ? ;
<span class="ex_comment">% ã“ã“ã¾ã§ã¯ç°¡å˜ã€‚å†å¸°ãªã—ã§åˆ¤æ˜ã™ã‚‹ãƒ‘ã‚¿ãƒ³ã€‚</span>

<span class="ex_comment">% ä¸Šã®è¡Œã§ã‚»ãƒŸã‚³ãƒ­ãƒ³ã‚’å…¥åŠ›ã—ãŸã®ã§ã€åˆ¥ã®è§£ã‚’æ¢ã—å§‹ã‚ã‚‹ã€‚
% å®Ÿéš›ã¯ã€ãƒ™ãƒ³ã‚ˆã‚Šä¸Šä½ã®äººé–“ã¯ã‚ªãƒªãƒãƒ¼ã ã‘ãªã®ã§ã€åˆ¥ã®è§£ãªã©å­˜åœ¨ã—ãªã„ã®ã ãŒã€
% ä»¥ä¸‹ã®é€šã‚Šã€æ¢ç´¢ãŒç„¡é™ãƒ«ãƒ¼ãƒ—ã«é™¥ã£ã¦ã—ã¾ã†ã€‚</span>
      1    1  Redo: outranked_by(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      2    2  Redo: supervisor(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      2    2  Fail: supervisor(['Bitdiddle','Ben'],_283) ? 
<span class="ex_comment">% supervisor(['Bitdiddle','Ben'], Who) ã«ãƒãƒƒãƒã™ã‚‹ã‚‚ã®ã¯ã‚‚ã†ãªã„ã®ã§ã€Fail ã¨ãªã£ãŸã€‚
% ã¨ã„ã†ã‚ã‘ã§ã€å†å¸°å‘¼ã³å‡ºã—å®šç¾©ã®æ–¹ã§ãƒãƒƒãƒã™ã‚‹ã‚‚ã®ã‚’æ¢ã—ã«ã„ãã€‚ã¤ã¾ã‚Šã€
% WhoãŒBossã«ãƒ¦ãƒ‹ãƒ•ã‚¡ã‚¤ã•ã‚Œã¦ã„ã‚‹çŠ¶æ…‹ã§ã€
% outranked_by(Middle_manager, Boss), supervisor(['Bitdiddle','Ben'], Middle_manager)
% ã«ãƒãƒƒãƒã™ã‚‹ã‚‚ã®ã‚’ã€æ¢ã—ã«ã„ãã€‚</span>
      2    2  Call: outranked_by(_352,_283) ? <span class="ex_comment">% (â˜†3)</span>
      3    3  Call: supervisor(_376,_283) ? 
      3    3  Exit: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      2    2  Exit: outranked_by(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ?
<span class="ex_comment">% ANDçµåˆã•ã‚ŒãŸä¸€ã¤ç›®ã®è¿°èªã‚’æº€ãŸã™è§£ã¯ã€ä¸Šã®è¡Œã®ã¨ãŠã‚Šè¦‹ã¤ã‹ã£ãŸãŒâ€¦â€¦</span>
      4    2  Call: supervisor(['Bitdiddle','Ben'],['Hacker','Alyssa','P']) ? 
      4    2  Fail: supervisor(['Bitdiddle','Ben'],['Hacker','Alyssa','P']) ? 
<span class="ex_comment">% ãã®è§£ã¯ã€äºŒã¤ç›®ã®è¿°èªã‚’æº€ãŸã•ãªã„ã¨åˆ¤æ˜ã™ã‚‹ã€‚
% ã¨ã„ã†ã‚ã‘ã§ã€ANDçµåˆã•ã‚ŒãŸä¸€ã¤ç›®ã®è¿°èªã‚’æº€ãŸã™åˆ¥ã®è§£ã‚’æ¢ã™ã¨â€¦â€¦</span>
      2    2  Redo: outranked_by(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      3    3  Redo: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      3    3  Exit: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      2    2  Exit: outranked_by(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
<span class="ex_comment">% ä¸Šã®è¡Œã®ã¨ãŠã‚Šè§£ãŒè¦‹ã¤ã‹ã‚‹ãŒâ€¦â€¦</span>
      4    2  Call: supervisor(['Bitdiddle','Ben'],['Fect','Cy','D']) ? 
      4    2  Fail: supervisor(['Bitdiddle','Ben'],['Fect','Cy','D']) ? 
<span class="ex_comment">% ãã®è§£ã¯ã€äºŒã¤ç›®ã®è¿°èªã‚’æº€ãŸã•ãªã„ã¨åˆ¤æ˜ã™ã‚‹ã€‚
% ã¨ã„ã†ã‚ã‘ã§ã€ANDçµåˆã•ã‚ŒãŸä¸€ã¤ç›®ã®è¿°èªã‚’æº€ãŸã™åˆ¥ã®è§£ã‚’æ¢ã™ã¨â€¦â€¦</span>
      2    2  Redo: outranked_by(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      3    3  Redo: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      3    3  Exit: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      2    2  Exit: outranked_by(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
<span class="ex_comment">% ä¸Šã®è¡Œã®ã¨ãŠã‚Šè§£ãŒè¦‹ã¤ã‹ã‚‹ãŒâ€¦â€¦</span>
      4    2  Call: supervisor(['Bitdiddle','Ben'],['Tweakit','Lem','E']) ? 
      4    2  Fail: supervisor(['Bitdiddle','Ben'],['Tweakit','Lem','E']) ? 
<span class="ex_comment">% ãã®è§£ã¯ã€äºŒã¤ç›®ã®è¿°èªã‚’æº€ãŸã•ãªã„ã¨åˆ¤æ˜ã™ã‚‹ã€‚
% ã¨ã„ã†ã‚ã‘ã§ã€ANDçµåˆã•ã‚ŒãŸä¸€ã¤ç›®ã®è¿°èªã‚’æº€ãŸã™åˆ¥ã®è§£ã‚’æ¢ã™ã¨â€¦â€¦</span>
      2    2  Redo: outranked_by(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      3    3  Redo: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      3    3  Exit: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      2    2  Exit: outranked_by(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
<span class="ex_comment">% ä¸Šã®è¡Œã®ã¨ãŠã‚Šè§£ãŒè¦‹ã¤ã‹ã‚‹ãŒâ€¦â€¦</span>
      4    2  Call: supervisor(['Bitdiddle','Ben'],['Reasoner','Louis']) ? 
      4    2  Fail: supervisor(['Bitdiddle','Ben'],['Reasoner','Louis']) ? 
<span class="ex_comment">% ãã®è§£ã¯ã€äºŒã¤ç›®ã®è¿°èªã‚’æº€ãŸã•ãªã„ã¨åˆ¤æ˜ã™ã‚‹ã€‚
% ã¨ã„ã†ã‚ã‘ã§ã€ANDçµåˆã•ã‚ŒãŸä¸€ã¤ç›®ã®è¿°èªã‚’æº€ãŸã™åˆ¥ã®è§£ã‚’æ¢ã™ã¨â€¦â€¦</span>
      2    2  Redo: outranked_by(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      3    3  Redo: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      3    3  Exit: supervisor(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      2    2  Exit: outranked_by(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
<span class="ex_comment">% ä¸Šã®è¡Œã®ã¨ãŠã‚Šè§£ãŒè¦‹ã¤ã‹ã‚‹ãŒâ€¦â€¦</span>
      4    2  Call: supervisor(['Bitdiddle','Ben'],['Bitdiddle','Ben']) ? 
      4    2  Fail: supervisor(['Bitdiddle','Ben'],['Bitdiddle','Ben']) ? 
<span class="ex_comment">% ãã®è§£ã¯ã€äºŒã¤ç›®ã®è¿°èªã‚’æº€ãŸã•ãªã„ã¨åˆ¤æ˜ã™ã‚‹ã€‚
% ã¨ã„ã†ã‚ã‘ã§ã€ANDçµåˆã•ã‚ŒãŸä¸€ã¤ç›®ã®è¿°èªã‚’æº€ãŸã™åˆ¥ã®è§£ã‚’æ¢ã™ã¨â€¦â€¦</span>
      2    2  Redo: outranked_by(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      3    3  Redo: supervisor(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      3    3  Exit: supervisor(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      2    2  Exit: outranked_by(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
<span class="ex_comment">% ä¸Šã®è¡Œã®ã¨ãŠã‚Šè§£ãŒè¦‹ã¤ã‹ã‚‹ãŒâ€¦â€¦</span>
      4    2  Call: supervisor(['Bitdiddle','Ben'],['Scrooge','Eben']) ? 
      4    2  Fail: supervisor(['Bitdiddle','Ben'],['Scrooge','Eben']) ? 
<span class="ex_comment">% ãã®è§£ã¯ã€äºŒã¤ç›®ã®è¿°èªã‚’æº€ãŸã•ãªã„ã¨åˆ¤æ˜ã™ã‚‹ã€‚
% ã¨ã„ã†ã‚ã‘ã§ã€ANDçµåˆã•ã‚ŒãŸä¸€ã¤ç›®ã®è¿°èªã‚’æº€ãŸã™åˆ¥ã®è§£ã‚’æ¢ã™ã¨â€¦â€¦</span>
      2    2  Redo: outranked_by(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      3    3  Redo: supervisor(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      3    3  Exit: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      2    2  Exit: outranked_by(['Cratchet','Robert'],['Scrooge','Eben']) ? 
<span class="ex_comment">% ä¸Šã®è¡Œã®ã¨ãŠã‚Šè§£ãŒè¦‹ã¤ã‹ã‚‹ãŒâ€¦â€¦</span>
      4    2  Call: supervisor(['Bitdiddle','Ben'],['Cratchet','Robert']) ? 
      4    2  Fail: supervisor(['Bitdiddle','Ben'],['Cratchet','Robert']) ? 
<span class="ex_comment">% ãã®è§£ã¯ã€äºŒã¤ç›®ã®è¿°èªã‚’æº€ãŸã•ãªã„ã¨åˆ¤æ˜ã™ã‚‹ã€‚
% ã¨ã„ã†ã‚ã‘ã§ã€ANDçµåˆã•ã‚ŒãŸä¸€ã¤ç›®ã®è¿°èªã‚’æº€ãŸã™åˆ¥ã®è§£ã‚’æ¢ã™ã¨â€¦â€¦</span>
      2    2  Redo: outranked_by(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      3    3  Redo: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      3    3  Exit: supervisor(['Aull','DeWitt'],['Warbucks','Oliver']) ? 
      2    2  Exit: outranked_by(['Aull','DeWitt'],['Warbucks','Oliver']) ? 
<span class="ex_comment">% ä¸Šã®è¡Œã®ã¨ãŠã‚Šè§£ãŒè¦‹ã¤ã‹ã‚‹ãŒâ€¦â€¦</span>
      4    2  Call: supervisor(['Bitdiddle','Ben'],['Aull','DeWitt']) ? 
      4    2  Fail: supervisor(['Bitdiddle','Ben'],['Aull','DeWitt']) ? 
      2    2  Redo: outranked_by(['Aull','DeWitt'],['Warbucks','Oliver']) ? 
<span class="ex_comment">% ãã®è§£ã¯ã€äºŒã¤ç›®ã®è¿°èªã‚’æº€ãŸã•ãªã„ã¨åˆ¤æ˜ã™ã‚‹ã€‚
% ã¨ã„ã†ã‚ã‘ã§ã€ANDçµåˆã•ã‚ŒãŸä¸€ã¤ç›®ã®è¿°èªã‚’æº€ãŸã™åˆ¥ã®è§£ã‚’æ¢ã™è¨³ã ãŒã€
% ã“ã“ã§ã€</span>
      3    3  Call: outranked_by(_376,_283) ? 
      4    4  Call: supervisor(_400,_283) ? 
      4    4  Exit: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      3    3  Exit: outranked_by(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      5    3  Call: supervisor(_436,['Hacker','Alyssa','P']) ? 
      5    3  Exit: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      2    2  Exit: outranked_by(['Reasoner','Louis'],['Bitdiddle','Ben']) ? 
      6    2  Call: supervisor(['Bitdiddle','Ben'],['Reasoner','Louis']) ? 
      6    2  Fail: supervisor(['Bitdiddle','Ben'],['Reasoner','Louis']) ? 
      2    2  Redo: outranked_by(['Reasoner','Louis'],['Bitdiddle','Ben']) ? 
      5    3  Redo: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      5    3  Fail: supervisor(_424,['Hacker','Alyssa','P']) ? 
      3    3  Redo: outranked_by(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      4    4  Redo: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      4    4  Exit: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      3    3  Exit: outranked_by(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      5    3  Call: supervisor(_436,['Fect','Cy','D']) ? 
      5    3  Fail: supervisor(_424,['Fect','Cy','D']) ? 
      3    3  Redo: outranked_by(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      4    4  Redo: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      4    4  Exit: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      3    3  Exit: outranked_by(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      5    3  Call: supervisor(_436,['Tweakit','Lem','E']) ? 
      5    3  Fail: supervisor(_424,['Tweakit','Lem','E']) ? 
      3    3  Redo: outranked_by(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      4    4  Redo: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      4    4  Exit: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      3    3  Exit: outranked_by(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      5    3  Call: supervisor(_436,['Reasoner','Louis']) ? 
      5    3  Fail: supervisor(_424,['Reasoner','Louis']) ? 
      3    3  Redo: outranked_by(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      4    4  Redo: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      4    4  Exit: supervisor(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      3    3  Exit: outranked_by(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      5    3  Call: supervisor(_434,['Bitdiddle','Ben']) ? 
      5    3  Exit: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      2    2  Exit: outranked_by(['Hacker','Alyssa','P'],['Warbucks','Oliver']) ? 
      6    2  Call: supervisor(['Bitdiddle','Ben'],['Hacker','Alyssa','P']) ? 
      6    2  Fail: supervisor(['Bitdiddle','Ben'],['Hacker','Alyssa','P']) ? 
      2    2  Redo: outranked_by(['Hacker','Alyssa','P'],['Warbucks','Oliver']) ? 
      5    3  Redo: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      5    3  Exit: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      2    2  Exit: outranked_by(['Fect','Cy','D'],['Warbucks','Oliver']) ? 
      6    2  Call: supervisor(['Bitdiddle','Ben'],['Fect','Cy','D']) ? 
      6    2  Fail: supervisor(['Bitdiddle','Ben'],['Fect','Cy','D']) ? 
      2    2  Redo: outranked_by(['Fect','Cy','D'],['Warbucks','Oliver']) ? 
      5    3  Redo: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      5    3  Exit: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      2    2  Exit: outranked_by(['Tweakit','Lem','E'],['Warbucks','Oliver']) ? 
      6    2  Call: supervisor(['Bitdiddle','Ben'],['Tweakit','Lem','E']) ? 
      6    2  Fail: supervisor(['Bitdiddle','Ben'],['Tweakit','Lem','E']) ? 
      2    2  Redo: outranked_by(['Tweakit','Lem','E'],['Warbucks','Oliver']) ? 
      5    3  Redo: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      5    3  Fail: supervisor(_422,['Bitdiddle','Ben']) ? 
      3    3  Redo: outranked_by(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      4    4  Redo: supervisor(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      4    4  Exit: supervisor(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      3    3  Exit: outranked_by(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      5    3  Call: supervisor(_434,['Scrooge','Eben']) ? 
      5    3  Exit: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      2    2  Exit: outranked_by(['Cratchet','Robert'],['Warbucks','Oliver']) ? 
      6    2  Call: supervisor(['Bitdiddle','Ben'],['Cratchet','Robert']) ? 
      6    2  Fail: supervisor(['Bitdiddle','Ben'],['Cratchet','Robert']) ? 
      2    2  Redo: outranked_by(['Cratchet','Robert'],['Warbucks','Oliver']) ? 
      5    3  Redo: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      5    3  Fail: supervisor(_422,['Scrooge','Eben']) ? 
      3    3  Redo: outranked_by(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      4    4  Redo: supervisor(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      4    4  Exit: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      3    3  Exit: outranked_by(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      5    3  Call: supervisor(_434,['Cratchet','Robert']) ? 
      5    3  Fail: supervisor(_422,['Cratchet','Robert']) ? 
      3    3  Redo: outranked_by(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      4    4  Redo: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      4    4  Exit: supervisor(['Aull','DeWitt'],['Warbucks','Oliver']) ? 
      3    3  Exit: outranked_by(['Aull','DeWitt'],['Warbucks','Oliver']) ? 
      5    3  Call: supervisor(_434,['Aull','DeWitt']) ? 
      5    3  Fail: supervisor(_422,['Aull','DeWitt']) ? 
      3    3  Redo: outranked_by(['Aull','DeWitt'],['Warbucks','Oliver']) ? 
      4    4  Call: outranked_by(_400,_283) ? 
      5    5  Call: supervisor(_424,_283) ? 
      5    5  Exit: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      4    4  Exit: outranked_by(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      6    4  Call: supervisor(_460,['Hacker','Alyssa','P']) ? 
      6    4  Exit: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      3    3  Exit: outranked_by(['Reasoner','Louis'],['Bitdiddle','Ben']) ? 
      7    3  Call: supervisor(_490,['Reasoner','Louis']) ? 
      7    3  Fail: supervisor(_478,['Reasoner','Louis']) ? 
      3    3  Redo: outranked_by(['Reasoner','Louis'],['Bitdiddle','Ben']) ? 
      6    4  Redo: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      6    4  Fail: supervisor(_448,['Hacker','Alyssa','P']) ? 
      4    4  Redo: outranked_by(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      5    5  Redo: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      5    5  Exit: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      4    4  Exit: outranked_by(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      6    4  Call: supervisor(_460,['Fect','Cy','D']) ? 
      6    4  Fail: supervisor(_448,['Fect','Cy','D']) ? 
      4    4  Redo: outranked_by(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      5    5  Redo: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      5    5  Exit: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      4    4  Exit: outranked_by(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      6    4  Call: supervisor(_460,['Tweakit','Lem','E']) ? 
      6    4  Fail: supervisor(_448,['Tweakit','Lem','E']) ? 
      4    4  Redo: outranked_by(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      5    5  Redo: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      5    5  Exit: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      4    4  Exit: outranked_by(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      6    4  Call: supervisor(_460,['Reasoner','Louis']) ? 
      6    4  Fail: supervisor(_448,['Reasoner','Louis']) ? 
      4    4  Redo: outranked_by(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      5    5  Redo: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      5    5  Exit: supervisor(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      4    4  Exit: outranked_by(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      6    4  Call: supervisor(_458,['Bitdiddle','Ben']) ? 
      6    4  Exit: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      3    3  Exit: outranked_by(['Hacker','Alyssa','P'],['Warbucks','Oliver']) ? 
      7    3  Call: supervisor(_490,['Hacker','Alyssa','P']) ? 
      7    3  Exit: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      2    2  Exit: outranked_by(['Reasoner','Louis'],['Warbucks','Oliver']) ? 
      8    2  Call: supervisor(['Bitdiddle','Ben'],['Reasoner','Louis']) ? 
      8    2  Fail: supervisor(['Bitdiddle','Ben'],['Reasoner','Louis']) ? 
      2    2  Redo: outranked_by(['Reasoner','Louis'],['Warbucks','Oliver']) ? 
      7    3  Redo: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      7    3  Fail: supervisor(_478,['Hacker','Alyssa','P']) ? 
      3    3  Redo: outranked_by(['Hacker','Alyssa','P'],['Warbucks','Oliver']) ? 
      6    4  Redo: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      6    4  Exit: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      3    3  Exit: outranked_by(['Fect','Cy','D'],['Warbucks','Oliver']) ? 
      7    3  Call: supervisor(_490,['Fect','Cy','D']) ? 
      7    3  Fail: supervisor(_478,['Fect','Cy','D']) ? 
      3    3  Redo: outranked_by(['Fect','Cy','D'],['Warbucks','Oliver']) ? 
      6    4  Redo: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      6    4  Exit: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      3    3  Exit: outranked_by(['Tweakit','Lem','E'],['Warbucks','Oliver']) ? 
      7    3  Call: supervisor(_490,['Tweakit','Lem','E']) ? 
      7    3  Fail: supervisor(_478,['Tweakit','Lem','E']) ? 
      3    3  Redo: outranked_by(['Tweakit','Lem','E'],['Warbucks','Oliver']) ? 
      6    4  Redo: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      6    4  Fail: supervisor(_446,['Bitdiddle','Ben']) ? 
      4    4  Redo: outranked_by(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      5    5  Redo: supervisor(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      5    5  Exit: supervisor(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      4    4  Exit: outranked_by(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      6    4  Call: supervisor(_458,['Scrooge','Eben']) ? 
      6    4  Exit: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      3    3  Exit: outranked_by(['Cratchet','Robert'],['Warbucks','Oliver']) ? 
      7    3  Call: supervisor(_488,['Cratchet','Robert']) ? 
      7    3  Fail: supervisor(_476,['Cratchet','Robert']) ? 
      3    3  Redo: outranked_by(['Cratchet','Robert'],['Warbucks','Oliver']) ? 
      6    4  Redo: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      6    4  Fail: supervisor(_446,['Scrooge','Eben']) ? 
      4    4  Redo: outranked_by(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      5    5  Redo: supervisor(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      5    5  Exit: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      4    4  Exit: outranked_by(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      6    4  Call: supervisor(_458,['Cratchet','Robert']) ? 
      6    4  Fail: supervisor(_446,['Cratchet','Robert']) ? 
      4    4  Redo: outranked_by(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      5    5  Redo: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      5    5  Exit: supervisor(['Aull','DeWitt'],['Warbucks','Oliver']) ? 
      4    4  Exit: outranked_by(['Aull','DeWitt'],['Warbucks','Oliver']) ? 
      6    4  Call: supervisor(_458,['Aull','DeWitt']) ? 
      6    4  Fail: supervisor(_446,['Aull','DeWitt']) ? 
      4    4  Redo: outranked_by(['Aull','DeWitt'],['Warbucks','Oliver']) ? 
      5    5  Call: outranked_by(_424,_283) ? 
      6    6  Call: supervisor(_448,_283) ? 
      6    6  Exit: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      5    5  Exit: outranked_by(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      7    5  Call: supervisor(_484,['Hacker','Alyssa','P']) ? 
      7    5  Exit: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      4    4  Exit: outranked_by(['Reasoner','Louis'],['Bitdiddle','Ben']) ? 
      8    4  Call: supervisor(_514,['Reasoner','Louis']) ? 
      8    4  Fail: supervisor(_502,['Reasoner','Louis']) ? 
      4    4  Redo: outranked_by(['Reasoner','Louis'],['Bitdiddle','Ben']) ? 
      7    5  Redo: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      7    5  Fail: supervisor(_472,['Hacker','Alyssa','P']) ? 
      5    5  Redo: outranked_by(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      6    6  Redo: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      6    6  Exit: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      5    5  Exit: outranked_by(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      7    5  Call: supervisor(_484,['Fect','Cy','D']) ? 
      7    5  Fail: supervisor(_472,['Fect','Cy','D']) ? 
      5    5  Redo: outranked_by(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      6    6  Redo: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      6    6  Exit: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      5    5  Exit: outranked_by(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      7    5  Call: supervisor(_484,['Tweakit','Lem','E']) ? 
      7    5  Fail: supervisor(_472,['Tweakit','Lem','E']) ? 
      5    5  Redo: outranked_by(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      6    6  Redo: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      6    6  Exit: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      5    5  Exit: outranked_by(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      7    5  Call: supervisor(_484,['Reasoner','Louis']) ? 
      7    5  Fail: supervisor(_472,['Reasoner','Louis']) ? 
      5    5  Redo: outranked_by(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      6    6  Redo: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      6    6  Exit: supervisor(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      5    5  Exit: outranked_by(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      7    5  Call: supervisor(_482,['Bitdiddle','Ben']) ? 
      7    5  Exit: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      4    4  Exit: outranked_by(['Hacker','Alyssa','P'],['Warbucks','Oliver']) ? 
      8    4  Call: supervisor(_514,['Hacker','Alyssa','P']) ? 
      8    4  Exit: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      3    3  Exit: outranked_by(['Reasoner','Louis'],['Warbucks','Oliver']) ? 
      9    3  Call: supervisor(_544,['Reasoner','Louis']) ? 
      9    3  Fail: supervisor(_532,['Reasoner','Louis']) ? 
      3    3  Redo: outranked_by(['Reasoner','Louis'],['Warbucks','Oliver']) ? 
      8    4  Redo: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      8    4  Fail: supervisor(_502,['Hacker','Alyssa','P']) ? 
      4    4  Redo: outranked_by(['Hacker','Alyssa','P'],['Warbucks','Oliver']) ? 
      7    5  Redo: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      7    5  Exit: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      4    4  Exit: outranked_by(['Fect','Cy','D'],['Warbucks','Oliver']) ? 
      8    4  Call: supervisor(_514,['Fect','Cy','D']) ? 
      8    4  Fail: supervisor(_502,['Fect','Cy','D']) ? 
      4    4  Redo: outranked_by(['Fect','Cy','D'],['Warbucks','Oliver']) ? 
      7    5  Redo: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      7    5  Exit: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      4    4  Exit: outranked_by(['Tweakit','Lem','E'],['Warbucks','Oliver']) ? 
      8    4  Call: supervisor(_514,['Tweakit','Lem','E']) ? 
      8    4  Fail: supervisor(_502,['Tweakit','Lem','E']) ? 
      4    4  Redo: outranked_by(['Tweakit','Lem','E'],['Warbucks','Oliver']) ? 
      7    5  Redo: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      7    5  Fail: supervisor(_470,['Bitdiddle','Ben']) ? 
      5    5  Redo: outranked_by(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      6    6  Redo: supervisor(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      6    6  Exit: supervisor(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      5    5  Exit: outranked_by(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      7    5  Call: supervisor(_482,['Scrooge','Eben']) ? 
      7    5  Exit: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      4    4  Exit: outranked_by(['Cratchet','Robert'],['Warbucks','Oliver']) ? 
      8    4  Call: supervisor(_512,['Cratchet','Robert']) ? 
      8    4  Fail: supervisor(_500,['Cratchet','Robert']) ? 
      4    4  Redo: outranked_by(['Cratchet','Robert'],['Warbucks','Oliver']) ? 
      7    5  Redo: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      7    5  Fail: supervisor(_470,['Scrooge','Eben']) ? 
      5    5  Redo: outranked_by(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      6    6  Redo: supervisor(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      6    6  Exit: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      5    5  Exit: outranked_by(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      7    5  Call: supervisor(_482,['Cratchet','Robert']) ? 
      7    5  Fail: supervisor(_470,['Cratchet','Robert']) ? 
      5    5  Redo: outranked_by(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      6    6  Redo: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      6    6  Exit: supervisor(['Aull','DeWitt'],['Warbucks','Oliver']) ? 
      5    5  Exit: outranked_by(['Aull','DeWitt'],['Warbucks','Oliver']) ? 
      7    5  Call: supervisor(_482,['Aull','DeWitt']) ? 
      7    5  Fail: supervisor(_470,['Aull','DeWitt']) ? 
      5    5  Redo: outranked_by(['Aull','DeWitt'],['Warbucks','Oliver']) ? 
      6    6  Call: outranked_by(_448,_283) ? 
      7    7  Call: supervisor(_472,_283) ? 
      7    7  Exit: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      6    6  Exit: outranked_by(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      8    6  Call: supervisor(_508,['Hacker','Alyssa','P']) ? 
      8    6  Exit: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      5    5  Exit: outranked_by(['Reasoner','Louis'],['Bitdiddle','Ben']) ? 
      9    5  Call: supervisor(_538,['Reasoner','Louis']) ? 
      9    5  Fail: supervisor(_526,['Reasoner','Louis']) ? 
      5    5  Redo: outranked_by(['Reasoner','Louis'],['Bitdiddle','Ben']) ? 
      8    6  Redo: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      8    6  Fail: supervisor(_496,['Hacker','Alyssa','P']) ? 
      6    6  Redo: outranked_by(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      7    7  Redo: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      7    7  Exit: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      6    6  Exit: outranked_by(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      8    6  Call: supervisor(_508,['Fect','Cy','D']) ? 
      8    6  Fail: supervisor(_496,['Fect','Cy','D']) ? 
      6    6  Redo: outranked_by(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      7    7  Redo: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      7    7  Exit: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      6    6  Exit: outranked_by(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      8    6  Call: supervisor(_508,['Tweakit','Lem','E']) ? 
      8    6  Fail: supervisor(_496,['Tweakit','Lem','E']) ? 
      6    6  Redo: outranked_by(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      7    7  Redo: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      7    7  Exit: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      6    6  Exit: outranked_by(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      8    6  Call: supervisor(_508,['Reasoner','Louis']) ? 
      8    6  Fail: supervisor(_496,['Reasoner','Louis']) ? 
      6    6  Redo: outranked_by(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      7    7  Redo: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      7    7  Exit: supervisor(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      6    6  Exit: outranked_by(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      8    6  Call: supervisor(_506,['Bitdiddle','Ben']) ? 
      8    6  Exit: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      5    5  Exit: outranked_by(['Hacker','Alyssa','P'],['Warbucks','Oliver']) ? 
      9    5  Call: supervisor(_538,['Hacker','Alyssa','P']) ? 
      9    5  Exit: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      4    4  Exit: outranked_by(['Reasoner','Louis'],['Warbucks','Oliver']) ? 
     10    4  Call: supervisor(_568,['Reasoner','Louis']) ? 
     10    4  Fail: supervisor(_556,['Reasoner','Louis']) ? 
      4    4  Redo: outranked_by(['Reasoner','Louis'],['Warbucks','Oliver']) ? 
      9    5  Redo: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      9    5  Fail: supervisor(_526,['Hacker','Alyssa','P']) ? 
      5    5  Redo: outranked_by(['Hacker','Alyssa','P'],['Warbucks','Oliver']) ? 
      8    6  Redo: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      8    6  Exit: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      5    5  Exit: outranked_by(['Fect','Cy','D'],['Warbucks','Oliver']) ? 
      9    5  Call: supervisor(_538,['Fect','Cy','D']) ? 
      9    5  Fail: supervisor(_526,['Fect','Cy','D']) ? 
      5    5  Redo: outranked_by(['Fect','Cy','D'],['Warbucks','Oliver']) ? 
      8    6  Redo: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      8    6  Exit: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      5    5  Exit: outranked_by(['Tweakit','Lem','E'],['Warbucks','Oliver']) ? 
      9    5  Call: supervisor(_538,['Tweakit','Lem','E']) ? 
      9    5  Fail: supervisor(_526,['Tweakit','Lem','E']) ? 
      5    5  Redo: outranked_by(['Tweakit','Lem','E'],['Warbucks','Oliver']) ? 
      8    6  Redo: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      8    6  Fail: supervisor(_494,['Bitdiddle','Ben']) ? 
      6    6  Redo: outranked_by(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      7    7  Redo: supervisor(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      7    7  Exit: supervisor(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      6    6  Exit: outranked_by(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      8    6  Call: supervisor(_506,['Scrooge','Eben']) ? 
      8    6  Exit: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      5    5  Exit: outranked_by(['Cratchet','Robert'],['Warbucks','Oliver']) ? 
      9    5  Call: supervisor(_536,['Cratchet','Robert']) ? 
      9    5  Fail: supervisor(_524,['Cratchet','Robert']) ? 
      5    5  Redo: outranked_by(['Cratchet','Robert'],['Warbucks','Oliver']) ? 
      8    6  Redo: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      8    6  Fail: supervisor(_494,['Scrooge','Eben']) ? 
      6    6  Redo: outranked_by(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      7    7  Redo: supervisor(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      7    7  Exit: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      6    6  Exit: outranked_by(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      8    6  Call: supervisor(_506,['Cratchet','Robert']) ? 
      8    6  Fail: supervisor(_494,['Cratchet','Robert']) ? 
      6    6  Redo: outranked_by(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      7    7  Redo: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      7    7  Exit: supervisor(['Aull','DeWitt'],['Warbucks','Oliver']) ? 
      6    6  Exit: outranked_by(['Aull','DeWitt'],['Warbucks','Oliver']) ? 
      8    6  Call: supervisor(_506,['Aull','DeWitt']) ? 
      8    6  Fail: supervisor(_494,['Aull','DeWitt']) ? 
      6    6  Redo: outranked_by(['Aull','DeWitt'],['Warbucks','Oliver']) ? 
      7    7  Call: outranked_by(_472,_283) ? 
      8    8  Call: supervisor(_496,_283) ? 
      8    8  Exit: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      7    7  Exit: outranked_by(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      9    7  Call: supervisor(_532,['Hacker','Alyssa','P']) ? 
      9    7  Exit: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      6    6  Exit: outranked_by(['Reasoner','Louis'],['Bitdiddle','Ben']) ? 
     10    6  Call: supervisor(_562,['Reasoner','Louis']) ? 
     10    6  Fail: supervisor(_550,['Reasoner','Louis']) ? 
      6    6  Redo: outranked_by(['Reasoner','Louis'],['Bitdiddle','Ben']) ? 
      9    7  Redo: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      9    7  Fail: supervisor(_520,['Hacker','Alyssa','P']) ? 
      7    7  Redo: outranked_by(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      8    8  Redo: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      8    8  Exit: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      7    7  Exit: outranked_by(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      9    7  Call: supervisor(_532,['Fect','Cy','D']) ? 
      9    7  Fail: supervisor(_520,['Fect','Cy','D']) ? 
      7    7  Redo: outranked_by(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      8    8  Redo: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      8    8  Exit: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      7    7  Exit: outranked_by(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      9    7  Call: supervisor(_532,['Tweakit','Lem','E']) ? 
      9    7  Fail: supervisor(_520,['Tweakit','Lem','E']) ? 
      7    7  Redo: outranked_by(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      8    8  Redo: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      8    8  Exit: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      7    7  Exit: outranked_by(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      9    7  Call: supervisor(_532,['Reasoner','Louis']) ? 
      9    7  Fail: supervisor(_520,['Reasoner','Louis']) ? 
      7    7  Redo: outranked_by(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      8    8  Redo: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      8    8  Exit: supervisor(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      7    7  Exit: outranked_by(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      9    7  Call: supervisor(_530,['Bitdiddle','Ben']) ? 
      9    7  Exit: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      6    6  Exit: outranked_by(['Hacker','Alyssa','P'],['Warbucks','Oliver']) ? 
     10    6  Call: supervisor(_562,['Hacker','Alyssa','P']) ? 
     10    6  Exit: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      5    5  Exit: outranked_by(['Reasoner','Louis'],['Warbucks','Oliver']) ? 
     11    5  Call: supervisor(_592,['Reasoner','Louis']) ? 
     11    5  Fail: supervisor(_580,['Reasoner','Louis']) ? 
      5    5  Redo: outranked_by(['Reasoner','Louis'],['Warbucks','Oliver']) ? 
     10    6  Redo: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
     10    6  Fail: supervisor(_550,['Hacker','Alyssa','P']) ? 
      6    6  Redo: outranked_by(['Hacker','Alyssa','P'],['Warbucks','Oliver']) ? 
      9    7  Redo: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      9    7  Exit: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      6    6  Exit: outranked_by(['Fect','Cy','D'],['Warbucks','Oliver']) ? 
     10    6  Call: supervisor(_562,['Fect','Cy','D']) ? 
     10    6  Fail: supervisor(_550,['Fect','Cy','D']) ? 
      6    6  Redo: outranked_by(['Fect','Cy','D'],['Warbucks','Oliver']) ? 
      9    7  Redo: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      9    7  Exit: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      6    6  Exit: outranked_by(['Tweakit','Lem','E'],['Warbucks','Oliver']) ? 
     10    6  Call: supervisor(_562,['Tweakit','Lem','E']) ? 
     10    6  Fail: supervisor(_550,['Tweakit','Lem','E']) ? 
      6    6  Redo: outranked_by(['Tweakit','Lem','E'],['Warbucks','Oliver']) ? 
      9    7  Redo: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      9    7  Fail: supervisor(_518,['Bitdiddle','Ben']) ? 
      7    7  Redo: outranked_by(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      8    8  Redo: supervisor(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      8    8  Exit: supervisor(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      8    8  Exit: supervisor(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      7    7  Exit: outranked_by(['Scrooge','Eben'],['Warbucks','Oliver']) ? a
</p>

<p class="orig" lang="en">
<a name="%_thm_4.65"></a>
<b>Exercise 4.65.</b>  <a name="%_idx_5278"></a>Cy D. Fect, looking forward to the day when he will rise in the
organization, gives a query to find all the wheels
(using the <tt>wheel</tt> rule of section <a href="#%_sec_4.4.1">4.4.1</a>):</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.65.</b> ã‚µã‚¤ãƒ»Dãƒ»ãƒ•ã‚§ã‚¯ãƒˆã¯ã€çµ„ç¹”å†…ã§æ˜‡æ ¼ã™ã‚‹æ—¥ã‚’æ¥½ã—ã¿ã«ã—ã¦ã„ã¦ã€å¤§ç‰©ãŸã¡ã™ã¹ã¦ã‚’è¦‹ã¤ã‘ã‚‹ãŸã‚ã« (<a href="#%_sec_4.4.1">4.4.1</a>ç¯€ã® <a href="#%_idx_5144"><tt>wheel</tt> ã®è¦å‰‡</a>ã‚’ä½¿ã£ã¦) ã‚¯ã‚¨ãƒªã‚’ä¸ãˆã‚‹ã€‚
</p>

<p class="lisp">(wheel ?who)
</p>

<p class="orig" lang="en">To his surprise, the system responds</p>

<p class="trans" lang="ja">
å½¼ãŒé©šã„ãŸã“ã¨ã«ã¯ã€ã‚·ã‚¹ãƒ†ãƒ ã¯æ¬¡ã®ã‚ˆã†ã«å¿œç­”ã™ã‚‹ã®ã ã€‚
</p>

<p class="lisp"><i>;;; Query results:</i>
(wheel (Warbucks Oliver))
(wheel (Bitdiddle Ben))
(wheel (Warbucks Oliver))
(wheel (Warbucks Oliver))
(wheel (Warbucks Oliver))
</p>

<p class="orig" lang="en">Why is Oliver Warbucks listed four times?
</p>

<p class="trans" lang="ja">
ãªãœã‚ªãƒªãƒãƒ¼ãƒ»ã‚¦ã‚©ãƒ¼ãƒãƒƒã‚¯ã‚¹ãŒ4å›åˆ—æŒ™ã•ã‚Œã¦ã„ã‚‹ã®ã ã‚ã†?
</p>

<p class="exercise"><span class="ex_comment">ã¾ãšã€wheel ã®è¦å‰‡ã®æœ¬ä½“ã® and ç¯€ã®ä¸­ã®</span>
(supervisor ?middle-manager ?person)
<span class="ex_comment">ã«ãƒãƒƒãƒã™ã‚‹è¨€æ˜ã¨ã—ã¦ã€ä»¥ä¸‹ã®ã‚‚ã®ãŒè¦‹ã¤ã‹ã‚‹ã€‚ä¾¿å®œä¸Šã€ç•ªå·ã‚’æŒ¯ã£ã¦ãŠãã€‚
ã“ã‚Œã‚‰ã®è¨€æ˜ã®ç¬¬2å¼•æ•°ãŒã€ã€Œå¤§ç‰©ã€ã®å€™è£œã¨ã„ã†ã“ã¨ã€‚</span>

(supervisor (Hacker Alyssa P) (Bitdiddle Ben))    <span class="ex_comment">(1)</span>
(supervisor (Fect Cy D) (Bitdiddle Ben))          <span class="ex_comment">(2)</span>
(supervisor (Tweakit Lem E) (Bitdiddle Ben))      <span class="ex_comment">(3)</span>
(supervisor (Reasoner Louis) (Hacker Alyssa P))   <span class="ex_comment">(4)</span>
(supervisor (Bitdiddle Ben) (Warbucks Oliver))    <span class="ex_comment">(5)</span>
(supervisor (Scrooge Eben) (Warbucks Oliver))     <span class="ex_comment">(6)</span>
(supervisor (Cratchet Robert) (Scrooge Eben))     <span class="ex_comment">(7)</span>
(supervisor (Aull DeWitt) (Warbucks Oliver))      <span class="ex_comment">(8)</span>

<span class="ex_comment">å›³ã§ç¤ºã™ã¨ã€ä»¥ä¸‹ã®é€šã‚Šã®ä¸Šä¸‹é–¢ä¿‚ã€‚</span>
Warbucks Oliver
  |
  +-- Bitdiddle Ben
  |     |
  |     +-- Hacker Alyssa P
  |     |     |
  |     |     +-- Reasoner Louis
  |     |
  |     +-- Fect Cy D
  |     +-- Tweakit Lem E
  |
  +-- Scrooge Eben
  |     |
  |     +-- Cratchet Robert
  |
  +-- Aull DeWitt

<span class="ex_comment">wheel ã®è¦å‰‡ã¯ã€èª°ã‹ã®äºŒæ®µä¸Šã®äººã‚’ wheel (å¤§ç‰©) ã¨å®šç¾©ã—ã¦ã„ã‚‹ã‚ã‘ã ã‹ã‚‰ã€
  * ã‚¢ãƒªãƒƒã‚µã®äºŒæ®µä¸Šã«ã„ã‚‹è·å“¡ã¨ã—ã¦ã®ã€ã‚ªãƒªãƒãƒ¼
  * ãƒ«ã‚¤ã‚¹ã®äºŒæ®µä¸Šã«ã„ã‚‹è·å“¡ã¨ã—ã¦ã®ã€ãƒ™ãƒ³
  * ã‚µã‚¤ã®äºŒæ®µä¸Šã«ã„ã‚‹è·å“¡ã¨ã—ã¦ã®ã€ã‚ªãƒªãƒãƒ¼
  * ãƒ¬ãƒ ã®äºŒæ®µä¸Šã«ã„ã‚‹è·å“¡ã¨ã—ã¦ã®ã€ã‚ªãƒªãƒãƒ¼
  * ãƒ­ãƒãƒ¼ãƒˆã®äºŒæ®µä¸Šã«ã„ã‚‹è·å“¡ã¨ã—ã¦ã®ã€ã‚ªãƒªãƒãƒ¼
ãŒç­”ãˆã¨ã—ã¦å‡ºã¦ãã‚‹ã€‚ã¨ã„ã†ã“ã¨ã§ã€å¿œç­”ã«ã¯ã‚ªãƒªãƒãƒ¼ãŒ4å›å«ã¾ã‚Œã‚‹ã€‚

å®Ÿéš›ã€ä¸Šè¨˜(1)ã€œ(7)ãã‚Œãã‚Œã«ã‚ˆã£ã¦å¤‰æ•°ãŒæŸç¸›ã•ã‚Œã¦ã§ããŸå„ãƒ•ãƒ¬ãƒ¼ãƒ ã§ã€</span>
(supervisor ?x ?middle-manager)
<span class="ex_comment">ã«ãƒãƒƒãƒã™ã‚‹è¨€æ˜ã¯ã€ä»¥ä¸‹ã®ã¨ãŠã‚Šã§ã‚ã‚‹ã€‚
  * (1)ã‹ã‚‰ã§ããŸãƒ•ãƒ¬ãƒ¼ãƒ ã§ã¯ã€(4)ãŒãƒãƒƒãƒã™ã‚‹ã€‚ã‚ˆã£ã¦ã€ãƒ™ãƒ³ã¯å¤§ç‰©ã€‚
  * (2)ã€(3)ã€(4)ã®å„ã€…ã‹ã‚‰ã§ããŸãƒ•ãƒ¬ãƒ¼ãƒ ã§ã¯ã€ã“ã®ãƒ‘ã‚¿ãƒ³ã«ãƒãƒƒãƒã™ã‚‹ã‚‚ã®ãŒãªã„ã€‚
  * (5)ã‹ã‚‰ã§ããŸãƒ•ãƒ¬ãƒ¼ãƒ ã§ã¯ã€(1)ã€(2)ã€(3)ãŒãƒãƒƒãƒã™ã‚‹ã€‚
    ã‚ˆã£ã¦ã€ã‚ªãƒªãƒãƒ¼ã¯å¤§ç‰©ã€‚ã¾ãŸã€ä¸‰ã¤ã«ãƒãƒƒãƒã—ãŸã®ã§ã€ã‚ªãƒªãƒãƒ¼ã¯3å›ã€å¿œç­”ã«å‡ºç¾ã™ã‚‹ã€‚
  * (6)ã‹ã‚‰ã§ããŸãƒ•ãƒ¬ãƒ¼ãƒ ã§ã¯ã€(7)ãŒãƒãƒƒãƒã™ã‚‹ã€‚ã‚ˆã£ã¦ã€ã‚ªãƒªãƒãƒ¼ã¯å¤§ç‰©ã€‚
  * (7)ã€(8)ã®å„ã€…ã‹ã‚‰ã§ããŸãƒ•ãƒ¬ãƒ¼ãƒ ã§ã¯ã€ãƒãƒƒãƒã™ã‚‹ã‚‚ã®ãŒãªã„ã€‚
</span></p>

<p class="extra_code"><span class="ex_comment">% <a href="#%_thm_4.64">ç·´ç¿’å•é¡Œ4.64</a>ã¨åŒæ§˜ã«ãƒˆãƒ¬ãƒ¼ã‚¹ã‚’è¡Œã£ã¦ã¿ã‚‹ã€‚</span>
| ?- wheel(Who).
      1    1  Call: wheel(_279) ? 
      2    2  Call: supervisor(_347,_279) ? 
      2    2  Exit: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      3    2  Call: supervisor(_344,['Hacker','Alyssa','P']) ? 
      3    2  Exit: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      1    1  Exit: wheel(['Bitdiddle','Ben']) ? 

Who = ['Bitdiddle','Ben'] ? ;
<span class="ex_comment">% ãƒ«ã‚¤ã‚¹â†’ã‚¢ãƒªãƒƒã‚µâ†’ãƒ™ãƒ³</span>

      1    1  Redo: wheel(['Bitdiddle','Ben']) ? 
      3    2  Redo: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      3    2  Fail: supervisor(_344,['Hacker','Alyssa','P']) ? 
      2    2  Redo: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      2    2  Exit: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      3    2  Call: supervisor(_344,['Fect','Cy','D']) ? 
      3    2  Fail: supervisor(_344,['Fect','Cy','D']) ? 
      2    2  Redo: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      2    2  Exit: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      3    2  Call: supervisor(_344,['Tweakit','Lem','E']) ? 
      3    2  Fail: supervisor(_344,['Tweakit','Lem','E']) ? 
      2    2  Redo: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      2    2  Exit: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      3    2  Call: supervisor(_344,['Reasoner','Louis']) ? 
      3    2  Fail: supervisor(_344,['Reasoner','Louis']) ? 
      2    2  Redo: supervisor(['Reasoner','Louis'],['Hacker','Alyssa','P']) ? 
      2    2  Exit: supervisor(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      3    2  Call: supervisor(_342,['Bitdiddle','Ben']) ? 
      3    2  Exit: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      1    1  Exit: wheel(['Warbucks','Oliver']) ? 

Who = ['Warbucks','Oliver'] ? ;
<span class="ex_comment">% </span>

      1    1  Redo: wheel(['Warbucks','Oliver']) ? 
      3    2  Redo: supervisor(['Hacker','Alyssa','P'],['Bitdiddle','Ben']) ? 
      3    2  Exit: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      1    1  Exit: wheel(['Warbucks','Oliver']) ? 

Who = ['Warbucks','Oliver'] ? ;
<span class="ex_comment">% </span>

      1    1  Redo: wheel(['Warbucks','Oliver']) ? 
      3    2  Redo: supervisor(['Fect','Cy','D'],['Bitdiddle','Ben']) ? 
      3    2  Exit: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      1    1  Exit: wheel(['Warbucks','Oliver']) ? 

Who = ['Warbucks','Oliver'] ? ;
<span class="ex_comment">% </span>

      1    1  Redo: wheel(['Warbucks','Oliver']) ? 
      3    2  Redo: supervisor(['Tweakit','Lem','E'],['Bitdiddle','Ben']) ? 
      3    2  Fail: supervisor(_342,['Bitdiddle','Ben']) ? 
      2    2  Redo: supervisor(['Bitdiddle','Ben'],['Warbucks','Oliver']) ? 
      2    2  Exit: supervisor(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      3    2  Call: supervisor(_342,['Scrooge','Eben']) ? 
      3    2  Exit: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      1    1  Exit: wheel(['Warbucks','Oliver']) ? 

Who = ['Warbucks','Oliver'] ? ;
<span class="ex_comment">% </span>

      1    1  Redo: wheel(['Warbucks','Oliver']) ? 
      3    2  Redo: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      3    2  Fail: supervisor(_342,['Scrooge','Eben']) ? 
      2    2  Redo: supervisor(['Scrooge','Eben'],['Warbucks','Oliver']) ? 
      2    2  Exit: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      3    2  Call: supervisor(_342,['Cratchet','Robert']) ? 
      3    2  Fail: supervisor(_342,['Cratchet','Robert']) ? 
      2    2  Redo: supervisor(['Cratchet','Robert'],['Scrooge','Eben']) ? 
      2    2  Exit: supervisor(['Aull','DeWitt'],['Warbucks','Oliver']) ? 
      3    2  Call: supervisor(_342,['Aull','DeWitt']) ? 
      3    2  Fail: supervisor(_342,['Aull','DeWitt']) ? 
      1    1  Fail: wheel(_279) ? 

(4 ms) no
<span class="ex_comment">% ã“ã‚Œä»¥ä¸Šã®è§£ã¯ãªã„ã¨åˆ†ã‹ã£ãŸã®ã§ã€ã“ã‚Œã§çµ‚ã‚ã‚Šã€‚</span>
</p>

<p class="orig" lang="en">
<a name="%_thm_4.66"></a>
<b>Exercise 4.66.</b>  <a name="%_idx_5280"></a>Ben has been generalizing the query system to provide statistics
about the company.  For example, to find the total salaries of all the
computer programmers one will be able to say</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.66.</b> ãƒ™ãƒ³ã¯ã€ä¼šç¤¾ã«ã¤ã„ã¦ã®çµ±è¨ˆå€¤ã‚’æä¾›ã™ã‚‹ãŸã‚ã«ã€ã‚¯ã‚¨ãƒªãƒ»ã‚·ã‚¹ãƒ†ãƒ ã®ä¸€èˆ¬åŒ–ã‚’ãšã£ã¨è¡Œã£ã¦ã„ã‚‹ã€‚
ãŸã¨ãˆã°ã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ»ãƒ—ãƒ­ã‚°ãƒ©ãƒå…¨å“¡ã®çµ¦ä¸ç·é¡ã‚’çŸ¥ã‚‹ãŸã‚ã«ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã«è¿°ã¹ã‚‹ã“ã¨ãŒå¯èƒ½ã¨ãªã‚‹ã“ã¨ã ã‚ã†ã€‚
</p>

<p class="lisp">(sum ?amount
     (and (job ?x (computer programmer))
          (salary ?x ?amount)))
</p>

<p class="orig" lang="en">In general, Ben's new system allows expressions of the form</p>

<p class="trans" lang="ja">
ä¸€èˆ¬ã«ã€ãƒ™ãƒ³ã®æ–°ã‚·ã‚¹ãƒ†ãƒ ã¯ã€ä»¥ä¸‹ã®å½¢ã®å¼ã‚’è¨±ã—ã€
</p>

<p class="lisp">(accumulation-function &lt;<em>variable</em>&gt;
                       &lt;<em>query pattern</em>&gt;)
</p>

<p class="orig" lang="en">where <tt>accumulation-function</tt> can be things like <tt>sum</tt>,  
<tt>average</tt>, or <tt>maximum</tt>.  Ben reasons that it should be a
cinch to implement this.  He will simply feed the query pattern to
<tt>qeval</tt>.  This will produce a stream of frames.  He will then pass
this stream through a mapping function that extracts the value of the
designated variable from each frame in the stream and feed the
resulting stream of values to the accumulation function.  Just as Ben
completes the implementation and is about to try it out, Cy walks by,
still puzzling over the <tt>wheel</tt> query result in
exercise <a href="#%_thm_4.65">4.65</a>.  When Cy shows Ben the system's
response, Ben groans, ``Oh, no, my simple accumulation scheme won't
work!''</p>

<p class="trans" lang="ja">
ã“ã“ã§ã€<tt>accumulation-function</tt> ã¯ã€<tt>sum</tt> ã‚„ã€<tt>average</tt> ã‚„ã€ã‚ã‚‹ã„ã¯ <tt>maximum</tt> ã®ã‚ˆã†ãªã‚‚ã®ã¨ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
ãƒ™ãƒ³ã¯ã€ã“ã‚Œã‚’å®Ÿè£…ã™ã‚‹ã®ã¯æœé£¯å‰ã®ã¯ãšã ã€ã¨æ¨æ¸¬ã™ã‚‹ã€‚
å½¼ã¯ã€å˜ç´”ã«ã‚¯ã‚¨ãƒªãƒ»ãƒ‘ã‚¿ãƒ³ã‚’ <tt>qeval</tt> ã¸ã¨ä¸ãˆã‚‹ã ã‚ã†ã€‚
ã“ã‚Œã¯ã€ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½œã‚Šå‡ºã™ã ã‚ã†ã€‚
å½¼ã¯ã€ãã‚Œã‹ã‚‰ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ å†…ã®å„ãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰æŒ‡å®šã•ã‚ŒãŸå¤‰æ•°ã®å€¤ã‚’æŠ½å‡ºã™ã‚‹ãƒãƒƒãƒ”ãƒ³ã‚°é–¢æ•°ã‚’é€šã˜ã¦ã€ã“ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å—ã‘æ¸¡ã—ã€ãã—ã¦ã€çµæœã¨ã—ã¦å¾—ã‚‰ã‚Œã‚‹å€¤ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ã€ç´¯ç©é–¢æ•°ã«ä¸ãˆã‚‹ã ã‚ã†ã€‚
ãƒ™ãƒ³ãŒã¡ã‚‡ã†ã©å®Ÿè£…ã‚’å®Œäº†ã—ã¦ã€ã¾ã•ã«ãã®å®Ÿè£…ã‚’è©¦ã—ã¦ã¿ã‚ˆã†ã¨ã™ã‚‹ã¨ãã«ã€ã‚µã‚¤ãŒé€šã‚Šã‹ã‹ã£ãŸã®ã ãŒã€ã‚µã‚¤ã¯ã€ç·´ç¿’å•é¡Œ<a href="#%_thm_4.65">4.65</a>ã§ã® <tt>wheel</tt> ã®ã‚¯ã‚¨ãƒªã®çµæœã«ã€ã¾ã é ­ã‚’æ‚©ã¾ã›ã¦ã„ã‚‹ã€‚
ã‚µã‚¤ãŒãƒ™ãƒ³ã«ã‚·ã‚¹ãƒ†ãƒ ã®å¿œç­”ã‚’è¦‹ã›ã‚‹ã¨ã€ãƒ™ãƒ³ã¯ã€Œã‚ã¡ã‚ƒãƒ¼ã€åƒ•ã®å˜ç´”ãªç´¯ç©ã®ã‚„ã‚Šæ–¹ã¯ã†ã¾ãã„ã‹ãªã„ã‚ˆ!ã€ã¨ã†ã‚ãã€‚
</p>

<p class="orig" lang="en">
What has Ben just realized?  Outline a method he can use to
salvage the situation.
</p>

<p class="trans" lang="ja">
ã¡ã‚‡ã†ã©ä»Šã€ãƒ™ãƒ³ã¯ä½•ã«æ°—ã¥ã„ãŸã¨ã“ã‚ãªã®ã ã‚ã†?
çŠ¶æ³ã‚’æ•‘ã„å‡ºã™ãŸã‚ã«å½¼ãŒä½¿ãˆã‚‹æ–¹æ³•ã«ã¤ã„ã¦ã€æ¦‚è¦ã‚’è¿°ã¹ã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment">ç·´ç¿’å•é¡Œ<a href="#%_thm_4.65">4.65</a>ã§ã‚ªãƒªãƒãƒ¼ãŒ4å›å‡ºç¾ã—ãŸã“ã¨ã‚’è€ƒæ…®ã™ã‚‹ã¨ã€
ã‚‚ã—ã€ä¸Šè¨˜ã®ãƒ™ãƒ³ã®å®Ÿè£…ã§</span>
(sum ?amount (and (wheel ?x) (salary ?x ?amount)))
<span class="ex_comment">ã¨ã™ã‚‹ã¨ã€æ‰€æœ›ã®ã€Œå¤§ç‰©ãŸã¡ã®çµ¦ä¸ç·é¡ã€ã¯å¾—ã‚‰ã‚Œãšã€ã‚ªãƒªãƒãƒ¼ã®çµ¦ä¸ãŒ4å›æ•°ãˆã‚‰ã‚Œã¦ã—ã¾ã†ã€‚

ã¤ã¾ã‚Šã€ã‚¯ã‚¨ãƒªã« <tt>or</tt> ãŒå«ã¾ã‚Œã¦ã„ãªãã¦ã•ãˆã‚‚ã€
  * ã‚ã‚‹ä¸€ã¤ã®ã‚¯ã‚¨ãƒª (ãŸã¨ãˆã° (wheel ?x) ) ã¨ã€
  * ãã®ä¸­ã®ä¸€ã¤ã®å¤‰æ•° (ãŸã¨ãˆã° ?x) ã¨ã€
  * ãã®ã‚¯ã‚¨ãƒªã‚’æº€ãŸã™ã‚ˆã†ãªã€ãã®å¤‰æ•°ã«å¯¾ã™ã‚‹ç‰¹å®šã®ä¸€ã¤ã®å€¤ (ãŸã¨ãˆã° (Warbucks Oliver) )
ã®çµ„ã¿åˆã‚ã›ã‚’å°ãå‡ºã™ã‚ˆã†ãªãƒ•ãƒ¬ãƒ¼ãƒ ãŒã€è¤‡æ•°å­˜åœ¨ã™ã‚‹å ´åˆãŒã‚ã‚‹ã€ã¨ã„ã†ã“ã¨ã€‚
å¤šåˆ†ã€ãƒ™ãƒ³ã¯ãã®ã“ã¨ã«æ°—ã¥ã„ãŸã¨ã“ã‚ãªã®ã ã‚ã†ã€‚

è§£æ±ºç­–ã¯ã€ç´¯ç©é–¢æ•°ã«å€¤ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä¸ãˆã‚‹å‰ã«ã€ã“ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‹ã‚‰ã€é‡è¤‡ã—ãŸå€¤ã‚’
å–ã‚Šé™¤ãã“ã¨ã€‚ãã—ã¦ã€å€¤ã®é‡è¤‡ã®ãªã„ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ã€ç´¯ç©é–¢æ•°ã«ä¸ãˆã‚‹ã“ã¨
(å…·ä½“çš„ã«ã©ã†å®Ÿè£…ã™ã‚‹ã‹ã¯ã¨ã‚‚ã‹ãã¨ã—ã¦)ã€‚
</p>


<p class="orig" lang="en">
<a name="%_thm_4.67"></a>
<b>Exercise 4.67.</b>  <a name="%_idx_5282"></a><a name="%_idx_5284"></a>Devise a way to install a loop detector in the query system so as to
avoid the kinds of simple loops illustrated in the text and in
exercise <a href="#%_thm_4.64">4.64</a>.  The general idea is that the
system should maintain some sort of history of its current chain of
deductions and should not begin processing a query that it is already
working on.  Describe what kind of information (patterns and frames)
is included in this history, and how the check should be made.  (After
you study the details of the query-system implementation in
section <a href="#%_sec_4.4.4">4.4.4</a>, you may want to
modify the system to include your loop detector.)
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.67.</b> æœ¬æ–‡ã¨ç·´ç¿’å•é¡Œ<a href="#%_thm_4.64">4.64</a>ã«ãŠã„ã¦ä¾‹ç¤ºã•ã‚Œã¦ã„ã‚‹å˜ç´”ãªãƒ«ãƒ¼ãƒ—ã®é¡ã‚’é¿ã‘ã‚‹ã‚ˆã†ã«ã€ã‚¯ã‚¨ãƒªãƒ»ã‚·ã‚¹ãƒ†ãƒ å†…ã«ãƒ«ãƒ¼ãƒ—æ¤œå‡ºå™¨ã‚’çµ„ã¿å…¥ã‚Œã‚‹æ–¹æ³•ã‚’ã€è€ƒæ¡ˆã›ã‚ˆã€‚
ä¸€èˆ¬çš„ãªè€ƒãˆæ–¹ã¯ã€ã‚·ã‚¹ãƒ†ãƒ ã¯è‡ªåˆ†ã®ç¾åœ¨ã®æ¼”ç¹¹ã®é€£é–ã«ã¤ã„ã¦ã®ã€ã‚ã‚‹ç¨®ã®å±¥æ­´ã‚’ç¶­æŒã™ã¹ãã§ã‚ã‚Šã€ã‹ã¤ã€ãã®ã‚·ã‚¹ãƒ†ãƒ ãŒæ—¢ã«<!-- ãã‚Œã«ã¤ã„ã¦ä½œæ¥­ã—ãŸã“ã¨ã®ã‚ã‚‹ -->ä½œæ¥­å¯¾è±¡ã¨ã—ã¦ã„ã‚‹ã‚¯ã‚¨ãƒªã‚’ã€å‡¦ç†ã—å§‹ã‚ã‚‹ã¹ãã§ã¯ãªã„ã€ã¨ã„ã†ã‚‚ã®ã ã€‚
ã©ã®ã‚ˆã†ãªç¨®é¡ã®æƒ…å ± (ãƒ‘ã‚¿ãƒ³ã¨ãƒ•ãƒ¬ãƒ¼ãƒ ) ãŒã“ã®å±¥æ­´ã«å«ã¾ã‚Œã‚‹ã®ã‹ã€ãã—ã¦ã€ã©ã®ã‚ˆã†ã«ã—ã¦ç¢ºèªãŒè¡Œã‚ã‚Œã‚‹ã¹ããªã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’èª¬æ˜ã›ã‚ˆ (å›ã¯ã€ã‚¯ã‚¨ãƒªãƒ»ã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…ã®è©³ç´°ã«ã¤ã„ã¦<a href="#%_sec_4.4.4">4.4.4</a>ç¯€ã§ç ”ç©¶ã—ãŸå¾Œã€è‡ªåˆ†ã®ãƒ«ãƒ¼ãƒ—æ¤œå‡ºå™¨ã‚’å«ã‚ã‚‹ã‚ˆã†ã«ã‚·ã‚¹ãƒ†ãƒ ã‚’æ”¹å¤‰ã—ãŸã„ã¨æ€ã†ã‹ã‚‚ã—ã‚Œãªã„ã­)ã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_4.68"></a>
<b>Exercise 4.68.</b>  <a name="%_idx_5286"></a>Define rules to implement the <tt>reverse</tt> operation of
exercise <a href="15_sec2_2.html#%_thm_2.18">2.18</a>, which returns a list containing the same
elements as a given list in reverse order.  (Hint: Use <tt>append-to-form</tt>.)
Can your rules answer both
<tt>(reverse (1 2 3) ?x)</tt> and <tt>(reverse ?x (1 2 3))</tt> ?
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.68.</b> ç·´ç¿’å•é¡Œ<a href="15_sec2_2.html#%_thm_2.18">2.18</a>ã® <tt>reverse</tt> æ¼”ç®—â€”â€”ä¸ãˆã‚‰ã‚ŒãŸãƒªã‚¹ãƒˆã¨åŒã˜è¦ç´ ã‚’é€†é †ã§å«ã‚€ãƒªã‚¹ãƒˆã‚’è¿”ã™â€”â€”ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã®è¦å‰‡ã‚’å®šç¾©ã›ã‚ˆ (ãƒ’ãƒ³ãƒˆ: <a href="#%_idx_5158"><tt>append-to-form</tt></a> ã‚’ä½¿ãˆ)ã€‚
å›ã®è¦å‰‡ã¯ã€<tt>(reverse (1 2 3) ?x)</tt> ã¨ <tt>(reverse ?x (1 2 3))</tt> ã®ä¸¡æ–¹ã«ç­”ãˆã‚‰ã‚Œã‚‹ã‹ãª?
</p>

<p class="exercise"><span class="ex_comment">; ã¨ã‚Šã‚ãˆãšã€ä»¥ä¸‹ã®å®šç¾©ã‚’ã‚¯ã‚¨ãƒªè¨€èªã«ç¿»è¨³ã—ã‚ˆã†ã‹ãªã€‚</span>
(define (reverse arg-list)
  (if (or (null? arg-list) (null? (cdr arg-list)))
      arg-list
      (append (reverse (cdr arg-list)) (list (car arg-list)))))

<span class="ex_comment">; å ´åˆåˆ†ã‘ã«ã—ãŸãŒã£ã¦ã€è¦å‰‡ã‚’æ›¸ãä¸¦ã¹ã¦ã¿ãŸã€‚</span>
(rule (reverse () ()))
(rule (reverse (?x) (?x)))
(rule (reverse (?given-car . ?given-cdr) ?reversed-list)
      (and (reverse ?given-cdr ?reversed-cdr)
           (append-to-form ?reversed-cdr (?given-car) ?reversed-list)))

<span class="ex_comment">; ã“ã®ã‚ˆã†ãªå®šç¾©ã§ã†ã¾ãå‹•ãã®ã‹ã‚’è€ƒãˆã‚‹ã€‚
(a) (reverse (1 2 3) ?x) ã¯ã€3ç•ªç›®ã®è¦å‰‡ã«ãƒãƒƒãƒã™ã‚‹ã€‚
    ã“ã“ã§ã€ã€Œ?given-car ãŒ 1 ã«æŸç¸›ã•ã‚Œã€?given-cdr ãŒ (2 3) ã«æŸç¸›ã•ã‚Œã€
    ?reversed-list ãŒ ?x ã«æŸç¸›ã•ã‚ŒãŸãƒ•ãƒ¬ãƒ¼ãƒ ã€(F1 ã¨ã™ã‚‹) ãŒã§ãã‚‹ã€‚
(b) æ¬¡ã¯ F1 ã§ã® (reverse (2 3) ?reversed-cdr) ã®ãƒ¦ãƒ‹ãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã ãŒã€
    ã“ã‚Œã‚‚3ç•ªç›®ã®è¦å‰‡ã«ãƒãƒƒãƒã™ã‚‹ã€‚å¤‰æ•°ã®åå‰ãŒåŒã˜ãªã®ã§ã‚„ã‚„ã“ã—ã„ãŒã€
    F1 ã«å¯¾ã™ã‚‹å­ãƒ•ãƒ¬ãƒ¼ãƒ  (F2 ã¨ã™ã‚‹) ã®å´ã§ã¯ã€?given-car ãŒ 2 ã«æŸç¸›ã•ã‚Œã€
    ?given-cdr ãŒ (3) ã«æŸç¸›ã•ã‚Œã€?reversed-list ã¯ F1 ã§ã® ?reversed-cdr ã«
    æŸç¸›ã•ã‚Œã‚‹ã€‚
(c) ã™ã‚‹ã¨ä»Šåº¦ã¯ F2 ã§ã® (reverse (3) ?reversed-cdr) ã®ãƒ¦ãƒ‹ãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã ãŒã€
    ã“ã‚Œã¯2ç•ªç›®ã®è¦å‰‡ã«ãƒãƒƒãƒã—ã€(ã“ã®è¦å‰‡ã«ãŠã‘ã‚‹) ?x ãŒ 3 ã«æŸç¸›ã•ã‚Œã‚‹ã€‚
    ãã—ã¦ã€F2ã«ãŠã‘ã‚‹ ?reversed-cdr ãŒ (3) ã«æŸç¸›ã•ã‚Œã‚‹ã€‚
(d) æ¬¡ã¯ã€and ç¯€ã®2ç•ªç›®ã®ã‚¯ã‚¨ãƒªã«ã¤ã„ã¦ã®ã€F2 ã§ã®ãƒ¦ãƒ‹ãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã€‚
     ã¤ã¾ã‚Šã€(append-to-form (3) (2) ?reversed-list) ã®ãƒ¦ãƒ‹ãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’è¡Œã†ã€‚
     append-to-form å†…éƒ¨ã®é€”ä¸­çµŒéã¯çœç•¥ã™ã‚‹ã¨ã€ã“ã‚Œã«ã‚ˆã‚Šã€?reversed-list ãŒ
     (3 2) ã«æŸç¸›ã•ã‚Œã‚‹ã€‚
(e) ã‚ˆã£ã¦ã€(and (reverse (3) (3)) (append-to-form (3) (2) (3 2))) ã ã‹ã‚‰ã€
     F2 ã«ãŠã„ã¦ (reverse (2 3) (3 2)) ã¨ã„ã†çµæœãŒå¾—ã‚‰ã‚Œã‚‹ã€‚
(f) ã¾ãŸã€F2 ã® ?reversed-list ã¯ F1 ã§ã® ?reversed-cdr ã«æŸç¸›ã•ã‚Œã¦ã„ã‚‹ã‹ã‚‰ã€
    æ¬¡ã¯ã€F1 ã§ã® (append-to-form (3 2) (1) ?reversed-list) ã®ãƒ¦ãƒ‹ãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã€‚
    append-to-form å†…éƒ¨ã®é€”ä¸­çµŒéã¯çœç•¥ã™ã‚‹ã¨ã€ã“ã‚Œã«ã‚ˆã‚Šã€?reversed-list ãŒ
    (3 2 1) ã«æŸç¸›ã•ã‚Œã‚‹ã€‚
(g) ã™ã§ã« (a) ã§è¿°ã¹ãŸã‚ˆã†ã«ã€F1 ã«ãŠã„ã¦ã¯ ?reversed-list ãŒ ?x ã«æŸç¸›ã•ã‚Œã¦
    ã„ã‚‹ã‹ã‚‰ã€ã¤ã¾ã‚Šã¯ (reverse (1 2 3) ?x) ã® ?x ã¯ (3 2 1) ã ã¨ã„ã†ã“ã¨ã€‚
    ã¡ã‚ƒã‚“ã¨è§£ã‘ãŸã€‚

(h) ã§ã¯é€†ã«ã€(reverse ?x (1 2 3)) ã¨ã„ã†ã‚¯ã‚¨ãƒªã ã£ãŸã‚‰ã©ã†ãªã‚‹ã‹ã€‚
    ã“ã‚Œã¯3ç•ªç›®ã®è¦å‰‡ã«ãƒãƒƒãƒã™ã‚‹ã€‚ãã—ã¦ã€ã€Œ(?given-car . ?given-cdr) ã¨ã„ã†
    å¯¾ãŒ ?x ã«æŸç¸›ã•ã‚Œã€?reversed-list ãŒ (1 2 3) ã«æŸç¸›ã•ã‚ŒãŸãƒ•ãƒ¬ãƒ¼ãƒ ã€
    (G1 ã¨ã™ã‚‹) ãŒã§ãã‚‹ã€‚
(i) æ¬¡ã¯ G1 ã§ã®ãƒ¦ãƒ‹ãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã ãŒã€
    â€¦â€¦ã¨ã€ã“ã“ã§æ€ã£ãŸãŒã€2ç•ªç›®ã®è¦å‰‡ãŒã‚ã‚‹ã¨ç„¡é™ãƒ«ãƒ¼ãƒ—è¡Œãã‹ã‚‚ã—ã‚Œãªã„ã€‚
    ã¡ã‚ƒã‚“ã¨è€ƒãˆãªã„ã¨åˆ†ã‹ã‚‰ãªã„ãŒã€ãªã‚“ã‹å±é™ºãªæ°—ãŒã™ã‚‹ãªã€‚
</span></p>

<p class="orig" lang="en">
<a name="%_thm_4.69"></a>
<b>Exercise 4.69.</b>  Beginning with the data base and the rules you formulated in
exercise <a href="#%_thm_4.63">4.63</a>, devise a rule for adding ``greats'' to
a grandson relationship. This should enable the system to deduce that
Irad is the great-grandson of Adam, or that Jabal and Jubal are
the great-great-great-great-great-grandsons of Adam.  (Hint: Represent
the fact about Irad, for example, as <tt>((great grandson) Adam
Irad)</tt>.  Write rules that determine if a list ends in the word
<tt>grandson</tt>.  Use this to express a rule that allows one to derive
the relationship <tt>((great .  ?rel) ?x ?y)</tt>, where <tt>?rel</tt> is a
list ending in <tt>grandson</tt>.)
Check your rules on queries such as
<tt>((great grandson) ?g ?ggs)</tt> and <tt>(?relationship Adam Irad)</tt>.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.69.</b> ç·´ç¿’å•é¡Œ<a href="#%_thm_4.63">4.63</a>ã§å›ãŒå®šå¼åŒ–ã—ãŸãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã¨è¦å‰‡ã‹ã‚‰å§‹ã‚ã¦ã€å­«æ¯å­é–¢ä¿‚ã«<!-- ã€Œ<ruby><rb>æ›¾</rb><rp> (</rp><rt>ã²</rt><rp>) </rp></ruby>ã€ -->ã€Œä¸€ä¸–ä»£é›¢ã‚ŒãŸ (great-)ã€ã‚’ä»˜ã‘åŠ ãˆã‚‹ãŸã‚ã®è¦å‰‡ã‚’ã€è€ƒæ¡ˆã›ã‚ˆã€‚
ã“ã‚Œã«ã‚ˆã£ã¦ã€ã‚·ã‚¹ãƒ†ãƒ ãŒã€ã‚¤ãƒ©ãƒ‡ã¯ã‚¢ãƒ€ãƒ ã®æ›¾å­«ã§ã‚ã‚‹ã€ã¨ã‹ã€ã‚ã‚‹ã„ã¯ã€ãƒ¤ãƒãƒ«ã¨ãƒ¦ãƒãƒ«ã¯ã‚¢ãƒ€ãƒ ã®<ruby><rb>ä»å­«</rb><rp> (</rp><rt>ã˜ã‚‡ã†ãã‚“</rt><rp>) </rp></ruby>ã§ã‚ã‚‹ã€ã¨æ¼”ç¹¹ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã‚ˆã†ã«ãªã‚‹ã¯ãšã 
(ãƒ’ãƒ³ãƒˆ: ãŸã¨ãˆã°ã‚¤ãƒ©ãƒ‡ã«ã¤ã„ã¦ã®äº‹å®Ÿã‚’ã€<tt>((great grandson) Adam Irad)</tt> ã¨è¡¨ç¾ã›ã‚ˆã€‚<tt>grandson</tt> ã¨ã„ã†èªã§ãƒªã‚¹ãƒˆãŒçµ‚ã‚ã£ã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’åˆ¤å®šã™ã‚‹è¦å‰‡ã‚’æ›¸ã‘ã€‚ã“ã‚Œã‚’ç”¨ã„ã¦ã€<tt>((great .  ?rel) ?x ?y)</tt> ã¨ã„ã†é–¢ä¿‚ã‚’å°å‡ºã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹è¦å‰‡ã‚’è¡¨ã›ã€‚ãªãŠã“ã“ã§ã€<tt>?rel</tt> ã¯ <tt>grandson</tt> ã§çµ‚ã‚ã‚‹ãƒªã‚¹ãƒˆã§ã‚ã‚‹)ã€‚
<tt>((great grandson) ?g ?ggs)</tt> ã‚„ <tt>(?relationship Adam Irad)</tt> ã®ã‚ˆã†ãªã‚¯ã‚¨ãƒªã«å¯¾ã—ã¦ã€å›ã®è¦å‰‡ã‚’ç¢ºèªã›ã‚ˆã€‚
</p>

<p class="exercise">

<span class="inline-aa">
ã€€ã€€ã€€ã€€ã€€å­ã€€ã€€ã€€å­«ã€€ã€€æ›¾å­«ã€€ã€€ã€€ç„å­«ã€€ã€€ã€€ã€€æ¥å­«ã€€ã€€ã€€æ˜†å­«ã€€ã€€<ruby><rb>ä»å­«</rb><rp> (</rp><rt>ã˜ã‚‡ã†ãã‚“</rt><rp>) </rp></ruby>

ã‚¢ãƒ€ãƒ â”€ã‚«ã‚¤ãƒ³â”€ã‚¨ãƒã‚¯â”€ã‚¤ãƒ©ãƒ‡â”€ãƒ¡ãƒ›ãƒ¤ã‚¨ãƒ«â”€ãƒ¡ãƒˆã‚µã‚¨ãƒ«â”€ãƒ¬ãƒ¡ã‚¯
ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€â”œâ”€â”¬ãƒ¤ãƒãƒ«
ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã‚¢ãƒ€ã€€â””ãƒ¦ãƒãƒ«

</span>

<span class="ex_comment">
</span></p>

<a name="%_sec_4.4.4"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_4.4.4">4.4.4  Implementing the Query System</a></h3>
<h3 class="trans" lang="ja">4.4.4 ã‚¯ã‚¨ãƒªãƒ»ã‚·ã‚¹ãƒ†ãƒ ã‚’å®Ÿè£…ã™ã‚‹</h3>

<p class="orig" lang="en">Section <a href="#%_sec_4.4.2">4.4.2</a> described how the query system
works. Now we fill in the details by presenting a complete
implementation of the system.</p>

<p class="trans" lang="ja">
<a href="#%_sec_4.4.2">4.4.2</a>ç¯€ã§ã¯ã€ã‚¯ã‚¨ãƒªãƒ»ã‚·ã‚¹ãƒ†ãƒ ãŒã©ã†å‹•ãã®ã‹ã‚’èª¬æ˜ã—ãŸã€‚
ä»Šã‚„ã€ç§ãŸã¡ã¯ã€ã‚·ã‚¹ãƒ†ãƒ ã®å®Œå…¨ãªå®Ÿè£…ã‚’æç¤ºã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€è©³ç´°ã‚’åŸ‹ã‚ã‚‹ã€‚
</p>

<a name="%_sec_4.4.4.1"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_4.4.4.1">4.4.4.1  The Driver Loop and Instantiation</a></h4>
<h4 class="trans" lang="ja">4.4.4.1 ãƒ‰ãƒ©ã‚¤ãƒãƒ»ãƒ«ãƒ¼ãƒ—ã¨ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–</h4>


<p class="orig" lang="en">
<a name="%_idx_5288"></a><a name="%_idx_5290"></a>The driver loop for the query system repeatedly reads input
expressions.  If the expression is a rule or assertion to be added to
the data base, then the information is added.  Otherwise the
expression is assumed to be a query.  The driver passes this query to
the evaluator <tt>qeval</tt> together with an initial frame stream
consisting of a single empty frame.  The result of the evaluation is a
stream of frames generated by satisfying the query with variable
values found in the data base.  These frames are used to form a new
stream consisting of copies of the original query in which the
variables are instantiated with values supplied by the stream of
frames, and this final stream is printed at the terminal:</p>

<p class="trans" lang="ja">
ã‚¯ã‚¨ãƒªãƒ»ã‚·ã‚¹ãƒ†ãƒ ã®ãŸã‚ã®ãƒ‰ãƒ©ã‚¤ãƒãƒ»ãƒ«ãƒ¼ãƒ—ã¯ã€ç¹°ã‚Šè¿”ã—ã€å…¥åŠ›ã•ã‚ŒãŸå¼ã‚’èª­ã‚€ã€‚
ã‚‚ã—å¼ãŒã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«è¿½åŠ ã™ã¹ãè¦å‰‡ã‹è¨€æ˜ã ã£ãŸã‚‰ã€ãã®æƒ…å ±ãŒè¿½åŠ ã•ã‚Œã‚‹ã€‚
ãã‚Œä»¥å¤–ã®å ´åˆã€ãã®å¼ã¯ã€ã‚¯ã‚¨ãƒªã ã¨æƒ³å®šã•ã‚Œã‚‹ã€‚
ãƒ‰ãƒ©ã‚¤ãƒã¯ã€ã“ã®ã‚¯ã‚¨ãƒªã‚’ã€å˜ä¸€ã®ç©ºãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰ãªã‚‹åˆæœŸãƒ•ãƒ¬ãƒ¼ãƒ ãƒ»ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¨ä¸€ç·’ã«ã€<tt>qeval</tt> ã¨ã„ã†è©•ä¾¡å™¨ã¸ã¨æ¸¡ã™ã€‚
è©•ä¾¡ã®çµæœã¯ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å†…ã§è¦‹ã¤ã‹ã£ãŸå¤‰æ•°å€¤ã§ã‚¯ã‚¨ãƒªã‚’æº€ãŸã™ã“ã¨ã«ã‚ˆã‚Šç”Ÿæˆã•ã‚Œã‚‹ã€ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã§ã‚ã‚‹ã€‚
ã“ã‚Œã‚‰ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã¯ã€ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«ã‚ˆã‚Šä¸ãˆã‚‰ã‚Œã‚‹å€¤ã§å¤‰æ•°ãŒã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã•ã‚ŒãŸçŠ¶æ…‹ã®å…ƒã®ã‚¯ã‚¨ãƒªã®è¤‡è£½ã‹ã‚‰ãªã‚‹ã€æ–°ãŸãªã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å½¢æˆã™ã‚‹ã®ã«ä½¿ã‚ã‚Œã‚‹ã€‚ãã—ã¦ã€ã“ã®æœ€çµ‚çš„ãªã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒã€ç«¯æœ«ã«å°å­—ã•ã‚Œã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_5292"></a>(define input-prompt &quot;;;; Query input:&quot;)
(define output-prompt &quot;;;; Query results:&quot;)
<a name="%_idx_5294"></a>(define (query-driver-loop)
  (prompt-for-input input-prompt)
  (let ((q (query-syntax-process (read))))
    (cond ((assertion-to-be-added? q)
           (add-rule-or-assertion! (add-assertion-body q))
           (newline)
           (display &quot;Assertion added to data base.&quot;)
           (query-driver-loop))
          (else
           (newline)
           (display output-prompt)
           (display-stream
            (stream-map
             (lambda (frame)
               (instantiate q
                            frame
                            (lambda (v f)
                              (contract-question-mark v))))
             (qeval q (singleton-stream '()))))
           (query-driver-loop)))))
</p>

<p class="orig" lang="en"><a name="%_idx_5296"></a>Here, as in the other evaluators in this chapter, we use an abstract
syntax for the expressions of the query language.
The implementation of the expression syntax, including the predicate
<tt>assertion-to-be-added?</tt> and the selector <tt>add-assertion-body</tt>,
is given in section <a href="#%_sec_4.4.4.7">4.4.4.7</a>.
<tt>Add-rule-or-assertion!</tt> is defined in section <a href="#%_sec_4.4.4.5">4.4.4.5</a>.</p>

<p class="trans" lang="ja">
ã“ã“ã§ã€æœ¬ç« ã®ä»–ã®è©•ä¾¡å™¨ã«ãŠã‘ã‚‹ã®ã¨åŒæ§˜ã«ã€ã‚¯ã‚¨ãƒªè¨€èªã®å¼ã®ãŸã‚ã®æŠ½è±¡çš„<ruby><rb>æ–‡æ³•</rb><rp> (</rp><rt>ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹</rt><rp>) </rp></ruby>ã‚’ä½¿ã†ã€‚
å¼ã®æ–‡æ³•ã®å®Ÿè£…â€”â€” <tt>assertion-to-be-added?</tt> ã¨ã„ã†è¿°èªã¨ <tt>add-assertion-body</tt> ã¨ã„ã†ã‚»ãƒ¬ã‚¯ã‚¿ã‚’å«ã‚€â€”â€”ã¯ã€<a href="#%_sec_4.4.4.7">4.4.4.7</a>ç¯€ã§ä¸ãˆã‚‰ã‚Œã‚‹ã€‚
<tt>add-rule-or-assertion!</tt> ã¯<a href="#%_sec_4.4.4.5">4.4.4.5</a>ç¯€ã§å®šç¾©ã•ã‚Œã‚‹ã€‚
</p>

<p class="orig" lang="en">
Before doing any processing on an input expression, the driver loop
transforms it syntactically into a form that makes the processing more
efficient.  This involves changing the <a name="%_idx_5298"></a><a name="%_idx_5300"></a>representation of pattern
variables.  When the query is instantiated, any variables that remain
unbound are transformed back to the input representation before being
printed.  These transformations are performed by the two procedures
<tt>query-syntax-process</tt> and <tt>contract-question-mark</tt>
(section  <a href="#%_sec_4.4.4.7">4.4.4.7</a>).</p>

<p class="trans" lang="ja">
å…¥åŠ›ã•ã‚ŒãŸå¼ã«å¯¾ã—ã¦ä½•ã‹å‡¦ç†ã‚’è¡Œã†å‰ã«ã€ãƒ‰ãƒ©ã‚¤ãƒãƒ»ãƒ«ãƒ¼ãƒ—ã¯ã€ãã®å¼ã‚’ã€å‡¦ç†ã‚’ã‚ˆã‚ŠåŠ¹ç‡çš„ã«ã™ã‚‹å½¢å¼ã¸ã¨ã€æ–‡æ³•çš„ã«å¤‰å½¢ã™ã‚‹ã€‚
ã“ã‚Œã¯ã€ãƒ‘ã‚¿ãƒ³å¤‰æ•°ã®è¡¨ç¾ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ã‚’å«ã‚€ã€‚
ã‚¯ã‚¨ãƒªãŒã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã•ã‚Œã‚‹ã¨ãã€æŸç¸›ã•ã‚Œã¦ã„ãªã„ã¾ã¾ã§æ®‹ã£ã¦ã„ã‚‹ã©ã®å¤‰æ•°ã‚‚ã€å°å­—ã•ã‚Œã‚‹å‰ã«ã¯ã€å¤‰å½¢ã•ã‚Œã¦ã€å…¥åŠ›ã•ã‚ŒãŸè¡¨ç¾ã¸ã¨æˆ»ã•ã‚Œã‚‹ã€‚
ã“ã‚Œã‚‰ã®å¤‰å½¢ã¯ã€<tt>query-syntax-process</tt> ã¨ <tt>contract-question-mark</tt> ã¨ã„ã†äºŒã¤ã®æ‰‹ç¶šãã«ã‚ˆã‚Šå®Ÿè¡Œã•ã‚Œã‚‹ (<a href="#%_sec_4.4.4.7">4.4.4.7</a>ç¯€)ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_5302"></a>To instantiate an expression, we copy it, replacing any variables in
the expression by their values in a given frame.  The values are
themselves instantiated, since they could contain variables (for
example, if <tt>?x</tt> in <tt>exp</tt> is bound to <tt>?y</tt> as the result
of unification and <tt>?y</tt> is in turn bound to 5).  The action to
take if a variable cannot be instantiated is given by a procedural
argument to <tt>instantiate</tt>.</p>

<p class="trans" lang="ja">
å¼ã‚’ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã™ã‚‹ã«ã¯ã€ãã®å¼ã‚’ã‚³ãƒ”ãƒ¼ã—ã€ãã®éš›ã€ãã®å¼ã®ä¸­ã®ã©ã®å¤‰æ•°ã‚‚ã€ä¸ãˆã‚‰ã‚ŒãŸãƒ•ãƒ¬ãƒ¼ãƒ å†…ã§ã®å½“è©²å¤‰æ•°ã®å€¤ã«ç½®æ›ã™ã‚‹ã€‚
å€¤ã¯ã€ãã‚Œè‡ªä½“ãŒã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã•ã‚Œ<!--ã¦ã„-->ã‚‹ã€‚ã¨ã„ã†ã®ã‚‚ã€ãã‚Œã‚‰ã®å€¤ã¯ã€å¤‰æ•°ã‚’å«ã¿å¾—ã‚‹ã‹ã‚‰ã  (ãŸã¨ãˆã°ã€<tt>exp</tt> ã®ä¸­ã® <tt>?x</tt> ãŒãƒ¦ãƒ‹ãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®çµæœã¨ã—ã¦ <tt>?y</tt> ã«æŸç¸›ã•ã‚Œã¦ãŠã‚Šã€ãã—ã¦ä»Šåº¦ã¯ <tt>?y</tt> ãŒ 5 ã«æŸç¸›ã•ã‚Œã¦ã„ã‚‹å ´åˆãªã©ã«)ã€‚
å¤‰æ•°ã‚’ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã§ããªã‹ã£ãŸã‚‰<!-- å–ã‚‹ã¹ãè¡Œå‹• -->è¡Œã†ã¹ãå‹•ä½œã¯ã€<tt>instantiate</tt> ã«å¯¾ã™ã‚‹æ‰‹ç¶šãçš„å¼•æ•°ã«ã‚ˆã‚Šã€æç¤ºã•ã‚Œã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_5304"></a>(define (instantiate exp frame unbound-var-handler)
  (define (copy exp)
    (cond ((var? exp)
           (let ((binding (binding-in-frame exp frame)))
             (if binding
                 (copy (binding-value binding))
                 (unbound-var-handler exp frame))))
          ((pair? exp)
           (cons (copy (car exp)) (copy (cdr exp))))
          (else exp)))
  (copy exp))
</p>

<p class="orig" lang="en">The procedures that manipulate bindings are defined in
section <a href="#%_sec_4.4.4.8">4.4.4.8</a>.
</p>

<p class="trans" lang="ja">
æŸç¸›ã‚’æ“ä½œã™ã‚‹æ‰‹ç¶šãã¯ã€<a href="#%_sec_4.4.4.8">4.4.4.8</a>ç¯€ã§å®šç¾©ã•ã‚Œã‚‹ã€‚
</p>


<a name="%_sec_4.4.4.2"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_4.4.4.2">4.4.4.2  The Evaluator</a></h4>
<h4 class="trans" lang="ja">4.4.4.2 è©•ä¾¡å™¨</h4>

<p class="orig" lang="en">
<a name="%_idx_5306"></a>The <tt>qeval</tt> procedure, called by the <tt>query-driver-loop</tt>, is
the basic evaluator of the query system.  It takes as inputs a query
and a stream of frames, and it returns a stream of extended frames.
It identifies special forms by a <a name="%_idx_5308"></a>data-directed dispatch using <tt>get</tt> and <tt>put</tt>, just as we did in implementing generic operations
in chapter 2.  Any query that is not identified as a special form is
assumed to be a simple query, to be processed by <tt>simple-query</tt>.</p>

<p class="trans" lang="ja">
<tt>qeval</tt> æ‰‹ç¶šãâ€”â€” <tt>query-driver-loop</tt> ã«ã‚ˆã‚Šå‘¼ã³å‡ºã•ã‚Œã‚‹â€”â€”ã¯ã€ã‚¯ã‚¨ãƒªãƒ»ã‚·ã‚¹ãƒ†ãƒ ã®åŸºæœ¬çš„è©•ä¾¡å™¨ã§ã‚ã‚‹ã€‚
ã“ã‚Œã¯ã€ã‚¯ã‚¨ãƒªã¨ã€ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¨ã‚’ã€å…¥åŠ›ã¨ã—ã¦ã¨ã‚Šã€æ‹¡å¼µã—ãŸãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’è¿”ã™ã€‚
ã“ã‚Œã¯ã€2ç« ã§ç·ç§°çš„æ¼”ç®—ã‚’å®Ÿè£…ã™ã‚‹éš›ã«è¡Œã£ãŸã®ã¨ã¡ã‚‡ã†ã©åŒæ§˜ã«ã€<tt>get</tt> ã¨ <tt>put</tt> ã‚’ç”¨ã„ãŸãƒ‡ãƒ¼ã‚¿æŒ‡å‘ã®<ruby><rb>å‰²ã‚ŠæŒ¯ã‚Š</rb><rp> (</rp><rt>ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒ</rt><rp>) </rp></ruby>ã«ã‚ˆã‚Šã€ç‰¹æ®Šå½¢å¼ã‚’è­˜åˆ¥ã™ã‚‹ã€‚
ç‰¹æ®Šå½¢å¼ã¨ã—ã¦è­˜åˆ¥ã•ã‚Œãªã„ã‚¯ã‚¨ãƒªã¯ã©ã‚Œã‚‚ã€<tt>simple-query</tt> ã«ã‚ˆã‚Šå‡¦ç†ã•ã‚Œã‚‹ã¹ãå˜ç´”ã‚¯ã‚¨ãƒªã§ã‚ã‚‹ã€ã¨æƒ³å®šã•ã‚Œã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_5310"></a>(define (qeval query frame-stream)
  (let ((qproc (get (type query) 'qeval)))
    (if qproc
        (qproc (contents query) frame-stream)
        (simple-query query frame-stream))))
</p>

<p class="orig" lang="en"><tt>Type</tt> and <tt>contents</tt>, defined in section <a href="#%_sec_4.4.4.7">4.4.4.7</a>,
implement the abstract syntax of the special forms.</p>

<p class="trans" lang="ja">
<a href="#%_sec_4.4.4.7">4.4.4.7</a>ç¯€ã§å®šç¾©ã—ãŸã€<tt>type</tt> ã¨ <tt>contents</tt> ãŒã€ç‰¹æ®Šå½¢å¼ã®æŠ½è±¡çš„ãªæ§‹æ–‡ã‚’å®Ÿè£…ã™ã‚‹ã€‚
</p>

<a name="%_sec_Temp_696"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_696">Simple queries</a></h4>
<h4 class="trans" lang="ja">å˜ç´”ã‚¯ã‚¨ãƒª</h4>

<p class="orig" lang="en">
<a name="%_idx_5312"></a>
The <tt>simple-query</tt> procedure handles simple queries.  It takes as
arguments a simple query (a pattern) together with a stream of frames,
and it returns the stream formed by extending each frame by all
data-base matches of the query.</p>

<p class="trans" lang="ja">
<tt>simple-query</tt> æ‰‹ç¶šãã¯ã€å˜ç´”ã‚¯ã‚¨ãƒªã‚’å–ã‚Šæ‰±ã†ã€‚
ã“ã‚Œã¯ã€å˜ç´”ã‚¯ã‚¨ãƒª (ãƒ‘ã‚¿ãƒ³) ã‚’ã€ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¨ã¨ã‚‚ã«å¼•æ•°ã¨ã—ã¦å–ã‚Šã€ãã®ã‚¯ã‚¨ãƒªã®ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ä¸Šã§ã®ã™ã¹ã¦ã®ãƒãƒƒãƒã«ã‚ˆã£ã¦ã€å„ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’æ‹¡å¼µã™ã‚‹ã“ã¨ã§å½¢æˆã•ã‚Œã‚‹ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’è¿”ã™ã€‚
</p>

<p class="lisp"><a name="%_idx_5314"></a>(define (simple-query query-pattern frame-stream)
  (stream-flatmap
   (lambda (frame)
     (stream-append-delayed
      (find-assertions query-pattern frame)
      (delay (apply-rules query-pattern frame))))
   frame-stream))
</p>

<p class="orig" lang="en">
For each frame in the input stream, we use <tt>find-assertions</tt>
(section <a href="#%_sec_4.4.4.3">4.4.4.3</a>) to match the pattern against all
assertions in the data base, producing a stream of extended frames,
and we use <tt>apply-rules</tt> (section <a href="#%_sec_4.4.4.4">4.4.4.4</a>) to apply
all possible rules, producing another stream of extended frames.
These two streams are combined (using <tt>stream-append-delayed</tt>,
section <a href="#%_sec_4.4.4.6">4.4.4.6</a>) to make a stream of all the ways that
the given pattern can be satisfied consistent with the original frame
(see exercise <a href="#%_thm_4.71">4.71</a>).  The streams for the
individual input frames are combined using <tt>stream-flatmap</tt>
(section <a href="#%_sec_4.4.4.6">4.4.4.6</a>) to form one large stream of all the
ways that any of the frames in the original input stream can be
extended to produce a match with the given pattern.</p>

<p class="trans" lang="ja">
å…¥åŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ å†…ã®å„ãƒ•ãƒ¬ãƒ¼ãƒ ã«ã¤ã„ã¦ã€<tt>find-assertions</tt> (<a href="#%_sec_4.4.4.3">4.4.4.3</a>ç¯€) ã‚’ä½¿ã£ã¦ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å†…ã®ã™ã¹ã¦ã®è¨€æ˜ã«å¯¾ã—ã¦å½“è©²ãƒ‘ã‚¿ãƒ³ã‚’ãƒãƒƒãƒã•ã›ã€æ‹¡å¼µã—ãŸãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½œã‚Šå‡ºã™ã¨ã¨ã‚‚ã«ã€<tt>apply-rules</tt> (<a href="#%_sec_4.4.4.4">4.4.4.4</a>ç¯€) ã‚’ä½¿ã£ã¦ã€ã™ã¹ã¦ã®ã‚ã‚Šå¾—ã‚‹è¦å‰‡ã‚’é©ç”¨ã—ã¦ã€æ‹¡å¼µã—ãŸãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚‚ã†ä¸€ã¤åˆ¥ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½œã‚Šå‡ºã™ã€‚
ã“ã‚Œã‚‰äºŒã¤ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ (<a href="#%_sec_4.4.4.6">4.4.4.6</a>ç¯€ã® <tt>stream-append-delayed</tt> ã‚’ç”¨ã„ã¦) çµåˆã—ã¦ã€å…ƒã®ãƒ•ãƒ¬ãƒ¼ãƒ ã¨æ•´åˆæ€§ã‚’ä¿ã¡ã¤ã¤æ‰€ä¸ã®ãƒ‘ã‚¿ãƒ³ã‚’æº€ãŸã›ã‚‹ã‚ˆã†ãªã™ã¹ã¦ã®æ–¹æ³•ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½œã‚‹ (ç·´ç¿’å•é¡Œ<a href="#%_thm_4.71">4.71</a>ã‚’å‚ç…§)ã€‚
<!-- å…ƒã®å…¥åŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ å†…ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã„ãšã‚Œã‹ã‚’ã€æ‰€ä¸ã®ãƒ‘ã‚¿ãƒ³ã¨ã®ãƒãƒƒãƒã‚’ä½œã‚Šå‡ºã™ã‚ˆã†ã«æ‹¡å¼µã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã‚ˆã†ãªã€ã™ã¹ã¦ã®æ–¹æ³•ã‹ã‚‰ãªã‚‹ä¸€ã¤ã®å¤§ããªã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å½¢æˆã™ã‚‹ã‚ˆã†ã«ã€å€‹ã€…ã®å…¥åŠ›ãƒ•ãƒ¬ãƒ¼ãƒ ã«å¯¾ã™ã‚‹ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ã€<tt>stream-flatmap</tt> (<a href="#%_sec_4.4.4.6">4.4.4.6</a>ç¯€) ã‚’ç”¨ã„ã¦çµåˆã™ã‚‹ã€‚ -->
å€‹ã€…ã®å…¥åŠ›ãƒ•ãƒ¬ãƒ¼ãƒ ã«å¯¾ã™ã‚‹ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ã€<tt>stream-flatmap</tt> (<a href="#%_sec_4.4.4.6">4.4.4.6</a>ç¯€) ã‚’ç”¨ã„ã¦çµåˆã—ã€æ‰€ä¸ã®ãƒ‘ã‚¿ãƒ³ã¨ã®ãƒãƒƒãƒã‚’ä½œã‚Šå‡ºã™ã‚ˆã†ã«å…ƒã®å…¥åŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ å†…ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã„ãšã‚Œã‹ã‚’æ‹¡å¼µã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã‚ˆã†ãªã™ã¹ã¦ã®æ–¹æ³•ã‹ã‚‰ãªã‚‹ã€ä¸€ã¤ã®å¤§ããªã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å½¢æˆã™ã‚‹ã€‚
</p>

<a name="%_sec_Temp_697"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_697">Compound queries</a></h4>
<h4 class="trans" lang="ja">è¤‡åˆã‚¯ã‚¨ãƒª</h4>

<p class="orig" lang="en">
<a name="%_idx_5316"></a>
<a name="%_idx_5318"></a><tt>And</tt> queries are handled as illustrated in
figure <a href="#%_fig_4.5">4.5</a> by the <tt>conjoin</tt> procedure.  <tt>Conjoin</tt> takes as inputs the conjuncts and the frame stream and
returns the stream of extended frames.  First, <tt>conjoin</tt> processes
the stream of frames to find the stream of all possible frame extensions
that satisfy the first query in the conjunction.  Then, using this as the new
frame stream, it recursively applies <tt>conjoin</tt> to the rest of the
queries.</p>

<p class="trans" lang="ja">
<tt>and</tt> ã‚¯ã‚¨ãƒªã¯ã€å›³<a href="#%_fig_4.5">4.5</a>ã«ç¤ºã•ã‚Œã¦ã„ã‚‹ã¨ãŠã‚Šã€<tt>conjoin</tt> æ‰‹ç¶šãã«ã‚ˆã‚Šå–ã‚Šæ‰±ã‚ã‚Œã‚‹ã€‚
<tt>conjoin</tt> ã¯ã€é€£è¨€è‚¢ã¨ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ»ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¨ã‚’å…¥åŠ›ã¨ã—ã¦å–ã‚Šã€æ‹¡å¼µã—ãŸãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’è¿”ã™ã€‚
<!-- ã¾ãšã€<tt>conjoin</tt> ã¯ã€é€£è¨€ã®ä¸­ã§æœ€åˆã®ã‚¯ã‚¨ãƒªã‚’æº€ãŸã™ã‚ˆã†ãªã€ã™ã¹ã¦ã®ã‚ã‚Šå¾—ã‚‹ãƒ•ãƒ¬ãƒ¼ãƒ æ‹¡å¼µã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’è¦‹ã¤ã‘ã‚‹ãŸã‚ã«ã€ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å‡¦ç†ã™ã‚‹ã€‚
 -->
ã¾ãšã€<tt>conjoin</tt> ã¯ã€ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å‡¦ç†ã—ã¦ã€é€£è¨€ã®ä¸­ã§æœ€åˆã®ã‚¯ã‚¨ãƒªã‚’æº€ãŸã™ã‚ˆã†ãªã™ã¹ã¦ã®ã‚ã‚Šå¾—ã‚‹ãƒ•ãƒ¬ãƒ¼ãƒ æ‹¡å¼µã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’è¦‹ã¤ã‘ã‚‹ã€‚
ãã‚Œã‹ã‚‰ã€ã“ã‚Œ<span class="note"> (ã“ã®è¦‹ã¤ã‘ãŸã‚¹ãƒˆãƒªãƒ¼ãƒ ) </span>ã‚’æ–°ãŸãªãƒ•ãƒ¬ãƒ¼ãƒ ãƒ»ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¨ã—ã¦ç”¨ã„ã¦ã€<tt>conjoin</tt> ã¯ã€ã‚¯ã‚¨ãƒªã®æ®‹ã‚Šã®éƒ¨åˆ†ã« <tt>conjoin</tt> ã‚’å†å¸°çš„ã«é©ç”¨ã™ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_5320"></a>(define (conjoin conjuncts frame-stream)
  (if (empty-conjunction? conjuncts)
      frame-stream
      (conjoin (rest-conjuncts conjuncts)
               (qeval (first-conjunct conjuncts)
                      frame-stream))))
</p>

<p class="orig" lang="en">The expression
</p>

<p class="trans" lang="ja">
æ¬¡ã®å¼ã¯ã€
</p>

<p class="lisp">(put 'and 'qeval conjoin)
</p>

<p class="orig" lang="en">sets up <tt>qeval</tt> to dispatch to <tt>conjoin</tt> when an <tt>and</tt>
form is encountered.</p>

<p class="trans" lang="ja">
<tt>and</tt> å½¢å¼ã«é­é‡ã—ãŸã¨ãã« <tt>conjoin</tt> ã¸ã¨<ruby><rb>æŒ¯ã‚Šåˆ†ã‘</rb><rp> (</rp><rt>ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒ</rt><rp>) </rp></ruby>ã‚’è¡Œã†ã‚ˆã†ã«ã€<tt>qeval</tt> ã‚’è¨­å®šã™ã‚‹ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_5322"></a><tt>Or</tt> queries are handled similarly, as shown in
figure <a href="#%_fig_4.6">4.6</a>.  The output streams for the various
disjuncts of the <tt>or</tt> are computed separately and merged using the
<tt>interleave-delayed</tt> procedure from section <a href="#%_sec_4.4.4.6">4.4.4.6</a>.
(See exercises <a href="#%_thm_4.71">4.71</a> and <a href="#%_thm_4.72">4.72</a>.)</p>

<p class="trans" lang="ja">
<tt>or</tt> ã‚¯ã‚¨ãƒªã‚‚åŒæ§˜ã«ã€å›³<a href="#%_fig_4.6">4.6</a>ã«ç¤ºã™ã‚ˆã†ã«å–ã‚Šæ‰±ã‚ã‚Œã‚‹ã€‚
<tt>or</tt> ã®æ§˜ã€…ãªé¸è¨€è‚¢ã«å¯¾ã™ã‚‹å‡ºåŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ã€åˆ¥ã€…ã«è¨ˆç®—ã—ã€<a href="#%_sec_4.4.4.6">4.4.4.6</a>ç¯€ã® <tt>interleave-delayed</tt> æ‰‹ç¶šãã‚’ç”¨ã„ã¦åˆä½µã™ã‚‹ (ç·´ç¿’å•é¡Œ<a href="#%_thm_4.71">4.71</a>ã¨ç·´ç¿’å•é¡Œ<a href="#%_thm_4.72">4.72</a>ã‚’å‚ç…§)ã€‚
</p>

<p class="lisp"><a name="%_idx_5324"></a>(define (disjoin disjuncts frame-stream)
  (if (empty-disjunction? disjuncts)
      the-empty-stream
      (interleave-delayed
       (qeval (first-disjunct disjuncts) frame-stream)
       (delay (disjoin (rest-disjuncts disjuncts)
                       frame-stream)))))
(put 'or 'qeval disjoin)
</p>

<p class="orig" lang="en">The predicates and selectors for the syntax of conjuncts and disjuncts
are given in section <a href="#%_sec_4.4.4.7">4.4.4.7</a>.</p>

<p class="trans" lang="ja">
é€£è¨€è‚¢ã‚„é¸è¨€è‚¢ã®æ§‹æ–‡ã«ã¤ã„ã¦ã®ã€è¿°èªã‚„ã‚»ãƒ¬ã‚¯ã‚¿ã¯ã€<a href="#%_sec_4.4.4.7">4.4.4.7</a>ç¯€ã§ä¸ãˆã‚‰ã‚Œã‚‹ã€‚
</p>

<a name="%_sec_Temp_698"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_698">Filters</a></h4>
<h4 class="trans" lang="ja">ãƒ•ã‚£ãƒ«ã‚¿</h4>

<p class="orig" lang="en">
<a name="%_idx_5326"></a><tt>Not</tt> is handled by the method outlined in
section <a href="#%_sec_4.4.2">4.4.2</a>.  We attempt to extend each frame in
the input stream to satisfy the query being negated, and we include a
given frame in the output stream only if it cannot be extended.</p>

<p class="trans" lang="ja">
<tt>not</tt> ã¯ã€<a href="#%_sec_4.4.2">4.4.2</a>ç¯€ã§æ¦‚è¦ã‚’è¿°ã¹ãŸæ‰‹æ³•ã«ã‚ˆã£ã¦ã€å–ã‚Šæ‰±ã‚ã‚Œã‚‹ã€‚
ç§ãŸã¡ã¯ã€å…¥åŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ ä¸­ã®å„ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ã€å¦å®šã•ã‚Œã¦ã„ã‚‹ã‚¯ã‚¨ãƒªã‚’æº€ãŸã™ã‚ˆã†ã«æ‹¡å¼µã—ã‚ˆã†ã¨è©¦ã¿ã€ãã—ã¦ã€ä¸ãˆã‚‰ã‚ŒãŸãƒ•ãƒ¬ãƒ¼ãƒ ã‚’æ‹¡å¼µã§ããªã‹ã£ãŸã¨ãã«ã®ã¿ã€ä¸ãˆã‚‰ã‚ŒãŸãƒ•ãƒ¬ãƒ¼ãƒ ã‚’å‡ºåŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«å«ã‚ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_5328"></a>(define (negate operands frame-stream)
  (stream-flatmap
   (lambda (frame)
     (if (stream-null? (qeval (negated-query operands)
                              (singleton-stream frame)))
         (singleton-stream frame)
         the-empty-stream))
   frame-stream))
(put 'not 'qeval negate)
</p>

<p class="orig" lang="en">
<a name="%_idx_5330"></a><tt>Lisp-value</tt> is a filter similar to <tt>not</tt>.  Each frame in the
stream is used to instantiate the variables in the pattern, the
indicated predicate is applied, and the frames for which the predicate
returns false are filtered out of the input stream.  An error results
if there are unbound pattern variables.</p>

<p class="trans" lang="ja">
<tt>lisp-value</tt> ã¯ã€<tt>not</tt> ã«ä¼¼ãŸãƒ•ã‚£ãƒ«ã‚¿ã§ã‚ã‚‹ã€‚
ãƒ‘ã‚¿ãƒ³å†…ã®å¤‰æ•°ã‚’ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã™ã‚‹ã®ã«ã‚¹ãƒˆãƒªãƒ¼ãƒ ä¸­ã®å„ãƒ•ãƒ¬ãƒ¼ãƒ ãŒä½¿ã‚ã‚Œã€ç¤ºã•ã‚ŒãŸè¿°èªãŒé©ç”¨ã•ã‚Œã€è¿°èªãŒå½ã‚’è¿”ã™ã‚ˆã†ãªãƒ•ãƒ¬ãƒ¼ãƒ ãŒå…¥åŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‹ã‚‰ãƒ•ã‚£ãƒ«ã‚¿ã«ã‚ˆã‚Šé™¤å»ã•ã‚Œã‚‹ã€‚
ã‚‚ã—æŸç¸›ã•ã‚Œã¦ã„ãªã„ãƒ‘ã‚¿ãƒ³å¤‰æ•°ãŒã‚ã‚Œã°ã€ã‚¨ãƒ©ãƒ¼ãŒç”Ÿã˜ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_5332"></a>(define (lisp-value call frame-stream)
  (stream-flatmap
   (lambda (frame)
     (if (execute
          (instantiate
           call
           frame
           (lambda (v f)
             (error &quot;Unknown pat var -- LISP-VALUE&quot; v))))
         (singleton-stream frame)
         the-empty-stream))
   frame-stream))
(put 'lisp-value 'qeval lisp-value)
</p>

<p class="orig" lang="en">
<tt>Execute</tt>, which applies the predicate to the arguments, must <tt>eval</tt> the predicate expression to get the procedure to apply.
However, it must not evaluate the arguments, since they are already
the actual arguments, not expressions whose evaluation (in Lisp) will
produce the arguments.  Note that <tt>execute</tt> is implemented using
<a name="%_idx_5334"></a><tt>eval</tt> and <tt>apply</tt> from the underlying Lisp system.</p>

<p class="trans" lang="ja">
<tt>execute</tt> â€”â€”è¿°èªã‚’å¼•æ•°ã«é©ç”¨ã™ã‚‹â€”â€”ã¯ã€é©ç”¨ã™ã¹ãæ‰‹ç¶šãã‚’å¾—ã‚‹ãŸã‚ã«ã€è¿°èªã®å¼ã‚’ <tt>eval</tt> ã›ã­ã°ãªã‚‰ãªã„ã€‚
ã—ã‹ã—ã€<tt>execute</tt> ã¯ã€å¼•æ•°ã‚’è©•ä¾¡ã—ã¦ã¯ãªã‚‰ãªã„ã€‚ã¨ã„ã†ã®ã‚‚ã€å¼•æ•°ã¯ã™ã§ã«å®Ÿéš›ã®å¼•æ•°ãªã®ã§ã‚ã£ã¦ã€(Lisp ã§ã®) è©•ä¾¡ãŒå¼•æ•°ã‚’ä½œã‚Šå‡ºã™ã§ã‚ã‚ã†ã‚ˆã†ãªå¼ãªã®ã§ã¯ãªã„ã‹ã‚‰ã ã€‚
æ ¹åº•ã«ã‚ã‚‹ Lisp ã‚·ã‚¹ãƒ†ãƒ ã§ã® <tt>eval</tt> ã¨ <tt>apply</tt> ã‚’ä½¿ã£ã¦ <tt>execute</tt> ãŒå®Ÿè£…ã•ã‚Œã‚‹ã€ã¨ã„ã†ã“ã¨ã«æ³¨æ„ã—ã¦ã»ã—ã„ã€‚
</p>

<p class="lisp">(define (execute exp)
  (apply (eval (predicate exp) user-initial-environment)
         (args exp)))
</p>

<p class="orig" lang="en">
The <tt>always-true</tt> special form provides for a query that is always
satisfied.  It ignores its contents (normally empty) and simply passes
through all the frames in the input stream.  <tt>Always-true</tt> is used
by the <tt>rule-body</tt> selector (section <a href="#%_sec_4.4.4.7">4.4.4.7</a>)
<a name="%_idx_5336"></a>to provide bodies for rules that were
defined without bodies (that is, rules whose conclusions are always
satisfied).</p>

<p class="trans" lang="ja">
<tt>always-true</tt> ã¨ã„ã†ç‰¹æ®Šå½¢å¼ã¯ã€å¸¸ã«æº€ãŸã•ã‚Œã‚‹ã‚¯ã‚¨ãƒªã‚’ä¸ãˆã‚‹ã€‚
ã“ã‚Œã¯ã€è‡ªåˆ†ã®ä¸­èº« (æ™®é€šã¯ç©º) ã‚’ç„¡è¦–ã—ã¦ã€å˜ç´”ã«å…¥åŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ å†…ã®å…¨ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’é€šã™ã€‚
<tt>always-true</tt> ã¯ã€æœ¬ä½“ãªã—ã§å®šç¾©ã•ã‚ŒãŸè¦å‰‡ (ã¤ã¾ã‚Šã€å¸°çµéƒ¨ãŒå¸¸ã«æº€ãŸã•ã‚Œã‚‹ã‚ˆã†ãªè¦å‰‡) ã«æœ¬ä½“ã‚’ä¸ãˆã‚‹ãŸã‚ã«ã€<tt>rule-body</tt> ã‚»ãƒ¬ã‚¯ã‚¿ (<a href="#%_sec_4.4.4.7">4.4.4.7</a>ç¯€) ã«ã‚ˆã£ã¦ä½¿ã‚ã‚Œã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_5338"></a>(define (always-true ignore frame-stream) frame-stream)
(put 'always-true 'qeval always-true)
</p>

<p class="orig" lang="en">The selectors that define the syntax of <tt>not</tt> and <tt>lisp-value</tt>
are given in section <a href="#%_sec_4.4.4.7">4.4.4.7</a>.
</p>

<p class="trans" lang="ja">
<tt>not</tt> ã¨ <tt>lisp-value</tt> ã®æ§‹æ–‡ã‚’å®šç¾©ã™ã‚‹ã‚»ãƒ¬ã‚¯ã‚¿ã¯ã€<a href="#%_sec_4.4.4.7">4.4.4.7</a>ç¯€ã§ä¸ãˆã‚‰ã‚Œã‚‹ã€‚
</p>

<a name="%_sec_4.4.4.3"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_4.4.4.3">4.4.4.3  Finding Assertions by Pattern Matching</a></h4>
<h4 class="trans" lang="ja">4.4.4.3 ãƒ‘ã‚¿ãƒ³ãƒ»ãƒãƒƒãƒãƒ³ã‚°ã«ã‚ˆã‚Š<ruby><rb>è¨€æ˜</rb><rp> (</rp><rt>ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³</rt><rp>) </rp></ruby>ã‚’è¦‹ã¤ã‘ã‚‹</h4>

<p class="orig" lang="en">
<a name="%_idx_5340"></a><a name="%_idx_5342"></a><tt>Find-assertions</tt>, called by <tt>simple-query</tt>
(section <a href="#%_sec_4.4.4.2">4.4.4.2</a>), takes as input a pattern and a frame.
It returns a stream of frames, each extending the given one by a
data-base match of the given pattern.  It uses <tt>fetch-assertions</tt>
(section <a href="#%_sec_4.4.4.5">4.4.4.5</a>) to get a stream of all the assertions in
the data base that should be checked for a match against the pattern
and the frame.  The reason for <tt>fetch-assertions</tt> here is that we
can often apply simple tests that will eliminate many of the entries
in the data base from the pool of candidates for a successful match.
The system would still work if we eliminated <tt>fetch-assertions</tt>
and simply checked a stream of all assertions in the data base, but
the computation would be less efficient because we would need to make
many more calls to the matcher.</p>

<p class="trans" lang="ja">
<tt>find-assertions</tt>  â€”â€” <tt>simple-query</tt> (<a href="#%_sec_4.4.4.2">4.4.4.2</a>ç¯€) ã«ã‚ˆã‚Šå‘¼ã³å‡ºã•ã‚Œã‚‹â€”â€”ã¯ã€ãƒ‘ã‚¿ãƒ³ã¨ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’å…¥åŠ›ã¨ã—ã¦ã¨ã‚‹ã€‚
<tt>find-assertions</tt> ã¯ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’è¿”ã™ã®ã ãŒã€ãã‚Œã‚‰ãƒ•ãƒ¬ãƒ¼ãƒ ã®å„ã€…ã¯ã€ä¸ãˆã‚‰ã‚ŒãŸãƒ‘ã‚¿ãƒ³ã®ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ä¸Šã§ã®ãƒãƒƒãƒã«ã‚ˆã£ã¦ã€ä¸ãˆã‚‰ã‚ŒãŸãƒ•ãƒ¬ãƒ¼ãƒ ã‚’æ‹¡å¼µã™ã‚‹ã‚‚ã®ã§ã‚ã‚‹ã€‚
<tt>find-assertions</tt> ã¯ã€<tt>fetch-assertions</tt> (<a href="#%_sec_4.4.4.5">4.4.4.5</a>ç¯€) ã‚’ç”¨ã„ã¦ã€ãƒ‘ã‚¿ãƒ³ã¨ãƒ•ãƒ¬ãƒ¼ãƒ ã«å¯¾ã™ã‚‹ãƒãƒƒãƒãŒã‚ã‚‹ã‹ã‚’èª¿ã¹ã‚‹ã¹ãã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å†…ã®ã™ã¹ã¦ã®è¨€æ˜ã‹ã‚‰ãªã‚‹ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å¾—ã‚‹ã€‚
ã“ã“ã§ <tt>fetch-assertions</tt> ã‚’ä½¿ã†ç†ç”±ã¯ã€æˆåŠŸã™ã‚‹ãƒãƒƒãƒã®å€™è£œã®è“„ãˆã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å†…ã®ã‚¨ãƒ³ãƒˆãƒªã®å¤šãã‚’å‰Šé™¤ã™ã‚‹ã§ã‚ã‚ã†ã€å˜ç´”ãªæ¤œæŸ»ã‚’é©ç”¨ã§ãã‚‹ã“ã¨ãŒã€ã‚ˆãã‚ã‚‹ãŸã‚ã§ã‚ã‚‹ã€‚
ã‚‚ã— <tt>fetch-assertions</tt> ã‚’å‰Šé™¤ã—ã¦ã€å˜ç´”ã«ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å†…ã®ã™ã¹ã¦ã®è¨€æ˜ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’èª¿ã¹ãŸã¨ã—ã¦ã‚‚ã€ã‚·ã‚¹ãƒ†ãƒ ã¯ä¾ç„¶ã¨ã—ã¦æ©Ÿèƒ½ã™ã‚‹ã ã‚ã†ãŒã€ã‚‚ã£ã¨ãŸãã•ã‚“ã®å›æ•°ã€ãƒãƒƒãƒãƒ£ã®å‘¼ã³å‡ºã—ã‚’è¡Œã†å¿…è¦ãŒã‚ã‚‹ã ã‚ã†ã‹ã‚‰ã€è¨ˆç®—ã®åŠ¹ç‡æ€§ã¯è½ã¡ã‚‹ã ã‚ã†ã€‚
</p>

<p class="lisp"><a name="%_idx_5344"></a>(define (find-assertions pattern frame)
  (stream-flatmap (lambda (datum)
                    (check-an-assertion datum pattern frame))
                  (fetch-assertions pattern frame)))
</p>

<p class="orig" lang="en">
<tt>Check-an-assertion</tt> takes as arguments a pattern, a data object
(assertion), and a frame and returns either a one-element stream
containing the extended frame or <tt>the-empty-stream</tt> if the match
fails.</p>

<p class="trans" lang="ja">
<tt>check-an-assertion</tt> ã¯ã€å¼•æ•°ã¨ã—ã¦ã€ãƒ‘ã‚¿ãƒ³ã¨ãƒ‡ãƒ¼ã‚¿ãƒ»ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (è¨€æ˜) ã¨ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ã¨ã‚Šã€æ‹¡å¼µã—ãŸãƒ•ãƒ¬ãƒ¼ãƒ ã‚’å«ã‚€ä¸€è¦ç´ ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‹ã€ã‚‚ã—ãã¯ã€ãƒãƒƒãƒãŒå¤±æ•—ã—ãŸå ´åˆã«ã¯ <tt>the-empty-stream</tt> ã‚’è¿”ã™ã€‚
</p>

<p class="lisp">(define (check-an-assertion assertion query-pat query-frame)
  (let ((match-result
         (pattern-match query-pat assertion query-frame)))
    (if (eq? match-result 'failed)
        the-empty-stream
        (singleton-stream match-result))))
</p>

<p class="orig" lang="en">The basic pattern matcher returns either the symbol <tt>failed</tt> or an
extension of the given frame.  The basic idea of the matcher is to
check the pattern against the data, element by element, accumulating
bindings for the pattern variables.  If the pattern and the data
object are the same, the match succeeds and we return the frame of
bindings accumulated so far.  Otherwise, if the pattern is a variable
we extend the current frame by binding the variable to the data, so
long as this is consistent with the bindings already in the frame.  If
the pattern and the data are both pairs, we (recursively) match the
<tt>car</tt> of the pattern against the <tt>car</tt> of the data to produce
a frame; in this frame we then match the <tt>cdr</tt> of the pattern
against the <tt>cdr</tt> of the data.  If none of these cases are
applicable, the match fails and we return the symbol <tt>failed</tt>.</p>

<p class="trans" lang="ja">
åŸºæœ¬çš„ãƒ‘ã‚¿ãƒ³ãƒ»ãƒãƒƒãƒãƒ£ã¯ã€<tt>failed</tt> ã¨ã„ã†è¨˜å·ã‹ã€ã¾ãŸã¯ã€ä¸ãˆã‚‰ã‚ŒãŸãƒ•ãƒ¬ãƒ¼ãƒ ã®æ‹¡å¼µã‚’è¿”ã™ã€‚
ãƒãƒƒãƒãƒ£ã®åŸºæœ¬çš„ãªè€ƒãˆæ–¹ã¯ã€ãƒ‘ã‚¿ãƒ³å¤‰æ•°ã«å¯¾ã™ã‚‹æŸç¸›ã‚’è“„ç©ã—ãªãŒã‚‰ã€ãƒ‡ãƒ¼ã‚¿ã«å¯¾ã—ã¦ãƒ‘ã‚¿ãƒ³ã‚’è¦ç´ ã”ã¨ã«èª¿ã¹ã‚‹ã€ã¨ã„ã†ã‚‚ã®ã§ã‚ã‚‹ã€‚
ã‚‚ã—ãƒ‘ã‚¿ãƒ³ã¨ãƒ‡ãƒ¼ã‚¿ãƒ»ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç­‰ã—ã‘ã‚Œã°ã€ãƒãƒƒãƒã¯æˆåŠŸã—ã€ã“ã‚Œã¾ã§ã®ã¨ã“ã‚è“„ç©ã•ã‚ŒãŸæŸç¸›ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’è¿”ã™ã€‚
ãã‚Œä»¥å¤–ã®å ´åˆã€ã‚‚ã—ãƒ‘ã‚¿ãƒ³ãŒå¤‰æ•°ãªã‚‰ã€ãã®å¤‰æ•°ã‚’ãƒ‡ãƒ¼ã‚¿ã«æŸç¸›ã™ã‚‹ã“ã¨ã§ç¾åœ¨ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’æ‹¡å¼µã™ã‚‹â€”â€”ã“ã‚ŒãŒã€ãƒ•ãƒ¬ãƒ¼ãƒ å†…ã«æ—¢ã«ã‚ã‚‹æŸç¸›ã¨æ•´åˆæ€§ãŒå–ã‚Œã¦ã„ã‚‹é™ã‚Šã¯ã€‚
ã‚‚ã—ãƒ‘ã‚¿ãƒ³ã¨ãƒ‡ãƒ¼ã‚¿ã®åŒæ–¹ãŒå¯¾ã§ã‚ã‚Œã°ã€(å†å¸°çš„ã«) ãƒ‘ã‚¿ãƒ³ã® <tt>car</tt> ã‚’ãƒ‡ãƒ¼ã‚¿ã® <tt>car</tt> ã«å¯¾ã—ã¦ãƒãƒƒãƒã•ã›ã¦ã€ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ä½œã‚Šå‡ºã™ã€‚ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã«ãŠã„ã¦ã€ãã®å¾Œã€ãƒ‘ã‚¿ãƒ³ã® <tt>cdr</tt> ã‚’ãƒ‡ãƒ¼ã‚¿ã® <tt>cdr</tt> ã«å¯¾ã—ã¦ãƒãƒƒãƒã•ã›ã‚‹ã€‚
ã“ã‚Œã‚‰ã®å ´åˆã®ã©ã‚Œã‚‚å½“ã¦ã¯ã¾ã‚‰ãªã‘ã‚Œã°ã€ãƒãƒƒãƒã¯å¤±æ•—ã—ã€<tt>failed</tt> ã¨ã„ã†è¨˜å·ã‚’è¿”ã™ã€‚
</p>

<p class="lisp"><a name="%_idx_5346"></a>(define (pattern-match pat dat frame)
  (cond ((eq? frame 'failed) 'failed)
        ((equal? pat dat) frame)
        ((var? pat) (extend-if-consistent pat dat frame))
        ((and (pair? pat) (pair? dat))
         (pattern-match (cdr pat)
                        (cdr dat)
                        (pattern-match (car pat)
                                       (car dat)
                                       frame)))
        (else 'failed)))
</p>

<p class="orig" lang="en">
Here is the procedure that extends a frame by adding a new binding, if
this is consistent with the bindings already in the frame:</p>

<p class="trans" lang="ja">
æ–°ãŸãªæŸç¸›ã‚’â€”â€”ã‚‚ã—ã“ã‚ŒãŒã€ãƒ•ãƒ¬ãƒ¼ãƒ å†…ã«æ—¢ã«ã‚ã‚‹æŸç¸›ã¨æ•´åˆæ€§ãŒå–ã‚Œã¦ã„ã‚Œã°â€”â€”åŠ ãˆã‚‹ã“ã¨ã§ã€ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’æ‹¡å¼µã™ã‚‹æ‰‹ç¶šãã‚’ã€ã“ã“ã«ç¤ºã™ã€‚
</p>

<p class="lisp"><a name="%_idx_5348"></a>(define (extend-if-consistent var dat frame)
  (let ((binding (binding-in-frame var frame)))
    (if binding
        (pattern-match (binding-value binding) dat frame)
        (extend var dat frame))))
</p>

<p class="orig" lang="en">If there is no binding for the variable in the frame, we simply add
the binding of the variable to the data.  Otherwise we match, in the
frame, the data against the value of the variable in the frame.  If
the stored value contains only constants, as it must if it was stored
during pattern matching by <tt>extend-if-consistent</tt>, then the match
simply tests whether the stored and new values are the same.  If so,
it returns the unmodified frame; if not, it returns a failure
indication.  The stored value may, however, contain pattern variables
if it was stored during unification (see section <a href="#%_sec_4.4.4.4">4.4.4.4</a>).
The recursive match of the stored pattern against the new data will add or
check bindings for the variables in this pattern.  For example,
suppose we have a frame in which <tt>?x</tt> is bound to <tt>(f ?y)</tt> and
<tt>?y</tt> is unbound, and we wish to augment this frame by a binding of
<tt>?x</tt> to <tt>(f b)</tt>.  We look up <tt>?x</tt> and find that it is
bound to <tt>(f ?y)</tt>.  This leads us to match <tt>(f ?y)</tt> against
the proposed new value <tt>(f b)</tt> in the same frame.  Eventually
this match extends the frame by adding a binding of <tt>?y</tt> to <tt>b</tt>.  <tt>?X</tt> remains bound to <tt>(f ?y)</tt>.  We never modify a stored
binding and we never store more than one binding for a given variable.</p>

<p class="trans" lang="ja">
ãã®ãƒ•ãƒ¬ãƒ¼ãƒ å†…ã®ãã®å¤‰æ•°ã«ã¤ã„ã¦ã®æŸç¸›ãŒã€ã‚‚ã—å­˜åœ¨ã—ãªã‘ã‚Œã°ã€ãã®ãƒ‡ãƒ¼ã‚¿ã¸ã®ãã®å¤‰æ•°ã®æŸç¸›ã‚’ã€ãŸã åŠ ãˆã‚‹ã ã‘ã§ã‚ã‚‹ã€‚
ãã‚Œä»¥å¤–ã®å ´åˆã€ãã®ãƒ•ãƒ¬ãƒ¼ãƒ å†…ã§ã€ãã®ãƒ•ãƒ¬ãƒ¼ãƒ å†…ã®ãã®å¤‰æ•°ã®å€¤ã«å¯¾ã—ã¦ã€ãã®ãƒ‡ãƒ¼ã‚¿ã‚’ãƒãƒƒãƒã•ã›ã‚‹ã€‚
ã‚‚ã—ã€æ ¼ç´ã•ã‚Œã¦ã„ã‚‹å€¤ãŒå®šæ•°ã®ã¿ã‚’å«ã‚€ãªã‚‰â€”â€”ã‚‚ã—ãã®å€¤ãŒã€<tt>extend-if-consistent</tt> ã«ã‚ˆã‚‹ãƒ‘ã‚¿ãƒ³ãƒ»ãƒãƒƒãƒãƒ³ã‚°ã®é–“ã«æ ¼ç´ã•ã‚ŒãŸã®ã§ã‚ã‚Œã°ã€ãã£ã¨ãã†ãªã‚‹ç­ˆã ãŒâ€”â€”ãã®ãƒãƒƒãƒã¯ã€å˜ã«ã€æ ¼ç´ã•ã‚Œã¦ã„ã‚‹å€¤ã¨æ–°ãŸãªå€¤ãŒç­‰ã—ã„ã‹ã©ã†ã‹ã‚’èª¿ã¹ã‚‹ã ã‘ã§ã‚ã‚‹ã€‚
ã‚‚ã—ç­‰ã—ã‘ã‚Œã°ã€å¤‰æ›´ã—ãªã„ã¾ã¾ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’è¿”ã™ã€‚ã‚‚ã—ç­‰ã—ããªã‘ã‚Œã°ã€å¤±æ•—ã®å°ã‚’è¿”ã™ã€‚
ã—ã‹ã—ã€æ ¼ç´ã•ã‚Œã¦ã„ã‚‹å€¤ã¯ã€ã‚‚ã—ãã‚ŒãŒãƒ¦ãƒ‹ãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®é–“ã«æ ¼ç´ã•ã‚ŒãŸã®ã§ã‚ã‚Œã°ã€ãƒ‘ã‚¿ãƒ³å¤‰æ•°ã‚’å«ã‚€ã“ã¨ã‚‚ã‚ã‚Šå¾—ã‚‹ (<a href="#%_sec_4.4.4.4">4.4.4.4</a>ç¯€ã‚’å‚ç…§)ã€‚
æ ¼ç´ã•ã‚Œã¦ã„ã‚‹ãƒ‘ã‚¿ãƒ³ã®ã€æ–°ãŸãªãƒ‡ãƒ¼ã‚¿ã«å¯¾ã™ã‚‹å†å¸°çš„ãƒãƒƒãƒã¯ã€ã“ã®ãƒ‘ã‚¿ãƒ³å†…ã®å¤‰æ•°ã«ã¤ã„ã¦ã®æŸç¸›ã‚’åŠ ãˆãŸã‚Šã€ã¾ãŸã¯èª¿ã¹ãŸã‚Šã™ã‚‹ã ã‚ã†ã€‚
ãŸã¨ãˆã°ã€<tt>?x</tt> ãŒ <tt>(f ?y)</tt> ã«æŸç¸›ã•ã‚Œã¦ãŠã‚Šã€ã‹ã¤ã€<tt>?y</tt> ãŒæŸç¸›ã•ã‚Œã¦ã„ãªã„ã‚ˆã†ãªãƒ•ãƒ¬ãƒ¼ãƒ ãŒã‚ã‚‹ã‚‚ã®ã¨ã—ã¦ã€ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ã€<tt>?x</tt> ã® <tt>(f b)</tt> ã¸ã®æŸç¸›ã«ã‚ˆã£ã¦æ‹¡å¤§ã—ãŸã„ã®ã ã¨ã—ã‚ˆã†ã€‚
ç§ãŸã¡ã¯ã€<tt>x?</tt> ã‚’èª¿ã¹ã€ãã—ã¦ã€<tt>x?</tt> ãŒ <tt>(f ?y)</tt> ã«æŸç¸›ã•ã‚Œã¦ã„ã‚‹ã¨åˆ†ã‹ã‚‹ã€‚
ã“ã®ã“ã¨ã«ã‚ˆã‚Šç§ãŸã¡ã¯ã€<tt>(f b)</tt> ã¨ã„ã†ææ¡ˆã•ã‚ŒãŸæ–°ãŸãªå€¤ã«å¯¾ã—ã¦ã€<tt>(f ?y)</tt> ã‚’åŒä¸€ãƒ•ãƒ¬ãƒ¼ãƒ å†…ã§ãƒãƒƒãƒã•ã›ã‚‹ã‚ˆã†ã«ã€ä»•å‘ã‘ã‚‰ã‚Œã‚‹ã€‚
æœ€çµ‚çš„ã«ã€ã“ã®ãƒãƒƒãƒã¯ã€<tt>?y</tt> ã® <tt>b</tt> ã¸ã®æŸç¸›ã‚’åŠ ãˆã‚‹ã“ã¨ã§ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’æ‹¡å¼µã™ã‚‹ã€‚
<tt>x?</tt> ã¯ <tt>(f ?y)</tt> ã«æŸç¸›ã•ã‚ŒãŸã¾ã¾ã§ã‚ã‚‹ã€‚
ç§ãŸã¡ã¯ã€æ ¼ç´ã•ã‚Œã¦ã„ã‚‹æŸç¸›ã‚’æ±ºã—ã¦å¤‰æ›´ã—ãªã„ã—ã€ä¸ãˆã‚‰ã‚ŒãŸå¤‰æ•°ã«ã¤ã„ã¦ä¸€ã¤ã‚ˆã‚Šã‚‚å¤šãã®æŸç¸›ã‚’æ ¼ç´ã™ã‚‹ã“ã¨ã‚‚ã€æ±ºã—ã¦ã—ãªã„ã€‚
</p>

<p class="orig" lang="en">
The procedures used by <tt>extend-if-consistent</tt> to manipulate
bindings are defined in section <a href="#%_sec_4.4.4.8">4.4.4.8</a>.</p>

<p class="trans" lang="ja">
æŸç¸›ã‚’æ“ä½œã™ã‚‹ãŸã‚ã« <tt>extend-if-consistent</tt> ã«ã‚ˆã‚Šä½¿ã‚ã‚Œã‚‹æ‰‹ç¶šãã¯ã€<a href="#%_sec_4.4.4.8">4.4.4.8</a>ç¯€ã§å®šç¾©ã•ã‚Œã‚‹ã€‚
</p>

<a name="%_sec_Temp_699"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_699">Patterns with dotted tails</a></h4>
<h4 class="trans" lang="ja">ãƒ‰ãƒƒãƒˆã®ä»˜ã„ãŸæœ«å°¾ãŒã‚ã‚‹ãƒ‘ã‚¿ãƒ³</h4>

<p class="orig" lang="en">
<a name="%_idx_5350"></a>
If a pattern contains a dot followed by a pattern variable, the
pattern variable matches the rest of the data list (rather than the
next element of the data list), just as one would expect with the
dotted-tail notation described in exercise <a href="15_sec2_2.html#%_thm_2.20">2.20</a>.
Although the pattern matcher we have just implemented doesn't look for
dots, it does behave as we want.  This is because the Lisp <tt>read</tt>
primitive, which is used by <tt>query-driver-loop</tt> to read the query
and represent it as a list structure, treats dots in a special way.</p>

<p class="trans" lang="ja">
ã‚‚ã—ãƒ‘ã‚¿ãƒ³ãŒã€ãƒ‘ã‚¿ãƒ³å¤‰æ•°ãŒå¾Œã«ç¶šã„ã¦ã„ã‚‹ãƒ‰ãƒƒãƒˆã‚’å«ã‚€ãªã‚‰ã€ãã®ãƒ‘ã‚¿ãƒ³å¤‰æ•°ã¯ã€(ãƒ‡ãƒ¼ã‚¿ãƒ»ãƒªã‚¹ãƒˆã®æ¬¡ã®è¦ç´ ã§ã¯ãªã) ãƒ‡ãƒ¼ã‚¿ãƒ»ãƒªã‚¹ãƒˆã®æ®‹ã‚Šã®éƒ¨åˆ†ã«ãƒãƒƒãƒã™ã‚‹â€”â€”ã¡ã‚‡ã†ã©ã€ç·´ç¿’å•é¡Œ<a href="15_sec2_2.html#%_thm_2.20">2.20</a>ã§èª¬æ˜ã—ãŸã€æœ«å°¾ã«ãƒ‰ãƒƒãƒˆãŒã¤ã„ãŸè¨˜æ³•ã‚’ä½¿ã£ã¦ã€äººãŒäºˆæœŸã™ã‚‹ã§ã‚ã‚ã†ã¨ãŠã‚Šã«ã€‚
ç§ãŸã¡ãŒå®Ÿè£…ã—ãŸã°ã‹ã‚Šã®ãƒ‘ã‚¿ãƒ³ãƒ»ãƒãƒƒãƒãƒ£ã¯ã€ãƒ‰ãƒƒãƒˆã‚’æ¢ã™ã‚ã‘ã§ã¯ãªã„ãŒã€ç§ãŸã¡ãŒæœ›ã‚€ã¨ãŠã‚Šã«ãµã‚‹ã¾ã†ã€‚
ã“ã‚Œã¯ã€Lisp ã«ã‚ˆã‚Š <tt>read</tt> ã•ã‚ŒãŸãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–â€”â€”ã‚¯ã‚¨ãƒªã‚’èª­ã‚“ã§ãã‚Œã‚’ãƒªã‚¹ãƒˆæ§‹é€ ã¨ã—ã¦è¡¨ç¾ã™ã‚‹ãŸã‚ã« <tt>query-driver-loop</tt> ã«ã‚ˆã£ã¦ä½¿ã‚ã‚Œã‚‹â€”â€”ãŒã€ãƒ‰ãƒƒãƒˆã‚’ç‰¹åˆ¥ãªæ–¹æ³•ã§æ‰±ã†ã‹ã‚‰ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_5352"></a><a name="%_idx_5354"></a>When <tt>read</tt> sees a dot, instead of making the next item be the
next element of a list (the <tt>car</tt> of a <tt>cons</tt> whose <tt>cdr</tt>
will be the rest of the list) it makes the next item be the <tt>cdr</tt>
of the list structure.  For example, the list structure produced by
<tt>read</tt> for the pattern <tt>(computer ?type)</tt> could be constructed
by evaluating the expression <tt>(cons 'computer (cons '?type '()))</tt>,
and that for <tt>(computer . ?type)</tt> could be constructed by
evaluating the expression <tt>(cons 'computer '?type)</tt>.</p>

<p class="trans" lang="ja">
<tt>read</tt> ã¯ã€ãƒ‰ãƒƒãƒˆ<!-- ã‚’è¦‹ã‚‹ -->ã«å‡ºä¼šã†ã¨ã€æ¬¡ã®é …ç›®ã‚’ã€ãƒªã‚¹ãƒˆã®æ¬¡ã®è¦ç´ ã¨ã™ã‚‹ (<tt>cdr</tt> ãŒãã®ãƒªã‚¹ãƒˆã®æ®‹ã‚Šã®éƒ¨åˆ†ã¨ãªã‚‹ã§ã‚ã‚ã†ã‚ˆã†ãª <tt>cons</tt> ã®ã€<tt>car</tt> ã¨ã™ã‚‹) ä»£ã‚ã‚Šã«ã€æ¬¡ã®é …ç›®ã‚’ãƒªã‚¹ãƒˆæ§‹é€ ã® <tt>cdr</tt> ã¨ã™ã‚‹ã€‚
ãŸã¨ãˆã°ã€<tt>(computer ?type)</tt> ã¨ã„ã†ãƒ‘ã‚¿ãƒ³ã«å¯¾ã—ã¦ <tt>read</tt> ã«ã‚ˆã‚Šä½œã‚Šå‡ºã•ã‚Œã‚‹ãƒªã‚¹ãƒˆæ§‹é€ ã¯ã€<tt>(cons 'computer (cons '?type '()))</tt> ã¨ã„ã†å¼ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦æ§‹ç¯‰ã§ãã‚‹ã ã‚ã†ã—ã€<tt>(computer . ?type)</tt> ã«å¯¾ã™ã‚‹ã‚‚ã®ã¯ã€<tt>(cons 'computer '?type)</tt> ã¨ã„ã†å¼ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦æ§‹ç¯‰ã§ãã‚‹ã ã‚ã†ã€‚
<span class="note"><br>(å…¥ã‚Šçµ„ã‚“ã§ã„ã¦åˆ†ã‹ã‚Šã¥ã‚‰ã„ã®ã ã‘ã‚Œã©ã€å¤šåˆ†ã€æ¬¡ã®ã‚ˆã†ãªæ„å›³ã ã¨æ€ã†ã€‚
ãŸã¨ãˆã°ã€<tt>(computer . ?type)</tt> ã®ãƒ‰ãƒƒãƒˆã‚’è¦‹ã‚‹ã¨ã€ãƒ‰ãƒƒãƒˆã®ã€Œæ¬¡ã®é …ç›®ã€ã§ã‚ã‚‹ <tt>?type</tt> ã‚’ã€ãƒªã‚¹ãƒˆã®æ¬¡ã®è¦ç´ ã¨ã™ã‚‹â€”â€”ã¤ã¾ã‚Šã€<tt>(computer ?type)</tt> ã¨æ§‹ç¯‰ã™ã‚‹â€”â€”ã¨ã„ã†ã“ã¨ã¯ã—ãªã„ã€‚ã™ãªã‚ã¡ã€ãƒ‰ãƒƒãƒˆã®ã€Œæ¬¡ã®é …ç›®ã€ã§ã‚ã‚‹ <tt>?type</tt> ã‚’ã€ã€Œãã® <tt>cdr</tt> ãŒã€(ãã® <tt>(computer ?type)</tt> ã¨ã„ã†)ã€ãƒªã‚¹ãƒˆã€ã®ã€æ®‹ã‚Šã®éƒ¨åˆ†ã€ãŸã‚‹ <tt>()</tt> ã¨ãªã‚‹ã‚ˆã†ãª <tt>cons</tt> ã®ã€<tt>car</tt>ã€ã«ã—ãŸã‚Šã¯ã—ãªã„ (è¦ã™ã‚‹ã«ã€<tt>?type</tt> ã‚’ã€<tt>(?type)</tt> ã¨ã„ã† <tt>cons</tt> ã® <tt>car</tt> ã«ã¯ã—ãªã„)ã€‚ãã®ä»£ã‚ã‚Šã€ãƒ‰ãƒƒãƒˆã®ã€Œæ¬¡ã®é …ç›®ã€ã§ã‚ã‚‹ <tt>?type</tt> ã‚’ã€ãƒªã‚¹ãƒˆæ§‹é€ ã® <tt>cdr</tt> ã¨ã—ã¦ã€<tt>(computer . ?type)</tt> ã¨ã„ã†ãƒ‰ãƒƒãƒˆå¯¾ã‚’æ§‹ç¯‰ã™ã‚‹ã€‚ )</span>
</p>

<p class="orig" lang="en">
Thus, as <tt>pattern-match</tt> recursively compares <tt>car</tt>s and <tt>cdr</tt>s of a data list and a pattern that had a dot, it eventually
matches the variable after the dot (which is a <tt>cdr</tt> of the
pattern) against a sublist of the data list, binding the variable to
that list.  For example, matching the pattern <tt>(computer . ?type)</tt> against
<tt>(computer programmer trainee)</tt> will match <tt>?type</tt> against the
list <tt>(programmer trainee)</tt>.
</p>

<p class="trans" lang="ja">
ã“ã®ã‚ˆã†ã«ã—ã¦ã€<tt>pattern-match</tt> ã¯ã€ãƒ‡ãƒ¼ã‚¿ãƒ»ãƒªã‚¹ãƒˆã¨ãƒ‰ãƒƒãƒˆã®ã‚ã£ãŸãƒ‘ã‚¿ãƒ³ã¨ã® <tt>car</tt> åŒå£«ãŠã‚ˆã³ <tt>cdr</tt> åŒå£«ã‚’å†å¸°çš„ã«æ¯”è¼ƒã™ã‚‹ã®ã§ã€æœ€çµ‚çš„ã«ã€ãƒ‰ãƒƒãƒˆã®å¾Œã®å¤‰æ•° (ãƒ‘ã‚¿ãƒ³ã® <tt>cdr</tt>) ã‚’ãƒ‡ãƒ¼ã‚¿ãƒ»ãƒªã‚¹ãƒˆã®éƒ¨åˆ†ãƒªã‚¹ãƒˆã«å¯¾ã—ã¦ãƒãƒƒãƒã•ã›ã€ãã®å¤‰æ•°ã‚’ãã®ãƒªã‚¹ãƒˆã«æŸç¸›ã™ã‚‹ã€‚
ãŸã¨ãˆã°ã€<tt>(computer . ?type)</tt> ã¨ã„ã†ãƒ‘ã‚¿ãƒ³ã‚’ <tt>(computer programmer trainee)</tt> ã«å¯¾ã—ã¦ãƒãƒƒãƒã•ã›ã‚‹ã“ã¨ã§ã€<tt>(programmer trainee)</tt> ã¨ã„ã†ãƒªã‚¹ãƒˆã«å¯¾ã—ã¦ <tt>?type</tt> ã‚’ãƒãƒƒãƒã•ã›ã‚‹ã“ã¨ã«ãªã‚‹ã ã‚ã†ã€‚
</p>

<a name="%_sec_4.4.4.4"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_4.4.4.4">4.4.4.4  Rules and Unification</a></h4>
<h4 class="trans" lang="ja">4.4.4.4 è¦å‰‡ã¨ãƒ¦ãƒ‹ãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³</h4>

<p class="orig" lang="en">
<a name="%_idx_5356"></a><tt>Apply-rules</tt> is the rule analog of <tt>find-assertions</tt>
(section <a href="#%_sec_4.4.4.3">4.4.4.3</a>).  It
takes as input a pattern and a frame, and it forms a stream of
extension frames by applying rules from the data base.  <tt>Stream-flatmap</tt> maps <tt>apply-a-rule</tt> down the stream of possibly
applicable rules (selected by <tt>fetch-rules</tt>, section <a href="#%_sec_4.4.4.5">4.4.4.5</a>)
and combines the resulting streams of frames.</p>

<p class="trans" lang="ja">
<tt>apply-rules</tt> ã¯ã€<tt>find-assertions</tt> (<a href="#%_sec_4.4.4.3">4.4.4.3</a>ç¯€)ã®ã€è¦å‰‡ç‰ˆã®é¡ä¼¼ç‰©ã§ã‚ã‚‹ã€‚
ã“ã‚Œã¯ã€å…¥åŠ›ã¨ã—ã¦ãƒ‘ã‚¿ãƒ³ã¨ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ã¨ã‚Šã€è¦å‰‡ã‚’é©ç”¨ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‹ã‚‰æ‹¡å¼µãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å½¢æˆã™ã‚‹ã€‚
<tt>stream-flatmap</tt> ã¯ã€ã‚‚ã—ã‹ã™ã‚‹ã¨é©ç”¨å¯èƒ½ãªè¦å‰‡ (<a href="#%_sec_4.4.4.5">4.4.4.5</a>ç¯€ã® <tt>fetch-rules</tt> ã«ã‚ˆã‚Šé¸æŠã•ã‚Œã‚‹) ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«å¯¾ã—ã¦ <tt>apply-a-rule</tt> ã‚’ãƒãƒƒãƒ—ã—ã€çµæœã¨ã—ã¦ç”Ÿã˜ã‚‹ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ åŒå£«ã‚’çµåˆã™ã‚‹ã€‚

</p>

<p class="lisp"><a name="%_idx_5358"></a>(define (apply-rules pattern frame)
  (stream-flatmap (lambda (rule)
                    (apply-a-rule rule pattern frame))
                  (fetch-rules pattern frame)))
</p>

<p class="orig" lang="en">
<tt>Apply-a-rule</tt> applies rules using the method outlined in
section <a href="#%_sec_4.4.2">4.4.2</a>.  It first augments its argument
frame by unifying the rule conclusion with the pattern in the given
frame.  If this succeeds, it evaluates the rule body in this new
frame.</p>

<p class="trans" lang="ja">
<tt>apply-a-rule</tt> ã¯ã€<a href="#%_sec_4.4.2">4.4.2</a>ç¯€ã§æ¦‚è¦ã‚’è¿°ã¹ãŸæ–¹æ³•ã‚’ç”¨ã„ã¦ã€è¦å‰‡ã‚’é©ç”¨ã™ã‚‹ã€‚
ã“ã‚Œã¯ã€ã¾ãšã€è¦å‰‡ã®å¸°çµéƒ¨ã‚’ã€ä¸ãˆã‚‰ã‚ŒãŸãƒ•ãƒ¬ãƒ¼ãƒ å†…ã®ãƒ‘ã‚¿ãƒ³ã¨ãƒ¦ãƒ‹ãƒ•ã‚¡ã‚¤ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€è‡ªèº«ã®å¼•æ•°ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’æ‹¡å¼µã™ã‚‹ã€‚
ã‚‚ã—ã“ã‚ŒãŒæˆåŠŸã™ã‚Œã°ã€<tt>apply-a-rule</tt> ã¯ã€è¦å‰‡ã®æœ¬ä½“éƒ¨ã‚’ã“ã®æ–°ãŸãªãƒ•ãƒ¬ãƒ¼ãƒ ã«ãŠã„ã¦è©•ä¾¡ã™ã‚‹ã€‚
</p>

<p class="orig" lang="en">
Before any of this happens, however, the program renames all the
variables in the rule with unique new names.  The reason for this is
to prevent the variables for different rule applications from becoming
confused with each other.  For instance, if two rules both use a
variable named <tt>?x</tt>, then each one may add a binding for <tt>?x</tt>
to the frame when it is applied.  These two <tt>?x</tt>'s have nothing to
do with each other, and we should not be fooled into thinking that the
two bindings must be consistent.  Rather than rename variables, we
could devise a more clever environment structure; however, the
renaming approach we have chosen here is the most straightforward,
even if not the most efficient.  (See
exercise <a href="#%_thm_4.79">4.79</a>.)  Here is the <tt>apply-a-rule</tt>
procedure:</p>

<p class="trans" lang="ja">
ã—ã‹ã—ã€ã“ã†ã—ãŸã“ã¨ã®ã„ãšã‚Œã‹ãŒèµ·ã“ã‚‹å‰ã«ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€è¦å‰‡å†…ã®ã™ã¹ã¦ã®å¤‰æ•°ã‚’ã€ä¸€æ„ãªæ–°ã—ã„åå‰ã‚’ä½¿ã£ã¦ãƒªãƒãƒ¼ãƒ ã™ã‚‹ã€‚
ã“ã†ã™ã‚‹ç†ç”±ã¯ã€ç•°ãªã‚‹è¦å‰‡é©ç”¨ã«ã¤ã„ã¦ã®å¤‰æ•°åŒå£«ãŒã€ãŠäº’ã„ã¨æ··åŒã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚‹ã“ã¨ã‚’é˜²ããŸã‚ã§ã‚ã‚‹ã€‚
ãŸã¨ãˆã°ã€äºŒã¤ã®è¦å‰‡ãŒã©ã¡ã‚‰ã‚‚ <tt>?x</tt> ã¨åä»˜ã‘ã‚‰ã‚ŒãŸå¤‰æ•°ã‚’ç”¨ã„ã¦ã„ã‚Œã°ã€ãã‚Œãã‚Œã®è¦å‰‡ãŒã€ãã®è¦å‰‡ãŒé©ç”¨ã•ã‚ŒãŸéš›ã«ã€<tt>?x</tt> ã«å¯¾ã™ã‚‹æŸç¸›ã‚’ãƒ•ãƒ¬ãƒ¼ãƒ ã«è¿½åŠ ã™ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚
ã“ã‚Œã‚‰äºŒã¤ã® <tt>?x</tt> ã¯ãŠäº’ã„ã«ç„¡é–¢ä¿‚ã§ã‚ã‚Šã€ç§ãŸã¡ã¯ã€äºŒã¤ã®æŸç¸›ã¯æ•´åˆæ€§ãŒå–ã‚Œã¦ã„ãªãã¦ã¯ãªã‚‰ãªã„ã¨è€ƒãˆã‚‹ã‚ˆã†ã«é¨™ã•ã‚ŒãŸã‚Šã™ã¹ãã§ã¯ãªã„ã€‚
å¤‰æ•°ã‚’ãƒªãƒãƒ¼ãƒ ã™ã‚‹ã®ã§ãªãã€ã‚€ã—ã‚ã€ç§ãŸã¡ã¯ã€ã‚ˆã‚Šè³¢ã„ç’°å¢ƒæ§‹é€ ã‚’è€ƒæ¡ˆã™ã‚‹ã“ã¨ã‚‚ã§ãã‚‹ã§ã‚ã‚ã†ã€‚ã—ã‹ã—ã€ã“ã“ã§é¸æŠã—ãŸã€ãƒªãƒãƒ¼ãƒ ã™ã‚‹ã¨ã„ã†æ‰‹æ³•ã¯ã€ã‚‚ã£ã¨ã‚‚åŠ¹ç‡çš„ã¨ã„ã†è¨³ã§ã¯ãªã„ã¨ã—ã¦ã‚‚ã€ã‚‚ã£ã¨ã‚‚åˆ†ã‹ã‚Šã‚„ã™ã„ã‚‚ã®ã§ã‚ã‚‹ (ç·´ç¿’å•é¡Œ<a href="#%_thm_4.79">4.79</a>ã‚’å‚ç…§)ã€‚
<tt>apply-a-rule</tt> æ‰‹ç¶šãã‚’ã“ã“ã«ç¤ºã™ã€‚
</p>

<p class="lisp">(define (apply-a-rule rule query-pattern query-frame)
  (let ((clean-rule (rename-variables-in rule)))
    (let ((unify-result
           (unify-match query-pattern
                        (conclusion clean-rule)
                        query-frame)))
      (if (eq? unify-result 'failed)
          the-empty-stream
          (qeval (rule-body clean-rule)
                 (singleton-stream unify-result))))))
</p>

<p class="orig" lang="en">The selectors <tt>rule-body</tt> and <tt>conclusion</tt> that extract parts
of a rule are defined in section <a href="#%_sec_4.4.4.7">4.4.4.7</a>.</p>

<p class="trans" lang="ja">
è¦å‰‡ã®ä¸€éƒ¨ã‚’æŠ½å‡ºã™ã‚‹ <tt>rule-body</tt> ãŠã‚ˆã³ <tt>conclusion</tt> ã¨ã„ã†ã‚»ãƒ¬ã‚¯ã‚¿ã¯ã€<a href="#%_sec_4.4.4.7">4.4.4.7</a>ç¯€ã§å®šç¾©ã•ã‚Œã‚‹ã€‚
</p>

<p class="orig" lang="en">
We generate unique variable names by associating a unique identifier
(such as a number) with each rule application and combining this
identifier with the original variable names.  For example, if the
rule-application identifier is 7, we might change each <tt>?x</tt> in
the rule to <tt>?x-7</tt> and each <tt>?y</tt> in the rule to <tt>?y-7</tt>.
(<tt>Make-new-variable</tt> and <tt>new-rule-application-id</tt> are
included with the syntax procedures in section <a href="#%_sec_4.4.4.7">4.4.4.7</a>.)</p>

<p class="trans" lang="ja">
(ç•ªå·ãªã©ã®) ä¸€æ„ãªè­˜åˆ¥å­ã‚’ãã‚Œãã‚Œã®è¦å‰‡é©ç”¨ã¨å¯¾å¿œã¥ã‘ã¦ã€ã“ã®è­˜åˆ¥å­ã‚’å…ƒã®å¤‰æ•°åã¨çµåˆã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€ç§ãŸã¡ã¯ã€ä¸€æ„ãªå¤‰æ•°åã‚’ç”Ÿæˆã™ã‚‹ã€‚
ãŸã¨ãˆã°ã€è¦å‰‡é©ç”¨ã®è­˜åˆ¥å­ãŒ 7 ã§ã‚ã‚Œã°ã€ãã®è¦å‰‡å†…ã®ãã‚Œãã‚Œã® <tt>?x</tt> ã‚’ <tt>?x-7</tt> ã«å¤‰æ›´ã™ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã—ã€ãã®è¦å‰‡å†…ã®ãã‚Œãã‚Œã® <tt>?y</tt> ã‚’ <tt>?y-7</tt> ã«å¤‰æ›´ã™ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ (<tt>make-new-variable</tt> ã¨ <tt>new-rule-application-id</tt> ã¯ã€<a href="#%_sec_4.4.4.7">4.4.4.7</a>ç¯€ã®æ–‡æ³•æ‰‹ç¶šãã«å«ã¾ã‚Œã¦ã„ã‚‹)ã€‚
</p>

<p class="lisp">(define (rename-variables-in rule)
  (let ((rule-application-id (new-rule-application-id)))
    (define (tree-walk exp)
      (cond ((var? exp)
             (make-new-variable exp rule-application-id))
            ((pair? exp)
             (cons (tree-walk (car exp))
                   (tree-walk (cdr exp))))
            (else exp)))
    (tree-walk rule)))
</p>

<p class="orig" lang="en">
<a name="%_idx_5360"></a><a name="%_idx_5362"></a>The unification algorithm is implemented as a procedure that takes as
inputs two patterns and a frame and returns either the extended frame
or the symbol <tt>failed</tt>.
The unifier is like the pattern matcher except that it is
symmetrical -- variables are allowed on both sides of the match.
<tt>Unify-match</tt> is basically the same as <tt>pattern-match</tt>,
except that there is extra code (marked ``<tt>***</tt>'' below) to handle
the case where the object on the right side of the match is a variable.</p>

<p class="trans" lang="ja">
äºŒã¤ã®ãƒ‘ã‚¿ãƒ³ã¨ä¸€ã¤ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã¨ã‚’å…¥åŠ›ã¨ã—ã¦ã¨ã‚Šã€æ‹¡å¼µã—ãŸãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã€<tt>failed</tt> ã¨ã„ã†è¨˜å·ã®ã€ã„ãšã‚Œã‹ã‚’è¿”ã™ã‚ˆã†ãªæ‰‹ç¶šãã¨ã—ã¦ã€ãƒ¦ãƒ‹ãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ»ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯å®Ÿè£…ã•ã‚Œã‚‹ã€‚
ãƒ¦ãƒ‹ãƒ•ã‚¡ã‚¤ã‚¢ã¯ã€å¯¾ç§°çš„ã â€”â€”å¤‰æ•°ãŒãƒãƒƒãƒã®ä¸¡å´ã§è¨±ã•ã‚Œã‚‹â€”â€”ã¨ã„ã†ç‚¹ã‚’é™¤ã„ã¦ã¯ã€ãƒ‘ã‚¿ãƒ³ãƒ»ãƒãƒƒãƒãƒ£ã¨ä¼¼ã¦ã„ã‚‹ã€‚
<tt>unify-match</tt> ã¯ã€åŸºæœ¬çš„ã«ã¯ <tt>pattern-match</tt> ã¨åŒã˜ã§ã‚ã‚‹â€”â€”ãŸã ã—ã€ãƒãƒƒãƒã®å³å´ã«ã‚ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå¤‰æ•°ã§ã‚ã‚‹ã€ã¨ã„ã†å ´åˆã‚’æ‰±ã†ãŸã‚ã®ã€è¿½åŠ ã®ã‚³ãƒ¼ãƒ‰ (ä»¥ä¸‹ã§ã¯ &ldquo;<tt>***</tt>&rdquo; ã¨ã„ã†å°ãŒã¤ã„ã¦ã„ã‚‹) ãŒå­˜åœ¨ã™ã‚‹ã€ã¨ã„ã†ç‚¹ã‚’é™¤ã„ã¦ã€‚
</p>

<p class="lisp"><a name="%_idx_5364"></a>(define (unify-match p1 p2 frame)
  (cond ((eq? frame 'failed) 'failed)
        ((equal? p1 p2) frame)
        ((var? p1) (extend-if-possible p1 p2 frame))
        ((var? p2) (extend-if-possible p2 p1 frame))  <em>; ***</em>
        ((and (pair? p1) (pair? p2))
         (unify-match (cdr p1)
                      (cdr p2)
                      (unify-match (car p1)
                                   (car p2)
                                   frame)))
        (else 'failed)))
</p>

<p class="orig" lang="en">
In unification, as in one-sided pattern matching, we want to accept a
proposed extension of the frame only if it is consistent with existing
bindings.  The procedure <tt>extend-if-possible</tt> used in unification
is the same as the <tt>extend-if-consistent</tt> used in pattern matching
except for two special checks, marked ``<tt>***</tt>'' in the program
below.  In the first case, if the variable we are trying to match is
not bound, but the value we are trying to match it with
is itself a (different) variable, it is
necessary to check to see if the value is bound, and if so, to match
its value.  If both parties to the match are unbound, we may bind
either to the other.</p>

<p class="trans" lang="ja">
ãƒ¦ãƒ‹ãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ã¯ã€ç‰‡å´ã ã‘ã®ãƒ‘ã‚¿ãƒ³ãƒ»ãƒãƒƒãƒãƒ³ã‚°ã«ãŠã‘ã‚‹ã®ã¨åŒæ§˜ã«ã€æ—¢å­˜ã®æŸç¸›ã¨æ•´åˆæ€§ãŒå–ã‚Œã¦ã„ã‚‹å ´åˆã«ã®ã¿ã€ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã€ææ¡ˆã•ã‚ŒãŸæ‹¡å¼µã‚’å—ã‘å…¥ã‚Œã‚‹ã‚ˆã†ã«ã—ãŸã„ã€‚
ãƒ¦ãƒ‹ãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ä½¿ã‚ã‚Œã‚‹ <tt>extend-if-possible</tt> ã¨ã„ã†æ‰‹ç¶šãã¯ã€ä¸‹è¨˜ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ãŠã„ã¦ &ldquo;<tt>***</tt>&rdquo; ã¨ã„ã†å°ã®ã¤ã„ãŸäºŒã¤ã®ç‰¹åˆ¥ãªæ¤œæŸ»ã‚’é™¤ã„ã¦ã€ãƒ‘ã‚¿ãƒ³ãƒ»ãƒãƒƒãƒãƒ³ã‚°ã§ä½¿ã‚ã‚Œã‚‹ <tt>extend-if-consistent</tt> ã¨åŒã˜ã§ã‚ã‚‹ã€‚
1ç•ªç›®ã®å ´åˆã§ã¯ã€ã‚‚ã—ã€ãƒãƒƒãƒã•ã›ã‚ˆã†ã¨ã—ã¦ã„ã‚‹å¤‰æ•°ãŒæŸç¸›ã•ã‚Œã¦ã„ãªã„ã‚‚ã®ã®ã€ãã®å¤‰æ•°ã«ãƒãƒƒãƒã•ã›ã‚ˆã†ã¨ã—ã¦ã„ã‚‹å€¤ãã‚Œè‡ªä½“ãŒ (åˆ¥ã®) å¤‰æ•°ãªã®ã§ã‚ã‚Œã°ã€ãã®å€¤ãŒæŸç¸›ã•ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’èª¿ã¹ã‚‹å¿…è¦ãŒã‚ã‚Šã€ã‚‚ã—æŸç¸›ã•ã‚Œã¦ã„ã‚Œã°ã€ãã®å€¤ã¨ãƒãƒƒãƒã•ã›ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
ã‚‚ã—ã€ãƒãƒƒãƒã«å¯¾ã™ã‚‹åŒæ–¹ã®å´ãŒæœªæŸç¸›ãªã‚‰ã€ã©ã¡ã‚‰ã‹ã‚’ä»–æ–¹ã«æŸç¸›ã—ã¦ã‚‚ã‚ˆã„ã€‚
</p>

<p class="orig" lang="en">
The second check deals with attempts to bind a variable to a pattern
that includes that variable.  Such a situation can occur whenever a
variable is repeated in both patterns.  Consider, for example,
unifying the two patterns <tt>(?x ?x)</tt> and <tt>(?y
&lt;<em>expression involving <tt>?y</tt></em>&gt;)</tt> in a frame where both <tt>?x</tt>
and <tt>?y</tt> are unbound.  First <tt>?x</tt> is matched
against <tt>?y</tt>, making a binding of <tt>?x</tt> to <tt>?y</tt>.  Next, the same <tt>?x</tt> is matched against the given expression
involving <tt>?y</tt>.
Since <tt>?x</tt> is already bound to <tt>?y</tt>, this
results in matching <tt>?y</tt> against the expression.
If we think of the
unifier as finding a set of values for the pattern variables that make
the patterns the same, then these patterns imply instructions to find
a <tt>?y</tt> such that <tt>?y</tt> is equal to the expression involving <tt>?y</tt>.
There is no general method for solving such
equations, so we reject such bindings; these cases are recognized by
the predicate <tt>depends-on?</tt>.<a name="call_footnote_Temp_700" href="#footnote_Temp_700"><sup><small>80</small></sup></a>
On the other hand, we do not want to reject attempts
to bind a variable to itself.  For example, consider unifying <tt>(?x ?x)</tt>
and <tt>(?y ?y)</tt>.  The second attempt to bind <tt>?x</tt> to <tt>?y</tt> matches <tt>?y</tt> (the stored value of <tt>?x</tt>) against <tt>?y</tt>
(the new value of <tt>?x</tt>).  This is taken care of by the <tt>equal?</tt> clause
of <tt>unify-match</tt>.</p>

<p class="trans" lang="ja">
2ç•ªç›®ã®æ¤œæŸ»ã¯ã€å¤‰æ•°ã‚’ã€ãã®å¤‰æ•°ã‚’å«ã‚€ãƒ‘ã‚¿ãƒ³ã¸ã¨æŸç¸›ã™ã‚‹è©¦ã¿ã‚’å–ã‚Šæ‰±ã†ã€‚
ãã†ã—ãŸçŠ¶æ³ã¯ã€å¤‰æ•°ãŒåŒæ–¹ã®ãƒ‘ã‚¿ãƒ³ã§ç¹°ã‚Šè¿”ã•ã‚Œã‚‹å ´åˆã«ã¯ã„ã¤ã§ã‚‚èµ·ã“ã‚Šå¾—ã‚‹ã€‚
ãŸã¨ãˆã°ã€<tt>?x</tt> ã¨ <tt>?y</tt> ã®åŒæ–¹ãŒæŸç¸›ã•ã‚Œã¦ã„ãªã„ãƒ•ãƒ¬ãƒ¼ãƒ ã«ãŠã„ã¦ã€<tt>(?x ?x)</tt> ãŠã‚ˆã³ <tt>(?y &lt;<em class="en"><tt>?y</tt> ã‚’å«ã‚€å¼</em>&gt;)</tt> ã¨ã„ã†äºŒã¤ã®ãƒ‘ã‚¿ãƒ³ã‚’ãƒ¦ãƒ‹ãƒ•ã‚¡ã‚¤ã™ã‚‹ã“ã¨ã‚’ã€è€ƒãˆã‚ˆã†ã€‚
ã¾ãšã€<tt>?x</tt> ã‚’ <tt>?y</tt> ã«å¯¾ã—ã¦ãƒãƒƒãƒã•ã›ã€<tt>?x</tt> ã® <tt>?y</tt> ã¸ã®æŸç¸›ã‚’ä½œã‚Šå‡ºã™ã€‚
æ¬¡ã«ã€<tt>?y</tt> ã‚’å«ã‚€ã€ä¸ãˆã‚‰ã‚ŒãŸå¼ã«å¯¾ã—ã¦ã€åŒã˜<tt>?x</tt> ã‚’ãƒãƒƒãƒã•ã›ã‚‹ã€‚
<tt>?x</tt> ã¯æ—¢ã« <tt>?y</tt> ã«æŸç¸›ã•ã‚Œã¦ã„ã‚‹ã‹ã‚‰ã€ã“ã‚Œã¯ã€<tt>?y</tt> ã‚’å½“è©²ã®å¼ã«å¯¾ã—ã¦ãƒãƒƒãƒã•ã›ã‚‹ã¨ã„ã†çµæœã«ãªã‚‹ã€‚
ã‚‚ã—ã€ãƒ¦ãƒ‹ãƒ•ã‚¡ã‚¤ã‚¢ã®ã“ã¨ã‚’ã€ãƒ‘ã‚¿ãƒ³åŒå£«ã‚’ç­‰ã—ãã™ã‚‹ã‚ˆã†ãªã€ãƒ‘ã‚¿ãƒ³å¤‰æ•°ã«å¯¾ã™ã‚‹å€¤ã®é›†åˆã‚’æ±‚ã‚ã¦ã„ã‚‹ã®ã ã¨è¦‹ãªã™ãªã‚‰ã€ã“ã‚Œã‚‰ã®ãƒ‘ã‚¿ãƒ³åŒå£«ã¯ã€<tt>?y</tt> ã‚’å«ã‚€å¼ã« <tt>?y</tt> ãŒç­‰ã—ããªã‚‹ã‚ˆã†ãª <tt>?y</tt> ã‚’æ±‚ã‚ã‚ˆã€ã¨ã„ã†å‘½ä»¤ã‚’æš—ç¤ºã™ã‚‹ã€‚
ãã†ã—ãŸæ–¹ç¨‹å¼ã‚’è§£ããŸã‚ã®ä¸€èˆ¬çš„æ‰‹æ³•ã¯å­˜åœ¨ã›ãšã€ãã‚Œã‚†ãˆã€ç§ãŸã¡ã¯ã€ãã†ã„ã£ãŸæŸç¸›ã‚’æ‹’çµ¶ã™ã‚‹ã€‚ã“ã‚Œã‚‰ã®å ´åˆã¯ã€<tt>depends-on?</tt> ã¨ã„ã†è¿°èªã«ã‚ˆã£ã¦èªè­˜ã•ã‚Œã‚‹<a href="#footnote_Temp_700"><sup><small>80</small></sup></a>ã€‚
ä¸€æ–¹ã€å¤‰æ•°ã‚’ãã®å¤‰æ•°è‡ªèº«ã«æŸç¸›ã™ã‚‹è©¦ã¿ã¯ã€æ‹’çµ¶ã—ãŸããªã„ã€‚
ãŸã¨ãˆã°ã€<tt>(?x ?x)</tt> ã¨ <tt>(?y ?y)</tt> ã‚’ãƒ¦ãƒ‹ãƒ•ã‚¡ã‚¤ã™ã‚‹ã“ã¨ã‚’è€ƒãˆã‚ˆã†ã€‚
<tt>?x</tt> ã‚’ <tt>?y</tt> ã«æŸç¸›ã—ã‚ˆã†ã¨ã„ã†2å›ç›®ã®è©¦ã¿ã¯ã€<tt>?y</tt> (<tt>?x</tt> ã®ã€æ ¼ç´ã•ã‚ŒãŸå€¤) ã‚’ã€<tt>?y</tt> (<tt>?x</tt> ã®æ–°ãŸãªå€¤) ã«å¯¾ã—ã¦ãƒãƒƒãƒã•ã›ã‚‹ã€‚
ã“ã‚Œã¯ã€<tt>unify-match</tt> ã® <tt>equal?</tt> ã«ã‚ˆã£ã¦å‡¦ç†ã•ã‚Œã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_5370"></a>(define (extend-if-possible var val frame)
  (let ((binding (binding-in-frame var frame)))
    (cond (binding
           (unify-match
            (binding-value binding) val frame))
          ((var? val)                      <em>; ***</em>
           (let ((binding (binding-in-frame val frame)))
             (if binding
                 (unify-match
                  var (binding-value binding) frame)
                 (extend var val frame))))
          ((depends-on? val var frame)     <em>; ***</em>
           'failed)
          (else (extend var val frame)))))
</p>

<p class="orig" lang="en">
<tt>Depends-on?</tt> is a predicate that tests whether an expression
proposed to be the value of a pattern variable depends on the variable.
This must be done relative to the current frame because the expression
may contain occurrences of a variable that already has a value that
depends on our test variable.  The structure of <tt>depends-on?</tt> is a
simple recursive tree walk in which we substitute for the values of
variables whenever necessary.</p>

<p class="trans" lang="ja">
<tt>depends-on?</tt> ã¯ã€ã‚ã‚‹ãƒ‘ã‚¿ãƒ³å¤‰æ•°ã®å€¤ã¨ãªã‚‹ã¹ãã ã¨ææ¡ˆã•ã‚Œã¦ã„ã‚‹å¼ãŒã€ãã®å¤‰æ•°ã«ä¾å­˜ã™ã‚‹ã‹å¦ã‹ã‚’æ¤œæŸ»ã™ã‚‹ã€‚
ã“ã‚Œã¯ã€ç¾åœ¨ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã«é–¢ã—ã¦è¡Œã‚ã‚Œãªãã¦ã¯ãªã‚‰ãªã„ã€‚ãªãœãªã‚‰ã€ãƒ†ã‚¹ãƒˆå¤‰æ•°ã«ä¾å­˜ã™ã‚‹å€¤ã‚’æ—¢ã«æœ‰ã—ã¦ã„ã‚‹ã‚ˆã†ãªå¤‰æ•°ã®å‡ºç¾ã‚’ã€ãã®å¼ãŒå«ã‚“ã§ã„ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã‹ã‚‰ã§ã‚ã‚‹ã€‚
<tt>depends-on?</tt> ã®æ§‹é€ ã¯ã€å¿…è¦ãªã¨ãã¯ã„ã¤ã§ã‚‚å¤‰æ•°ã®å€¤ã‚’ç½®ãæ›ãˆã‚‹ã‚ˆã†ãªã€å˜ç´”ã§å†å¸°çš„ãªæœ¨ã®<ruby><rb>æ­©é“</rb><rp> (</rp><rt>ã‚¦ã‚©ãƒ¼ã‚¯</rt><rp>) </rp></ruby>ã§ã‚ã‚‹ã€‚
</p>

<p class="lisp">(define (depends-on? exp var frame)
  (define (tree-walk e)
    (cond ((var? e)
           (if (equal? var e)
               true
               (let ((b (binding-in-frame e frame)))
                 (if b
                     (tree-walk (binding-value b))
                     false))))
          ((pair? e)
           (or (tree-walk (car e))
               (tree-walk (cdr e))))
          (else false)))
  (tree-walk exp))
</p>

<a name="%_sec_4.4.4.5"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_4.4.4.5">4.4.4.5  Maintaining the Data Base</a></h4>
<h4 class="trans" lang="ja">4.4.4.5 ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’ä¿å®ˆã™ã‚‹</h4>

<p class="orig" lang="en">
<a name="%_idx_5372"></a>
<a name="%_idx_5374"></a><a name="%_idx_5376"></a>One important problem in designing logic programming languages is that
of arranging things so that as few irrelevant data-base entries as
possible will be examined in checking a given pattern.  In our
system, in addition to storing all assertions in one big stream,
we store all assertions whose <tt>car</tt>s are constant symbols
in separate streams, in a table indexed by the symbol.  To fetch an
assertion that may match a pattern, we first check to see if the <tt>car</tt> of the pattern is a constant symbol.  If so, we return (to be
tested using the matcher) all the stored assertions that have the same
<tt>car</tt>.  If the pattern's <tt>car</tt> is not a constant symbol, we
return all the stored assertions.  Cleverer methods could also take
advantage of information in the frame, or try also to optimize the
case where the <tt>car</tt> of the pattern is not a constant symbol.  We
avoid building our criteria for indexing (using the <tt>car</tt>,
handling only the case of constant symbols) into the program; instead
we call on predicates and selectors that embody our criteria.</p>

<p class="trans" lang="ja">
è«–ç†ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã‚’è¨­è¨ˆã™ã‚‹éš›ã®ä¸€ã¤ã®é‡è¦ãªå•é¡Œã¯ã€ä¸ãˆã‚‰ã‚ŒãŸãƒ‘ã‚¿ãƒ³ã‚’èª¿ã¹ã‚‹éš›ã«ã¯ã€ç„¡é–¢ä¿‚ãªãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒ»ã‚¨ãƒ³ãƒˆãƒªã¯ã§ãã‚‹ã ã‘å°‘æ•°ã®ã‚‚ã®ã ã‘ã‚’æ¤œè¨ã™ã‚Œã°æ¸ˆã‚€ã‚ˆã†ã«ã€ç‰©äº‹ã‚’æ•´ãˆã¦ãŠãã€ã¨ã„ã†å•é¡Œã§ã‚ã‚‹ã€‚
ç§ãŸã¡ã®ã‚·ã‚¹ãƒ†ãƒ ã§ã¯ã€ä¸€ã¤ã®å¤§ããªã‚¹ãƒˆãƒªãƒ¼ãƒ ã®ä¸­ã«ã™ã¹ã¦ã®è¨€æ˜ã‚’æ ¼ç´ã™ã‚‹ã“ã¨ã«åŠ ãˆã¦ã€<tt>car</tt> ãŒå®šæ•°è¨˜å·ã§ã‚ã‚‹ã‚ˆã†ãªã™ã¹ã¦ã®è¨€æ˜ã‚’ã€ãã®è¨˜å·ã«ã‚ˆã‚Šç´¢å¼•ã¥ã‘ãŒãªã•ã‚ŒãŸè¡¨ã®ä¸­ã®åˆ¥ã€…ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«æ ¼ç´ã™ã‚‹ã€‚
ãƒ‘ã‚¿ãƒ³ã«ãƒãƒƒãƒã™ã‚‹ã‹ã‚‚ã—ã‚Œãªã„è¨€æ˜ã‚’å–ã£ã¦ãã‚‹ã«ã¯ã€ã¾ãšã€ãã®ãƒ‘ã‚¿ãƒ³ã® <tt>car</tt> ãŒå®šæ•°è¨˜å·ã‹å¦ã‹ã‚’èª¿ã¹ã‚‹ã€‚
ã‚‚ã—ãã†ã§ã‚ã‚Œã°ã€åŒã˜ <tt>car</tt> ã‚’æœ‰ã™ã‚‹ã€ã™ã¹ã¦ã®æ ¼ç´ã•ã‚Œã¦ã„ã‚‹è¨€æ˜ã‚’ã€(ãƒãƒƒãƒãƒ£ã‚’ç”¨ã„ã¦æ¤œæŸ»ã•ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã«) è¿”ã™ã€‚
ã‚‚ã—ã€ãƒ‘ã‚¿ãƒ³ã® <tt>car</tt> ãŒå®šæ•°è¨˜å·ã§ãªã‘ã‚Œã°ã€ã™ã¹ã¦ã®æ ¼ç´ã•ã‚Œã¦ã„ã‚‹è¨€æ˜ã‚’è¿”ã™ã€‚
ã‚ˆã‚Šè³¢ã„æ–¹æ³•ã§ã‚ã‚Œã°ã€ãƒ•ãƒ¬ãƒ¼ãƒ å†…ã®æƒ…å ±ã‚’ã‚‚åˆ©ç”¨ã§ãã‚‹ã§ã‚ã‚ã†ã—ã€ã‚ã‚‹ã„ã¯ã€ãƒ‘ã‚¿ãƒ³ã® <tt>car</tt> ãŒå®šæ•°è¨˜å·ã§ãªã„å ´åˆã‚’ã‚‚æœ€é©åŒ–ã—ã‚ˆã†ã¨è©¦ã¿ã‚‹ã“ã¨ã‚‚ã§ãã‚‹ã ã‚ã†ã€‚
ç§ãŸã¡ã¯ã€(<tt>car</tt> ã‚’ç”¨ã„ãŸã€å®šæ•°è¨˜å·ã®å ´åˆã ã‘ã‚’æ‰±ã†) ç´¢å¼•ã¥ã‘ã®ãŸã‚ã®ã€è‡ªåˆ†ã®åŸºæº–ã‚’æ§‹ç¯‰ã™ã‚‹ã“ã¨ã‚’é¿ã‘ã€ãã®ä»£ã‚ã‚Šã€è‡ªåˆ†ã®åŸºæº–ã‚’å…·ç¾åŒ–ã™ã‚‹ã‚ˆã†ãªã€è¿°èªã¨ã‚»ãƒ¬ã‚¯ã‚¿ã‚’é ¼ã‚Šã«ã—ã¦ã„ã‚‹ã€‚
</p>

<p class="lisp">(define THE-ASSERTIONS the-empty-stream)
<a name="%_idx_5378"></a>(define (fetch-assertions pattern frame)
  (if (use-index? pattern)
      (get-indexed-assertions pattern)
      (get-all-assertions)))
(define (get-all-assertions) THE-ASSERTIONS)
(define (get-indexed-assertions pattern)
  (get-stream (index-key-of pattern) 'assertion-stream))
</p>

<p class="orig" lang="en"><tt>Get-stream</tt> looks up a stream in the table and returns an empty
stream if nothing is stored there.</p>

<p class="trans" lang="ja">
<tt>get-stream</tt> ã¯ã€è¡¨ã«ã‚ã‚‹ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’èª¿ã¹ã¦ã€ã‚‚ã—ãã“ã«ä½•ã‚‚æ ¼ç´ã•ã‚Œã¦ã„ãªã‘ã‚Œã°ã€ç©ºã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’è¿”ã™ã€‚
</p>

<p class="lisp">(define (get-stream key1 key2)
  (let ((s (get key1 key2)))
    (if s s the-empty-stream)))
</p>

<p class="orig" lang="en">
Rules are stored similarly, using the <tt>car</tt> of the rule
conclusion.  Rule conclusions are arbitrary patterns, however, so they
differ from assertions in that they can contain variables.  A pattern
whose <tt>car</tt> is a constant symbol can match rules whose conclusions
start with a variable as well as rules whose conclusions have the same
<tt>car</tt>.  Thus, when fetching rules that might match a pattern whose
<tt>car</tt> is a constant symbol we fetch all rules whose conclusions
start with a variable as well as those whose conclusions have the same
<tt>car</tt> as the pattern.  For this purpose we store all rules whose
conclusions start with a variable in a separate stream in our table,
indexed by the symbol <tt>?</tt>.</p>

<p class="trans" lang="ja">
è¦å‰‡ã‚‚åŒæ§˜ã«ã€è¦å‰‡å¸°çµéƒ¨ã® <tt>car</tt> ã‚’åˆ©ç”¨ã—ã¦ã€æ ¼ç´ã•ã‚Œã‚‹ã€‚
ã—ã‹ã—ã€è¦å‰‡å¸°çµéƒ¨ã¯ä»»æ„ã®ãƒ‘ã‚¿ãƒ³ã§ã‚ã‚Šã€ãã®ãŸã‚ã€è¦å‰‡å¸°çµéƒ¨ã¯ã€å¤‰æ•°ã‚’å«ã‚€ã“ã¨ãŒã§ãã‚‹ã¨ã„ã†ç‚¹ã§ã€è¨€æ˜ã¨ã¯ç•°ãªã‚‹ã€‚
<tt>car</tt> ãŒå®šæ•°è¨˜å·ã§ã‚ã‚‹ã‚ˆã†ãªãƒ‘ã‚¿ãƒ³ã¯ã€å¸°çµéƒ¨ãŒå¤‰æ•°ã§å§‹ã¾ã‚‹è¦å‰‡ã«ãƒãƒƒãƒã—å¾—ã‚‹ã—ã€å¸°çµéƒ¨ãŒåŒã˜ <tt>car</tt> ã‚’æœ‰ã—ã¦ã„ã‚‹ã‚ˆã†ãªè¦å‰‡ã«ã‚‚ãƒãƒƒãƒã—å¾—ã‚‹ã€‚
ã‚ˆã£ã¦ã€<tt>car</tt> ãŒå®šæ•°è¨˜å·ã§ã‚ã‚‹ã‚ˆã†ãªãƒ‘ã‚¿ãƒ³ã¨ãƒãƒƒãƒã™ã‚‹ã‹ã‚‚ã—ã‚Œãªã„è¦å‰‡ã‚’å–ã£ã¦ãã‚‹ã¨ãã«ã¯ã€å¸°çµéƒ¨ãŒå¤‰æ•°ã§å§‹ã¾ã‚‹ã™ã¹ã¦ã®è¦å‰‡ã¨ã€ãã®ãƒ‘ã‚¿ãƒ³ã¨åŒã˜ <tt>car</tt> ã‚’å¸°çµéƒ¨ãŒæœ‰ã—ã¦ã„ã‚‹è¦å‰‡ã¨ã‚’ã€å–ã£ã¦ãã‚‹ã€‚
ã“ã®ç›®çš„ã®ãŸã‚ã€ç§ãŸã¡ã¯ã€å¸°çµéƒ¨ãŒå¤‰æ•°ã§å§‹ã¾ã‚‹ã™ã¹ã¦ã®è¦å‰‡ã‚’ã€è¡¨ã®ä¸­ã®åˆ¥ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ â€”â€” <tt>?</tt> ã¨ã„ã†è¨˜å·ã«ã‚ˆã‚Šç´¢å¼•ã¥ã‘ã•ã‚ŒãŸã‚‚ã®â€”â€”ã«æ ¼ç´ã™ã‚‹ã€‚
</p>

<p class="lisp">(define THE-RULES the-empty-stream)
<a name="%_idx_5380"></a>(define (fetch-rules pattern frame)
  (if (use-index? pattern)
      (get-indexed-rules pattern)
      (get-all-rules)))
(define (get-all-rules) THE-RULES)
(define (get-indexed-rules pattern)
  (stream-append
   (get-stream (index-key-of pattern) 'rule-stream)
   (get-stream '? 'rule-stream)))
</p>

<p class="orig" lang="en">
<tt>Add-rule-or-assertion!</tt> is used by <tt>query-driver-loop</tt> to
add assertions and rules to the data base.  Each item is stored in the
index, if appropriate, and in a stream of all assertions or rules in
the data base.</p>

<p class="trans" lang="ja">
<tt>add-rule-or-assertion!</tt> ã¯ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«è¨€æ˜ã‚„è¦å‰‡ã‚’è¿½åŠ ã™ã‚‹ãŸã‚ã«ã€<tt>query-driver-loop</tt> ã«ã‚ˆã‚Šä½¿ã‚ã‚Œã‚‹ã€‚
å„é …ç›®ã¯ã€ãã‚ŒãŒå¦¥å½“ãªå ´åˆã«ã¯ç´¢å¼•ã«æ ¼ç´ã•ã‚Œã‚‹ã¨ã¨ã‚‚ã«ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å†…ã®å…¨è¨€æ˜ã¾ãŸã¯å…¨è¦å‰‡ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«æ ¼ç´ã•ã‚Œã‚‹ã€‚
</p>


<p class="lisp"><a name="%_idx_5382"></a>(define (add-rule-or-assertion! assertion)
  (if (rule? assertion)
      (add-rule! assertion)
      (add-assertion! assertion)))
(define (add-assertion! assertion)
  (store-assertion-in-index assertion)
  (let ((old-assertions THE-ASSERTIONS))
    (set! THE-ASSERTIONS
          (cons-stream assertion old-assertions))
    'ok))
(define (add-rule! rule)
  (store-rule-in-index rule)
  (let ((old-rules THE-RULES))
    (set! THE-RULES (cons-stream rule old-rules))
    'ok))
</p>

<p class="orig" lang="en">
To actually store an assertion or a rule, we check to see if it can be
indexed.  If so, we store it in the appropriate stream.</p>

<p class="trans" lang="ja">
å®Ÿéš›ã«è¨€æ˜ã¾ãŸã¯è¦å‰‡ã‚’æ ¼ç´ã™ã‚‹ãŸã‚ã«ã¯ã€ãã®è¨€æ˜ã¾ãŸã¯è¦å‰‡ã‚’ç´¢å¼•ã¥ã‘ã‚‰ã‚Œã‚‹ã‹ã©ã†ã‹ã‚’èª¿ã¹ã‚‹ã€‚
ã‚‚ã—ç´¢å¼•ã¥ã‘ã‚‰ã‚Œã‚‹ãªã‚‰ã€ãã®è¨€æ˜ã¾ãŸã¯è¦å‰‡ã‚’é©åˆ‡ãªã‚¹ãƒˆãƒªãƒ¼ãƒ ã«æ ¼ç´ã™ã‚‹ã€‚
</p>

<p class="lisp">(define (store-assertion-in-index assertion)
  (if (indexable? assertion)
      (let ((key (index-key-of assertion)))
        (let ((current-assertion-stream
               (get-stream key 'assertion-stream)))
          (put key
               'assertion-stream
               (cons-stream assertion
                            current-assertion-stream))))))
(define (store-rule-in-index rule)
  (let ((pattern (conclusion rule)))
    (if (indexable? pattern)
        (let ((key (index-key-of pattern)))
          (let ((current-rule-stream
                 (get-stream key 'rule-stream)))
            (put key
                 'rule-stream
                 (cons-stream rule
                              current-rule-stream)))))))
</p>

<p class="orig" lang="en">
The following procedures define how the data-base index is used.  A
pattern (an assertion or a rule conclusion) will be stored in the
table if it starts with a variable or a constant symbol.</p>

<p class="trans" lang="ja">
ä»¥ä¸‹ã®æ‰‹ç¶šãã¯ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ç´¢å¼•ãŒã©ã®ã‚ˆã†ã«ä½¿ã‚ã‚Œã‚‹ã®ã‹ã‚’å®šç¾©ã—ã¦ã„ã‚‹ã€‚
ãƒ‘ã‚¿ãƒ³ (è¨€æ˜ã¾ãŸã¯è¦å‰‡å¸°çµéƒ¨) ã¯ã€å¤‰æ•°ã¾ãŸã¯å®šæ•°è¨˜å·ã‹ã‚‰å§‹ã¾ã‚‹å ´åˆã€è¡¨ã«æ ¼ç´ã•ã‚Œã‚‹ã ã‚ã†ã€‚
</p>

<p class="lisp">(define (indexable? pat)
  (or (constant-symbol? (car pat))
      (var? (car pat))))
</p>

<p class="orig" lang="en">The key under which a pattern is stored in the table is either <tt>?</tt> (if it starts with a variable) or the constant symbol with which
it starts.</p>

<p class="trans" lang="ja">
è¡¨å†…ã§ãã®ã‚­ãƒ¼ã®ã‚‚ã¨ã«ãƒ‘ã‚¿ãƒ³ãŒæ ¼ç´ã•ã‚Œã‚‹ã€ã¨ã„ã†ã‚­ãƒ¼ã¯ã€<tt>?</tt> (ãã®ãƒ‘ã‚¿ãƒ³ãŒå¤‰æ•°ã‹ã‚‰å§‹ã¾ã‚‹å ´åˆ) ã‹ã€ã¾ãŸã¯ã€ãã®ãƒ‘ã‚¿ãƒ³ã®å§‹ã¾ã‚Šã®å®šæ•°è¨˜å·ã§ã‚ã‚‹ã€‚
</p>


<p class="lisp">(define (index-key-of pat)
  (let ((key (car pat)))
    (if (var? key) '? key)))
</p>

<p class="orig" lang="en">The index will be used to retrieve items that might match a pattern if
the pattern starts with a constant symbol.</p>

<p class="trans" lang="ja">
ãƒ‘ã‚¿ãƒ³ãŒå®šæ•°è¨˜å·ã‹ã‚‰å§‹ã¾ã‚‹å ´åˆã«ã€ãã®ãƒ‘ã‚¿ãƒ³ã«ãƒãƒƒãƒã™ã‚‹ã‹ã‚‚ã—ã‚Œãªã„é …ç›®ã‚’å–ã‚Šå‡ºã™ãŸã‚ã«ã€ç´¢å¼•ãŒä½¿ã‚ã‚Œã‚‹ã ã‚ã†ã€‚
</p>

<p class="lisp">(define (use-index? pat)
  (constant-symbol? (car pat)))
</p>

<p class="orig" lang="en">
<a name="%_thm_4.70"></a>
<b>Exercise 4.70.</b>  What is the purpose of the <tt>let</tt> bindings in the procedures <tt>add-assertion!</tt> and <tt>add-rule!</tt> ?  What would be wrong with the
following implementation of <tt>add-assertion!</tt> ?
Hint: Recall the definition of the infinite stream of ones in
section <a href="24_sec3_5.html#%_sec_3.5.2">3.5.2</a>: <tt>(define ones (cons-stream 1 ones))</tt>.</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.70.</b> <tt>add-assertion!</tt> ãŠã‚ˆã³ <tt>add-rule!</tt> ã¨ã„ã†æ‰‹ç¶šãã«ãŠã‘ã‚‹ <tt>let</tt> æŸç¸›ã®ç›®çš„ã¯ä½•ã ã‚ã†ã‹?
<tt>add-assertion!</tt> ã®ä»¥ä¸‹ã®å®Ÿè£…ã®ã€ä½•ãŒä¸å…·åˆãªã®ã ã‚ã†ã‹?
ãƒ’ãƒ³ãƒˆ: <a href="24_sec3_5.html#%_sec_3.5.2">3.5.2</a>ç¯€ã®ã€1ã®ç„¡é™ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®å®šç¾©ã€ã™ãªã‚ã¡ã€
<tt>(define ones (cons-stream 1 ones))</tt>
ã‚’ã€æ€ã„å‡ºã›ã€‚
</p>

<p class="lisp">(define (add-assertion! assertion)
  (store-assertion-in-index assertion)
  (set! THE-ASSERTIONS
        (cons-stream assertion THE-ASSERTIONS))
  'ok)
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_4.4.4.6"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_4.4.4.6">4.4.4.6  Stream Operations</a></h4>
<h4 class="trans" lang="ja">4.4.4.6 ã‚¹ãƒˆãƒªãƒ¼ãƒ æ¼”ç®—</h4>

<p class="orig" lang="en">
<a name="%_idx_5384"></a>
The query system uses a few stream operations that were not presented
in chapter 3.</p>

<p class="trans" lang="ja">
ã‚¯ã‚¨ãƒªãƒ»ã‚·ã‚¹ãƒ†ãƒ ã¯ã€3ç« ã§ã¯æç¤ºã•ã‚Œãªã‹ã£ãŸå°‘æ•°ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ æ¼”ç®—ã‚’ç”¨ã„ã‚‹ã€‚
</p>

<p class="orig" lang="en">
<tt>Stream-append-delayed</tt> and <tt>interleave-delayed</tt>
are just like <tt>stream-append</tt> and <tt>interleave</tt>
(section <a href="24_sec3_5.html#%_sec_3.5.3">3.5.3</a>),
except that they take a delayed argument (like the <tt>integral</tt>
procedure in section <a href="24_sec3_5.html#%_sec_3.5.4">3.5.4</a>).
This postpones looping in some cases (see exercise <a href="#%_thm_4.71">4.71</a>).</p>

<p class="trans" lang="ja">
<tt>stream-append-delayed</tt> ãŠã‚ˆã³ <tt>interleave-delayed</tt> ã¯ã€ã¾ã•ã« <tt>stream-append</tt> ãŠã‚ˆã³ <tt>interleave</tt> (<a href="24_sec3_5.html#%_sec_3.5.3">3.5.3</a>ç¯€) ã«ä¼¼ã¦ã„ã‚‹â€”â€”ãŸã ã—ã€(<a href="24_sec3_5.html#%_sec_3.5.4">3.5.4</a>ç¯€ã® <tt>integral</tt> æ‰‹ç¶šãã¨åŒæ§˜ã«) é…å»¶ã•ã›ãŸå¼•æ•°ã‚’ã¨ã‚‹ã€ã¨ã„ã†ç‚¹ã¯é™¤ã„ã¦ã€‚
ã“ã‚Œã¯ã€ã‚ã‚‹ç¨®ã®å ´åˆã«ãŠã„ã¦ãƒ«ãƒ¼ãƒ—ã‚’é…å»¶ã•ã›ã‚‹ (ç·´ç¿’å•é¡Œ<a href="#%_thm_4.71">4.71</a>ã‚’å‚ç…§)ã€‚
</p>

<p class="lisp"><a name="%_idx_5386"></a>(define (stream-append-delayed s1 delayed-s2)
  (if (stream-null? s1)
      (force delayed-s2)
      (cons-stream
       (stream-car s1)
       (stream-append-delayed (stream-cdr s1) delayed-s2))))
<a name="%_idx_5388"></a>(define (interleave-delayed s1 delayed-s2)
  (if (stream-null? s1)
      (force delayed-s2)
      (cons-stream
       (stream-car s1)
       (interleave-delayed (force delayed-s2)
                           (delay (stream-cdr s1))))))
</p>

<p class="orig" lang="en">
<tt>Stream-flatmap</tt>, which is used throughout the query evaluator to
map a procedure over a stream of frames and combine the resulting
streams of frames, is the stream analog of the <tt>flatmap</tt> procedure
introduced for ordinary lists in section <a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a>.
Unlike ordinary <tt>flatmap</tt>, however, we accumulate the streams with
an interleaving process, rather than simply appending them (see
exercises <a href="#%_thm_4.72">4.72</a> and  <a href="#%_thm_4.73">4.73</a>).</p>

<p class="trans" lang="ja">
<tt>stream-flatmap</tt> â€”â€”ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«å¯¾ã—ã¦æ‰‹ç¶šãã‚’ãƒãƒƒãƒ—ã—ã¦ã€çµæœã¨ã—ã¦ç”Ÿã˜ã‚‹ã€ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ åŒå£«ã‚’çµåˆã™ã‚‹ãŸã‚ã«ã€ã‚¯ã‚¨ãƒªè©•ä¾¡å™¨ã®å…¨ä½“ã«ã‚ãŸã£ã¦ä½¿ã‚ã‚Œã‚‹â€”â€”ã¯ã€<a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a>ç¯€ã§æ™®é€šã®ãƒªã‚¹ãƒˆã«é–¢ã—ã¦å°å…¥ã—ãŸ <tt>flatmap</tt> æ‰‹ç¶šãã®ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ç‰ˆã®é¡ä¼¼ç‰©ã§ã‚ã‚‹ã€‚
ã—ã‹ã—ã€æ™®é€šã® <tt>flatmap</tt> ã¨ã¯é•ã£ã¦ã€å˜ç´”ã«ã‚¹ãƒˆãƒªãƒ¼ãƒ åŒå£«ã‚’ç¹‹ã’ã‚‹ã®ã§ã¯ãªãã€é–“ã«æŒŸã¾ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã¨ã¨ã‚‚ã«ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’è“„ç©ã™ã‚‹ (ç·´ç¿’å•é¡Œ<a href="#%_thm_4.72">4.72</a>ã¨ç·´ç¿’å•é¡Œ<a href="#%_thm_4.73">4.73</a>ã‚’å‚ç…§)ã€‚
</p>

<p class="lisp"><a name="%_idx_5390"></a>(define (stream-flatmap proc s)
  (flatten-stream (stream-map proc s)))
<a name="%_idx_5392"></a>(define (flatten-stream stream)
  (if (stream-null? stream)
      the-empty-stream
      (interleave-delayed
       (stream-car stream)
       (delay (flatten-stream (stream-cdr stream))))))
</p>

<p class="orig" lang="en">
The evaluator also uses the following simple procedure
to generate a stream consisting of a single element:</p>

<p class="trans" lang="ja">
è©•ä¾¡å™¨ã¯ã€å˜ä¸€è¦ç´ ã‹ã‚‰ãªã‚‹ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ç”Ÿæˆã™ã‚‹ãŸã‚ã«ã€ä»¥ä¸‹ã®å˜ç´”ãªæ‰‹ç¶šãã‚‚ç”¨ã„ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_5394"></a>(define (singleton-stream x)
  (cons-stream x the-empty-stream))
</p>

<a name="%_sec_4.4.4.7"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_4.4.4.7">4.4.4.7  Query Syntax Procedures</a></h4>
<h4 class="trans" lang="ja">4.4.4.7 ã‚¯ã‚¨ãƒªã®æ–‡æ³•æ‰‹ç¶šã</h4>

<p class="orig" lang="en">
<a name="%_idx_5396"></a>
<tt>Type</tt> and <tt>contents</tt>, used by <tt>qeval</tt>
(section <a href="#%_sec_4.4.4.2">4.4.4.2</a>), specify that a
special form is identified by the symbol in its <tt>car</tt>.
They are the same as the <tt>type-tag</tt> and <tt>contents</tt> procedures in
section <a href="17_sec2_4.html#%_sec_2.4.2">2.4.2</a>, except for the error message.</p>

<p class="trans" lang="ja">
<tt>tyoe</tt> ã¨ <tt>contents</tt> â€”â€” <tt>qeval</tt> ã«ã‚ˆã‚Šä½¿ã‚ã‚Œã‚‹ (<a href="#%_sec_4.4.4.2">4.4.4.2</a>ç¯€) â€”â€”ã¯ã€ç‰¹æ®Šå½¢å¼ã¯ãã® <tt>car</tt> ã«ã‚ã‚‹è¨˜å·ã«ã‚ˆã‚Šè­˜åˆ¥ã•ã‚Œã‚‹ã®ã ã€ã¨ã„ã†ã“ã¨ã‚’è¦å®šã—ã¦ã„ã‚‹ã€‚
ã“ã‚Œã‚‰ã¯ã€ã‚¨ãƒ©ãƒ¼ãƒ»ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ä»¥å¤–ã¯ã€<a href="17_sec2_4.html#%_sec_2.4.2">2.4.2</a>ç¯€ã® <tt>type-tag</tt> æ‰‹ç¶šããŠã‚ˆã³ <tt>contents</tt> æ‰‹ç¶šãã¨åŒã˜ã§ã‚ã‚‹ã€‚
</p>

<p class="lisp">(define (type exp)
  (if (pair? exp)
      (car exp)
      (error &quot;Unknown expression TYPE&quot; exp)))
(define (contents exp)
  (if (pair? exp)
      (cdr exp)
      (error &quot;Unknown expression CONTENTS&quot; exp)))
</p>

<p class="orig" lang="en">
The following procedures, used by <tt>query-driver-loop</tt>
(in section <a href="#%_sec_4.4.4.1">4.4.4.1</a>), specify
that rules and assertions are added to the data base by expressions of
the form <tt>(assert! &lt;<em>rule-or-assertion</em>&gt;):</tt></p>

<p class="trans" lang="ja">
ä»¥ä¸‹ã®æ‰‹ç¶šãâ€”â€” (<a href="#%_sec_4.4.4.1">4.4.4.1</a>ç¯€ã«ãŠã‘ã‚‹) <tt>query-driver-loop</tt> ã«ã‚ˆã‚Šä½¿ã‚ã‚Œã‚‹â€”â€”ã¯ã€è¦å‰‡ã‚„è¨€æ˜ãŒã€
<tt>(assert! &lt;<em class="en">rule-or-assertion</em>&gt;)</tt>
ã¨ã„ã†å½¢ã®å¼ã«ã‚ˆã£ã¦ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«è¿½åŠ ã•ã‚Œã‚‹ã€ã¨ã„ã†ã“ã¨ã‚’è¦å®šã—ã¦ã„ã‚‹ã€‚
</p>

<p class="lisp">(define (assertion-to-be-added? exp)
  (eq? (type exp) 'assert!))
(define (add-assertion-body exp)
  (car (contents exp)))
</p>

<p class="orig" lang="en">
Here are the syntax definitions for the <tt>and</tt>,  <tt>or</tt>,  <tt>not</tt>, and <tt>lisp-value</tt> special forms
(section <a href="#%_sec_4.4.4.2">4.4.4.2</a>):</p>

<p class="trans" lang="ja">
<tt>and</tt> ã¨ <tt>or</tt> ã¨ <tt>not</tt> ã¨ <tt>lisp-value</tt> ã¨ã„ã†ç‰¹æ®Šå½¢å¼ (<a href="#%_sec_4.4.4.2">4.4.4.2</a>ç¯€) ã«ã¤ã„ã¦ã®æ–‡æ³•å®šç¾©ã‚’ã€ã“ã“ã«ç¤ºã™ã€‚
</p>

<p class="lisp">(define (empty-conjunction? exps) (null? exps))
(define (first-conjunct exps) (car exps))
(define (rest-conjuncts exps) (cdr exps))
(define (empty-disjunction? exps) (null? exps))
(define (first-disjunct exps) (car exps))
(define (rest-disjuncts exps) (cdr exps))
(define (negated-query exps) (car exps))
(define (predicate exps) (car exps))
(define (args exps) (cdr exps))
</p>

<p class="orig" lang="en">
The following three procedures define the syntax of rules:</p>

<p class="trans" lang="ja">
ä»¥ä¸‹ã®ä¸‰ã¤ã®æ‰‹ç¶šãã¯ã€è¦å‰‡ã®æ–‡æ³•ã‚’å®šç¾©ã—ã¦ã„ã‚‹ã€‚
</p>

<p class="lisp">(define (rule? statement)
  (tagged-list? statement 'rule))
(define (conclusion rule) (cadr rule))
(define (rule-body rule)
  (if (null? (cddr rule))
      '(always-true)
      (caddr rule)))
</p>

<p class="orig" lang="en">
<a name="%_idx_5398"></a><a name="%_idx_5400"></a><tt>Query-driver-loop</tt> (section <a href="#%_sec_4.4.4.1">4.4.4.1</a>)
calls <tt>query-syntax-process</tt> to
transform pattern variables in the expression, which have the form
<tt>?symbol</tt>, into the internal format <tt>(? symbol)</tt>.  That is to
say, a pattern such as <tt>(job ?x ?y)</tt> is actually represented
internally by the system as <tt>(job (? x) (? y))</tt>.  This increases
the efficiency of query processing, since it means that the system can
check to see if an expression is a pattern variable by checking
whether the <tt>car</tt> of the expression is the symbol <tt>?</tt>, rather
than having to extract characters from the symbol.  The syntax
transformation is accomplished by the following
procedure:<a name="call_footnote_Temp_702" href="#footnote_Temp_702"><sup><small>81</small></sup></a></p>

<p class="trans" lang="ja">
<tt>query-driver-loop</tt> (<a href="#%_sec_4.4.4.1">4.4.4.1</a>ç¯€) ã¯ã€å¼ã®ä¸­ã®ãƒ‘ã‚¿ãƒ³å¤‰æ•°â€”â€” <tt>?symbol</tt> ã¨ã„ã†å½¢ã§ã‚ã‚‹â€”â€”ã‚’ã€<tt>(? symbol)</tt> ã¨ã„ã†å†…éƒ¨å½¢å¼ã¸ã¨å¤‰å½¢ã™ã‚‹ãŸã‚ã«ã€<tt>query-syntax-process</tt> ã‚’å‘¼ã³å‡ºã™ã€‚
ã¤ã¾ã‚Šã€<tt>(job ?x ?y)</tt> ã®ã‚ˆã†ãªãƒ‘ã‚¿ãƒ³ã¯ã€å®Ÿéš›ã®ã¨ã“ã‚ã€å†…éƒ¨çš„ã«ã¯ã‚·ã‚¹ãƒ†ãƒ ã«ã‚ˆã‚Š <tt>(job (? x) (? y))</tt> ã®ã‚ˆã†ã«è¡¨ç¾ã•ã‚Œã‚‹ã‚ã‘ã ã€‚
ã“ã‚Œã¯ã€ã‚¯ã‚¨ãƒªå‡¦ç†ã®åŠ¹ç‡æ€§ã‚’å‘ä¸Šã•ã›ã‚‹ã€‚ã¨ã„ã†ã®ã‚‚ã€ã“ã‚Œã¯ã€è¨˜å·ã‹ã‚‰æ–‡å­—ã‚’æŠ½å‡ºã—ãªãã¦ã¯ãªã‚‰ãªã„ã®ã§ã¯ãªãã¦ã€ã‚€ã—ã‚ã€å¼ã® <tt>car</tt> ãŒ <tt>?</tt> ã¨ã„ã†è¨˜å·ã‹å¦ã‹ã‚’èª¿ã¹ã‚‹ã“ã¨ã§ã€ãã®å¼ãŒãƒ‘ã‚¿ãƒ³å¤‰æ•°ã‹å¦ã‹ã‚’ã‚·ã‚¹ãƒ†ãƒ ãŒèª¿ã¹ã‚‰ã‚Œã‚‹ã€ã¨ã„ã†ã“ã¨ã‚’æ„å‘³ã™ã‚‹ã‹ã‚‰ã§ã‚ã‚‹ã€‚
æ–‡æ³•å¤‰å½¢ã¯ä»¥ä¸‹ã®æ‰‹ç¶šãã«ã‚ˆã‚Šé”æˆã•ã‚Œã‚‹ href="#footnote_Temp_702"><sup><small>81</small></sup></a>ã€‚
</p>

<p class="lisp">(define (query-syntax-process exp)
  (map-over-symbols expand-question-mark exp))
<a name="%_idx_5412"></a>(define (map-over-symbols proc exp)
  (cond ((pair? exp)
         (cons (map-over-symbols proc (car exp))
               (map-over-symbols proc (cdr exp))))
        ((symbol? exp) (proc exp))
        (else exp)))
(define (expand-question-mark symbol)
  (let ((chars (symbol-&gt;string symbol)))
    (if (string=? (substring chars 0 1) &quot;?&quot;)
        (list '?
              (string-&gt;symbol
               (substring chars 1 (string-length chars))))
        symbol)))
</p>

<p class="orig" lang="en">
Once the variables are transformed in this way, the variables in a
pattern are lists starting with <tt>?</tt>,
and the constant symbols (which need to be recognized for
data-base indexing, section <a href="#%_sec_4.4.4.5">4.4.4.5</a>) are just the symbols.</p>

<p class="trans" lang="ja">
ä¸€æ—¦ã“ã®æ–¹æ³•ã§å¤‰æ•°ãŒå¤‰å½¢ã•ã‚Œã‚‹ã¨ã€ãƒ‘ã‚¿ãƒ³å†…ã®å¤‰æ•°ã¯ <tt>?</tt> ã§å§‹ã¾ã‚‹ãƒªã‚¹ãƒˆã§ã‚ã‚Šã€å®šæ•°è¨˜å· (<a href="#%_sec_4.4.4.5">4.4.4.5</a>ç¯€ã®ã¨ãŠã‚Šã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ç´¢å¼•ã¥ã‘ã®ãŸã‚ã«ã€èªè­˜ã•ã‚Œã­ã°ãªã‚‰ãªã„) ã¯ãŸã ã®è¨˜å·ã§ã‚ã‚‹ã€‚
</p>

<p class="lisp">(define (var? exp)
  (tagged-list? exp '?))
(define (constant-symbol? exp) (symbol? exp))
</p>

<p class="orig" lang="en">
Unique variables are constructed during rule application
(in section <a href="#%_sec_4.4.4.4">4.4.4.4</a>) by means of
the following procedures.  The unique identifier for a rule
application is a number, which is incremented each time a rule is
applied.</p>

<p class="trans" lang="ja">
(<a href="#%_sec_4.4.4.4">4.4.4.4</a>ç¯€ã§ã®) è¦å‰‡é©ç”¨ã®é–“ã«ã€ä»¥ä¸‹ã®æ‰‹ç¶šãã‚’ç”¨ã„ã¦ã€ä¸€æ„ãªå¤‰æ•°ãŒæ§‹ç¯‰ã•ã‚Œã‚‹ã€‚
è¦å‰‡é©ç”¨ã«å¯¾ã™ã‚‹ä¸€æ„ãªè­˜åˆ¥å­ã¯ç•ªå·ã§ã‚ã‚Šã€ã“ã‚Œã¯ã€è¦å‰‡ãŒé©ç”¨ã•ã‚Œã‚‹ãŸã³ã«ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã•ã‚Œã‚‹ã€‚
</p>


<p class="lisp">(define rule-counter 0)
(define (new-rule-application-id)
  (set! rule-counter (+ 1 rule-counter))
  rule-counter)
(define (make-new-variable var rule-application-id)
  (cons '? (cons rule-application-id (cdr var))))
</p>

<p class="orig" lang="en">
When <tt>query-driver-loop</tt> instantiates the query to print the
answer, it converts any unbound pattern variables back to the right
form for printing, using</p>

<p class="trans" lang="ja">
<tt>query-driver-loop</tt> ã¯ã€ã‚¯ã‚¨ãƒªã‚’ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã—ã¦ç­”ãˆã‚’å°å­—ã™ã‚‹ã¨ãã€æŸç¸›ã•ã‚Œã¦ã„ãªã„ã©ã®ãƒ‘ã‚¿ãƒ³å¤‰æ•°ã‚’ã‚‚ã€å°å­—ç”¨ã®æ­£ã—ã„å½¢å¼ã¸æˆ»ã™ã‚ˆã†ã«ã€ä»¥ä¸‹ã‚’ç”¨ã„ã¦å¤‰æ›ã™ã‚‹ã€‚
</p>

<p class="lisp">(define (contract-question-mark variable)
  (string-&gt;symbol
   (string-append &quot;?&quot; 
     (if (number? (cadr variable))
         (string-append (symbol-&gt;string (caddr variable))
                        &quot;-&quot;
                        (number-&gt;string (cadr variable)))
         (symbol-&gt;string (cadr variable))))))
</p>

<a name="%_sec_4.4.4.8"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_4.4.4.8">4.4.4.8  Frames and Bindings</a></h4>
<h4 class="trans" lang="ja">4.4.4.8 ãƒ•ãƒ¬ãƒ¼ãƒ ã¨æŸç¸›</h4>

<p class="orig" lang="en">
<a name="%_idx_5414"></a><a name="%_idx_5416"></a>Frames are represented as lists of bindings, which are
variable-value pairs:</p>

<p class="trans" lang="ja">
ãƒ•ãƒ¬ãƒ¼ãƒ ã¯ã€æŸç¸›â€”â€”å¤‰æ•°ã¨å€¤ã®å¯¾â€”â€”ã®ãƒªã‚¹ãƒˆã¨ã—ã¦ã€è¡¨ç¾ã•ã‚Œã‚‹ã€‚
</p>

<p class="lisp">(define (make-binding variable value)
  (cons variable value))
(define (binding-variable binding)
  (car binding))
(define (binding-value binding)
  (cdr binding))
(define (binding-in-frame variable frame)
  (assoc variable frame))
(define (extend variable value frame)
  (cons (make-binding variable value) frame))
</p>

<p class="extra" id="translating">**ã“ã“ã‹ã‚‰</p>
<p class="orig" lang="en">
<a name="%_thm_4.71"></a>
<b>Exercise 4.71.</b>  Louis Reasoner wonders why the <tt>simple-query</tt> and <tt>disjoin</tt>
procedures (section <a href="#%_sec_4.4.4.2">4.4.4.2</a>) are implemented using
explicit <tt>delay</tt> operations, rather than being defined as follows:</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.71.</b> ãƒ«ã‚¤ã‚¹ãƒ»ãƒªãƒ¼ã‚ºãƒŠã¯ã€
</p>

<p class="lisp">(define (simple-query query-pattern frame-stream)
  (stream-flatmap
   (lambda (frame)
     (stream-append (find-assertions query-pattern frame)
                    (apply-rules query-pattern frame)))
   frame-stream))
(define (disjoin disjuncts frame-stream)
  (if (empty-disjunction? disjuncts)
      the-empty-stream
      (interleave
       (qeval (first-disjunct disjuncts) frame-stream)
       (disjoin (rest-disjuncts disjuncts) frame-stream))))
</p>

<p class="orig" lang="en">Can you give examples of queries where these simpler definitions would
lead to undesirable behavior?
</p>

<p class="trans" lang="ja">
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_4.72"></a>
<b>Exercise 4.72.</b>  Why do <tt>disjoin</tt> and <tt>stream-flatmap</tt> interleave the
streams rather than simply append them?  Give examples that illustrate
why interleaving works better.  (Hint: Why did we use <tt>interleave</tt> in
section <a href="24_sec3_5.html#%_sec_3.5.3">3.5.3</a>?)
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.72.</b> 
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_4.73"></a>
<b>Exercise 4.73.</b>  Why does <tt>flatten-stream</tt> use <tt>delay</tt> explicitly?
What would be wrong with defining it as follows:
</p>


<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.73.</b> 
</p>

<p class="lisp">(define (flatten-stream stream)
  (if (stream-null? stream)
      the-empty-stream
      (interleave
       (stream-car stream)
       (flatten-stream (stream-cdr stream)))))
</p>

<p class="exercise"><span class="ex_comment">
</span></p>


<p class="orig" lang="en">
<a name="%_thm_4.74"></a>
<b>Exercise 4.74.</b>  <a name="%_idx_5418"></a>Alyssa P. Hacker proposes to use a simpler version of <tt>stream-flatmap</tt>
in <tt>negate</tt>, <tt>lisp-value</tt>, and <tt>find-assertions</tt>.
She observes that the procedure that is mapped over the frame stream
in these cases always produces either the empty stream or a singleton
stream, so no interleaving is needed when combining these streams.</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.74.</b> 
</p>

<ol class="orig alph" start="1" lang="en">
<li>Fill in the missing expressions in Alyssa's program.</li>
</ol>

<ol class="trans alph" start="1" lang="ja">
<li></li>
</ol>

<p class="lisp">(define (simple-stream-flatmap proc s)
  (simple-flatten (stream-map proc s)))

(define (simple-flatten stream)
  (stream-map &lt;<em>??</em>&gt;
              (stream-filter &lt;<em>??</em>&gt; stream)))
</p>

<ol class="orig alph" start="2" lang="en">
<li>Does the query system's behavior change if we change it in this way?</li>
</ol>

<ol class="trans alph" start="2" lang="ja">
<li></li>
</ol>

<p class="exercise"><span class="ex_comment">
</span></p>


<p class="orig" lang="en">
<a name="%_thm_4.75"></a>
<b>Exercise 4.75.</b>  <a name="%_idx_5420"></a><a name="%_idx_5422"></a><a name="%_idx_5424"></a>Implement for the query language a new special form called <tt>unique</tt>.  <tt>Unique</tt> should succeed if there is precisely one item
in the data base satisfying a specified query.  For example,</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.75.</b> 
</p>

<p class="lisp">(unique (job ?x (computer wizard)))
</p>

<p class="orig" lang="en">should print the one-item stream</p>

<p class="trans" lang="ja">
</p>

<p class="lisp">(unique (job (Bitdiddle Ben) (computer wizard)))
</p>

<p class="orig" lang="en">since Ben is the only computer wizard, and</p>

<p class="trans" lang="ja">
</p>

<p class="lisp">(unique (job ?x (computer programmer)))
</p>

<p class="orig" lang="en">should print the empty stream, since there is more than one computer
programmer.  Moreover,</p>

<p class="trans" lang="ja">
</p>

<p class="lisp">(and (job ?x ?j) (unique (job ?anyone ?j)))
</p>

<p class="orig" lang="en">should list all the jobs that are filled by only one person, and the
people who fill them.</p>

<p class="trans" lang="ja">
</p>

<p class="orig" lang="en">
There are two parts to implementing <tt>unique</tt>.  The first is to
write a procedure that handles this special form, and the second is to make
<tt>qeval</tt> dispatch to that procedure.  The second part is trivial,
since <tt>qeval</tt> does its dispatching in a data-directed way.  If
your procedure is called <tt>uniquely-asserted</tt>, all you need to do
is</p>

<p class="trans" lang="ja">
</p>

<p class="lisp">(put 'unique 'qeval uniquely-asserted)
</p>

<p class="orig" lang="en">and <tt>qeval</tt> will dispatch to this procedure for every query whose
<tt>type</tt> (<tt>car</tt>) is the symbol <tt>unique</tt>.</p>

<p class="trans" lang="ja">
</p>

<p class="orig" lang="en">
The real problem is to write the procedure <tt>uniquely-asserted</tt>.
This should take as input the <tt>contents</tt> (<tt>cdr</tt>) of the <tt>unique</tt> query, together with a stream of frames.  For each frame in
the stream, it should use <tt>qeval</tt> to find the stream of all
extensions to the frame that satisfy the given query.  Any stream that
does not have exactly one item in it should be eliminated.  The
remaining streams should be passed back to be accumulated into one big
stream that is the result of the <tt>unique</tt> query.  This is similar
to the implementation of the <tt>not</tt> special form.</p>

<p class="trans" lang="ja">
</p>

<p class="orig" lang="en">
Test your implementation by forming a query that lists all people who
supervise precisely one person.
</p>

<p class="trans" lang="ja">
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_4.76"></a>
<b>Exercise 4.76.</b>  <a name="%_idx_5426"></a><a name="%_idx_5428"></a><a name="%_idx_5430"></a>Our implementation of <tt>and</tt> as a series combination of queries
(figure <a href="#%_fig_4.5">4.5</a>) is elegant, but it is inefficient because in
processing the second query of the <tt>and</tt> we must scan the data
base for each frame produced by the first query.  If the data base has
<em>N</em> elements, and a typical query produces a number of output frames
proportional to <em>N</em> (say <em>N</em>/<em>k</em>), then scanning the data base for each
frame produced by the first query will require <em>N</em><sup>2</sup>/<em>k</em> calls to the
pattern matcher.  Another approach would be to process the two clauses
of the <tt>and</tt> separately, then look for all pairs of output frames
that are compatible.  If each query produces <em>N</em>/<em>k</em> output frames, then
this means that we must perform <em>N</em><sup>2</sup>/<em>k</em><sup>2</sup> compatibility checks -- a
factor of <em>k</em> fewer than the number of matches required in our current
method.</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.76.</b> 
</p>

<p class="orig" lang="en">
Devise an implementation of <tt>and</tt> that uses this strategy.  You
must implement a procedure that takes two frames as inputs, checks
whether the bindings in the frames are compatible, and, if so,
produces a frame that merges the two sets of bindings.  This operation
is similar to unification.
</p>

<p class="trans" lang="ja">
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_4.77"></a>
<b>Exercise 4.77.</b>  <a name="%_idx_5432"></a><a name="%_idx_5434"></a><a name="%_idx_5436"></a><a name="%_idx_5438"></a><a name="%_idx_5440"></a>In section <a href="#%_sec_4.4.3">4.4.3</a> we saw that <tt>not</tt> and <tt>lisp-value</tt> can cause the query language to give ``wrong'' answers if
these filtering operations are applied to frames in which variables
are unbound.  Devise a way to fix this shortcoming.  One idea is to
perform the filtering in a ``delayed'' manner by appending to the
frame a ``promise'' to filter that is fulfilled only when enough
variables have been bound to make the operation possible.  We could
wait to perform filtering until all other operations have been
performed.  However, for efficiency's sake, we would like to perform
filtering as soon as possible so as to cut down on the number of
intermediate frames generated.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.77.</b> 
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_4.78"></a>
<b>Exercise 4.78.</b>  <a name="%_idx_5442"></a>Redesign the query language as a nondeterministic program to be
implemented using the evaluator of
section <a href="28_sec4_3.html#%_sec_4.3">4.3</a>, rather than as a stream
process.  In this approach, each query will produce a single answer
(rather than the stream of all answers) and the user can type <tt>try-again</tt> to see more answers.  You should find that much of the
mechanism we built in this section is subsumed by nondeterministic
search and backtracking.  You will probably also find, however, that
your new query language has subtle differences in behavior from the
one implemented here.  Can you find examples that illustrate this
difference?
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.78.</b> 
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_4.79"></a>
<b>Exercise 4.79.</b>  <a name="%_idx_5444"></a><a name="%_idx_5446"></a>When we implemented the Lisp evaluator in section <a href="26_sec4_1.html#%_sec_4.1">4.1</a>,
we saw how to use local environments to avoid name conflicts between
the parameters of procedures.  For example, in evaluating</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.79.</b> 
</p>

<p class="lisp">(define (square x)
  (* x x))
(define (sum-of-squares x y)
  (+ (square x) (square y)))
(sum-of-squares 3 4)
</p>

<p class="orig" lang="en">there is no confusion between the <tt>x</tt> in <tt>square</tt> and the <tt>x</tt>
in <tt>sum-of-squares</tt>, because we evaluate the body of each
procedure in an environment that is specially constructed to contain
bindings for the local variables.  In the query system, we used a
different strategy to avoid name conflicts in applying rules.  Each
time we apply a rule we rename the variables with new names that are
guaranteed to be unique.  The analogous strategy for the Lisp
evaluator would be to do away with local environments and simply
rename the variables in the body of a procedure each time we apply the
procedure.</p>

<p class="trans" lang="ja">
</p>

<p class="orig" lang="en">
<a name="%_idx_5448"></a><a name="%_idx_5450"></a><a name="%_idx_5452"></a><a name="%_idx_5454"></a>Implement for the query language a rule-application method that uses
environments rather than renaming.  See if you can build on your
environment structure to create constructs in the query language for
dealing with large systems, such as the rule analog of
block-structured procedures.  Can you relate any of this to the
problem of making deductions in a context (e.g., ``If I supposed that
<em>P</em> were true, then I would be able to deduce <em>A</em> and <em>B</em>.'') as a
method of problem solving?  (This problem is open-ended.  A good
answer is probably worth a Ph.D.)</p>


<p class="trans" lang="ja">
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="footnotes"></a>
<hr>
<p class="orig" lang="en"><a name="footnote_Temp_645" href="#call_footnote_Temp_645"><sup><small>58</small></sup></a> Logic programming has grown out of a long
<a name="%_idx_5040"></a><a name="%_idx_5042"></a>history of research in automatic theorem proving.  Early
theorem-proving programs could accomplish very little, because they
exhaustively searched the space of possible proofs.  The major
breakthrough that made such a search plausible was the discovery in
the early 1960s of the <a name="%_idx_5044"></a><em>unification algorithm</em> and the <a name="%_idx_5046"></a><em>resolution principle</em> (Robinson 1965).  Resolution was used, for
example, by <a name="%_idx_5048"></a><a name="%_idx_5050"></a>Green and Raphael (1968) (see also Green 1969) as the
basis for a deductive question-answering system.  During most of this
period, researchers concentrated on algorithms that are guaranteed to
find a proof if one exists.  Such algorithms were difficult to control
and to direct toward a proof.  <a name="%_idx_5052"></a>Hewitt (1969) recognized the
possibility of merging the control structure of a programming language
with the operations of a logic-manipulation system, leading to the
work in automatic search mentioned in section <a href="28_sec4_3.html#%_sec_4.3.1">4.3.1</a>
(footnote <a href="28_sec4_3.html#footnote_Temp_603">47</a>).  At the same time that this was being done,
<a name="%_idx_5054"></a>Colmerauer, in Marseille, was developing rule-based systems for
manipulating natural language (see Colmerauer et al. 1973).  He
invented a programming language called <a name="%_idx_5056"></a>Prolog for representing those
rules.  <a name="%_idx_5058"></a>Kowalski (1973; 1979), in Edinburgh, recognized that execution
of a Prolog program could be interpreted as proving theorems (using a
proof technique called linear <a name="%_idx_5060"></a>Horn-clause resolution).  The merging of
the last two strands led to the logic-programming movement.  Thus, in
assigning credit for the development of logic programming, the French
can point to Prolog's genesis at the <a name="%_idx_5062"></a>University of Marseille, while
the British can highlight the work at the <a name="%_idx_5064"></a>University of Edinburgh.
According to people at <a name="%_idx_5066"></a>MIT, logic programming was developed by these
groups in an attempt to figure out what Hewitt was talking about in
his brilliant but impenetrable Ph.D. thesis.  For a history of logic
<a name="%_idx_5068"></a>programming, see Robinson 1983.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_645"><sup><small>58</small></sup></a> 
è«–ç†ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã¯ã€è‡ªå‹•å®šç†è¨¼æ˜ã«ã¤ã„ã¦ã®ç ”ç©¶ã®é•·ã„æ­´å²ã®ä¸­ã‹ã‚‰ã€æˆé•·ã—ã¦ããŸã€‚
åˆæœŸã®å®šç†è¨¼æ˜ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€å¯èƒ½ãªè¨¼æ˜ã®ç©ºé–“ã‚’ç¶²ç¾…çš„ã«æ¢ç´¢ã—ãŸã®ã§ã€ã»ã‚“ã®ã‚ãšã‹ã®ã“ã¨ã—ã‹é”æˆã§ããªã‹ã£ãŸã€‚
ãã†ã—ãŸæ¢ç´¢ã‚’è¦‹è¾¼ã¿ã®ã‚ã‚‹ã‚‚ã®ã«ã—ãŸä¸»è¦ãª<ruby><rb>å¤§èºé€²</rb><rp> (</rp><rt>ãƒ–ãƒ¬ãƒ¼ã‚¯ã‚¹ãƒ«ãƒ¼</rt><rp>) </rp></ruby>ã¯ã€1960å¹´ä»£åˆæœŸã«ãŠã‘ã‚‹ã€<em>ãƒ¦ãƒ‹ãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ»ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ </em>ã¨<em>å°å‡ºåŸç†</em> (Robinson 1965) ã®ç™ºè¦‹ã§ã‚ã£ãŸã€‚
ãŸã¨ãˆã°ã€Green and Raphael (1968) (Green 1969 ã‚‚å‚ç…§) ã«ã‚ˆã£ã¦ã€å°å‡ºã¯ã€æ¼”ç¹¹çš„ãªè³ªå•å›ç­”ã‚·ã‚¹ãƒ†ãƒ ã®åŸºç¤ã¨ã—ã¦ä½¿ã‚ã‚ŒãŸã€‚
ã“ã®æœŸé–“ã®ã»ã¨ã‚“ã©ã«ãŠã„ã¦ã€ç ”ç©¶è€…ãŸã¡ã¯ã€ã‚‚ã—ä¸€ã¤ã§ã‚‚è¨¼æ˜ãŒå­˜åœ¨ã—ã¦ã„ã‚Œã°è¨¼æ˜ã‚’è¦‹ã¤ã‘ã‚‹ã“ã¨ãŒä¿è¨¼ã•ã‚ŒãŸã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã«å°‚å¿µã—ãŸã€‚
ãã†ã—ãŸã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯ã€åˆ¶å¾¡ã—ã¥ã‚‰ã‹ã£ãŸã—ã€è¨¼æ˜ã¸ã¨å‘ã‹ã‚ã›ã¥ã‚‰ã‹ã£ãŸã€‚
Hewitt (1969) ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã®åˆ¶å¾¡æ§‹é€ ã‚’è«–ç†æ“ä½œã‚·ã‚¹ãƒ†ãƒ ã®æ¼”ç®—ã¨åˆã‚ã›ã‚‹ã€ã¨ã„ã†å¯èƒ½æ€§ã‚’èªè­˜ã—ã€ãã‚Œã¯ã€<a href="28_sec4_3.html#%_sec_4.3.1">4.3.1</a>ç¯€ã§è¨€åŠã—ãŸè‡ªå‹•æ¢ç´¢ã«ã¤ã„ã¦ã®æ¥­ç¸¾ã«ã¤ãªãŒã£ãŸ (è„šæ³¨<a href="28_sec4_3.html#footnote_Temp_603">47</a>)ã€‚
ã“ã‚ŒãŒãªã•ã‚ŒãŸã®ã¨åŒæ™‚ã«ã€ãƒãƒ«ã‚»ã‚¤ãƒ¦ã§ Colmerauer ãŒã€è‡ªç„¶è¨€èªã‚’æ“ä½œã™ã‚‹ãŸã‚ã®ã€<ruby><rb>è¦å‰‡ã«åŸºã¥ã</rb><rp> (</rp><rt>ãƒ«ãƒ¼ãƒ«ãƒ»ãƒ™ãƒ¼ã‚¹ã®</rt><rp>) </rp></ruby>ã‚·ã‚¹ãƒ†ãƒ ã‚’é–‹ç™ºã—ã¦ã„ãŸ (Colmerauer et al. 1973 ã‚’å‚ç…§)ã€‚
å½¼ã¯ã€ãã‚Œã‚‰ã®è¦å‰‡ã‚’è¡¨ç¾ã™ã‚‹ãŸã‚ã®ã€Prolog ã¨å‘¼ã°ã‚Œã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã‚’ç™ºæ˜ã—ãŸã€‚
ã‚¨ãƒ‡ã‚£ãƒ³ãƒãƒ©ã§ã¯ã€Kowalski (1973; 1979) ãŒã€Prolog ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®å®Ÿè¡Œã¯ã€å®šç¾©ã‚’è¨¼æ˜ã—ã¦ã„ã‚‹ã‚‚ã®ãªã®ã ã¨è§£é‡ˆã§ãã‚‹ã€ã¨ã„ã†ã“ã¨ã‚’èªè­˜ã—ãŸ (ç·šå½¢ãƒ›ãƒ¼ãƒ³ç¯€å°å‡ºã¨å‘¼ã°ã‚Œã‚‹è¨¼æ˜æŠ€è¡“ã‚’ä½¿ã£ãŸ)ã€‚
æœ€å¾Œã®äºŒã¤ã®è¦ç´ ã‚’åˆã‚ã›ã‚‹ã“ã¨ã§ã€è«–ç†ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®é€²å±•ã¸ã¨ã¤ãªãŒã£ãŸã€‚
ã“ã®ã‚ˆã†ã«ã—ã¦ã€è«–ç†ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®ç™ºå±•ã«å¯¾ã™ã‚‹åŠŸç¸¾ã‚’å‰²ã‚Šå½“ã¦ã¦ã‚†ãä¸­ã§ã¯ã€ã‚¤ã‚®ãƒªã‚¹äººãŒã‚¨ãƒ‡ã‚£ãƒ³ãƒãƒ©å¤§å­¦ã§ã®æ¥­ç¸¾ã‚’å¼·èª¿ã§ãã‚‹ã®ã«å¯¾ã—ã€ãƒ•ãƒ©ãƒ³ã‚¹äººã¯ãƒãƒ«ã‚»ã‚¤ãƒ¦å¤§å­¦ã«ãŠã‘ã‚‹ Prolog ã®å‰µä¸–è¨˜ã‚’æŒ‡ã—ç¤ºã™ã“ã¨ãŒã§ãã‚‹ã€‚
MIT ã®äººãŸã¡ã«ã‚ˆã‚Œã°ã€è«–ç†ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã¯ã€ãƒ’ãƒ¥ãƒ¼ã‚¦ã‚£ãƒƒãƒˆãŒè¼ã‹ã—ãã‚‚ç†è§£ä¸èƒ½ãªå½¼ã®åšå£«è«–æ–‡ã§ä½•ã«ã¤ã„ã¦èªã£ã¦ã„ãŸã®ã‹ã‚’é—¡æ˜ã—ã‚ˆã†ã¨ã—ã¦ã€ã“ã‚Œã‚‰ã®ã‚°ãƒ«ãƒ¼ãƒ—ã«ã‚ˆã£ã¦é–‹ç™ºã•ã‚ŒãŸã®ã ã€‚
è«–ç†ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®æ­´å²ã«ã¤ã„ã¦ã¯ã€Robinson 1983 ã‚’å‚ç…§ã®ã“ã¨ã€‚
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_646" href="#call_footnote_Temp_646"><sup><small>59</small></sup></a> To
see the correspondence between the rules and the procedure, let <tt>x</tt> in the procedure (where <tt>x</tt> is nonempty) correspond to <tt>(cons u v)</tt> in the rule.  Then <tt>z</tt> in the rule corresponds to the
<tt>append</tt> of <tt>(cdr x)</tt> and <tt>y</tt>.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_646"><sup><small>59</small></sup></a> 
è¦å‰‡ã¨æ‰‹ç¶šãã¨ã®é–“ã®å¯¾å¿œé–¢ä¿‚ã‚’è¦‹ã‚‹ãŸã‚ã«ã¯ã€æ‰‹ç¶šãä¸­ã® <tt>x</tt> (ãŸã ã— <tt>x</tt> ã¯éç©º) ãŒè¦å‰‡ä¸­ã® <tt>(cons u v)</tt> ã«å¯¾å¿œã™ã‚‹ã‚‚ã®ã¨ã›ã‚ˆã€‚
ã™ã‚‹ã¨ã€è¦å‰‡ä¸­ã® <tt>z</tt> ã¯ã€<tt>(cdr x)</tt> ã¨ <tt>y</tt> ã® <tt>append</tt> ã«å¯¾å¿œã™ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_647" href="#call_footnote_Temp_647"><sup><small>60</small></sup></a> This certainly does not
relieve the user of the entire problem of how to compute the answer.
There are many different mathematically equivalent sets of rules for
formulating the <tt>append</tt> relation, only some of which can be
turned into effective devices for computing in any direction.  In
addition, sometimes ``what is'' information gives no clue ``how to''
compute an answer.  For example, consider the problem of computing the
<em>y</em> such that <em>y</em><sup>2</sup>  =  <em>x</em>.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_647"><sup><small>60</small></sup></a>
ãªã‚‹ã»ã©ã€ã“ã‚Œã¯ã€ç­”ãˆã‚’ã©ã®ã‚ˆã†ã«è¨ˆç®—ã™ã‚‹ã®ã‹ã¨ã„ã†å•é¡Œå…¨ä½“ã‹ã‚‰ã€ãƒ¦ãƒ¼ã‚¶ã‚’è§£æ”¾ã—ã¦ãã‚Œã‚‹ã€ã¨ã„ã†ã‚ã‘ã§ã¯ãªã„ã€‚
<tt>append</tt> é–¢ä¿‚ã‚’å®šå¼åŒ–ã™ã‚‹ãŸã‚ã®ã€æ•°å­¦çš„ã«ã¯ç­‰ä¾¡ãªå¤šãã®ç•°ãªã‚‹è¦å‰‡é›†åˆãŒå­˜åœ¨ã™ã‚‹ãŒã€<!--ãã‚Œã‚‰ã®ã†ã¡ã®ã„ãã¤ã‹ã ã‘ã—ã‹ã€ã„ãšã‚Œã‹ã®æ–¹å‘ã«è¨ˆç®—ã™ã‚‹ãŸã‚ã®æœ‰åŠ¹ãªé“å…·ã ã¨ã¯åˆ¤æ˜ã—å¾—ãªã„ã®ã ã€‚-->ãã‚Œã‚‰ã®ã†ã¡ã®ä¸€éƒ¨ã—ã‹ã€ã©ã®æ–¹å‘ã§ã‚ã‚Œã€è¨ˆç®—ã™ã‚‹ãŸã‚ã®æœ‰åŠ¹ãªé“å…·ã«ã¯ãªã‚Šå¾—ãªã„ã®ã ã€‚
ã•ã‚‰ã«ã€ã€Œä½•ã§ã‚ã‚‹ã‹ã€ã¨ã„ã†æƒ…å ±ã¯ã€ã¨ãã¨ã—ã¦ã€ã€Œã©ã†ã‚„ã£ã¦ã€ç­”ãˆã‚’è¨ˆç®—ã™ã‚‹ã®ã‹ã€ã«ã¤ã„ã¦ä½•ã®æ‰‹ãŒã‹ã‚Šã‚‚ä¸ãˆã¦ãã‚Œãªã„ã€‚
ãŸã¨ãˆã°ã€
<span class="math"><em class="en">y</em><sup>2</sup>  =  <em class="en">x</em></span>
ã§ã‚ã‚‹ã‚ˆã†ãª <em class="en">y</em> ã‚’è¨ˆç®—ã™ã‚‹å•é¡Œã‚’è€ƒãˆãŸã¾ãˆã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_648" href="#call_footnote_Temp_648"><sup><small>61</small></sup></a> Interest in logic programming peaked
<a name="%_idx_5080"></a><a name="%_idx_5082"></a><a name="%_idx_5084"></a>during the early 80s when the Japanese government began an ambitious
project aimed at building superfast computers optimized to run logic
programming languages.  The speed of such computers was to be measured
in LIPS (Logical Inferences Per Second) rather than the usual FLOPS
(FLoating-point Operations Per Second).  Although the project
succeeded in developing hardware and software as originally planned,
the international computer industry moved in a different direction.
See <a name="%_idx_5086"></a><a name="%_idx_5088"></a>Feigenbaum and Shrobe 1993 for an overview evaluation of the
Japanese project.  The logic programming community has also moved on
to consider relational programming based on techniques other than
simple pattern matching, such as the ability to deal with numerical
constraints such as the ones illustrated in the constraint-propagation
system of section <a href="22_sec3_3.html#%_sec_3.3.5">3.3.5</a>.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_648"><sup><small>61</small></sup></a>
è«–ç†ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã‚’å®Ÿè¡Œã™ã‚‹ãŸã‚ã«æœ€é©åŒ–ã•ã‚ŒãŸè¶…é«˜é€Ÿã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã‚’æ§‹ç¯‰ã™ã‚‹ã“ã¨ã‚’ç›®æ¨™ã«ã—ãŸé‡å¿ƒçš„ãªãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’æ—¥æœ¬æ”¿åºœãŒé–‹å§‹ã—ãŸ1980å¹´ä»£ã®å§‹ã‚ã«ã€è«–ç†ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã¸ã®é–¢å¿ƒã¯æœ€é«˜æ½®ã«é”ã—ãŸã€‚
ãã†ã—ãŸã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã®é€Ÿåº¦ã¯ã€FLOPS (1ç§’ã‚ãŸã‚Šã®æµ®å‹•å°æ•°ç‚¹æ•°æ¼”ç®—å›æ•°) ã§ã¯ãªãã€ã‚€ã—ã‚ã€LIPS (1ç§’ã‚ãŸã‚Šã®è«–ç†æ¨è«–å›æ•°) ã§è¨ˆæ¸¬ã•ã‚Œã‚‹ã¹ãã§ã‚ã£ãŸã€‚
ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¯ã€å½“åˆè¨ˆç”»ã•ã‚ŒãŸã‚ˆã†ãªãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ã¨ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã‚’é–‹ç™ºã™ã‚‹ã“ã¨ã«æˆåŠŸã—ãŸã®ã ãŒã€å›½éš›çš„ãªã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ç”£æ¥­ã¯ã€åˆ¥ã®æ–¹å‘ã¸ã¨å‹•ã„ãŸã€‚
æ—¥æœ¬ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®æ¦‚è¦çš„è©•ä¾¡ã«ã¤ã„ã¦ã¯ã€Feigenbaum and Shrobe 1993 ã‚’å‚ç…§ã®ã“ã¨ã€‚
è«–ç†ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ç•Œã‚‚ã€<a href="22_sec3_3.html#%_sec_3.3.5">3.3.5</a>ç¯€ã®åˆ¶ç´„ä¼æ’­ã‚·ã‚¹ãƒ†ãƒ ã«ãŠã„ã¦ä¾‹ç¤ºã—ãŸã‚‚ã®ã®ã‚ˆã†ãªæ•°é‡çš„åˆ¶ç´„ã‚’æ‰±ã†èƒ½åŠ›ãªã©ã€å˜ç´”ãªãƒ‘ã‚¿ãƒ³ãƒ»ãƒãƒƒãƒãƒ³ã‚°ã§ã¯ãªã„æŠ€æ³•ã«åŸºã¥ã<ruby><rb>é–¢ä¿‚</rb><rp> (</rp><rt>ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒŠãƒ«</rt><rp>) </rp></ruby>ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚’è€ƒæ…®ã™ã‚‹ã‚ˆã†ã«ã€é€²æ­©ã—ã¦ããŸã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_651" href="#call_footnote_Temp_651"><sup><small>62</small></sup></a> This uses the dotted-tail notation introduced in
exercise <a href="15_sec2_2.html#%_thm_2.20">2.20</a>.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_651"><sup><small>62</small></sup></a>
ã“ã‚Œã¯ã€ç·´ç¿’å•é¡Œ<a href="15_sec2_2.html#%_thm_2.20">2.20</a>ã§å°å…¥ã—ãŸã€æœ«å°¾ã«ãƒ‰ãƒƒãƒˆãŒã¤ã„ãŸè¨˜æ³•ã‚’ä½¿ã£ã¦ã„ã‚‹ã€‚
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_654" href="#call_footnote_Temp_654"><sup><small>63</small></sup></a> Actually, this description of <tt>not</tt> is valid only for simple cases.  The real behavior of <tt>not</tt>
is more complex.  We will examine <tt>not</tt>'s peculiarities in
sections <a href="#%_sec_4.4.2">4.4.2</a> and <a href="#%_sec_4.4.3">4.4.3</a>.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_654"><sup><small>63</small></sup></a>
å®Ÿéš›ã¯ã€<tt>not</tt> ã«ã¤ã„ã¦ã®ã“ã®è¨˜è¿°ã¯ã€å˜ç´”ãªå ´åˆã«ã¤ã„ã¦ã®ã¿å¦¥å½“ã§ã‚ã‚‹ã€‚
<tt>not</tt> ã®ç¾å®Ÿã®æŒ¯ã‚‹èˆã„ã¯ã€ã‚‚ã£ã¨è¤‡é›‘ã ã€‚
<tt>not</tt> ã®å¦™ãªæ€§è³ªã«ã¤ã„ã¦ã¯ã€<a href="#%_sec_4.4.2">4.4.2</a>ç¯€ã¨<a href="#%_sec_4.4.3">4.4.3</a>ç¯€ã§åŸå‘³ã—ã‚ˆã†ã€‚
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_655" href="#call_footnote_Temp_655"><sup><small>64</small></sup></a> <tt>Lisp-value</tt> should be used only to perform an operation not
<a name="%_idx_5134"></a>provided in the query language.  In particular, it should not
be used to test equality (since that is what the matching in the
query language is designed to do) or inequality (since that can
be done with the <tt>same</tt> rule shown below).</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_655"><sup><small>64</small></sup></a>
<tt>lisp-value</tt> ã¯ã€ã‚¯ã‚¨ãƒªè¨€èªã§ã¯æä¾›ã•ã‚Œã¦ã„ãªã„æ¼”ç®—ã‚’å®Ÿè¡Œã™ã‚‹ãŸã‚ã«ã ã‘ä½¿ã‚ã‚Œã‚‹ã¹ãã§ã‚ã‚‹ã€‚
ç‰¹ã«ã€ç­‰ä¾¡æ€§ã‚’æ¤œæŸ»ã™ã‚‹ãŸã‚ã«ã“ã‚Œã‚’ä½¿ã†ã¹ãã§ã¯ãªã„ã— (ãªãœãªã‚‰ã€ãã‚Œã“ããŒã€ã‚¯ã‚¨ãƒªè¨€èªã«ãŠã‘ã‚‹ãƒãƒƒãƒãƒ³ã‚°ãŒãã‚Œã‚’è¡Œã†ã¹ãè¨­è¨ˆã•ã‚Œã¦ã„ã‚‹å¯¾è±¡ã®äº‹æŸ„ã ã‹ã‚‰ã§ã‚ã‚‹)ã€ã‚ã‚‹ã„ã¯ã€ä¸ç­‰ä¾¡æ€§ã‚’æ¤œæŸ»ã™ã‚‹ãŸã‚ã«ã‚‚ä½¿ã†ã¹ãã§ã¯ãªã„ (ãªãœãªã‚‰ã€ãã‚Œã¯ã€å¾Œã«ç¤ºã™ <tt>same</tt> è¦å‰‡ã‚’ä½¿ã£ã¦è¡Œã‚ã‚Œã‚‹ã‹ã‚‰ã§ã‚ã‚‹)ã€‚
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_658" href="#call_footnote_Temp_658"><sup><small>65</small></sup></a> Notice that we do not need <tt>same</tt> in order to make two things be
the same: We just use the same pattern variable for each -- in effect,
we have one thing instead of two things in the first place.  For
example, see <tt>?town</tt> in the <tt>lives-near</tt> rule and <tt>?middle-manager</tt> in the <tt>wheel</tt> rule below.
<tt>Same</tt> is useful when we want to force two things to be
different, such as <tt>?person-1</tt> and <tt>?person-2</tt> in the <tt>lives-near</tt> rule.  Although using the same pattern variable in two
parts of a query forces the same value to appear in both places, using
different pattern variables does not force different values to appear.
(The values assigned to different pattern variables may be the same or
different.)</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_658"><sup><small>65</small></sup></a>
äºŒã¤ã®ã‚‚ã®ã‚’åŒä¸€ã¨ã™ã‚‹ãŸã‚ã«ã¯ã€<tt>same</tt> ã‚’å¿…è¦ã¨ã¯ã—ãªã„ã®ã ã€ã¨ã„ã†ã“ã¨ã«æ³¨æ„ã›ã‚ˆã€‚ãã‚Œãã‚Œã«ã¤ã„ã¦åŒã˜ãƒ‘ã‚¿ãƒ³å¤‰æ•°ã‚’ä½¿ã„ã•ãˆã™ã‚Œã°ã‚ˆã„ã®ã ã€‚å®Ÿéš›ã€ãã‚‚ãã‚‚ã¯ã€äºŒã¤ã®ã‚‚ã®ã§ã¯ãªãã€ä¸€ã¤ã®ã‚‚ã®ãŒã‚ã‚‹è¨³ã ã€‚
ãŸã¨ãˆã°ã€<tt>lives-near</tt> ã®è¦å‰‡ã«ãŠã‘ã‚‹ <tt>?town</tt> ã‚„ã€ä»¥ä¸‹ã® <tt>wheel</tt> ã®è¦å‰‡ã«ãŠã‘ã‚‹ <tt>?middle-manager</tt> ã‚’å‚ç…§ã›ã‚ˆã€‚
<tt>same</tt> ã¯ã€<tt>lives-near</tt> ã®è¦å‰‡ã«ãŠã‘ã‚‹ <tt>?person-1</tt> ã¨ <tt>?person-2</tt> ã®ã‚ˆã†ã«ã€äºŒã¤ã®ã‚‚ã®ã‚’å¼·åˆ¶çš„ã«ç•°ãªã‚‹ã‚‚ã®ã¨ã—ãŸã„å ´åˆã«ã€æœ‰ç”¨ã§ã‚ã‚‹ã€‚
ã‚¯ã‚¨ãƒªã®äºŒã¤ã®éƒ¨åˆ†ã§åŒã˜ãƒ‘ã‚¿ãƒ³å¤‰æ•°ã‚’ä½¿ã†ã“ã¨ã¯ã€åŒã˜å€¤ãŒä¸¡æ–¹ã®å ´æ‰€ã«ç¾ã‚Œã‚‹ã“ã¨ã‚’å¼·ã„ã‚‹ãŒã€ç•°ãªã‚‹ãƒ‘ã‚¿ãƒ³å¤‰æ•°ã‚’ä½¿ã†ã“ã¨ã¯ã€ç•°ãªã‚‹å€¤ãŒç¾ã‚Œã‚‹ã“ã¨ã‚’å¼·ã„ã‚‹è¨³ã§ã¯ãªã„ (ç•°ãªã‚‹ãƒ‘ã‚¿ãƒ³å¤‰æ•°ã«<ruby><rb>ä»£å…¥ã•ã‚ŒãŸ</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦ã‚‰ã‚ŒãŸ</rt><rp>) </rp></ruby>å€¤ã¯ã€åŒã˜ã‹ã‚‚ã—ã‚Œãªã„ã—ã€ã‚ã‚‹ã„ã¯ã€é•ã†ã‹ã‚‚ã—ã‚Œãªã„ã®ã )ã€‚
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_659" href="#call_footnote_Temp_659"><sup><small>66</small></sup></a> We will also allow rules without bodies, as in <tt><a name="%_idx_5146"></a>same</tt>, and we will interpret such a rule to mean that the rule
conclusion is satisfied by any values of the variables.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_659"><sup><small>66</small></sup></a>
<tt>same</tt> ã«è¦‹ã‚‰ã‚Œã‚‹ã‚ˆã†ãªã€æœ¬ä½“ã®ãªã„è¦å‰‡ã‚‚è¨±å¯ã—ã‚ˆã†ã€‚ãã—ã¦ã€ãã†ã„ã£ãŸè¦å‰‡ã‚’ã€å¤‰æ•°ã®ä»»æ„ã®å€¤ã«ã‚ˆã£ã¦å½“è©²è¦å‰‡ã®å¸°çµãŒæº€ãŸã•ã‚Œã‚‹ã“ã¨ã‚’æ„å‘³ã™ã‚‹ã‚‚ã®ã¨ã—ã¦ã€è§£é‡ˆã—ã‚ˆã†ã€‚
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_670" href="#call_footnote_Temp_670"><sup><small>67</small></sup></a> Because matching is generally very expensive, we would
<a name="%_idx_5188"></a>like to avoid applying the full matcher to every element of the data
base.  This is usually arranged by breaking up the process into a
fast, coarse match and the final match.  The coarse match filters the
data base to produce a small set of candidates for the final match.
With care, we can arrange our data base so that some of the work of
coarse matching can be done when the data base is constructed rather
<a name="%_idx_5190"></a><a name="%_idx_5192"></a>then when we want to select the candidates.  This is called <em>indexing</em> the data base.  There is a vast technology built around
data-base-indexing schemes.  Our implementation, described in
section <a href="#%_sec_4.4.4">4.4.4</a>, contains a
simple-minded form of such an optimization.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_670"><sup><small>67</small></sup></a>
ãƒãƒƒãƒãƒ³ã‚°ã¯ä¸€èˆ¬çš„ã«ã¯ã¨ã¦ã‚‚é«˜ãã¤ãã®ã§ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ã©ã®è¦ç´ ã«å¯¾ã—ã¦ã‚‚å®Œå…¨ãªãƒãƒƒãƒãƒ£ã‚’é©ç”¨ã™ã‚‹ã“ã¨ã¯é¿ã‘ãŸã„ã€‚
ã“ã‚Œ<span class="note"> (å®Œå…¨ãªãƒãƒƒãƒãƒ£ã®é©ç”¨ã‚’é¿ã‘ã‚‹ã“ã¨) </span>ã®æ‰‹ç­ˆã¯ã€æ™®é€šã€ãƒ—ãƒ­ã‚»ã‚¹ã‚’ã€é«˜é€Ÿã§ç²—ã„ãƒãƒƒãƒã¨æœ€çµ‚çš„ãªãƒãƒƒãƒã¸ã¨åˆ†è§£ã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€æ•´ãˆã‚‰ã‚Œã‚‹ã€‚
ç²—ã„ãƒãƒƒãƒã¯ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’ãƒ•ã‚£ãƒ«ã‚¿ã«ã‹ã‘ã¦ã€æœ€çµ‚çš„ãªãƒãƒƒãƒã«å¯¾ã™ã‚‹å€™è£œã®å°ã•ãªé›†åˆã‚’ä½œã‚Šå‡ºã™ã€‚
æ³¨æ„ã™ã‚Œã°ã€ç§ãŸã¡ã¯ã€å€™è£œã‚’é¸æŠã—ãŸã„ã¨ãã§ã¯ãªããƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãŒæ§‹ç¯‰ã•ã‚Œã‚‹ã¨ãã«ç²—ã„ãƒãƒƒãƒãƒ³ã‚°ã®ä½œæ¥­ã®ã†ã¡ã®ã„ãã‚‰ã‹ã‚’è¡Œãˆã‚‹ã‚ˆã†ã«ã€è‡ªåˆ†ã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’æ•´ãˆã‚‰ã‚Œã‚‹ã€‚
ã“ã‚Œã¯ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®<em><ruby><rb>ç´¢å¼•ã¥ã‘</rb><rp> (</rp><rt>ã‚¤ãƒ³ãƒ‡ã‚¯ã‚·ãƒ³ã‚°</rt><rp>) </rp></ruby></em>ã¨å‘¼ã°ã‚Œã‚‹ã€‚
ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ã‚¤ãƒ³ãƒ‡ã‚¯ã‚·ãƒ³ã‚°æ–¹å¼ã‚’ã‚ãã£ã¦æ§‹ç¯‰ã•ã‚ŒãŸã€ãŠã³ãŸã ã—ã„æŠ€è¡“ãŒã‚ã‚‹ã€‚
ç§ãŸã¡ã®å®Ÿè£…ã¯ã€<a href="#%_sec_4.4.4">4.4.4</a>ç¯€ã§èª¬æ˜ã™ã‚‹ãŒã€ãã†ã—ãŸæœ€é©åŒ–ã®å˜ç´”ãªå½¢ã‚’å«ã‚“ã§ã„ã‚‹ã€‚
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_672" href="#call_footnote_Temp_672"><sup><small>68</small></sup></a> But this kind of exponential explosion is not common in <tt>and</tt>
queries because the added conditions tend to reduce rather than expand
the number of frames produced.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_672"><sup><small>68</small></sup></a>
ã—ã‹ã—ã€ã“ã®ç¨®ã®æŒ‡æ•°é–¢æ•°çš„çˆ†ç™ºã¯ã€<tt>and</tt> ã‚¯ã‚¨ãƒªã§ã‚ˆãã‚ã‚‹ã“ã¨ã§ã¯ãªã„ã€‚ãªãœãªã‚‰ã€è¿½åŠ ã•ã‚Œã‚‹æ¡ä»¶ã¯ã€ä½œã‚Šå‡ºã•ã‚Œã‚‹ãƒ•ãƒ¬ãƒ¼ãƒ ã®æ•°ã‚’å¢—ã‚„ã™ã‚ˆã‚Šã€ã‚€ã—ã‚æ¸›ã‚‰ã™å‚¾å‘ãŒã‚ã‚‹ãŸã‚ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_673" href="#call_footnote_Temp_673"><sup><small>69</small></sup></a> There is a large literature on data-base-management
systems that is concerned with how to handle complex queries
efficiently.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_673"><sup><small>69</small></sup></a>
è¤‡é›‘ãªã‚¯ã‚¨ãƒªã‚’åŠ¹ç‡ã‚ˆãæ‰±ã†æ–¹æ³•ã«é–¢ã™ã‚‹ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã«ã¤ã„ã¦ã®å¤§é‡ã®æ–‡çŒ®ãŒã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_674" href="#call_footnote_Temp_674"><sup><small>70</small></sup></a> There is a subtle difference between this filter
implementation of <tt>not</tt> and the usual meaning of <tt>not</tt> in
mathematical logic.  See section <a href="#%_sec_4.4.3">4.4.3</a>.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_674"><sup><small>70</small></sup></a>
<tt>not</tt> ã«ã¤ã„ã¦ã®ã€ã“ã®ãƒ•ã‚£ãƒ«ã‚¿å¼ã®å®Ÿè£…ã¨ã€æ•°å­¦çš„è«–ç†ã«ãŠã‘ã‚‹ <tt>not</tt> ã®é€šå¸¸ã®æ„å‘³ã¨ã®é–“ã«ã¯ã€å¾®å¦™ãªå·®ç•°ãŒã‚ã‚‹ã€‚
<a href="#%_sec_4.4.3">4.4.3</a>ç¯€ã‚’å‚ç…§ã®ã“ã¨ã€‚
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_676" href="#call_footnote_Temp_676"><sup><small>71</small></sup></a> In one-sided pattern matching, all the equations that
contain pattern variables are explicit and already solved for the
unknown (the pattern variable).</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_676"><sup><small>71</small></sup></a>
ä¸€æ–¹çš„ãªãƒ‘ã‚¿ãƒ³ãƒ»ãƒãƒƒãƒãƒ³ã‚°ã«ãŠã„ã¦ã¯ã€ãƒ‘ã‚¿ãƒ³å¤‰æ•°ã‚’å«ã‚€ã™ã¹ã¦ã®æ–¹ç¨‹å¼ã¯ã€é™½ã§ã‚ã‚Š<span class="note"> (é™½é–¢æ•°ã®ã€Œé™½ã€)</span>ã€ã‹ã¤ã€æœªçŸ¥æ•° (ãƒ‘ã‚¿ãƒ³å¤‰æ•°) ã«ã¤ã„ã¦æ—¢ã«è§£ã‹ã‚Œã¦ã„ã‚‹ã€‚
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_677" href="#call_footnote_Temp_677"><sup><small>72</small></sup></a> Another way to think of unification is that it generates the most
general pattern that is a specialization of the two input patterns.
That is, the unification of <tt>(?x a)</tt> and <tt>((b ?y) ?z)</tt> is <tt>((b ?y) a)</tt>, and the unification of <tt>(?x a ?y)</tt> and <tt>(?y ?z
a)</tt>, discussed above, is <tt>(a a a)</tt>.
For our implementation, it is more convenient to think of the result
of unification as a frame rather than a pattern.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_677"><sup><small>72</small></sup></a>
ãƒ¦ãƒ‹ãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ã“ã¨ã‚’è€ƒãˆã‚‹åˆ¥ã®æ–¹æ³•ã¯ã€äºŒã¤ã®å…¥åŠ›ãƒ‘ã‚¿ãƒ³ã®ç‰¹æ®ŠåŒ–ã§ã‚ã‚‹ã‚ˆã†ãªæœ€ã‚‚ä¸€èˆ¬çš„ãªãƒ‘ã‚¿ãƒ³ã‚’ãƒ¦ãƒ‹ãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒç”Ÿæˆã™ã‚‹ã€ã¨ã„ã†ã‚‚ã®ã§ã‚ã‚‹ã€‚
ã¤ã¾ã‚Šã€<tt>(?x a)</tt> ã¨ <tt>((b ?y) ?z)</tt> ã®ãƒ¦ãƒ‹ãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯ <tt>((b ?y) a)</tt> ã§ã‚ã‚Šã€<tt>(?x a ?y)</tt> ã¨ <tt>(?y ?z a)</tt> ã®ãƒ¦ãƒ‹ãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³â€”â€”ä¸Šè¨˜ã§è­°è«–ã—ãŸã‚‚ã®â€”â€”ã¯ <tt>(a a a)</tt> ã§ã‚ã‚‹ã€‚
ç§ãŸã¡ã®å®Ÿè£…ã«ã¨ã£ã¦ã¯ã€ãƒ¦ãƒ‹ãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®çµæœã‚’ã€ãƒ‘ã‚¿ãƒ³ã§ãªããƒ•ãƒ¬ãƒ¼ãƒ ã¨è¦‹ãªã™ã“ã¨ãŒã€ã‚ˆã‚Šä¾¿åˆ©ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_680" href="#call_footnote_Temp_680"><sup><small>73</small></sup></a> Since unification is a
<a name="%_idx_5222"></a><a name="%_idx_5224"></a>generalization of matching, we could simplify the system by using the
unifier to produce both streams.  Treating the easy case with the
simple matcher, however, illustrates how matching (as opposed to
full-blown unification) can be useful in its own right.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_680"><sup><small>73</small></sup></a>
ãƒ¦ãƒ‹ãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯ãƒãƒƒãƒãƒ³ã‚°ã®ä¸€èˆ¬åŒ–ãªã®ã§ã€ç§ãŸã¡ã¯ã€åŒæ–¹ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½œã‚Šå‡ºã™ã®ã«ãƒ¦ãƒ‹ãƒ•ã‚¡ã‚¤ã‚¢ã‚’ä½¿ã†ã“ã¨ã«ã‚ˆã£ã¦ã€ã‚·ã‚¹ãƒ†ãƒ ã‚’ç°¡ç´ åŒ–ã§ããŸã ã‚ã†ã€‚
ã—ã‹ã—ã€å˜ç´”ãªãƒãƒƒãƒãƒ£ã§ç°¡å˜ãªå ´åˆã‚’å–ã‚Šæ‰±ã†ã“ã¨ã§ã€(æœ¬æ ¼çš„ãƒ¦ãƒ‹ãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ã¯ãªã) ãƒãƒƒãƒãƒ³ã‚°ãŒãã‚Œè‡ªä½“ã®èƒ½åŠ›ã§ã©ã®ã‚ˆã†ã«æœ‰ç›ŠãŸã‚Šå¾—ã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ãŒä¾‹ç¤ºã•ã‚Œã‚‹ã®ã ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_682" href="#call_footnote_Temp_682"><sup><small>74</small></sup></a> The reason we use streams (rather than lists) of frames is that the
<a name="%_idx_5236"></a><a name="%_idx_5238"></a>recursive application of rules can generate
infinite numbers of values that satisfy a query.  The delayed
evaluation embodied in streams is crucial here: The system will print
responses one by one as they are generated, regardless of whether
there are a finite or infinite number of responses.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_682"><sup><small>74</small></sup></a>
ãƒ•ãƒ¬ãƒ¼ãƒ ã® (ãƒªã‚¹ãƒˆã§ãªã) ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½¿ã†ç†ç”±ã¯ã€è¦å‰‡ã®å†å¸°çš„é©ç”¨ãŒã€ã‚¯ã‚¨ãƒªã‚’æº€ãŸã™ç„¡é™å€‹ã®å€¤ã‚’ç”Ÿæˆã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ã§ã‚ã‚‹ã€‚
ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«ãŠã„ã¦å…·ç¾åŒ–ã•ã‚Œã¦ã„ã‚‹é…å»¶è©•ä¾¡ãŒã€ã“ã“ã§ã¯å¿…è¦ä¸å¯æ¬ ãªã®ã ã€‚
æœ‰é™å€‹ã®å¿œç­”ãŒã‚ã‚‹ã®ã‹ã€ãã‚Œã¨ã‚‚ç„¡é™å€‹ã®å¿œç­”ãŒã‚ã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã«é–¢ä¿‚ãªãã€ã‚·ã‚¹ãƒ†ãƒ ã¯ã€å¿œç­”ãŒç”Ÿæˆã•ã‚Œã‚‹ã®ã«ã¤ã‚Œã¦ã€å¿œç­”ã‚’ä¸€ã¤ãšã¤å°å­—ã™ã‚‹ã ã‚ã†ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_683" href="#call_footnote_Temp_683"><sup><small>75</small></sup></a> That a particular method of inference is
legitimate is not a trivial assertion.  One must prove that if one
starts with true premises, only true conclusions can be derived.  The
method of inference represented by rule applications is <a name="%_idx_5250"></a><em>modus
ponens</em>, the familiar method of inference that says that if <em>A</em> is
true and <em>A implies B</em> is true, then we may conclude that <em>B</em>
is true.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_683"><sup><small>75</small></sup></a>
æ¨è«–ã®ç‰¹å®šã®æ‰‹æ³•ãŒæ­£å½“ã§ã‚ã‚‹ã€ã¨ã„ã†ã“ã¨ã¯ã€ç‘£æœ«ãªä¸»å¼µã§ã¯ãªã„ã€‚
äººã¯ã€ã‚‚ã—çœŸã®å‰æã‹ã‚‰é–‹å§‹ã™ã‚‹ãªã‚‰çœŸã®çµè«–ã®ã¿ã‚’å°å‡ºã§ãã‚‹ã€ã¨ã„ã†ã“ã¨ã‚’è¨¼æ˜ã›ã­ã°ãªã‚‰ãªã„ã€‚
è¦å‰‡é©ç”¨ã«ã‚ˆã‚Šè¡¨ã•ã‚Œã‚‹æ¨è«–ã®æ‰‹æ³•ã¯ã€<em class="en">modus ponens</em> â€”â€”ã‚‚ã— <em class="en">A</em> ãŒçœŸã§ã‚ã‚Šã€ã‹ã¤ã€<em class="en">B</em> ãŒçœŸã§ã‚ã‚‹ã“ã¨ã‚’ <em class="en">A</em> ãŒ<em>å«æ„ã™ã‚‹</em>ãªã‚‰ã°ã€<em class="en">B</em> ãŒçœŸã ã¨çµè«–ã¥ã‘ã¦ã‚ˆã„ã€ã¨è¿°ã¹ã‚‹ã€ãŠãªã˜ã¿ã®æ¨è«–æ‰‹æ³•â€”â€”ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_684" href="#call_footnote_Temp_684"><sup><small>76</small></sup></a> We must qualify this statement by
agreeing that, in speaking of the ``inference'' accomplished by a
logic program, we assume that the computation terminates.
Unfortunately, even this qualified statement is false for our
implementation of the query language (and also false for programs in
Prolog and most other current logic programming languages) because of
our use of <tt>not</tt> and <tt>lisp-value</tt>.  As we will describe below,
the <tt>not</tt> implemented in the query language is not always
consistent with the <tt>not</tt> of mathematical logic, and <tt>lisp-value</tt> introduces additional complications.  We could implement a
language consistent with mathematical logic by simply removing <tt>not</tt> and <tt>lisp-value</tt> from the language and agreeing to write
programs using only simple queries, <tt>and</tt>, and <tt>or</tt>.  However,
this would greatly restrict the expressive power of the language.  One
of the major concerns of research in logic programming is to find ways
to achieve more consistency with mathematical logic without unduly
sacrificing expressive power.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_684"><sup><small>76</small></sup></a>
ç§ãŸã¡ã¯ã€ã“ã®é™³è¿°ã‚’å’Œã‚‰ã’ã­ã°ãªã‚‰ãªã„â€”â€”è«–ç†ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ã‚ˆã‚Šé”æˆã•ã‚Œã‚‹ã€Œæ¨è«–ã€ã«è¨€åŠã™ã‚‹éš›ã«ã€ç§ãŸã¡ã¯ã€è¨ˆç®—ãŒçµ‚äº†ã™ã‚‹ã¨æƒ³å®šã—ã¦ã„ã‚‹ã€ã¨åŒæ„ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€‚
ã‚ã„ã«ãã€ã“ã®å’Œã‚‰ã’ãŸé™³è¿°ã§ã•ãˆã‚‚ã€ç§ãŸã¡ãŒ <tt>not</tt> ã¨ <tt>lisp-value</tt> ã‚’ä½¿ã†ã›ã„ã§ã€ã‚¯ã‚¨ãƒªè¨€èªã®ç§ãŸã¡ã«ã‚ˆã‚‹å®Ÿè£…ã«ã¨ã£ã¦ã¯ã€å½ã§ã‚ã‚‹ (ãã—ã¦ã¾ãŸã€Prolog ã‚„ã€ä»–ã®ã»ã¨ã‚“ã©ã®ç¾åœ¨ã®è«–ç†ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã§æ›¸ã‹ã‚ŒãŸãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ã¨ã£ã¦ã‚‚ã€å½ã§ã‚ã‚‹)ã€‚
ã“ã®å¾Œã«è¿°ã¹ã‚‹ã¨ãŠã‚Šã€ã‚¯ã‚¨ãƒªè¨€èªã§å®Ÿè£…ã•ã‚Œã‚‹ <tt>not</tt> ã¯ã€å¸¸ã«æ•°å­¦çš„è«–ç†ã® <tt>not</tt> ã¨æ•´åˆæ€§ãŒã‚ã‚‹ã‚ã‘ã§ã¯ãªã„ã—ã€<tt>lisp-value</tt> ã¯ã•ã‚‰ãªã‚‹ã‚„ã‚„ã“ã—ã•ã‚’ã‚‚ãŸã‚‰ã™ã€‚
å˜ã«ã€è¨€èªã‹ã‚‰ <tt>not</tt> ã¨ <tt>lisp-value</tt> ã‚’å–ã‚Šé™¤ãã¨ã¨ã‚‚ã«ã€å˜ç´”ã‚¯ã‚¨ãƒªã¨ <tt>and</tt> ã¨ <tt>or</tt> ã®ã¿ã‚’ä½¿ã£ã¦ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ãã“ã¨ã«åŒæ„ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€ç§ãŸã¡ã¯ã€æ•°å­¦çš„è«–ç†ã¨æ•´åˆæ€§ã®ã‚ã‚‹è¨€èªã‚’å®Ÿè£…ã§ããŸã§ã‚ã‚ã†ã€‚
ã—ã‹ã—ã€ã“ã‚Œã¯è¨€èªã®è¡¨ç¾åŠ›ã‚’éå¸¸ã«åˆ¶é™ã—ã¦ã—ã¾ã†ã€‚
è«–ç†ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã«ãŠã‘ã‚‹ç ”ç©¶ã®ä¸»è¦ãªé–¢å¿ƒäº‹ã®ã†ã¡ã®ä¸€ã¤ã¯ã€éåº¦ã«è¡¨ç¾åŠ›ã‚’çŠ ç‰²ã«ã™ã‚‹ã“ã¨ãªãã€æ•°å­¦çš„è«–ç†ã¨ã®ã•ã‚‰ãªã‚‹æ•´åˆæ€§ã‚’é”æˆã™ã‚‹æ–¹æ³•ã‚’ã€è¦‹ã¤ã‘å‡ºã™ã“ã¨ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_686" href="#call_footnote_Temp_686"><sup><small>77</small></sup></a> This is not a problem of the logic but one of the
procedural interpretation of the logic provided by our interpreter.
We could write an interpreter that would not fall into a loop here.
For example, we could enumerate all the proofs derivable from our
assertions and our rules in a breadth-first rather than a depth-first
order.  However, such a system makes it more difficult to take
advantage of the order of deductions in our programs.  One attempt to
build sophisticated control into such a program is described in
<a name="%_idx_5264"></a>deKleer et al. 1977.  Another technique, which does not lead to such
serious control problems, is to put in special knowledge, such as
detectors for particular kinds of loops
(exercise <a href="#%_thm_4.67">4.67</a>).  However, there can be no
general scheme for reliably preventing a system from going down
infinite paths in performing deductions.  Imagine a diabolical rule of
the form ``To show <em>P</em>(<em>x</em>) is true, show that <em>P</em>(<em>f</em>(<em>x</em>)) is true,'' for
some suitably chosen function <em>f</em>.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_686"><sup><small>77</small></sup></a>
ã“ã‚Œã¯è«–ç†ã®å•é¡Œã§ã¯ãªãã€ç§ãŸã¡ã®ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«ã‚ˆã‚Šæä¾›ã•ã‚Œã‚‹ã€è«–ç†ã®æ‰‹ç¶šãçš„è§£é‡ˆã®å•é¡Œã§ã‚ã‚‹ã€‚
ã“ã“ã§ã¯ãƒ«ãƒ¼ãƒ—ã«é™¥ã‚‰ãªã„ã ã‚ã†ã€ã¨ã„ã†ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã‚’ã€ç§ãŸã¡ã¯æ›¸ãã“ã¨ãŒã§ãã‚‹ã ã‚ã†ã€‚
ä¾‹ãˆã°ã€ç§ãŸã¡ã¯ã€è‡ªåˆ†ã®è¨€æ˜ã¨è¦å‰‡ã‹ã‚‰å°å‡ºå¯èƒ½ãªã™ã¹ã¦ã®è¨¼æ˜ã‚’ã€æ·±ã•å„ªå…ˆé †ã§ã¯ãªãå¹…å„ªå…ˆé †ã§ã€æ•°ãˆä¸Šã’ã‚‹ã“ã¨ãŒã§ãã‚‹ã ã‚ã†ã€‚
ã—ã‹ã—ã€ãã†ã—ãŸã‚·ã‚¹ãƒ†ãƒ ã¯ã€ç§ãŸã¡ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã®æ¼”ç¹¹ã®é †åºã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ã‚’ã€ã‚ˆã‚Šå›°é›£ã«ã—ã¦ã—ã¾ã†ã€‚
ãã†ã—ãŸãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ä¸­ã«æ´—ç·´ã•ã‚ŒãŸåˆ¶å¾¡ã‚’çµ„ã¿è¾¼ã‚€ãŸã‚ã®ä¸€ã¤ã®è©¦ã¿ã¯ã€deKleer et al. 1977 ã«èª¬æ˜ã•ã‚Œã¦ã„ã‚‹ã€‚
ã‚‚ã†ä¸€ã¤åˆ¥ã®æŠ€æ³•ã¯ã€ãã†ã„ã†æ·±åˆ»ãªåˆ¶å¾¡ã®å•é¡Œã‚’å¼•ãèµ·ã“ã•ãªã„ã‚‚ã®ãªã®ã ãŒã€ç‰¹å®šã®ç¨®é¡ã®ãƒ«ãƒ¼ãƒ—ã«å¯¾ã™ã‚‹æ¤œå‡ºå™¨ã®ã‚ˆã†ãªã€ç‰¹æ®ŠãªçŸ¥è­˜ã‚’æç¤ºã™ã‚‹ã“ã¨ã§ã‚ã‚‹ (ç·´ç¿’å•é¡Œ<a href="#%_thm_4.67">4.67</a>)ã€‚
ã—ã‹ã—ã€ã‚·ã‚¹ãƒ†ãƒ ãŒæ¼”ç¹¹ã‚’å®Ÿè¡Œã™ã‚‹éš›ã«ç„¡é™ã®çµŒè·¯ã‚’é™ã‚Šã¦ã‚†ãã®ã‚’ã€æœŸå¾…ã©ãŠã‚Šã«é˜²ããŸã‚ã®ä¸€èˆ¬çš„ãªä½“ç³»ãªã©ã€ã‚ã‚Šå¾—ãªã„ã€‚
ã‚ã‚‹é©åˆ‡ã«é¸ã°ã‚ŒãŸ <em class="en">f</em> ã¨ã„ã†é–¢æ•°ã«ã¤ã„ã¦ã€
ã€Œ<em class="en">P</em>(<em class="en">x</em>) ãŒçœŸã ã¨ç¤ºã™ãŸã‚ã«ã¯ã€<em class="en">P</em>(<em class="en">f</em>(<em class="en">x</em>)) ãŒçœŸã ã¨ç¤ºã›ã€
ã¨ã„ã†å½¢å¼ã®ã€é‚ªæ‚ªãªè¦å‰‡ã‚’æƒ³åƒã—ã¦ã¿ãŸã¾ãˆã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_688" href="#call_footnote_Temp_688"><sup><small>78</small></sup></a> Consider the query <tt>(not (baseball-fan (Bitdiddle Ben)))</tt>.  The system finds that <tt>(baseball-fan (Bitdiddle Ben))</tt> is not in the data base, so the empty
frame does not satisfy the pattern and is not filtered out of the
initial stream of frames.  The result of the query is thus the empty
frame, which is used to instantiate the input query to produce <tt>(not (baseball-fan (Bitdiddle Ben)))</tt>.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_688"><sup><small>78</small></sup></a>
<tt>(not (baseball-fan (Bitdiddle Ben)))</tt> ã¨ã„ã†ã‚¯ã‚¨ãƒªã‚’è€ƒãˆã‚ˆã†ã€‚
ã‚·ã‚¹ãƒ†ãƒ ã¯ã€<tt>(baseball-fan (Bitdiddle Ben))</tt> ãŒãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å†…ã«å­˜åœ¨ã—ãªã„ã¨çŸ¥ã‚Šã€ã‚ˆã£ã¦ã€ç©ºãƒ•ãƒ¬ãƒ¼ãƒ ã¯ã€ã“ã®ãƒ‘ã‚¿ãƒ³ã‚’æº€ãŸã•ãšã€ãƒ•ãƒ¬ãƒ¼ãƒ ã®åˆæœŸã‚¹ãƒˆãƒªãƒ¼ãƒ ã‹ã‚‰é™¤å¤–ã•ã‚Œãªã„ã€‚
ã—ãŸãŒã£ã¦ã€ã‚¯ã‚¨ãƒªã®çµæœã¯ç©ºãƒ•ãƒ¬ãƒ¼ãƒ ã§ã‚ã‚Šã€ã“ã®ç©ºãƒ•ãƒ¬ãƒ¼ãƒ ã¯ã€å…¥åŠ›ã‚¯ã‚¨ãƒªã‚’ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã—ã¦ <tt>(not (baseball-fan (Bitdiddle Ben)))</tt> ã‚’ä½œã‚Šå‡ºã™ã®ã«ä½¿ã‚ã‚Œã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_689" href="#call_footnote_Temp_689"><sup><small>79</small></sup></a> A discussion and justification of this
<a name="%_idx_5274"></a>treatment of <tt>not</tt> can be found in the article by Clark (1978).</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_689"><sup><small>79</small></sup></a>
<tt>not</tt> ã®ã“ã†ã—ãŸå–ã‚Šæ‰±ã„ã«ã¤ã„ã¦ã®è­°è«–ã¨æ­£å½“åŒ–ã¯ã€Clark (1978) ã«ã‚ˆã‚‹è«–æ–‡ã«è¦‹ã„ã ã™ã“ã¨ãŒã§ãã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_700" href="#call_footnote_Temp_700"><sup><small>80</small></sup></a> In general, unifying <tt>?y</tt> with an expression involving
<a name="%_idx_5366"></a><tt>?y</tt> would require our being able to find a fixed point of the
equation <tt>?y</tt>  =  &lt;<em>expression involving <tt>?y</tt></em>&gt;.  It is
sometimes possible to syntactically form an expression that appears to
be the solution.  For example, <tt>?y</tt>  =  <tt>(f ?y)</tt> seems to have
the fixed point <tt>(f (f (f <tt>...</tt> )))</tt>, which we can produce by
beginning with the expression <tt>(f ?y)</tt> and repeatedly substituting
<tt>(f ?y)</tt> for <tt>?y</tt>.  Unfortunately, not every such equation has
a meaningful fixed point.  The issues that arise here are similar to
the issues of manipulating <a name="%_idx_5368"></a>infinite series in mathematics.  For
example, we know that 2 is the solution to the equation <em>y</em>  =  1  +  <em>y</em>/2.
Beginning with the expression 1  +  <em>y</em>/2 and repeatedly substituting 1
 +  <em>y</em>/2 for <em>y</em> gives
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_700"><sup><small>80</small></sup></a>
</p>


<figure><img src="ch4-Z-G-7.gif" border="0"></figure>

<p class="orig" lang="en">which leads to</p>

<p class="trans" lang="ja">
</p>

<figure><img src="ch4-Z-G-8.gif" border="0"></figure>

<p class="orig" lang="en">However, if we try the same manipulation beginning with the
observation that  - 1 is the solution to the equation <em>y</em>  =  1  +  2<em>y</em>, we
obtain
</p>

<p class="trans" lang="ja">
</p>

<figure><img src="ch4-Z-G-9.gif" border="0"></figure>


<p class="orig" lang="en">which leads to </p>


<p class="trans" lang="ja">
</p>

<figure><img src="ch4-Z-G-10.gif" border="0"></figure>

<p class="orig" lang="en">Although the formal manipulations used in deriving these two equations
are identical, the first result is a valid assertion about infinite
series but the second is not.  Similarly, for our unification results,
reasoning with an arbitrary syntactically constructed expression may
lead to errors. </p>


<p class="trans" lang="ja">
</p>

<p class="orig" lang="en"><a name="footnote_Temp_702" href="#call_footnote_Temp_702"><sup><small>81</small></sup></a> Most Lisp systems give the user the ability to
modify the ordinary <tt>read</tt> procedure to perform such
transformations by defining <a name="%_idx_5402"></a><a name="%_idx_5404"></a><a name="%_idx_5406"></a><a name="%_idx_5408"></a><em>reader macro characters</em>.  Quoted
expressions are already handled in this way: The reader automatically
translates <tt>'expression</tt> into <tt>(quote expression)</tt> before the
evaluator sees it.  We could arrange for <tt>?expression</tt> to be
transformed into <tt>(? expression)</tt> in the same way; however, for
the sake of clarity we have included the transformation procedure here
explicitly.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_702"><sup><small>81</small></sup></a>
</p>

<p class="orig" lang="en">
<a name="%_idx_5410"></a><tt>Expand-question-mark</tt> and <tt>contract-question-mark</tt> use
several procedures with <tt>string</tt> in their names.
These are Scheme primitives.</p>

<p class="trans" lang="ja">
</p>

</div>
</body>
</html>
