<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="sicp.css" type="text/css">
<base target="_top">
<title>SICP私訳: 3.4 並行性: 時間は本質的なものである</title>
<link rel="canonical" href="https://piyo-ko.github.io/SICP/23_sec3_4.html" />
</head>
<body>

<div class="idx-bar">
<nav>
<a href="https://twitter.com/share" class="twitter-share-button" data-lang="ja">ツイート</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
<span class="status">推敲待ち</span>
[
<a href="00_cover.html">先頭へ</a> |
<a href="22_sec3_3.html">前へ</a> |
<a href="24_sec3_5.html">次へ</a> |
<a href="04_toc.html#%_toc_start">目次</a> |
<a href="38_index.html#%_index_start">索引</a>
] [<a href="99_about.html">この対訳版について</a> | <a href="../index.html">ホーム</a>]
[
§<a href="#%_sec_3.4">3.4</a>
§<a href="#%_sec_3.4.1">3.4.1</a>
📚<a href="#%_sec_Temp_408">&hellip;</a>
🎨<a href="#%_fig_3.29">3.29</a>
🎨<a href="#%_fig_3.30">3.30</a>
📝<a href="#%_thm_3.38">3.38</a>
§<a href="#%_sec_3.4.2">3.4.2</a>
📚<a href="#%_sec_Temp_413">&hellip;</a>
📚<a href="#%_sec_Temp_414">&hellip;</a>
📝<a href="#%_thm_3.39">3.39</a>
📝<a href="#%_thm_3.40">3.40</a>
📝<a href="#%_thm_3.41">3.41</a>
📝<a href="#%_thm_3.42">3.42</a>
📚<a href="#%_sec_Temp_420">&hellip;</a>
📝<a href="#%_thm_3.43">3.43</a>
📝<a href="#%_thm_3.44">3.44</a>
📝<a href="#%_thm_3.45">3.45</a>
📚<a href="#%_sec_Temp_427">&hellip;</a>
📝<a href="#%_thm_3.46">3.46</a>
📝<a href="#%_thm_3.47">3.47</a>
📚<a href="#%_sec_Temp_434">&hellip;</a>
📝<a href="#%_thm_3.48">3.48</a>
📝<a href="#%_thm_3.49">3.49</a>
📚<a href="#%_sec_Temp_438">&hellip;</a>
<a href="#footnotes">脚注</a>
]
</nav>


</div>
<!--
$ curl -o ch3-Z-G-#1.gif https://mitpress.mit.edu/sicp/full-text/book/ch3-Z-G-[31-33].gif
-->
<div class="main-txt">
<a name="%_sec_3.4"></a>
<h2 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_3.4">3.4  Concurrency: Time Is of the Essence</a></h2>
<h2 class="trans" lang="ja">3.4 並行性: 時間は本質的なものである</h2>


<p class="orig" lang="en">
<a name="%_idx_3578"></a>
We've seen the power of computational objects with local state as
tools for modeling.  Yet, as section <a href="20_sec3_1.html#%_sec_3.1.3">3.1.3</a>
warned, this power extracts a price: the loss of referential
transparency, giving rise to a thicket of questions about sameness and
change, and the need to abandon the substitution model of evaluation in
favor of the more intricate environment model.</p>

<p class="trans" lang="ja">
私たちは、局所状態のある計算オブジェクトの、モデル化の手段としての力を見てきた。
しかし、<a href="20_sec3_1.html#%_sec_3.1.3">3.1.3</a>節で警告したとおり、この力は代償をもたらすのだ。つまり、参照等価性の喪失やら、同一性と変化についての疑念の、錯綜した山を引き起こすことやら、より込み入った環境モデルに取り替えることにして、評価の<ruby><rb>代入</rb><rp> (</rp><rt>おきかえ</rt><rp>) </rp></ruby>モデルを捨てる必要性やら、といった代償である。
</p>

<p class="orig" lang="en">
<a name="%_idx_3580"></a>The central issue lurking beneath the complexity of state, sameness,
and change is that by introducing assignment we are forced to admit
<em>time</em> into our computational models.  Before we introduced
assignment, all our programs were timeless, in the sense that any
expression that has a value always has the same value.  In contrast,
recall the example of modeling withdrawals from a bank account
and returning the resulting balance,
introduced at the beginning of
section <a href="20_sec3_1.html#%_sec_3.1.1">3.1.1</a>:</p>

<p class="trans" lang="ja">
状態と同一性と変化との複雑性の下に潜んでいる中心的な問題は、<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>を導入することで、計算モデルに<em>時間</em>を受け入れることを認めざるをえなくなる、ということである。
<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>を導入する前は、私たちのプログラムのすべては、時間と無関係だった——値を持っている式はどれも、その同じ値を常に持っている、という意味で。
対照的に、銀行口座からの引き出しをモデル化してその結果の残高を返す例——<a href="20_sec3_1.html#%_sec_3.1.1">3.1.1</a>の最初に導入したもの——を思い起こそう。
</p>

<p class="lisp">(withdraw 25)
<i>75</i>
(withdraw 25)
<i>50</i>
</p>


<p class="orig" lang="en">
Here successive evaluations of the same expression yield different
values.  This behavior arises from the fact that the execution of
assignment statements (in this case, assignments to the variable <tt>balance</tt>) delineates <em>moments in time</em> when values change.  The
result of evaluating an expression depends not only on the expression
itself, but also on whether the evaluation occurs before or after
these moments.  Building models in terms of computational objects with
local state forces us to confront time as an essential concept in
programming.</p>

<p class="trans" lang="ja">
ここでは、同じ式の連続した評価が、異なる値を生み出す。
この振る舞いは、<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>文 (この場合は、<tt>balance</tt> という変数への<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>) の実行が、値が変化する<em>時点</em>を精密に説明するのだ、という事実から生じる。
式を評価した結果は、その式自体に依存するだけでなく、これらの時点の前に評価が起きたのか、それとも後に起きたのか、ということにも依存する。
局所状態のある計算オブジェクトを使ってモデルを構築することで、私たちは、プログラミングにおける本質的な概念として、時間と直面せざるをえなくなるのだ。
</p>

<p class="orig" lang="en">
We can go further in structuring computational models to match our
perception of the physical world.  Objects in the world do not change
one at a time in sequence.  Rather we perceive them as acting <em>concurrently</em> -- all at once.  So it is often natural to model systems
as collections of computational processes that execute concurrently.
Just as we can make our programs modular by organizing models in
terms of objects with separate local state, it is often appropriate to
divide computational models into parts that evolve separately and
concurrently.  Even if the programs are to be executed on a sequential
computer, the practice of writing programs as if they were to be
executed concurrently forces the programmer to avoid inessential
timing constraints and thus makes programs more modular.</p>

<p class="trans" lang="ja">
物理世界についての自分たちの認識に一致するように、計算モデルを構造化することに関して、私たちは、さらに踏み出すことができる。
世界の中の<ruby><rb>物</rb><rp> (</rp><rt>オブジェクト</rt><rp>) </rp></ruby>
は、一度に一つづつ順番に変化するのではない。
むしろ、私たちは、それらの物が<em>並行して</em>——すべてが一度に——行動している、と知覚する。
だから、並行して実行される計算プロセスの集まりとして<ruby><rb>系</rb><rp> (</rp><rt>システム</rt><rp>) </rp></ruby>をモデル化するのが自然であることが、しばしばあるのだ。
別々の局所状態をもったオブジェクトを使ってモデルを組織化することによって、プログラムをモジュール性のあるものにできるのとちょうど同じように、別々かつ並行に進展する幾つかの部分へと、計算モデルを分割することが適切なことが、しばしばある。
たとえプログラムが、<ruby><rb>逐次的</rb><rp> (</rp><rt>シーケンシャル</rt><rp>) </rp></ruby>コンピュータ上で実行されるべきものであろうとも、それらのプログラムがまるで並行に実行されるべきであるかのように、それらのプログラムを書くという練習により、プログラマは、非本質的なタイミング制約を避けざるをえなくなり、したがって、プログラムは、よりモジュール性のあるものになる。
</p>

<p class="orig" lang="en">
In addition to making programs more modular, concurrent computation
can provide a speed advantage over sequential computation.  Sequential
computers execute only one operation at a time, so the amount of time
it takes to perform a task is proportional to the total number of
operations performed.<a name="call_footnote_Temp_405" href="#footnote_Temp_405"><sup><small>34</small></sup></a>
However, if it is possible to decompose a problem into pieces that are
relatively independent and need to communicate only rarely, it may be
possible to allocate pieces to separate computing processors,
producing a speed advantage proportional to the number of processors
available.</p>

<p class="trans" lang="ja">
プログラムをよりモジュール性のあるものにすることに加えて、並行計算は、逐次計算に優る速度の利点を提供できる。
逐次的コンピュータは、一度に一つの演算しか実行せず、そのため、タスクを実行するのにかかる時間の量は、実行される演算の総数に比例する<a href="#footnote_Temp_405"><sup><small>34</small></sup></a>。
しかし、もし、比較的独立していて稀にしか通信する必要がないような幾つかの部分へと問題を分解することが可能なら、諸部分を別々のコンピューティング・プロセッサに割り当てることが可能かもしれない——それにより、利用可能なプロセッサの数に比例する、速度の利点を、生み出すことになろう。
</p>

<p class="orig" lang="en">
Unfortunately, the complexities introduced by assignment become even
more problematic in the presence of concurrency.  The fact of
concurrent execution, either because the world operates in parallel or
because our computers do, entails additional complexity in our
understanding of time.</p>

<p class="trans" lang="ja">
しかしあいにく、並行性が存在するところでは、<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>により持ち込まれた複雑性は、よりずっと難しい問題になるのだ。
並行実行という事実は、世界が並列に動いているからであろうが、あるいは、私たちのコンピュータが並列に動いているからであろうが、時間についての私たちの理解に、付加的な複雑さを否応なくもたらす。
</p>


<a name="%_sec_3.4.1"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_3.4.1">3.4.1  The Nature of Time in Concurrent Systems</a></h3>
<h3 class="trans" lang="ja">3.4.1 並行システムにおける時間の本質</h3>


<p class="orig" lang="en">
<a name="%_idx_3584"></a>
On the surface, time seems straightforward.  It
is an ordering imposed on events.<a name="call_footnote_Temp_406" href="#footnote_Temp_406"><sup><small>35</small></sup></a>
For any events <em>A</em> and <em>B</em>, either <em>A</em> occurs before <em>B</em>, <em>A</em> and <em>B</em>
are simultaneous, or <em>A</em> occurs after <em>B</em>.  For instance,
returning to the bank account example, suppose that Peter withdraws
$10 and Paul withdraws $25 from a <a name="%_idx_3588"></a>joint account that initially
contains $100, leaving $65 in the account.  Depending on the order
of the two withdrawals, the sequence of balances in the account is
either $100 <img src="book-Z-G-D-15.gif" border="0"> $90 <img src="book-Z-G-D-15.gif" border="0"> $65 or
$100 <img src="book-Z-G-D-15.gif" border="0"> $75 <img src="book-Z-G-D-15.gif" border="0"> $65.  In a computer implementation
of the banking system, this changing sequence of balances could be
modeled by successive assignments to a variable <tt>balance</tt>.</p>

<p class="trans" lang="ja">
表面上は、時間はまっすぐに進むように見える。
時間は、<ruby><rb>出来事</rb><rp> (</rp><rt>イベント</rt><rp>) </rp></ruby>の上に押しつけられる順序づけである<a href="#footnote_Temp_406"><sup><small>35</small></sup></a>。
任意の <em class="en">A</em> および <em class="en">B</em> という出来事に対して、<em class="en">A</em> が <em class="en">B</em> の前に起きるか、<em class="en">A</em> と <em class="en">B</em> が同時か、<em class="en">A</em> が <em class="en">B</em> の後に起きるか、のいずれかである。
たとえば、銀行口座の例に戻ると、最初に100ドルを有している共同預金口座から、ピーターが10ドルを引き出して、ポールが25ドルを引き出すとすると、それにより、口座には65ドルが残る。
二回の引き出しの順序によって、口座残高の列は、
<span class="math">100ドル &rarr; 90ドル &rarr; 65ドル</span>
か、
<span class="math">100ドル &rarr; 75ドル &rarr; 65ドル</span>
の、いずれかである。
銀行システムのコンピュータ実装において、このような変化する残高の列は、<tt>balance</tt> という変数への連続した<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>により、モデル化できるだろう。
</p>

<p class="orig" lang="en">
In complex situations, however, such a view can be problematic.
Suppose that Peter and Paul, and other people besides, are
accessing the same bank account through a network of banking machines
distributed all over the world.  The actual sequence of balances in
the account will depend critically on the detailed timing of the
accesses and the details of the communication among the machines.</p>

<p class="trans" lang="ja">
しかし、複雑な状況では、そうした見方は、問題のあるものとなりかねない。
ピーターとポール、そしてさらに別の人たちが、世界中に分散した銀行取引用の機械のネットワークを通じて、同じ銀行口座にアクセスしているところだとしよう。
口座の残高の実際の列は、アクセスの細かいタイミングと、機械同士の間での通信の詳細に、決定的に依存するだろう。
</p>

<p class="orig" lang="en">
<a name="%_idx_3590"></a>This indeterminacy in the order of events can pose serious problems in
the design of concurrent systems.  For instance, suppose that the
withdrawals made by Peter and Paul are implemented as two separate
processes sharing a common variable <tt>balance</tt>, each process
specified by the procedure given in
section <a href="20_sec3_1.html#%_sec_3.1.1">3.1.1</a>:
</p>

<p class="trans" lang="ja">
出来事の順序における、この不確定性は、並行システムの設計に深刻な問題をもたらす可能性がある。
たとえば、ピーターとポールによって行われた引き出しが、 <tt>balance</tt> という共通の変数を共有している二つの別々のプロセス——各プロセスは  <a href="20_sec3_1.html#%_sec_3.1.1">3.1.1</a> 節で与えられた手続きにより規定されている——として実装されている、としよう。
</p>

<p class="lisp"><a name="%_idx_3592"></a>(define (withdraw amount)
  (if (&gt;= balance amount)
      (begin (set! balance (- balance amount))
             balance)
      &quot;Insufficient funds&quot;))
</p>


<p class="orig" lang="en">
If the two processes operate independently, then Peter might test the
balance and attempt to withdraw a legitimate amount.  However, Paul
might withdraw some funds in between the time that Peter checks the
balance and the time Peter completes the withdrawal, thus invalidating
Peter's test.</p>

<p class="trans" lang="ja">
もし二つのプロセスが独立に動作したら、ピーターは、残高を調べてから、合法な金額を引き出そうと試みるかもしれない。
しかし、ピーターが残高を調べる時点と、ピーターが引き出しを完了する時点との間に、ポールが何らかの資金を引き出すかもしれず、それによって、ピーターの検査を無効化してしまうかもしれない。
</p>

<p class="orig" lang="en">
Things can be worse still.  Consider the expression
</p>

<p class="trans" lang="ja">
ものごとは、さらに一層悪くなる可能性がある。
以下の式を考えよう。
</p>

<p class="lisp">(set! balance (- balance amount))
</p>

<p class="orig" lang="en">
executed as part of each withdrawal process.  This consists of three
steps: (1) accessing the value of the <tt>balance</tt> variable; (2)
computing the new balance; (3) setting <tt>balance</tt> to this new
value.  If Peter and Paul's withdrawals execute this statement
concurrently, then the two withdrawals might interleave the order in
which they access <tt>balance</tt> and set it to the new value.</p>

<p class="trans" lang="ja">
これは、それぞれの引き出しプロセスの一部として実行されるものである。
これは、
(1) <tt>balance</tt> という変数の値にアクセスし、
(2) 新たな残高を計算し、
(3) <tt>balance</tt> をこの新たな値に設定する、
という、三つのステップからなる。
もし、ピーターによる引き出しとポールによる引き出しがこの文を並行に実行したら、二度の引き出しは、それら二度の引き出しが <tt>balance</tt> にアクセスしてこれを新たな値に設定する際の順序を、<!--お互いの間に挟まり合うように混ぜて-->混ぜこぜにしてしまうかもしれない。
</p>

<p class="orig" lang="en">
The timing diagram in figure <a href="#%_fig_3.29">3.29</a> depicts an order of
events where <tt>balance</tt> starts at 100, Peter withdraws 10,
Paul withdraws 25, and yet the final value of <tt>balance</tt> is 75.  As
shown in the diagram, the reason for this anomaly is that Paul's
assignment of 75 to <tt>balance</tt> is made under the assumption that
the value of <tt>balance</tt> to be decremented is 100.  That assumption,
however, became invalid when Peter changed <tt>balance</tt> to 90.  This
is a catastrophic failure for the banking system, because the total
amount of money in the system is not conserved.  Before the transactions,
the total amount of money was $100.  Afterwards, Peter has $10, Paul
has $25, and the bank has $75.<a name="call_footnote_Temp_407" href="#footnote_Temp_407"><sup><small>36</small></sup></a></p>

<p class="trans" lang="ja">
図<a href="#%_fig_3.29">3.29</a>のタイミング図は、<tt>balance</tt> が100から始まり、ピーターが10を引き出し、ポールが25を引き出し、そして、それでもまだ <tt>balance</tt> の最終値が75だ、という出来事の順序を図示している。
図に示すように、この異常の理由は、ポールの <tt>balance</tt> への75の<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>が、これから減らすべき <tt>balance</tt> の値が100だ、という仮定のもとになされていることである。
その仮定は、しかし、ピーターが <tt>balance</tt> を90に変更したときに無効になったのだ。
これは、銀行システムにとって壊滅的な失敗である。なぜなら、システム内の総金額が保全されないからだ。
取引の前には、総金額は100ドルだった。
その後、ピーターは10ドルを持っていて、ポールは25ドルを持っていて、銀行は75ドルを持っているのだ<a href="#footnote_Temp_407"><sup><small>36</small></sup></a>。
</p>

<p class="orig" lang="en">
<a name="%_idx_3596"></a><a name="%_idx_3598"></a>The general phenomenon illustrated
here is that several processes may share  a
common state variable.  What makes this complicated is that more than
one process may be trying to manipulate the shared state at the same
time.  For the bank account example, during each transaction, each
customer should be able to act as if the other customers did not
exist.  When a customer changes the balance in a way that depends on
the balance, he must be able to assume that, just before the moment of
change, the balance is still what he thought it was.</p>

<p class="trans" lang="ja">
ここに例示した一般的現象は、いくつかのプロセスが共通の状態変数を共有するかもしれない、ということである。
これを複雑にしているのは、一つよりも多いプロセスが、その共有された状態を同時に操作しようとしているかもしれない、という点である。
銀行口座の例については、それぞれの取引の間はずっと、各顧客は、あたかも残りの顧客が存在しないかのように行動できるべきである。
ある顧客が残高に依存するような方法で残高を変更するとき、その顧客は、次のように想定できなくてはならない。つまり、変更の瞬間の直前において、依然として残高は、自分がその残高はこの額だなと思ったとおりのままである、と。
</p>

<a name="%_sec_Temp_408"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_408">Correct behavior of concurrent programs</a></h4>
<h4 class="trans" lang="ja">並行なプログラムの正しい振る舞い</h4>

<p class="orig" lang="en">
<a name="%_idx_3600"></a>
The above example typifies the subtle bugs that can creep into
concurrent programs.  The root of this complexity lies in the
assignments to variables that are shared among the different
processes.  We already know that we must be careful in writing
programs that use <tt>set!</tt>, because the results of a computation
depend on the order in which the assignments occur.<a name="call_footnote_Temp_409" href="#footnote_Temp_409"><sup><small>37</small></sup></a>
With concurrent processes we must be especially careful about
assignments, because we may not be able to control the order of the
assignments made by the different processes.  If several such changes
might be made concurrently (as with two depositors accessing a joint
account) we need some way to ensure that our system behaves correctly.
For example, in the case of withdrawals from a joint bank account, we
must ensure that money is conserved.
To make concurrent programs behave correctly, we may have to
place some restrictions on concurrent execution.</p>

<p class="trans" lang="ja">
上記の例は、並行なプログラムの中に入り込み得る、とらえがたいバグの典型例を示している。
この複雑さの根源は、異なるプロセス間で共有される変数への<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>にある。
<tt>set!</tt> を使うプログラムを書く際には、<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>が生じる順序に計算結果が依存するので、注意深くなくてはいけない、ということを、私たちは既に知っている<a href="#footnote_Temp_409"><sup><small>37</small></sup></a>。
並行なプロセスを使うとき、私たちはとりわけ<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>について注意深くなくてはいけない。というのも、異なるプロセスにより行われる<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>の順序を、自分では制御できないかもしれないからだ。
もし、(共同預金口座にアクセスする二人の預金者の場合のように) いくつかのそうした変更が並行に行われるならば、自分のシステムが正しく振る舞うことを保証するための何らかの方法が必要である。
たとえば、共同預金口座からの引き出しの場合だと、金銭が保全されることを保証せねばならない。
並行なプログラムを正しく振る舞わせるためには、並行な実行に対して、何らかの制約を課す必要があるかもしれない。
</p>


<figure>
<a name="%_fig_3.29"></a>
<img src="ch3-Z-G-31.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.29:</b>  Timing diagram showing how interleaving the order of events
in two banking withdrawals can lead to an incorrect final balance.</figcaption>
<figcaption class="trans" lang="ja"><b>図3.29:</b> 銀行手続き上の二回の引き出しにおける出来事の順序を<!--、お互いの間に挟まり合うように混ぜる-->混ぜこぜにすることが、どのようにして、不正な最終残高という結果を引き起こし得るのか、を示すタイミング図</figcaption>
<a name="%_idx_3602"></a>
</figure>

<p class="orig" lang="en">
One possible restriction on concurrency would
stipulate that no two operations that
change any shared state variables can occur at the same time.  This is an
extremely stringent requirement.  For distributed banking, it would
require the system designer to ensure that only one transaction could
proceed at a time.  This would be both inefficient and overly
conservative.  Figure <a href="#%_fig_3.30">3.30</a> shows Peter and
Paul sharing a bank account, where Paul has a private account as well.
The diagram illustrates two withdrawals from the shared account
(one by Peter and one by Paul) and a deposit to Paul's private account.<a name="call_footnote_Temp_410" href="#footnote_Temp_410"><sup><small>38</small></sup></a>
The two withdrawals from the shared account must not be
concurrent (since both access and update the same account), and Paul's
deposit and withdrawal must not be concurrent (since both access and
update the amount in Paul's wallet).
But there should be no problem
permitting Paul's deposit to his private account to proceed
concurrently with Peter's withdrawal from the shared account.</p>

<p class="trans" lang="ja">
並行性に対する一つの可能な制約は、どれか共有された状態変数を変更するような、いかなる二つの演算も、同時には起こり得ない、と規定するであろう。
これは非常に厳格な要求である。
分散銀行業についてだと、一度にたった一つの取引のみが進行できるのだと保証するよう、システム設計者に要求することになるだろう。
これは、非効率的でもあり、過剰に慎重でもあるだろう。
図<a href="#%_fig_3.30">3.30</a>は、ピーターとポールが銀行口座を共有していて、ただしポールは個人口座も持っている、ということを示している。
この図は、共有口座からの二回の引き出し (一回はピーターによるもの、もう一回はポールによるもの) と、ポールの個人口座への一回の預け入れとを示している<a href="#footnote_Temp_410"><sup><small>38</small></sup></a>。
共有口座からの二回の引き出しは、並行であってはならず (なぜなら、双方が同じ口座にアクセスしてこれを更新するからである) 、ポールの預け入れと引き出しも並行であってはならない (なぜなら、双方がポールの財布の中の金額にアクセスしてこれを更新するからである)。
しかし、ポールによる自分の個人口座への預け入れが、ピーターによる共有口座からの引き出しと並行に進行することを許すことは、何の問題もないはずだ。
</p>


<a name="%_fig_3.30"></a>
<figure>
<img src="ch3-Z-G-32.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.30:</b>  Concurrent deposits and withdrawals from a joint account
in Bank1 and a private account in Bank2.</figcaption>
<figcaption class="trans" lang="ja"><b>図3.30:</b> 銀行その1の共同口座と銀行その2の個人口座に対する、並行した預け入れと引き出し</figcaption>
</figure>


<p class="orig" lang="en">
A less stringent restriction on concurrency would ensure that a
concurrent system produces the same result
as if the processes had run sequentially in some order.
There are two important aspects to this requirement.
First, it does not require the processes to actually run sequentially,
but only to produce results that are the same <em>as if</em> they had run
sequentially.  For the example in
figure <a href="#%_fig_3.30">3.30</a>, the designer of the bank account
system can safely allow Paul's deposit and Peter's withdrawal to
happen concurrently, because the net result will be the same as if the
two operations had happened sequentially.  Second, there may be more
than one possible ``correct'' result produced by a concurrent program,
because we require only that the result be the same as for <em>some</em>
sequential order.
For example, suppose that Peter and Paul's joint account starts out
with $100, and Peter deposits $40 while Paul concurrently withdraws
half the money in the account.
Then sequential execution could result in the account balance being
either $70 or $90 (see exercise <a href="#%_thm_3.38">3.38</a>).<a name="call_footnote_Temp_411" href="#footnote_Temp_411"><sup><small>39</small></sup></a></p>

<p class="trans" lang="ja">
並行性に対する緩めの制約は、まるでプロセスが何らかの順序で逐次的に実行されたのと同じであるような結果を、並行システムが生み出すことを、保証するだろう。
この要件に対しては、二つの重要な側面がある。
第一に、これは、プロセスが実際に逐次的に実行されることを求めているわけではなく、ただ、プロセスが<em>まるで</em>逐次的に実行されたのと同じであるような結果を生み出すことだけを、求めている。
図<a href="#%_fig_3.30">3.30</a>の例について言うと、銀行口座システムの設計者は、ポールの預け入れとピーターの引き出しが並行に生じることを、何の差し支えもなく、許すことができる。なぜなら、最終的な結果は、まるで二つの操作が逐次的に起きたのと同じになるだろうから。
第二に、並行プログラムによって生み出される、可能性のある「正しい」結果が、一つならず存在するかもしれない。なぜなら、私たちは、<em>何らかの</em>逐次的順序について、それと結果が同じになることだけを求めているからである。
<!--たとえば、ピーターとポールの共同口座が100ドルから始まって、ピーターが40ドルを預け入れ、その間に並行してポールが口座の金額の半分を引き出す、と仮定する。-->
たとえば、ピーターとポールの共同口座が100ドルから始まって、ポールが並行して口座の金額の半分を引き出している間にピーターが40ドルを預け入れる、と仮定する。
すると、逐次的な実行は、口座残高が70ドルか90ドルのいずれか、という結果を招き得るだろう (練習問題<a href="#%_thm_3.38">3.38</a>を参照)
<a href="#footnote_Temp_411"><sup><small>39</small></sup></a>。
</p>

<p class="orig" lang="en">
There are still weaker requirements for correct execution of
concurrent programs.  A program for simulating <a name="%_idx_3606"></a>diffusion (say, the
flow of heat in an object) might consist of a large number of
processes, each one representing a small volume of space, that update
their values concurrently.  Each process repeatedly changes its
value to the average of its own value and its neighbors' values.
This algorithm
converges to the right answer independent of the order in which the
operations are done; there is no need for any restrictions on
concurrent use of the shared values.</p>

<p class="trans" lang="ja">
並行プログラムの正しい実行に対する、さらに弱い要件がある。
拡散 (たとえば、ある物体の中での熱の流れ) をシミュレートするためのプログラムは、自分自身の値を並行に更新するような多数のプロセス——その一つ一つは、空間の小さな体積を表している——からなるかもしれない。
各プロセスは、繰り返し、自分の値を、自分自身の値と自分の隣接者の値との平均へと、変更する。
このアルゴリズムは、演算が行われる順序とは無関係に、正しい答えに収束する。共有されている値の並行利用に対して、何の制約も必要ないのだ。
</p>



<p class="orig" lang="en"><a name="%_thm_3.38"></a>
<b>Exercise 3.38.</b>  Suppose that Peter, Paul, and Mary share a joint bank account that
initially contains $100.  Concurrently, Peter deposits $10, Paul
withdraws $20, and Mary withdraws half the money in the account, by
executing the following commands:</p>

<p class="trans" lang="ja"><b>練習問題3.38.</b> 最初に100ドルを保有している銀行口座を、ピーターとポールとメアリが共有している、と仮定しよう。
並行に、ピーターは10ドルを預け入れ、ポールは20ドルを引き出し、メアリは口座内の金額の半分を引き出す——以下のコマンドを実行することによって。
</p>

<div class="lisp">
<table border=0><tr><td valign=top >Peter: </td><td valign=top ><tt>(set! balance (+ balance 10))</tt></td></tr>
<tr><td valign=top >Paul: </td><td valign=top ><tt>(set! balance (- balance 20))</tt></td></tr>
<tr><td valign=top >Mary: </td><td valign=top ><tt>(set! balance (- balance (/ balance 2)))</tt>
</td></tr></table>
</div>

<ol class="orig" lang="en" style="list-style-type: lower-alpha" start="1"><li>List all the different possible values for <tt>balance</tt> after these
three transactions have been completed, assuming that the banking
system forces the three processes to run sequentially in some order.</li></ol>

<ol class="trans" lang="ja" style="list-style-type: lower-alpha" start="1"><li>
これらの三回の取引が完了した後の、<tt>balance</tt> についての、可能な異なる値をすべて挙げよ——ただし、銀行システムは、三つのプロセスが、何らかの順序で逐次的に実行されるように強制する、と仮定する。
</li></ol>

<p class="exercise"><span class="ex_comment">可能な順列は3!=6通り。
(1) ピーター、ポール、メアリの順: $100 → $110 → $90 → $45
(2) ピーター、メアリ、ポールの順: $100 → $110 → $55 → $35
(3) ポール、メアリ、ピーターの順: $100 → $80 → $40 → $50
(4) ポール、ピーター、メアリの順: $100 → $80 → $90 → $45
(5) メアリ、ピーター、ポールの順: $100 → $50 → $60 → $40
(6) メアリ、ポール、ピーターの順: $100 → $50 → $30 → $40

ピーターとポールが連続している場合、二人の順序が変わっても最終額には影響しない。
結局、あり得る最終金額は、35、40、45、50ドルの4通りである。
</span></p>

<ol class="orig" lang="en" style="list-style-type: lower-alpha" start="2"><li>What are some other values
that could be produced if the system allows the processes to be interleaved?
Draw timing diagrams like the one in figure <a href="#%_fig_3.29">3.29</a> to
explain how these values can occur.
</li></ol>

<ol class="trans" lang="ja" style="list-style-type: lower-alpha" start="2"><li>
プロセス同士を<!--、お互いの間に挟まり合うように混ぜ合わせる-->混ぜこぜにすることを、もしシステムが許すとしたら、生み出され得るであろう、他のいくつかの値とは、どのようなものか?
図<a href="#%_fig_3.29">3.29</a>のようなタイミング図を描いて、これらの値がどのようにして生じ得るのか、を説明せよ。
</li></ol>

<p class="exercise"><span class="ex_comment">(a) まずは簡単な例から。3人とも初期状態の$100を見て、それに基づき、新たな金額を計算する場合。
ここまでの、balanceを読み取る順や、各自で計算する順は、最終金額に影響しない。
最終金額に影響するのは、その後のset!がどういう順で生じるか、という点である。
下の図は、メアリ、ピーター、ポールの順の場合を示している。
最後にset!した人 (下図ではポール) の命令が、最終金額を決定づける。
よって、あり得る金額として、$50、$80、$110をまず挙げることができる。</span>

|      Peter               Paul               Bank        Mary
|                                             $100
|                                               |
|        +--------------------------------------+
|        |                                      |
|        |                  +-------------------+
|        V                  |                   |
|  access balance $100      |                   +--------+
|        |                  |                            |
|        |                  |                            V
|        |                  V                      access balance $100
|        |         access balance $100                   |
|        |                  |                            |
|        V                  |                            |
|  new value: 100+10=110    |                            V
|        |                  V                      new value: 100/2=50
|        |         new value: 100-20=80                  |
|        |                  |                            V
|        |                  |                      set! balance to $50
|        V                  |                            |
|  set! balance to $110     |                 $50&lt;-------+
|        |                  |
|        +-----------------------------------&gt;$110
|                           |
|                           V
|                  set! nalance to $80
|                           |
|                           +----------------&gt;$80
V
 time

<span class="ex_comment">(b) 最初にピーターがset!まで済ませてから、ポールとメアリがbalanceを読む場合。
ピーターは最初の$100という金額を読んで、100+10=110と計算し、balanceを$110にset!する。
ポールは110-20=90と計算し、メアリは110/2=55と計算する。
ポールが先にset!すると、下図のとおり最終金額は$55となり、メアリが先にset!すると、最終金額は$90となる。</span>

|      Peter               Paul               Bank        Mary
|                                             $100
|                                               |
|        +--------------------------------------+
|        |
|        V
|  access balance $100
|  new value: 100+10=110
|  set! balance to $110
|        |
|        +-----------------------------------&gt;$110
|                                               |
|                            +------------------+
|                            |                  |
|                            V                  +-----------+
|                  access balance $110                      |
|                  new value: 110-20=90                     V
|                            |                       access balance $110
|                            V                              |
|                  set! balance to $90               new value: 110/2=55
|                            |                              |
|                            +----------------&gt;$90          V
|                                                    set! balance to $55
|                                                           |
|                                             $55&lt;----------+
V
 time

<span class="ex_comment">(c) 最初にポールがset!まで済ませてから、ピーターとメアリがbalanceを読む場合。
ポールは最初の$100という金額を読んで、100-20=80と計算し、balanceを$80にset!する。
ピーターは80+10=90と計算し、メアリは80/2=40と計算する。
ピーターが先にset!すると、最終金額は$40となり、メアリが先にset!すると、最終金額は$90となる。</span>

<span class="ex_comment">(d) 最初にメアリがset!まで済ませてから、ピーターとポールがbalanceを読む場合。
メアリは最初の$100という金額を読んで、100/2=50 (厳密には、100-100/2=50) と計算し、balanceを$50にset!する。
ピーターは50+10=60と計算し、ポールは50-20=30と計算する。
ピーターが先にset!すると、最終金額は$60となり、ポールが先にset!すると、最終金額は$30となる。</span>

<span class="ex_comment">(e) 最初にポールとメアリが並行してbalanceを読み、各自計算をする場合。
ポールは100-20=80と計算し、メアリは100/2=50と計算する。
(e1) メアリより先にポールがset!して、それをピーターが読むと、ピーターは80＋10=90と計算する。
　　その後、メアリ、ピーターの順でset!すれば、下図のとおり最終金額は$90となり、逆順でset!すれば、最終金額は$50となる。
(e2) ポールより先にメアリがset!して、それをピーターが読むと、ピーターは50+10=60と計算する。
　　その後、ポール、ピーターの順でset!すれば、最終金額は$60となり、逆順でset!すれば、最終金額は$80となる。</span>

|      Peter               Paul               Bank        Mary
|                                             $100
|                                               |
|                                               +----------+
|                                               |          |
|                          +--------------------+          V
|                          |                         access balance $100
|                          V                               |
|                 access balance $100                      V
|                 new value: 100-20=80              new value: 100/2=50
|                 set balance to $80                       |
|                          |                               |
|                          +------------------&gt;$80         |
|                                               |          |
|        +--------------------------------------+          V
|        |                                             set! balance to $50
|        V                                                 |
|  access balance $80                          $50&lt;--------+
|  new value: 80+10=90
|  set! balance to $90
|        |
|        +------------------------------------&gt;$90
V
 time

<span class="ex_comment">(f) 最初にピーターとメアリが並行してbalanceを読み、各自計算をする場合。
ピーターは100+10=110と計算し、メアリは100/2=50と計算する。
(f1) メアリより先にピーターがset!して、それをポールが読むと、ポールは110-20=90と計算する。
　　その後、メアリ、ポールの順でset!すれば、最終金額は$90となり、逆順でset!すれば、最終金額は$50となる。
(f2) ピーターより先にメアリがset!して、それをポールが読むと、ポールは50-20=30と計算する。
　　その後、ピーター、ポールの順でset!すれば、最終金額は$30となり、逆順でset!すれば、最終金額は$110となる。</span>

<span class="ex_comment">(g) 最初にピーターとポールが並行してbalanceを読み、各自計算をする場合。
ピーターは100+10=110と計算し、ポールは100-20=80と計算する。
(g1) ポールより先にピーターがset!して、それをメアリが読むと、メアリは110/2=55と計算する。
　　その後、ポール、メアリの順でset!すれば、最終金額は$55となり、逆順でset!すれば、最終金額は$80となる。
(g2) ピーターより先にポールがset!して、それをメアリが読むと、メアリは80/2=40と計算する。
　　その後、ピーター、メアリの順でset!すれば、最終金額は$40となり、逆順でset!すれば、最終金額は$110となる。</span>

<span class="ex_comment">(h) まとめ
30、40、50、55、60、80、90、110ドル、という可能性があることがわかった。
</p>

<a name="%_sec_3.4.2"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_3.4.2">3.4.2  Mechanisms for Controlling Concurrency</a></h3>
<h3 class="trans" lang="ja">3.4.2 並行性を制御するための仕組み</h3>

<p class="orig" lang="en">
<a name="%_idx_3608"></a>
We've seen that the difficulty in dealing with concurrent processes is
rooted in the need to consider the interleaving of the order of events
in the different processes.  For example, suppose we have two
processes, one with three ordered events (<em>a</em>,<em>b</em>,<em>c</em>) and one with three
ordered events (<em>x</em>,<em>y</em>,<em>z</em>).  If the two processes run concurrently, with
no constraints on how their execution is interleaved, then there are
20 different possible orderings for the events that are consistent
with the individual orderings for the two processes:
</p>

<p class="trans" lang="ja">
並行なプロセスを扱う際の困難は、異なるプロセスのイベント同士の順序が入り混じることを考慮する必要がある、という点に根ざしている、ということを私たちは見てきた。
たとえば、二つのプロセスがあるものとし、一方は
<span class="math">(<em class="en">a</em>,<em class="en">b</em>,<em class="en">c</em>)</span>
という順序づけられた三つのイベントを有し、もう一方は
<span class="math">(<em class="en">x</em>,<em class="en">y</em>,<em class="en">z</em>)</span>
という順序づけられた三つのイベントを有するものとしよう。
もし、二つのプロセスが並行に——そして、これらのプロセスの実行がどのように<!--お互いの間に挟まれて混ぜ合わされる-->混ぜこぜにされるのか、についての制約なしに——実行されたら、二つのプロセスについての個別の順序づけと整合性があるような、イベント間の可能な異なる順序づけが、20通りある。
</p>

<figure><img src="ch3-Z-G-33.gif" border="0"></figure>


<p class="orig" lang="en">
As programmers designing this system, we would have to consider the
effects of each of these 20 orderings and check that each behavior is
acceptable.  Such an approach rapidly becomes unwieldy as the numbers
of processes and events increase.</p>

<p class="trans" lang="ja">
このシステムを設計するプログラマとして、私たちは、これら20通りの順序づけの各々の影響を考慮しなくてはならないだろうし、各々の振る舞いが許容できることを確かめなくてはならないだろう。
そういう手法は、プロセス数やイベント数が増えるにつれて、すぐに手に負えなくなる。
</p>

<p class="orig" lang="en">
A more practical approach to the design of concurrent systems is to
devise general mechanisms that allow us to constrain the interleaving
of concurrent processes so that we can be sure that the program
behavior is correct.  Many mechanisms have been developed for this
purpose.  In this section, we describe one of them, the <em>serializer</em>.</p>

<p class="trans" lang="ja">
並行システムの設計の、より実際的な手法とは、プログラムの振る舞いが正しいと確信できるようにするために、並行なプロセス同士が<!--互いの間に挟まって入り混じる-->混ぜこぜになることを制約できるようにしてくれる、一般的な仕組みを考案することである。
この目的のために、多くの仕組みが開発されてきた。
本節では、それらのうちの一つ——すなわち<em><ruby><rb>直列化するもの</rb><rp> (</rp><rt>シリアライザ</rt><rp>) </rp></ruby></em>——について、説明する。
</p>


<a name="%_sec_Temp_413"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_413">Serializing access to shared state</a></h4>
<h4 class="trans" lang="ja">共有状態へのアクセスを直列化する</h4>

<p class="orig" lang="en">
<a name="%_idx_3610"></a>
Serialization implements the following idea: Processes will execute
concurrently, but there will be certain collections of procedures that
cannot be executed concurrently.  More precisely, serialization creates
distinguished sets of procedures such that only one execution of a
procedure in each serialized set is permitted to happen at a time.
If some procedure in the set is being executed, then a process that
attempts to execute any procedure in the set will be forced to wait
until the first execution has finished.</p>

<p class="trans" lang="ja">
<ruby><rb>直列化</rb><rp> (</rp><rt>シリアライゼーション</rt><rp>) </rp></ruby>は、以下の考え方を実現する。
プロセスは並行に実行されるだろうが、並行には実行できない手続きの、ある集まりがあるだろう。
より正確には、直列化は、分別された手続き集合を、直列化された各集合のうちで一つの手続きの一つの実行のみが一度に起こることを許されるようにして、作成する。
集合内の何らかの手続きが実行中なら、その集合内の手続きのどれかを実行しようとするプロセスは、最初に述べた方の実行が終わるまで、強制的に待たされるだろう。
</p>

<p class="orig" lang="en">
We can use serialization to control access to shared variables.
For example, if we want to update a shared variable based on the
previous value of that variable, we put the access to the previous
value of the variable and the assignment of the new value to the
variable in the same procedure.  We then ensure that no other
procedure that assigns to the variable can run concurrently with this
procedure by serializing all of these procedures with the same
serializer.  This guarantees that the value of the variable cannot be
changed between an access and the corresponding assignment.</p>

<p class="trans" lang="ja">
共有変数へのアクセスを制御するのに、直列化を利用できる。
たとえば、共有変数を、その変数の以前の値に基づいて更新したい場合、その変数の以前の値へのアクセスと、その変数への新たな値の<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>とを、同じ手続きの中に記す。
それから、その変数への<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>を行う他の手続きはどれも、この手続きとは並行に実行できない、ということを、これらの手続きのすべてを同じシリアライザで直列化することによって、保証する。
これは、その変数の値が、アクセスとそれに対応する<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>の間は、変更できない、ということを保証する。
</p>


<a name="%_sec_Temp_414"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_414">Serializers in Scheme</a></h4>
<h4 class="trans" lang="ja">Schemeにおけるシリアライザ</h4>

<p class="orig" lang="en">
To make the above mechanism more concrete, suppose that we have
extended Scheme to include a procedure called <a name="%_idx_3612"></a><tt>parallel-execute</tt>:</p>

<p class="trans" lang="ja">
上記の仕組みをより具体的にするために、<tt>parallel-execute</tt> と呼ばれる手続きを含むように拡張されたSchemeがあるものとしよう。
</p>


<p class="lisp">(parallel-execute &lt;<em>p<sub>1</sub></em>&gt; &lt;<em>p<sub>2</sub></em>&gt; <tt>...</tt> &lt;<em>p<sub><em>k</em></sub></em>&gt;)
</p>


<p class="orig" lang="en">
Each &lt;<em>p</em>&gt; must be a procedure of no arguments.  <tt>Parallel-execute</tt>
creates a separate process for each
&lt;<em>p</em>&gt;, which applies &lt;<em>p</em>&gt; (to no arguments).  These processes all
run concurrently.<a name="call_footnote_Temp_415" href="#footnote_Temp_415"><sup><small>40</small></sup></a></p>

<p class="trans" lang="ja">
それぞれの &lt;<em class="en">p</em>&gt; は、引数のない手続きでなくてはならない。
<tt>parallel-execute</tt> は、それぞれの &lt;<em class="en">p</em>&gt; に対して別々のプロセス——これが &lt;<em class="en">p</em>&gt; を (無引数に) 適用する——を作成する。
これらのプロセスはすべて並行に実行される<a href="#footnote_Temp_415"><sup><small>40</small></sup></a>。
</p>

<p class="orig" lang="en">
As an example of how this is used, consider</p>

<p class="trans" lang="ja">
これがどのように使われるかの例として、以下のものを考えよう。
</p>

<p class="lisp">(define x 10)

(parallel-execute (lambda () (set! x (* x x)))
                  (lambda () (set! x (+ x 1))))
</p>

<p class="orig" lang="en">
This creates two concurrent processes -- <em>P</em><sub>1</sub>, which sets <tt>x</tt> to
<tt>x</tt> times <tt>x</tt>, and <em>P</em><sub>2</sub>, which increments <tt>x</tt>.  After
execution is complete, <tt>x</tt> will be left with one of five possible
values, depending on the interleaving of the events of <em>P</em><sub>1</sub> and
<em>P</em><sub>2</sub>:
</p>

<p class="trans" lang="ja">
これは、二つの並行なプロセスを作成する。つまり、
<em class="en">P</em><sub>1</sub> —— <tt>x</tt> を、<tt>x</tt> 掛ける <tt>x</tt> に設定する——と、
<em class="en">P</em><sub>2</sub> —— <tt>x</tt> をインクリメントする——である。
実行が完了すると、<tt>x</tt> は、5通りの可能な値のうちの一つになっているだろう—— <em class="en">P</em><sub>1</sub> と <em class="en">P</em><sub>2</sub> のイベント同士の入り混じり方に応じて。
</p>

<div class="orig" lang="en">
<table class="expl"><tr><td valign=top >101: </td><td valign=top ><em>P</em><sub>1</sub> sets <tt>x</tt> to 100 and then <em>P</em><sub>2</sub> increments <tt>x</tt> to 101.</td></tr>
<tr><td valign=top >121: </td><td valign=top ><em>P</em><sub>2</sub> increments <tt>x</tt> to 11 and then <em>P</em><sub>1</sub> sets <tt>x</tt> to
<tt>x</tt> times <tt>x</tt>.</td></tr>
<tr><td valign=top >110: </td><td valign=top ><em>P</em><sub>2</sub> changes <tt>x</tt> from 10 to 11 between the two times that
<em>P</em><sub>1</sub> accesses the value of <tt>x</tt> during the evaluation of <tt>(* x x)</tt>.</td></tr>
<tr><td valign=top >11:  </td><td valign=top ><em>P</em><sub>2</sub> accesses <tt>x</tt>, then <em>P</em><sub>1</sub> sets <tt>x</tt> to 100,
then <em>P</em><sub>2</sub> sets <tt>x</tt>.</td></tr>
<tr><td valign=top >100: </td><td valign=top ><em>P</em><sub>1</sub> accesses <tt>x</tt> (twice), then <em>P</em><sub>2</sub> sets <tt>x</tt> to 11,
then <em>P</em><sub>1</sub> sets <tt>x</tt>.</td></tr>
</table>
</div>

<br>

<div class="trans" lang="ja">
<table class="expl">
<tr><td>101: </td><td><em class="en">P</em><sub>1</sub> が <tt>x</tt> を 100 に設定し、それから <em class="en">P</em><sub>2</sub> が <tt>x</tt> を 101 にインクリメントする。</td></tr>
<tr><td>121: </td><td><em class="en">P</em><sub>2</sub> が <tt>x</tt> を 11 にインクリメントし、それから、<em class="en">P</em><sub>1</sub> が <tt>x</tt> を、<tt>x</tt> 掛ける <tt>x</tt> に設定する。</td></tr>
<tr><td>110: </td><td><em class="en">P</em><sub>1</sub> が <tt>(* x x)</tt> の評価の最中において <tt>x</tt> の値に二回アクセスする、その二回の間に、<em class="en">P</em><sub>2</sub> が <tt>x</tt> を 10 から 11へと変更する。</td></tr>
<tr><td>11:  </td><td><em class="en">P</em><sub>2</sub> が <tt>x</tt> にアクセスし、それから、<em class="en">P</em><sub>1</sub> が <tt>x</tt> を 100 に設定し、それから、<em class="en">P</em><sub>2</sub> が <tt>x</tt> を設定する。</td></tr>
<tr><td>100: </td><td><em class="en">P</em><sub>1</sub> が <tt>x</tt> にアクセスし (2回)、それから、<em class="en">P</em><sub>2</sub> が <tt>x</tt> を 11 に設定し、それから、<em class="en">P</em><sub>1</sub> が <tt>x</tt> を設定する。</td></tr>
</table>
</div>

<p class="orig" lang="en">
We can constrain the concurrency by using serialized procedures,
which are created by <em>serializers</em>. Serializers are constructed by <tt>make-serializer</tt>, whose implementation is given below.  A serializer
takes a procedure as argument and returns a serialized procedure that
behaves like the original procedure.  All calls to a given serializer
return serialized procedures in the same set.</p>

<p class="trans" lang="ja">
直列化された手続き——<em>シリアライザ</em>により作成される——を使うことで、並行性を制約することができる。
シリアライザは、<tt>make-serializer</tt> ——その実装は以下に示す——により構築される。
シリアライザは、手続きを引数としてとり、そして、元の手続きのように振る舞う直列化された手続きを返す。
与えられたシリアライザに対するすべての呼び出しは、同一集合内の直列化された手続きを返す。
</p>

<p class="orig" lang="en">
Thus, in contrast to the example above, executing</p>

<p class="trans" lang="ja">
よって、上記の例とは対照的に、以下のように実行すると、
</p>


<p class="lisp">(define x 10)

(define s (make-serializer))

(parallel-execute (s (lambda () (set! x (* x x))))
                  (s (lambda () (set! x (+ x 1)))))
</p>


<p class="orig" lang="en">
can produce only two possible values for <tt>x</tt>, 101 or 121.  The
other possibilities are eliminated, because the execution of <em>P</em><sub>1</sub> and
<em>P</em><sub>2</sub> cannot be interleaved.</p>

<p class="trans" lang="ja">
<tt>x</tt> に対して、あり得る値を二つしか作り出せない———つまり、101または121である。
残りの可能性は消される。なぜなら、 <em class="en">P</em><sub>1</sub> と <em class="en">P</em><sub>2</sub> の実行は、混ぜこぜにできないからである。
</p>

<p class="orig" lang="en">
Here is a version of the <tt>make-account</tt> procedure from
section <a href="20_sec3_1.html#%_sec_3.1.1">3.1.1</a>, where the deposits and
withdrawals have been serialized:</p>

<p class="trans" lang="ja">
ここに、<a href="20_sec3_1.html#%_sec_3.1.1">3.1.1</a>節の <tt>make-account</tt> の、あるバージョン——預け入れと引き出しが直列化されている——を示す。
</p>


<p class="lisp"><a name="%_idx_3614"></a><a name="%_idx_3616"></a>(define (make-account balance)
  (define (withdraw amount)
    (if (&gt;= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        &quot;Insufficient funds&quot;))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((protected (make-serializer)))
    (define (dispatch m)
      (cond ((eq? m 'withdraw) (protected withdraw))
            ((eq? m 'deposit) (protected deposit))
            ((eq? m 'balance) balance)
            (else (error &quot;Unknown request -- MAKE-ACCOUNT&quot;
                         m))))
    dispatch))
</p>


<p class="orig" lang="en">
With this implementation, two processes cannot be withdrawing from or
depositing into a single account concurrently.  This eliminates the source
of the error illustrated in figure <a href="#%_fig_3.29">3.29</a>, where Peter
changes the account balance between the times when Paul accesses the
balance to compute the new value and when Paul actually performs the
assignment.  On the other hand, each account has its own serializer,
so that deposits and withdrawals for different accounts can proceed
concurrently.</p>

<p class="trans" lang="ja">
この実装を使うと、二つのプロセスが並行に、単一の口座から引き出し、または、そこへの預け入れをしている最中だ、ということは、あり得ない。
これは、図<a href="#%_fig_3.29">3.29</a> ——ポールが新たな値を計算するために残高にアクセスする時点と、ポールが実際に<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>を実行する時点との間に、ピーターが口座残高を変更する——に示されるエラーの発生源を排除する。
他方、それぞれの口座には、その口座自身のシリアライザがあって、そのため、異なる口座に対する預け入れと引き出しは、並行に進行し得る。
</p>


<p class="orig" lang="en"><a name="%_thm_3.39"></a>
<b>Exercise 3.39.</b>  Which of the five possibilities in the parallel execution shown above
remain if we instead serialize execution as follows:</p>

<p class="trans" lang="ja"><b>練習問題3.39.</b> 代わりに、実行を以下のように直列化したとしたら、上に示した並列実行における五つの可能性のうちのどれが残るだろうか?
</p>


<p class="lisp">(define x 10)

(define s (make-serializer))

(parallel-execute (lambda () (set! x ((s (lambda () (* x x))))))
                  (s (lambda () (set! x (+ x 1)))))
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.40"></a>
<b>Exercise 3.40.</b>  Give all possible values of <tt>x</tt> that can result from executing</p>

<p class="trans" lang="ja"><b>練習問題3.40.</b> 以下を実行することに起因して生じ得る、<tt>x</tt> のすべての可能な値を挙げよ。
</p>

<p class="lisp">(define x 10)

(parallel-execute (lambda () (set! x (* x x)))
                  (lambda () (set! x (* x x x))))
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
Which of these possibilities remain if we instead use serialized
procedures:</p>

<p class="trans" lang="ja">
代わりに、以下のように直列化した手続きを使ったとしたら、これらの可能性のうちのいずれが残るだろう?
</p>


<p class="lisp">(define x 10)

(define s (make-serializer))

(parallel-execute (s (lambda () (set! x (* x x))))
                  (s (lambda () (set! x (* x x x)))))
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.41"></a>
<b>Exercise 3.41.</b>  Ben Bitdiddle worries that it would be better to implement the bank
account as follows (where the commented line has been changed):</p>

<p class="trans" lang="ja"><b>練習問題3.41.</b> ベン・ビットディドルは、銀行口座を以下 (コメントされた行が変更されている) のように実装する方がいいのではないか、と悩んでいる。
</p>

<p class="lisp"><a name="%_idx_3618"></a>(define (make-account balance)
  (define (withdraw amount)
    (if (&gt;= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        &quot;Insufficient funds&quot;))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  <em>;; continued on next page</em>

  (let ((protected (make-serializer)))
    (define (dispatch m)
      (cond ((eq? m 'withdraw) (protected withdraw))
            ((eq? m 'deposit) (protected deposit))
            ((eq? m 'balance)
             ((protected (lambda () balance)))) <em>; serialized</em>
            (else (error &quot;Unknown request -- MAKE-ACCOUNT&quot;
                         m))))
    dispatch))
</p>


<p class="orig" lang="en">
because allowing unserialized access to the bank balance can result in
anomalous behavior.  Do you agree?  Is there any scenario that
demonstrates Ben's concern?
</p>

<p class="trans" lang="ja">
なぜなら、銀行残高への、直列化されていないアクセスを許すことは、異常な振る舞い、という結果になりかねないからである。
ベンの懸念を立証するようなシナリオが何かあるだろうか?
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.42"></a>
<b>Exercise 3.42.</b>  Ben Bitdiddle suggests that it's a waste of time to create a new
serialized procedure in response to every <tt>withdraw</tt> and <tt>deposit</tt> message.  He says that <tt>make-account</tt> could be changed so
that the calls to <tt>protected</tt> are done outside the <tt>dispatch</tt>
procedure.  That is, an account would return the same serialized
procedure (which was created at the same time as the account) each time
it is asked for a withdrawal procedure.
</p>


<p class="trans" lang="ja"><b>練習問題3.42.</b> すべての <tt>withdraw</tt> と <tt>deposit</tt> のメッセージごとに、それに応じて新たな直列化手続きを作成するのは、時間の無駄である、とベン・ビットディドルはほのめかす。
彼は、<tt>protected</tt> への呼び出しが <tt>dispatch</tt> という手続きの外側で行われるように、<tt>make-account</tt> を変更できるだろう、と言う。
つまり、口座は、引き出しの手続きを求められるたびに、(その口座と同時に作成された) 同じ直列化手続きを、返すだろう。
</p>

<p class="lisp"><a name="%_idx_3620"></a>(define (make-account balance)
  (define (withdraw amount)
    (if (&gt;= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        &quot;Insufficient funds&quot;))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((protected (make-serializer)))
    (let ((protected-withdraw (protected withdraw))
          (protected-deposit (protected deposit)))
      (define (dispatch m)
        (cond ((eq? m 'withdraw) protected-withdraw)
              ((eq? m 'deposit) protected-deposit)
              ((eq? m 'balance) balance)
              (else (error &quot;Unknown request -- MAKE-ACCOUNT&quot;
                           m))))
      dispatch)))
</p>


<p class="orig" lang="en">
Is this a safe change to make?  In particular, is there any difference in
what concurrency is allowed by these two versions of <tt>make-account</tt> ?
</p>

<p class="trans" lang="ja">
これは、行っても安全な変更か?
特に、<tt>make-account</tt> のこれらの二つのバージョンにより、どのような並行性が許されるのか、という点において、何か違いがあるか?
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_Temp_420"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_420">Complexity of using multiple shared resources</a></h4>
<h4 class="trans" lang="ja">共有された複数の資源を使うことの複雑性</h4>


<p class="orig" lang="en">
<a name="%_idx_3622"></a><a name="%_idx_3624"></a>
Serializers provide a powerful abstraction that helps isolate the
complexities of concurrent programs so that they can be dealt with
carefully and (hopefully) correctly.  However, while using serializers
is relatively straightforward when there is only a single shared
resource (such as a single bank account), concurrent programming can
be treacherously difficult when there are multiple shared resources.</p>

<p class="trans" lang="ja">並行プログラムの複雑性を、それらを注意深く、かつ (願わくば) 正しく扱えるように隔離するのを助けてくれる、強力な抽象化を、シリアライザは提供する。
しかし、(たとえば一つの銀行口座など) 一つしか共有資源がないときには、シリアライザを使うことは比較的わかりやすいのだが、複数の共有資源があるときは、並行プログラミングは、油断できないほど難しくなり得る。
</p>

<p class="orig" lang="en">
To illustrate one of the difficulties that can arise, suppose we wish to swap
the balances in two bank accounts.  We access each account to find the
balance, compute the difference between the balances, withdraw this
difference from one account, and deposit it in the other account.  We
could implement this as follows:<a name="call_footnote_Temp_421" href="#footnote_Temp_421"><sup><small>41</small></sup></a></p>

<p class="trans" lang="ja">
生じ得る困難のうちの一つを例示するために、二つの銀行口座の残高を入れ替えたいのだとしよう。
それぞれの口座にアクセスして残高を知り、残高同士の差を計算し、この差額を一方の口座から引き出し、それを他方の口座に預け入れる。
これを、以下のように実装することができる<a href="#footnote_Temp_421"><sup><small>41</small></sup></a>。
</p>

<p class="lisp"><a name="%_idx_3626"></a><a name="%_idx_3628"></a>(define (exchange account1 account2)
  (let ((difference (- (account1 'balance)
                       (account2 'balance))))
    ((account1 'withdraw) difference)
    ((account2 'deposit) difference)))
</p>

<p class="orig" lang="en">
This procedure works well when only a single process is trying to do
the exchange.  Suppose, however, that Peter and Paul both have access
to accounts <em>a</em>1, <em>a</em>2, and <em>a</em>3, and that
Peter exchanges <em>a</em>1 and
<em>a</em>2 while Paul concurrently exchanges <em>a</em>1 and <em>a</em>3.
Even with account deposits and withdrawals
serialized for individual accounts (as in the <tt>make-account</tt>
procedure shown above in this section), <tt>exchange</tt> can still
produce incorrect results.  For example, Peter might compute the
difference in the balances for <em>a</em>1 and <em>a</em>2, but then Paul
might change the balance in <em>a</em>1 before Peter is able to complete
the exchange.<a name="call_footnote_Temp_422" href="#footnote_Temp_422"><sup><small>42</small></sup></a>
For correct behavior, we must arrange for the <tt>exchange</tt> procedure
to lock out any other concurrent accesses to the accounts during the
entire time of the exchange.</p>

<p class="trans" lang="ja">
一つのプロセスのみがこの交換をしようと試みている場合には、この手続きは、うまく動く。
しかし、ピーターとポールの二人とも、<em class="en">a</em>1 と <em class="en">a</em>2 と <em class="en">a</em>3 という口座の利用権があり、かつ、ポールが並行に <em class="en">a</em>1 と <em class="en">a</em>3 を交換している間にピーターが <em class="en">a</em>1 と <em class="en">a</em>2 を交換するのだ、と仮定しよう。
<!--しかし、ピーターとポールの二人とも、<em class="en">a</em>1 と <em class="en">a</em>2 と <em class="en">a</em>3 という口座の利用権があるものと仮定し、かつ、ピーターが <em class="en">a</em>1 と <em class="en">a</em>2 を交換し、その間にポールが並行に <em class="en">a</em>1 と <em class="en">a</em>3 を交換しているものと仮定しよう。--><!--<span class="note"> (と、訳した方が、わかりやすいといえばわかりやすいのだが。)</span>-->
たとえ口座の預け入れと引き出しが、個々の口座について直列化されていたとしても (たとえば本節で上に示した <tt>make-account</tt> という手続きにおけるように)、それでも <tt>exchange</tt> は、誤った結果を生み出す可能性がある。
たとえば、ピーターは、<em class="en">a</em>1 と <em class="en">a</em>2 の残高の差を計算するかもしれないが、その後、ピーターが交換を完了できるよりも前に、ポールが <em class="en">a</em>1 の残高を変えるかもしれない<a href="#footnote_Temp_422"><sup><small>42</small></sup></a>。
正しい振る舞いのためには、<tt>exchange</tt> の手続きが、その交換の時間の間ずっと、その口座へのいかなる他の並行なアクセスをも排除できるように、私たちが手筈を整えておかなくてはならないのだ。
</p>

<p class="orig" lang="en">
One way we can accomplish this is by using both accounts' serializers
to serialize the entire <tt>exchange</tt> procedure.
To do this, we will arrange for access to an account's serializer.
Note that we are deliberately
breaking the modularity of the bank-account object by exposing the
serializer.  The following version of <tt>make-account</tt> is identical
to the original version given in
section <a href="20_sec3_1.html#%_sec_3.1.1">3.1.1</a>, except that a serializer is
provided to protect the balance variable, and the serializer is
exported via message passing:</p>

<p class="trans" lang="ja">
これを達成できるような一つの方法は、両方の口座のシリアライザを使うことにより、<tt>exchange</tt> の手続き全体を直列化することである。
これを行うために、口座のシリアライザへのアクセスを用意しよう。
私たちが、シリアライザをむき出しにすることによって、銀行口座オブジェクトのモジュール性を慎重に破っているところなのだ、ということに注意せよ。
<tt>make-account</tt> の、以下のバージョンは、 <a href="20_sec3_1.html#%_sec_3.1.1">3.1.1</a>節に示した元のバージョンと同一である——残高変数を保護するためにシリアライザが与えられており、そのシリアライザがメッセージ渡しによって<ruby><rb>エクスポートされて</rb><rp> (</rp><rt>そとにだされて</rt><rp>) </rp></ruby>いる、という点を除いて。
</p>


<p class="lisp"><a name="%_idx_3630"></a>(define (make-account-and-serializer balance)
  (define (withdraw amount)
    (if (&gt;= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        &quot;Insufficient funds&quot;))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((balance-serializer (make-serializer)))
    (define (dispatch m)
      (cond ((eq? m 'withdraw) withdraw)
            ((eq? m 'deposit) deposit)
            ((eq? m 'balance) balance)
            ((eq? m 'serializer) balance-serializer)
            (else (error &quot;Unknown request -- MAKE-ACCOUNT&quot;
                         m))))
    dispatch))
</p>



<p class="orig" lang="en">
We can use this to do serialized deposits and withdrawals.  However,
unlike our earlier serialized account, it is now the responsibility of
each user of bank-account objects to explicitly manage the
serialization, for example as follows:<a name="call_footnote_Temp_423" href="#footnote_Temp_423"><sup><small>43</small></sup></a></p>

<p class="trans" lang="ja">
直列化された預け入れと引き出しを実行するために、これを用いることができる。
しかし、先の直列化口座とは違って、今や、直列化を明示的に管理することは、たとえば以下のように、銀行口座オブジェクトの各ユーザの責任なのだ<a href="#footnote_Temp_423"><sup><small>43</small></sup></a>。
</p>

<p class="lisp"><a name="%_idx_3632"></a>(define (deposit account amount)
  (let ((s (account 'serializer))
        (d (account 'deposit)))
    ((s d) amount)))
</p>


<p class="orig" lang="en">
Exporting the serializer in this way gives us enough flexibility to
implement a serialized exchange program.  We simply
serialize the original
<tt>exchange</tt> procedure with the serializers for both accounts:</p>


<p class="trans" lang="ja">
このやり方でシリアライザをエクスポートすることは、私たちに、直列化された取引プログラムを実装するのに十分な柔軟性を与えてくれる。
私たちは単に、双方の口座用のシリアライザを使って、元の <tt>exchange</tt> の手続きを直列化するだけだ。
</p>


<p class="lisp"><a name="%_idx_3634"></a>(define (serialized-exchange account1 account2)
  (let ((serializer1 (account1 'serializer))
        (serializer2 (account2 'serializer)))
    ((serializer1 (serializer2 exchange))
     account1
     account2)))
</p>


<p class="orig" lang="en"><a name="%_thm_3.43"></a>
<b>Exercise 3.43.</b>  Suppose that the balances in three accounts start out as $10, $20,
and $30, and that multiple processes run, exchanging the balances in
the accounts.  Argue that if the processes are run sequentially,
after any number of concurrent exchanges, the account balances should be 
$10, $20, and $30 in some order.
Draw a timing diagram like the one in figure <a href="#%_fig_3.29">3.29</a> to
show how this condition can be violated if the exchanges are
implemented using the first version of the account-exchange program in
this section.  On the other hand, argue that even with this <tt>exchange</tt> program, the sum of the balances in the accounts will be
preserved.  Draw a timing diagram to show how even this condition would
be violated if we did not serialize the transactions
on individual accounts.
</p>

<p class="trans" lang="ja"><b>練習問題3.43.</b> 三つの口座の残高が10ドル、20ドル、30ドルから始まるものとし、複数のプロセスが実行されて、これらの口座の残高同士を交換するのだとしよう。
もしプロセスが逐次的に実行されたら、並行な交換を何回行った後でも、口座残高は、何らかの順序で、10ドル、20ドル、30ドルとなるべきである、ということを論ぜよ。
もし本節における最初のバージョンの口座取引プログラムを使って交換が実装されていたら、この条件がどのようにして破られ得るのか、ということを示すために、図<a href="#%_fig_3.29">3.29</a>のようなタイミング図を描け。
一方、この <tt>exchange</tt> のプログラムを使っていてさえ、口座残高の和は保たれるだろう、ということを論ぜよ。
もし個々の口座に対する取引を直列化しなかったとしたら、どのようにしてこの条件でさえも破られてしまうのか、ということを示すために、タイミング図を描け。
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.44"></a>
<b>Exercise 3.44.</b>  <a name="%_idx_3636"></a>Consider the problem of transferring an amount from one account to
another.  Ben Bitdiddle claims that this can be accomplished with the
following procedure, even if there are multiple people concurrently
transferring money among multiple accounts, using any account
mechanism that serializes deposit and withdrawal transactions, for
example, the version of <tt>make-account</tt> in the text above.</p>

<p class="trans" lang="ja"><b>練習問題3.44.</b> 一つの口座から別の口座へ、ある金額を送るという問題を考えよう。
ベン・ビットディドルは、これは以下の手続きによって達成できる、と主張する——たとえば、上述の本分中にある <tt>make-account</tt> のバージョンなど、預け入れと引き出しの取引を直列化するような任意の口座の仕組みを使っていれば、複数の人たちが並行に複数の口座間で送金していてさえも、達成できるのだ、と。
</p>


<p class="lisp">(define (transfer from-account to-account amount)
  ((from-account 'withdraw) amount)
  ((to-account 'deposit) amount))
</p>


<p class="orig" lang="en">
Louis Reasoner claims that there is a problem here, and that we need
to use a more sophisticated method, such as the one required for
dealing with the exchange problem.  Is Louis right?  If not, what is
the essential difference between the transfer problem and the exchange
problem?  (You should assume that the balance in <tt>from-account</tt>
is at least <tt>amount</tt>.)
</p>

<p class="trans" lang="ja">
ルイス・リーズナは、ここには問題がある、と主張し、さらに、より洗練された方法——たとえば、交換の問題を扱うのに必要とされたものなど——を使う必要がある、と主張する。
ルイスは正しいか?
もし正しくなければ、送金の問題と交換の問題の間の本質的な差異とは何だろう?
(<tt>from-account</tt> の残高は少なくとも <tt>amount</tt> である、と想定すべきである。)
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.45"></a>
<b>Exercise 3.45.</b>  Louis Reasoner thinks our bank-account system is unnecessarily complex and
error-prone now that deposits and withdrawals aren't automatically serialized.
He suggests that <tt>make-account-and-serializer</tt> should have
exported the serializer (for use by such procedures as
<tt>serialized-exchange</tt>) in addition to (rather than instead of)
using it to serialize accounts and deposits as <tt>make-account</tt> did.
He proposes to redefine accounts as follows:</p>

<p class="trans" lang="ja"><b>練習問題3.45.</b> 今や預け入れと引き出しが自動的に直列化されてはいないため、私たちの銀行口座システムは、不必要なほどに複雑でありエラーを招きやすい、とルイス・リーズナは考えている。
彼は、<tt>make-account-and-serializer</tt> が、<tt>make-account</tt> がしたのと同様に口座や預け入れを直列化するためにシリアライザを使うこと (に代えて、と言うよりもむしろ、そうした使用) に加えて、(<tt>serialized-exchange</tt> などの手続きによる使用のために) シリアライザをエクスポートすべきだった、と示唆する。
彼は以下のように口座を再定義することを提案する。
</p>

<p class="lisp">(define (make-account-and-serializer balance)
  (define (withdraw amount)
    (if (&gt;= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        &quot;Insufficient funds&quot;))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((balance-serializer (make-serializer)))
    (define (dispatch m)
      (cond ((eq? m 'withdraw) (balance-serializer withdraw))
            ((eq? m 'deposit) (balance-serializer deposit))
            ((eq? m 'balance) balance)
            ((eq? m 'serializer) balance-serializer)
            (else (error &quot;Unknown request -- MAKE-ACCOUNT&quot;
                         m))))
    dispatch))
</p>


<p class="orig" lang="en">
Then deposits are handled as with the original <tt>make-account</tt>:
</p>

<p class="trans" lang="ja">
すると、預け入れは、元の <tt>make-account</tt> を使ったときと同様に扱われる。
</p>

<p class="lisp">(define (deposit account amount)
 ((account 'deposit) amount))
</p>


<p class="orig" lang="en">
Explain what is wrong with Louis's reasoning.  In particular,
consider what happens when <tt>serialized-exchange</tt> is called.
</p>

<p class="trans" lang="ja">
ルイスの推論の何が間違っているのか、説明せよ。
特に、<tt>serialized-exchange</tt> が呼ばれたときに何が起こるのかを考えよ。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_Temp_427"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_427">Implementing serializers</a></h4>
<h4 class="trans" lang="ja">シリアライザを実装する</h4>


<p class="orig" lang="en">
<a name="%_idx_3638"></a>
We implement serializers in terms of a more primitive synchronization
mechanism called a <a name="%_idx_3640"></a><em>mutex</em>.  A mutex is an object that supports
two operations -- the mutex can be <a name="%_idx_3642"></a><em>acquired</em>, and the mutex can be
<a name="%_idx_3644"></a><em>released</em>.  Once a mutex has been acquired, no other acquire
operations on that mutex may proceed until the mutex is released.<a name="call_footnote_Temp_428" href="#footnote_Temp_428"><sup><small>44</small></sup></a> In our implementation, each
serializer has an associated mutex.  Given a procedure <tt>p</tt>, the
serializer returns a procedure that acquires the mutex, runs <tt>p</tt>,
and then releases the mutex.  This ensures that only one of the
procedures produced by the serializer can be running at once, which is
precisely the serialization property that we need to guarantee.</p>

<p class="trans" lang="ja">
私たちは、シリアライザを、<em>ミューテックス</em> と呼ばれる、より原始的な同期の仕組みを使って、実装する。
ミューテックスは、二つの操作をサポートするオブジェクトである——ミューテックスは<em>獲得され</em>得るし、また、ミューテックスは<em>解放され</em>得る。
一旦ミューテックスが獲得されたら、そのミューテックスに対する他の獲得操作はどれも、そのミューテックスが解放されるまでは、先に進めない<a href="#footnote_Temp_428"><sup><small>44</small></sup></a>。
私たちの実装では、各シリアライザが、対応づけられたミューテックスを持つ。
<tt>p</tt> という手続きを与えられると、シリアライザは、ミューテックスを獲得する手続きを返し、<tt>p</tt> を実行し、それからミューテックスを解放する。
これは、シリアライザによって作り出された手続きのうちのたった一つしか、同時に実行中とはなれない、ということを保証するもので、それこそは、まさに、私たちが保証する必要のある直列化の性質である。
</p>


<p class="lisp"><a name="%_idx_3660"></a>(define (make-serializer)
  (let ((mutex (make-mutex)))
    (lambda (p)
      (define (serialized-p . args)
        (mutex 'acquire)
        (let ((val (apply p args)))
          (mutex 'release)
          val))
      serialized-p)))
</p>


<p class="orig" lang="en">
The mutex is a mutable object (here we'll use a one-element
list, which we'll refer to as a <a name="%_idx_3662"></a><em>cell</em>) that can hold the value
true or false.  When the value is false, the mutex is available to be
acquired.  When the value is true, the mutex is unavailable, and any
process that attempts to acquire the mutex must wait.</p>

<p class="trans" lang="ja">
ミューテックスは、真または偽という値を保持できる、変更可能なオブジェクトである (ここでは、一要素のリスト——<em>セル</em>と呼ぶことにしよう——を使おう)。
その値が偽のとき、ミューテックスは利用可能で、獲得できる。
その値が真のとき、ミューテックスは利用不能で、そのミューテックスを獲得しようとするどのプロセスも、待たなくてはならない。
</p>

<p class="orig" lang="en">
Our mutex constructor <tt>make-mutex</tt> begins by initializing the cell
contents to false.  To acquire the mutex, we test the cell.  If the
mutex is available, we set the cell contents to true and proceed.
Otherwise, we wait in a loop, attempting to acquire over and over
again, until we find that the mutex is available.<a name="call_footnote_Temp_429" href="#footnote_Temp_429"><sup><small>45</small></sup></a>  To release the
mutex, we set the cell contents to false.</p>

<p class="trans" lang="ja">
<tt>make-mutex</tt> という、ミューテックスのコンストラクタは、セルの中身を偽に初期化することから始める。
ミューテックスを獲得するためには、セルを調べる。
もしミューテックスが利用可能なら、セルの中身を真に設定して、先へ進む。
そうでなければ、ミューテックスが利用可能だと分かるまで、何度も何度も獲得を試みながら、ループして待つ<a href="#footnote_Temp_429"><sup><small>45</small></sup></a>。
ミューテックスを解放するには、セルの中身を偽に設定する。
</p>


<p class="lisp"><a name="%_idx_3668"></a>(define (make-mutex)
  (let ((cell (list false)))            
    (define (the-mutex m)
      (cond ((eq? m 'acquire)
             (if (test-and-set! cell)
                 (the-mutex 'acquire))) <em>; retry</em>
            ((eq? m 'release) (clear! cell))))
    the-mutex))
(define (clear! cell)
  (set-car! cell false))
</p>


<p class="orig" lang="en">
<tt>Test-and-set!</tt> tests the cell and returns the result of the
test.  In addition, if the test was false, <tt>test-and-set!</tt> sets
the cell contents to true before returning false.  We can express this
behavior as the following procedure:</p>

<p class="trans" lang="ja">
<tt>test-and-set!</tt> は、セルを調べて、その検査の結果を返す。
さらに、もし検査が偽なら、<tt>test-and-set!</tt> は、偽を返す前にセルの中身を真に設定する。
この振る舞いは、以下の手続きのように表現できる。
</p>

<p class="lisp"><a name="%_idx_3670"></a>(define (test-and-set! cell)
  (if (car cell)
      true
      (begin (set-car! cell true)
             false)))
</p>


<p class="orig" lang="en">
However, this implementation of <tt>test-and-set!</tt> does not suffice
as it stands.  There is a crucial subtlety here, which is the
essential place where concurrency control enters the system: The <tt>test-and-set!</tt> operation must be performed <a name="%_idx_3672"></a><em>atomically</em>.  That
is, we must guarantee that, once a process has tested the cell and
found it to be false, the cell contents will actually be set to true
before any other process can test the cell.  If we do not make this
guarantee, then the mutex can fail in a way similar to the
bank-account failure in figure <a href="#%_fig_3.29">3.29</a>.  (See
exercise <a href="#%_thm_3.46">3.46</a>.)</p>

<p class="trans" lang="ja">
しかし、<tt>test-and-set!</tt> のこの実装は、現状のままでは不十分である。
ここには決定的に重要な巧妙さがあり、それは、並行性制御がシステムに入り込んでくる本質的な箇所なのである。つまり、<tt>test-and-set!</tt> の操作は、<em><ruby><rb>原子的</rb><rp> (</rp><rt>アトミック</rt><rp>) </rp></ruby>に</em>行われなくてはならないのだ。
すなわち、プロセスが一旦セルを試してセルが偽だと分かったら、セルの中身は、他のどのプロセスがそのセルを試せるときよりも前に、実際に真に設定されるだろう。
もしこの保証をしなかったら、ミューテックスは、図<a href="#%_fig_3.29">3.29</a>の銀行口座の失敗と似たような筋道で、失敗し得るのだ (練習問題<a href="#%_thm_3.46">3.46</a>を参照)。
</p>

<p class="orig" lang="en">
The actual implementation of <tt>test-and-set!</tt> depends on the
details of how our system runs concurrent processes.  For example, we
might be executing concurrent processes on a sequential processor
using a <a name="%_idx_3674"></a>time-slicing mechanism that cycles through the processes,
permitting each process to run for a short time before interrupting it
and moving on to the next process.  In that case, <tt>test-and-set!</tt>
can work by disabling time slicing during the testing and setting.<a name="call_footnote_Temp_430" href="#footnote_Temp_430"><sup><small>46</small></sup></a>
Alternatively, multiprocessing computers provide instructions that
support atomic operations directly in hardware.<a name="call_footnote_Temp_431" href="#footnote_Temp_431"><sup><small>47</small></sup></a></p>

<p class="trans" lang="ja">
<tt>test-and-set!</tt> の実際の実装は、私たちのシステムが並行なプロセスを実行するやり方の詳細による。
たとえば、私たちは、複数のプロセスを循環するタイム・スライシングの仕組みを使って、逐次的プロセッサ上で、並行なプロセスを実行しているところ——各プロセスに対して、そのプロセスに割り込んで次のプロセスへと進むよりも前の短い時間だけ、実行されることを許しながら——かもしれない。
その場合、<tt>test-and-set!</tt> は、調べて設定している間にはタイム・スライシングを無効化することで、うまく機能できる<a href="#footnote_Temp_430"><sup><small>46</small></sup></a>。
あるいは、マルチプロセシング・コンピュータが、原子的な操作をハードウェアで直接的にサポートする命令を、提供する<a href="#footnote_Temp_431"><sup><small>47</small></sup></a>。
</p>


<p class="orig" lang="en"><a name="%_thm_3.46"></a>
<b>Exercise 3.46.</b>  Suppose that we implement <tt>test-and-set!</tt>  using an ordinary
procedure as shown in the text, without attempting to make the operation
atomic.  Draw a timing diagram like the one in
figure <a href="#%_fig_3.29">3.29</a> to demonstrate how the mutex
implementation can fail by allowing two processes to acquire the mutex
at the same time.
</p>

<p class="trans" lang="ja"><b>練習問題3.46.</b> 本文に示したように普通の手続きを使って——ただし、操作を原子的にしようとはせずに—— <tt>test-and-set!</tt> を実装するものとしよう。
二つのプロセスが同時にミューテックスを獲得することを許すことによって、ミューテックスの実装がどのようにして失敗する可能性があるのかを実証するために、図<a href="#%_fig_3.29">3.29</a>にあるようなタイミング図を描け。
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.47"></a>
<b>Exercise 3.47.</b>  <a name="%_idx_3692"></a>A semaphore (of size <em>n</em>) is a generalization of a mutex.  Like a
mutex, a semaphore supports acquire and release operations, but it is
more general in that up to <em>n</em> processes can acquire it
concurrently.  Additional processes that attempt to acquire the
semaphore must wait for release operations.  Give implementations of
semaphores</p>

<p class="trans" lang="ja"><b>練習問題3.47.</b> (大きさが <em class="en">n</em> の) セマフォとは、ミューテックスの一般化である。
ミューテックスと同様に、セマフォは、獲得と解放の操作をサポートするが、最大で <em class="en">n</em> 個までのプロセスがそのセマフォを並行に獲得できるのだ、という点において、セマフォはより一般的である。
セマフォを獲得しようとする、さらなるプロセスは、解放操作を待たねばならない。
セマフォの実装を示せ。
</p>

<p class="orig" lang="en">a. in terms of mutexes</p>

<p class="trans" lang="ja">
a. ミューテックスを使って。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>


<p class="orig" lang="en">b. in terms of atomic <tt>test-and-set!</tt> operations.
</p>

<p class="trans" lang="ja">
b. 原子的な <tt>test-and-set!</tt> の演算を使って。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_Temp_434"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_434">Deadlock</a></h4>
<h4 class="trans" lang="ja">デッドロック</h4>

<p class="orig" lang="en">
<a name="%_idx_3694"></a><a name="%_idx_3696"></a>
Now that we have seen how to implement serializers, we can see
that account exchanging still has a problem, even with the
<tt>serialized-exchange</tt> procedure above.
Imagine that Peter attempts to exchange <em>a</em>1
with <em>a</em>2 while Paul concurrently attempts to exchange <em>a</em>2
with <em>a</em>1.  Suppose that Peter's process reaches the point where
it has entered a serialized procedure protecting <em>a</em>1 and, just
after that, Paul's process enters a serialized procedure protecting
<em>a</em>2.  Now Peter cannot proceed (to enter a serialized procedure
protecting <em>a</em>2) until Paul exits the serialized procedure
protecting <em>a</em>2.  Similarly, Paul cannot proceed until Peter exits
the serialized procedure protecting <em>a</em>1.  Each process is stalled
forever, waiting for the other.  This situation is called a <em>deadlock</em>.  Deadlock is always a danger in systems that provide
concurrent access to multiple shared resources.</p>

<p class="trans" lang="ja">
今ではもう、シリアライザをどう実装するのかを見てきたのだから、私たちは、たとえ上記の <tt>serialized-exchange</tt> の手続きを使っても口座の交換には依然として問題がある、ということが分かる。
ポールが並行に <em class="en">a</em>2 と <em class="en">a</em>1 を交換しようとしている間に、ピーターが <em class="en">a</em>1 と <em class="en">a</em>2 を交換しようとする、と想像せよ。
<!--ピーターが <em class="en">a</em>1 と <em class="en">a</em>2 を交換しようとし、その間に並行して、ポールが <em class="en">a</em>2 と <em class="en">a</em>1 を交換しようとしている、と想像せよ。-->
ピーターのプロセスは、<em class="en">a</em>1 を保護している直列化手続きにそのプロセスが入ったところまで到達しているものとし、その直後に、ポールのプロセスが、<em class="en">a</em>2 を保護している直列化手続きに入るものとしよう。
ここで、ピーターは、<em class="en">a</em>2 を保護している直列化手続きからポールが抜け出すまでは、先に進めない (<em class="en">a</em>2 を保護している直列化手続きに入るところまで進めない)。
同様に、ポールは、<em class="en">a</em>1 を保護している直列化手続きからピーターが抜け出すまでは、先に進めない。
それぞれのプロセスは、他方を待っているところで、永遠に止められてしまう。
この状況は<em>デッドロック</em>と呼ばれる。
複数の共有資源に対する並行なアクセスを提供するようなシステムにおいて、デッドロックはいつでも危険なものなのだ。
</p>

<p class="orig" lang="en">
<a name="%_idx_3698"></a>One way to avoid the deadlock in this situation is to give each
account a unique identification number and rewrite <tt>serialized-exchange</tt> so
that a process will always attempt to enter a procedure protecting the
lowest-numbered account first.  Although this method works well for
the exchange problem, there are other situations that require more
sophisticated deadlock-avoidance techniques, or where deadlock cannot
be avoided at all.  (See exercises <a href="#%_thm_3.48">3.48</a>
and <a href="#%_thm_3.49">3.49</a>.)<a name="call_footnote_Temp_435" href="#footnote_Temp_435"><sup><small>48</small></sup></a></p>

<p class="trans" lang="ja">
この状況におけるデッドロックを防ぐための一つの方法は、それぞれの口座に一意な識別番号を与えて、そして、プロセスが必ずいつも、もっとも小さい番号のついた口座を保護するような手続きに最初に入ろうとするように、<tt>serialized-exchange</tt> を書き換えること、である。
この方法は、交換のプログラムに対してはうまくゆくのだが、より洗練されたデッドロック回避技法を要するような他の状況、あるいは、デッドロックをまったく防げないような状況がある
(練習問題<a href="#%_thm_3.48">3.48</a>と<a href="#%_thm_3.49">3.49</a>を参照)<a href="#footnote_Temp_435"><sup><small>48</small></sup></a>。
</p>


<p class="orig" lang="en"><a name="%_thm_3.48"></a>
<b>Exercise 3.48.</b>  <a name="%_idx_3708"></a>Explain in detail why the deadlock-avoidance method described above,
(i.e., the accounts are numbered, and each process attempts to acquire
the smaller-numbered account first) avoids deadlock in the exchange
problem.  Rewrite <tt>serialized-exchange</tt> to incorporate this idea.
(You will
also need to modify <tt>make-account</tt> so that each account is created
with a number, which can be accessed by sending an appropriate
message.)

</p>

<p class="trans" lang="ja"><b>練習問題3.48.</b> 上記のデッドロック回避法 (つまり、口座に番号がつけられ、各プロセスは、より小さい番号のついた口座をまず獲得しようとする) が、なぜ、交換の問題ではデッドロックを回避するのか、を詳しく説明せよ。
この考えを取り込むように、<tt>serialized-exchange</tt> を書き換えよ
(各口座が、番号——適切なメッセージを送ることによってアクセスできる——とともに作成されるように、<tt>make-account</tt> を修正する必要もあるだろう)。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.49"></a>
<b>Exercise 3.49.</b>  Give a scenario where the deadlock-avoidance mechanism described
above does not work.  (Hint: In the exchange problem, each process
knows in advance which accounts it will need to get access to.  Consider a
situation where a process must get access to some shared resources before it
can know which additional shared resources it will require.)

</p>

<p class="trans" lang="ja"><b>練習問題3.49.</b> 上記のデッドロック回避の仕組みがうまくいかないようなシナリオを示せ。
(ヒント：交換の問題では、各プロセスは、そのプロセスがどの口座への利用権を得る必要があるだろうか、ということを、事前に知っている。
プロセスが、自分がどの追加的な共有資源を必要とするだろうか、ということを知ることができないうちに、何らかの共有資源への利用権を得なくてはならない、という状況を考えよ。)
</p>

<p class="exercise"><span class="ex_comment">
</span></p>


<a name="%_sec_Temp_438"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_438">Concurrency, time, and communication</a></h4>
<h4 class="trans" lang="ja">並行性と時間と通信</h4>

<p class="orig" lang="en">
We've seen how programming concurrent systems requires controlling the
ordering of events when different processes access shared
state, and we've seen how to achieve this control through judicious
use of serializers.  But the problems of concurrency
lie deeper than this, because, from a fundamental point of view, it's
not always clear what is meant by ``shared state.''</p>

<p class="trans" lang="ja">
並行システムをプログラムすることが、異なるプロセスが共有状態にアクセスする場合のイベントの順序を制御することを、どのように必要とするのか、ということを私たちは見てきたし、また、シリアライザを思慮深く使うことを通じて、この制御をどのように達成するのか、ということを私たちは見てきた。
しかし、並行性の問題は、これよりも深いところにある——なぜなら、根本的な観点からは、「共有状態」が何を意味するのか、ということが必ずしも明確ではないからだ。
</p>

<p class="orig" lang="en">
Mechanisms such as <tt>test-and-set!</tt> require processes to examine a
global shared flag at arbitrary times.  This is problematic and
inefficient to implement in modern high-speed processors, where
due to optimization techniques such as pipelining and cached memory,
the contents of memory
may not be in a consistent state at every instant.  In contemporary
multiprocessing systems, therefore, the serializer paradigm is being
supplanted by new approaches to concurrency control.<a name="call_footnote_Temp_439" href="#footnote_Temp_439"><sup><small>49</small></sup></a></p>

<p class="trans" lang="ja">
<tt>test-and-set!</tt> のような仕組みは、プロセスが大域的な共有フラグを任意の時点で検査することを要する。
これには問題があり、近代的な高速プロセッサ——パイプライン化やキャッシュされたメモリなどの、最適化技法により、メモリの内容がどの瞬間においても整合性のとれた状態にあるわけではないかもしれない——で実装するには、非効率的である。
そのため、現代のマルチプロセシング・システムでは、シリアライザ・パラダイムは、並行性制御への新たな取り組みに、取って代わられつつある<a href="#footnote_Temp_439"><sup><small>49</small></sup></a>。

</p>

<p class="orig" lang="en">
The problematic aspects of shared state also arise
in large, distributed systems.  For
instance, imagine a
distributed banking system where individual branch banks maintain
local values for bank balances and periodically compare these with
values maintained by other branches.  In such a system the value of
``the account balance'' would be undetermined, except right after
synchronization.
If Peter deposits money in an account he holds
jointly with Paul, when should we say that the account balance has
changed -- when the balance in the local branch changes, or not until
after the synchronization?  
And if Paul accesses the account from a
different branch, what are the reasonable constraints to place on the
banking system such that the behavior is ``correct''?  
The only thing that might matter for
correctness is the behavior observed by Peter and Paul individually
and the ``state'' of the account immediately after synchronization.
Questions about the
``real'' account balance or the order of events between synchronizations
may be irrelevant or meaningless.<a name="call_footnote_Temp_440" href="#footnote_Temp_440"><sup><small>50</small></sup></a></p>

<p class="trans" lang="ja">
共有状態の問題多き側面は、大規模な分散システムにおいても発生する。
たとえば、個々の支店銀行が、銀行残高についての局所的な値を保持し、これらの値を、他の支店で保持されている値と定期的に比べるような、分散銀行システムを想像せよ。
そうしたシステムでは、同期の直後を除き、「口座残高」の値は定まらないだろう。
もしピーターが、ポールと共同で保有している口座に預金をしたら、局所的支店の残高はいつ変化するのだろう?　あるいは、同期の後までは変化しないのだろうか?
そして、もしポールが別の支店から当該口座にアクセスしたら、振る舞いが「正しい」ものとなるように、銀行システムに対して課すべき、筋の通った制約とは、どんなものだろうか?
正しさにとって重要かもしれない唯一のことは、ピーターとポールにより個々に観察される振る舞いであり、同期直後の口座の「状態」である。
「現実」の口座残高あるいは同期同士の間のイベントの順序についての疑問は、無関係または無意味である<a href="#footnote_Temp_440"><sup><small>50</small></sup></a>。
</p>

<p class="orig" lang="en">
<a name="%_idx_3720"></a>The basic phenomenon here is that synchronizing different processes,
establishing shared state, or imposing an order on events requires
communication among the processes.  In essence, any notion of time in
concurrency control must be intimately tied to communication.<a name="call_footnote_Temp_441" href="#footnote_Temp_441"><sup><small>51</small></sup></a>  It is
intriguing that a similar connection between time and communication
also arises in the <a name="%_idx_3724"></a>Theory of Relativity, where the speed of light (the
fastest signal that can be used to synchronize events) is a
fundamental constant relating time and space.  The
complexities we encounter in dealing with time and state in our
computational models may in fact mirror a fundamental complexity of
the physical universe.
</p>

<p class="trans" lang="ja">
ここでの基本的現象は、異なるプロセス同士を同期させること、共有状態を確立すること、または、諸イベントに対して順序を押し付けることが、プロセス間の通信を要する、ということである。
本質的には、並行性制御における、時間についてのいかなる概念も、通信と密接に結びついているはずである<a name="call_footnote_Temp_441" href="#footnote_Temp_441"><sup><small>51</small></sup></a>。
時間と通信の間の、似たようなつながりが、相対性理論——そこでは、光 (イベント同士を同期させるのに使える最速の信号) の速さが、時間と空間に関する根本的な定数である——でも生じることは、興味深い。
私たちの計算モデルにおける時間と状態を扱う際に私たちが遭遇する様々な複雑さは、実際は、物理的宇宙の根本的な複雑さを反映しているのかもしれない。
</p>


<hr>
<a name="footnotes"></a>

<p class="orig" lang="en"><a name="footnote_Temp_405" href="#call_footnote_Temp_405"><sup><small>34</small></sup></a> Most real processors actually execute a few
operations at a time, following a strategy called <a name="%_idx_3582"></a><em>pipelining</em>.  Although this technique greatly improves the effective
utilization of the hardware, it is used only to speed up the execution
of a sequential instruction stream, while retaining the behavior of
the sequential program.

</p>

<p class="trans" lang="ja">
ほとんどの現実のプロセッサは、<em>パイプライン化</em>と呼ばれる戦略にしたがって、実際には一度に少数個の演算を実行する。
この技法は、ハードウェアの有効活用をとても増進させるのだが、逐次的なプログラムの振る舞いを保持しつつ、逐次的な命令列の実行を高速化するためだけに使われている。</p>

<p class="orig" lang="en"><a name="footnote_Temp_406" href="#call_footnote_Temp_406"><sup><small>35</small></sup></a> To quote some graffiti seen on a Cambridge
<a name="%_idx_3586"></a>building wall: ``Time is a device that was invented to keep everything
from happening at once.''

</p>

<p class="trans" lang="ja">
ケンブリッジの建物の壁に見られる、ある落書きを引用すると、「時間とは、すべてのものが一度に起きないようにするために発明された仕掛けである」とのこと。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_407" href="#call_footnote_Temp_407"><sup><small>36</small></sup></a> An even worse failure for this system
could occur if the two <tt>set!</tt> operations attempt to change the
balance simultaneously, in which case the actual data appearing in
memory might end up being a random combination of the information
being written by the two processes.  Most computers have interlocks on
the primitive memory-write operations, which protect against such
simultaneous access.  Even this seemingly simple kind of protection,
however, raises implementation challenges in the design of
multiprocessing computers, where elaborate <a name="%_idx_3594"></a><em>cache-coherence</em>
protocols are required to ensure that the various processors will
maintain a consistent view of memory contents, despite the fact that
data may be replicated (``cached'') among the different processors to
increase the speed of memory access.
</p>

<p class="trans" lang="ja">
もし、二回の <tt>set!</tt> 操作が、残高を同時に変更しようとすると、このシステムにとってより一層まずい失敗が、起こり得る——その場合、メモリ内に現れる実際のデータは、最終的には、二つのプロセスによって書き込まれる情報のランダムな組み合わせ、ということになるかもしれないのだ。
ほとんどのコンピュータには、原始的なメモリ書き込み操作についての<ruby><rb>連動機構</rb><rp> (</rp><rt>インターロック</rt><rp>) </rp></ruby>があり、それによって、こういった同時アクセスに対する保護の役目を果たしている。
しかし、この見たところは簡素な種類の保護でさえ、マルチプロセシング・コンピュータの設計における実装上の課題を提起する——マルチプロセシング・コンピュータでは、メモリアクセスの速さを増すために、異なるプロセッサ間でデータが複製される（「キャッシュされる」）ことがある、という事実にもかかわらず、それでも、様々なプロセッサが、メモリの内容についての整合性のとれた眺めを保つことを保証するために、入念な<em>キャッシュ・コヒーレンシ</em>・プロトコルが必要とされるのだ。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_409" href="#call_footnote_Temp_409"><sup><small>37</small></sup></a> The factorial program in
section <a href="20_sec3_1.html#%_sec_3.1.3">3.1.3</a> illustrates this for a single
sequential process.
</p>

<p class="trans" lang="ja">
<a href="20_sec3_1.html#%_sec_3.1.3">3.1.3</a>節の階乗プログラムは、単一の逐次的プロセスについて、このことを例示している。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_410" href="#call_footnote_Temp_410"><sup><small>38</small></sup></a> The columns show the contents of Peter's wallet,
the joint account (in Bank1), Paul's wallet, and Paul's private account
(in Bank2), before and after each withdrawal (W) and deposit (D).
Peter withdraws $10 from Bank1; Paul deposits $5 in Bank2,
then withdraws $25 from Bank1.

</p>

<p class="trans" lang="ja">
これらの列は、それぞれの引き出し (W) と預け入れ (D) の前後における、ピーターの財布、(銀行その1の) 共同口座、ポールの財布、(銀行その2の) ポールの個人口座、の中身を示している。
ピーターが、銀行その1から10ドルを引き出し、ポールが、銀行その2に5ドルを預け入れ、それから、銀行その1から25ドルを引き出す。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_411" href="#call_footnote_Temp_411"><sup><small>39</small></sup></a> A more formal way to express this idea is to say that
concurrent programs are inherently <a name="%_idx_3604"></a><em>nondeterministic</em>. That
is, they are described not by single-valued functions, but by
functions whose results are sets of possible values.  In
section <a href="28_sec4_3.html#%_sec_4.3">4.3</a> we will study a
language for expressing nondeterministic
computations.
</p>

<p class="trans" lang="ja">
この考えを表すための、より形式的な方法は、並行なプログラムは内在的に<em>非決定的</em>なのだ、と述べることである。
つまり、並行なプログラムは、一価関数によっては記述されのではなく、あり得る値の集合をその結果とするような関数によって、記述されるのである。
<a href="28_sec4_3.html#%_sec_4.3">4.3</a>では、非決定的な計算を表現するための言語について研究しよう。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_415" href="#call_footnote_Temp_415"><sup><small>40</small></sup></a> <tt>Parallel-execute</tt> is not part of standard Scheme, but
it can be implemented in MIT Scheme.  In our implementation, the
new concurrent processes also run concurrently with the original
Scheme process.  Also, in our implementation, the value returned
by <tt>parallel-execute</tt> is a special control object that can be used
to halt the newly created processes.
</p>

<p class="trans" lang="ja">
<tt>parallel-execute</tt> は、標準的Schemeの一部ではないが、MIT Schemeで実装できる。
私たちの実装では、新たな並行プロセスも、元のSchemeプロセスと並行に実行される。
また、私たちの実装では、<tt>parallel-execute</tt> により返される値は、新たな作成されたプロセスを停止させるのに使える、特殊な制御オブジェクトである。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_421" href="#call_footnote_Temp_421"><sup><small>41</small></sup></a> We have simplified <tt>exchange</tt> by exploiting the fact
that our <tt>deposit</tt> message accepts negative amounts.  (This is a
serious bug in our banking system!)
</p>

<p class="trans" lang="ja">
私たちの <tt>deposit</tt> というメッセージが負の量を受け入れる、という事実を活用することで、私たちは、<tt>exchange</tt> を簡単化した。
(これは、私たちの銀行システムにおける深刻なバグである!)
</p>

<p class="orig" lang="en"><a name="footnote_Temp_422" href="#call_footnote_Temp_422"><sup><small>42</small></sup></a> If the account balances start out as $10,
$20, and $30, then after any number of concurrent exchanges, the
balances should still be $10, $20, and
$30 in some order.  Serializing the deposits to individual accounts is not
sufficient to guarantee this.  See exercise <a href="#%_thm_3.43">3.43</a>.

</p>

<p class="trans" lang="ja">
口座残高が10ドル、20ドル、30ドルで始まった場合、並行な交換を何回おこなった後でも、残高は、何らかの順序において、依然として10ドル、20ドル、30ドルとなるはずだ。
個別の口座への預け入れを直列化することは、これを保証するのに十分ではない。
練習問題<a href="#%_thm_3.43">3.43</a>を参照。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_423" href="#call_footnote_Temp_423"><sup><small>43</small></sup></a> Exercise <a href="#%_thm_3.45">3.45</a> investigates why
deposits and withdrawals are no longer automatically serialized
by the account.

</p>

<p class="trans" lang="ja">
練習問題<a href="#%_thm_3.45">3.45</a>は、なぜ、預け入れと引き出しが、もはや自動的に口座によって直列化されないのか、ということを研究している。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_428" href="#call_footnote_Temp_428"><sup><small>44</small></sup></a> The term ``mutex'' is an abbreviation for <a name="%_idx_3646"></a><em>mutual
exclusion</em>.  The general problem of arranging a mechanism that permits
concurrent processes to safely share resources is called the mutual
exclusion problem.  Our mutex is a simple variant of the <a name="%_idx_3648"></a><em>semaphore</em> mechanism (see exercise <a href="#%_thm_3.47">3.47</a>), which was
introduced in the <a name="%_idx_3650"></a>``THE'' Multiprogramming System developed at the
<a name="%_idx_3652"></a>Technological University of Eindhoven and named for the university's
initials in Dutch (Dijkstra 1968a).  The acquire and
release operations were originally called <a name="%_idx_3654"></a><a name="%_idx_3656"></a><a name="%_idx_3658"></a>P and V, from the Dutch
words <em>passeren</em> (to pass) and <em>vrijgeven</em> (to release), in
reference to the semaphores used on railroad systems.  Dijkstra's
classic exposition (1968b) was one of the first to clearly present the
issues of concurrency control, and showed how to use semaphores to
handle a variety of concurrency problems.
</p>

<p class="trans" lang="ja">
「ミューテックス」という用語は、<em>相互排他</em>の略語である。
並行はプロセスが安全に資源を共有することを許す仕組みを整えることの一般的な問題は、相互排他問題と呼ばれる。
私たちのミューテックスは、<em>セマフォ</em>の仕組み (練習問題<a href="#%_thm_3.47">3.47</a> を参照) ——アイントホーフェン工科大学で開発されてオランダ語での当該大学の頭文字にちなんで名付けられた、「THE」マルチプログラミング・システム (Dijkstra 1968a) で導入された——の簡潔な変種である。
獲得と解放の操作は、元は、鉄道システムに使われた<ruby><rb>腕木信号機</rb><rp> (</rp><rt>セマフォ</rt><rp>) </rp></ruby>を参照して、オランダ語の <em class="en">passeren</em> (通過する) と <em class="en">vrijgeven</em> (解放する) から、PとVと呼ばれた。
ダイクストラの古典的解説 (1968b) は、並行性制御の論点を明確に提示した最初期のものの一つであり、様々な並行性の問題を扱うのにセマフォをどう使うのか、ということを示した。

</p>

<p class="orig" lang="en"><a name="footnote_Temp_429" href="#call_footnote_Temp_429"><sup><small>45</small></sup></a> In most
time-shared operating systems, processes that are <a name="%_idx_3664"></a>blocked by a mutex do
<a name="%_idx_3666"></a>not waste time ``busy-waiting'' as above.  Instead, the system
schedules another process to run while the first is waiting, and the blocked
process is awakened when the mutex becomes available.

</p>

<p class="trans" lang="ja">
ほとんどの時分割式のオペレーティング・システムでは、ミューテックスによって阻止されるプロセスは、上記のように「ビジー・ウェイティング」で時間を無駄にするわけではない。
代わりに、システムは、第一のプロセスが待っている間に、別のプロセスを実行するように予定を組み、阻止されたプロセスは、ミューテックスが利用可能になった時に起こされる。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_430" href="#call_footnote_Temp_430"><sup><small>46</small></sup></a> In MIT Scheme for a single processor, which uses a time-slicing
model, <tt>test-and-set!</tt> can be implemented as follows:
<a name="%_idx_3676"></a><a name="%_idx_3678"></a></p>

<p class="trans" lang="ja">
単一プロセッサ用のMIT Scheme——タイム・スライシング・モデルを使う——では、<tt>test-and-set!</tt> を以下のように実装することができる。
</p>

<p class="lisp"><a name="%_idx_3680"></a>(define (test-and-set! cell)
  (without-interrupts
   (lambda ()
     (if (car cell)
         true
         (begin (set-car! cell true)
                false)))))
</p>


<p class="orig" lang="en">
<tt>Without-interrupts</tt> disables
time-slicing interrupts while its procedure argument is being executed.

</p>

<p class="trans" lang="ja">
<tt>without-interrupts</tt> は、自分への手続き引数が実行されている間は、タイム・スライシングの割り込みを無効化する。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_431" href="#call_footnote_Temp_431"><sup><small>47</small></sup></a> There are many variants of such
<a name="%_idx_3682"></a>instructions -- including test-and-set, test-and-clear, swap,
compare-and-exchange, load-reserve, and store-conditional -- whose
design must be carefully matched to the machine's processor-memory
interface.
One issue that arises here is to determine what happens
if two processes attempt to acquire the same resource
at exactly the same time by using such an instruction.
This requires some mechanism
for making a decision about which process gets control.  Such a
mechanism is called an <a name="%_idx_3684"></a><em>arbiter</em>.  Arbiters usually boil down to
some sort of hardware device.
Unfortunately, it is possible to prove that one cannot physically
construct a fair arbiter that works 100% of the time unless one
allows the arbiter an arbitrarily long time to make its decision.  The
fundamental phenomenon here was originally observed by the fourteenth-century
French philosopher <a name="%_idx_3686"></a>Jean Buridan in his commentary on
<a name="%_idx_3688"></a>Aristotle's <i>De caelo</i>.  Buridan argued that a perfectly rational
<a name="%_idx_3690"></a>dog placed between two equally attractive sources of food will starve
to death, because it is incapable of deciding which to go to first.
</p>

<p class="trans" lang="ja">
そういう命令の多くの変種——<ruby><rb>調べて設定</rb><rp> (</rp><rt>test-and-set</rt><rp>) </rp></ruby>、<ruby><rb>調べてクリア</rb><rp> (</rp><rt>test-and-clear</rt><rp>) </rp></ruby>、<ruby><rb>入れ替え</rb><rp> (</rp><rt>swap</rt><rp>) </rp></ruby>、<ruby><rb>比べて交換</rb><rp> (</rp><rt>compare-and-exchange</rt><rp>) </rp></ruby>、<ruby><rb>ロードして予約</rb><rp> (</rp><rt>load-reserve</rt><rp>) </rp></ruby>、<ruby><rb>条件つきストア</rb><rp> (</rp><rt>store-conditional</rt><rp>) </rp></ruby>などを含む——がある。
ここで持ち上がる一つの問題は、そうした命令を用いて、二つのプロセスが、ぴったり同時に同じ資源を獲得しようと試みたら、何が起こるのか、ということを決めることである。
これには、どちらのプロセスが支配権を握るのかについての決定を下すための、何らかの仕組みが必要だ。
そうした仕組みは、<em>調停器</em>と呼ばれる。
普通は、調停器は、つまるところある種のハードウェア装置になる。
しかしあいにく、決定を下すための任意に長い時間を調停器に許すのでない限り、100%の時間ちゃんと動く公平な調停器を物理的に構築することはできない、ということを証明できてしまうのだ。
ここでの根源的な現象は、もともとは14世紀のフランスの哲学者のジャン・ビュリダンにより、アリストテレスの『天体論』についての彼の論評の中で、観察された。
二つの等価に魅力的な餌の源の間に置かれた、完全に理性的な犬は、どちらに最初に行くべきかを決めることができないせいで、飢え死にするだろう、とビュリダンは論じた
<span class="note"> (あれ、これってビュリダンの驢馬のことだよね? 犬なの?)</span>。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_435" href="#call_footnote_Temp_435"><sup><small>48</small></sup></a> The general technique for avoiding deadlock by numbering the
<a name="%_idx_3700"></a>shared resources and acquiring them in order is due to <a name="%_idx_3702"></a><a name="%_idx_3704"></a><a name="%_idx_3706"></a>Havender
(1968).  Situations where deadlock cannot be avoided require <em>deadlock-recovery</em> methods, which entail having processes ``back out''
of the deadlocked state and try again.  Deadlock-recovery
mechanisms are widely used in database management systems, a topic that
is treated in detail in Gray and Reuter 1993.

</p>

<p class="trans" lang="ja">
共有資源に番号をつけ、それらの共有資源を順に獲得することによって、デッドロックを回避する一般的技法は、Havender (1968) によるものである。
デッドロックを回避できない状況では、<em>デッドロックからの回復</em>方法——プロセスに、デッドロックした状態から「手を引」かせて、再度挑戦させることを、必然的に伴う——が必要となる。
デッドロックからの回復の仕組みは、データベース管理システムで広く使われている——すなわち、Gray and Reuter 1993 で詳細に扱われている話題である。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_439" href="#call_footnote_Temp_439"><sup><small>49</small></sup></a> One such alternative to serialization is called <a name="%_idx_3710"></a><em>barrier
synchronization</em>.  The programmer permits concurrent processes to
execute as they please, but establishes certain synchronization points
(``barriers'') through which no process can proceed until all the
processes have reached the barrier.  Modern processors provide machine
instructions that permit programmers to establish synchronization
points at places where consistency is required.  The <a name="%_idx_3712"></a>PowerPC<sup>
<em>T</em><em>M</em></sup>, for example, includes for this purpose two instructions called
<a name="%_idx_3714"></a>SYNC and <a name="%_idx_3716"></a>EIEIO (Enforced In-order Execution of Input/Output).

</p>

<p class="trans" lang="ja">
直列化に対するそうした代替策の一つは、<em>バリア同期</em>と呼ばれる。
プログラマは、並行なプロセスが好きなように実行することを許すのだが、すべてのプロセスがそのバリアに達するまではどのプロセスもそこを通過して先に進むことはできないような、ある同期ポイント（「バリア」）を設ける。
近代的なプロセッサは、整合性が求められる場所にプログラマが同期ポイントを設けることを可能とするマシン命令を、提供している。
たとえば、PowerPC&trade;は、この目的のために、SYNC および EIEIO (Enforced In-order Execution of Input/Output: 強制的に順序どおりに行う入出力の実行) と呼ばれる二つの命令を含んでいる。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_440" href="#call_footnote_Temp_440"><sup><small>50</small></sup></a> This may seem like a strange point of view, but there are
<a name="%_idx_3718"></a>systems that work this way.  International charges to credit-card
accounts, for example, are normally cleared on a per-country basis,
and the charges made in different countries are periodically
reconciled.  Thus the account balance may be different in
different countries.

</p>

<p class="trans" lang="ja">
これは奇妙な見方のように見えるかもしれないが、こういう方法で動くシステムがあるのだ。
たとえば、クレジットカード口座への国際的な請求は、普通、国ごとに清算され、別々の国々でなされた請求同士に対して定期的に帳尻合わせの調整が行われる。
よって、口座残高は、別の国では異なっているかもしれない。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_441" href="#call_footnote_Temp_441"><sup><small>51</small></sup></a> For distributed
systems, this perspective was pursued by <a name="%_idx_3722"></a>Lamport (1978), who showed how
to use communication to establish ``global clocks'' that can be used
to establish orderings on events in distributed systems.
</p>

<p class="trans" lang="ja">
分散システムについては、この見方は、Lamport (1978) ——分散システムにおけるイベント同士に対する順序を確立するのに使える、「大域的な時計」を確立するために、通信をどう使うのか、を示した——によって追求された。
</p>


</div>
</body>
</html>
