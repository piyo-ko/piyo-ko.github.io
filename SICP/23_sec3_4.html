<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="sicp.css" type="text/css">
<base target="_top">
<title>SICPç§è¨³: 3.4 ä¸¦è¡Œæ€§: æ™‚é–“ã¯æœ¬è³ªçš„ãªã‚‚ã®ã§ã‚ã‚‹</title>
<link rel="canonical" href="https://piyo-ko.github.io/SICP/23_sec3_4.html" />
</head>
<body>

<div class="idx-bar">
<nav>
<a href="https://twitter.com/share" class="twitter-share-button" data-lang="ja">ãƒ„ã‚¤ãƒ¼ãƒˆ</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
<span class="status">æ¨æ•²å¾…ã¡</span>
[
<a href="00_cover.html">å…ˆé ­ã¸</a> |
<a href="22_sec3_3.html">å‰ã¸</a> |
<a href="24_sec3_5.html">æ¬¡ã¸</a> |
<a href="04_toc.html#%_toc_start">ç›®æ¬¡</a> |
<a href="38_index.html#%_index_start">ç´¢å¼•</a>
] [<a href="99_about.html">ã“ã®å¯¾è¨³ç‰ˆã«ã¤ã„ã¦</a> | <a href="../index.html">ãƒ›ãƒ¼ãƒ </a>]
[
Â§<a href="#%_sec_3.4">3.4</a>
Â§<a href="#%_sec_3.4.1">3.4.1</a>
ğŸ“š<a href="#%_sec_Temp_408">&hellip;</a>
ğŸ¨<a href="#%_fig_3.29">3.29</a>
ğŸ¨<a href="#%_fig_3.30">3.30</a>
ğŸ“<a href="#%_thm_3.38">3.38</a>
Â§<a href="#%_sec_3.4.2">3.4.2</a>
ğŸ“š<a href="#%_sec_Temp_413">&hellip;</a>
ğŸ“š<a href="#%_sec_Temp_414">&hellip;</a>
ğŸ“<a href="#%_thm_3.39">3.39</a>
ğŸ“<a href="#%_thm_3.40">3.40</a>
ğŸ“<a href="#%_thm_3.41">3.41</a>
ğŸ“<a href="#%_thm_3.42">3.42</a>
ğŸ“š<a href="#%_sec_Temp_420">&hellip;</a>
ğŸ“<a href="#%_thm_3.43">3.43</a>
ğŸ“<a href="#%_thm_3.44">3.44</a>
ğŸ“<a href="#%_thm_3.45">3.45</a>
ğŸ“š<a href="#%_sec_Temp_427">&hellip;</a>
ğŸ“<a href="#%_thm_3.46">3.46</a>
ğŸ“<a href="#%_thm_3.47">3.47</a>
ğŸ“š<a href="#%_sec_Temp_434">&hellip;</a>
ğŸ“<a href="#%_thm_3.48">3.48</a>
ğŸ“<a href="#%_thm_3.49">3.49</a>
ğŸ“š<a href="#%_sec_Temp_438">&hellip;</a>
<a href="#footnotes">è„šæ³¨</a>
]
</nav>


</div>
<!--
$ curl -o ch3-Z-G-#1.gif https://mitpress.mit.edu/sicp/full-text/book/ch3-Z-G-[31-33].gif
-->
<div class="main-txt">
<a name="%_sec_3.4"></a>
<h2 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_3.4">3.4  Concurrency: Time Is of the Essence</a></h2>
<h2 class="trans" lang="ja">3.4 ä¸¦è¡Œæ€§: æ™‚é–“ã¯æœ¬è³ªçš„ãªã‚‚ã®ã§ã‚ã‚‹</h2>


<p class="orig" lang="en">
<a name="%_idx_3578"></a>
We've seen the power of computational objects with local state as
tools for modeling.  Yet, as section <a href="20_sec3_1.html#%_sec_3.1.3">3.1.3</a>
warned, this power extracts a price: the loss of referential
transparency, giving rise to a thicket of questions about sameness and
change, and the need to abandon the substitution model of evaluation in
favor of the more intricate environment model.</p>

<p class="trans" lang="ja">
ç§ãŸã¡ã¯ã€å±€æ‰€çŠ¶æ…‹ã®ã‚ã‚‹è¨ˆç®—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã€ãƒ¢ãƒ‡ãƒ«åŒ–ã®æ‰‹æ®µã¨ã—ã¦ã®åŠ›ã‚’è¦‹ã¦ããŸã€‚
ã—ã‹ã—ã€<a href="20_sec3_1.html#%_sec_3.1.3">3.1.3</a>ç¯€ã§è­¦å‘Šã—ãŸã¨ãŠã‚Šã€ã“ã®åŠ›ã¯ä»£å„Ÿã‚’ã‚‚ãŸã‚‰ã™ã®ã ã€‚ã¤ã¾ã‚Šã€å‚ç…§ç­‰ä¾¡æ€§ã®å–ªå¤±ã‚„ã‚‰ã€åŒä¸€æ€§ã¨å¤‰åŒ–ã«ã¤ã„ã¦ã®ç–‘å¿µã®ã€éŒ¯ç¶œã—ãŸå±±ã‚’å¼•ãèµ·ã“ã™ã“ã¨ã‚„ã‚‰ã€ã‚ˆã‚Šè¾¼ã¿å…¥ã£ãŸç’°å¢ƒãƒ¢ãƒ‡ãƒ«ã«å–ã‚Šæ›¿ãˆã‚‹ã“ã¨ã«ã—ã¦ã€è©•ä¾¡ã®<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ãŠãã‹ãˆ</rt><rp>) </rp></ruby>ãƒ¢ãƒ‡ãƒ«ã‚’æ¨ã¦ã‚‹å¿…è¦æ€§ã‚„ã‚‰ã€ã¨ã„ã£ãŸä»£å„Ÿã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_3580"></a>The central issue lurking beneath the complexity of state, sameness,
and change is that by introducing assignment we are forced to admit
<em>time</em> into our computational models.  Before we introduced
assignment, all our programs were timeless, in the sense that any
expression that has a value always has the same value.  In contrast,
recall the example of modeling withdrawals from a bank account
and returning the resulting balance,
introduced at the beginning of
section <a href="20_sec3_1.html#%_sec_3.1.1">3.1.1</a>:</p>

<p class="trans" lang="ja">
çŠ¶æ…‹ã¨åŒä¸€æ€§ã¨å¤‰åŒ–ã¨ã®è¤‡é›‘æ€§ã®ä¸‹ã«æ½œã‚“ã§ã„ã‚‹ä¸­å¿ƒçš„ãªå•é¡Œã¯ã€<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã‚’å°å…¥ã™ã‚‹ã“ã¨ã§ã€è¨ˆç®—ãƒ¢ãƒ‡ãƒ«ã«<em>æ™‚é–“</em>ã‚’å—ã‘å…¥ã‚Œã‚‹ã“ã¨ã‚’èªã‚ã–ã‚‹ã‚’ãˆãªããªã‚‹ã€ã¨ã„ã†ã“ã¨ã§ã‚ã‚‹ã€‚
<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã‚’å°å…¥ã™ã‚‹å‰ã¯ã€ç§ãŸã¡ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ã™ã¹ã¦ã¯ã€æ™‚é–“ã¨ç„¡é–¢ä¿‚ã ã£ãŸâ€”â€”å€¤ã‚’æŒã£ã¦ã„ã‚‹å¼ã¯ã©ã‚Œã‚‚ã€ãã®åŒã˜å€¤ã‚’å¸¸ã«æŒã£ã¦ã„ã‚‹ã€ã¨ã„ã†æ„å‘³ã§ã€‚
å¯¾ç…§çš„ã«ã€éŠ€è¡Œå£åº§ã‹ã‚‰ã®å¼•ãå‡ºã—ã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã—ã¦ãã®çµæœã®æ®‹é«˜ã‚’è¿”ã™ä¾‹â€”â€”<a href="20_sec3_1.html#%_sec_3.1.1">3.1.1</a>ã®æœ€åˆã«å°å…¥ã—ãŸã‚‚ã®â€”â€”ã‚’æ€ã„èµ·ã“ãã†ã€‚
</p>

<p class="lisp">(withdraw 25)
<i>75</i>
(withdraw 25)
<i>50</i>
</p>


<p class="orig" lang="en">
Here successive evaluations of the same expression yield different
values.  This behavior arises from the fact that the execution of
assignment statements (in this case, assignments to the variable <tt>balance</tt>) delineates <em>moments in time</em> when values change.  The
result of evaluating an expression depends not only on the expression
itself, but also on whether the evaluation occurs before or after
these moments.  Building models in terms of computational objects with
local state forces us to confront time as an essential concept in
programming.</p>

<p class="trans" lang="ja">
ã“ã“ã§ã¯ã€åŒã˜å¼ã®é€£ç¶šã—ãŸè©•ä¾¡ãŒã€ç•°ãªã‚‹å€¤ã‚’ç”Ÿã¿å‡ºã™ã€‚
ã“ã®æŒ¯ã‚‹èˆã„ã¯ã€<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>æ–‡ (ã“ã®å ´åˆã¯ã€<tt>balance</tt> ã¨ã„ã†å¤‰æ•°ã¸ã®<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>) ã®å®Ÿè¡ŒãŒã€å€¤ãŒå¤‰åŒ–ã™ã‚‹<em>æ™‚ç‚¹</em>ã‚’ç²¾å¯†ã«èª¬æ˜ã™ã‚‹ã®ã ã€ã¨ã„ã†äº‹å®Ÿã‹ã‚‰ç”Ÿã˜ã‚‹ã€‚
å¼ã‚’è©•ä¾¡ã—ãŸçµæœã¯ã€ãã®å¼è‡ªä½“ã«ä¾å­˜ã™ã‚‹ã ã‘ã§ãªãã€ã“ã‚Œã‚‰ã®æ™‚ç‚¹ã®å‰ã«è©•ä¾¡ãŒèµ·ããŸã®ã‹ã€ãã‚Œã¨ã‚‚å¾Œã«èµ·ããŸã®ã‹ã€ã¨ã„ã†ã“ã¨ã«ã‚‚ä¾å­˜ã™ã‚‹ã€‚
å±€æ‰€çŠ¶æ…‹ã®ã‚ã‚‹è¨ˆç®—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½¿ã£ã¦ãƒ¢ãƒ‡ãƒ«ã‚’æ§‹ç¯‰ã™ã‚‹ã“ã¨ã§ã€ç§ãŸã¡ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã«ãŠã‘ã‚‹æœ¬è³ªçš„ãªæ¦‚å¿µã¨ã—ã¦ã€æ™‚é–“ã¨ç›´é¢ã›ã–ã‚‹ã‚’ãˆãªããªã‚‹ã®ã ã€‚
</p>

<p class="orig" lang="en">
We can go further in structuring computational models to match our
perception of the physical world.  Objects in the world do not change
one at a time in sequence.  Rather we perceive them as acting <em>concurrently</em> -- all at once.  So it is often natural to model systems
as collections of computational processes that execute concurrently.
Just as we can make our programs modular by organizing models in
terms of objects with separate local state, it is often appropriate to
divide computational models into parts that evolve separately and
concurrently.  Even if the programs are to be executed on a sequential
computer, the practice of writing programs as if they were to be
executed concurrently forces the programmer to avoid inessential
timing constraints and thus makes programs more modular.</p>

<p class="trans" lang="ja">
ç‰©ç†ä¸–ç•Œã«ã¤ã„ã¦ã®è‡ªåˆ†ãŸã¡ã®èªè­˜ã«ä¸€è‡´ã™ã‚‹ã‚ˆã†ã«ã€è¨ˆç®—ãƒ¢ãƒ‡ãƒ«ã‚’æ§‹é€ åŒ–ã™ã‚‹ã“ã¨ã«é–¢ã—ã¦ã€ç§ãŸã¡ã¯ã€ã•ã‚‰ã«è¸ã¿å‡ºã™ã“ã¨ãŒã§ãã‚‹ã€‚
ä¸–ç•Œã®ä¸­ã®<ruby><rb>ç‰©</rb><rp> (</rp><rt>ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ</rt><rp>) </rp></ruby>
ã¯ã€ä¸€åº¦ã«ä¸€ã¤ã¥ã¤é †ç•ªã«å¤‰åŒ–ã™ã‚‹ã®ã§ã¯ãªã„ã€‚
ã‚€ã—ã‚ã€ç§ãŸã¡ã¯ã€ãã‚Œã‚‰ã®ç‰©ãŒ<em>ä¸¦è¡Œã—ã¦</em>â€”â€”ã™ã¹ã¦ãŒä¸€åº¦ã«â€”â€”è¡Œå‹•ã—ã¦ã„ã‚‹ã€ã¨çŸ¥è¦šã™ã‚‹ã€‚
ã ã‹ã‚‰ã€ä¸¦è¡Œã—ã¦å®Ÿè¡Œã•ã‚Œã‚‹è¨ˆç®—ãƒ—ãƒ­ã‚»ã‚¹ã®é›†ã¾ã‚Šã¨ã—ã¦<ruby><rb>ç³»</rb><rp> (</rp><rt>ã‚·ã‚¹ãƒ†ãƒ </rt><rp>) </rp></ruby>ã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã™ã‚‹ã®ãŒè‡ªç„¶ã§ã‚ã‚‹ã“ã¨ãŒã€ã—ã°ã—ã°ã‚ã‚‹ã®ã ã€‚
åˆ¥ã€…ã®å±€æ‰€çŠ¶æ…‹ã‚’ã‚‚ã£ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½¿ã£ã¦ãƒ¢ãƒ‡ãƒ«ã‚’çµ„ç¹”åŒ–ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ€§ã®ã‚ã‚‹ã‚‚ã®ã«ã§ãã‚‹ã®ã¨ã¡ã‚‡ã†ã©åŒã˜ã‚ˆã†ã«ã€åˆ¥ã€…ã‹ã¤ä¸¦è¡Œã«é€²å±•ã™ã‚‹å¹¾ã¤ã‹ã®éƒ¨åˆ†ã¸ã¨ã€è¨ˆç®—ãƒ¢ãƒ‡ãƒ«ã‚’åˆ†å‰²ã™ã‚‹ã“ã¨ãŒé©åˆ‡ãªã“ã¨ãŒã€ã—ã°ã—ã°ã‚ã‚‹ã€‚
ãŸã¨ãˆãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒã€<ruby><rb>é€æ¬¡çš„</rb><rp> (</rp><rt>ã‚·ãƒ¼ã‚±ãƒ³ã‚·ãƒ£ãƒ«</rt><rp>) </rp></ruby>ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ä¸Šã§å®Ÿè¡Œã•ã‚Œã‚‹ã¹ãã‚‚ã®ã§ã‚ã‚ã†ã¨ã‚‚ã€ãã‚Œã‚‰ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒã¾ã‚‹ã§ä¸¦è¡Œã«å®Ÿè¡Œã•ã‚Œã‚‹ã¹ãã§ã‚ã‚‹ã‹ã®ã‚ˆã†ã«ã€ãã‚Œã‚‰ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ãã¨ã„ã†ç·´ç¿’ã«ã‚ˆã‚Šã€ãƒ—ãƒ­ã‚°ãƒ©ãƒã¯ã€éæœ¬è³ªçš„ãªã‚¿ã‚¤ãƒŸãƒ³ã‚°åˆ¶ç´„ã‚’é¿ã‘ã–ã‚‹ã‚’ãˆãªããªã‚Šã€ã—ãŸãŒã£ã¦ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€ã‚ˆã‚Šãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ€§ã®ã‚ã‚‹ã‚‚ã®ã«ãªã‚‹ã€‚
</p>

<p class="orig" lang="en">
In addition to making programs more modular, concurrent computation
can provide a speed advantage over sequential computation.  Sequential
computers execute only one operation at a time, so the amount of time
it takes to perform a task is proportional to the total number of
operations performed.<a name="call_footnote_Temp_405" href="#footnote_Temp_405"><sup><small>34</small></sup></a>
However, if it is possible to decompose a problem into pieces that are
relatively independent and need to communicate only rarely, it may be
possible to allocate pieces to separate computing processors,
producing a speed advantage proportional to the number of processors
available.</p>

<p class="trans" lang="ja">
ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ã‚ˆã‚Šãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ€§ã®ã‚ã‚‹ã‚‚ã®ã«ã™ã‚‹ã“ã¨ã«åŠ ãˆã¦ã€ä¸¦è¡Œè¨ˆç®—ã¯ã€é€æ¬¡è¨ˆç®—ã«å„ªã‚‹é€Ÿåº¦ã®åˆ©ç‚¹ã‚’æä¾›ã§ãã‚‹ã€‚
é€æ¬¡çš„ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã¯ã€ä¸€åº¦ã«ä¸€ã¤ã®æ¼”ç®—ã—ã‹å®Ÿè¡Œã›ãšã€ãã®ãŸã‚ã€ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œã™ã‚‹ã®ã«ã‹ã‹ã‚‹æ™‚é–“ã®é‡ã¯ã€å®Ÿè¡Œã•ã‚Œã‚‹æ¼”ç®—ã®ç·æ•°ã«æ¯”ä¾‹ã™ã‚‹<a href="#footnote_Temp_405"><sup><small>34</small></sup></a>ã€‚
ã—ã‹ã—ã€ã‚‚ã—ã€æ¯”è¼ƒçš„ç‹¬ç«‹ã—ã¦ã„ã¦ç¨€ã«ã—ã‹é€šä¿¡ã™ã‚‹å¿…è¦ãŒãªã„ã‚ˆã†ãªå¹¾ã¤ã‹ã®éƒ¨åˆ†ã¸ã¨å•é¡Œã‚’åˆ†è§£ã™ã‚‹ã“ã¨ãŒå¯èƒ½ãªã‚‰ã€è«¸éƒ¨åˆ†ã‚’åˆ¥ã€…ã®ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒ»ãƒ—ãƒ­ã‚»ãƒƒã‚µã«å‰²ã‚Šå½“ã¦ã‚‹ã“ã¨ãŒå¯èƒ½ã‹ã‚‚ã—ã‚Œãªã„â€”â€”ãã‚Œã«ã‚ˆã‚Šã€åˆ©ç”¨å¯èƒ½ãªãƒ—ãƒ­ã‚»ãƒƒã‚µã®æ•°ã«æ¯”ä¾‹ã™ã‚‹ã€é€Ÿåº¦ã®åˆ©ç‚¹ã‚’ã€ç”Ÿã¿å‡ºã™ã“ã¨ã«ãªã‚ã†ã€‚
</p>

<p class="orig" lang="en">
Unfortunately, the complexities introduced by assignment become even
more problematic in the presence of concurrency.  The fact of
concurrent execution, either because the world operates in parallel or
because our computers do, entails additional complexity in our
understanding of time.</p>

<p class="trans" lang="ja">
ã—ã‹ã—ã‚ã„ã«ãã€ä¸¦è¡Œæ€§ãŒå­˜åœ¨ã™ã‚‹ã¨ã“ã‚ã§ã¯ã€<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã«ã‚ˆã‚ŠæŒã¡è¾¼ã¾ã‚ŒãŸè¤‡é›‘æ€§ã¯ã€ã‚ˆã‚Šãšã£ã¨é›£ã—ã„å•é¡Œã«ãªã‚‹ã®ã ã€‚
ä¸¦è¡Œå®Ÿè¡Œã¨ã„ã†äº‹å®Ÿã¯ã€ä¸–ç•ŒãŒä¸¦åˆ—ã«å‹•ã„ã¦ã„ã‚‹ã‹ã‚‰ã§ã‚ã‚ã†ãŒã€ã‚ã‚‹ã„ã¯ã€ç§ãŸã¡ã®ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãŒä¸¦åˆ—ã«å‹•ã„ã¦ã„ã‚‹ã‹ã‚‰ã§ã‚ã‚ã†ãŒã€æ™‚é–“ã«ã¤ã„ã¦ã®ç§ãŸã¡ã®ç†è§£ã«ã€ä»˜åŠ çš„ãªè¤‡é›‘ã•ã‚’å¦å¿œãªãã‚‚ãŸã‚‰ã™ã€‚
</p>


<a name="%_sec_3.4.1"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_3.4.1">3.4.1  The Nature of Time in Concurrent Systems</a></h3>
<h3 class="trans" lang="ja">3.4.1 ä¸¦è¡Œã‚·ã‚¹ãƒ†ãƒ ã«ãŠã‘ã‚‹æ™‚é–“ã®æœ¬è³ª</h3>


<p class="orig" lang="en">
<a name="%_idx_3584"></a>
On the surface, time seems straightforward.  It
is an ordering imposed on events.<a name="call_footnote_Temp_406" href="#footnote_Temp_406"><sup><small>35</small></sup></a>
For any events <em>A</em> and <em>B</em>, either <em>A</em> occurs before <em>B</em>, <em>A</em> and <em>B</em>
are simultaneous, or <em>A</em> occurs after <em>B</em>.  For instance,
returning to the bank account example, suppose that Peter withdraws
$10 and Paul withdraws $25 from a <a name="%_idx_3588"></a>joint account that initially
contains $100, leaving $65 in the account.  Depending on the order
of the two withdrawals, the sequence of balances in the account is
either $100 <img src="book-Z-G-D-15.gif" border="0"> $90 <img src="book-Z-G-D-15.gif" border="0"> $65 or
$100 <img src="book-Z-G-D-15.gif" border="0"> $75 <img src="book-Z-G-D-15.gif" border="0"> $65.  In a computer implementation
of the banking system, this changing sequence of balances could be
modeled by successive assignments to a variable <tt>balance</tt>.</p>

<p class="trans" lang="ja">
è¡¨é¢ä¸Šã¯ã€æ™‚é–“ã¯ã¾ã£ã™ãã«é€²ã‚€ã‚ˆã†ã«è¦‹ãˆã‚‹ã€‚
æ™‚é–“ã¯ã€<ruby><rb>å‡ºæ¥äº‹</rb><rp> (</rp><rt>ã‚¤ãƒ™ãƒ³ãƒˆ</rt><rp>) </rp></ruby>ã®ä¸Šã«æŠ¼ã—ã¤ã‘ã‚‰ã‚Œã‚‹é †åºã¥ã‘ã§ã‚ã‚‹<a href="#footnote_Temp_406"><sup><small>35</small></sup></a>ã€‚
ä»»æ„ã® <em class="en">A</em> ãŠã‚ˆã³ <em class="en">B</em> ã¨ã„ã†å‡ºæ¥äº‹ã«å¯¾ã—ã¦ã€<em class="en">A</em> ãŒ <em class="en">B</em> ã®å‰ã«èµ·ãã‚‹ã‹ã€<em class="en">A</em> ã¨ <em class="en">B</em> ãŒåŒæ™‚ã‹ã€<em class="en">A</em> ãŒ <em class="en">B</em> ã®å¾Œã«èµ·ãã‚‹ã‹ã€ã®ã„ãšã‚Œã‹ã§ã‚ã‚‹ã€‚
ãŸã¨ãˆã°ã€éŠ€è¡Œå£åº§ã®ä¾‹ã«æˆ»ã‚‹ã¨ã€æœ€åˆã«100ãƒ‰ãƒ«ã‚’æœ‰ã—ã¦ã„ã‚‹å…±åŒé é‡‘å£åº§ã‹ã‚‰ã€ãƒ”ãƒ¼ã‚¿ãƒ¼ãŒ10ãƒ‰ãƒ«ã‚’å¼•ãå‡ºã—ã¦ã€ãƒãƒ¼ãƒ«ãŒ25ãƒ‰ãƒ«ã‚’å¼•ãå‡ºã™ã¨ã™ã‚‹ã¨ã€ãã‚Œã«ã‚ˆã‚Šã€å£åº§ã«ã¯65ãƒ‰ãƒ«ãŒæ®‹ã‚‹ã€‚
äºŒå›ã®å¼•ãå‡ºã—ã®é †åºã«ã‚ˆã£ã¦ã€å£åº§æ®‹é«˜ã®åˆ—ã¯ã€
<span class="math">100ãƒ‰ãƒ« &rarr; 90ãƒ‰ãƒ« &rarr; 65ãƒ‰ãƒ«</span>
ã‹ã€
<span class="math">100ãƒ‰ãƒ« &rarr; 75ãƒ‰ãƒ« &rarr; 65ãƒ‰ãƒ«</span>
ã®ã€ã„ãšã‚Œã‹ã§ã‚ã‚‹ã€‚
éŠ€è¡Œã‚·ã‚¹ãƒ†ãƒ ã®ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿å®Ÿè£…ã«ãŠã„ã¦ã€ã“ã®ã‚ˆã†ãªå¤‰åŒ–ã™ã‚‹æ®‹é«˜ã®åˆ—ã¯ã€<tt>balance</tt> ã¨ã„ã†å¤‰æ•°ã¸ã®é€£ç¶šã—ãŸ<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã«ã‚ˆã‚Šã€ãƒ¢ãƒ‡ãƒ«åŒ–ã§ãã‚‹ã ã‚ã†ã€‚
</p>

<p class="orig" lang="en">
In complex situations, however, such a view can be problematic.
Suppose that Peter and Paul, and other people besides, are
accessing the same bank account through a network of banking machines
distributed all over the world.  The actual sequence of balances in
the account will depend critically on the detailed timing of the
accesses and the details of the communication among the machines.</p>

<p class="trans" lang="ja">
ã—ã‹ã—ã€è¤‡é›‘ãªçŠ¶æ³ã§ã¯ã€ãã†ã—ãŸè¦‹æ–¹ã¯ã€å•é¡Œã®ã‚ã‚‹ã‚‚ã®ã¨ãªã‚Šã‹ã­ãªã„ã€‚
ãƒ”ãƒ¼ã‚¿ãƒ¼ã¨ãƒãƒ¼ãƒ«ã€ãã—ã¦ã•ã‚‰ã«åˆ¥ã®äººãŸã¡ãŒã€ä¸–ç•Œä¸­ã«åˆ†æ•£ã—ãŸéŠ€è¡Œå–å¼•ç”¨ã®æ©Ÿæ¢°ã®ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚’é€šã˜ã¦ã€åŒã˜éŠ€è¡Œå£åº§ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ã„ã‚‹ã¨ã“ã‚ã ã¨ã—ã‚ˆã†ã€‚
å£åº§ã®æ®‹é«˜ã®å®Ÿéš›ã®åˆ—ã¯ã€ã‚¢ã‚¯ã‚»ã‚¹ã®ç´°ã‹ã„ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã¨ã€æ©Ÿæ¢°åŒå£«ã®é–“ã§ã®é€šä¿¡ã®è©³ç´°ã«ã€æ±ºå®šçš„ã«ä¾å­˜ã™ã‚‹ã ã‚ã†ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_3590"></a>This indeterminacy in the order of events can pose serious problems in
the design of concurrent systems.  For instance, suppose that the
withdrawals made by Peter and Paul are implemented as two separate
processes sharing a common variable <tt>balance</tt>, each process
specified by the procedure given in
section <a href="20_sec3_1.html#%_sec_3.1.1">3.1.1</a>:
</p>

<p class="trans" lang="ja">
å‡ºæ¥äº‹ã®é †åºã«ãŠã‘ã‚‹ã€ã“ã®ä¸ç¢ºå®šæ€§ã¯ã€ä¸¦è¡Œã‚·ã‚¹ãƒ†ãƒ ã®è¨­è¨ˆã«æ·±åˆ»ãªå•é¡Œã‚’ã‚‚ãŸã‚‰ã™å¯èƒ½æ€§ãŒã‚ã‚‹ã€‚
ãŸã¨ãˆã°ã€ãƒ”ãƒ¼ã‚¿ãƒ¼ã¨ãƒãƒ¼ãƒ«ã«ã‚ˆã£ã¦è¡Œã‚ã‚ŒãŸå¼•ãå‡ºã—ãŒã€ <tt>balance</tt> ã¨ã„ã†å…±é€šã®å¤‰æ•°ã‚’å…±æœ‰ã—ã¦ã„ã‚‹äºŒã¤ã®åˆ¥ã€…ã®ãƒ—ãƒ­ã‚»ã‚¹â€”â€”å„ãƒ—ãƒ­ã‚»ã‚¹ã¯  <a href="20_sec3_1.html#%_sec_3.1.1">3.1.1</a> ç¯€ã§ä¸ãˆã‚‰ã‚ŒãŸæ‰‹ç¶šãã«ã‚ˆã‚Šè¦å®šã•ã‚Œã¦ã„ã‚‹â€”â€”ã¨ã—ã¦å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ã€ã¨ã—ã‚ˆã†ã€‚
</p>

<p class="lisp"><a name="%_idx_3592"></a>(define (withdraw amount)
  (if (&gt;= balance amount)
      (begin (set! balance (- balance amount))
             balance)
      &quot;Insufficient funds&quot;))
</p>


<p class="orig" lang="en">
If the two processes operate independently, then Peter might test the
balance and attempt to withdraw a legitimate amount.  However, Paul
might withdraw some funds in between the time that Peter checks the
balance and the time Peter completes the withdrawal, thus invalidating
Peter's test.</p>

<p class="trans" lang="ja">
ã‚‚ã—äºŒã¤ã®ãƒ—ãƒ­ã‚»ã‚¹ãŒç‹¬ç«‹ã«å‹•ä½œã—ãŸã‚‰ã€ãƒ”ãƒ¼ã‚¿ãƒ¼ã¯ã€æ®‹é«˜ã‚’èª¿ã¹ã¦ã‹ã‚‰ã€åˆæ³•ãªé‡‘é¡ã‚’å¼•ãå‡ºãã†ã¨è©¦ã¿ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚
ã—ã‹ã—ã€ãƒ”ãƒ¼ã‚¿ãƒ¼ãŒæ®‹é«˜ã‚’èª¿ã¹ã‚‹æ™‚ç‚¹ã¨ã€ãƒ”ãƒ¼ã‚¿ãƒ¼ãŒå¼•ãå‡ºã—ã‚’å®Œäº†ã™ã‚‹æ™‚ç‚¹ã¨ã®é–“ã«ã€ãƒãƒ¼ãƒ«ãŒä½•ã‚‰ã‹ã®è³‡é‡‘ã‚’å¼•ãå‡ºã™ã‹ã‚‚ã—ã‚Œãšã€ãã‚Œã«ã‚ˆã£ã¦ã€ãƒ”ãƒ¼ã‚¿ãƒ¼ã®æ¤œæŸ»ã‚’ç„¡åŠ¹åŒ–ã—ã¦ã—ã¾ã†ã‹ã‚‚ã—ã‚Œãªã„ã€‚
</p>

<p class="orig" lang="en">
Things can be worse still.  Consider the expression
</p>

<p class="trans" lang="ja">
ã‚‚ã®ã”ã¨ã¯ã€ã•ã‚‰ã«ä¸€å±¤æ‚ªããªã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã€‚
ä»¥ä¸‹ã®å¼ã‚’è€ƒãˆã‚ˆã†ã€‚
</p>

<p class="lisp">(set! balance (- balance amount))
</p>

<p class="orig" lang="en">
executed as part of each withdrawal process.  This consists of three
steps: (1) accessing the value of the <tt>balance</tt> variable; (2)
computing the new balance; (3) setting <tt>balance</tt> to this new
value.  If Peter and Paul's withdrawals execute this statement
concurrently, then the two withdrawals might interleave the order in
which they access <tt>balance</tt> and set it to the new value.</p>

<p class="trans" lang="ja">
ã“ã‚Œã¯ã€ãã‚Œãã‚Œã®å¼•ãå‡ºã—ãƒ—ãƒ­ã‚»ã‚¹ã®ä¸€éƒ¨ã¨ã—ã¦å®Ÿè¡Œã•ã‚Œã‚‹ã‚‚ã®ã§ã‚ã‚‹ã€‚
ã“ã‚Œã¯ã€
(1) <tt>balance</tt> ã¨ã„ã†å¤‰æ•°ã®å€¤ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã€
(2) æ–°ãŸãªæ®‹é«˜ã‚’è¨ˆç®—ã—ã€
(3) <tt>balance</tt> ã‚’ã“ã®æ–°ãŸãªå€¤ã«è¨­å®šã™ã‚‹ã€
ã¨ã„ã†ã€ä¸‰ã¤ã®ã‚¹ãƒ†ãƒƒãƒ—ã‹ã‚‰ãªã‚‹ã€‚
ã‚‚ã—ã€ãƒ”ãƒ¼ã‚¿ãƒ¼ã«ã‚ˆã‚‹å¼•ãå‡ºã—ã¨ãƒãƒ¼ãƒ«ã«ã‚ˆã‚‹å¼•ãå‡ºã—ãŒã“ã®æ–‡ã‚’ä¸¦è¡Œã«å®Ÿè¡Œã—ãŸã‚‰ã€äºŒåº¦ã®å¼•ãå‡ºã—ã¯ã€ãã‚Œã‚‰äºŒåº¦ã®å¼•ãå‡ºã—ãŒ <tt>balance</tt> ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ã“ã‚Œã‚’æ–°ãŸãªå€¤ã«è¨­å®šã™ã‚‹éš›ã®é †åºã‚’ã€<!--ãŠäº’ã„ã®é–“ã«æŒŸã¾ã‚Šåˆã†ã‚ˆã†ã«æ··ãœã¦-->æ··ãœã“ãœã«ã—ã¦ã—ã¾ã†ã‹ã‚‚ã—ã‚Œãªã„ã€‚
</p>

<p class="orig" lang="en">
The timing diagram in figure <a href="#%_fig_3.29">3.29</a> depicts an order of
events where <tt>balance</tt> starts at 100, Peter withdraws 10,
Paul withdraws 25, and yet the final value of <tt>balance</tt> is 75.  As
shown in the diagram, the reason for this anomaly is that Paul's
assignment of 75 to <tt>balance</tt> is made under the assumption that
the value of <tt>balance</tt> to be decremented is 100.  That assumption,
however, became invalid when Peter changed <tt>balance</tt> to 90.  This
is a catastrophic failure for the banking system, because the total
amount of money in the system is not conserved.  Before the transactions,
the total amount of money was $100.  Afterwards, Peter has $10, Paul
has $25, and the bank has $75.<a name="call_footnote_Temp_407" href="#footnote_Temp_407"><sup><small>36</small></sup></a></p>

<p class="trans" lang="ja">
å›³<a href="#%_fig_3.29">3.29</a>ã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°å›³ã¯ã€<tt>balance</tt> ãŒ100ã‹ã‚‰å§‹ã¾ã‚Šã€ãƒ”ãƒ¼ã‚¿ãƒ¼ãŒ10ã‚’å¼•ãå‡ºã—ã€ãƒãƒ¼ãƒ«ãŒ25ã‚’å¼•ãå‡ºã—ã€ãã—ã¦ã€ãã‚Œã§ã‚‚ã¾ã  <tt>balance</tt> ã®æœ€çµ‚å€¤ãŒ75ã ã€ã¨ã„ã†å‡ºæ¥äº‹ã®é †åºã‚’å›³ç¤ºã—ã¦ã„ã‚‹ã€‚
å›³ã«ç¤ºã™ã‚ˆã†ã«ã€ã“ã®ç•°å¸¸ã®ç†ç”±ã¯ã€ãƒãƒ¼ãƒ«ã® <tt>balance</tt> ã¸ã®75ã®<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ãŒã€ã“ã‚Œã‹ã‚‰æ¸›ã‚‰ã™ã¹ã <tt>balance</tt> ã®å€¤ãŒ100ã ã€ã¨ã„ã†ä»®å®šã®ã‚‚ã¨ã«ãªã•ã‚Œã¦ã„ã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚
ãã®ä»®å®šã¯ã€ã—ã‹ã—ã€ãƒ”ãƒ¼ã‚¿ãƒ¼ãŒ <tt>balance</tt> ã‚’90ã«å¤‰æ›´ã—ãŸã¨ãã«ç„¡åŠ¹ã«ãªã£ãŸã®ã ã€‚
ã“ã‚Œã¯ã€éŠ€è¡Œã‚·ã‚¹ãƒ†ãƒ ã«ã¨ã£ã¦å£Šæ»…çš„ãªå¤±æ•—ã§ã‚ã‚‹ã€‚ãªãœãªã‚‰ã€ã‚·ã‚¹ãƒ†ãƒ å†…ã®ç·é‡‘é¡ãŒä¿å…¨ã•ã‚Œãªã„ã‹ã‚‰ã ã€‚
å–å¼•ã®å‰ã«ã¯ã€ç·é‡‘é¡ã¯100ãƒ‰ãƒ«ã ã£ãŸã€‚
ãã®å¾Œã€ãƒ”ãƒ¼ã‚¿ãƒ¼ã¯10ãƒ‰ãƒ«ã‚’æŒã£ã¦ã„ã¦ã€ãƒãƒ¼ãƒ«ã¯25ãƒ‰ãƒ«ã‚’æŒã£ã¦ã„ã¦ã€éŠ€è¡Œã¯75ãƒ‰ãƒ«ã‚’æŒã£ã¦ã„ã‚‹ã®ã <a href="#footnote_Temp_407"><sup><small>36</small></sup></a>ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_3596"></a><a name="%_idx_3598"></a>The general phenomenon illustrated
here is that several processes may share  a
common state variable.  What makes this complicated is that more than
one process may be trying to manipulate the shared state at the same
time.  For the bank account example, during each transaction, each
customer should be able to act as if the other customers did not
exist.  When a customer changes the balance in a way that depends on
the balance, he must be able to assume that, just before the moment of
change, the balance is still what he thought it was.</p>

<p class="trans" lang="ja">
ã“ã“ã«ä¾‹ç¤ºã—ãŸä¸€èˆ¬çš„ç¾è±¡ã¯ã€ã„ãã¤ã‹ã®ãƒ—ãƒ­ã‚»ã‚¹ãŒå…±é€šã®çŠ¶æ…‹å¤‰æ•°ã‚’å…±æœ‰ã™ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€ã¨ã„ã†ã“ã¨ã§ã‚ã‚‹ã€‚
ã“ã‚Œã‚’è¤‡é›‘ã«ã—ã¦ã„ã‚‹ã®ã¯ã€ä¸€ã¤ã‚ˆã‚Šã‚‚å¤šã„ãƒ—ãƒ­ã‚»ã‚¹ãŒã€ãã®å…±æœ‰ã•ã‚ŒãŸçŠ¶æ…‹ã‚’åŒæ™‚ã«æ“ä½œã—ã‚ˆã†ã¨ã—ã¦ã„ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€ã¨ã„ã†ç‚¹ã§ã‚ã‚‹ã€‚
éŠ€è¡Œå£åº§ã®ä¾‹ã«ã¤ã„ã¦ã¯ã€ãã‚Œãã‚Œã®å–å¼•ã®é–“ã¯ãšã£ã¨ã€å„é¡§å®¢ã¯ã€ã‚ãŸã‹ã‚‚æ®‹ã‚Šã®é¡§å®¢ãŒå­˜åœ¨ã—ãªã„ã‹ã®ã‚ˆã†ã«è¡Œå‹•ã§ãã‚‹ã¹ãã§ã‚ã‚‹ã€‚
ã‚ã‚‹é¡§å®¢ãŒæ®‹é«˜ã«ä¾å­˜ã™ã‚‹ã‚ˆã†ãªæ–¹æ³•ã§æ®‹é«˜ã‚’å¤‰æ›´ã™ã‚‹ã¨ãã€ãã®é¡§å®¢ã¯ã€æ¬¡ã®ã‚ˆã†ã«æƒ³å®šã§ããªãã¦ã¯ãªã‚‰ãªã„ã€‚ã¤ã¾ã‚Šã€å¤‰æ›´ã®ç¬é–“ã®ç›´å‰ã«ãŠã„ã¦ã€ä¾ç„¶ã¨ã—ã¦æ®‹é«˜ã¯ã€è‡ªåˆ†ãŒãã®æ®‹é«˜ã¯ã“ã®é¡ã ãªã¨æ€ã£ãŸã¨ãŠã‚Šã®ã¾ã¾ã§ã‚ã‚‹ã€ã¨ã€‚
</p>

<a name="%_sec_Temp_408"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_408">Correct behavior of concurrent programs</a></h4>
<h4 class="trans" lang="ja">ä¸¦è¡Œãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®æ­£ã—ã„æŒ¯ã‚‹èˆã„</h4>

<p class="orig" lang="en">
<a name="%_idx_3600"></a>
The above example typifies the subtle bugs that can creep into
concurrent programs.  The root of this complexity lies in the
assignments to variables that are shared among the different
processes.  We already know that we must be careful in writing
programs that use <tt>set!</tt>, because the results of a computation
depend on the order in which the assignments occur.<a name="call_footnote_Temp_409" href="#footnote_Temp_409"><sup><small>37</small></sup></a>
With concurrent processes we must be especially careful about
assignments, because we may not be able to control the order of the
assignments made by the different processes.  If several such changes
might be made concurrently (as with two depositors accessing a joint
account) we need some way to ensure that our system behaves correctly.
For example, in the case of withdrawals from a joint bank account, we
must ensure that money is conserved.
To make concurrent programs behave correctly, we may have to
place some restrictions on concurrent execution.</p>

<p class="trans" lang="ja">
ä¸Šè¨˜ã®ä¾‹ã¯ã€ä¸¦è¡Œãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ä¸­ã«å…¥ã‚Šè¾¼ã¿å¾—ã‚‹ã€ã¨ã‚‰ãˆãŒãŸã„ãƒã‚°ã®å…¸å‹ä¾‹ã‚’ç¤ºã—ã¦ã„ã‚‹ã€‚
ã“ã®è¤‡é›‘ã•ã®æ ¹æºã¯ã€ç•°ãªã‚‹ãƒ—ãƒ­ã‚»ã‚¹é–“ã§å…±æœ‰ã•ã‚Œã‚‹å¤‰æ•°ã¸ã®<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã«ã‚ã‚‹ã€‚
<tt>set!</tt> ã‚’ä½¿ã†ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ãéš›ã«ã¯ã€<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ãŒç”Ÿã˜ã‚‹é †åºã«è¨ˆç®—çµæœãŒä¾å­˜ã™ã‚‹ã®ã§ã€æ³¨æ„æ·±ããªãã¦ã¯ã„ã‘ãªã„ã€ã¨ã„ã†ã“ã¨ã‚’ã€ç§ãŸã¡ã¯æ—¢ã«çŸ¥ã£ã¦ã„ã‚‹<a href="#footnote_Temp_409"><sup><small>37</small></sup></a>ã€‚
ä¸¦è¡Œãªãƒ—ãƒ­ã‚»ã‚¹ã‚’ä½¿ã†ã¨ãã€ç§ãŸã¡ã¯ã¨ã‚Šã‚ã‘<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã«ã¤ã„ã¦æ³¨æ„æ·±ããªãã¦ã¯ã„ã‘ãªã„ã€‚ã¨ã„ã†ã®ã‚‚ã€ç•°ãªã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã«ã‚ˆã‚Šè¡Œã‚ã‚Œã‚‹<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã®é †åºã‚’ã€è‡ªåˆ†ã§ã¯åˆ¶å¾¡ã§ããªã„ã‹ã‚‚ã—ã‚Œãªã„ã‹ã‚‰ã ã€‚
ã‚‚ã—ã€(å…±åŒé é‡‘å£åº§ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹äºŒäººã®é é‡‘è€…ã®å ´åˆã®ã‚ˆã†ã«) ã„ãã¤ã‹ã®ãã†ã—ãŸå¤‰æ›´ãŒä¸¦è¡Œã«è¡Œã‚ã‚Œã‚‹ãªã‚‰ã°ã€è‡ªåˆ†ã®ã‚·ã‚¹ãƒ†ãƒ ãŒæ­£ã—ãæŒ¯ã‚‹èˆã†ã“ã¨ã‚’ä¿è¨¼ã™ã‚‹ãŸã‚ã®ä½•ã‚‰ã‹ã®æ–¹æ³•ãŒå¿…è¦ã§ã‚ã‚‹ã€‚
ãŸã¨ãˆã°ã€å…±åŒé é‡‘å£åº§ã‹ã‚‰ã®å¼•ãå‡ºã—ã®å ´åˆã ã¨ã€é‡‘éŠ­ãŒä¿å…¨ã•ã‚Œã‚‹ã“ã¨ã‚’ä¿è¨¼ã›ã­ã°ãªã‚‰ãªã„ã€‚
ä¸¦è¡Œãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ­£ã—ãæŒ¯ã‚‹èˆã‚ã›ã‚‹ãŸã‚ã«ã¯ã€ä¸¦è¡Œãªå®Ÿè¡Œã«å¯¾ã—ã¦ã€ä½•ã‚‰ã‹ã®åˆ¶ç´„ã‚’èª²ã™å¿…è¦ãŒã‚ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚
</p>


<figure>
<a name="%_fig_3.29"></a>
<img src="ch3-Z-G-31.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.29:</b>  Timing diagram showing how interleaving the order of events
in two banking withdrawals can lead to an incorrect final balance.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³3.29:</b> éŠ€è¡Œæ‰‹ç¶šãä¸Šã®äºŒå›ã®å¼•ãå‡ºã—ã«ãŠã‘ã‚‹å‡ºæ¥äº‹ã®é †åºã‚’<!--ã€ãŠäº’ã„ã®é–“ã«æŒŸã¾ã‚Šåˆã†ã‚ˆã†ã«æ··ãœã‚‹-->æ··ãœã“ãœã«ã™ã‚‹ã“ã¨ãŒã€ã©ã®ã‚ˆã†ã«ã—ã¦ã€ä¸æ­£ãªæœ€çµ‚æ®‹é«˜ã¨ã„ã†çµæœã‚’å¼•ãèµ·ã“ã—å¾—ã‚‹ã®ã‹ã€ã‚’ç¤ºã™ã‚¿ã‚¤ãƒŸãƒ³ã‚°å›³</figcaption>
<a name="%_idx_3602"></a>
</figure>

<p class="orig" lang="en">
One possible restriction on concurrency would
stipulate that no two operations that
change any shared state variables can occur at the same time.  This is an
extremely stringent requirement.  For distributed banking, it would
require the system designer to ensure that only one transaction could
proceed at a time.  This would be both inefficient and overly
conservative.  Figure <a href="#%_fig_3.30">3.30</a> shows Peter and
Paul sharing a bank account, where Paul has a private account as well.
The diagram illustrates two withdrawals from the shared account
(one by Peter and one by Paul) and a deposit to Paul's private account.<a name="call_footnote_Temp_410" href="#footnote_Temp_410"><sup><small>38</small></sup></a>
The two withdrawals from the shared account must not be
concurrent (since both access and update the same account), and Paul's
deposit and withdrawal must not be concurrent (since both access and
update the amount in Paul's wallet).
But there should be no problem
permitting Paul's deposit to his private account to proceed
concurrently with Peter's withdrawal from the shared account.</p>

<p class="trans" lang="ja">
ä¸¦è¡Œæ€§ã«å¯¾ã™ã‚‹ä¸€ã¤ã®å¯èƒ½ãªåˆ¶ç´„ã¯ã€ã©ã‚Œã‹å…±æœ‰ã•ã‚ŒãŸçŠ¶æ…‹å¤‰æ•°ã‚’å¤‰æ›´ã™ã‚‹ã‚ˆã†ãªã€ã„ã‹ãªã‚‹äºŒã¤ã®æ¼”ç®—ã‚‚ã€åŒæ™‚ã«ã¯èµ·ã“ã‚Šå¾—ãªã„ã€ã¨è¦å®šã™ã‚‹ã§ã‚ã‚ã†ã€‚
ã“ã‚Œã¯éå¸¸ã«å³æ ¼ãªè¦æ±‚ã§ã‚ã‚‹ã€‚
åˆ†æ•£éŠ€è¡Œæ¥­ã«ã¤ã„ã¦ã ã¨ã€ä¸€åº¦ã«ãŸã£ãŸä¸€ã¤ã®å–å¼•ã®ã¿ãŒé€²è¡Œã§ãã‚‹ã®ã ã¨ä¿è¨¼ã™ã‚‹ã‚ˆã†ã€ã‚·ã‚¹ãƒ†ãƒ è¨­è¨ˆè€…ã«è¦æ±‚ã™ã‚‹ã“ã¨ã«ãªã‚‹ã ã‚ã†ã€‚
ã“ã‚Œã¯ã€éåŠ¹ç‡çš„ã§ã‚‚ã‚ã‚Šã€éå‰°ã«æ…é‡ã§ã‚‚ã‚ã‚‹ã ã‚ã†ã€‚
å›³<a href="#%_fig_3.30">3.30</a>ã¯ã€ãƒ”ãƒ¼ã‚¿ãƒ¼ã¨ãƒãƒ¼ãƒ«ãŒéŠ€è¡Œå£åº§ã‚’å…±æœ‰ã—ã¦ã„ã¦ã€ãŸã ã—ãƒãƒ¼ãƒ«ã¯å€‹äººå£åº§ã‚‚æŒã£ã¦ã„ã‚‹ã€ã¨ã„ã†ã“ã¨ã‚’ç¤ºã—ã¦ã„ã‚‹ã€‚
ã“ã®å›³ã¯ã€å…±æœ‰å£åº§ã‹ã‚‰ã®äºŒå›ã®å¼•ãå‡ºã— (ä¸€å›ã¯ãƒ”ãƒ¼ã‚¿ãƒ¼ã«ã‚ˆã‚‹ã‚‚ã®ã€ã‚‚ã†ä¸€å›ã¯ãƒãƒ¼ãƒ«ã«ã‚ˆã‚‹ã‚‚ã®) ã¨ã€ãƒãƒ¼ãƒ«ã®å€‹äººå£åº§ã¸ã®ä¸€å›ã®é ã‘å…¥ã‚Œã¨ã‚’ç¤ºã—ã¦ã„ã‚‹<a href="#footnote_Temp_410"><sup><small>38</small></sup></a>ã€‚
å…±æœ‰å£åº§ã‹ã‚‰ã®äºŒå›ã®å¼•ãå‡ºã—ã¯ã€ä¸¦è¡Œã§ã‚ã£ã¦ã¯ãªã‚‰ãš (ãªãœãªã‚‰ã€åŒæ–¹ãŒåŒã˜å£åº§ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ã“ã‚Œã‚’æ›´æ–°ã™ã‚‹ã‹ã‚‰ã§ã‚ã‚‹) ã€ãƒãƒ¼ãƒ«ã®é ã‘å…¥ã‚Œã¨å¼•ãå‡ºã—ã‚‚ä¸¦è¡Œã§ã‚ã£ã¦ã¯ãªã‚‰ãªã„ (ãªãœãªã‚‰ã€åŒæ–¹ãŒãƒãƒ¼ãƒ«ã®è²¡å¸ƒã®ä¸­ã®é‡‘é¡ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ã“ã‚Œã‚’æ›´æ–°ã™ã‚‹ã‹ã‚‰ã§ã‚ã‚‹)ã€‚
ã—ã‹ã—ã€ãƒãƒ¼ãƒ«ã«ã‚ˆã‚‹è‡ªåˆ†ã®å€‹äººå£åº§ã¸ã®é ã‘å…¥ã‚ŒãŒã€ãƒ”ãƒ¼ã‚¿ãƒ¼ã«ã‚ˆã‚‹å…±æœ‰å£åº§ã‹ã‚‰ã®å¼•ãå‡ºã—ã¨ä¸¦è¡Œã«é€²è¡Œã™ã‚‹ã“ã¨ã‚’è¨±ã™ã“ã¨ã¯ã€ä½•ã®å•é¡Œã‚‚ãªã„ã¯ãšã ã€‚
</p>


<a name="%_fig_3.30"></a>
<figure>
<img src="ch3-Z-G-32.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.30:</b>  Concurrent deposits and withdrawals from a joint account
in Bank1 and a private account in Bank2.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³3.30:</b> éŠ€è¡Œãã®1ã®å…±åŒå£åº§ã¨éŠ€è¡Œãã®2ã®å€‹äººå£åº§ã«å¯¾ã™ã‚‹ã€ä¸¦è¡Œã—ãŸé ã‘å…¥ã‚Œã¨å¼•ãå‡ºã—</figcaption>
</figure>


<p class="orig" lang="en">
A less stringent restriction on concurrency would ensure that a
concurrent system produces the same result
as if the processes had run sequentially in some order.
There are two important aspects to this requirement.
First, it does not require the processes to actually run sequentially,
but only to produce results that are the same <em>as if</em> they had run
sequentially.  For the example in
figure <a href="#%_fig_3.30">3.30</a>, the designer of the bank account
system can safely allow Paul's deposit and Peter's withdrawal to
happen concurrently, because the net result will be the same as if the
two operations had happened sequentially.  Second, there may be more
than one possible ``correct'' result produced by a concurrent program,
because we require only that the result be the same as for <em>some</em>
sequential order.
For example, suppose that Peter and Paul's joint account starts out
with $100, and Peter deposits $40 while Paul concurrently withdraws
half the money in the account.
Then sequential execution could result in the account balance being
either $70 or $90 (see exercise <a href="#%_thm_3.38">3.38</a>).<a name="call_footnote_Temp_411" href="#footnote_Temp_411"><sup><small>39</small></sup></a></p>

<p class="trans" lang="ja">
ä¸¦è¡Œæ€§ã«å¯¾ã™ã‚‹ç·©ã‚ã®åˆ¶ç´„ã¯ã€ã¾ã‚‹ã§ãƒ—ãƒ­ã‚»ã‚¹ãŒä½•ã‚‰ã‹ã®é †åºã§é€æ¬¡çš„ã«å®Ÿè¡Œã•ã‚ŒãŸã®ã¨åŒã˜ã§ã‚ã‚‹ã‚ˆã†ãªçµæœã‚’ã€ä¸¦è¡Œã‚·ã‚¹ãƒ†ãƒ ãŒç”Ÿã¿å‡ºã™ã“ã¨ã‚’ã€ä¿è¨¼ã™ã‚‹ã ã‚ã†ã€‚
ã“ã®è¦ä»¶ã«å¯¾ã—ã¦ã¯ã€äºŒã¤ã®é‡è¦ãªå´é¢ãŒã‚ã‚‹ã€‚
ç¬¬ä¸€ã«ã€ã“ã‚Œã¯ã€ãƒ—ãƒ­ã‚»ã‚¹ãŒå®Ÿéš›ã«é€æ¬¡çš„ã«å®Ÿè¡Œã•ã‚Œã‚‹ã“ã¨ã‚’æ±‚ã‚ã¦ã„ã‚‹ã‚ã‘ã§ã¯ãªãã€ãŸã ã€ãƒ—ãƒ­ã‚»ã‚¹ãŒ<em>ã¾ã‚‹ã§</em>é€æ¬¡çš„ã«å®Ÿè¡Œã•ã‚ŒãŸã®ã¨åŒã˜ã§ã‚ã‚‹ã‚ˆã†ãªçµæœã‚’ç”Ÿã¿å‡ºã™ã“ã¨ã ã‘ã‚’ã€æ±‚ã‚ã¦ã„ã‚‹ã€‚
å›³<a href="#%_fig_3.30">3.30</a>ã®ä¾‹ã«ã¤ã„ã¦è¨€ã†ã¨ã€éŠ€è¡Œå£åº§ã‚·ã‚¹ãƒ†ãƒ ã®è¨­è¨ˆè€…ã¯ã€ãƒãƒ¼ãƒ«ã®é ã‘å…¥ã‚Œã¨ãƒ”ãƒ¼ã‚¿ãƒ¼ã®å¼•ãå‡ºã—ãŒä¸¦è¡Œã«ç”Ÿã˜ã‚‹ã“ã¨ã‚’ã€ä½•ã®å·®ã—æ”¯ãˆã‚‚ãªãã€è¨±ã™ã“ã¨ãŒã§ãã‚‹ã€‚ãªãœãªã‚‰ã€æœ€çµ‚çš„ãªçµæœã¯ã€ã¾ã‚‹ã§äºŒã¤ã®æ“ä½œãŒé€æ¬¡çš„ã«èµ·ããŸã®ã¨åŒã˜ã«ãªã‚‹ã ã‚ã†ã‹ã‚‰ã€‚
ç¬¬äºŒã«ã€ä¸¦è¡Œãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ã‚ˆã£ã¦ç”Ÿã¿å‡ºã•ã‚Œã‚‹ã€å¯èƒ½æ€§ã®ã‚ã‚‹ã€Œæ­£ã—ã„ã€çµæœãŒã€ä¸€ã¤ãªã‚‰ãšå­˜åœ¨ã™ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚ãªãœãªã‚‰ã€ç§ãŸã¡ã¯ã€<em>ä½•ã‚‰ã‹ã®</em>é€æ¬¡çš„é †åºã«ã¤ã„ã¦ã€ãã‚Œã¨çµæœãŒåŒã˜ã«ãªã‚‹ã“ã¨ã ã‘ã‚’æ±‚ã‚ã¦ã„ã‚‹ã‹ã‚‰ã§ã‚ã‚‹ã€‚
<!--ãŸã¨ãˆã°ã€ãƒ”ãƒ¼ã‚¿ãƒ¼ã¨ãƒãƒ¼ãƒ«ã®å…±åŒå£åº§ãŒ100ãƒ‰ãƒ«ã‹ã‚‰å§‹ã¾ã£ã¦ã€ãƒ”ãƒ¼ã‚¿ãƒ¼ãŒ40ãƒ‰ãƒ«ã‚’é ã‘å…¥ã‚Œã€ãã®é–“ã«ä¸¦è¡Œã—ã¦ãƒãƒ¼ãƒ«ãŒå£åº§ã®é‡‘é¡ã®åŠåˆ†ã‚’å¼•ãå‡ºã™ã€ã¨ä»®å®šã™ã‚‹ã€‚-->
ãŸã¨ãˆã°ã€ãƒ”ãƒ¼ã‚¿ãƒ¼ã¨ãƒãƒ¼ãƒ«ã®å…±åŒå£åº§ãŒ100ãƒ‰ãƒ«ã‹ã‚‰å§‹ã¾ã£ã¦ã€ãƒãƒ¼ãƒ«ãŒä¸¦è¡Œã—ã¦å£åº§ã®é‡‘é¡ã®åŠåˆ†ã‚’å¼•ãå‡ºã—ã¦ã„ã‚‹é–“ã«ãƒ”ãƒ¼ã‚¿ãƒ¼ãŒ40ãƒ‰ãƒ«ã‚’é ã‘å…¥ã‚Œã‚‹ã€ã¨ä»®å®šã™ã‚‹ã€‚
ã™ã‚‹ã¨ã€é€æ¬¡çš„ãªå®Ÿè¡Œã¯ã€å£åº§æ®‹é«˜ãŒ70ãƒ‰ãƒ«ã‹90ãƒ‰ãƒ«ã®ã„ãšã‚Œã‹ã€ã¨ã„ã†çµæœã‚’æ‹›ãå¾—ã‚‹ã ã‚ã† (ç·´ç¿’å•é¡Œ<a href="#%_thm_3.38">3.38</a>ã‚’å‚ç…§)
<a href="#footnote_Temp_411"><sup><small>39</small></sup></a>ã€‚
</p>

<p class="orig" lang="en">
There are still weaker requirements for correct execution of
concurrent programs.  A program for simulating <a name="%_idx_3606"></a>diffusion (say, the
flow of heat in an object) might consist of a large number of
processes, each one representing a small volume of space, that update
their values concurrently.  Each process repeatedly changes its
value to the average of its own value and its neighbors' values.
This algorithm
converges to the right answer independent of the order in which the
operations are done; there is no need for any restrictions on
concurrent use of the shared values.</p>

<p class="trans" lang="ja">
ä¸¦è¡Œãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®æ­£ã—ã„å®Ÿè¡Œã«å¯¾ã™ã‚‹ã€ã•ã‚‰ã«å¼±ã„è¦ä»¶ãŒã‚ã‚‹ã€‚
æ‹¡æ•£ (ãŸã¨ãˆã°ã€ã‚ã‚‹ç‰©ä½“ã®ä¸­ã§ã®ç†±ã®æµã‚Œ) ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã™ã‚‹ãŸã‚ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€è‡ªåˆ†è‡ªèº«ã®å€¤ã‚’ä¸¦è¡Œã«æ›´æ–°ã™ã‚‹ã‚ˆã†ãªå¤šæ•°ã®ãƒ—ãƒ­ã‚»ã‚¹â€”â€”ãã®ä¸€ã¤ä¸€ã¤ã¯ã€ç©ºé–“ã®å°ã•ãªä½“ç©ã‚’è¡¨ã—ã¦ã„ã‚‹â€”â€”ã‹ã‚‰ãªã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚
å„ãƒ—ãƒ­ã‚»ã‚¹ã¯ã€ç¹°ã‚Šè¿”ã—ã€è‡ªåˆ†ã®å€¤ã‚’ã€è‡ªåˆ†è‡ªèº«ã®å€¤ã¨è‡ªåˆ†ã®éš£æ¥è€…ã®å€¤ã¨ã®å¹³å‡ã¸ã¨ã€å¤‰æ›´ã™ã‚‹ã€‚
ã“ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯ã€æ¼”ç®—ãŒè¡Œã‚ã‚Œã‚‹é †åºã¨ã¯ç„¡é–¢ä¿‚ã«ã€æ­£ã—ã„ç­”ãˆã«åæŸã™ã‚‹ã€‚å…±æœ‰ã•ã‚Œã¦ã„ã‚‹å€¤ã®ä¸¦è¡Œåˆ©ç”¨ã«å¯¾ã—ã¦ã€ä½•ã®åˆ¶ç´„ã‚‚å¿…è¦ãªã„ã®ã ã€‚
</p>



<p class="orig" lang="en"><a name="%_thm_3.38"></a>
<b>Exercise 3.38.</b>  Suppose that Peter, Paul, and Mary share a joint bank account that
initially contains $100.  Concurrently, Peter deposits $10, Paul
withdraws $20, and Mary withdraws half the money in the account, by
executing the following commands:</p>

<p class="trans" lang="ja"><b>ç·´ç¿’å•é¡Œ3.38.</b> æœ€åˆã«100ãƒ‰ãƒ«ã‚’ä¿æœ‰ã—ã¦ã„ã‚‹éŠ€è¡Œå£åº§ã‚’ã€ãƒ”ãƒ¼ã‚¿ãƒ¼ã¨ãƒãƒ¼ãƒ«ã¨ãƒ¡ã‚¢ãƒªãŒå…±æœ‰ã—ã¦ã„ã‚‹ã€ã¨ä»®å®šã—ã‚ˆã†ã€‚
ä¸¦è¡Œã«ã€ãƒ”ãƒ¼ã‚¿ãƒ¼ã¯10ãƒ‰ãƒ«ã‚’é ã‘å…¥ã‚Œã€ãƒãƒ¼ãƒ«ã¯20ãƒ‰ãƒ«ã‚’å¼•ãå‡ºã—ã€ãƒ¡ã‚¢ãƒªã¯å£åº§å†…ã®é‡‘é¡ã®åŠåˆ†ã‚’å¼•ãå‡ºã™â€”â€”ä»¥ä¸‹ã®ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€‚
</p>

<div class="lisp">
<table border=0><tr><td valign=top >Peter: </td><td valign=top ><tt>(set! balance (+ balance 10))</tt></td></tr>
<tr><td valign=top >Paul: </td><td valign=top ><tt>(set! balance (- balance 20))</tt></td></tr>
<tr><td valign=top >Mary: </td><td valign=top ><tt>(set! balance (- balance (/ balance 2)))</tt>
</td></tr></table>
</div>

<ol class="orig" lang="en" style="list-style-type: lower-alpha" start="1"><li>List all the different possible values for <tt>balance</tt> after these
three transactions have been completed, assuming that the banking
system forces the three processes to run sequentially in some order.</li></ol>

<ol class="trans" lang="ja" style="list-style-type: lower-alpha" start="1"><li>
ã“ã‚Œã‚‰ã®ä¸‰å›ã®å–å¼•ãŒå®Œäº†ã—ãŸå¾Œã®ã€<tt>balance</tt> ã«ã¤ã„ã¦ã®ã€å¯èƒ½ãªç•°ãªã‚‹å€¤ã‚’ã™ã¹ã¦æŒ™ã’ã‚ˆâ€”â€”ãŸã ã—ã€éŠ€è¡Œã‚·ã‚¹ãƒ†ãƒ ã¯ã€ä¸‰ã¤ã®ãƒ—ãƒ­ã‚»ã‚¹ãŒã€ä½•ã‚‰ã‹ã®é †åºã§é€æ¬¡çš„ã«å®Ÿè¡Œã•ã‚Œã‚‹ã‚ˆã†ã«å¼·åˆ¶ã™ã‚‹ã€ã¨ä»®å®šã™ã‚‹ã€‚
</li></ol>

<p class="exercise"><span class="ex_comment">å¯èƒ½ãªé †åˆ—ã¯3!=6é€šã‚Šã€‚
(1) ãƒ”ãƒ¼ã‚¿ãƒ¼ã€ãƒãƒ¼ãƒ«ã€ãƒ¡ã‚¢ãƒªã®é †: $100 â†’ $110 â†’ $90 â†’ $45
(2) ãƒ”ãƒ¼ã‚¿ãƒ¼ã€ãƒ¡ã‚¢ãƒªã€ãƒãƒ¼ãƒ«ã®é †: $100 â†’ $110 â†’ $55 â†’ $35
(3) ãƒãƒ¼ãƒ«ã€ãƒ¡ã‚¢ãƒªã€ãƒ”ãƒ¼ã‚¿ãƒ¼ã®é †: $100 â†’ $80 â†’ $40 â†’ $50
(4) ãƒãƒ¼ãƒ«ã€ãƒ”ãƒ¼ã‚¿ãƒ¼ã€ãƒ¡ã‚¢ãƒªã®é †: $100 â†’ $80 â†’ $90 â†’ $45
(5) ãƒ¡ã‚¢ãƒªã€ãƒ”ãƒ¼ã‚¿ãƒ¼ã€ãƒãƒ¼ãƒ«ã®é †: $100 â†’ $50 â†’ $60 â†’ $40
(6) ãƒ¡ã‚¢ãƒªã€ãƒãƒ¼ãƒ«ã€ãƒ”ãƒ¼ã‚¿ãƒ¼ã®é †: $100 â†’ $50 â†’ $30 â†’ $40

ãƒ”ãƒ¼ã‚¿ãƒ¼ã¨ãƒãƒ¼ãƒ«ãŒé€£ç¶šã—ã¦ã„ã‚‹å ´åˆã€äºŒäººã®é †åºãŒå¤‰ã‚ã£ã¦ã‚‚æœ€çµ‚é¡ã«ã¯å½±éŸ¿ã—ãªã„ã€‚
çµå±€ã€ã‚ã‚Šå¾—ã‚‹æœ€çµ‚é‡‘é¡ã¯ã€35ã€40ã€45ã€50ãƒ‰ãƒ«ã®4é€šã‚Šã§ã‚ã‚‹ã€‚
</span></p>

<ol class="orig" lang="en" style="list-style-type: lower-alpha" start="2"><li>What are some other values
that could be produced if the system allows the processes to be interleaved?
Draw timing diagrams like the one in figure <a href="#%_fig_3.29">3.29</a> to
explain how these values can occur.
</li></ol>

<ol class="trans" lang="ja" style="list-style-type: lower-alpha" start="2"><li>
ãƒ—ãƒ­ã‚»ã‚¹åŒå£«ã‚’<!--ã€ãŠäº’ã„ã®é–“ã«æŒŸã¾ã‚Šåˆã†ã‚ˆã†ã«æ··ãœåˆã‚ã›ã‚‹-->æ··ãœã“ãœã«ã™ã‚‹ã“ã¨ã‚’ã€ã‚‚ã—ã‚·ã‚¹ãƒ†ãƒ ãŒè¨±ã™ã¨ã—ãŸã‚‰ã€ç”Ÿã¿å‡ºã•ã‚Œå¾—ã‚‹ã§ã‚ã‚ã†ã€ä»–ã®ã„ãã¤ã‹ã®å€¤ã¨ã¯ã€ã©ã®ã‚ˆã†ãªã‚‚ã®ã‹?
å›³<a href="#%_fig_3.29">3.29</a>ã®ã‚ˆã†ãªã‚¿ã‚¤ãƒŸãƒ³ã‚°å›³ã‚’æã„ã¦ã€ã“ã‚Œã‚‰ã®å€¤ãŒã©ã®ã‚ˆã†ã«ã—ã¦ç”Ÿã˜å¾—ã‚‹ã®ã‹ã€ã‚’èª¬æ˜ã›ã‚ˆã€‚
</li></ol>

<p class="exercise"><span class="ex_comment">(a) ã¾ãšã¯ç°¡å˜ãªä¾‹ã‹ã‚‰ã€‚3äººã¨ã‚‚åˆæœŸçŠ¶æ…‹ã®$100ã‚’è¦‹ã¦ã€ãã‚Œã«åŸºã¥ãã€æ–°ãŸãªé‡‘é¡ã‚’è¨ˆç®—ã™ã‚‹å ´åˆã€‚
ã“ã“ã¾ã§ã®ã€balanceã‚’èª­ã¿å–ã‚‹é †ã‚„ã€å„è‡ªã§è¨ˆç®—ã™ã‚‹é †ã¯ã€æœ€çµ‚é‡‘é¡ã«å½±éŸ¿ã—ãªã„ã€‚
æœ€çµ‚é‡‘é¡ã«å½±éŸ¿ã™ã‚‹ã®ã¯ã€ãã®å¾Œã®set!ãŒã©ã†ã„ã†é †ã§ç”Ÿã˜ã‚‹ã‹ã€ã¨ã„ã†ç‚¹ã§ã‚ã‚‹ã€‚
ä¸‹ã®å›³ã¯ã€ãƒ¡ã‚¢ãƒªã€ãƒ”ãƒ¼ã‚¿ãƒ¼ã€ãƒãƒ¼ãƒ«ã®é †ã®å ´åˆã‚’ç¤ºã—ã¦ã„ã‚‹ã€‚
æœ€å¾Œã«set!ã—ãŸäºº (ä¸‹å›³ã§ã¯ãƒãƒ¼ãƒ«) ã®å‘½ä»¤ãŒã€æœ€çµ‚é‡‘é¡ã‚’æ±ºå®šã¥ã‘ã‚‹ã€‚
ã‚ˆã£ã¦ã€ã‚ã‚Šå¾—ã‚‹é‡‘é¡ã¨ã—ã¦ã€$50ã€$80ã€$110ã‚’ã¾ãšæŒ™ã’ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚</span>

|      Peter               Paul               Bank        Mary
|                                             $100
|                                               |
|        +--------------------------------------+
|        |                                      |
|        |                  +-------------------+
|        V                  |                   |
|  access balance $100      |                   +--------+
|        |                  |                            |
|        |                  |                            V
|        |                  V                      access balance $100
|        |         access balance $100                   |
|        |                  |                            |
|        V                  |                            |
|  new value: 100+10=110    |                            V
|        |                  V                      new value: 100/2=50
|        |         new value: 100-20=80                  |
|        |                  |                            V
|        |                  |                      set! balance to $50
|        V                  |                            |
|  set! balance to $110     |                 $50&lt;-------+
|        |                  |
|        +-----------------------------------&gt;$110
|                           |
|                           V
|                  set! nalance to $80
|                           |
|                           +----------------&gt;$80
V
 time

<span class="ex_comment">(b) æœ€åˆã«ãƒ”ãƒ¼ã‚¿ãƒ¼ãŒset!ã¾ã§æ¸ˆã¾ã›ã¦ã‹ã‚‰ã€ãƒãƒ¼ãƒ«ã¨ãƒ¡ã‚¢ãƒªãŒbalanceã‚’èª­ã‚€å ´åˆã€‚
ãƒ”ãƒ¼ã‚¿ãƒ¼ã¯æœ€åˆã®$100ã¨ã„ã†é‡‘é¡ã‚’èª­ã‚“ã§ã€100+10=110ã¨è¨ˆç®—ã—ã€balanceã‚’$110ã«set!ã™ã‚‹ã€‚
ãƒãƒ¼ãƒ«ã¯110-20=90ã¨è¨ˆç®—ã—ã€ãƒ¡ã‚¢ãƒªã¯110/2=55ã¨è¨ˆç®—ã™ã‚‹ã€‚
ãƒãƒ¼ãƒ«ãŒå…ˆã«set!ã™ã‚‹ã¨ã€ä¸‹å›³ã®ã¨ãŠã‚Šæœ€çµ‚é‡‘é¡ã¯$55ã¨ãªã‚Šã€ãƒ¡ã‚¢ãƒªãŒå…ˆã«set!ã™ã‚‹ã¨ã€æœ€çµ‚é‡‘é¡ã¯$90ã¨ãªã‚‹ã€‚</span>

|      Peter               Paul               Bank        Mary
|                                             $100
|                                               |
|        +--------------------------------------+
|        |
|        V
|  access balance $100
|  new value: 100+10=110
|  set! balance to $110
|        |
|        +-----------------------------------&gt;$110
|                                               |
|                            +------------------+
|                            |                  |
|                            V                  +-----------+
|                  access balance $110                      |
|                  new value: 110-20=90                     V
|                            |                       access balance $110
|                            V                              |
|                  set! balance to $90               new value: 110/2=55
|                            |                              |
|                            +----------------&gt;$90          V
|                                                    set! balance to $55
|                                                           |
|                                             $55&lt;----------+
V
 time

<span class="ex_comment">(c) æœ€åˆã«ãƒãƒ¼ãƒ«ãŒset!ã¾ã§æ¸ˆã¾ã›ã¦ã‹ã‚‰ã€ãƒ”ãƒ¼ã‚¿ãƒ¼ã¨ãƒ¡ã‚¢ãƒªãŒbalanceã‚’èª­ã‚€å ´åˆã€‚
ãƒãƒ¼ãƒ«ã¯æœ€åˆã®$100ã¨ã„ã†é‡‘é¡ã‚’èª­ã‚“ã§ã€100-20=80ã¨è¨ˆç®—ã—ã€balanceã‚’$80ã«set!ã™ã‚‹ã€‚
ãƒ”ãƒ¼ã‚¿ãƒ¼ã¯80+10=90ã¨è¨ˆç®—ã—ã€ãƒ¡ã‚¢ãƒªã¯80/2=40ã¨è¨ˆç®—ã™ã‚‹ã€‚
ãƒ”ãƒ¼ã‚¿ãƒ¼ãŒå…ˆã«set!ã™ã‚‹ã¨ã€æœ€çµ‚é‡‘é¡ã¯$40ã¨ãªã‚Šã€ãƒ¡ã‚¢ãƒªãŒå…ˆã«set!ã™ã‚‹ã¨ã€æœ€çµ‚é‡‘é¡ã¯$90ã¨ãªã‚‹ã€‚</span>

<span class="ex_comment">(d) æœ€åˆã«ãƒ¡ã‚¢ãƒªãŒset!ã¾ã§æ¸ˆã¾ã›ã¦ã‹ã‚‰ã€ãƒ”ãƒ¼ã‚¿ãƒ¼ã¨ãƒãƒ¼ãƒ«ãŒbalanceã‚’èª­ã‚€å ´åˆã€‚
ãƒ¡ã‚¢ãƒªã¯æœ€åˆã®$100ã¨ã„ã†é‡‘é¡ã‚’èª­ã‚“ã§ã€100/2=50 (å³å¯†ã«ã¯ã€100-100/2=50) ã¨è¨ˆç®—ã—ã€balanceã‚’$50ã«set!ã™ã‚‹ã€‚
ãƒ”ãƒ¼ã‚¿ãƒ¼ã¯50+10=60ã¨è¨ˆç®—ã—ã€ãƒãƒ¼ãƒ«ã¯50-20=30ã¨è¨ˆç®—ã™ã‚‹ã€‚
ãƒ”ãƒ¼ã‚¿ãƒ¼ãŒå…ˆã«set!ã™ã‚‹ã¨ã€æœ€çµ‚é‡‘é¡ã¯$60ã¨ãªã‚Šã€ãƒãƒ¼ãƒ«ãŒå…ˆã«set!ã™ã‚‹ã¨ã€æœ€çµ‚é‡‘é¡ã¯$30ã¨ãªã‚‹ã€‚</span>

<span class="ex_comment">(e) æœ€åˆã«ãƒãƒ¼ãƒ«ã¨ãƒ¡ã‚¢ãƒªãŒä¸¦è¡Œã—ã¦balanceã‚’èª­ã¿ã€å„è‡ªè¨ˆç®—ã‚’ã™ã‚‹å ´åˆã€‚
ãƒãƒ¼ãƒ«ã¯100-20=80ã¨è¨ˆç®—ã—ã€ãƒ¡ã‚¢ãƒªã¯100/2=50ã¨è¨ˆç®—ã™ã‚‹ã€‚
(e1) ãƒ¡ã‚¢ãƒªã‚ˆã‚Šå…ˆã«ãƒãƒ¼ãƒ«ãŒset!ã—ã¦ã€ãã‚Œã‚’ãƒ”ãƒ¼ã‚¿ãƒ¼ãŒèª­ã‚€ã¨ã€ãƒ”ãƒ¼ã‚¿ãƒ¼ã¯80ï¼‹10=90ã¨è¨ˆç®—ã™ã‚‹ã€‚
ã€€ã€€ãã®å¾Œã€ãƒ¡ã‚¢ãƒªã€ãƒ”ãƒ¼ã‚¿ãƒ¼ã®é †ã§set!ã™ã‚Œã°ã€ä¸‹å›³ã®ã¨ãŠã‚Šæœ€çµ‚é‡‘é¡ã¯$90ã¨ãªã‚Šã€é€†é †ã§set!ã™ã‚Œã°ã€æœ€çµ‚é‡‘é¡ã¯$50ã¨ãªã‚‹ã€‚
(e2) ãƒãƒ¼ãƒ«ã‚ˆã‚Šå…ˆã«ãƒ¡ã‚¢ãƒªãŒset!ã—ã¦ã€ãã‚Œã‚’ãƒ”ãƒ¼ã‚¿ãƒ¼ãŒèª­ã‚€ã¨ã€ãƒ”ãƒ¼ã‚¿ãƒ¼ã¯50+10=60ã¨è¨ˆç®—ã™ã‚‹ã€‚
ã€€ã€€ãã®å¾Œã€ãƒãƒ¼ãƒ«ã€ãƒ”ãƒ¼ã‚¿ãƒ¼ã®é †ã§set!ã™ã‚Œã°ã€æœ€çµ‚é‡‘é¡ã¯$60ã¨ãªã‚Šã€é€†é †ã§set!ã™ã‚Œã°ã€æœ€çµ‚é‡‘é¡ã¯$80ã¨ãªã‚‹ã€‚</span>

|      Peter               Paul               Bank        Mary
|                                             $100
|                                               |
|                                               +----------+
|                                               |          |
|                          +--------------------+          V
|                          |                         access balance $100
|                          V                               |
|                 access balance $100                      V
|                 new value: 100-20=80              new value: 100/2=50
|                 set balance to $80                       |
|                          |                               |
|                          +------------------&gt;$80         |
|                                               |          |
|        +--------------------------------------+          V
|        |                                             set! balance to $50
|        V                                                 |
|  access balance $80                          $50&lt;--------+
|  new value: 80+10=90
|  set! balance to $90
|        |
|        +------------------------------------&gt;$90
V
 time

<span class="ex_comment">(f) æœ€åˆã«ãƒ”ãƒ¼ã‚¿ãƒ¼ã¨ãƒ¡ã‚¢ãƒªãŒä¸¦è¡Œã—ã¦balanceã‚’èª­ã¿ã€å„è‡ªè¨ˆç®—ã‚’ã™ã‚‹å ´åˆã€‚
ãƒ”ãƒ¼ã‚¿ãƒ¼ã¯100+10=110ã¨è¨ˆç®—ã—ã€ãƒ¡ã‚¢ãƒªã¯100/2=50ã¨è¨ˆç®—ã™ã‚‹ã€‚
(f1) ãƒ¡ã‚¢ãƒªã‚ˆã‚Šå…ˆã«ãƒ”ãƒ¼ã‚¿ãƒ¼ãŒset!ã—ã¦ã€ãã‚Œã‚’ãƒãƒ¼ãƒ«ãŒèª­ã‚€ã¨ã€ãƒãƒ¼ãƒ«ã¯110-20=90ã¨è¨ˆç®—ã™ã‚‹ã€‚
ã€€ã€€ãã®å¾Œã€ãƒ¡ã‚¢ãƒªã€ãƒãƒ¼ãƒ«ã®é †ã§set!ã™ã‚Œã°ã€æœ€çµ‚é‡‘é¡ã¯$90ã¨ãªã‚Šã€é€†é †ã§set!ã™ã‚Œã°ã€æœ€çµ‚é‡‘é¡ã¯$50ã¨ãªã‚‹ã€‚
(f2) ãƒ”ãƒ¼ã‚¿ãƒ¼ã‚ˆã‚Šå…ˆã«ãƒ¡ã‚¢ãƒªãŒset!ã—ã¦ã€ãã‚Œã‚’ãƒãƒ¼ãƒ«ãŒèª­ã‚€ã¨ã€ãƒãƒ¼ãƒ«ã¯50-20=30ã¨è¨ˆç®—ã™ã‚‹ã€‚
ã€€ã€€ãã®å¾Œã€ãƒ”ãƒ¼ã‚¿ãƒ¼ã€ãƒãƒ¼ãƒ«ã®é †ã§set!ã™ã‚Œã°ã€æœ€çµ‚é‡‘é¡ã¯$30ã¨ãªã‚Šã€é€†é †ã§set!ã™ã‚Œã°ã€æœ€çµ‚é‡‘é¡ã¯$110ã¨ãªã‚‹ã€‚</span>

<span class="ex_comment">(g) æœ€åˆã«ãƒ”ãƒ¼ã‚¿ãƒ¼ã¨ãƒãƒ¼ãƒ«ãŒä¸¦è¡Œã—ã¦balanceã‚’èª­ã¿ã€å„è‡ªè¨ˆç®—ã‚’ã™ã‚‹å ´åˆã€‚
ãƒ”ãƒ¼ã‚¿ãƒ¼ã¯100+10=110ã¨è¨ˆç®—ã—ã€ãƒãƒ¼ãƒ«ã¯100-20=80ã¨è¨ˆç®—ã™ã‚‹ã€‚
(g1) ãƒãƒ¼ãƒ«ã‚ˆã‚Šå…ˆã«ãƒ”ãƒ¼ã‚¿ãƒ¼ãŒset!ã—ã¦ã€ãã‚Œã‚’ãƒ¡ã‚¢ãƒªãŒèª­ã‚€ã¨ã€ãƒ¡ã‚¢ãƒªã¯110/2=55ã¨è¨ˆç®—ã™ã‚‹ã€‚
ã€€ã€€ãã®å¾Œã€ãƒãƒ¼ãƒ«ã€ãƒ¡ã‚¢ãƒªã®é †ã§set!ã™ã‚Œã°ã€æœ€çµ‚é‡‘é¡ã¯$55ã¨ãªã‚Šã€é€†é †ã§set!ã™ã‚Œã°ã€æœ€çµ‚é‡‘é¡ã¯$80ã¨ãªã‚‹ã€‚
(g2) ãƒ”ãƒ¼ã‚¿ãƒ¼ã‚ˆã‚Šå…ˆã«ãƒãƒ¼ãƒ«ãŒset!ã—ã¦ã€ãã‚Œã‚’ãƒ¡ã‚¢ãƒªãŒèª­ã‚€ã¨ã€ãƒ¡ã‚¢ãƒªã¯80/2=40ã¨è¨ˆç®—ã™ã‚‹ã€‚
ã€€ã€€ãã®å¾Œã€ãƒ”ãƒ¼ã‚¿ãƒ¼ã€ãƒ¡ã‚¢ãƒªã®é †ã§set!ã™ã‚Œã°ã€æœ€çµ‚é‡‘é¡ã¯$40ã¨ãªã‚Šã€é€†é †ã§set!ã™ã‚Œã°ã€æœ€çµ‚é‡‘é¡ã¯$110ã¨ãªã‚‹ã€‚</span>

<span class="ex_comment">(h) ã¾ã¨ã‚
30ã€40ã€50ã€55ã€60ã€80ã€90ã€110ãƒ‰ãƒ«ã€ã¨ã„ã†å¯èƒ½æ€§ãŒã‚ã‚‹ã“ã¨ãŒã‚ã‹ã£ãŸã€‚
</p>

<a name="%_sec_3.4.2"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_3.4.2">3.4.2  Mechanisms for Controlling Concurrency</a></h3>
<h3 class="trans" lang="ja">3.4.2 ä¸¦è¡Œæ€§ã‚’åˆ¶å¾¡ã™ã‚‹ãŸã‚ã®ä»•çµ„ã¿</h3>

<p class="orig" lang="en">
<a name="%_idx_3608"></a>
We've seen that the difficulty in dealing with concurrent processes is
rooted in the need to consider the interleaving of the order of events
in the different processes.  For example, suppose we have two
processes, one with three ordered events (<em>a</em>,<em>b</em>,<em>c</em>) and one with three
ordered events (<em>x</em>,<em>y</em>,<em>z</em>).  If the two processes run concurrently, with
no constraints on how their execution is interleaved, then there are
20 different possible orderings for the events that are consistent
with the individual orderings for the two processes:
</p>

<p class="trans" lang="ja">
ä¸¦è¡Œãªãƒ—ãƒ­ã‚»ã‚¹ã‚’æ‰±ã†éš›ã®å›°é›£ã¯ã€ç•°ãªã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã®ã‚¤ãƒ™ãƒ³ãƒˆåŒå£«ã®é †åºãŒå…¥ã‚Šæ··ã˜ã‚‹ã“ã¨ã‚’è€ƒæ…®ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€ã¨ã„ã†ç‚¹ã«æ ¹ã–ã—ã¦ã„ã‚‹ã€ã¨ã„ã†ã“ã¨ã‚’ç§ãŸã¡ã¯è¦‹ã¦ããŸã€‚
ãŸã¨ãˆã°ã€äºŒã¤ã®ãƒ—ãƒ­ã‚»ã‚¹ãŒã‚ã‚‹ã‚‚ã®ã¨ã—ã€ä¸€æ–¹ã¯
<span class="math">(<em class="en">a</em>,<em class="en">b</em>,<em class="en">c</em>)</span>
ã¨ã„ã†é †åºã¥ã‘ã‚‰ã‚ŒãŸä¸‰ã¤ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’æœ‰ã—ã€ã‚‚ã†ä¸€æ–¹ã¯
<span class="math">(<em class="en">x</em>,<em class="en">y</em>,<em class="en">z</em>)</span>
ã¨ã„ã†é †åºã¥ã‘ã‚‰ã‚ŒãŸä¸‰ã¤ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’æœ‰ã™ã‚‹ã‚‚ã®ã¨ã—ã‚ˆã†ã€‚
ã‚‚ã—ã€äºŒã¤ã®ãƒ—ãƒ­ã‚»ã‚¹ãŒä¸¦è¡Œã«â€”â€”ãã—ã¦ã€ã“ã‚Œã‚‰ã®ãƒ—ãƒ­ã‚»ã‚¹ã®å®Ÿè¡ŒãŒã©ã®ã‚ˆã†ã«<!--ãŠäº’ã„ã®é–“ã«æŒŸã¾ã‚Œã¦æ··ãœåˆã‚ã•ã‚Œã‚‹-->æ··ãœã“ãœã«ã•ã‚Œã‚‹ã®ã‹ã€ã«ã¤ã„ã¦ã®åˆ¶ç´„ãªã—ã«â€”â€”å®Ÿè¡Œã•ã‚ŒãŸã‚‰ã€äºŒã¤ã®ãƒ—ãƒ­ã‚»ã‚¹ã«ã¤ã„ã¦ã®å€‹åˆ¥ã®é †åºã¥ã‘ã¨æ•´åˆæ€§ãŒã‚ã‚‹ã‚ˆã†ãªã€ã‚¤ãƒ™ãƒ³ãƒˆé–“ã®å¯èƒ½ãªç•°ãªã‚‹é †åºã¥ã‘ãŒã€20é€šã‚Šã‚ã‚‹ã€‚
</p>

<figure><img src="ch3-Z-G-33.gif" border="0"></figure>


<p class="orig" lang="en">
As programmers designing this system, we would have to consider the
effects of each of these 20 orderings and check that each behavior is
acceptable.  Such an approach rapidly becomes unwieldy as the numbers
of processes and events increase.</p>

<p class="trans" lang="ja">
ã“ã®ã‚·ã‚¹ãƒ†ãƒ ã‚’è¨­è¨ˆã™ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒã¨ã—ã¦ã€ç§ãŸã¡ã¯ã€ã“ã‚Œã‚‰20é€šã‚Šã®é †åºã¥ã‘ã®å„ã€…ã®å½±éŸ¿ã‚’è€ƒæ…®ã—ãªãã¦ã¯ãªã‚‰ãªã„ã ã‚ã†ã—ã€å„ã€…ã®æŒ¯ã‚‹èˆã„ãŒè¨±å®¹ã§ãã‚‹ã“ã¨ã‚’ç¢ºã‹ã‚ãªãã¦ã¯ãªã‚‰ãªã„ã ã‚ã†ã€‚
ãã†ã„ã†æ‰‹æ³•ã¯ã€ãƒ—ãƒ­ã‚»ã‚¹æ•°ã‚„ã‚¤ãƒ™ãƒ³ãƒˆæ•°ãŒå¢—ãˆã‚‹ã«ã¤ã‚Œã¦ã€ã™ãã«æ‰‹ã«è² ãˆãªããªã‚‹ã€‚
</p>

<p class="orig" lang="en">
A more practical approach to the design of concurrent systems is to
devise general mechanisms that allow us to constrain the interleaving
of concurrent processes so that we can be sure that the program
behavior is correct.  Many mechanisms have been developed for this
purpose.  In this section, we describe one of them, the <em>serializer</em>.</p>

<p class="trans" lang="ja">
ä¸¦è¡Œã‚·ã‚¹ãƒ†ãƒ ã®è¨­è¨ˆã®ã€ã‚ˆã‚Šå®Ÿéš›çš„ãªæ‰‹æ³•ã¨ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®æŒ¯ã‚‹èˆã„ãŒæ­£ã—ã„ã¨ç¢ºä¿¡ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã«ã€ä¸¦è¡Œãªãƒ—ãƒ­ã‚»ã‚¹åŒå£«ãŒ<!--äº’ã„ã®é–“ã«æŒŸã¾ã£ã¦å…¥ã‚Šæ··ã˜ã‚‹-->æ··ãœã“ãœã«ãªã‚‹ã“ã¨ã‚’åˆ¶ç´„ã§ãã‚‹ã‚ˆã†ã«ã—ã¦ãã‚Œã‚‹ã€ä¸€èˆ¬çš„ãªä»•çµ„ã¿ã‚’è€ƒæ¡ˆã™ã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚
ã“ã®ç›®çš„ã®ãŸã‚ã«ã€å¤šãã®ä»•çµ„ã¿ãŒé–‹ç™ºã•ã‚Œã¦ããŸã€‚
æœ¬ç¯€ã§ã¯ã€ãã‚Œã‚‰ã®ã†ã¡ã®ä¸€ã¤â€”â€”ã™ãªã‚ã¡<em><ruby><rb>ç›´åˆ—åŒ–ã™ã‚‹ã‚‚ã®</rb><rp> (</rp><rt>ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¶</rt><rp>) </rp></ruby></em>â€”â€”ã«ã¤ã„ã¦ã€èª¬æ˜ã™ã‚‹ã€‚
</p>


<a name="%_sec_Temp_413"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_413">Serializing access to shared state</a></h4>
<h4 class="trans" lang="ja">å…±æœ‰çŠ¶æ…‹ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã‚’ç›´åˆ—åŒ–ã™ã‚‹</h4>

<p class="orig" lang="en">
<a name="%_idx_3610"></a>
Serialization implements the following idea: Processes will execute
concurrently, but there will be certain collections of procedures that
cannot be executed concurrently.  More precisely, serialization creates
distinguished sets of procedures such that only one execution of a
procedure in each serialized set is permitted to happen at a time.
If some procedure in the set is being executed, then a process that
attempts to execute any procedure in the set will be forced to wait
until the first execution has finished.</p>

<p class="trans" lang="ja">
<ruby><rb>ç›´åˆ—åŒ–</rb><rp> (</rp><rt>ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³</rt><rp>) </rp></ruby>ã¯ã€ä»¥ä¸‹ã®è€ƒãˆæ–¹ã‚’å®Ÿç¾ã™ã‚‹ã€‚
ãƒ—ãƒ­ã‚»ã‚¹ã¯ä¸¦è¡Œã«å®Ÿè¡Œã•ã‚Œã‚‹ã ã‚ã†ãŒã€ä¸¦è¡Œã«ã¯å®Ÿè¡Œã§ããªã„æ‰‹ç¶šãã®ã€ã‚ã‚‹é›†ã¾ã‚ŠãŒã‚ã‚‹ã ã‚ã†ã€‚
ã‚ˆã‚Šæ­£ç¢ºã«ã¯ã€ç›´åˆ—åŒ–ã¯ã€åˆ†åˆ¥ã•ã‚ŒãŸæ‰‹ç¶šãé›†åˆã‚’ã€ç›´åˆ—åŒ–ã•ã‚ŒãŸå„é›†åˆã®ã†ã¡ã§ä¸€ã¤ã®æ‰‹ç¶šãã®ä¸€ã¤ã®å®Ÿè¡Œã®ã¿ãŒä¸€åº¦ã«èµ·ã“ã‚‹ã“ã¨ã‚’è¨±ã•ã‚Œã‚‹ã‚ˆã†ã«ã—ã¦ã€ä½œæˆã™ã‚‹ã€‚
é›†åˆå†…ã®ä½•ã‚‰ã‹ã®æ‰‹ç¶šããŒå®Ÿè¡Œä¸­ãªã‚‰ã€ãã®é›†åˆå†…ã®æ‰‹ç¶šãã®ã©ã‚Œã‹ã‚’å®Ÿè¡Œã—ã‚ˆã†ã¨ã™ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã¯ã€æœ€åˆã«è¿°ã¹ãŸæ–¹ã®å®Ÿè¡ŒãŒçµ‚ã‚ã‚‹ã¾ã§ã€å¼·åˆ¶çš„ã«å¾…ãŸã•ã‚Œã‚‹ã ã‚ã†ã€‚
</p>

<p class="orig" lang="en">
We can use serialization to control access to shared variables.
For example, if we want to update a shared variable based on the
previous value of that variable, we put the access to the previous
value of the variable and the assignment of the new value to the
variable in the same procedure.  We then ensure that no other
procedure that assigns to the variable can run concurrently with this
procedure by serializing all of these procedures with the same
serializer.  This guarantees that the value of the variable cannot be
changed between an access and the corresponding assignment.</p>

<p class="trans" lang="ja">
å…±æœ‰å¤‰æ•°ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã‚’åˆ¶å¾¡ã™ã‚‹ã®ã«ã€ç›´åˆ—åŒ–ã‚’åˆ©ç”¨ã§ãã‚‹ã€‚
ãŸã¨ãˆã°ã€å…±æœ‰å¤‰æ•°ã‚’ã€ãã®å¤‰æ•°ã®ä»¥å‰ã®å€¤ã«åŸºã¥ã„ã¦æ›´æ–°ã—ãŸã„å ´åˆã€ãã®å¤‰æ•°ã®ä»¥å‰ã®å€¤ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã¨ã€ãã®å¤‰æ•°ã¸ã®æ–°ãŸãªå€¤ã®<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã¨ã‚’ã€åŒã˜æ‰‹ç¶šãã®ä¸­ã«è¨˜ã™ã€‚
ãã‚Œã‹ã‚‰ã€ãã®å¤‰æ•°ã¸ã®<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã‚’è¡Œã†ä»–ã®æ‰‹ç¶šãã¯ã©ã‚Œã‚‚ã€ã“ã®æ‰‹ç¶šãã¨ã¯ä¸¦è¡Œã«å®Ÿè¡Œã§ããªã„ã€ã¨ã„ã†ã“ã¨ã‚’ã€ã“ã‚Œã‚‰ã®æ‰‹ç¶šãã®ã™ã¹ã¦ã‚’åŒã˜ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¶ã§ç›´åˆ—åŒ–ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€ä¿è¨¼ã™ã‚‹ã€‚
ã“ã‚Œã¯ã€ãã®å¤‰æ•°ã®å€¤ãŒã€ã‚¢ã‚¯ã‚»ã‚¹ã¨ãã‚Œã«å¯¾å¿œã™ã‚‹<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã®é–“ã¯ã€å¤‰æ›´ã§ããªã„ã€ã¨ã„ã†ã“ã¨ã‚’ä¿è¨¼ã™ã‚‹ã€‚
</p>


<a name="%_sec_Temp_414"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_414">Serializers in Scheme</a></h4>
<h4 class="trans" lang="ja">Schemeã«ãŠã‘ã‚‹ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¶</h4>

<p class="orig" lang="en">
To make the above mechanism more concrete, suppose that we have
extended Scheme to include a procedure called <a name="%_idx_3612"></a><tt>parallel-execute</tt>:</p>

<p class="trans" lang="ja">
ä¸Šè¨˜ã®ä»•çµ„ã¿ã‚’ã‚ˆã‚Šå…·ä½“çš„ã«ã™ã‚‹ãŸã‚ã«ã€<tt>parallel-execute</tt> ã¨å‘¼ã°ã‚Œã‚‹æ‰‹ç¶šãã‚’å«ã‚€ã‚ˆã†ã«æ‹¡å¼µã•ã‚ŒãŸSchemeãŒã‚ã‚‹ã‚‚ã®ã¨ã—ã‚ˆã†ã€‚
</p>


<p class="lisp">(parallel-execute &lt;<em>p<sub>1</sub></em>&gt; &lt;<em>p<sub>2</sub></em>&gt; <tt>...</tt> &lt;<em>p<sub><em>k</em></sub></em>&gt;)
</p>


<p class="orig" lang="en">
Each &lt;<em>p</em>&gt; must be a procedure of no arguments.  <tt>Parallel-execute</tt>
creates a separate process for each
&lt;<em>p</em>&gt;, which applies &lt;<em>p</em>&gt; (to no arguments).  These processes all
run concurrently.<a name="call_footnote_Temp_415" href="#footnote_Temp_415"><sup><small>40</small></sup></a></p>

<p class="trans" lang="ja">
ãã‚Œãã‚Œã® &lt;<em class="en">p</em>&gt; ã¯ã€å¼•æ•°ã®ãªã„æ‰‹ç¶šãã§ãªãã¦ã¯ãªã‚‰ãªã„ã€‚
<tt>parallel-execute</tt> ã¯ã€ãã‚Œãã‚Œã® &lt;<em class="en">p</em>&gt; ã«å¯¾ã—ã¦åˆ¥ã€…ã®ãƒ—ãƒ­ã‚»ã‚¹â€”â€”ã“ã‚ŒãŒ &lt;<em class="en">p</em>&gt; ã‚’ (ç„¡å¼•æ•°ã«) é©ç”¨ã™ã‚‹â€”â€”ã‚’ä½œæˆã™ã‚‹ã€‚
ã“ã‚Œã‚‰ã®ãƒ—ãƒ­ã‚»ã‚¹ã¯ã™ã¹ã¦ä¸¦è¡Œã«å®Ÿè¡Œã•ã‚Œã‚‹<a href="#footnote_Temp_415"><sup><small>40</small></sup></a>ã€‚
</p>

<p class="orig" lang="en">
As an example of how this is used, consider</p>

<p class="trans" lang="ja">
ã“ã‚ŒãŒã©ã®ã‚ˆã†ã«ä½¿ã‚ã‚Œã‚‹ã‹ã®ä¾‹ã¨ã—ã¦ã€ä»¥ä¸‹ã®ã‚‚ã®ã‚’è€ƒãˆã‚ˆã†ã€‚
</p>

<p class="lisp">(define x 10)

(parallel-execute (lambda () (set! x (* x x)))
                  (lambda () (set! x (+ x 1))))
</p>

<p class="orig" lang="en">
This creates two concurrent processes -- <em>P</em><sub>1</sub>, which sets <tt>x</tt> to
<tt>x</tt> times <tt>x</tt>, and <em>P</em><sub>2</sub>, which increments <tt>x</tt>.  After
execution is complete, <tt>x</tt> will be left with one of five possible
values, depending on the interleaving of the events of <em>P</em><sub>1</sub> and
<em>P</em><sub>2</sub>:
</p>

<p class="trans" lang="ja">
ã“ã‚Œã¯ã€äºŒã¤ã®ä¸¦è¡Œãªãƒ—ãƒ­ã‚»ã‚¹ã‚’ä½œæˆã™ã‚‹ã€‚ã¤ã¾ã‚Šã€
<em class="en">P</em><sub>1</sub> â€”â€” <tt>x</tt> ã‚’ã€<tt>x</tt> æ›ã‘ã‚‹ <tt>x</tt> ã«è¨­å®šã™ã‚‹â€”â€”ã¨ã€
<em class="en">P</em><sub>2</sub> â€”â€” <tt>x</tt> ã‚’ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã™ã‚‹â€”â€”ã§ã‚ã‚‹ã€‚
å®Ÿè¡ŒãŒå®Œäº†ã™ã‚‹ã¨ã€<tt>x</tt> ã¯ã€5é€šã‚Šã®å¯èƒ½ãªå€¤ã®ã†ã¡ã®ä¸€ã¤ã«ãªã£ã¦ã„ã‚‹ã ã‚ã†â€”â€” <em class="en">P</em><sub>1</sub> ã¨ <em class="en">P</em><sub>2</sub> ã®ã‚¤ãƒ™ãƒ³ãƒˆåŒå£«ã®å…¥ã‚Šæ··ã˜ã‚Šæ–¹ã«å¿œã˜ã¦ã€‚
</p>

<div class="orig" lang="en">
<table class="expl"><tr><td valign=top >101: </td><td valign=top ><em>P</em><sub>1</sub> sets <tt>x</tt> to 100 and then <em>P</em><sub>2</sub> increments <tt>x</tt> to 101.</td></tr>
<tr><td valign=top >121: </td><td valign=top ><em>P</em><sub>2</sub> increments <tt>x</tt> to 11 and then <em>P</em><sub>1</sub> sets <tt>x</tt> to
<tt>x</tt> times <tt>x</tt>.</td></tr>
<tr><td valign=top >110: </td><td valign=top ><em>P</em><sub>2</sub> changes <tt>x</tt> from 10 to 11 between the two times that
<em>P</em><sub>1</sub> accesses the value of <tt>x</tt> during the evaluation of <tt>(* x x)</tt>.</td></tr>
<tr><td valign=top >11:  </td><td valign=top ><em>P</em><sub>2</sub> accesses <tt>x</tt>, then <em>P</em><sub>1</sub> sets <tt>x</tt> to 100,
then <em>P</em><sub>2</sub> sets <tt>x</tt>.</td></tr>
<tr><td valign=top >100: </td><td valign=top ><em>P</em><sub>1</sub> accesses <tt>x</tt> (twice), then <em>P</em><sub>2</sub> sets <tt>x</tt> to 11,
then <em>P</em><sub>1</sub> sets <tt>x</tt>.</td></tr>
</table>
</div>

<br>

<div class="trans" lang="ja">
<table class="expl">
<tr><td>101: </td><td><em class="en">P</em><sub>1</sub> ãŒ <tt>x</tt> ã‚’ 100 ã«è¨­å®šã—ã€ãã‚Œã‹ã‚‰ <em class="en">P</em><sub>2</sub> ãŒ <tt>x</tt> ã‚’ 101 ã«ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã™ã‚‹ã€‚</td></tr>
<tr><td>121: </td><td><em class="en">P</em><sub>2</sub> ãŒ <tt>x</tt> ã‚’ 11 ã«ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã—ã€ãã‚Œã‹ã‚‰ã€<em class="en">P</em><sub>1</sub> ãŒ <tt>x</tt> ã‚’ã€<tt>x</tt> æ›ã‘ã‚‹ <tt>x</tt> ã«è¨­å®šã™ã‚‹ã€‚</td></tr>
<tr><td>110: </td><td><em class="en">P</em><sub>1</sub> ãŒ <tt>(* x x)</tt> ã®è©•ä¾¡ã®æœ€ä¸­ã«ãŠã„ã¦ <tt>x</tt> ã®å€¤ã«äºŒå›ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã€ãã®äºŒå›ã®é–“ã«ã€<em class="en">P</em><sub>2</sub> ãŒ <tt>x</tt> ã‚’ 10 ã‹ã‚‰ 11ã¸ã¨å¤‰æ›´ã™ã‚‹ã€‚</td></tr>
<tr><td>11:  </td><td><em class="en">P</em><sub>2</sub> ãŒ <tt>x</tt> ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã€ãã‚Œã‹ã‚‰ã€<em class="en">P</em><sub>1</sub> ãŒ <tt>x</tt> ã‚’ 100 ã«è¨­å®šã—ã€ãã‚Œã‹ã‚‰ã€<em class="en">P</em><sub>2</sub> ãŒ <tt>x</tt> ã‚’è¨­å®šã™ã‚‹ã€‚</td></tr>
<tr><td>100: </td><td><em class="en">P</em><sub>1</sub> ãŒ <tt>x</tt> ã«ã‚¢ã‚¯ã‚»ã‚¹ã— (2å›)ã€ãã‚Œã‹ã‚‰ã€<em class="en">P</em><sub>2</sub> ãŒ <tt>x</tt> ã‚’ 11 ã«è¨­å®šã—ã€ãã‚Œã‹ã‚‰ã€<em class="en">P</em><sub>1</sub> ãŒ <tt>x</tt> ã‚’è¨­å®šã™ã‚‹ã€‚</td></tr>
</table>
</div>

<p class="orig" lang="en">
We can constrain the concurrency by using serialized procedures,
which are created by <em>serializers</em>. Serializers are constructed by <tt>make-serializer</tt>, whose implementation is given below.  A serializer
takes a procedure as argument and returns a serialized procedure that
behaves like the original procedure.  All calls to a given serializer
return serialized procedures in the same set.</p>

<p class="trans" lang="ja">
ç›´åˆ—åŒ–ã•ã‚ŒãŸæ‰‹ç¶šãâ€”â€”<em>ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¶</em>ã«ã‚ˆã‚Šä½œæˆã•ã‚Œã‚‹â€”â€”ã‚’ä½¿ã†ã“ã¨ã§ã€ä¸¦è¡Œæ€§ã‚’åˆ¶ç´„ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¶ã¯ã€<tt>make-serializer</tt> â€”â€”ãã®å®Ÿè£…ã¯ä»¥ä¸‹ã«ç¤ºã™â€”â€”ã«ã‚ˆã‚Šæ§‹ç¯‰ã•ã‚Œã‚‹ã€‚
ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¶ã¯ã€æ‰‹ç¶šãã‚’å¼•æ•°ã¨ã—ã¦ã¨ã‚Šã€ãã—ã¦ã€å…ƒã®æ‰‹ç¶šãã®ã‚ˆã†ã«æŒ¯ã‚‹èˆã†ç›´åˆ—åŒ–ã•ã‚ŒãŸæ‰‹ç¶šãã‚’è¿”ã™ã€‚
ä¸ãˆã‚‰ã‚ŒãŸã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¶ã«å¯¾ã™ã‚‹ã™ã¹ã¦ã®å‘¼ã³å‡ºã—ã¯ã€åŒä¸€é›†åˆå†…ã®ç›´åˆ—åŒ–ã•ã‚ŒãŸæ‰‹ç¶šãã‚’è¿”ã™ã€‚
</p>

<p class="orig" lang="en">
Thus, in contrast to the example above, executing</p>

<p class="trans" lang="ja">
ã‚ˆã£ã¦ã€ä¸Šè¨˜ã®ä¾‹ã¨ã¯å¯¾ç…§çš„ã«ã€ä»¥ä¸‹ã®ã‚ˆã†ã«å®Ÿè¡Œã™ã‚‹ã¨ã€
</p>


<p class="lisp">(define x 10)

(define s (make-serializer))

(parallel-execute (s (lambda () (set! x (* x x))))
                  (s (lambda () (set! x (+ x 1)))))
</p>


<p class="orig" lang="en">
can produce only two possible values for <tt>x</tt>, 101 or 121.  The
other possibilities are eliminated, because the execution of <em>P</em><sub>1</sub> and
<em>P</em><sub>2</sub> cannot be interleaved.</p>

<p class="trans" lang="ja">
<tt>x</tt> ã«å¯¾ã—ã¦ã€ã‚ã‚Šå¾—ã‚‹å€¤ã‚’äºŒã¤ã—ã‹ä½œã‚Šå‡ºã›ãªã„â€”â€”â€”ã¤ã¾ã‚Šã€101ã¾ãŸã¯121ã§ã‚ã‚‹ã€‚
æ®‹ã‚Šã®å¯èƒ½æ€§ã¯æ¶ˆã•ã‚Œã‚‹ã€‚ãªãœãªã‚‰ã€ <em class="en">P</em><sub>1</sub> ã¨ <em class="en">P</em><sub>2</sub> ã®å®Ÿè¡Œã¯ã€æ··ãœã“ãœã«ã§ããªã„ã‹ã‚‰ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
Here is a version of the <tt>make-account</tt> procedure from
section <a href="20_sec3_1.html#%_sec_3.1.1">3.1.1</a>, where the deposits and
withdrawals have been serialized:</p>

<p class="trans" lang="ja">
ã“ã“ã«ã€<a href="20_sec3_1.html#%_sec_3.1.1">3.1.1</a>ç¯€ã® <tt>make-account</tt> ã®ã€ã‚ã‚‹ãƒãƒ¼ã‚¸ãƒ§ãƒ³â€”â€”é ã‘å…¥ã‚Œã¨å¼•ãå‡ºã—ãŒç›´åˆ—åŒ–ã•ã‚Œã¦ã„ã‚‹â€”â€”ã‚’ç¤ºã™ã€‚
</p>


<p class="lisp"><a name="%_idx_3614"></a><a name="%_idx_3616"></a>(define (make-account balance)
  (define (withdraw amount)
    (if (&gt;= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        &quot;Insufficient funds&quot;))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((protected (make-serializer)))
    (define (dispatch m)
      (cond ((eq? m 'withdraw) (protected withdraw))
            ((eq? m 'deposit) (protected deposit))
            ((eq? m 'balance) balance)
            (else (error &quot;Unknown request -- MAKE-ACCOUNT&quot;
                         m))))
    dispatch))
</p>


<p class="orig" lang="en">
With this implementation, two processes cannot be withdrawing from or
depositing into a single account concurrently.  This eliminates the source
of the error illustrated in figure <a href="#%_fig_3.29">3.29</a>, where Peter
changes the account balance between the times when Paul accesses the
balance to compute the new value and when Paul actually performs the
assignment.  On the other hand, each account has its own serializer,
so that deposits and withdrawals for different accounts can proceed
concurrently.</p>

<p class="trans" lang="ja">
ã“ã®å®Ÿè£…ã‚’ä½¿ã†ã¨ã€äºŒã¤ã®ãƒ—ãƒ­ã‚»ã‚¹ãŒä¸¦è¡Œã«ã€å˜ä¸€ã®å£åº§ã‹ã‚‰å¼•ãå‡ºã—ã€ã¾ãŸã¯ã€ãã“ã¸ã®é ã‘å…¥ã‚Œã‚’ã—ã¦ã„ã‚‹æœ€ä¸­ã ã€ã¨ã„ã†ã“ã¨ã¯ã€ã‚ã‚Šå¾—ãªã„ã€‚
ã“ã‚Œã¯ã€å›³<a href="#%_fig_3.29">3.29</a> â€”â€”ãƒãƒ¼ãƒ«ãŒæ–°ãŸãªå€¤ã‚’è¨ˆç®—ã™ã‚‹ãŸã‚ã«æ®‹é«˜ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹æ™‚ç‚¹ã¨ã€ãƒãƒ¼ãƒ«ãŒå®Ÿéš›ã«<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã‚’å®Ÿè¡Œã™ã‚‹æ™‚ç‚¹ã¨ã®é–“ã«ã€ãƒ”ãƒ¼ã‚¿ãƒ¼ãŒå£åº§æ®‹é«˜ã‚’å¤‰æ›´ã™ã‚‹â€”â€”ã«ç¤ºã•ã‚Œã‚‹ã‚¨ãƒ©ãƒ¼ã®ç™ºç”Ÿæºã‚’æ’é™¤ã™ã‚‹ã€‚
ä»–æ–¹ã€ãã‚Œãã‚Œã®å£åº§ã«ã¯ã€ãã®å£åº§è‡ªèº«ã®ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¶ãŒã‚ã£ã¦ã€ãã®ãŸã‚ã€ç•°ãªã‚‹å£åº§ã«å¯¾ã™ã‚‹é ã‘å…¥ã‚Œã¨å¼•ãå‡ºã—ã¯ã€ä¸¦è¡Œã«é€²è¡Œã—å¾—ã‚‹ã€‚
</p>


<p class="orig" lang="en"><a name="%_thm_3.39"></a>
<b>Exercise 3.39.</b>  Which of the five possibilities in the parallel execution shown above
remain if we instead serialize execution as follows:</p>

<p class="trans" lang="ja"><b>ç·´ç¿’å•é¡Œ3.39.</b> ä»£ã‚ã‚Šã«ã€å®Ÿè¡Œã‚’ä»¥ä¸‹ã®ã‚ˆã†ã«ç›´åˆ—åŒ–ã—ãŸã¨ã—ãŸã‚‰ã€ä¸Šã«ç¤ºã—ãŸä¸¦åˆ—å®Ÿè¡Œã«ãŠã‘ã‚‹äº”ã¤ã®å¯èƒ½æ€§ã®ã†ã¡ã®ã©ã‚ŒãŒæ®‹ã‚‹ã ã‚ã†ã‹?
</p>


<p class="lisp">(define x 10)

(define s (make-serializer))

(parallel-execute (lambda () (set! x ((s (lambda () (* x x))))))
                  (s (lambda () (set! x (+ x 1)))))
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.40"></a>
<b>Exercise 3.40.</b>  Give all possible values of <tt>x</tt> that can result from executing</p>

<p class="trans" lang="ja"><b>ç·´ç¿’å•é¡Œ3.40.</b> ä»¥ä¸‹ã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ã«èµ·å› ã—ã¦ç”Ÿã˜å¾—ã‚‹ã€<tt>x</tt> ã®ã™ã¹ã¦ã®å¯èƒ½ãªå€¤ã‚’æŒ™ã’ã‚ˆã€‚
</p>

<p class="lisp">(define x 10)

(parallel-execute (lambda () (set! x (* x x)))
                  (lambda () (set! x (* x x x))))
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
Which of these possibilities remain if we instead use serialized
procedures:</p>

<p class="trans" lang="ja">
ä»£ã‚ã‚Šã«ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ç›´åˆ—åŒ–ã—ãŸæ‰‹ç¶šãã‚’ä½¿ã£ãŸã¨ã—ãŸã‚‰ã€ã“ã‚Œã‚‰ã®å¯èƒ½æ€§ã®ã†ã¡ã®ã„ãšã‚ŒãŒæ®‹ã‚‹ã ã‚ã†?
</p>


<p class="lisp">(define x 10)

(define s (make-serializer))

(parallel-execute (s (lambda () (set! x (* x x))))
                  (s (lambda () (set! x (* x x x)))))
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.41"></a>
<b>Exercise 3.41.</b>  Ben Bitdiddle worries that it would be better to implement the bank
account as follows (where the commented line has been changed):</p>

<p class="trans" lang="ja"><b>ç·´ç¿’å•é¡Œ3.41.</b> ãƒ™ãƒ³ãƒ»ãƒ“ãƒƒãƒˆãƒ‡ã‚£ãƒ‰ãƒ«ã¯ã€éŠ€è¡Œå£åº§ã‚’ä»¥ä¸‹ (ã‚³ãƒ¡ãƒ³ãƒˆã•ã‚ŒãŸè¡ŒãŒå¤‰æ›´ã•ã‚Œã¦ã„ã‚‹) ã®ã‚ˆã†ã«å®Ÿè£…ã™ã‚‹æ–¹ãŒã„ã„ã®ã§ã¯ãªã„ã‹ã€ã¨æ‚©ã‚“ã§ã„ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_3618"></a>(define (make-account balance)
  (define (withdraw amount)
    (if (&gt;= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        &quot;Insufficient funds&quot;))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  <em>;; continued on next page</em>

  (let ((protected (make-serializer)))
    (define (dispatch m)
      (cond ((eq? m 'withdraw) (protected withdraw))
            ((eq? m 'deposit) (protected deposit))
            ((eq? m 'balance)
             ((protected (lambda () balance)))) <em>; serialized</em>
            (else (error &quot;Unknown request -- MAKE-ACCOUNT&quot;
                         m))))
    dispatch))
</p>


<p class="orig" lang="en">
because allowing unserialized access to the bank balance can result in
anomalous behavior.  Do you agree?  Is there any scenario that
demonstrates Ben's concern?
</p>

<p class="trans" lang="ja">
ãªãœãªã‚‰ã€éŠ€è¡Œæ®‹é«˜ã¸ã®ã€ç›´åˆ—åŒ–ã•ã‚Œã¦ã„ãªã„ã‚¢ã‚¯ã‚»ã‚¹ã‚’è¨±ã™ã“ã¨ã¯ã€ç•°å¸¸ãªæŒ¯ã‚‹èˆã„ã€ã¨ã„ã†çµæœã«ãªã‚Šã‹ã­ãªã„ã‹ã‚‰ã§ã‚ã‚‹ã€‚
ãƒ™ãƒ³ã®æ‡¸å¿µã‚’ç«‹è¨¼ã™ã‚‹ã‚ˆã†ãªã‚·ãƒŠãƒªã‚ªãŒä½•ã‹ã‚ã‚‹ã ã‚ã†ã‹?
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.42"></a>
<b>Exercise 3.42.</b>  Ben Bitdiddle suggests that it's a waste of time to create a new
serialized procedure in response to every <tt>withdraw</tt> and <tt>deposit</tt> message.  He says that <tt>make-account</tt> could be changed so
that the calls to <tt>protected</tt> are done outside the <tt>dispatch</tt>
procedure.  That is, an account would return the same serialized
procedure (which was created at the same time as the account) each time
it is asked for a withdrawal procedure.
</p>


<p class="trans" lang="ja"><b>ç·´ç¿’å•é¡Œ3.42.</b> ã™ã¹ã¦ã® <tt>withdraw</tt> ã¨ <tt>deposit</tt> ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã”ã¨ã«ã€ãã‚Œã«å¿œã˜ã¦æ–°ãŸãªç›´åˆ—åŒ–æ‰‹ç¶šãã‚’ä½œæˆã™ã‚‹ã®ã¯ã€æ™‚é–“ã®ç„¡é§„ã§ã‚ã‚‹ã€ã¨ãƒ™ãƒ³ãƒ»ãƒ“ãƒƒãƒˆãƒ‡ã‚£ãƒ‰ãƒ«ã¯ã»ã®ã‚ã‹ã™ã€‚
å½¼ã¯ã€<tt>protected</tt> ã¸ã®å‘¼ã³å‡ºã—ãŒ <tt>dispatch</tt> ã¨ã„ã†æ‰‹ç¶šãã®å¤–å´ã§è¡Œã‚ã‚Œã‚‹ã‚ˆã†ã«ã€<tt>make-account</tt> ã‚’å¤‰æ›´ã§ãã‚‹ã ã‚ã†ã€ã¨è¨€ã†ã€‚
ã¤ã¾ã‚Šã€å£åº§ã¯ã€å¼•ãå‡ºã—ã®æ‰‹ç¶šãã‚’æ±‚ã‚ã‚‰ã‚Œã‚‹ãŸã³ã«ã€(ãã®å£åº§ã¨åŒæ™‚ã«ä½œæˆã•ã‚ŒãŸ) åŒã˜ç›´åˆ—åŒ–æ‰‹ç¶šãã‚’ã€è¿”ã™ã ã‚ã†ã€‚
</p>

<p class="lisp"><a name="%_idx_3620"></a>(define (make-account balance)
  (define (withdraw amount)
    (if (&gt;= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        &quot;Insufficient funds&quot;))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((protected (make-serializer)))
    (let ((protected-withdraw (protected withdraw))
          (protected-deposit (protected deposit)))
      (define (dispatch m)
        (cond ((eq? m 'withdraw) protected-withdraw)
              ((eq? m 'deposit) protected-deposit)
              ((eq? m 'balance) balance)
              (else (error &quot;Unknown request -- MAKE-ACCOUNT&quot;
                           m))))
      dispatch)))
</p>


<p class="orig" lang="en">
Is this a safe change to make?  In particular, is there any difference in
what concurrency is allowed by these two versions of <tt>make-account</tt> ?
</p>

<p class="trans" lang="ja">
ã“ã‚Œã¯ã€è¡Œã£ã¦ã‚‚å®‰å…¨ãªå¤‰æ›´ã‹?
ç‰¹ã«ã€<tt>make-account</tt> ã®ã“ã‚Œã‚‰ã®äºŒã¤ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«ã‚ˆã‚Šã€ã©ã®ã‚ˆã†ãªä¸¦è¡Œæ€§ãŒè¨±ã•ã‚Œã‚‹ã®ã‹ã€ã¨ã„ã†ç‚¹ã«ãŠã„ã¦ã€ä½•ã‹é•ã„ãŒã‚ã‚‹ã‹?
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_Temp_420"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_420">Complexity of using multiple shared resources</a></h4>
<h4 class="trans" lang="ja">å…±æœ‰ã•ã‚ŒãŸè¤‡æ•°ã®è³‡æºã‚’ä½¿ã†ã“ã¨ã®è¤‡é›‘æ€§</h4>


<p class="orig" lang="en">
<a name="%_idx_3622"></a><a name="%_idx_3624"></a>
Serializers provide a powerful abstraction that helps isolate the
complexities of concurrent programs so that they can be dealt with
carefully and (hopefully) correctly.  However, while using serializers
is relatively straightforward when there is only a single shared
resource (such as a single bank account), concurrent programming can
be treacherously difficult when there are multiple shared resources.</p>

<p class="trans" lang="ja">ä¸¦è¡Œãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®è¤‡é›‘æ€§ã‚’ã€ãã‚Œã‚‰ã‚’æ³¨æ„æ·±ãã€ã‹ã¤ (é¡˜ã‚ãã°) æ­£ã—ãæ‰±ãˆã‚‹ã‚ˆã†ã«éš”é›¢ã™ã‚‹ã®ã‚’åŠ©ã‘ã¦ãã‚Œã‚‹ã€å¼·åŠ›ãªæŠ½è±¡åŒ–ã‚’ã€ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¶ã¯æä¾›ã™ã‚‹ã€‚
ã—ã‹ã—ã€(ãŸã¨ãˆã°ä¸€ã¤ã®éŠ€è¡Œå£åº§ãªã©) ä¸€ã¤ã—ã‹å…±æœ‰è³‡æºãŒãªã„ã¨ãã«ã¯ã€ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¶ã‚’ä½¿ã†ã“ã¨ã¯æ¯”è¼ƒçš„ã‚ã‹ã‚Šã‚„ã™ã„ã®ã ãŒã€è¤‡æ•°ã®å…±æœ‰è³‡æºãŒã‚ã‚‹ã¨ãã¯ã€ä¸¦è¡Œãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã¯ã€æ²¹æ–­ã§ããªã„ã»ã©é›£ã—ããªã‚Šå¾—ã‚‹ã€‚
</p>

<p class="orig" lang="en">
To illustrate one of the difficulties that can arise, suppose we wish to swap
the balances in two bank accounts.  We access each account to find the
balance, compute the difference between the balances, withdraw this
difference from one account, and deposit it in the other account.  We
could implement this as follows:<a name="call_footnote_Temp_421" href="#footnote_Temp_421"><sup><small>41</small></sup></a></p>

<p class="trans" lang="ja">
ç”Ÿã˜å¾—ã‚‹å›°é›£ã®ã†ã¡ã®ä¸€ã¤ã‚’ä¾‹ç¤ºã™ã‚‹ãŸã‚ã«ã€äºŒã¤ã®éŠ€è¡Œå£åº§ã®æ®‹é«˜ã‚’å…¥ã‚Œæ›¿ãˆãŸã„ã®ã ã¨ã—ã‚ˆã†ã€‚
ãã‚Œãã‚Œã®å£åº§ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦æ®‹é«˜ã‚’çŸ¥ã‚Šã€æ®‹é«˜åŒå£«ã®å·®ã‚’è¨ˆç®—ã—ã€ã“ã®å·®é¡ã‚’ä¸€æ–¹ã®å£åº§ã‹ã‚‰å¼•ãå‡ºã—ã€ãã‚Œã‚’ä»–æ–¹ã®å£åº§ã«é ã‘å…¥ã‚Œã‚‹ã€‚
ã“ã‚Œã‚’ã€ä»¥ä¸‹ã®ã‚ˆã†ã«å®Ÿè£…ã™ã‚‹ã“ã¨ãŒã§ãã‚‹<a href="#footnote_Temp_421"><sup><small>41</small></sup></a>ã€‚
</p>

<p class="lisp"><a name="%_idx_3626"></a><a name="%_idx_3628"></a>(define (exchange account1 account2)
  (let ((difference (- (account1 'balance)
                       (account2 'balance))))
    ((account1 'withdraw) difference)
    ((account2 'deposit) difference)))
</p>

<p class="orig" lang="en">
This procedure works well when only a single process is trying to do
the exchange.  Suppose, however, that Peter and Paul both have access
to accounts <em>a</em>1, <em>a</em>2, and <em>a</em>3, and that
Peter exchanges <em>a</em>1 and
<em>a</em>2 while Paul concurrently exchanges <em>a</em>1 and <em>a</em>3.
Even with account deposits and withdrawals
serialized for individual accounts (as in the <tt>make-account</tt>
procedure shown above in this section), <tt>exchange</tt> can still
produce incorrect results.  For example, Peter might compute the
difference in the balances for <em>a</em>1 and <em>a</em>2, but then Paul
might change the balance in <em>a</em>1 before Peter is able to complete
the exchange.<a name="call_footnote_Temp_422" href="#footnote_Temp_422"><sup><small>42</small></sup></a>
For correct behavior, we must arrange for the <tt>exchange</tt> procedure
to lock out any other concurrent accesses to the accounts during the
entire time of the exchange.</p>

<p class="trans" lang="ja">
ä¸€ã¤ã®ãƒ—ãƒ­ã‚»ã‚¹ã®ã¿ãŒã“ã®äº¤æ›ã‚’ã—ã‚ˆã†ã¨è©¦ã¿ã¦ã„ã‚‹å ´åˆã«ã¯ã€ã“ã®æ‰‹ç¶šãã¯ã€ã†ã¾ãå‹•ãã€‚
ã—ã‹ã—ã€ãƒ”ãƒ¼ã‚¿ãƒ¼ã¨ãƒãƒ¼ãƒ«ã®äºŒäººã¨ã‚‚ã€<em class="en">a</em>1 ã¨ <em class="en">a</em>2 ã¨ <em class="en">a</em>3 ã¨ã„ã†å£åº§ã®åˆ©ç”¨æ¨©ãŒã‚ã‚Šã€ã‹ã¤ã€ãƒãƒ¼ãƒ«ãŒä¸¦è¡Œã« <em class="en">a</em>1 ã¨ <em class="en">a</em>3 ã‚’äº¤æ›ã—ã¦ã„ã‚‹é–“ã«ãƒ”ãƒ¼ã‚¿ãƒ¼ãŒ <em class="en">a</em>1 ã¨ <em class="en">a</em>2 ã‚’äº¤æ›ã™ã‚‹ã®ã ã€ã¨ä»®å®šã—ã‚ˆã†ã€‚
<!--ã—ã‹ã—ã€ãƒ”ãƒ¼ã‚¿ãƒ¼ã¨ãƒãƒ¼ãƒ«ã®äºŒäººã¨ã‚‚ã€<em class="en">a</em>1 ã¨ <em class="en">a</em>2 ã¨ <em class="en">a</em>3 ã¨ã„ã†å£åº§ã®åˆ©ç”¨æ¨©ãŒã‚ã‚‹ã‚‚ã®ã¨ä»®å®šã—ã€ã‹ã¤ã€ãƒ”ãƒ¼ã‚¿ãƒ¼ãŒ <em class="en">a</em>1 ã¨ <em class="en">a</em>2 ã‚’äº¤æ›ã—ã€ãã®é–“ã«ãƒãƒ¼ãƒ«ãŒä¸¦è¡Œã« <em class="en">a</em>1 ã¨ <em class="en">a</em>3 ã‚’äº¤æ›ã—ã¦ã„ã‚‹ã‚‚ã®ã¨ä»®å®šã—ã‚ˆã†ã€‚--><!--<span class="note"> (ã¨ã€è¨³ã—ãŸæ–¹ãŒã€ã‚ã‹ã‚Šã‚„ã™ã„ã¨ã„ãˆã°ã‚ã‹ã‚Šã‚„ã™ã„ã®ã ãŒã€‚)</span>-->
ãŸã¨ãˆå£åº§ã®é ã‘å…¥ã‚Œã¨å¼•ãå‡ºã—ãŒã€å€‹ã€…ã®å£åº§ã«ã¤ã„ã¦ç›´åˆ—åŒ–ã•ã‚Œã¦ã„ãŸã¨ã—ã¦ã‚‚ (ãŸã¨ãˆã°æœ¬ç¯€ã§ä¸Šã«ç¤ºã—ãŸ <tt>make-account</tt> ã¨ã„ã†æ‰‹ç¶šãã«ãŠã‘ã‚‹ã‚ˆã†ã«)ã€ãã‚Œã§ã‚‚ <tt>exchange</tt> ã¯ã€èª¤ã£ãŸçµæœã‚’ç”Ÿã¿å‡ºã™å¯èƒ½æ€§ãŒã‚ã‚‹ã€‚
ãŸã¨ãˆã°ã€ãƒ”ãƒ¼ã‚¿ãƒ¼ã¯ã€<em class="en">a</em>1 ã¨ <em class="en">a</em>2 ã®æ®‹é«˜ã®å·®ã‚’è¨ˆç®—ã™ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ãŒã€ãã®å¾Œã€ãƒ”ãƒ¼ã‚¿ãƒ¼ãŒäº¤æ›ã‚’å®Œäº†ã§ãã‚‹ã‚ˆã‚Šã‚‚å‰ã«ã€ãƒãƒ¼ãƒ«ãŒ <em class="en">a</em>1 ã®æ®‹é«˜ã‚’å¤‰ãˆã‚‹ã‹ã‚‚ã—ã‚Œãªã„<a href="#footnote_Temp_422"><sup><small>42</small></sup></a>ã€‚
æ­£ã—ã„æŒ¯ã‚‹èˆã„ã®ãŸã‚ã«ã¯ã€<tt>exchange</tt> ã®æ‰‹ç¶šããŒã€ãã®äº¤æ›ã®æ™‚é–“ã®é–“ãšã£ã¨ã€ãã®å£åº§ã¸ã®ã„ã‹ãªã‚‹ä»–ã®ä¸¦è¡Œãªã‚¢ã‚¯ã‚»ã‚¹ã‚’ã‚‚æ’é™¤ã§ãã‚‹ã‚ˆã†ã«ã€ç§ãŸã¡ãŒæ‰‹ç­ˆã‚’æ•´ãˆã¦ãŠã‹ãªãã¦ã¯ãªã‚‰ãªã„ã®ã ã€‚
</p>

<p class="orig" lang="en">
One way we can accomplish this is by using both accounts' serializers
to serialize the entire <tt>exchange</tt> procedure.
To do this, we will arrange for access to an account's serializer.
Note that we are deliberately
breaking the modularity of the bank-account object by exposing the
serializer.  The following version of <tt>make-account</tt> is identical
to the original version given in
section <a href="20_sec3_1.html#%_sec_3.1.1">3.1.1</a>, except that a serializer is
provided to protect the balance variable, and the serializer is
exported via message passing:</p>

<p class="trans" lang="ja">
ã“ã‚Œã‚’é”æˆã§ãã‚‹ã‚ˆã†ãªä¸€ã¤ã®æ–¹æ³•ã¯ã€ä¸¡æ–¹ã®å£åº§ã®ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¶ã‚’ä½¿ã†ã“ã¨ã«ã‚ˆã‚Šã€<tt>exchange</tt> ã®æ‰‹ç¶šãå…¨ä½“ã‚’ç›´åˆ—åŒ–ã™ã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚
ã“ã‚Œã‚’è¡Œã†ãŸã‚ã«ã€å£åº§ã®ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¶ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã‚’ç”¨æ„ã—ã‚ˆã†ã€‚
ç§ãŸã¡ãŒã€ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¶ã‚’ã‚€ãå‡ºã—ã«ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€éŠ€è¡Œå£åº§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ€§ã‚’æ…é‡ã«ç ´ã£ã¦ã„ã‚‹ã¨ã“ã‚ãªã®ã ã€ã¨ã„ã†ã“ã¨ã«æ³¨æ„ã›ã‚ˆã€‚
<tt>make-account</tt> ã®ã€ä»¥ä¸‹ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯ã€ <a href="20_sec3_1.html#%_sec_3.1.1">3.1.1</a>ç¯€ã«ç¤ºã—ãŸå…ƒã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¨åŒä¸€ã§ã‚ã‚‹â€”â€”æ®‹é«˜å¤‰æ•°ã‚’ä¿è­·ã™ã‚‹ãŸã‚ã«ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¶ãŒä¸ãˆã‚‰ã‚Œã¦ãŠã‚Šã€ãã®ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¶ãŒãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ¸¡ã—ã«ã‚ˆã£ã¦<ruby><rb>ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã•ã‚Œã¦</rb><rp> (</rp><rt>ãã¨ã«ã ã•ã‚Œã¦</rt><rp>) </rp></ruby>ã„ã‚‹ã€ã¨ã„ã†ç‚¹ã‚’é™¤ã„ã¦ã€‚
</p>


<p class="lisp"><a name="%_idx_3630"></a>(define (make-account-and-serializer balance)
  (define (withdraw amount)
    (if (&gt;= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        &quot;Insufficient funds&quot;))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((balance-serializer (make-serializer)))
    (define (dispatch m)
      (cond ((eq? m 'withdraw) withdraw)
            ((eq? m 'deposit) deposit)
            ((eq? m 'balance) balance)
            ((eq? m 'serializer) balance-serializer)
            (else (error &quot;Unknown request -- MAKE-ACCOUNT&quot;
                         m))))
    dispatch))
</p>



<p class="orig" lang="en">
We can use this to do serialized deposits and withdrawals.  However,
unlike our earlier serialized account, it is now the responsibility of
each user of bank-account objects to explicitly manage the
serialization, for example as follows:<a name="call_footnote_Temp_423" href="#footnote_Temp_423"><sup><small>43</small></sup></a></p>

<p class="trans" lang="ja">
ç›´åˆ—åŒ–ã•ã‚ŒãŸé ã‘å…¥ã‚Œã¨å¼•ãå‡ºã—ã‚’å®Ÿè¡Œã™ã‚‹ãŸã‚ã«ã€ã“ã‚Œã‚’ç”¨ã„ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
ã—ã‹ã—ã€å…ˆã®ç›´åˆ—åŒ–å£åº§ã¨ã¯é•ã£ã¦ã€ä»Šã‚„ã€ç›´åˆ—åŒ–ã‚’æ˜ç¤ºçš„ã«ç®¡ç†ã™ã‚‹ã“ã¨ã¯ã€ãŸã¨ãˆã°ä»¥ä¸‹ã®ã‚ˆã†ã«ã€éŠ€è¡Œå£åº§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å„ãƒ¦ãƒ¼ã‚¶ã®è²¬ä»»ãªã®ã <a href="#footnote_Temp_423"><sup><small>43</small></sup></a>ã€‚
</p>

<p class="lisp"><a name="%_idx_3632"></a>(define (deposit account amount)
  (let ((s (account 'serializer))
        (d (account 'deposit)))
    ((s d) amount)))
</p>


<p class="orig" lang="en">
Exporting the serializer in this way gives us enough flexibility to
implement a serialized exchange program.  We simply
serialize the original
<tt>exchange</tt> procedure with the serializers for both accounts:</p>


<p class="trans" lang="ja">
ã“ã®ã‚„ã‚Šæ–¹ã§ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¶ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ã“ã¨ã¯ã€ç§ãŸã¡ã«ã€ç›´åˆ—åŒ–ã•ã‚ŒãŸå–å¼•ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’å®Ÿè£…ã™ã‚‹ã®ã«ååˆ†ãªæŸ”è»Ÿæ€§ã‚’ä¸ãˆã¦ãã‚Œã‚‹ã€‚
ç§ãŸã¡ã¯å˜ã«ã€åŒæ–¹ã®å£åº§ç”¨ã®ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¶ã‚’ä½¿ã£ã¦ã€å…ƒã® <tt>exchange</tt> ã®æ‰‹ç¶šãã‚’ç›´åˆ—åŒ–ã™ã‚‹ã ã‘ã ã€‚
</p>


<p class="lisp"><a name="%_idx_3634"></a>(define (serialized-exchange account1 account2)
  (let ((serializer1 (account1 'serializer))
        (serializer2 (account2 'serializer)))
    ((serializer1 (serializer2 exchange))
     account1
     account2)))
</p>


<p class="orig" lang="en"><a name="%_thm_3.43"></a>
<b>Exercise 3.43.</b>  Suppose that the balances in three accounts start out as $10, $20,
and $30, and that multiple processes run, exchanging the balances in
the accounts.  Argue that if the processes are run sequentially,
after any number of concurrent exchanges, the account balances should be 
$10, $20, and $30 in some order.
Draw a timing diagram like the one in figure <a href="#%_fig_3.29">3.29</a> to
show how this condition can be violated if the exchanges are
implemented using the first version of the account-exchange program in
this section.  On the other hand, argue that even with this <tt>exchange</tt> program, the sum of the balances in the accounts will be
preserved.  Draw a timing diagram to show how even this condition would
be violated if we did not serialize the transactions
on individual accounts.
</p>

<p class="trans" lang="ja"><b>ç·´ç¿’å•é¡Œ3.43.</b> ä¸‰ã¤ã®å£åº§ã®æ®‹é«˜ãŒ10ãƒ‰ãƒ«ã€20ãƒ‰ãƒ«ã€30ãƒ‰ãƒ«ã‹ã‚‰å§‹ã¾ã‚‹ã‚‚ã®ã¨ã—ã€è¤‡æ•°ã®ãƒ—ãƒ­ã‚»ã‚¹ãŒå®Ÿè¡Œã•ã‚Œã¦ã€ã“ã‚Œã‚‰ã®å£åº§ã®æ®‹é«˜åŒå£«ã‚’äº¤æ›ã™ã‚‹ã®ã ã¨ã—ã‚ˆã†ã€‚
ã‚‚ã—ãƒ—ãƒ­ã‚»ã‚¹ãŒé€æ¬¡çš„ã«å®Ÿè¡Œã•ã‚ŒãŸã‚‰ã€ä¸¦è¡Œãªäº¤æ›ã‚’ä½•å›è¡Œã£ãŸå¾Œã§ã‚‚ã€å£åº§æ®‹é«˜ã¯ã€ä½•ã‚‰ã‹ã®é †åºã§ã€10ãƒ‰ãƒ«ã€20ãƒ‰ãƒ«ã€30ãƒ‰ãƒ«ã¨ãªã‚‹ã¹ãã§ã‚ã‚‹ã€ã¨ã„ã†ã“ã¨ã‚’è«–ãœã‚ˆã€‚
ã‚‚ã—æœ¬ç¯€ã«ãŠã‘ã‚‹æœ€åˆã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®å£åº§å–å¼•ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ä½¿ã£ã¦äº¤æ›ãŒå®Ÿè£…ã•ã‚Œã¦ã„ãŸã‚‰ã€ã“ã®æ¡ä»¶ãŒã©ã®ã‚ˆã†ã«ã—ã¦ç ´ã‚‰ã‚Œå¾—ã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’ç¤ºã™ãŸã‚ã«ã€å›³<a href="#%_fig_3.29">3.29</a>ã®ã‚ˆã†ãªã‚¿ã‚¤ãƒŸãƒ³ã‚°å›³ã‚’æã‘ã€‚
ä¸€æ–¹ã€ã“ã® <tt>exchange</tt> ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ä½¿ã£ã¦ã„ã¦ã•ãˆã€å£åº§æ®‹é«˜ã®å’Œã¯ä¿ãŸã‚Œã‚‹ã ã‚ã†ã€ã¨ã„ã†ã“ã¨ã‚’è«–ãœã‚ˆã€‚
ã‚‚ã—å€‹ã€…ã®å£åº§ã«å¯¾ã™ã‚‹å–å¼•ã‚’ç›´åˆ—åŒ–ã—ãªã‹ã£ãŸã¨ã—ãŸã‚‰ã€ã©ã®ã‚ˆã†ã«ã—ã¦ã“ã®æ¡ä»¶ã§ã•ãˆã‚‚ç ´ã‚‰ã‚Œã¦ã—ã¾ã†ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’ç¤ºã™ãŸã‚ã«ã€ã‚¿ã‚¤ãƒŸãƒ³ã‚°å›³ã‚’æã‘ã€‚
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.44"></a>
<b>Exercise 3.44.</b>  <a name="%_idx_3636"></a>Consider the problem of transferring an amount from one account to
another.  Ben Bitdiddle claims that this can be accomplished with the
following procedure, even if there are multiple people concurrently
transferring money among multiple accounts, using any account
mechanism that serializes deposit and withdrawal transactions, for
example, the version of <tt>make-account</tt> in the text above.</p>

<p class="trans" lang="ja"><b>ç·´ç¿’å•é¡Œ3.44.</b> ä¸€ã¤ã®å£åº§ã‹ã‚‰åˆ¥ã®å£åº§ã¸ã€ã‚ã‚‹é‡‘é¡ã‚’é€ã‚‹ã¨ã„ã†å•é¡Œã‚’è€ƒãˆã‚ˆã†ã€‚
ãƒ™ãƒ³ãƒ»ãƒ“ãƒƒãƒˆãƒ‡ã‚£ãƒ‰ãƒ«ã¯ã€ã“ã‚Œã¯ä»¥ä¸‹ã®æ‰‹ç¶šãã«ã‚ˆã£ã¦é”æˆã§ãã‚‹ã€ã¨ä¸»å¼µã™ã‚‹â€”â€”ãŸã¨ãˆã°ã€ä¸Šè¿°ã®æœ¬åˆ†ä¸­ã«ã‚ã‚‹ <tt>make-account</tt> ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãªã©ã€é ã‘å…¥ã‚Œã¨å¼•ãå‡ºã—ã®å–å¼•ã‚’ç›´åˆ—åŒ–ã™ã‚‹ã‚ˆã†ãªä»»æ„ã®å£åº§ã®ä»•çµ„ã¿ã‚’ä½¿ã£ã¦ã„ã‚Œã°ã€è¤‡æ•°ã®äººãŸã¡ãŒä¸¦è¡Œã«è¤‡æ•°ã®å£åº§é–“ã§é€é‡‘ã—ã¦ã„ã¦ã•ãˆã‚‚ã€é”æˆã§ãã‚‹ã®ã ã€ã¨ã€‚
</p>


<p class="lisp">(define (transfer from-account to-account amount)
  ((from-account 'withdraw) amount)
  ((to-account 'deposit) amount))
</p>


<p class="orig" lang="en">
Louis Reasoner claims that there is a problem here, and that we need
to use a more sophisticated method, such as the one required for
dealing with the exchange problem.  Is Louis right?  If not, what is
the essential difference between the transfer problem and the exchange
problem?  (You should assume that the balance in <tt>from-account</tt>
is at least <tt>amount</tt>.)
</p>

<p class="trans" lang="ja">
ãƒ«ã‚¤ã‚¹ãƒ»ãƒªãƒ¼ã‚ºãƒŠã¯ã€ã“ã“ã«ã¯å•é¡ŒãŒã‚ã‚‹ã€ã¨ä¸»å¼µã—ã€ã•ã‚‰ã«ã€ã‚ˆã‚Šæ´—ç·´ã•ã‚ŒãŸæ–¹æ³•â€”â€”ãŸã¨ãˆã°ã€äº¤æ›ã®å•é¡Œã‚’æ‰±ã†ã®ã«å¿…è¦ã¨ã•ã‚ŒãŸã‚‚ã®ãªã©â€”â€”ã‚’ä½¿ã†å¿…è¦ãŒã‚ã‚‹ã€ã¨ä¸»å¼µã™ã‚‹ã€‚
ãƒ«ã‚¤ã‚¹ã¯æ­£ã—ã„ã‹?
ã‚‚ã—æ­£ã—ããªã‘ã‚Œã°ã€é€é‡‘ã®å•é¡Œã¨äº¤æ›ã®å•é¡Œã®é–“ã®æœ¬è³ªçš„ãªå·®ç•°ã¨ã¯ä½•ã ã‚ã†?
(<tt>from-account</tt> ã®æ®‹é«˜ã¯å°‘ãªãã¨ã‚‚ <tt>amount</tt> ã§ã‚ã‚‹ã€ã¨æƒ³å®šã™ã¹ãã§ã‚ã‚‹ã€‚)
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.45"></a>
<b>Exercise 3.45.</b>  Louis Reasoner thinks our bank-account system is unnecessarily complex and
error-prone now that deposits and withdrawals aren't automatically serialized.
He suggests that <tt>make-account-and-serializer</tt> should have
exported the serializer (for use by such procedures as
<tt>serialized-exchange</tt>) in addition to (rather than instead of)
using it to serialize accounts and deposits as <tt>make-account</tt> did.
He proposes to redefine accounts as follows:</p>

<p class="trans" lang="ja"><b>ç·´ç¿’å•é¡Œ3.45.</b> ä»Šã‚„é ã‘å…¥ã‚Œã¨å¼•ãå‡ºã—ãŒè‡ªå‹•çš„ã«ç›´åˆ—åŒ–ã•ã‚Œã¦ã¯ã„ãªã„ãŸã‚ã€ç§ãŸã¡ã®éŠ€è¡Œå£åº§ã‚·ã‚¹ãƒ†ãƒ ã¯ã€ä¸å¿…è¦ãªã»ã©ã«è¤‡é›‘ã§ã‚ã‚Šã‚¨ãƒ©ãƒ¼ã‚’æ‹›ãã‚„ã™ã„ã€ã¨ãƒ«ã‚¤ã‚¹ãƒ»ãƒªãƒ¼ã‚ºãƒŠã¯è€ƒãˆã¦ã„ã‚‹ã€‚
å½¼ã¯ã€<tt>make-account-and-serializer</tt> ãŒã€<tt>make-account</tt> ãŒã—ãŸã®ã¨åŒæ§˜ã«å£åº§ã‚„é ã‘å…¥ã‚Œã‚’ç›´åˆ—åŒ–ã™ã‚‹ãŸã‚ã«ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¶ã‚’ä½¿ã†ã“ã¨ (ã«ä»£ãˆã¦ã€ã¨è¨€ã†ã‚ˆã‚Šã‚‚ã‚€ã—ã‚ã€ãã†ã—ãŸä½¿ç”¨) ã«åŠ ãˆã¦ã€(<tt>serialized-exchange</tt> ãªã©ã®æ‰‹ç¶šãã«ã‚ˆã‚‹ä½¿ç”¨ã®ãŸã‚ã«) ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¶ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã¹ãã ã£ãŸã€ã¨ç¤ºå”†ã™ã‚‹ã€‚
å½¼ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«å£åº§ã‚’å†å®šç¾©ã™ã‚‹ã“ã¨ã‚’ææ¡ˆã™ã‚‹ã€‚
</p>

<p class="lisp">(define (make-account-and-serializer balance)
  (define (withdraw amount)
    (if (&gt;= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        &quot;Insufficient funds&quot;))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((balance-serializer (make-serializer)))
    (define (dispatch m)
      (cond ((eq? m 'withdraw) (balance-serializer withdraw))
            ((eq? m 'deposit) (balance-serializer deposit))
            ((eq? m 'balance) balance)
            ((eq? m 'serializer) balance-serializer)
            (else (error &quot;Unknown request -- MAKE-ACCOUNT&quot;
                         m))))
    dispatch))
</p>


<p class="orig" lang="en">
Then deposits are handled as with the original <tt>make-account</tt>:
</p>

<p class="trans" lang="ja">
ã™ã‚‹ã¨ã€é ã‘å…¥ã‚Œã¯ã€å…ƒã® <tt>make-account</tt> ã‚’ä½¿ã£ãŸã¨ãã¨åŒæ§˜ã«æ‰±ã‚ã‚Œã‚‹ã€‚
</p>

<p class="lisp">(define (deposit account amount)
 ((account 'deposit) amount))
</p>


<p class="orig" lang="en">
Explain what is wrong with Louis's reasoning.  In particular,
consider what happens when <tt>serialized-exchange</tt> is called.
</p>

<p class="trans" lang="ja">
ãƒ«ã‚¤ã‚¹ã®æ¨è«–ã®ä½•ãŒé–“é•ã£ã¦ã„ã‚‹ã®ã‹ã€èª¬æ˜ã›ã‚ˆã€‚
ç‰¹ã«ã€<tt>serialized-exchange</tt> ãŒå‘¼ã°ã‚ŒãŸã¨ãã«ä½•ãŒèµ·ã“ã‚‹ã®ã‹ã‚’è€ƒãˆã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_Temp_427"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_427">Implementing serializers</a></h4>
<h4 class="trans" lang="ja">ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¶ã‚’å®Ÿè£…ã™ã‚‹</h4>


<p class="orig" lang="en">
<a name="%_idx_3638"></a>
We implement serializers in terms of a more primitive synchronization
mechanism called a <a name="%_idx_3640"></a><em>mutex</em>.  A mutex is an object that supports
two operations -- the mutex can be <a name="%_idx_3642"></a><em>acquired</em>, and the mutex can be
<a name="%_idx_3644"></a><em>released</em>.  Once a mutex has been acquired, no other acquire
operations on that mutex may proceed until the mutex is released.<a name="call_footnote_Temp_428" href="#footnote_Temp_428"><sup><small>44</small></sup></a> In our implementation, each
serializer has an associated mutex.  Given a procedure <tt>p</tt>, the
serializer returns a procedure that acquires the mutex, runs <tt>p</tt>,
and then releases the mutex.  This ensures that only one of the
procedures produced by the serializer can be running at once, which is
precisely the serialization property that we need to guarantee.</p>

<p class="trans" lang="ja">
ç§ãŸã¡ã¯ã€ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¶ã‚’ã€<em>ãƒŸãƒ¥ãƒ¼ãƒ†ãƒƒã‚¯ã‚¹</em> ã¨å‘¼ã°ã‚Œã‚‹ã€ã‚ˆã‚ŠåŸå§‹çš„ãªåŒæœŸã®ä»•çµ„ã¿ã‚’ä½¿ã£ã¦ã€å®Ÿè£…ã™ã‚‹ã€‚
ãƒŸãƒ¥ãƒ¼ãƒ†ãƒƒã‚¯ã‚¹ã¯ã€äºŒã¤ã®æ“ä½œã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚‹â€”â€”ãƒŸãƒ¥ãƒ¼ãƒ†ãƒƒã‚¯ã‚¹ã¯<em>ç²å¾—ã•ã‚Œ</em>å¾—ã‚‹ã—ã€ã¾ãŸã€ãƒŸãƒ¥ãƒ¼ãƒ†ãƒƒã‚¯ã‚¹ã¯<em>è§£æ”¾ã•ã‚Œ</em>å¾—ã‚‹ã€‚
ä¸€æ—¦ãƒŸãƒ¥ãƒ¼ãƒ†ãƒƒã‚¯ã‚¹ãŒç²å¾—ã•ã‚ŒãŸã‚‰ã€ãã®ãƒŸãƒ¥ãƒ¼ãƒ†ãƒƒã‚¯ã‚¹ã«å¯¾ã™ã‚‹ä»–ã®ç²å¾—æ“ä½œã¯ã©ã‚Œã‚‚ã€ãã®ãƒŸãƒ¥ãƒ¼ãƒ†ãƒƒã‚¯ã‚¹ãŒè§£æ”¾ã•ã‚Œã‚‹ã¾ã§ã¯ã€å…ˆã«é€²ã‚ãªã„<a href="#footnote_Temp_428"><sup><small>44</small></sup></a>ã€‚
ç§ãŸã¡ã®å®Ÿè£…ã§ã¯ã€å„ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¶ãŒã€å¯¾å¿œã¥ã‘ã‚‰ã‚ŒãŸãƒŸãƒ¥ãƒ¼ãƒ†ãƒƒã‚¯ã‚¹ã‚’æŒã¤ã€‚
<tt>p</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’ä¸ãˆã‚‰ã‚Œã‚‹ã¨ã€ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¶ã¯ã€ãƒŸãƒ¥ãƒ¼ãƒ†ãƒƒã‚¯ã‚¹ã‚’ç²å¾—ã™ã‚‹æ‰‹ç¶šãã‚’è¿”ã—ã€<tt>p</tt> ã‚’å®Ÿè¡Œã—ã€ãã‚Œã‹ã‚‰ãƒŸãƒ¥ãƒ¼ãƒ†ãƒƒã‚¯ã‚¹ã‚’è§£æ”¾ã™ã‚‹ã€‚
ã“ã‚Œã¯ã€ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¶ã«ã‚ˆã£ã¦ä½œã‚Šå‡ºã•ã‚ŒãŸæ‰‹ç¶šãã®ã†ã¡ã®ãŸã£ãŸä¸€ã¤ã—ã‹ã€åŒæ™‚ã«å®Ÿè¡Œä¸­ã¨ã¯ãªã‚Œãªã„ã€ã¨ã„ã†ã“ã¨ã‚’ä¿è¨¼ã™ã‚‹ã‚‚ã®ã§ã€ãã‚Œã“ãã¯ã€ã¾ã•ã«ã€ç§ãŸã¡ãŒä¿è¨¼ã™ã‚‹å¿…è¦ã®ã‚ã‚‹ç›´åˆ—åŒ–ã®æ€§è³ªã§ã‚ã‚‹ã€‚
</p>


<p class="lisp"><a name="%_idx_3660"></a>(define (make-serializer)
  (let ((mutex (make-mutex)))
    (lambda (p)
      (define (serialized-p . args)
        (mutex 'acquire)
        (let ((val (apply p args)))
          (mutex 'release)
          val))
      serialized-p)))
</p>


<p class="orig" lang="en">
The mutex is a mutable object (here we'll use a one-element
list, which we'll refer to as a <a name="%_idx_3662"></a><em>cell</em>) that can hold the value
true or false.  When the value is false, the mutex is available to be
acquired.  When the value is true, the mutex is unavailable, and any
process that attempts to acquire the mutex must wait.</p>

<p class="trans" lang="ja">
ãƒŸãƒ¥ãƒ¼ãƒ†ãƒƒã‚¯ã‚¹ã¯ã€çœŸã¾ãŸã¯å½ã¨ã„ã†å€¤ã‚’ä¿æŒã§ãã‚‹ã€å¤‰æ›´å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚‹ (ã“ã“ã§ã¯ã€ä¸€è¦ç´ ã®ãƒªã‚¹ãƒˆâ€”â€”<em>ã‚»ãƒ«</em>ã¨å‘¼ã¶ã“ã¨ã«ã—ã‚ˆã†â€”â€”ã‚’ä½¿ãŠã†)ã€‚
ãã®å€¤ãŒå½ã®ã¨ãã€ãƒŸãƒ¥ãƒ¼ãƒ†ãƒƒã‚¯ã‚¹ã¯åˆ©ç”¨å¯èƒ½ã§ã€ç²å¾—ã§ãã‚‹ã€‚
ãã®å€¤ãŒçœŸã®ã¨ãã€ãƒŸãƒ¥ãƒ¼ãƒ†ãƒƒã‚¯ã‚¹ã¯åˆ©ç”¨ä¸èƒ½ã§ã€ãã®ãƒŸãƒ¥ãƒ¼ãƒ†ãƒƒã‚¯ã‚¹ã‚’ç²å¾—ã—ã‚ˆã†ã¨ã™ã‚‹ã©ã®ãƒ—ãƒ­ã‚»ã‚¹ã‚‚ã€å¾…ãŸãªãã¦ã¯ãªã‚‰ãªã„ã€‚
</p>

<p class="orig" lang="en">
Our mutex constructor <tt>make-mutex</tt> begins by initializing the cell
contents to false.  To acquire the mutex, we test the cell.  If the
mutex is available, we set the cell contents to true and proceed.
Otherwise, we wait in a loop, attempting to acquire over and over
again, until we find that the mutex is available.<a name="call_footnote_Temp_429" href="#footnote_Temp_429"><sup><small>45</small></sup></a>  To release the
mutex, we set the cell contents to false.</p>

<p class="trans" lang="ja">
<tt>make-mutex</tt> ã¨ã„ã†ã€ãƒŸãƒ¥ãƒ¼ãƒ†ãƒƒã‚¯ã‚¹ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ã€ã‚»ãƒ«ã®ä¸­èº«ã‚’å½ã«åˆæœŸåŒ–ã™ã‚‹ã“ã¨ã‹ã‚‰å§‹ã‚ã‚‹ã€‚
ãƒŸãƒ¥ãƒ¼ãƒ†ãƒƒã‚¯ã‚¹ã‚’ç²å¾—ã™ã‚‹ãŸã‚ã«ã¯ã€ã‚»ãƒ«ã‚’èª¿ã¹ã‚‹ã€‚
ã‚‚ã—ãƒŸãƒ¥ãƒ¼ãƒ†ãƒƒã‚¯ã‚¹ãŒåˆ©ç”¨å¯èƒ½ãªã‚‰ã€ã‚»ãƒ«ã®ä¸­èº«ã‚’çœŸã«è¨­å®šã—ã¦ã€å…ˆã¸é€²ã‚€ã€‚
ãã†ã§ãªã‘ã‚Œã°ã€ãƒŸãƒ¥ãƒ¼ãƒ†ãƒƒã‚¯ã‚¹ãŒåˆ©ç”¨å¯èƒ½ã ã¨åˆ†ã‹ã‚‹ã¾ã§ã€ä½•åº¦ã‚‚ä½•åº¦ã‚‚ç²å¾—ã‚’è©¦ã¿ãªãŒã‚‰ã€ãƒ«ãƒ¼ãƒ—ã—ã¦å¾…ã¤<a href="#footnote_Temp_429"><sup><small>45</small></sup></a>ã€‚
ãƒŸãƒ¥ãƒ¼ãƒ†ãƒƒã‚¯ã‚¹ã‚’è§£æ”¾ã™ã‚‹ã«ã¯ã€ã‚»ãƒ«ã®ä¸­èº«ã‚’å½ã«è¨­å®šã™ã‚‹ã€‚
</p>


<p class="lisp"><a name="%_idx_3668"></a>(define (make-mutex)
  (let ((cell (list false)))            
    (define (the-mutex m)
      (cond ((eq? m 'acquire)
             (if (test-and-set! cell)
                 (the-mutex 'acquire))) <em>; retry</em>
            ((eq? m 'release) (clear! cell))))
    the-mutex))
(define (clear! cell)
  (set-car! cell false))
</p>


<p class="orig" lang="en">
<tt>Test-and-set!</tt> tests the cell and returns the result of the
test.  In addition, if the test was false, <tt>test-and-set!</tt> sets
the cell contents to true before returning false.  We can express this
behavior as the following procedure:</p>

<p class="trans" lang="ja">
<tt>test-and-set!</tt> ã¯ã€ã‚»ãƒ«ã‚’èª¿ã¹ã¦ã€ãã®æ¤œæŸ»ã®çµæœã‚’è¿”ã™ã€‚
ã•ã‚‰ã«ã€ã‚‚ã—æ¤œæŸ»ãŒå½ãªã‚‰ã€<tt>test-and-set!</tt> ã¯ã€å½ã‚’è¿”ã™å‰ã«ã‚»ãƒ«ã®ä¸­èº«ã‚’çœŸã«è¨­å®šã™ã‚‹ã€‚
ã“ã®æŒ¯ã‚‹èˆã„ã¯ã€ä»¥ä¸‹ã®æ‰‹ç¶šãã®ã‚ˆã†ã«è¡¨ç¾ã§ãã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_3670"></a>(define (test-and-set! cell)
  (if (car cell)
      true
      (begin (set-car! cell true)
             false)))
</p>


<p class="orig" lang="en">
However, this implementation of <tt>test-and-set!</tt> does not suffice
as it stands.  There is a crucial subtlety here, which is the
essential place where concurrency control enters the system: The <tt>test-and-set!</tt> operation must be performed <a name="%_idx_3672"></a><em>atomically</em>.  That
is, we must guarantee that, once a process has tested the cell and
found it to be false, the cell contents will actually be set to true
before any other process can test the cell.  If we do not make this
guarantee, then the mutex can fail in a way similar to the
bank-account failure in figure <a href="#%_fig_3.29">3.29</a>.  (See
exercise <a href="#%_thm_3.46">3.46</a>.)</p>

<p class="trans" lang="ja">
ã—ã‹ã—ã€<tt>test-and-set!</tt> ã®ã“ã®å®Ÿè£…ã¯ã€ç¾çŠ¶ã®ã¾ã¾ã§ã¯ä¸ååˆ†ã§ã‚ã‚‹ã€‚
ã“ã“ã«ã¯æ±ºå®šçš„ã«é‡è¦ãªå·§å¦™ã•ãŒã‚ã‚Šã€ãã‚Œã¯ã€ä¸¦è¡Œæ€§åˆ¶å¾¡ãŒã‚·ã‚¹ãƒ†ãƒ ã«å…¥ã‚Šè¾¼ã‚“ã§ãã‚‹æœ¬è³ªçš„ãªç®‡æ‰€ãªã®ã§ã‚ã‚‹ã€‚ã¤ã¾ã‚Šã€<tt>test-and-set!</tt> ã®æ“ä½œã¯ã€<em><ruby><rb>åŸå­çš„</rb><rp> (</rp><rt>ã‚¢ãƒˆãƒŸãƒƒã‚¯</rt><rp>) </rp></ruby>ã«</em>è¡Œã‚ã‚Œãªãã¦ã¯ãªã‚‰ãªã„ã®ã ã€‚
ã™ãªã‚ã¡ã€ãƒ—ãƒ­ã‚»ã‚¹ãŒä¸€æ—¦ã‚»ãƒ«ã‚’è©¦ã—ã¦ã‚»ãƒ«ãŒå½ã ã¨åˆ†ã‹ã£ãŸã‚‰ã€ã‚»ãƒ«ã®ä¸­èº«ã¯ã€ä»–ã®ã©ã®ãƒ—ãƒ­ã‚»ã‚¹ãŒãã®ã‚»ãƒ«ã‚’è©¦ã›ã‚‹ã¨ãã‚ˆã‚Šã‚‚å‰ã«ã€å®Ÿéš›ã«çœŸã«è¨­å®šã•ã‚Œã‚‹ã ã‚ã†ã€‚
ã‚‚ã—ã“ã®ä¿è¨¼ã‚’ã—ãªã‹ã£ãŸã‚‰ã€ãƒŸãƒ¥ãƒ¼ãƒ†ãƒƒã‚¯ã‚¹ã¯ã€å›³<a href="#%_fig_3.29">3.29</a>ã®éŠ€è¡Œå£åº§ã®å¤±æ•—ã¨ä¼¼ãŸã‚ˆã†ãªç­‹é“ã§ã€å¤±æ•—ã—å¾—ã‚‹ã®ã  (ç·´ç¿’å•é¡Œ<a href="#%_thm_3.46">3.46</a>ã‚’å‚ç…§)ã€‚
</p>

<p class="orig" lang="en">
The actual implementation of <tt>test-and-set!</tt> depends on the
details of how our system runs concurrent processes.  For example, we
might be executing concurrent processes on a sequential processor
using a <a name="%_idx_3674"></a>time-slicing mechanism that cycles through the processes,
permitting each process to run for a short time before interrupting it
and moving on to the next process.  In that case, <tt>test-and-set!</tt>
can work by disabling time slicing during the testing and setting.<a name="call_footnote_Temp_430" href="#footnote_Temp_430"><sup><small>46</small></sup></a>
Alternatively, multiprocessing computers provide instructions that
support atomic operations directly in hardware.<a name="call_footnote_Temp_431" href="#footnote_Temp_431"><sup><small>47</small></sup></a></p>

<p class="trans" lang="ja">
<tt>test-and-set!</tt> ã®å®Ÿéš›ã®å®Ÿè£…ã¯ã€ç§ãŸã¡ã®ã‚·ã‚¹ãƒ†ãƒ ãŒä¸¦è¡Œãªãƒ—ãƒ­ã‚»ã‚¹ã‚’å®Ÿè¡Œã™ã‚‹ã‚„ã‚Šæ–¹ã®è©³ç´°ã«ã‚ˆã‚‹ã€‚
ãŸã¨ãˆã°ã€ç§ãŸã¡ã¯ã€è¤‡æ•°ã®ãƒ—ãƒ­ã‚»ã‚¹ã‚’å¾ªç’°ã™ã‚‹ã‚¿ã‚¤ãƒ ãƒ»ã‚¹ãƒ©ã‚¤ã‚·ãƒ³ã‚°ã®ä»•çµ„ã¿ã‚’ä½¿ã£ã¦ã€é€æ¬¡çš„ãƒ—ãƒ­ã‚»ãƒƒã‚µä¸Šã§ã€ä¸¦è¡Œãªãƒ—ãƒ­ã‚»ã‚¹ã‚’å®Ÿè¡Œã—ã¦ã„ã‚‹ã¨ã“ã‚â€”â€”å„ãƒ—ãƒ­ã‚»ã‚¹ã«å¯¾ã—ã¦ã€ãã®ãƒ—ãƒ­ã‚»ã‚¹ã«å‰²ã‚Šè¾¼ã‚“ã§æ¬¡ã®ãƒ—ãƒ­ã‚»ã‚¹ã¸ã¨é€²ã‚€ã‚ˆã‚Šã‚‚å‰ã®çŸ­ã„æ™‚é–“ã ã‘ã€å®Ÿè¡Œã•ã‚Œã‚‹ã“ã¨ã‚’è¨±ã—ãªãŒã‚‰â€”â€”ã‹ã‚‚ã—ã‚Œãªã„ã€‚
ãã®å ´åˆã€<tt>test-and-set!</tt> ã¯ã€èª¿ã¹ã¦è¨­å®šã—ã¦ã„ã‚‹é–“ã«ã¯ã‚¿ã‚¤ãƒ ãƒ»ã‚¹ãƒ©ã‚¤ã‚·ãƒ³ã‚°ã‚’ç„¡åŠ¹åŒ–ã™ã‚‹ã“ã¨ã§ã€ã†ã¾ãæ©Ÿèƒ½ã§ãã‚‹<a href="#footnote_Temp_430"><sup><small>46</small></sup></a>ã€‚
ã‚ã‚‹ã„ã¯ã€ãƒãƒ«ãƒãƒ—ãƒ­ã‚»ã‚·ãƒ³ã‚°ãƒ»ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãŒã€åŸå­çš„ãªæ“ä½œã‚’ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ã§ç›´æ¥çš„ã«ã‚µãƒãƒ¼ãƒˆã™ã‚‹å‘½ä»¤ã‚’ã€æä¾›ã™ã‚‹<a href="#footnote_Temp_431"><sup><small>47</small></sup></a>ã€‚
</p>


<p class="orig" lang="en"><a name="%_thm_3.46"></a>
<b>Exercise 3.46.</b>  Suppose that we implement <tt>test-and-set!</tt>  using an ordinary
procedure as shown in the text, without attempting to make the operation
atomic.  Draw a timing diagram like the one in
figure <a href="#%_fig_3.29">3.29</a> to demonstrate how the mutex
implementation can fail by allowing two processes to acquire the mutex
at the same time.
</p>

<p class="trans" lang="ja"><b>ç·´ç¿’å•é¡Œ3.46.</b> æœ¬æ–‡ã«ç¤ºã—ãŸã‚ˆã†ã«æ™®é€šã®æ‰‹ç¶šãã‚’ä½¿ã£ã¦â€”â€”ãŸã ã—ã€æ“ä½œã‚’åŸå­çš„ã«ã—ã‚ˆã†ã¨ã¯ã›ãšã«â€”â€” <tt>test-and-set!</tt> ã‚’å®Ÿè£…ã™ã‚‹ã‚‚ã®ã¨ã—ã‚ˆã†ã€‚
äºŒã¤ã®ãƒ—ãƒ­ã‚»ã‚¹ãŒåŒæ™‚ã«ãƒŸãƒ¥ãƒ¼ãƒ†ãƒƒã‚¯ã‚¹ã‚’ç²å¾—ã™ã‚‹ã“ã¨ã‚’è¨±ã™ã“ã¨ã«ã‚ˆã£ã¦ã€ãƒŸãƒ¥ãƒ¼ãƒ†ãƒƒã‚¯ã‚¹ã®å®Ÿè£…ãŒã©ã®ã‚ˆã†ã«ã—ã¦å¤±æ•—ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã®ã‹ã‚’å®Ÿè¨¼ã™ã‚‹ãŸã‚ã«ã€å›³<a href="#%_fig_3.29">3.29</a>ã«ã‚ã‚‹ã‚ˆã†ãªã‚¿ã‚¤ãƒŸãƒ³ã‚°å›³ã‚’æã‘ã€‚
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.47"></a>
<b>Exercise 3.47.</b>  <a name="%_idx_3692"></a>A semaphore (of size <em>n</em>) is a generalization of a mutex.  Like a
mutex, a semaphore supports acquire and release operations, but it is
more general in that up to <em>n</em> processes can acquire it
concurrently.  Additional processes that attempt to acquire the
semaphore must wait for release operations.  Give implementations of
semaphores</p>

<p class="trans" lang="ja"><b>ç·´ç¿’å•é¡Œ3.47.</b> (å¤§ãã•ãŒ <em class="en">n</em> ã®) ã‚»ãƒãƒ•ã‚©ã¨ã¯ã€ãƒŸãƒ¥ãƒ¼ãƒ†ãƒƒã‚¯ã‚¹ã®ä¸€èˆ¬åŒ–ã§ã‚ã‚‹ã€‚
ãƒŸãƒ¥ãƒ¼ãƒ†ãƒƒã‚¯ã‚¹ã¨åŒæ§˜ã«ã€ã‚»ãƒãƒ•ã‚©ã¯ã€ç²å¾—ã¨è§£æ”¾ã®æ“ä½œã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ãŒã€æœ€å¤§ã§ <em class="en">n</em> å€‹ã¾ã§ã®ãƒ—ãƒ­ã‚»ã‚¹ãŒãã®ã‚»ãƒãƒ•ã‚©ã‚’ä¸¦è¡Œã«ç²å¾—ã§ãã‚‹ã®ã ã€ã¨ã„ã†ç‚¹ã«ãŠã„ã¦ã€ã‚»ãƒãƒ•ã‚©ã¯ã‚ˆã‚Šä¸€èˆ¬çš„ã§ã‚ã‚‹ã€‚
ã‚»ãƒãƒ•ã‚©ã‚’ç²å¾—ã—ã‚ˆã†ã¨ã™ã‚‹ã€ã•ã‚‰ãªã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã¯ã€è§£æ”¾æ“ä½œã‚’å¾…ãŸã­ã°ãªã‚‰ãªã„ã€‚
ã‚»ãƒãƒ•ã‚©ã®å®Ÿè£…ã‚’ç¤ºã›ã€‚
</p>

<p class="orig" lang="en">a. in terms of mutexes</p>

<p class="trans" lang="ja">
a. ãƒŸãƒ¥ãƒ¼ãƒ†ãƒƒã‚¯ã‚¹ã‚’ä½¿ã£ã¦ã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>


<p class="orig" lang="en">b. in terms of atomic <tt>test-and-set!</tt> operations.
</p>

<p class="trans" lang="ja">
b. åŸå­çš„ãª <tt>test-and-set!</tt> ã®æ¼”ç®—ã‚’ä½¿ã£ã¦ã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_Temp_434"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_434">Deadlock</a></h4>
<h4 class="trans" lang="ja">ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯</h4>

<p class="orig" lang="en">
<a name="%_idx_3694"></a><a name="%_idx_3696"></a>
Now that we have seen how to implement serializers, we can see
that account exchanging still has a problem, even with the
<tt>serialized-exchange</tt> procedure above.
Imagine that Peter attempts to exchange <em>a</em>1
with <em>a</em>2 while Paul concurrently attempts to exchange <em>a</em>2
with <em>a</em>1.  Suppose that Peter's process reaches the point where
it has entered a serialized procedure protecting <em>a</em>1 and, just
after that, Paul's process enters a serialized procedure protecting
<em>a</em>2.  Now Peter cannot proceed (to enter a serialized procedure
protecting <em>a</em>2) until Paul exits the serialized procedure
protecting <em>a</em>2.  Similarly, Paul cannot proceed until Peter exits
the serialized procedure protecting <em>a</em>1.  Each process is stalled
forever, waiting for the other.  This situation is called a <em>deadlock</em>.  Deadlock is always a danger in systems that provide
concurrent access to multiple shared resources.</p>

<p class="trans" lang="ja">
ä»Šã§ã¯ã‚‚ã†ã€ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¶ã‚’ã©ã†å®Ÿè£…ã™ã‚‹ã®ã‹ã‚’è¦‹ã¦ããŸã®ã ã‹ã‚‰ã€ç§ãŸã¡ã¯ã€ãŸã¨ãˆä¸Šè¨˜ã® <tt>serialized-exchange</tt> ã®æ‰‹ç¶šãã‚’ä½¿ã£ã¦ã‚‚å£åº§ã®äº¤æ›ã«ã¯ä¾ç„¶ã¨ã—ã¦å•é¡ŒãŒã‚ã‚‹ã€ã¨ã„ã†ã“ã¨ãŒåˆ†ã‹ã‚‹ã€‚
ãƒãƒ¼ãƒ«ãŒä¸¦è¡Œã« <em class="en">a</em>2 ã¨ <em class="en">a</em>1 ã‚’äº¤æ›ã—ã‚ˆã†ã¨ã—ã¦ã„ã‚‹é–“ã«ã€ãƒ”ãƒ¼ã‚¿ãƒ¼ãŒ <em class="en">a</em>1 ã¨ <em class="en">a</em>2 ã‚’äº¤æ›ã—ã‚ˆã†ã¨ã™ã‚‹ã€ã¨æƒ³åƒã›ã‚ˆã€‚
<!--ãƒ”ãƒ¼ã‚¿ãƒ¼ãŒ <em class="en">a</em>1 ã¨ <em class="en">a</em>2 ã‚’äº¤æ›ã—ã‚ˆã†ã¨ã—ã€ãã®é–“ã«ä¸¦è¡Œã—ã¦ã€ãƒãƒ¼ãƒ«ãŒ <em class="en">a</em>2 ã¨ <em class="en">a</em>1 ã‚’äº¤æ›ã—ã‚ˆã†ã¨ã—ã¦ã„ã‚‹ã€ã¨æƒ³åƒã›ã‚ˆã€‚-->
ãƒ”ãƒ¼ã‚¿ãƒ¼ã®ãƒ—ãƒ­ã‚»ã‚¹ã¯ã€<em class="en">a</em>1 ã‚’ä¿è­·ã—ã¦ã„ã‚‹ç›´åˆ—åŒ–æ‰‹ç¶šãã«ãã®ãƒ—ãƒ­ã‚»ã‚¹ãŒå…¥ã£ãŸã¨ã“ã‚ã¾ã§åˆ°é”ã—ã¦ã„ã‚‹ã‚‚ã®ã¨ã—ã€ãã®ç›´å¾Œã«ã€ãƒãƒ¼ãƒ«ã®ãƒ—ãƒ­ã‚»ã‚¹ãŒã€<em class="en">a</em>2 ã‚’ä¿è­·ã—ã¦ã„ã‚‹ç›´åˆ—åŒ–æ‰‹ç¶šãã«å…¥ã‚‹ã‚‚ã®ã¨ã—ã‚ˆã†ã€‚
ã“ã“ã§ã€ãƒ”ãƒ¼ã‚¿ãƒ¼ã¯ã€<em class="en">a</em>2 ã‚’ä¿è­·ã—ã¦ã„ã‚‹ç›´åˆ—åŒ–æ‰‹ç¶šãã‹ã‚‰ãƒãƒ¼ãƒ«ãŒæŠœã‘å‡ºã™ã¾ã§ã¯ã€å…ˆã«é€²ã‚ãªã„ (<em class="en">a</em>2 ã‚’ä¿è­·ã—ã¦ã„ã‚‹ç›´åˆ—åŒ–æ‰‹ç¶šãã«å…¥ã‚‹ã¨ã“ã‚ã¾ã§é€²ã‚ãªã„)ã€‚
åŒæ§˜ã«ã€ãƒãƒ¼ãƒ«ã¯ã€<em class="en">a</em>1 ã‚’ä¿è­·ã—ã¦ã„ã‚‹ç›´åˆ—åŒ–æ‰‹ç¶šãã‹ã‚‰ãƒ”ãƒ¼ã‚¿ãƒ¼ãŒæŠœã‘å‡ºã™ã¾ã§ã¯ã€å…ˆã«é€²ã‚ãªã„ã€‚
ãã‚Œãã‚Œã®ãƒ—ãƒ­ã‚»ã‚¹ã¯ã€ä»–æ–¹ã‚’å¾…ã£ã¦ã„ã‚‹ã¨ã“ã‚ã§ã€æ°¸é ã«æ­¢ã‚ã‚‰ã‚Œã¦ã—ã¾ã†ã€‚
ã“ã®çŠ¶æ³ã¯<em>ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯</em>ã¨å‘¼ã°ã‚Œã‚‹ã€‚
è¤‡æ•°ã®å…±æœ‰è³‡æºã«å¯¾ã™ã‚‹ä¸¦è¡Œãªã‚¢ã‚¯ã‚»ã‚¹ã‚’æä¾›ã™ã‚‹ã‚ˆã†ãªã‚·ã‚¹ãƒ†ãƒ ã«ãŠã„ã¦ã€ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯ã¯ã„ã¤ã§ã‚‚å±é™ºãªã‚‚ã®ãªã®ã ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_3698"></a>One way to avoid the deadlock in this situation is to give each
account a unique identification number and rewrite <tt>serialized-exchange</tt> so
that a process will always attempt to enter a procedure protecting the
lowest-numbered account first.  Although this method works well for
the exchange problem, there are other situations that require more
sophisticated deadlock-avoidance techniques, or where deadlock cannot
be avoided at all.  (See exercises <a href="#%_thm_3.48">3.48</a>
and <a href="#%_thm_3.49">3.49</a>.)<a name="call_footnote_Temp_435" href="#footnote_Temp_435"><sup><small>48</small></sup></a></p>

<p class="trans" lang="ja">
ã“ã®çŠ¶æ³ã«ãŠã‘ã‚‹ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯ã‚’é˜²ããŸã‚ã®ä¸€ã¤ã®æ–¹æ³•ã¯ã€ãã‚Œãã‚Œã®å£åº§ã«ä¸€æ„ãªè­˜åˆ¥ç•ªå·ã‚’ä¸ãˆã¦ã€ãã—ã¦ã€ãƒ—ãƒ­ã‚»ã‚¹ãŒå¿…ãšã„ã¤ã‚‚ã€ã‚‚ã£ã¨ã‚‚å°ã•ã„ç•ªå·ã®ã¤ã„ãŸå£åº§ã‚’ä¿è­·ã™ã‚‹ã‚ˆã†ãªæ‰‹ç¶šãã«æœ€åˆã«å…¥ã‚ã†ã¨ã™ã‚‹ã‚ˆã†ã«ã€<tt>serialized-exchange</tt> ã‚’æ›¸ãæ›ãˆã‚‹ã“ã¨ã€ã§ã‚ã‚‹ã€‚
ã“ã®æ–¹æ³•ã¯ã€äº¤æ›ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«å¯¾ã—ã¦ã¯ã†ã¾ãã‚†ãã®ã ãŒã€ã‚ˆã‚Šæ´—ç·´ã•ã‚ŒãŸãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯å›é¿æŠ€æ³•ã‚’è¦ã™ã‚‹ã‚ˆã†ãªä»–ã®çŠ¶æ³ã€ã‚ã‚‹ã„ã¯ã€ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯ã‚’ã¾ã£ãŸãé˜²ã’ãªã„ã‚ˆã†ãªçŠ¶æ³ãŒã‚ã‚‹
(ç·´ç¿’å•é¡Œ<a href="#%_thm_3.48">3.48</a>ã¨<a href="#%_thm_3.49">3.49</a>ã‚’å‚ç…§)<a href="#footnote_Temp_435"><sup><small>48</small></sup></a>ã€‚
</p>


<p class="orig" lang="en"><a name="%_thm_3.48"></a>
<b>Exercise 3.48.</b>  <a name="%_idx_3708"></a>Explain in detail why the deadlock-avoidance method described above,
(i.e., the accounts are numbered, and each process attempts to acquire
the smaller-numbered account first) avoids deadlock in the exchange
problem.  Rewrite <tt>serialized-exchange</tt> to incorporate this idea.
(You will
also need to modify <tt>make-account</tt> so that each account is created
with a number, which can be accessed by sending an appropriate
message.)

</p>

<p class="trans" lang="ja"><b>ç·´ç¿’å•é¡Œ3.48.</b> ä¸Šè¨˜ã®ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯å›é¿æ³• (ã¤ã¾ã‚Šã€å£åº§ã«ç•ªå·ãŒã¤ã‘ã‚‰ã‚Œã€å„ãƒ—ãƒ­ã‚»ã‚¹ã¯ã€ã‚ˆã‚Šå°ã•ã„ç•ªå·ã®ã¤ã„ãŸå£åº§ã‚’ã¾ãšç²å¾—ã—ã‚ˆã†ã¨ã™ã‚‹) ãŒã€ãªãœã€äº¤æ›ã®å•é¡Œã§ã¯ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯ã‚’å›é¿ã™ã‚‹ã®ã‹ã€ã‚’è©³ã—ãèª¬æ˜ã›ã‚ˆã€‚
ã“ã®è€ƒãˆã‚’å–ã‚Šè¾¼ã‚€ã‚ˆã†ã«ã€<tt>serialized-exchange</tt> ã‚’æ›¸ãæ›ãˆã‚ˆ
(å„å£åº§ãŒã€ç•ªå·â€”â€”é©åˆ‡ãªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹â€”â€”ã¨ã¨ã‚‚ã«ä½œæˆã•ã‚Œã‚‹ã‚ˆã†ã«ã€<tt>make-account</tt> ã‚’ä¿®æ­£ã™ã‚‹å¿…è¦ã‚‚ã‚ã‚‹ã ã‚ã†)ã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.49"></a>
<b>Exercise 3.49.</b>  Give a scenario where the deadlock-avoidance mechanism described
above does not work.  (Hint: In the exchange problem, each process
knows in advance which accounts it will need to get access to.  Consider a
situation where a process must get access to some shared resources before it
can know which additional shared resources it will require.)

</p>

<p class="trans" lang="ja"><b>ç·´ç¿’å•é¡Œ3.49.</b> ä¸Šè¨˜ã®ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯å›é¿ã®ä»•çµ„ã¿ãŒã†ã¾ãã„ã‹ãªã„ã‚ˆã†ãªã‚·ãƒŠãƒªã‚ªã‚’ç¤ºã›ã€‚
(ãƒ’ãƒ³ãƒˆï¼šäº¤æ›ã®å•é¡Œã§ã¯ã€å„ãƒ—ãƒ­ã‚»ã‚¹ã¯ã€ãã®ãƒ—ãƒ­ã‚»ã‚¹ãŒã©ã®å£åº§ã¸ã®åˆ©ç”¨æ¨©ã‚’å¾—ã‚‹å¿…è¦ãŒã‚ã‚‹ã ã‚ã†ã‹ã€ã¨ã„ã†ã“ã¨ã‚’ã€äº‹å‰ã«çŸ¥ã£ã¦ã„ã‚‹ã€‚
ãƒ—ãƒ­ã‚»ã‚¹ãŒã€è‡ªåˆ†ãŒã©ã®è¿½åŠ çš„ãªå…±æœ‰è³‡æºã‚’å¿…è¦ã¨ã™ã‚‹ã ã‚ã†ã‹ã€ã¨ã„ã†ã“ã¨ã‚’çŸ¥ã‚‹ã“ã¨ãŒã§ããªã„ã†ã¡ã«ã€ä½•ã‚‰ã‹ã®å…±æœ‰è³‡æºã¸ã®åˆ©ç”¨æ¨©ã‚’å¾—ãªãã¦ã¯ãªã‚‰ãªã„ã€ã¨ã„ã†çŠ¶æ³ã‚’è€ƒãˆã‚ˆã€‚)
</p>

<p class="exercise"><span class="ex_comment">
</span></p>


<a name="%_sec_Temp_438"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_438">Concurrency, time, and communication</a></h4>
<h4 class="trans" lang="ja">ä¸¦è¡Œæ€§ã¨æ™‚é–“ã¨é€šä¿¡</h4>

<p class="orig" lang="en">
We've seen how programming concurrent systems requires controlling the
ordering of events when different processes access shared
state, and we've seen how to achieve this control through judicious
use of serializers.  But the problems of concurrency
lie deeper than this, because, from a fundamental point of view, it's
not always clear what is meant by ``shared state.''</p>

<p class="trans" lang="ja">
ä¸¦è¡Œã‚·ã‚¹ãƒ†ãƒ ã‚’ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã™ã‚‹ã“ã¨ãŒã€ç•°ãªã‚‹ãƒ—ãƒ­ã‚»ã‚¹ãŒå…±æœ‰çŠ¶æ…‹ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹å ´åˆã®ã‚¤ãƒ™ãƒ³ãƒˆã®é †åºã‚’åˆ¶å¾¡ã™ã‚‹ã“ã¨ã‚’ã€ã©ã®ã‚ˆã†ã«å¿…è¦ã¨ã™ã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’ç§ãŸã¡ã¯è¦‹ã¦ããŸã—ã€ã¾ãŸã€ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¶ã‚’æ€æ…®æ·±ãä½¿ã†ã“ã¨ã‚’é€šã˜ã¦ã€ã“ã®åˆ¶å¾¡ã‚’ã©ã®ã‚ˆã†ã«é”æˆã™ã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’ç§ãŸã¡ã¯è¦‹ã¦ããŸã€‚
ã—ã‹ã—ã€ä¸¦è¡Œæ€§ã®å•é¡Œã¯ã€ã“ã‚Œã‚ˆã‚Šã‚‚æ·±ã„ã¨ã“ã‚ã«ã‚ã‚‹â€”â€”ãªãœãªã‚‰ã€æ ¹æœ¬çš„ãªè¦³ç‚¹ã‹ã‚‰ã¯ã€ã€Œå…±æœ‰çŠ¶æ…‹ã€ãŒä½•ã‚’æ„å‘³ã™ã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ãŒå¿…ãšã—ã‚‚æ˜ç¢ºã§ã¯ãªã„ã‹ã‚‰ã ã€‚
</p>

<p class="orig" lang="en">
Mechanisms such as <tt>test-and-set!</tt> require processes to examine a
global shared flag at arbitrary times.  This is problematic and
inefficient to implement in modern high-speed processors, where
due to optimization techniques such as pipelining and cached memory,
the contents of memory
may not be in a consistent state at every instant.  In contemporary
multiprocessing systems, therefore, the serializer paradigm is being
supplanted by new approaches to concurrency control.<a name="call_footnote_Temp_439" href="#footnote_Temp_439"><sup><small>49</small></sup></a></p>

<p class="trans" lang="ja">
<tt>test-and-set!</tt> ã®ã‚ˆã†ãªä»•çµ„ã¿ã¯ã€ãƒ—ãƒ­ã‚»ã‚¹ãŒå¤§åŸŸçš„ãªå…±æœ‰ãƒ•ãƒ©ã‚°ã‚’ä»»æ„ã®æ™‚ç‚¹ã§æ¤œæŸ»ã™ã‚‹ã“ã¨ã‚’è¦ã™ã‚‹ã€‚
ã“ã‚Œã«ã¯å•é¡ŒãŒã‚ã‚Šã€è¿‘ä»£çš„ãªé«˜é€Ÿãƒ—ãƒ­ã‚»ãƒƒã‚µâ€”â€”ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³åŒ–ã‚„ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚ŒãŸãƒ¡ãƒ¢ãƒªãªã©ã®ã€æœ€é©åŒ–æŠ€æ³•ã«ã‚ˆã‚Šã€ãƒ¡ãƒ¢ãƒªã®å†…å®¹ãŒã©ã®ç¬é–“ã«ãŠã„ã¦ã‚‚æ•´åˆæ€§ã®ã¨ã‚ŒãŸçŠ¶æ…‹ã«ã‚ã‚‹ã‚ã‘ã§ã¯ãªã„ã‹ã‚‚ã—ã‚Œãªã„â€”â€”ã§å®Ÿè£…ã™ã‚‹ã«ã¯ã€éåŠ¹ç‡çš„ã§ã‚ã‚‹ã€‚
ãã®ãŸã‚ã€ç¾ä»£ã®ãƒãƒ«ãƒãƒ—ãƒ­ã‚»ã‚·ãƒ³ã‚°ãƒ»ã‚·ã‚¹ãƒ†ãƒ ã§ã¯ã€ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¶ãƒ»ãƒ‘ãƒ©ãƒ€ã‚¤ãƒ ã¯ã€ä¸¦è¡Œæ€§åˆ¶å¾¡ã¸ã®æ–°ãŸãªå–ã‚Šçµ„ã¿ã«ã€å–ã£ã¦ä»£ã‚ã‚‰ã‚Œã¤ã¤ã‚ã‚‹<a href="#footnote_Temp_439"><sup><small>49</small></sup></a>ã€‚

</p>

<p class="orig" lang="en">
The problematic aspects of shared state also arise
in large, distributed systems.  For
instance, imagine a
distributed banking system where individual branch banks maintain
local values for bank balances and periodically compare these with
values maintained by other branches.  In such a system the value of
``the account balance'' would be undetermined, except right after
synchronization.
If Peter deposits money in an account he holds
jointly with Paul, when should we say that the account balance has
changed -- when the balance in the local branch changes, or not until
after the synchronization?  
And if Paul accesses the account from a
different branch, what are the reasonable constraints to place on the
banking system such that the behavior is ``correct''?  
The only thing that might matter for
correctness is the behavior observed by Peter and Paul individually
and the ``state'' of the account immediately after synchronization.
Questions about the
``real'' account balance or the order of events between synchronizations
may be irrelevant or meaningless.<a name="call_footnote_Temp_440" href="#footnote_Temp_440"><sup><small>50</small></sup></a></p>

<p class="trans" lang="ja">
å…±æœ‰çŠ¶æ…‹ã®å•é¡Œå¤šãå´é¢ã¯ã€å¤§è¦æ¨¡ãªåˆ†æ•£ã‚·ã‚¹ãƒ†ãƒ ã«ãŠã„ã¦ã‚‚ç™ºç”Ÿã™ã‚‹ã€‚
ãŸã¨ãˆã°ã€å€‹ã€…ã®æ”¯åº—éŠ€è¡ŒãŒã€éŠ€è¡Œæ®‹é«˜ã«ã¤ã„ã¦ã®å±€æ‰€çš„ãªå€¤ã‚’ä¿æŒã—ã€ã“ã‚Œã‚‰ã®å€¤ã‚’ã€ä»–ã®æ”¯åº—ã§ä¿æŒã•ã‚Œã¦ã„ã‚‹å€¤ã¨å®šæœŸçš„ã«æ¯”ã¹ã‚‹ã‚ˆã†ãªã€åˆ†æ•£éŠ€è¡Œã‚·ã‚¹ãƒ†ãƒ ã‚’æƒ³åƒã›ã‚ˆã€‚
ãã†ã—ãŸã‚·ã‚¹ãƒ†ãƒ ã§ã¯ã€åŒæœŸã®ç›´å¾Œã‚’é™¤ãã€ã€Œå£åº§æ®‹é«˜ã€ã®å€¤ã¯å®šã¾ã‚‰ãªã„ã ã‚ã†ã€‚
ã‚‚ã—ãƒ”ãƒ¼ã‚¿ãƒ¼ãŒã€ãƒãƒ¼ãƒ«ã¨å…±åŒã§ä¿æœ‰ã—ã¦ã„ã‚‹å£åº§ã«é é‡‘ã‚’ã—ãŸã‚‰ã€å±€æ‰€çš„æ”¯åº—ã®æ®‹é«˜ã¯ã„ã¤å¤‰åŒ–ã™ã‚‹ã®ã ã‚ã†?ã€€ã‚ã‚‹ã„ã¯ã€åŒæœŸã®å¾Œã¾ã§ã¯å¤‰åŒ–ã—ãªã„ã®ã ã‚ã†ã‹?
ãã—ã¦ã€ã‚‚ã—ãƒãƒ¼ãƒ«ãŒåˆ¥ã®æ”¯åº—ã‹ã‚‰å½“è©²å£åº§ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ãŸã‚‰ã€æŒ¯ã‚‹èˆã„ãŒã€Œæ­£ã—ã„ã€ã‚‚ã®ã¨ãªã‚‹ã‚ˆã†ã«ã€éŠ€è¡Œã‚·ã‚¹ãƒ†ãƒ ã«å¯¾ã—ã¦èª²ã™ã¹ãã€ç­‹ã®é€šã£ãŸåˆ¶ç´„ã¨ã¯ã€ã©ã‚“ãªã‚‚ã®ã ã‚ã†ã‹?
æ­£ã—ã•ã«ã¨ã£ã¦é‡è¦ã‹ã‚‚ã—ã‚Œãªã„å”¯ä¸€ã®ã“ã¨ã¯ã€ãƒ”ãƒ¼ã‚¿ãƒ¼ã¨ãƒãƒ¼ãƒ«ã«ã‚ˆã‚Šå€‹ã€…ã«è¦³å¯Ÿã•ã‚Œã‚‹æŒ¯ã‚‹èˆã„ã§ã‚ã‚Šã€åŒæœŸç›´å¾Œã®å£åº§ã®ã€ŒçŠ¶æ…‹ã€ã§ã‚ã‚‹ã€‚
ã€Œç¾å®Ÿã€ã®å£åº§æ®‹é«˜ã‚ã‚‹ã„ã¯åŒæœŸåŒå£«ã®é–“ã®ã‚¤ãƒ™ãƒ³ãƒˆã®é †åºã«ã¤ã„ã¦ã®ç–‘å•ã¯ã€ç„¡é–¢ä¿‚ã¾ãŸã¯ç„¡æ„å‘³ã§ã‚ã‚‹<a href="#footnote_Temp_440"><sup><small>50</small></sup></a>ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_3720"></a>The basic phenomenon here is that synchronizing different processes,
establishing shared state, or imposing an order on events requires
communication among the processes.  In essence, any notion of time in
concurrency control must be intimately tied to communication.<a name="call_footnote_Temp_441" href="#footnote_Temp_441"><sup><small>51</small></sup></a>  It is
intriguing that a similar connection between time and communication
also arises in the <a name="%_idx_3724"></a>Theory of Relativity, where the speed of light (the
fastest signal that can be used to synchronize events) is a
fundamental constant relating time and space.  The
complexities we encounter in dealing with time and state in our
computational models may in fact mirror a fundamental complexity of
the physical universe.
</p>

<p class="trans" lang="ja">
ã“ã“ã§ã®åŸºæœ¬çš„ç¾è±¡ã¯ã€ç•°ãªã‚‹ãƒ—ãƒ­ã‚»ã‚¹åŒå£«ã‚’åŒæœŸã•ã›ã‚‹ã“ã¨ã€å…±æœ‰çŠ¶æ…‹ã‚’ç¢ºç«‹ã™ã‚‹ã“ã¨ã€ã¾ãŸã¯ã€è«¸ã‚¤ãƒ™ãƒ³ãƒˆã«å¯¾ã—ã¦é †åºã‚’æŠ¼ã—ä»˜ã‘ã‚‹ã“ã¨ãŒã€ãƒ—ãƒ­ã‚»ã‚¹é–“ã®é€šä¿¡ã‚’è¦ã™ã‚‹ã€ã¨ã„ã†ã“ã¨ã§ã‚ã‚‹ã€‚
æœ¬è³ªçš„ã«ã¯ã€ä¸¦è¡Œæ€§åˆ¶å¾¡ã«ãŠã‘ã‚‹ã€æ™‚é–“ã«ã¤ã„ã¦ã®ã„ã‹ãªã‚‹æ¦‚å¿µã‚‚ã€é€šä¿¡ã¨å¯†æ¥ã«çµã³ã¤ã„ã¦ã„ã‚‹ã¯ãšã§ã‚ã‚‹<a name="call_footnote_Temp_441" href="#footnote_Temp_441"><sup><small>51</small></sup></a>ã€‚
æ™‚é–“ã¨é€šä¿¡ã®é–“ã®ã€ä¼¼ãŸã‚ˆã†ãªã¤ãªãŒã‚ŠãŒã€ç›¸å¯¾æ€§ç†è«–â€”â€”ãã“ã§ã¯ã€å…‰ (ã‚¤ãƒ™ãƒ³ãƒˆåŒå£«ã‚’åŒæœŸã•ã›ã‚‹ã®ã«ä½¿ãˆã‚‹æœ€é€Ÿã®ä¿¡å·) ã®é€Ÿã•ãŒã€æ™‚é–“ã¨ç©ºé–“ã«é–¢ã™ã‚‹æ ¹æœ¬çš„ãªå®šæ•°ã§ã‚ã‚‹â€”â€”ã§ã‚‚ç”Ÿã˜ã‚‹ã“ã¨ã¯ã€èˆˆå‘³æ·±ã„ã€‚
ç§ãŸã¡ã®è¨ˆç®—ãƒ¢ãƒ‡ãƒ«ã«ãŠã‘ã‚‹æ™‚é–“ã¨çŠ¶æ…‹ã‚’æ‰±ã†éš›ã«ç§ãŸã¡ãŒé­é‡ã™ã‚‹æ§˜ã€…ãªè¤‡é›‘ã•ã¯ã€å®Ÿéš›ã¯ã€ç‰©ç†çš„å®‡å®™ã®æ ¹æœ¬çš„ãªè¤‡é›‘ã•ã‚’åæ˜ ã—ã¦ã„ã‚‹ã®ã‹ã‚‚ã—ã‚Œãªã„ã€‚
</p>


<hr>
<a name="footnotes"></a>

<p class="orig" lang="en"><a name="footnote_Temp_405" href="#call_footnote_Temp_405"><sup><small>34</small></sup></a> Most real processors actually execute a few
operations at a time, following a strategy called <a name="%_idx_3582"></a><em>pipelining</em>.  Although this technique greatly improves the effective
utilization of the hardware, it is used only to speed up the execution
of a sequential instruction stream, while retaining the behavior of
the sequential program.

</p>

<p class="trans" lang="ja">
ã»ã¨ã‚“ã©ã®ç¾å®Ÿã®ãƒ—ãƒ­ã‚»ãƒƒã‚µã¯ã€<em>ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³åŒ–</em>ã¨å‘¼ã°ã‚Œã‚‹æˆ¦ç•¥ã«ã—ãŸãŒã£ã¦ã€å®Ÿéš›ã«ã¯ä¸€åº¦ã«å°‘æ•°å€‹ã®æ¼”ç®—ã‚’å®Ÿè¡Œã™ã‚‹ã€‚
ã“ã®æŠ€æ³•ã¯ã€ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ã®æœ‰åŠ¹æ´»ç”¨ã‚’ã¨ã¦ã‚‚å¢—é€²ã•ã›ã‚‹ã®ã ãŒã€é€æ¬¡çš„ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®æŒ¯ã‚‹èˆã„ã‚’ä¿æŒã—ã¤ã¤ã€é€æ¬¡çš„ãªå‘½ä»¤åˆ—ã®å®Ÿè¡Œã‚’é«˜é€ŸåŒ–ã™ã‚‹ãŸã‚ã ã‘ã«ä½¿ã‚ã‚Œã¦ã„ã‚‹ã€‚</p>

<p class="orig" lang="en"><a name="footnote_Temp_406" href="#call_footnote_Temp_406"><sup><small>35</small></sup></a> To quote some graffiti seen on a Cambridge
<a name="%_idx_3586"></a>building wall: ``Time is a device that was invented to keep everything
from happening at once.''

</p>

<p class="trans" lang="ja">
ã‚±ãƒ³ãƒ–ãƒªãƒƒã‚¸ã®å»ºç‰©ã®å£ã«è¦‹ã‚‰ã‚Œã‚‹ã€ã‚ã‚‹è½æ›¸ãã‚’å¼•ç”¨ã™ã‚‹ã¨ã€ã€Œæ™‚é–“ã¨ã¯ã€ã™ã¹ã¦ã®ã‚‚ã®ãŒä¸€åº¦ã«èµ·ããªã„ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã«ç™ºæ˜ã•ã‚ŒãŸä»•æ›ã‘ã§ã‚ã‚‹ã€ã¨ã®ã“ã¨ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_407" href="#call_footnote_Temp_407"><sup><small>36</small></sup></a> An even worse failure for this system
could occur if the two <tt>set!</tt> operations attempt to change the
balance simultaneously, in which case the actual data appearing in
memory might end up being a random combination of the information
being written by the two processes.  Most computers have interlocks on
the primitive memory-write operations, which protect against such
simultaneous access.  Even this seemingly simple kind of protection,
however, raises implementation challenges in the design of
multiprocessing computers, where elaborate <a name="%_idx_3594"></a><em>cache-coherence</em>
protocols are required to ensure that the various processors will
maintain a consistent view of memory contents, despite the fact that
data may be replicated (``cached'') among the different processors to
increase the speed of memory access.
</p>

<p class="trans" lang="ja">
ã‚‚ã—ã€äºŒå›ã® <tt>set!</tt> æ“ä½œãŒã€æ®‹é«˜ã‚’åŒæ™‚ã«å¤‰æ›´ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ã€ã“ã®ã‚·ã‚¹ãƒ†ãƒ ã«ã¨ã£ã¦ã‚ˆã‚Šä¸€å±¤ã¾ãšã„å¤±æ•—ãŒã€èµ·ã“ã‚Šå¾—ã‚‹â€”â€”ãã®å ´åˆã€ãƒ¡ãƒ¢ãƒªå†…ã«ç¾ã‚Œã‚‹å®Ÿéš›ã®ãƒ‡ãƒ¼ã‚¿ã¯ã€æœ€çµ‚çš„ã«ã¯ã€äºŒã¤ã®ãƒ—ãƒ­ã‚»ã‚¹ã«ã‚ˆã£ã¦æ›¸ãè¾¼ã¾ã‚Œã‚‹æƒ…å ±ã®ãƒ©ãƒ³ãƒ€ãƒ ãªçµ„ã¿åˆã‚ã›ã€ã¨ã„ã†ã“ã¨ã«ãªã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã®ã ã€‚
ã»ã¨ã‚“ã©ã®ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã«ã¯ã€åŸå§‹çš„ãªãƒ¡ãƒ¢ãƒªæ›¸ãè¾¼ã¿æ“ä½œã«ã¤ã„ã¦ã®<ruby><rb>é€£å‹•æ©Ÿæ§‹</rb><rp> (</rp><rt>ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ­ãƒƒã‚¯</rt><rp>) </rp></ruby>ãŒã‚ã‚Šã€ãã‚Œã«ã‚ˆã£ã¦ã€ã“ã†ã„ã£ãŸåŒæ™‚ã‚¢ã‚¯ã‚»ã‚¹ã«å¯¾ã™ã‚‹ä¿è­·ã®å½¹ç›®ã‚’æœãŸã—ã¦ã„ã‚‹ã€‚
ã—ã‹ã—ã€ã“ã®è¦‹ãŸã¨ã“ã‚ã¯ç°¡ç´ ãªç¨®é¡ã®ä¿è­·ã§ã•ãˆã€ãƒãƒ«ãƒãƒ—ãƒ­ã‚»ã‚·ãƒ³ã‚°ãƒ»ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã®è¨­è¨ˆã«ãŠã‘ã‚‹å®Ÿè£…ä¸Šã®èª²é¡Œã‚’æèµ·ã™ã‚‹â€”â€”ãƒãƒ«ãƒãƒ—ãƒ­ã‚»ã‚·ãƒ³ã‚°ãƒ»ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã§ã¯ã€ãƒ¡ãƒ¢ãƒªã‚¢ã‚¯ã‚»ã‚¹ã®é€Ÿã•ã‚’å¢—ã™ãŸã‚ã«ã€ç•°ãªã‚‹ãƒ—ãƒ­ã‚»ãƒƒã‚µé–“ã§ãƒ‡ãƒ¼ã‚¿ãŒè¤‡è£½ã•ã‚Œã‚‹ï¼ˆã€Œã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚Œã‚‹ã€ï¼‰ã“ã¨ãŒã‚ã‚‹ã€ã¨ã„ã†äº‹å®Ÿã«ã‚‚ã‹ã‹ã‚ã‚‰ãšã€ãã‚Œã§ã‚‚ã€æ§˜ã€…ãªãƒ—ãƒ­ã‚»ãƒƒã‚µãŒã€ãƒ¡ãƒ¢ãƒªã®å†…å®¹ã«ã¤ã„ã¦ã®æ•´åˆæ€§ã®ã¨ã‚ŒãŸçœºã‚ã‚’ä¿ã¤ã“ã¨ã‚’ä¿è¨¼ã™ã‚‹ãŸã‚ã«ã€å…¥å¿µãª<em>ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ»ã‚³ãƒ’ãƒ¼ãƒ¬ãƒ³ã‚·</em>ãƒ»ãƒ—ãƒ­ãƒˆã‚³ãƒ«ãŒå¿…è¦ã¨ã•ã‚Œã‚‹ã®ã ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_409" href="#call_footnote_Temp_409"><sup><small>37</small></sup></a> The factorial program in
section <a href="20_sec3_1.html#%_sec_3.1.3">3.1.3</a> illustrates this for a single
sequential process.
</p>

<p class="trans" lang="ja">
<a href="20_sec3_1.html#%_sec_3.1.3">3.1.3</a>ç¯€ã®éšä¹—ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€å˜ä¸€ã®é€æ¬¡çš„ãƒ—ãƒ­ã‚»ã‚¹ã«ã¤ã„ã¦ã€ã“ã®ã“ã¨ã‚’ä¾‹ç¤ºã—ã¦ã„ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_410" href="#call_footnote_Temp_410"><sup><small>38</small></sup></a> The columns show the contents of Peter's wallet,
the joint account (in Bank1), Paul's wallet, and Paul's private account
(in Bank2), before and after each withdrawal (W) and deposit (D).
Peter withdraws $10 from Bank1; Paul deposits $5 in Bank2,
then withdraws $25 from Bank1.

</p>

<p class="trans" lang="ja">
ã“ã‚Œã‚‰ã®åˆ—ã¯ã€ãã‚Œãã‚Œã®å¼•ãå‡ºã— (W) ã¨é ã‘å…¥ã‚Œ (D) ã®å‰å¾Œã«ãŠã‘ã‚‹ã€ãƒ”ãƒ¼ã‚¿ãƒ¼ã®è²¡å¸ƒã€(éŠ€è¡Œãã®1ã®) å…±åŒå£åº§ã€ãƒãƒ¼ãƒ«ã®è²¡å¸ƒã€(éŠ€è¡Œãã®2ã®) ãƒãƒ¼ãƒ«ã®å€‹äººå£åº§ã€ã®ä¸­èº«ã‚’ç¤ºã—ã¦ã„ã‚‹ã€‚
ãƒ”ãƒ¼ã‚¿ãƒ¼ãŒã€éŠ€è¡Œãã®1ã‹ã‚‰10ãƒ‰ãƒ«ã‚’å¼•ãå‡ºã—ã€ãƒãƒ¼ãƒ«ãŒã€éŠ€è¡Œãã®2ã«5ãƒ‰ãƒ«ã‚’é ã‘å…¥ã‚Œã€ãã‚Œã‹ã‚‰ã€éŠ€è¡Œãã®1ã‹ã‚‰25ãƒ‰ãƒ«ã‚’å¼•ãå‡ºã™ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_411" href="#call_footnote_Temp_411"><sup><small>39</small></sup></a> A more formal way to express this idea is to say that
concurrent programs are inherently <a name="%_idx_3604"></a><em>nondeterministic</em>. That
is, they are described not by single-valued functions, but by
functions whose results are sets of possible values.  In
section <a href="28_sec4_3.html#%_sec_4.3">4.3</a> we will study a
language for expressing nondeterministic
computations.
</p>

<p class="trans" lang="ja">
ã“ã®è€ƒãˆã‚’è¡¨ã™ãŸã‚ã®ã€ã‚ˆã‚Šå½¢å¼çš„ãªæ–¹æ³•ã¯ã€ä¸¦è¡Œãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯å†…åœ¨çš„ã«<em>éæ±ºå®šçš„</em>ãªã®ã ã€ã¨è¿°ã¹ã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚
ã¤ã¾ã‚Šã€ä¸¦è¡Œãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€ä¸€ä¾¡é–¢æ•°ã«ã‚ˆã£ã¦ã¯è¨˜è¿°ã•ã‚Œã®ã§ã¯ãªãã€ã‚ã‚Šå¾—ã‚‹å€¤ã®é›†åˆã‚’ãã®çµæœã¨ã™ã‚‹ã‚ˆã†ãªé–¢æ•°ã«ã‚ˆã£ã¦ã€è¨˜è¿°ã•ã‚Œã‚‹ã®ã§ã‚ã‚‹ã€‚
<a href="28_sec4_3.html#%_sec_4.3">4.3</a>ã§ã¯ã€éæ±ºå®šçš„ãªè¨ˆç®—ã‚’è¡¨ç¾ã™ã‚‹ãŸã‚ã®è¨€èªã«ã¤ã„ã¦ç ”ç©¶ã—ã‚ˆã†ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_415" href="#call_footnote_Temp_415"><sup><small>40</small></sup></a> <tt>Parallel-execute</tt> is not part of standard Scheme, but
it can be implemented in MIT Scheme.  In our implementation, the
new concurrent processes also run concurrently with the original
Scheme process.  Also, in our implementation, the value returned
by <tt>parallel-execute</tt> is a special control object that can be used
to halt the newly created processes.
</p>

<p class="trans" lang="ja">
<tt>parallel-execute</tt> ã¯ã€æ¨™æº–çš„Schemeã®ä¸€éƒ¨ã§ã¯ãªã„ãŒã€MIT Schemeã§å®Ÿè£…ã§ãã‚‹ã€‚
ç§ãŸã¡ã®å®Ÿè£…ã§ã¯ã€æ–°ãŸãªä¸¦è¡Œãƒ—ãƒ­ã‚»ã‚¹ã‚‚ã€å…ƒã®Schemeãƒ—ãƒ­ã‚»ã‚¹ã¨ä¸¦è¡Œã«å®Ÿè¡Œã•ã‚Œã‚‹ã€‚
ã¾ãŸã€ç§ãŸã¡ã®å®Ÿè£…ã§ã¯ã€<tt>parallel-execute</tt> ã«ã‚ˆã‚Šè¿”ã•ã‚Œã‚‹å€¤ã¯ã€æ–°ãŸãªä½œæˆã•ã‚ŒãŸãƒ—ãƒ­ã‚»ã‚¹ã‚’åœæ­¢ã•ã›ã‚‹ã®ã«ä½¿ãˆã‚‹ã€ç‰¹æ®Šãªåˆ¶å¾¡ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_421" href="#call_footnote_Temp_421"><sup><small>41</small></sup></a> We have simplified <tt>exchange</tt> by exploiting the fact
that our <tt>deposit</tt> message accepts negative amounts.  (This is a
serious bug in our banking system!)
</p>

<p class="trans" lang="ja">
ç§ãŸã¡ã® <tt>deposit</tt> ã¨ã„ã†ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒè² ã®é‡ã‚’å—ã‘å…¥ã‚Œã‚‹ã€ã¨ã„ã†äº‹å®Ÿã‚’æ´»ç”¨ã™ã‚‹ã“ã¨ã§ã€ç§ãŸã¡ã¯ã€<tt>exchange</tt> ã‚’ç°¡å˜åŒ–ã—ãŸã€‚
(ã“ã‚Œã¯ã€ç§ãŸã¡ã®éŠ€è¡Œã‚·ã‚¹ãƒ†ãƒ ã«ãŠã‘ã‚‹æ·±åˆ»ãªãƒã‚°ã§ã‚ã‚‹!)
</p>

<p class="orig" lang="en"><a name="footnote_Temp_422" href="#call_footnote_Temp_422"><sup><small>42</small></sup></a> If the account balances start out as $10,
$20, and $30, then after any number of concurrent exchanges, the
balances should still be $10, $20, and
$30 in some order.  Serializing the deposits to individual accounts is not
sufficient to guarantee this.  See exercise <a href="#%_thm_3.43">3.43</a>.

</p>

<p class="trans" lang="ja">
å£åº§æ®‹é«˜ãŒ10ãƒ‰ãƒ«ã€20ãƒ‰ãƒ«ã€30ãƒ‰ãƒ«ã§å§‹ã¾ã£ãŸå ´åˆã€ä¸¦è¡Œãªäº¤æ›ã‚’ä½•å›ãŠã“ãªã£ãŸå¾Œã§ã‚‚ã€æ®‹é«˜ã¯ã€ä½•ã‚‰ã‹ã®é †åºã«ãŠã„ã¦ã€ä¾ç„¶ã¨ã—ã¦10ãƒ‰ãƒ«ã€20ãƒ‰ãƒ«ã€30ãƒ‰ãƒ«ã¨ãªã‚‹ã¯ãšã ã€‚
å€‹åˆ¥ã®å£åº§ã¸ã®é ã‘å…¥ã‚Œã‚’ç›´åˆ—åŒ–ã™ã‚‹ã“ã¨ã¯ã€ã“ã‚Œã‚’ä¿è¨¼ã™ã‚‹ã®ã«ååˆ†ã§ã¯ãªã„ã€‚
ç·´ç¿’å•é¡Œ<a href="#%_thm_3.43">3.43</a>ã‚’å‚ç…§ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_423" href="#call_footnote_Temp_423"><sup><small>43</small></sup></a> Exercise <a href="#%_thm_3.45">3.45</a> investigates why
deposits and withdrawals are no longer automatically serialized
by the account.

</p>

<p class="trans" lang="ja">
ç·´ç¿’å•é¡Œ<a href="#%_thm_3.45">3.45</a>ã¯ã€ãªãœã€é ã‘å…¥ã‚Œã¨å¼•ãå‡ºã—ãŒã€ã‚‚ã¯ã‚„è‡ªå‹•çš„ã«å£åº§ã«ã‚ˆã£ã¦ç›´åˆ—åŒ–ã•ã‚Œãªã„ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’ç ”ç©¶ã—ã¦ã„ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_428" href="#call_footnote_Temp_428"><sup><small>44</small></sup></a> The term ``mutex'' is an abbreviation for <a name="%_idx_3646"></a><em>mutual
exclusion</em>.  The general problem of arranging a mechanism that permits
concurrent processes to safely share resources is called the mutual
exclusion problem.  Our mutex is a simple variant of the <a name="%_idx_3648"></a><em>semaphore</em> mechanism (see exercise <a href="#%_thm_3.47">3.47</a>), which was
introduced in the <a name="%_idx_3650"></a>``THE'' Multiprogramming System developed at the
<a name="%_idx_3652"></a>Technological University of Eindhoven and named for the university's
initials in Dutch (Dijkstra 1968a).  The acquire and
release operations were originally called <a name="%_idx_3654"></a><a name="%_idx_3656"></a><a name="%_idx_3658"></a>P and V, from the Dutch
words <em>passeren</em> (to pass) and <em>vrijgeven</em> (to release), in
reference to the semaphores used on railroad systems.  Dijkstra's
classic exposition (1968b) was one of the first to clearly present the
issues of concurrency control, and showed how to use semaphores to
handle a variety of concurrency problems.
</p>

<p class="trans" lang="ja">
ã€ŒãƒŸãƒ¥ãƒ¼ãƒ†ãƒƒã‚¯ã‚¹ã€ã¨ã„ã†ç”¨èªã¯ã€<em>ç›¸äº’æ’ä»–</em>ã®ç•¥èªã§ã‚ã‚‹ã€‚
ä¸¦è¡Œã¯ãƒ—ãƒ­ã‚»ã‚¹ãŒå®‰å…¨ã«è³‡æºã‚’å…±æœ‰ã™ã‚‹ã“ã¨ã‚’è¨±ã™ä»•çµ„ã¿ã‚’æ•´ãˆã‚‹ã“ã¨ã®ä¸€èˆ¬çš„ãªå•é¡Œã¯ã€ç›¸äº’æ’ä»–å•é¡Œã¨å‘¼ã°ã‚Œã‚‹ã€‚
ç§ãŸã¡ã®ãƒŸãƒ¥ãƒ¼ãƒ†ãƒƒã‚¯ã‚¹ã¯ã€<em>ã‚»ãƒãƒ•ã‚©</em>ã®ä»•çµ„ã¿ (ç·´ç¿’å•é¡Œ<a href="#%_thm_3.47">3.47</a> ã‚’å‚ç…§) â€”â€”ã‚¢ã‚¤ãƒ³ãƒˆãƒ›ãƒ¼ãƒ•ã‚§ãƒ³å·¥ç§‘å¤§å­¦ã§é–‹ç™ºã•ã‚Œã¦ã‚ªãƒ©ãƒ³ãƒ€èªã§ã®å½“è©²å¤§å­¦ã®é ­æ–‡å­—ã«ã¡ãªã‚“ã§åä»˜ã‘ã‚‰ã‚ŒãŸã€ã€ŒTHEã€ãƒãƒ«ãƒãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ãƒ»ã‚·ã‚¹ãƒ†ãƒ  (Dijkstra 1968a) ã§å°å…¥ã•ã‚ŒãŸâ€”â€”ã®ç°¡æ½”ãªå¤‰ç¨®ã§ã‚ã‚‹ã€‚
ç²å¾—ã¨è§£æ”¾ã®æ“ä½œã¯ã€å…ƒã¯ã€é‰„é“ã‚·ã‚¹ãƒ†ãƒ ã«ä½¿ã‚ã‚ŒãŸ<ruby><rb>è…•æœ¨ä¿¡å·æ©Ÿ</rb><rp> (</rp><rt>ã‚»ãƒãƒ•ã‚©</rt><rp>) </rp></ruby>ã‚’å‚ç…§ã—ã¦ã€ã‚ªãƒ©ãƒ³ãƒ€èªã® <em class="en">passeren</em> (é€šéã™ã‚‹) ã¨ <em class="en">vrijgeven</em> (è§£æ”¾ã™ã‚‹) ã‹ã‚‰ã€Pã¨Vã¨å‘¼ã°ã‚ŒãŸã€‚
ãƒ€ã‚¤ã‚¯ã‚¹ãƒˆãƒ©ã®å¤å…¸çš„è§£èª¬ (1968b) ã¯ã€ä¸¦è¡Œæ€§åˆ¶å¾¡ã®è«–ç‚¹ã‚’æ˜ç¢ºã«æç¤ºã—ãŸæœ€åˆæœŸã®ã‚‚ã®ã®ä¸€ã¤ã§ã‚ã‚Šã€æ§˜ã€…ãªä¸¦è¡Œæ€§ã®å•é¡Œã‚’æ‰±ã†ã®ã«ã‚»ãƒãƒ•ã‚©ã‚’ã©ã†ä½¿ã†ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’ç¤ºã—ãŸã€‚

</p>

<p class="orig" lang="en"><a name="footnote_Temp_429" href="#call_footnote_Temp_429"><sup><small>45</small></sup></a> In most
time-shared operating systems, processes that are <a name="%_idx_3664"></a>blocked by a mutex do
<a name="%_idx_3666"></a>not waste time ``busy-waiting'' as above.  Instead, the system
schedules another process to run while the first is waiting, and the blocked
process is awakened when the mutex becomes available.

</p>

<p class="trans" lang="ja">
ã»ã¨ã‚“ã©ã®æ™‚åˆ†å‰²å¼ã®ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒ»ã‚·ã‚¹ãƒ†ãƒ ã§ã¯ã€ãƒŸãƒ¥ãƒ¼ãƒ†ãƒƒã‚¯ã‚¹ã«ã‚ˆã£ã¦é˜»æ­¢ã•ã‚Œã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã¯ã€ä¸Šè¨˜ã®ã‚ˆã†ã«ã€Œãƒ“ã‚¸ãƒ¼ãƒ»ã‚¦ã‚§ã‚¤ãƒ†ã‚£ãƒ³ã‚°ã€ã§æ™‚é–“ã‚’ç„¡é§„ã«ã™ã‚‹ã‚ã‘ã§ã¯ãªã„ã€‚
ä»£ã‚ã‚Šã«ã€ã‚·ã‚¹ãƒ†ãƒ ã¯ã€ç¬¬ä¸€ã®ãƒ—ãƒ­ã‚»ã‚¹ãŒå¾…ã£ã¦ã„ã‚‹é–“ã«ã€åˆ¥ã®ãƒ—ãƒ­ã‚»ã‚¹ã‚’å®Ÿè¡Œã™ã‚‹ã‚ˆã†ã«äºˆå®šã‚’çµ„ã¿ã€é˜»æ­¢ã•ã‚ŒãŸãƒ—ãƒ­ã‚»ã‚¹ã¯ã€ãƒŸãƒ¥ãƒ¼ãƒ†ãƒƒã‚¯ã‚¹ãŒåˆ©ç”¨å¯èƒ½ã«ãªã£ãŸæ™‚ã«èµ·ã“ã•ã‚Œã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_430" href="#call_footnote_Temp_430"><sup><small>46</small></sup></a> In MIT Scheme for a single processor, which uses a time-slicing
model, <tt>test-and-set!</tt> can be implemented as follows:
<a name="%_idx_3676"></a><a name="%_idx_3678"></a></p>

<p class="trans" lang="ja">
å˜ä¸€ãƒ—ãƒ­ã‚»ãƒƒã‚µç”¨ã®MIT Schemeâ€”â€”ã‚¿ã‚¤ãƒ ãƒ»ã‚¹ãƒ©ã‚¤ã‚·ãƒ³ã‚°ãƒ»ãƒ¢ãƒ‡ãƒ«ã‚’ä½¿ã†â€”â€”ã§ã¯ã€<tt>test-and-set!</tt> ã‚’ä»¥ä¸‹ã®ã‚ˆã†ã«å®Ÿè£…ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_3680"></a>(define (test-and-set! cell)
  (without-interrupts
   (lambda ()
     (if (car cell)
         true
         (begin (set-car! cell true)
                false)))))
</p>


<p class="orig" lang="en">
<tt>Without-interrupts</tt> disables
time-slicing interrupts while its procedure argument is being executed.

</p>

<p class="trans" lang="ja">
<tt>without-interrupts</tt> ã¯ã€è‡ªåˆ†ã¸ã®æ‰‹ç¶šãå¼•æ•°ãŒå®Ÿè¡Œã•ã‚Œã¦ã„ã‚‹é–“ã¯ã€ã‚¿ã‚¤ãƒ ãƒ»ã‚¹ãƒ©ã‚¤ã‚·ãƒ³ã‚°ã®å‰²ã‚Šè¾¼ã¿ã‚’ç„¡åŠ¹åŒ–ã™ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_431" href="#call_footnote_Temp_431"><sup><small>47</small></sup></a> There are many variants of such
<a name="%_idx_3682"></a>instructions -- including test-and-set, test-and-clear, swap,
compare-and-exchange, load-reserve, and store-conditional -- whose
design must be carefully matched to the machine's processor-memory
interface.
One issue that arises here is to determine what happens
if two processes attempt to acquire the same resource
at exactly the same time by using such an instruction.
This requires some mechanism
for making a decision about which process gets control.  Such a
mechanism is called an <a name="%_idx_3684"></a><em>arbiter</em>.  Arbiters usually boil down to
some sort of hardware device.
Unfortunately, it is possible to prove that one cannot physically
construct a fair arbiter that works 100% of the time unless one
allows the arbiter an arbitrarily long time to make its decision.  The
fundamental phenomenon here was originally observed by the fourteenth-century
French philosopher <a name="%_idx_3686"></a>Jean Buridan in his commentary on
<a name="%_idx_3688"></a>Aristotle's <i>De caelo</i>.  Buridan argued that a perfectly rational
<a name="%_idx_3690"></a>dog placed between two equally attractive sources of food will starve
to death, because it is incapable of deciding which to go to first.
</p>

<p class="trans" lang="ja">
ãã†ã„ã†å‘½ä»¤ã®å¤šãã®å¤‰ç¨®â€”â€”<ruby><rb>èª¿ã¹ã¦è¨­å®š</rb><rp> (</rp><rt>test-and-set</rt><rp>) </rp></ruby>ã€<ruby><rb>èª¿ã¹ã¦ã‚¯ãƒªã‚¢</rb><rp> (</rp><rt>test-and-clear</rt><rp>) </rp></ruby>ã€<ruby><rb>å…¥ã‚Œæ›¿ãˆ</rb><rp> (</rp><rt>swap</rt><rp>) </rp></ruby>ã€<ruby><rb>æ¯”ã¹ã¦äº¤æ›</rb><rp> (</rp><rt>compare-and-exchange</rt><rp>) </rp></ruby>ã€<ruby><rb>ãƒ­ãƒ¼ãƒ‰ã—ã¦äºˆç´„</rb><rp> (</rp><rt>load-reserve</rt><rp>) </rp></ruby>ã€<ruby><rb>æ¡ä»¶ã¤ãã‚¹ãƒˆã‚¢</rb><rp> (</rp><rt>store-conditional</rt><rp>) </rp></ruby>ãªã©ã‚’å«ã‚€â€”â€”ãŒã‚ã‚‹ã€‚
ã“ã“ã§æŒã¡ä¸ŠãŒã‚‹ä¸€ã¤ã®å•é¡Œã¯ã€ãã†ã—ãŸå‘½ä»¤ã‚’ç”¨ã„ã¦ã€äºŒã¤ã®ãƒ—ãƒ­ã‚»ã‚¹ãŒã€ã´ã£ãŸã‚ŠåŒæ™‚ã«åŒã˜è³‡æºã‚’ç²å¾—ã—ã‚ˆã†ã¨è©¦ã¿ãŸã‚‰ã€ä½•ãŒèµ·ã“ã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’æ±ºã‚ã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚
ã“ã‚Œã«ã¯ã€ã©ã¡ã‚‰ã®ãƒ—ãƒ­ã‚»ã‚¹ãŒæ”¯é…æ¨©ã‚’æ¡ã‚‹ã®ã‹ã«ã¤ã„ã¦ã®æ±ºå®šã‚’ä¸‹ã™ãŸã‚ã®ã€ä½•ã‚‰ã‹ã®ä»•çµ„ã¿ãŒå¿…è¦ã ã€‚
ãã†ã—ãŸä»•çµ„ã¿ã¯ã€<em>èª¿åœå™¨</em>ã¨å‘¼ã°ã‚Œã‚‹ã€‚
æ™®é€šã¯ã€èª¿åœå™¨ã¯ã€ã¤ã¾ã‚‹ã¨ã“ã‚ã‚ã‚‹ç¨®ã®ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢è£…ç½®ã«ãªã‚‹ã€‚
ã—ã‹ã—ã‚ã„ã«ãã€æ±ºå®šã‚’ä¸‹ã™ãŸã‚ã®ä»»æ„ã«é•·ã„æ™‚é–“ã‚’èª¿åœå™¨ã«è¨±ã™ã®ã§ãªã„é™ã‚Šã€100%ã®æ™‚é–“ã¡ã‚ƒã‚“ã¨å‹•ãå…¬å¹³ãªèª¿åœå™¨ã‚’ç‰©ç†çš„ã«æ§‹ç¯‰ã™ã‚‹ã“ã¨ã¯ã§ããªã„ã€ã¨ã„ã†ã“ã¨ã‚’è¨¼æ˜ã§ãã¦ã—ã¾ã†ã®ã ã€‚
ã“ã“ã§ã®æ ¹æºçš„ãªç¾è±¡ã¯ã€ã‚‚ã¨ã‚‚ã¨ã¯14ä¸–ç´€ã®ãƒ•ãƒ©ãƒ³ã‚¹ã®å“²å­¦è€…ã®ã‚¸ãƒ£ãƒ³ãƒ»ãƒ“ãƒ¥ãƒªãƒ€ãƒ³ã«ã‚ˆã‚Šã€ã‚¢ãƒªã‚¹ãƒˆãƒ†ãƒ¬ã‚¹ã®ã€å¤©ä½“è«–ã€ã«ã¤ã„ã¦ã®å½¼ã®è«–è©•ã®ä¸­ã§ã€è¦³å¯Ÿã•ã‚ŒãŸã€‚
äºŒã¤ã®ç­‰ä¾¡ã«é­…åŠ›çš„ãªé¤Œã®æºã®é–“ã«ç½®ã‹ã‚ŒãŸã€å®Œå…¨ã«ç†æ€§çš„ãªçŠ¬ã¯ã€ã©ã¡ã‚‰ã«æœ€åˆã«è¡Œãã¹ãã‹ã‚’æ±ºã‚ã‚‹ã“ã¨ãŒã§ããªã„ã›ã„ã§ã€é£¢ãˆæ­»ã«ã™ã‚‹ã ã‚ã†ã€ã¨ãƒ“ãƒ¥ãƒªãƒ€ãƒ³ã¯è«–ã˜ãŸ
<span class="note"> (ã‚ã‚Œã€ã“ã‚Œã£ã¦ãƒ“ãƒ¥ãƒªãƒ€ãƒ³ã®é©¢é¦¬ã®ã“ã¨ã ã‚ˆã­? çŠ¬ãªã®?)</span>ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_435" href="#call_footnote_Temp_435"><sup><small>48</small></sup></a> The general technique for avoiding deadlock by numbering the
<a name="%_idx_3700"></a>shared resources and acquiring them in order is due to <a name="%_idx_3702"></a><a name="%_idx_3704"></a><a name="%_idx_3706"></a>Havender
(1968).  Situations where deadlock cannot be avoided require <em>deadlock-recovery</em> methods, which entail having processes ``back out''
of the deadlocked state and try again.  Deadlock-recovery
mechanisms are widely used in database management systems, a topic that
is treated in detail in Gray and Reuter 1993.

</p>

<p class="trans" lang="ja">
å…±æœ‰è³‡æºã«ç•ªå·ã‚’ã¤ã‘ã€ãã‚Œã‚‰ã®å…±æœ‰è³‡æºã‚’é †ã«ç²å¾—ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯ã‚’å›é¿ã™ã‚‹ä¸€èˆ¬çš„æŠ€æ³•ã¯ã€Havender (1968) ã«ã‚ˆã‚‹ã‚‚ã®ã§ã‚ã‚‹ã€‚
ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯ã‚’å›é¿ã§ããªã„çŠ¶æ³ã§ã¯ã€<em>ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯ã‹ã‚‰ã®å›å¾©</em>æ–¹æ³•â€”â€”ãƒ—ãƒ­ã‚»ã‚¹ã«ã€ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯ã—ãŸçŠ¶æ…‹ã‹ã‚‰ã€Œæ‰‹ã‚’å¼•ã€ã‹ã›ã¦ã€å†åº¦æŒ‘æˆ¦ã•ã›ã‚‹ã“ã¨ã‚’ã€å¿…ç„¶çš„ã«ä¼´ã†â€”â€”ãŒå¿…è¦ã¨ãªã‚‹ã€‚
ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯ã‹ã‚‰ã®å›å¾©ã®ä»•çµ„ã¿ã¯ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã§åºƒãä½¿ã‚ã‚Œã¦ã„ã‚‹â€”â€”ã™ãªã‚ã¡ã€Gray and Reuter 1993 ã§è©³ç´°ã«æ‰±ã‚ã‚Œã¦ã„ã‚‹è©±é¡Œã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_439" href="#call_footnote_Temp_439"><sup><small>49</small></sup></a> One such alternative to serialization is called <a name="%_idx_3710"></a><em>barrier
synchronization</em>.  The programmer permits concurrent processes to
execute as they please, but establishes certain synchronization points
(``barriers'') through which no process can proceed until all the
processes have reached the barrier.  Modern processors provide machine
instructions that permit programmers to establish synchronization
points at places where consistency is required.  The <a name="%_idx_3712"></a>PowerPC<sup>
<em>T</em><em>M</em></sup>, for example, includes for this purpose two instructions called
<a name="%_idx_3714"></a>SYNC and <a name="%_idx_3716"></a>EIEIO (Enforced In-order Execution of Input/Output).

</p>

<p class="trans" lang="ja">
ç›´åˆ—åŒ–ã«å¯¾ã™ã‚‹ãã†ã—ãŸä»£æ›¿ç­–ã®ä¸€ã¤ã¯ã€<em>ãƒãƒªã‚¢åŒæœŸ</em>ã¨å‘¼ã°ã‚Œã‚‹ã€‚
ãƒ—ãƒ­ã‚°ãƒ©ãƒã¯ã€ä¸¦è¡Œãªãƒ—ãƒ­ã‚»ã‚¹ãŒå¥½ããªã‚ˆã†ã«å®Ÿè¡Œã™ã‚‹ã“ã¨ã‚’è¨±ã™ã®ã ãŒã€ã™ã¹ã¦ã®ãƒ—ãƒ­ã‚»ã‚¹ãŒãã®ãƒãƒªã‚¢ã«é”ã™ã‚‹ã¾ã§ã¯ã©ã®ãƒ—ãƒ­ã‚»ã‚¹ã‚‚ãã“ã‚’é€šéã—ã¦å…ˆã«é€²ã‚€ã“ã¨ã¯ã§ããªã„ã‚ˆã†ãªã€ã‚ã‚‹åŒæœŸãƒã‚¤ãƒ³ãƒˆï¼ˆã€Œãƒãƒªã‚¢ã€ï¼‰ã‚’è¨­ã‘ã‚‹ã€‚
è¿‘ä»£çš„ãªãƒ—ãƒ­ã‚»ãƒƒã‚µã¯ã€æ•´åˆæ€§ãŒæ±‚ã‚ã‚‰ã‚Œã‚‹å ´æ‰€ã«ãƒ—ãƒ­ã‚°ãƒ©ãƒãŒåŒæœŸãƒã‚¤ãƒ³ãƒˆã‚’è¨­ã‘ã‚‹ã“ã¨ã‚’å¯èƒ½ã¨ã™ã‚‹ãƒã‚·ãƒ³å‘½ä»¤ã‚’ã€æä¾›ã—ã¦ã„ã‚‹ã€‚
ãŸã¨ãˆã°ã€PowerPC&trade;ã¯ã€ã“ã®ç›®çš„ã®ãŸã‚ã«ã€SYNC ãŠã‚ˆã³ EIEIO (Enforced In-order Execution of Input/Output: å¼·åˆ¶çš„ã«é †åºã©ãŠã‚Šã«è¡Œã†å…¥å‡ºåŠ›ã®å®Ÿè¡Œ) ã¨å‘¼ã°ã‚Œã‚‹äºŒã¤ã®å‘½ä»¤ã‚’å«ã‚“ã§ã„ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_440" href="#call_footnote_Temp_440"><sup><small>50</small></sup></a> This may seem like a strange point of view, but there are
<a name="%_idx_3718"></a>systems that work this way.  International charges to credit-card
accounts, for example, are normally cleared on a per-country basis,
and the charges made in different countries are periodically
reconciled.  Thus the account balance may be different in
different countries.

</p>

<p class="trans" lang="ja">
ã“ã‚Œã¯å¥‡å¦™ãªè¦‹æ–¹ã®ã‚ˆã†ã«è¦‹ãˆã‚‹ã‹ã‚‚ã—ã‚Œãªã„ãŒã€ã“ã†ã„ã†æ–¹æ³•ã§å‹•ãã‚·ã‚¹ãƒ†ãƒ ãŒã‚ã‚‹ã®ã ã€‚
ãŸã¨ãˆã°ã€ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆã‚«ãƒ¼ãƒ‰å£åº§ã¸ã®å›½éš›çš„ãªè«‹æ±‚ã¯ã€æ™®é€šã€å›½ã”ã¨ã«æ¸…ç®—ã•ã‚Œã€åˆ¥ã€…ã®å›½ã€…ã§ãªã•ã‚ŒãŸè«‹æ±‚åŒå£«ã«å¯¾ã—ã¦å®šæœŸçš„ã«å¸³å°»åˆã‚ã›ã®èª¿æ•´ãŒè¡Œã‚ã‚Œã‚‹ã€‚
ã‚ˆã£ã¦ã€å£åº§æ®‹é«˜ã¯ã€åˆ¥ã®å›½ã§ã¯ç•°ãªã£ã¦ã„ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_441" href="#call_footnote_Temp_441"><sup><small>51</small></sup></a> For distributed
systems, this perspective was pursued by <a name="%_idx_3722"></a>Lamport (1978), who showed how
to use communication to establish ``global clocks'' that can be used
to establish orderings on events in distributed systems.
</p>

<p class="trans" lang="ja">
åˆ†æ•£ã‚·ã‚¹ãƒ†ãƒ ã«ã¤ã„ã¦ã¯ã€ã“ã®è¦‹æ–¹ã¯ã€Lamport (1978) â€”â€”åˆ†æ•£ã‚·ã‚¹ãƒ†ãƒ ã«ãŠã‘ã‚‹ã‚¤ãƒ™ãƒ³ãƒˆåŒå£«ã«å¯¾ã™ã‚‹é †åºã‚’ç¢ºç«‹ã™ã‚‹ã®ã«ä½¿ãˆã‚‹ã€ã€Œå¤§åŸŸçš„ãªæ™‚è¨ˆã€ã‚’ç¢ºç«‹ã™ã‚‹ãŸã‚ã«ã€é€šä¿¡ã‚’ã©ã†ä½¿ã†ã®ã‹ã€ã‚’ç¤ºã—ãŸâ€”â€”ã«ã‚ˆã£ã¦è¿½æ±‚ã•ã‚ŒãŸã€‚
</p>


</div>
</body>
</html>
