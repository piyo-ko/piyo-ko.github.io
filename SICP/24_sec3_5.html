<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="sicp.css" type="text/css">
<base target="_top">
<title>SICPç§è¨³: 3.5 ã‚¹ãƒˆãƒªãƒ¼ãƒ </title>
<link rel="canonical" href="https://piyo-ko.github.io/SICP/24_sec3_5.html" />
</head>
<body>

<div class="idx-bar">
<nav>
<a href="https://twitter.com/share" class="twitter-share-button" data-lang="ja">ãƒ„ã‚¤ãƒ¼ãƒˆ</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
<span class="status">æ¨æ•²å¾…ã¡</span>
[
<a href="00_cover.html">å…ˆé ­ã¸</a> |
<a href="23_sec3_4.html">å‰ã¸</a> |
<a href="25_chap4.html">æ¬¡ã¸</a> |
<a href="04_toc.html#%_toc_start">ç›®æ¬¡</a> |
<a href="38_index.html#%_index_start">ç´¢å¼•</a>
] [<a href="99_about.html">ã“ã®å¯¾è¨³ç‰ˆã«ã¤ã„ã¦</a> | <a href="../index.html">ãƒ›ãƒ¼ãƒ </a>]
[
Â§<a href="#%_sec_3.5">3.5</a>
Â§<a href="#%_sec_3.5.1">3.5.1</a>
ğŸ“š<a href="#%_sec_Temp_447">&hellip;</a>
ğŸ“š<a href="#%_sec_Temp_449">&hellip;</a>
ğŸ“<a href="#%_thm_3.50">3.50</a>
ğŸ“<a href="#%_thm_3.51">3.51</a>
ğŸ“<a href="#%_thm_3.52">3.52</a>
Â§<a href="#%_sec_3.5.2">3.5.2</a>
ğŸ¨<a href="#%_fig_3.31">3.31</a>
ğŸ“š<a href="#%_sec_Temp_457">&hellip;</a>
ğŸ“<a href="#%_thm_3.53">3.53</a>
ğŸ“<a href="#%_thm_3.54">3.54</a>
ğŸ“<a href="#%_thm_3.55">3.55</a>
ğŸ“<a href="#%_thm_3.56">3.56</a>
ğŸ“<a href="#%_thm_3.57">3.57</a>
ğŸ“<a href="#%_thm_3.58">3.58</a>
ğŸ“<a href="#%_thm_3.59">3.59</a>
ğŸ“<a href="#%_thm_3.60">3.60</a>
ğŸ“<a href="#%_thm_3.61">3.61</a>
ğŸ“<a href="#%_thm_3.62">3.62</a>
Â§<a href="#%_sec_3.5.3">3.5.3</a>
ğŸ“š<a href="#%_sec_Temp_471">&hellip;</a>
ğŸ“<a href="#%_thm_3.63">3.63</a>
ğŸ“<a href="#%_thm_3.64">3.64</a>
ğŸ“<a href="#%_thm_3.65">3.65</a>
ğŸ“š<a href="#%_sec_Temp_476">&hellip;</a>
ğŸ“<a href="#%_thm_3.66">3.66</a>
ğŸ“<a href="#%_thm_3.67">3.67</a>
ğŸ“<a href="#%_thm_3.68">3.68</a>
ğŸ“<a href="#%_thm_3.69">3.69</a>
ğŸ“<a href="#%_thm_3.70">3.70</a>
ğŸ“<a href="#%_thm_3.71">3.71</a>
ğŸ“<a href="#%_thm_3.72">3.72</a>
ğŸ“š<a href="#%_sec_Temp_489">&hellip;</a>
ğŸ¨<a href="#%_fig_3.32">3.32</a>
ğŸ“<a href="#%_thm_3.73">3.73</a>
ğŸ¨<a href="#%_fig_3.33">3.33</a>
ğŸ“<a href="#%_thm_3.74">3.74</a>
ğŸ“<a href="#%_thm_3.75">3.75</a>
ğŸ“<a href="#%_thm_3.76">3.76</a>
Â§<a href="#%_sec_3.5.4">3.5.4</a>
ğŸ¨<a href="#%_fig_3.34">3.34</a>
ğŸ“<a href="#%_thm_3.77">3.77</a>
ğŸ“<a href="#%_thm_3.78">3.78</a>
ğŸ¨<a href="#%_fig_3.35">3.35</a>
ğŸ“<a href="#%_thm_3.79">3.79</a>
ğŸ“<a href="#%_thm_3.80">3.80</a>
ğŸ¨<a href="#%_fig_3.36">3.36</a>
ğŸ¨<a href="#%_fig_3.37">3.37</a>
ğŸ“š<a href="#%_sec_Temp_499">&hellip;</a>
Â§<a href="#%_sec_3.5.5">3.5.5</a>
ğŸ“<a href="#%_thm_3.81">3.81</a>
ğŸ“<a href="#%_thm_3.82">3.82</a>
ğŸ“š<a href="#%_sec_Temp_503">&hellip;</a>
ğŸ¨<a href="#%_fig_3.38">3.38</a>
<a href="#footnotes">è„šæ³¨</a>
]
</nav>

</div>

<!--
$ curl -o ch3-Z-G-#1.gif https://mitpress.mit.edu/sicp/full-text/book/ch3-Z-G-[34-60].gif
$ curl -o book-Z-G-D-19.gif https://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-19.gif
-->

<div class="main-txt">
<a name="%_sec_3.5"></a>
<h2 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_3.5">3.5  Streams</a></h2>
<h2 class="trans" lang="ja">3.5 ã‚¹ãƒˆãƒªãƒ¼ãƒ </h2>

<p class="orig" lang="en">
<a name="%_idx_3726"></a>
We've gained a good understanding of assignment as a tool in modeling,
as well as an appreciation of the complex problems that assignment
raises. It is time to ask whether we could have gone about things in a
different way, so as to avoid some of these problems.  In this
section, we explore an alternative approach to modeling state, based
on data structures called <em>streams</em>.  As we shall see, streams can
mitigate some of the complexity of modeling state.</p>

<p class="trans" lang="ja">
ç§ãŸã¡ã¯ã€ãƒ¢ãƒ‡ãƒ«åŒ–ã«ãŠã‘ã‚‹æ‰‹æ®µã¨ã—ã¦ã®<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã«ã¤ã„ã¦ã€ã‚ˆãç†è§£ã—ãŸã—ã€ãã‚Œã¨ã¨ã‚‚ã«ã€<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ãŒæèµ·ã™ã‚‹è¤‡é›‘ãªå•é¡Œã‚‚ã€ãã¡ã‚“ã¨èªè­˜ã—ãŸã€‚
ä»Šã‚„ã€ã“ã‚Œã‚‰ã®å•é¡Œã‚’é¿ã‘ã‚‹ã‚ˆã†ã«ã€ç‰©äº‹ã«åˆ¥ã®æ–¹æ³•ã§å–ã‚Šçµ„ã‚€ã“ã¨ãŒã§ãå¾—ãŸã®ã‹ã©ã†ã‹ã€ã¨ã„ã†ã“ã¨ã‚’å•ã†ã¹ãã¨ãã§ã‚ã‚‹ã€‚
æœ¬ç¯€ã§ã¯ã€<em>ã‚¹ãƒˆãƒªãƒ¼ãƒ </em>ã¨å‘¼ã°ã‚Œã‚‹ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã«åŸºã¥ã„ã¦ã€çŠ¶æ…‹ã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã™ã‚‹ãŸã‚ã®ä»£æ›¿çš„æ‰‹æ³•ã‚’ã€æ¢æ±‚ã™ã‚‹ã€‚
ã“ã‚Œã‹ã‚‰è¦‹ã‚‹ã“ã¨ã«ãªã‚‹ã¨ãŠã‚Šã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¯ã€çŠ¶æ…‹ã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã™ã‚‹ã“ã¨ã®è¤‡é›‘ã•ã®ã†ã¡ã®ã„ãã°ãã‹ã‚’ã€ã‚„ã‚ã‚‰ã’ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
</p>

<p class="orig" lang="en">
Let's step back and review where this complexity comes from.  In an
attempt to model real-world phenomena, we made some apparently
reasonable decisions: We modeled real-world objects with local state
by computational objects with local variables.  We identified time
variation in the real world with time variation in the computer.  We
implemented the time variation of the states of the model objects in
the computer with assignments to the local variables of the model
objects.</p>

<p class="trans" lang="ja">
ã“ã®è¤‡é›‘ã•ã®<ruby><rb>å› </rb><rp> (</rp><rt>ã‚ˆ</rt><rp>) </rp></ruby>ã£ã¦<ruby><rb>æ¥</rb><rp> (</rp><rt>ããŸ</rt><rp>) </rp></ruby>ã‚‹ã¨ã“ã‚ã¾ã§æˆ»ã£ã¦ã€ãã“ã‚’å†æ¤œè¨ã—ã‚ˆã†ã€‚
ç¾å®Ÿä¸–ç•Œã®ç¾è±¡ã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã—ã‚ˆã†ã¨ã„ã†è©¦ã¿ã«ãŠã„ã¦ã€ç§ãŸã¡ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ã€ä¸€è¦‹ã—ãŸã¨ã“ã‚ã¯ç†ã«ã‹ãªã£ãŸã€ã„ãã¤ã‹ã®æ±ºå®šã‚’ä¸‹ã—ãŸã€‚
ç§ãŸã¡ã¯ã€å±€æ‰€çŠ¶æ…‹ã®ã‚ã‚‹ã€å®Ÿä¸–ç•Œã®<ruby><rb>ç‰©</rb><rp> (</rp><rt>ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ</rt><rp>) </rp></ruby>ã‚’ã€å±€æ‰€å¤‰æ•°ã‚’æŒã£ãŸè¨ˆç®—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚ˆã‚Šã€ãƒ¢ãƒ‡ãƒ«åŒ–ã—ãŸã€‚
ç§ãŸã¡ã¯ã€ç¾å®Ÿä¸–ç•Œã«ãŠã‘ã‚‹æ™‚é–“å¤‰åŒ–ã‚’ã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã«ãŠã‘ã‚‹æ™‚é–“å¤‰åŒ–ã¨åŒä¸€è¦–ã—ãŸã€‚
ç§ãŸã¡ã¯ã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿å†…ã®ãƒ¢ãƒ‡ãƒ«ãƒ»ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®çŠ¶æ…‹ã®æ™‚é–“å¤‰åŒ–ã‚’ã€ãƒ¢ãƒ‡ãƒ«ãƒ»ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å±€æ‰€å¤‰æ•°ã¸ã®<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã‚’ä½¿ã£ã¦ã€å®Ÿè£…ã—ãŸã€‚
</p>

<p class="orig" lang="en">
Is there another approach?  Can we avoid identifying time in the
computer with time in the modeled world?  Must we make the model
change with time in order to model phenomena in a changing world?
Think about the issue in terms of mathematical functions.  We can
describe the time-varying behavior of a quantity <em>x</em> as a function of
time <em>x</em>(<em>t</em>).  If we concentrate on <em>x</em> instant by instant, we think of
it as a changing quantity.  Yet if we concentrate on the entire
time history of values, we do not emphasize change -- the function
itself does not change.<a name="call_footnote_Temp_442" href="#footnote_Temp_442"><sup><small>52</small></sup></a></p>

<p class="trans" lang="ja">
ä»–ã®æ‰‹æ³•ãŒã‚ã‚‹ã ã‚ã†ã‹?
ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿å†…ã§ã®æ™‚é–“ã‚’ã€ãƒ¢ãƒ‡ãƒ«åŒ–ã•ã‚Œã‚‹ä¸–ç•Œã§ã®æ™‚é–“ã¨åŒä¸€è¦–ã™ã‚‹ã“ã¨ã¯ã€é¿ã‘ã‚‰ã‚Œã‚‹ã ã‚ã†ã‹?
å¤‰åŒ–ã—ã¤ã¤ã‚ã‚‹ä¸–ç•Œã«ãŠã‘ã‚‹ç¾è±¡ã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã™ã‚‹ãŸã‚ã«ã€æ™‚é–“ã¨ã¨ã‚‚ã«ãƒ¢ãƒ‡ãƒ«ã‚’å¤‰åŒ–ã•ã›ãªãã¦ã¯ãªã‚‰ãªã„ã®ã ã‚ã†ã‹?
æ•°å­¦çš„é–¢æ•°ã®è¦³ç‚¹ã‹ã‚‰ã€å•é¡Œã«ã¤ã„ã¦è€ƒãˆã‚ˆã†ã€‚
<em class="en">x</em> ã¨ã„ã†é‡ã®ã€çµŒæ™‚å¤‰åŒ–ã™ã‚‹æŒ¯ã‚‹èˆã„ã‚’ã€
<span class="math"><em class="en">x</em>(<em class="en">t</em>) </span>
ã¨ã„ã†æ™‚é–“ã®é–¢æ•°ã¨ã—ã¦è¨˜è¿°ã§ãã‚‹ã€‚
å„ç¬é–“ã”ã¨ã® <em class="en">x</em> ã«æ³¨æ„ã‚’é›†ä¸­ã•ã›ã‚‹å ´åˆã€ç§ãŸã¡ã¯ã€<em class="en">x</em> ã‚’ã€å¤‰åŒ–ã™ã‚‹é‡ã ã¨è¦‹ãªã™ã€‚
ãã‚Œã§ã‚‚ã€å€¤ã®å…¨æ™‚é–“ã«ã‚ãŸã‚‹å±¥æ­´ã«æ³¨æ„ã‚’é›†ä¸­ã•ã›ã‚‹å ´åˆã€ç§ãŸã¡ã¯ã€å¤‰åŒ–ã‚’é‡è¦è¦–ã—ãªã„â€”â€”é–¢æ•°è‡ªä½“ã¯å¤‰åŒ–ã—ãªã„ã®ã <a href="#footnote_Temp_442"><sup><small>52</small></sup></a>ã€‚
</p>

<p class="orig" lang="en">
If time is measured in discrete steps, then we can model a time function as
a (possibly infinite) sequence.  In this section, we will see how to
model change in terms of sequences that represent the time histories
of the systems being modeled.  To accomplish this, we introduce new
data structures called <em>streams</em>.  From an abstract point of view,
a stream is simply a sequence.  However, we will find that the
straightforward implementation of streams as lists (as in
section <a href="15_sec2_2.html#%_sec_2.2.1">2.2.1</a>) doesn't fully reveal
the power of stream processing.  As an alternative, we introduce the
technique of <a name="%_idx_3730"></a><em>delayed evaluation</em>, which enables us to represent
very large (even infinite) sequences as streams.</p>

<p class="trans" lang="ja">
ã‚‚ã—æ™‚é–“ãŒé›¢æ•£çš„ãªå¹…ã§è¨ˆæ¸¬ã•ã‚Œã‚‹ãªã‚‰ã€æ™‚é–“é–¢æ•°ã‚’ï¼ˆã²ã‚‡ã£ã¨ã™ã‚‹ã¨ç„¡é™ã®ï¼‰æ•°åˆ—ã¨ã—ã¦ãƒ¢ãƒ‡ãƒ«åŒ–ã§ãã‚‹ã€‚
æœ¬ç¯€ã§ã¯ã€ãƒ¢ãƒ‡ãƒ«åŒ–ã•ã‚Œã¦ã„ã‚‹ã‚·ã‚¹ãƒ†ãƒ ã®æ™‚é–“å±¥æ­´ã‚’è¡¨ã™æ•°åˆ—ã®è¦³ç‚¹ã‹ã‚‰ã€å¤‰åŒ–ã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã™ã‚‹æ–¹æ³•ã‚’ã€è¦‹ã‚‹ã“ã¨ã«ã—ã‚ˆã†ã€‚
ã“ã‚Œã‚’é”æˆã™ã‚‹ãŸã‚ã«ã€<em>ã‚¹ãƒˆãƒªãƒ¼ãƒ </em>ã¨å‘¼ã°ã‚Œã‚‹æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’å°å…¥ã™ã‚‹ã€‚
æŠ½è±¡çš„ãªè¦–ç‚¹ã‹ã‚‰è¨€ã†ã¨ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¯å˜ç´”ã«åˆ—ã§ã‚ã‚‹ã€‚
ã—ã‹ã—ã€<!--ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ãƒªã‚¹ãƒˆã¨ã—ã¦åˆ†ã‹ã‚Šã‚„ã™ãå®Ÿè£…ã™ã‚‹ã“ã¨-->ï¼ˆ<a href="15_sec2_2.html#%_sec_2.2.1">2.2.1</a>ç¯€ã®ã‚ˆã†ã«ï¼‰ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ãƒªã‚¹ãƒˆã¨ã™ã‚‹åˆ†ã‹ã‚Šã‚„ã™ã„å®Ÿè£…<!--ãƒªã‚¹ãƒˆã¨ã—ã¦ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®åˆ†ã‹ã‚Šã‚„ã™ã„å®Ÿè£…-->ã¯ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ å‡¦ç†ã®åŠ›ã‚’å®Œå…¨ã«æ˜ã‚‰ã‹ã«ã¯ã—ãªã„ã€‚
ãã®ä»£æ›¿ç­–ã¨ã—ã¦ã€<em>é…å»¶è©•ä¾¡</em>ã¨ã„ã†æŠ€æ³•â€”â€”ã“ã‚Œã«ã‚ˆã£ã¦ã€éå¸¸ã«é•·ã„åˆ—ï¼ˆç„¡é™åˆ—ã§ã•ãˆï¼‰ã‚‚ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¨ã—ã¦è¡¨ç¾ã§ãã‚‹ã‚ˆã†ã«ãªã‚‹â€”â€”ã‚’å°å…¥ã™ã‚‹ã€‚
</p>

<p class="orig" lang="en">
Stream processing lets us model systems that have state without ever
using assignment or mutable data.  This has important implications,
both theoretical and practical, because we can build models that avoid
the drawbacks inherent in introducing assignment.  On the other hand,
the stream framework raises difficulties of its own, and the question
of which modeling technique leads to more modular and more easily
maintained systems remains open.</p>

<p class="trans" lang="ja">
<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ãªã„ã—<ruby><rb>å¤‰æ›´å¯èƒ½</rb><rp> (</rp><rt>ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«</rt><rp>) </rp></ruby>ãªãƒ‡ãƒ¼ã‚¿ã‚’ã¾ã£ãŸãä½¿ã‚ãšã«ã€çŠ¶æ…‹ã‚’æŒã¤ã‚·ã‚¹ãƒ†ãƒ ã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã™ã‚‹ã“ã¨ãŒã€ã‚¹ãƒˆãƒªãƒ¼ãƒ å‡¦ç†ã«ã‚ˆã£ã¦å¯èƒ½ã¨ãªã‚‹ã€‚
ã“ã®ã“ã¨ã¯ã€ç†è«–ä¸Šã¨å®Ÿç”¨ä¸Šã®åŒæ–¹ã®é¢ã§ã€é‡è¦ãªå«ã¿ã‚’æŒã¤â€”â€”ã¨ã„ã†ã®ã‚‚ã€<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã‚’æŒã¡è¾¼ã‚€ã“ã¨ã«ã¤ãã‚‚ã®ã®æ¬ ç‚¹ã‚’å›é¿ã™ã‚‹ãƒ¢ãƒ‡ãƒ«ã‚’æ§‹ç¯‰ã§ãã‚‹ã‹ã‚‰ã§ã‚ã‚‹ã€‚
ä¸€æ–¹ã§ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®æ çµ„ã¯ã€ãã‚Œè‡ªèº«ã«ç‰¹æœ‰ã®é›£ã—ã•ã‚’æç¤ºã™ã‚‹ã—ã€ãã‚Œã«ã€ã©ã®ãƒ¢ãƒ‡ãƒ«åŒ–æŠ€æ³•ãŒã€ã‚ˆã‚Šãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ€§ãŒã‚ã£ã¦ã‚ˆã‚Šç°¡å˜ã«ä¿å®ˆã•ã‚Œã‚‹ã‚·ã‚¹ãƒ†ãƒ ã«ã¤ãªãŒã‚‹ã®ã‹ã€ã¨ã„ã†ç–‘å•ã¯ã€æœªè§£æ±ºã®ã¾ã¾ã§ã‚ã‚‹ã€‚
</p>


<a name="%_sec_3.5.1"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_3.5.1">3.5.1  Streams Are Delayed Lists</a></h3>
<h3 class="trans" lang="ja">3.5.1 ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¯é…å»¶ã•ã‚ŒãŸãƒªã‚¹ãƒˆã </h3>

<p class="orig" lang="en">
<a name="%_idx_3732"></a>
As we saw in section <a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a>,
sequences can serve as standard interfaces for combining program
modules.  We formulated powerful abstractions for manipulating
sequences, such as <tt>map</tt>, <tt>filter</tt>, and <tt>accumulate</tt>, that
capture a wide variety of operations in a manner that is both succinct
and elegant.</p>

<p class="trans" lang="ja">
<a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a>ç¯€ã§è¦‹ãŸã¨ãŠã‚Šã€åˆ—ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åŒå£«ã‚’çµåˆã™ã‚‹ãŸã‚ã®æ¨™æº–çš„ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ã‚¤ã‚¹ã¨ã—ã¦æ©Ÿèƒ½ã§ãã‚‹ã€‚
ç°¡æ½”ã§ã‚‚ã‚ã‚Šæ´—ç·´ã•ã‚Œã¦ã‚‚ã„ã‚‹ã‚ˆã†ãªã‚„ã‚Šæ–¹ã§åºƒç¯„å›²ã®æ¼”ç®—ã‚’æ•ã¾ãˆã‚‹ã€<tt>map</tt> ã‚„ <tt>filter</tt> ã‚„ <tt>accumulate</tt> ãªã©ã¨ã„ã£ãŸã€åˆ—æ“ä½œç”¨ã®å¼·åŠ›ãªæŠ½è±¡åŒ–ã‚’ã€ç§ãŸã¡ã¯å®šå¼åŒ–ã—ãŸã€‚
</p>

<p class="orig" lang="en">
Unfortunately, if we represent sequences as lists, this elegance is
bought at the price of severe inefficiency with respect to both the
time and space required by our computations.
When we represent manipulations on sequences as transformations
of lists, our programs must construct and copy data structures (which
may be huge) at every step of a process.</p>

<p class="trans" lang="ja">
ã—ã‹ã—ã‚ã„ã«ãã€åˆ—ã‚’ãƒªã‚¹ãƒˆã¨ã—ã¦è¡¨ç¾ã™ã‚‹å ´åˆã€ã“ã†ã—ãŸæ´—ç·´ã¯ã€è‡ªåˆ†ã®è¨ˆç®—ã«å¿…è¦ãªæ™‚é–“ã¨ç©ºé–“ã®åŒæ–¹ã«é–¢ã™ã‚‹ã²ã©ã„éåŠ¹ç‡æ€§ã€ã¨ã„ã†ä»£å„Ÿã®ã‚‚ã¨ã«ã€ã‚‚ãŸã‚‰ã•ã‚Œã‚‹ã®ã§ã‚ã‚‹ã€‚
åˆ—ã«å¯¾ã™ã‚‹æ¼”ç®—ã‚’ãƒªã‚¹ãƒˆã®å¤‰å½¢ã¨ã—ã¦è¡¨ç¾ã™ã‚‹ã¨ãã€ç§ãŸã¡ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€ï¼ˆå·¨å¤§ã‹ã‚‚ã—ã‚Œãªã„ï¼‰ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’ã€ãƒ—ãƒ­ã‚»ã‚¹ã®å…¨ã‚¹ãƒ†ãƒƒãƒ—ã«ãŠã„ã¦ã€æ§‹ç¯‰ãƒ»è¤‡è£½ã—ãªãã¦ã¯ãªã‚‰ãªã„ã€‚
</p>

<p class="orig" lang="en">
To see why this is true, let us compare two programs for computing the
sum of all the prime numbers in an interval.  The first program is
written in standard iterative style:<a name="call_footnote_Temp_443" href="#footnote_Temp_443"><sup><small>53</small></sup></a></p>

<p class="trans" lang="ja">
ã“ã‚ŒãŒãªãœæœ¬å½“ãªã®ã‹ã‚’è¦‹ã‚‹ãŸã‚ã«ã€ã‚ã‚‹åŒºé–“å†…ã®ã™ã¹ã¦ã®ç´ æ•°ã®å’Œã‚’è¨ˆç®—ã™ã‚‹ãŸã‚ã®äºŒã¤ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ¯”è¼ƒã—ã‚ˆã†ã€‚
ä¸€ç•ªç›®ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€æ¨™æº–çš„ãªåå¾©æ–¹å¼ã§æ›¸ã‹ã‚Œã¦ã„ã‚‹<a href="#footnote_Temp_443"><sup><small>53</small></sup></a>ã€‚
</p>

<p class="lisp"><a name="%_idx_3734"></a>(define (sum-primes a b)
  (define (iter count accum)
    (cond ((&gt; count b) accum)
          ((prime? count) (iter (+ count 1) (+ count accum)))
          (else (iter (+ count 1) accum))))
  (iter a 0))
</p>



<p class="orig" lang="en">
The second program performs the same computation using the sequence
operations of section <a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a>:</p>

<p class="trans" lang="ja">
äºŒç•ªç›®ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€ <a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a>ç¯€ã®åˆ—æ“ä½œã‚’ä½¿ã£ã¦ã€åŒã˜è¨ˆç®—ã‚’è¡Œã†ã€‚
</p>


<p class="lisp"><a name="%_idx_3736"></a>(define (sum-primes a b)
  (accumulate +
              0
              (filter prime? (enumerate-interval a b))))
</p>


<p class="orig" lang="en">
In carrying out the computation, the first program needs to store only
the sum being accumulated.  In contrast, the filter in the second
program cannot do any testing until <tt>enumerate-interval</tt> has
constructed a complete list of the numbers in the interval.  The
filter generates another list, which in turn is passed to <tt>accumulate</tt> before being collapsed to form a sum.  Such large
intermediate storage is not needed by the first program, which we can
think of as enumerating the interval incrementally, adding each prime
to the sum as it is generated.</p>

<p class="trans" lang="ja">
è¨ˆç®—ã‚’å®Ÿè¡Œã™ã‚‹éš›ã«ã€ä¸€ç•ªç›®ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€ç´¯ç©ã•ã‚Œã¦ã„ã‚‹å’Œã ã‘ã‚’è¨˜æ†¶ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
ãã‚Œã«å¯¾ã—ã¦ã€äºŒç•ªç›®ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ãŠã‘ã‚‹ãƒ•ã‚£ãƒ«ã‚¿ã¯ã€<tt>enumerate-interval</tt> ãŒåŒºé–“å†…ã®æ•°ã®å®Œå…¨ãªãƒªã‚¹ãƒˆã‚’æ§‹ç¯‰ã™ã‚‹ã¾ã§ã¯ã€ä½•ã®ãƒ†ã‚¹ãƒˆã‚‚ã§ããªã„ã€‚
ãƒ•ã‚£ãƒ«ã‚¿ã¯åˆ¥ã®ãƒªã‚¹ãƒˆã‚’æ§‹ç¯‰ã—ã€ä»Šåº¦ã¯ãã®ãƒªã‚¹ãƒˆãŒã€åœ§ç¸®ã•ã‚Œã¦å’Œã®å½¢ã‚’ã¨ã‚‹ã‚ˆã‚Šã‚‚å‰ã«ã€<tt>accumulate</tt> ã«æ¸¡ã•ã‚Œã‚‹ã€‚
ã“ã†ã—ãŸå·¨å¤§ã§ä¸­é–“çš„ãªæ ¼ç´ã¯ã€ä¸€ç•ªç›®ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ â€”â€”ç§ãŸã¡ã¯ã“ã‚Œã‚’ã€å½“è©²åŒºé–“ã‚’å°‘ã—ãšã¤æ•°ãˆã¦ã„ã£ã¦ã€å„ç´ æ•°ã‚’ã€ãã®ç´ æ•°ãŒç”Ÿæˆã•ã‚Œã‚‹ã¨ãã«å’Œã«åŠ ãˆã‚‹ã‚‚ã®ã ã€ã¨è¦‹ãªã›ã‚‹â€”â€”ã§ã¯ã€å¿…è¦ãŒãªã„ã€‚
</p>

<p class="orig" lang="en">
The inefficiency in using lists becomes painfully apparent if we use
the sequence paradigm to compute the second prime in the interval from
10,000 to 1,000,000 by evaluating the expression</p>

<p class="trans" lang="ja">
åˆ—ã®ãƒ‘ãƒ©ãƒ€ã‚¤ãƒ ã‚’ä½¿ã£ã¦ã€ä»¥ä¸‹ã®å¼ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€10,000 ã‹ã‚‰ 1,000,000 ã¾ã§ã®åŒºé–“ã®ã†ã¡ã§äºŒç•ªç›®ã®ç´ æ•°ã‚’è¨ˆç®—ã™ã‚‹ã¨ãã€ãƒªã‚¹ãƒˆã‚’ä½¿ã†éš›ã®éåŠ¹ç‡æ€§ã¯ã€ã„ã‚„ã«ãªã‚‹ã»ã©æ˜ã‚‰ã‹ã«ãªã‚‹ã€‚
</p>


<p class="lisp">(car (cdr (filter prime?
                  (enumerate-interval 10000 1000000))))
</p>


<p class="orig" lang="en">
This expression does find the second prime, but the computational
overhead is outrageous.  We construct a list of almost a million
integers, filter this list by testing each element for primality, and
then ignore almost all of the result.  In a more traditional
programming style, we would interleave the enumeration and the
filtering, and stop when we reached the second prime.</p>

<p class="trans" lang="ja">
ã“ã®å¼ã¯ã€äºŒç•ªç›®ã®ç´ æ•°ã‚’ç¢ºã‹ã«è¦‹ã¤ã‘å‡ºã™ã®ã ãŒã€è¨ˆç®—ä¸Šã®ã‚ªãƒ¼ãƒãƒ˜ãƒƒãƒ‰ã¯æ³•å¤–ã§ã‚ã‚‹ã€‚
ç§ãŸã¡ã¯ã€ã»ã¨ã‚“ã©ç™¾ä¸‡å€‹ã®æ•´æ•°ã®ãƒªã‚¹ãƒˆã‚’æ§‹ç¯‰ã—ã¦ã€ç´ æ•°æ€§ã«ã¤ã„ã¦å„è¦ç´ ã‚’èª¿ã¹ã‚‹ã“ã¨ã§ã“ã®ãƒªã‚¹ãƒˆã‚’ãƒ•ã‚£ãƒ«ã‚¿ã«ã‹ã‘ã€ãã‚Œã‹ã‚‰ã€çµæœã®ã»ã¨ã‚“ã©ã™ã¹ã¦ã‚’ç„¡è¦–ã™ã‚‹ã®ã ã€‚
ã‚ˆã‚Šä¼çµ±çš„ãªãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®æ§˜å¼ã§ã¯ã€ç§ãŸã¡ã¯ã€æ•°ãˆä¸Šã’ã¨ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã‚’äº’ã„é•ã„ã«ã—ã¦ã€äºŒç•ªç›®ã®ç´ æ•°ã«åˆ°é”ã—ãŸã¨ãã«åœæ­¢ã™ã‚‹ã ã‚ã†ã€‚
</p>

<p class="orig" lang="en">
Streams are a clever idea that allows one to use sequence
manipulations without incurring the costs of manipulating sequences as
lists.  With streams we can achieve the best of both worlds: We can
formulate programs elegantly as sequence manipulations, while attaining the
efficiency of incremental computation.  The basic idea is to arrange
to construct a stream only partially, and to pass the partial
construction to the program that consumes the stream.  If the consumer
attempts to access a part of the stream that has not yet been
constructed, the stream will automatically construct just enough more
of itself to produce the required part, thus preserving the illusion
that the entire stream exists.  In other words, although we will write
programs as if we were processing complete sequences, we design our
stream implementation to automatically and transparently interleave
the construction of the stream with its use.</p>

<p class="trans" lang="ja">
ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¯ã€åˆ—ã‚’ãƒªã‚¹ãƒˆã¨ã—ã¦æ“ä½œã™ã‚‹ã¨ã„ã†çŠ ç‰²ã‚’æ‹›ãã“ã¨ãªãã€åˆ—æ“ä½œã‚’ä½¿ã†ã“ã¨ã‚’å¯èƒ½ã«ã—ã¦ãã‚Œã‚‹ã€è³¢ã„è€ƒãˆæ–¹ã ã€‚
ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒã‚ã‚Œã°ã€åŒæ–¹ã®ä¸–ç•Œã®æœ€å–„ã‚’é”æˆã§ãã‚‹ã€‚
ã¤ã¾ã‚Šã€<ruby><rb>ä¸€æ­©ãšã¤é€²ã‚ã‚‹æ–¹å¼ã®</rb><rp> (</rp><rt>ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ã‚¿ãƒ«ãª</rt><rp>) </rp></ruby>è¨ˆç®—ã®åŠ¹ç‡æ€§ã‚’é”æˆã—ã¤ã¤ã€æ´—ç·´ã•ã‚ŒãŸã‚„ã‚Šæ–¹ã§åˆ—æ“ä½œã¨ã—ã¦ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’å®šå¼åŒ–ã§ãã‚‹ã®ã ã€‚
åŸºæœ¬çš„ãªè€ƒãˆæ–¹ã¯ã€ãŸã éƒ¨åˆ†çš„ã«ã ã‘ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’æ§‹ç¯‰ã§ãã‚‹ã‚ˆã†ã«æ‰‹ç­ˆã‚’æ•´ãˆã¦ã€ãã®éƒ¨åˆ†çš„ãªæ§‹ç¯‰ã‚’ã€ãã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’æ¶ˆè²»ã™ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¸æ¸¡ã™ã“ã¨ã§ã‚ã‚‹ã€‚
ã‚‚ã—æ¶ˆè²»å´ãŒã€ã¾ã æ§‹ç¯‰ã•ã‚Œã¦ã„ãªã„ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®ä¸€éƒ¨ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã‚ˆã†ã¨è©¦ã¿ãŸã‚‰ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¯è‡ªå‹•çš„ã«ã€ãã®ã‚¹ãƒˆãƒªãƒ¼ãƒ è‡ªèº«ã®ã€ã¡ã‚‡ã†ã©ååˆ†ãªã ã‘å…ˆã¾ã§ã®éƒ¨åˆ†ã‚’æ§‹ç¯‰ã—ã¦ã€æ±‚ã‚ã‚‰ã‚ŒãŸéƒ¨åˆ†ã‚’ä½œã‚Šå‡ºã™ã ã‚ã†ã—ã€ã—ãŸãŒã£ã¦ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ å…¨ä½“ãŒå­˜åœ¨ã—ã¦ã„ã‚‹ã€ã¨ã„ã†å¹»æƒ³ã‚’ä¿ã¤ã ã‚ã†ã€‚
æ›è¨€ã™ã‚Œã°ã€ç§ãŸã¡ã¯ã€ã‚ãŸã‹ã‚‚è‡ªåˆ†ãŒå®Œå…¨ãªåˆ—ã‚’å‡¦ç†ã—ã¦ã„ã‚‹ã¨ã“ã‚ã§ã‚ã‚‹ã‹ã®ã‚ˆã†ã«ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ãã ã‚ã†ãŒã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®æ§‹ç¯‰ã‚’ãã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®ä½¿ç”¨ã®é–“ã«è‡ªå‹•çš„ã‹ã¤é€éçš„ã«æŒŸã¿è¾¼ã‚€ã‚ˆã†ã«ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®å®Ÿè£…ã‚’è¨­è¨ˆã™ã‚‹ã®ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
On the surface, streams are just lists with different names for the
procedures that manipulate them.  There is a constructor,
<a name="%_idx_3738"></a><tt>cons-stream</tt>, and two selectors, <a name="%_idx_3740"></a><tt>stream-car</tt> and <a name="%_idx_3742"></a><tt>stream-cdr</tt>, which satisfy the constraints
</p>

<p class="trans" lang="ja">
è¡¨é¢çš„ã«ã¯ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¨ã¯ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’æ“ä½œã™ã‚‹æ‰‹ç¶šãã«å¯¾ã—ã¦åˆ¥ã®åå‰ãŒã¤ã„ã¦ã„ã‚‹ã‚ˆã†ãªã€å˜ãªã‚‹ãƒªã‚¹ãƒˆã§ã‚ã‚‹ã€‚
ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿â€”â€”ã™ãªã‚ã¡ <tt>cons-stream</tt> â€”â€”ã¨ã€äºŒã¤ã®ã‚»ãƒ¬ã‚¯ã‚¿â€”â€”ã™ãªã‚ã¡ã€<tt>stream-car</tt> ã¨ <tt>stream-cdr</tt> â€”â€”ãŒã‚ã‚Šã€ã“ã‚Œã‚‰ã¯ä»¥ä¸‹ã®åˆ¶ç´„ã‚’æº€ãŸã™ã€‚
</p>

<figure><img src="ch3-Z-G-34.gif" border="0"></figure>


<p class="orig" lang="en">
There is a distinguishable object, <a name="%_idx_3744"></a><a name="%_idx_3746"></a><a name="%_idx_3748"></a><tt>the-empty-stream</tt>, which
cannot be the result of any <tt>cons-stream</tt> operation, and which can
be identified with the predicate <a name="%_idx_3750"></a><tt>stream-null?</tt>.<a name="call_footnote_Temp_444" href="#footnote_Temp_444"><sup><small>54</small></sup></a>
Thus we can make and use streams, in just the same way as we can make
and use lists, to represent aggregate data arranged in a sequence.  In
particular, we can build stream analogs of the list operations from
chapter 2, such as <tt>list-ref</tt>, <tt>map</tt>, and <tt>for-each</tt>:<a name="call_footnote_Temp_445" href="#footnote_Temp_445"><sup><small>55</small></sup></a>
</p>


<p class="trans" lang="ja">
è­˜åˆ¥ã—ã‚„ã™ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆâ€”â€”ã™ãªã‚ã¡ <tt>the-empty-stream</tt> â€”â€”ãŒã‚ã‚Šã€ã“ã‚Œã¯ã€ã©ã® <tt>cons-stream</tt> æ“ä½œã®çµæœã§ã‚‚ã‚ã‚Šå¾—ãšã€<tt>stream-null?</tt> ã¨ã„ã†è¿°èªã«ã‚ˆã‚ŠåŒå®šã•ã‚Œã‚‹<a href="#footnote_Temp_444"><sup><small>54</small></sup></a>ã€‚
ã‚ˆã£ã¦ã€ç§ãŸã¡ã¯ã€ä¸€åˆ—ã«ä¸¦ã‚“ã é›†åˆçš„ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ç¾ã™ã‚‹ãŸã‚ã«ãƒªã‚¹ãƒˆã‚’ä½œã£ãŸã‚Šä½¿ã£ãŸã‚Šã§ãã‚‹ã®ã¨ã¡ã‚‡ã†ã©åŒã˜ã‚ˆã†ã«ã—ã¦ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½œã£ãŸã‚Šä½¿ã£ãŸã‚Šã§ãã‚‹ã€‚
ç‰¹ã«ã€2ç« ã®ãƒªã‚¹ãƒˆæ“ä½œâ€”â€”ä¾‹ãˆã° <tt>list-ref</tt> ã‚„ <tt>map</tt> ã‚„ <tt>for-each</tt> ãªã©â€”â€”ã«å¯¾ã™ã‚‹ã‚¹ãƒˆãƒªãƒ¼ãƒ ç‰ˆã®ç›¸ä¼¼ç‰©ã‚’ã€æ§‹ç¯‰ã§ãã‚‹ã®ã <a href="#footnote_Temp_445"><sup><small>55</small></sup></a>ã€‚
</p>

<p class="lisp"><a name="%_idx_3758"></a>(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))
<a name="%_idx_3760"></a>(define (stream-map proc s)
  (if (stream-null? s)
      the-empty-stream
      (cons-stream (proc (stream-car s))
                   (stream-map proc (stream-cdr s)))))
<a name="%_idx_3762"></a>(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each proc (stream-cdr s)))))
</p>


<p class="orig" lang="en">
<tt>Stream-for-each</tt> is useful for viewing streams:
</p>

<p class="trans" lang="ja">
<tt>stream-for-each</tt> ã¯ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’çœºã‚ã‚‹ã®ã«æœ‰ç”¨ã§ã‚ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_3764"></a>(define (display-stream s)
  (stream-for-each display-line s))

<a name="%_idx_3766"></a>(define (display-line x)
  (newline)
  (display x))
</p>

<p class="orig" lang="en">
To make the stream implementation automatically and transparently
interleave the construction of a stream with its use, we will arrange
for the <tt>cdr</tt> of a stream to be evaluated when it is accessed by
the <tt>stream-cdr</tt> procedure rather than when the stream is
constructed by <tt>cons-stream</tt>.  This implementation choice is
reminiscent of our discussion of rational numbers in
section <a href="14_sec2_1.html#%_sec_2.1.2">2.1.2</a>, where we saw that we can
choose to implement rational numbers so that the reduction of
numerator and denominator to lowest terms is performed either at
construction time or at selection time.  The two rational-number
implementations produce the same data abstraction, but the choice has
an effect on efficiency.  There is a similar relationship between
streams and ordinary lists.  As a data abstraction, streams are the
same as lists.  The difference is the time at which the elements are
evaluated.  With ordinary lists, both the <tt>car</tt> and the <tt>cdr</tt>
are evaluated at construction time.  With streams, the <tt>cdr</tt> is
evaluated at selection time.</p>

<p class="trans" lang="ja">
ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®å®Ÿè£…<!--ã‚’-->ã«ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®æ§‹ç¯‰ã‚’ãã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®ä½¿ç”¨ã®é–“ã«è‡ªå‹•çš„ã‹ã¤é€éçš„ã«æŒŸã¿è¾¼<!--ã‚€ã‚ˆã†ãªã‚‚ã®ã¨ã™ã‚‹-->ã‚€ã‚ˆã†ã«ã•ã›ã‚‹ãŸã‚ã«ã€ç§ãŸã¡ã¯ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒ <tt>cons-stream</tt> ã«ã‚ˆã£ã¦æ§‹ç¯‰ã•ã‚Œã‚‹ã¨ãã«ã‚¹ãƒˆãƒªãƒ¼ãƒ ã® <tt>cdr</tt> ã‚’è©•ä¾¡ã™ã‚‹ã®ã§ã¯ãªãã€ã‚€ã—ã‚ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã® <tt>cdr</tt> ãŒ <tt>stream-cdr</tt> ã¨ã„ã†æ‰‹ç¶šãã«ã‚ˆã£ã¦ã‚¢ã‚¯ã‚»ã‚¹ã•ã‚Œã‚‹ã¨ãã«ã‚¹ãƒˆãƒªãƒ¼ãƒ ã® <tt>cdr</tt> ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã‚ˆã†ã«ã€æ‰‹ç­ˆã‚’æ•´ãˆã‚ˆã†ã€‚
<!--ã‚¹ãƒˆãƒªãƒ¼ãƒ ã® <tt>cdr</tt> ãŒã€ãã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒ <tt>cons-stream</tt> ã«ã‚ˆã£ã¦æ§‹ç¯‰ã•ã‚Œã‚‹ã¨ãã«è©•ä¾¡ã•ã‚Œã‚‹ã®ã§ã¯ãªãã€ã‚€ã—ã‚ã€ãã® <tt>cdr</tt> ãŒ <tt>stream-cdr</tt> ã«ã‚ˆã£ã¦ã‚¢ã‚¯ã‚»ã‚¹ã•ã‚Œã‚‹ã¨ãã«è©•ä¾¡ã•ã‚Œã‚‹ã‚ˆã†ã«ã€-->
ã“ã†ã—ãŸå®Ÿè£…ã®é¸æŠã¯ã€<a href="14_sec2_1.html#%_sec_2.1.2">2.1.2</a>ç¯€ã§ã®æœ‰ç†æ•°ã«ã¤ã„ã¦ã®è­°è«–â€”â€”åˆ†å­ã¨åˆ†æ¯ã®æ—¢ç´„åŒ–ã‚’ã€æ§‹ç¯‰æ™‚ã‹é¸æŠæ™‚ã®ã©ã¡ã‚‰ã‹ã§å®Ÿè¡Œã™ã‚‹ã‚ˆã†ã«ã€æœ‰ç†æ•°ã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ã‚’é¸ã¶ã“ã¨ãŒã§ãã‚‹ã®ã ã€ã¨ã„ã†ã“ã¨ã‚’è¦‹ãŸâ€”â€”ã‚’å½·å½¿ã¨ã•ã›ã‚‹ã€‚
äºŒã¤ã®æœ‰ç†æ•°ã®å®Ÿè£…ã¯ã€åŒã˜ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ç‰©ã‚’ç”Ÿã¿å‡ºã™ãŒã€ã©ã¡ã‚‰ã‚’é¸ã¶ã‹ã¯åŠ¹ç‡ã«å½±éŸ¿ã‚’åŠã¼ã™ã€‚
ä¼¼ãŸã‚ˆã†ãªé–¢ä¿‚ãŒã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¨æ™®é€šã®ãƒªã‚¹ãƒˆã®é–“ã«ã‚‚ã‚ã‚‹ã€‚
ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ç‰©ã¨ã—ã¦ã¯ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¯ãƒªã‚¹ãƒˆã¨åŒã˜ã§ã‚ã‚‹ã€‚
ãã®é•ã„ã¯ã€è¦ç´ ãŒè©•ä¾¡ã•ã‚Œã‚‹æ™‚ç‚¹ã§ã‚ã‚‹ã€‚
æ™®é€šã®ãƒªã‚¹ãƒˆã ã¨ã€<tt>car</tt> ã¨ <tt>cdr</tt> ã®åŒæ–¹ã¯ã€æ§‹ç¯‰æ™‚ã«è©•ä¾¡ã•ã‚Œã‚‹ã€‚
ã‚¹ãƒˆãƒªãƒ¼ãƒ ã ã¨ã€<tt>cdr</tt> ã¯ã€é¸æŠæ™‚ã«è©•ä¾¡ã•ã‚Œã‚‹ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_3768"></a><a name="%_idx_3770"></a>Our implementation of streams will be based on a special form called
<tt>delay</tt>.  Evaluating <tt>(delay &lt;<em>exp</em>&gt;)</tt> does not
evaluate the expression &lt;<em>exp</em>&gt;, but rather returns a so-called <a name="%_idx_3772"></a><em>delayed object</em>, which we can think of as a ``promise'' to evaluate
&lt;<em>exp</em>&gt; at some future time.  As a companion to <tt>delay</tt>, there is
a procedure called <a name="%_idx_3774"></a><tt>force</tt> that takes a delayed object as
argument and performs the evaluation -- in effect, forcing the
<tt>delay</tt> to fulfill its promise.  We will see below how <tt>delay</tt>
and <tt>force</tt> can be implemented, but first let us use these to
construct streams.</p>

<p class="trans" lang="ja">
ç§ãŸã¡ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®å®Ÿè£…ã¯ã€<tt>delay</tt> ã¨å‘¼ã°ã‚Œã‚‹ç‰¹æ®Šå½¢å¼ã«åŸºã¥ãã“ã¨ã ã‚ã†ã€‚
<tt>(delay &lt;<em class="en">exp</em>&gt;)</tt>
ã®è©•ä¾¡ã§ã¯ã€
&lt;<em class="en">exp</em>&gt;
ã‚’è©•ä¾¡ã—ãŸã‚Šã›ãšã€ã‚€ã—ã‚ã€ã„ã‚ã‚†ã‚‹<em>é…å»¶ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ</em>â€”â€” &lt;<em class="en">exp</em>&gt; ã‚’æœªæ¥ã®ã©ã“ã‹ã®æ™‚ç‚¹ã§è©•ä¾¡ã™ã‚‹ã¨ã„ã†ã€Œ<ruby><rb>ç´„æŸ</rb><rp> (</rp><rt>ãƒ—ãƒ­ãƒŸã‚¹</rt><rp>) </rp></ruby>ã€ã¨è¦‹ãªã›ã‚‹â€”â€”ã‚’è¿”ã™ã®ã ã€‚
<tt>delay</tt> ã¨å¯¾ã‚’ãªã™ç‰‡å‰²ã‚Œã¨ã—ã¦ã¯ã€é…å»¶ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å¼•æ•°ã¨ã—ã¦ã¨ã£ã¦è©•ä¾¡ã‚’å®Ÿè¡Œã™ã‚‹ã€<tt>force</tt> ã¨å‘¼ã°ã‚Œã‚‹æ‰‹ç¶šããŒã‚ã‚Šã€ã“ã‚Œã¯ã€äº‹å®Ÿä¸Šã€<tt>delay</tt> ã«ç´„æŸã‚’å®ˆã‚‰ã›ã‚‹ã‚‚ã®ã§ã‚ã‚‹ã€‚
ä»¥ä¸‹ã§ã¯ã€ã©ã®ã‚ˆã†ã«ã—ãŸã‚‰ <tt>delay</tt> ã¨ <tt>force</tt> ã‚’å®Ÿè£…ã§ãã‚‹ã®ã‹ã‚’è¦‹ã‚‹ã“ã¨ã«ã™ã‚‹ãŒã€ã¾ãšã¯ã€ã“ã‚Œã‚‰ã‚’ä½¿ã£ã¦ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½œã‚ã†ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_3776"></a><a name="%_idx_3778"></a><tt>Cons-stream</tt> is a special form defined so that</p>

<p class="trans" lang="ja">
<tt>cons-stream</tt> ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã‚‹ç‰¹æ®Šå½¢å¼ã§ã‚ã‚‹â€”â€”ã™ãªã‚ã¡ã€
</p>

<p class="lisp">(cons-stream &lt;<em>a</em>&gt; &lt;<em>b</em>&gt;)
</p>

<p class="orig" lang="en">
is equivalent to</p>

<p class="trans" lang="ja">
ãŒã€ä»¥ä¸‹ã®ã‚‚ã®ã¨ç­‰ä¾¡ã¨ãªã‚‹ã‚ˆã†ã«ã€å®šç¾©ã•ã‚Œã‚‹ã‚‚ã®ã§ã‚ã‚‹ã€‚
</p>

<p class="lisp">(cons &lt;<em>a</em>&gt; (delay &lt;<em>b</em>&gt;))
</p>

<p class="orig" lang="en">
What this means is that we will construct streams using pairs.  However,
rather than placing the value of the rest of the stream
into the <tt>cdr</tt> of the
pair we will put there a promise to compute the rest if it is ever
requested.  <tt>Stream-car</tt> and <tt>stream-cdr</tt> can now be defined as
procedures:</p>

<p class="trans" lang="ja">
ã“ã‚ŒãŒæ„å‘³ã™ã‚‹ã“ã¨ã¯ã€å¯¾ã‚’ä½¿ã£ã¦ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’æ§‹ç¯‰ã™ã‚‹ã“ã¨ã«ãªã‚‹ã ã‚ã†ã€ã¨ã„ã†ã“ã¨ã ã€‚
ã—ã‹ã—ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®æ®‹ã‚Šã®éƒ¨åˆ†ã®å€¤ã‚’ã€å¯¾ã® <tt>cdr</tt> ã«é…ç½®ã™ã‚‹ã“ã¨ã‚ˆã‚Šã‚‚ã‚€ã—ã‚ã€ãã“ã«ã¯ã€ã„ã¤ã‹æ±‚ã‚ã‚‰ã‚ŒãŸã¨ãã«ãã®æ®‹ã‚Šã®éƒ¨åˆ†ã‚’è¨ˆç®—ã™ã‚‹ã‚ˆã€ã¨ã„ã†ç´„æŸã‚’ã€ç½®ãã“ã¨ã«ãªã‚‹ã ã‚ã†ã€‚
<tt>stream-car</tt> ã¨ <tt>stream-cdr</tt> ã¯ã€ã“ã“ã§ã€ä»¥ä¸‹ã®ã‚ˆã†ãªæ‰‹ç¶šãã¨ã—ã¦å®šç¾©ã§ãã‚‹ã€‚
</p>


<p class="lisp"><a name="%_idx_3780"></a>(define (stream-car stream) (car stream))

<a name="%_idx_3782"></a>(define (stream-cdr stream) (force (cdr stream)))
</p>

<p class="orig" lang="en">
<tt>Stream-car</tt> selects the <tt>car</tt> of the pair; <tt>stream-cdr</tt>
selects the <tt>cdr</tt> of the pair and evaluates the delayed expression
found there to obtain the rest of the stream.<a name="call_footnote_Temp_446" href="#footnote_Temp_446"><sup><small>56</small></sup></a>

<p class="trans" lang="ja">
<tt>stream-car</tt> ã¯ã€å¯¾ã® <tt>car</tt> ã‚’é¸æŠã™ã‚‹ã€‚<tt>stream-cdr</tt> ã¯ã€å¯¾ã® <tt>cdr</tt> ã‚’é¸æŠã—ã€ãã“ã§è¦‹ã¤ã‹ã£ãŸé…å»¶ã•ã‚ŒãŸå¼ã‚’è©•ä¾¡ã—ã¦ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®æ®‹ã‚Šã®éƒ¨åˆ†ã‚’æ±‚ã‚ã‚‹<a href="#footnote_Temp_446"><sup><small>56</small></sup></a>ã€‚
</p>

<a name="%_sec_Temp_447"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_447">The stream implementation in action</a></h4>
<h4 class="trans" lang="ja">å‹•ä½œã—ã¦ã„ã‚‹ã‚¹ãƒˆãƒªãƒ¼ãƒ å®Ÿè£…</h4>

<p class="orig" lang="en">
To see how this implementation behaves, let us analyze the
``outrageous'' prime computation we saw above, reformulated in terms
of streams:</p>

<p class="trans" lang="ja">
ã“ã®å®Ÿè£…ãŒã©ã†æŒ¯ã‚‹èˆã†ã®ã‹ã‚’è¦‹ã‚‹ãŸã‚ã«ã€ä¸Šã§è¦‹ãŸã€Œæ³•å¤–ãªã€ç´ æ•°è¨ˆç®—â€”â€”ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½¿ã£ã¦ã€ä»¥ä¸‹ã®ã‚ˆã†ã«å®šå¼åŒ–ã—ç›´ã•ã‚ŒãŸã‚‚ã®â€”â€”ã‚’åˆ†æã—ã‚ˆã†ã€‚
</p>

<p class="lisp">(stream-car
 (stream-cdr
  (stream-filter prime?
                 (stream-enumerate-interval 10000 1000000))))
</p>


<p class="orig" lang="en">
We will see that it does indeed work efficiently.</p>

<p class="trans" lang="ja">
ã“ã‚ŒãŒç¢ºã‹ã«åŠ¹ç‡çš„ã«å‹•ãã“ã¨ãŒåˆ†ã‹ã‚‹ã§ã‚ã‚ã†ã€‚
</p>

<p class="orig" lang="en">
We begin by calling <tt>stream-enumerate-interval</tt> with
the arguments 10,000 and 1,000,000.  <tt>Stream-enumerate-interval</tt>
is the stream analog of <tt>enumerate-interval</tt>
(section <a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a>):</p>

<p class="trans" lang="ja">
10,000 ãŠã‚ˆã³ 1,000,000 ã¨ã„ã†å¼•æ•°ã¨ã¨ã‚‚ã« <tt>stream-enumerate-interval</tt> ã‚’å‘¼ã³å‡ºã™ã“ã¨ã‹ã‚‰å§‹ã‚ã‚‹ã€‚
<tt>stream-enumerate-interval</tt> ã¯ã€<tt>enumerate-interval</tt> (<a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a>ç¯€) ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ç‰ˆã®ç›¸ä¼¼ç‰©ã§ã‚ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_3788"></a>(define (stream-enumerate-interval low high)
  (if (&gt; low high)
      the-empty-stream
      (cons-stream
       low
       (stream-enumerate-interval (+ low 1) high))))
</p>

<p class="orig" lang="en">
and thus the result returned by <tt>stream-enumerate-interval</tt>,
formed by the <tt>cons-stream</tt>, is<a name="call_footnote_Temp_448" href="#footnote_Temp_448"><sup><small>57</small></sup></a></p>

<p class="trans" lang="ja">
ã—ãŸãŒã£ã¦ã€<tt>stream-enumerate-interval</tt> ã«ã‚ˆã‚Šè¿”ã•ã‚Œã‚‹çµæœâ€”â€” <tt>cons-stream</tt> ã«ã‚ˆã‚Šä½œã‚‰ã‚Œã‚‹â€”â€”ã¯ã€ä»¥ä¸‹ã®ã¨ãŠã‚Šã§ã‚ã‚‹<a  href="#footnote_Temp_448"><sup><small>57</small></sup></a>ã€‚
</p>


<p class="lisp">(cons 10000
      (delay (stream-enumerate-interval 10001 1000000)))
</p>

<p class="orig" lang="en">
That is, <tt>stream-enumerate-interval</tt>
returns a stream represented as a pair whose <tt>car</tt>
is 10,000 and whose <tt>cdr</tt> is a promise to enumerate more of the
interval if so requested.  This stream is now filtered for primes,
using the stream analog of the <tt>filter</tt> procedure
(section <a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a>):</p>

<p class="trans" lang="ja">
ã¤ã¾ã‚Šã€<tt>car</tt> ãŒ 10,000 ã§ã‚ã‚Šã€ã‹ã¤ã€<tt>cdr</tt> ã¯ã€ã‚‚ã—ãã®åŒºé–“ã®ã•ã‚‰ã«å…ˆã‚’æ•°ãˆä¸Šã’ã‚‹ã‚ˆã†ã«æ±‚ã‚ã‚‰ã‚ŒãŸã‚‰ãã†ã™ã‚‹ã‚ˆã€ã¨ã„ã†<ruby><rb>ç´„æŸ</rb><rp> (</rp><rt>ãƒ—ãƒ­ãƒŸã‚¹</rt><rp>) </rp></ruby>ã§ã‚ã‚‹ã€ã¨ã„ã†ã‚ˆã†ãªå¯¾ã¨ã—ã¦è¡¨ã•ã‚Œã‚‹ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ã€<tt>stream-enumerate-interval</tt> ãŒè¿”ã™ã®ã§ã‚ã‚‹ã€‚
ã“ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒã“ã“ã§ã€<tt>filter</tt> ã®æ‰‹ç¶šã (<a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a>ç¯€) ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ç‰ˆã®ç›¸ä¼¼ç‰©ã‚’ä½¿ã£ã¦ã€ç´ æ•°ç”¨ã®ãƒ•ã‚£ãƒ«ã‚¿ã«ã‹ã‘ã‚‰ã‚Œã‚‹ã€‚
</p>


<p class="lisp"><a name="%_idx_3790"></a>(define (stream-filter pred stream)
  (cond ((stream-null? stream) the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream (stream-car stream)
                      (stream-filter pred
                                     (stream-cdr stream))))
        (else (stream-filter pred (stream-cdr stream)))))
</p>


<p class="orig" lang="en">
<tt>Stream-filter</tt> tests the <tt>stream-car</tt> of the stream (the <tt>car</tt> of the pair, which is 10,000).  Since this is not prime,
<tt>stream-filter</tt> examines the <tt>stream-cdr</tt> of its input
stream.  The call to <tt>stream-cdr</tt> forces evaluation of the delayed
<tt>stream-enumerate-interval</tt>, which now returns</p>

<p class="trans" lang="ja">
<tt>stream-filter</tt> ã¯ã€å½“è©²ã‚¹ãƒˆãƒªãƒ¼ãƒ ã® <tt>stream-car</tt> (å¯¾ã® <tt>car</tt>ã€ã¤ã¾ã‚Šã€10,000) ã‚’èª¿ã¹ã‚‹ã€‚
ã“ã‚Œã¯ç´ æ•°ã§ã¯ãªã„ã‹ã‚‰ã€<tt>stream-filter</tt> ã¯ã€è‡ªåˆ†ã¸ã®å…¥åŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ ã® <tt>stream-cdr</tt> ã‚’æ¤œæŸ»ã™ã‚‹ã€‚
<tt>stream-cdr</tt> ã«å¯¾ã™ã‚‹å‘¼ã³å‡ºã—ã¯ã€é…å»¶ã•ã‚ŒãŸ <tt>stream-enumerate-interval</tt> ã®è©•ä¾¡ã‚’å¼·åˆ¶ã—ã€ãã‚ŒãŒä»Šåº¦ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«è¿”ã—ã¦ãã‚‹ã€‚
</p>


<p class="lisp">(cons 10001
      (delay (stream-enumerate-interval 10002 1000000)))
</p>


<p class="orig" lang="en">
<tt>Stream-filter</tt> now looks at the <tt>stream-car</tt> of this stream,
10,001, sees that this is not prime either, forces another <tt>stream-cdr</tt>, and so on, until <tt>stream-enumerate-interval</tt> yields
the prime 10,007, whereupon <tt>stream-filter</tt>, according to its
definition, returns</p>

<p class="trans" lang="ja">
<tt>stream-filter</tt> ã¯ã€ä»Šåº¦ã¯ã“ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã® <tt>stream-car</tt> â€”â€”ã¤ã¾ã‚Š 10,001 â€”â€”ã‚’è¦‹ã¦ã€ã“ã‚Œã‚‚ç´ æ•°ã§ã¯ãªã„ãªã€ã¨ç†è§£ã—ã€ã‚‚ã†ä¸€å› <tt>stream-cdr</tt> ã‚’å¼·åˆ¶çš„ã«è¡Œã„ã€â€¦â€¦ã¨ã„ã†ãµã†ã«ç¶šãâ€”â€” <tt>stream-enumerate-interval</tt> ãŒ 10,007 ã¨ã„ã†ç´ æ•°ã‚’ä½œã‚Šå‡ºã—ã¦ã€ãã®çµæœã€<tt>stream-filter</tt> ãŒãã®å®šç¾©ã«åŸºã¥ã„ã¦ä»¥ä¸‹ã®ã‚ˆã†ã«è¿”ã™ã¾ã§ã€‚
</p>


<p class="lisp">(cons-stream (stream-car stream)
             (stream-filter pred (stream-cdr stream)))
</p>


<p class="orig" lang="en">
which in this case is</p>

<p class="trans" lang="ja">
ã“ã®å ´åˆã€ã“ã‚Œã¯ä»¥ä¸‹ã®ã¨ãŠã‚Šã§ã‚ã‚‹ã€‚
</p>


<p class="lisp">(cons 10007
      (delay
        (stream-filter
         prime?
         (cons 10008
               (delay
                 (stream-enumerate-interval 10009
                                            1000000))))))
</p>

<p class="exercise"><span class="ex_comment">ã¡ãªã¿ã«ã€
10000 = 2<sup>4</sup> &middot; 5<sup>4</sup>
10001 = 73 &middot; 137
10002 = 2 &middot; 3 &middot; 1667
10003 = 7 &middot; 1429
10004 = 2<sup>2</sup> &middot; 41 &middot; 61
10005 = 3 &middot; 5 &middot; 23 &middot; 29
10006 = 2 &middot; 5003
10007 = 10007
10008 = 2<sup>3</sup> &middot; 3<sup>2</sup> &middot; 139
10009 = 10009
ã§ã™ã‚ˆã€‚</span></p>

<p class="orig" lang="en">
This result is now passed to <tt>stream-cdr</tt> in our
original expression.  This forces the delayed <tt>stream-filter</tt>, which in turn keeps forcing the delayed <tt>stream-enumerate-interval</tt> until it finds the next prime, which is
10,009.  Finally, the result passed to <tt>stream-car</tt> in our
original expression is</p>

<p class="trans" lang="ja">
ã“ã®çµæœãŒã“ã“ã§ã€å…ƒã€…ã®å¼ã«ãŠã‘ã‚‹ <tt>stream-cdr</tt> ã«æ¸¡ã•ã‚Œã‚‹ã€‚
ã“ã®ã“ã¨ã«ã‚ˆã‚Šã€é…å»¶ã•ã‚ŒãŸ <tt>stream-filter</tt> ã‚’å¼·åˆ¶çš„ã«è¡Œã†ã“ã¨ã«ãªã‚Šã€ãã® <tt>stream-filter</tt> ãŒä»Šåº¦ã¯ã€æ¬¡ã®ç´ æ•°â€”â€”ã¤ã¾ã‚Š 10,009 â€”â€”ã‚’è¦‹ã¤ã‘å‡ºã™ã¾ã§ãšã£ã¨ <tt>stream-enumerate-interval</tt> ã‚’å¼·åˆ¶çš„ã«è¡Œã„ç¶šã‘ã‚‹ã®ã§ã‚ã‚‹ã€‚
æœ€çµ‚çš„ã«ã€å…ƒã€…ã®å¼ã«ãŠã‘ã‚‹ <tt>stream-car</tt> ã«æ¸¡ã•ã‚Œã‚‹çµæœã¯ã€ä»¥ä¸‹ã®ã¨ãŠã‚Šã§ã‚ã‚‹ã€‚
</p>


<p class="lisp">(cons 10009
      (delay
        (stream-filter
         prime?
         (cons 10010
               (delay
                 (stream-enumerate-interval 10011
                                            1000000))))))
</p>



<p class="orig" lang="en">
<tt>Stream-car</tt> returns 10,009, and the computation is complete.  Only as
many integers were tested for primality as were necessary to find the
second prime, and the interval was enumerated only as far as was
necessary to feed the prime filter.</p>

<p class="trans" lang="ja">
<tt>stream-car</tt> ã¯ 10,009 ã‚’è¿”ã—ã€è¨ˆç®—ãŒå®Œäº†ã™ã‚‹ã€‚
äºŒç•ªç›®ã®ç´ æ•°ã‚’è¦‹ã¤ã‘ã‚‹ã®ã«å¿…è¦ãªã®ã¨åŒã˜å€‹æ•°ã ã‘ã®æ•´æ•°ãŒã€ç´ æ•°æ€§ã‚’èª¿ã¹ã‚‰ã‚ŒãŸã®ã ã—ã€åŒºé–“ã¯ã€ç´ æ•°ãƒ•ã‚£ãƒ«ã‚¿ã«æŠ•å…¥ã™ã‚‹ã®ã«å¿…è¦ãªé™ã‚Šã«ãŠã„ã¦ã ã‘ã€æ•°ãˆä¸Šã’ã‚‰ã‚ŒãŸã€‚
</p>

<p class="orig" lang="en">
In general, we can think of delayed evaluation as <a name="%_idx_3792"></a>``demand-driven''
programming, whereby each stage in the stream process is activated
only enough to satisfy the next stage.  What we have done is to
<a name="%_idx_3794"></a>decouple the actual order of events in the computation from the
apparent structure of our procedures.  We write procedures as if the
streams existed ``all at once'' when, in reality, the computation is
performed incrementally, as in traditional programming styles.</p>

<p class="trans" lang="ja">
ä¸€èˆ¬ã«ã€é…å»¶è©•ä¾¡ã¯ã€ã€Œéœ€è¦é§†å‹•ã®ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°â€”â€”ã“ã‚Œã«ã‚ˆã‚Šã€ã‚¹ãƒˆãƒªãƒ¼ãƒ å‡¦ç†ã«ãŠã‘ã‚‹å„æ®µéšã¯ã€æ¬¡ã®æ®µéšã‚’å……è¶³ã•ã›ã‚‹ã®ã«ååˆ†ãªåˆ†ã ã‘ã€æ´»æ€§åŒ–ã•ã‚Œã‚‹â€”â€”ã§ã‚ã‚‹ã€ã¨è¦‹ãªã›ã‚‹ã€‚
ç§ãŸã¡ãŒè¡Œã£ãŸã“ã¨ã¯ã€è¨ˆç®—ã«ãŠã‘ã‚‹å‡ºæ¥äº‹ã®å®Ÿéš›ã®é †åºã‚’ã€æ‰‹ç¶šãã®ã†ã‚ã¹ã®æ§‹é€ ã‹ã‚‰åˆ‡ã‚Šé›¢ã™ã“ã¨ã§ã‚ã‚‹ã€‚
å®Ÿéš›ã«ã¯è¨ˆç®—ãŒä¸€æ­©ãšã¤å®Ÿè¡Œã•ã‚Œã‚‹ã«ã‚‚ã‹ã‹ã‚ã‚‰ãšã€ç§ãŸã¡ã¯ã€ä¼çµ±çš„ãªãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°æµå„€ã¨åŒæ§˜ã«ã€ã‚ãŸã‹ã‚‚ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒã€Œã™ã¹ã¦ãŒä¸€åº¦ã«ã€å­˜åœ¨ã—ã¦ã„ã‚‹ã‹ã®ã‚ˆã†ã«ã€æ‰‹ç¶šãã‚’æ›¸ãã€‚
</p>


<a name="%_sec_Temp_449"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_449">Implementing <tt>delay</tt> and <tt>force</tt></a></h4>
<h4 class="trans" lang="ja"><tt>delay</tt> ã¨ <tt>force</tt> ã‚’å®Ÿè£…ã™ã‚‹</h4>


<p class="orig" lang="en">
<a name="%_idx_3796"></a>Although <tt>delay</tt> and <tt>force</tt> may seem like mysterious
operations, their implementation is really quite straightforward.
<tt>Delay</tt> must package an expression so that it can be evaluated
later on demand, and we can accomplish this simply by treating the
expression as the body of a procedure.  <tt>Delay</tt> can be a special
form such that</p>

<p class="trans" lang="ja">
<tt>delay</tt> ã¨ <tt>force</tt> ã¯ç¥ç§˜çš„ãªæ¼”ç®—ã®ã‚ˆã†ã«è¦‹ãˆã‚‹ã®ã ãŒã€ã“ã‚Œã‚‰ã®å®Ÿè£…ã¯æœ¬å½“ã«ã¨ã¦ã‚‚ã‚ã‹ã‚Šã‚„ã™ã„ã€‚
<tt>delay</tt> ã¯ã€å¾Œã§éœ€è¦ãŒã‚ã‚Šæ¬¡ç¬¬ã€å¼ã‚’è©•ä¾¡ã§ãã‚‹ã‚ˆã†ã«ã€å¼ã‚’åŒ…ã¿è¾¼ã¾ã­ã°ãªã‚‰ãªã„ã‚ã‘ã ãŒã€ç§ãŸã¡ã¯ã“ã‚Œã‚’ã€ãã®å¼ã‚’æ‰‹ç¶šãã®æœ¬ä½“ã¨ã—ã¦æ‰±ã†ã“ã¨ã§ã€ç°¡å˜ã«é”æˆã§ãã‚‹ã€‚
<tt>delay</tt> ã¯ã€æ¬¡ã®ã‚ˆã†ãªç‰¹æ®Šå½¢å¼ã§ã‚ã£ã¦ã‚ˆã„ã€‚ã™ãªã‚ã¡ã€
</p>


<p class="lisp">(delay &lt;<em>exp</em>&gt;)
</p>


<p class="orig" lang="en">
is syntactic sugar for</p>

<p class="trans" lang="ja">
ãŒã€ä»¥ä¸‹ã®ã‚‚ã®ã®ç³–è¡£æ§‹æ–‡ã§ã‚ã‚‹ã‚ˆã†ãªç‰¹æ®Šå½¢å¼ã§ã‚ã£ã¦ã‚ˆã„ã€‚
</p>

<p class="lisp">(lambda () &lt;<em>exp</em>&gt;)
</p>


<p class="orig" lang="en">
<tt>Force</tt> simply calls the procedure (of no
arguments) produced by <tt>delay</tt>, so we can implement <tt>force</tt> as
a procedure:</p>

<p class="trans" lang="ja">
<tt>force</tt> ã¯å˜ã«ã€<tt>delay</tt> ã«ã‚ˆã‚Šä½œã‚Šå‡ºã•ã‚ŒãŸ (å¼•æ•°ãªã—ã®) æ‰‹ç¶šãã‚’å‘¼ã³å‡ºã™ã ã‘ã§ã‚ã‚Šã€ã‚ˆã£ã¦ç§ãŸã¡ã¯ã€<tt>force</tt> ã‚’ä»¥ä¸‹ã®æ‰‹ç¶šãã¨ã—ã¦å®Ÿè£…ã§ãã‚‹ã€‚
</p>


<p class="lisp"><a name="%_idx_3798"></a>(define (force delayed-object)
  (delayed-object))
</p>


<p class="orig" lang="en">
<a name="%_idx_3800"></a><a name="%_idx_3802"></a>This implementation suffices for <tt>delay</tt> and <tt>force</tt> to work
as advertised, but there is an important optimization that we can
include.  In many applications, we end up forcing the same delayed object
many times.  This can lead to serious inefficiency in recursive
programs involving streams.  (See
exercise <a href="#%_thm_3.57">3.57</a>.)  The solution is to build
delayed objects so that the first time they are forced, they store the
value that is computed.  Subsequent forcings will simply return the
stored value without repeating the computation.  In other words, we
implement <tt>delay</tt> as a special-purpose memoized procedure similar
to the one described in exercise <a href="22_sec3_3.html#%_thm_3.27">3.27</a>.  One way to
accomplish this is to use the following procedure, which takes as
argument a procedure (of no arguments) and returns a memoized version
of the procedure.  The first time the memoized procedure is run, it
saves the computed result.  On subsequent evaluations, it simply
returns the result.</p>

<p class="trans" lang="ja">
ã“ã®å®Ÿè£…ã¯ã€<tt>delay</tt> ã¨ <tt>force</tt> ãŒå®£ä¼ã©ãŠã‚Šã«ã†ã¾ãå‹•ãã®ã«ååˆ†ã§ã‚ã‚‹ãŒã€ç§ãŸã¡ãŒå«ã‚ã‚‹ã“ã¨ã®ã§ãã‚‹é‡è¦ãªæœ€é©åŒ–ãŒã‚ã‚‹ã€‚
å¤šãã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«ãŠã„ã¦ã€ç§ãŸã¡ã¯æœ€çµ‚çš„ã«ã€ä½•å›ã‚‚åŒã˜é…å»¶ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å¼·åˆ¶çš„ã«è¡Œã†ã“ã¨ã«ãªã‚‹ã€‚
ã“ã®ã“ã¨ã¯ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä¼´ã†å†å¸°çš„ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ãŠã‘ã‚‹æ·±åˆ»ãªéåŠ¹ç‡ã«ã¤ãªãŒã‚‹ã“ã¨ãŒã‚ã‚‹ (ç·´ç¿’å•é¡Œ <a href="#%_thm_3.57">3.57</a>ã‚’å‚ç…§)ã€‚
è§£æ±ºæ³•ã¯ã€é…å»¶ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒæœ€åˆã«å¼·åˆ¶ã•ã‚ŒãŸã¨ãã«ã€è¨ˆç®—ã—ãŸå€¤ã‚’é…å»¶ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒè¨˜æ†¶ã—ã¦ãŠãã‚ˆã†ã«ã€é…å»¶ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ§‹ç¯‰ã™ã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚
ãã®å¾Œã®å¼·åˆ¶ã¯ã€è¨ˆç®—ã‚’ç¹°ã‚Šè¿”ã•ãšã«ã€å˜ã«è¨˜æ†¶ã•ã‚ŒãŸå€¤ã‚’è¿”ã™ã“ã¨ã«ãªã‚‹ã ã‚ã†ã€‚
æ›è¨€ã™ã‚Œã°ã€ç§ãŸã¡ã¯ã€ç·´ç¿’å•é¡Œ<a href="22_sec3_3.html#%_thm_3.27">3.27</a>ã§è¿°ã¹ãŸã‚‚ã®ã¨ä¼¼ãŸã‚ˆã†ãªã€ç‰¹å®šç›®çš„ã®ãƒ¡ãƒ¢åŒ–ã•ã‚ŒãŸæ‰‹ç¶šãã¨ã—ã¦ã€<tt>delay</tt> ã‚’å®Ÿè£…ã™ã‚‹ã€‚
ã“ã‚Œã‚’é”æˆã™ã‚‹ãŸã‚ã®ä¸€ã¤ã®æ–¹æ³•ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ãªæ‰‹ç¶šãâ€”â€”ã¤ã¾ã‚Šã€å¼•æ•°ã¨ã—ã¦ã€(å¼•æ•°ã®ãªã„) æ‰‹ç¶šãã‚’ã¨ã‚Šã€ãã®æ‰‹ç¶šãã®ãƒ¡ãƒ¢åŒ–ã•ã‚ŒãŸãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’è¿”ã™ã‚‚ã®â€”â€”ã‚’ä½¿ã†ã“ã¨ã§ã‚ã‚‹ã€‚
ãƒ¡ãƒ¢åŒ–ã•ã‚ŒãŸæ‰‹ç¶šããŒæœ€åˆã«å®Ÿè¡Œã•ã‚Œã‚‹ã¨ãã€ãƒ¡ãƒ¢åŒ–ã•ã‚ŒãŸæ‰‹ç¶šãã¯ã€è¨ˆç®—ã—ãŸçµæœã‚’ä¿å­˜ã™ã‚‹ã€‚
å¾Œç¶šã®è©•ä¾¡ã®éš›ã«ã¯ã€ãƒ¡ãƒ¢åŒ–ã•ã‚ŒãŸæ‰‹ç¶šãã¯å˜ã«ãã®çµæœã‚’è¿”ã™ã ã‘ã§ã‚ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_3804"></a>(define (memo-proc proc)
  (let ((already-run? false) (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))
</p>


<p class="orig" lang="en">
<tt>Delay</tt> is then defined so that <tt>(delay &lt;<em>exp</em>&gt;)</tt> is
equivalent to</p>

<p class="trans" lang="ja">
ãã—ã¦ã€<tt>delay</tt> ã¯ã€
<tt>(delay &lt;<em class="en">exp</em>&gt;)</tt> 
ãŒä»¥ä¸‹ã®ã‚‚ã®ã¨ç­‰ä¾¡ã¨ãªã‚‹ã‚ˆã†ã«å®šç¾©ã•ã‚Œã€
</p>

<p class="lisp">(memo-proc (lambda () &lt;<em>exp</em>&gt;))
</p>

<p class="orig" lang="en">
and <tt>force</tt> is as defined previously.<a name="call_footnote_Temp_450" href="#footnote_Temp_450"><sup><small>58</small></sup></a></p>

<p class="trans" lang="ja">
ã¾ãŸã€<tt>force</tt> ã¯ã€ä»¥å‰å®šç¾©ã—ãŸã¨ãŠã‚Šã§ã‚ã‚‹<a href="#footnote_Temp_450"><sup><small>58</small></sup></a>ã€‚
</p>


<p class="orig" lang="en"><a name="%_thm_3.50"></a>
<b>Exercise 3.50.</b>  Complete the following definition, which
generalizes <tt>stream-map</tt> to allow procedures that
take multiple arguments, analogous to <tt>map</tt> in
section <a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a>, footnote <a href="15_sec2_2.html#footnote_Temp_166">12</a>.</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.50.</b> <a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a>ç¯€ã® <tt>map</tt> ã‚„ è„šæ³¨<a href="15_sec2_2.html#footnote_Temp_166">12</a>ã¨é¡ä¼¼ã—ãŸä»¥ä¸‹ã®å®šç¾©â€”â€”è¤‡æ•°ã®å¼•æ•°ã‚’å–ã‚‹æ‰‹ç¶šãã‚’è¨±ã™ã‚ˆã†ã«ã€<tt>stream-map</tt> ã‚’ä¸€èˆ¬åŒ–ã—ã¦ã„ã‚‹â€”â€”ã‚’å®Œæˆã•ã›ã‚ˆã€‚
</p>

<p class="lisp"><a name="%_idx_3824"></a>(define (stream-map proc . argstreams)
  (if (&lt;<em>??</em>&gt; (car argstreams))
      the-empty-stream
      (&lt;<em>??</em>&gt;
       (apply proc (map &lt;<em>??</em>&gt; argstreams))
       (apply stream-map
              (cons proc (map &lt;<em>??</em>&gt; argstreams))))))
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.51"></a>
<b>Exercise 3.51.</b>  <a name="%_idx_3826"></a>In order to take a closer look at delayed evaluation, we will use the
following procedure, which simply returns its argument after printing it:</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.51.</b> é…å»¶è©•ä¾¡ã‚’ã‚‚ã£ã¨ã˜ã£ã¨ã‚ˆãè¦‹ã‚‹ãŸã‚ã«ã€ä»¥ä¸‹ã®æ‰‹ç¶šãâ€”â€”å˜ã«ã€å¼•æ•°ã‚’å°å­—ã—ã¦ã‹ã‚‰è¿”ã™ã ã‘ã§ã‚ã‚‹â€”â€”ã‚’ä½¿ãŠã†ã€‚
</p>


<p class="lisp">(define (show x)
  (display-line x)
  x)
</p>


<p class="orig" lang="en">
What does the interpreter print in response to evaluating each
expression in the following sequence?<a name="call_footnote_Temp_453" href="#footnote_Temp_453"><sup><small>59</small></sup></a></p>

<p class="trans" lang="ja">
ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã¯ã€ä»¥ä¸‹ã®ä¸€é€£ã®å¼ã®å„ã€…ã‚’è©•ä¾¡ã™ã‚‹ã®ã«å¿œã˜ã¦ã€ä½•ã‚’å°å­—ã™ã‚‹ã ã‚ã†?<a href="#footnote_Temp_453"><sup><small>59</small></sup></a>
</p>


<p class="lisp">(define x (stream-map show (stream-enumerate-interval 0 10)))
(stream-ref x 5)
(stream-ref x 7)
</p>


<p class="exercise"><span class="ex_comment">
</span></p>


<p class="orig" lang="en"><a name="%_thm_3.52"></a>
<b>Exercise 3.52.</b>  <a name="%_idx_3830"></a>Consider the sequence of expressions</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.52.</b> ä»¥ä¸‹ã®ã‚ˆã†ãªä¸€é€£ã®å¼ã‚’è€ƒãˆã‚ˆã†ã€‚
</p>

<p class="lisp">(define sum 0)
(define (accum x)
  (set! sum (+ x sum))
  sum)
(define seq (stream-map accum (stream-enumerate-interval 1 20)))
(define y (stream-filter even? seq))
(define z (stream-filter (lambda (x) (= (remainder x 5) 0))
                         seq))
(stream-ref y 7)
(display-stream z)
</p>

<p class="orig" lang="en">
What is the value of <tt>sum</tt> after each of the above expressions is
evaluated?  What is the printed response to evaluating the <tt>stream-ref</tt> and <tt>display-stream</tt> expressions?  Would these responses
differ if we had implemented <tt>(delay &lt;<em>exp</em>&gt;)</tt> simply as
<tt>(lambda () &lt;<em>exp</em>&gt;)</tt> without using the optimization provided by
<tt>memo-proc</tt> ?  Explain.
</p>

<p class="trans" lang="ja">
ä¸Šè¨˜ã®å¼ã®ãã‚Œãã‚ŒãŒè©•ä¾¡ã•ã‚ŒãŸå¾Œã®ã€<tt>sum</tt> ã®å€¤ã¯ã€ã©ã®ã‚ˆã†ãªã‚‚ã®ã‹?
<tt>stream-ref</tt> ã¨ <tt>display-stream</tt> ã®å¼ã®è©•ä¾¡ã«å¯¾ã—ã¦å°å­—ã•ã‚Œã‚‹å¿œç­”ã¨ã¯ã€ã©ã†ã„ã†ã‚‚ã®ã‹?
ã‚‚ã—ã€<tt>memo-proc</tt> ã«ã‚ˆã‚Šã‚‚ãŸã‚‰ã•ã‚Œã‚‹æœ€é©åŒ–ã‚’ä½¿ã‚ãªã„ã§ã€å˜ç´”ã«
<tt>(delay &lt;<em class="en">exp</em>&gt;)</tt>
ã‚’
<tt>(lambda () &lt;<em class="en">exp</em>&gt;)</tt> 
ã¨å®Ÿè£…ã—ã¦ã„ãŸã‚‰ã€ã“ã‚Œã‚‰ã®å¿œç­”ã¯é•ã£ã¦ã„ãŸã ã‚ã†ã‹?
èª¬æ˜ã›ã‚ˆã€‚
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_3.5.2"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_3.5.2">3.5.2  Infinite Streams</a></h3>
<h3 class="trans" lang="ja">3.5.2 ç„¡é™ã‚¹ãƒˆãƒªãƒ¼ãƒ </h3>


<p class="orig" lang="en">
<a name="%_idx_3832"></a>
We have seen how to support the illusion of manipulating streams
as complete entities even though, in actuality, we compute only
as much of the stream as we need to access.  We can exploit this
technique to represent sequences efficiently as streams, even if the
sequences are very long.  What is more striking, we can use streams to
represent sequences that are infinitely long.  For instance, consider
the following definition of the stream of positive integers:</p>

<p class="trans" lang="ja">
ãŸã¨ãˆç¾å®Ÿã«ã¯ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®ã†ã¡ã§ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹å¿…è¦ãŒã‚ã‚‹åˆ†ã ã‘ã‚’è¨ˆç®—ã™ã‚‹ã®ã ã¨ã—ã¦ã‚‚ã€å®Œå…¨ãªå®Ÿä½“ã¨ã—ã¦ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’æ“ä½œã—ã¦ã„ã‚‹ã®ã ã¨ã„ã†å¹»æƒ³ã‚’ã€ã©ã†ã‚„ã£ã¦æ”¯ãˆã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’ã“ã‚Œã¾ã§è¦‹ã¦ããŸã€‚
ãŸã¨ãˆåˆ—ãŒéå¸¸ã«é•·ãã¦ã‚‚ã€åŠ¹ç‡çš„ã«åˆ—ã‚’ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¨ã—ã¦è¡¨ç¾ã™ã‚‹ãŸã‚ã«ã€ã“ã®æŠ€æ³•ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
ã‚ˆã‚Šé­…åŠ›çš„ãªã“ã¨ã«ã¯ã€ç„¡é™ã«é•·ã„åˆ—ã‚’è¡¨ç¾ã™ã‚‹ã®ã«ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½¿ãˆã‚‹ã®ã ã€‚
ãŸã¨ãˆã°ã€æ­£æ•´æ•°ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®ã€ä»¥ä¸‹ã®ã‚ˆã†ãªå®šç¾©ã‚’è€ƒãˆã‚ˆã†ã€‚
</p>


<p class="lisp"><a name="%_idx_3834"></a>(define (integers-starting-from n)
  (cons-stream n (integers-starting-from (+ n 1))))

<a name="%_idx_3836"></a>(define integers (integers-starting-from 1))
</p>


<p class="orig" lang="en">
This makes sense because <tt>integers</tt> will be a pair whose <tt>car</tt>
is 1 and whose <tt>cdr</tt> is a promise to produce the integers
beginning with 2.  This is an infinitely long stream, but in any given
time we can examine only a finite portion of it.  Thus, our programs
will never know that the entire infinite stream is not there.</p>

<p class="trans" lang="ja">
<tt>integers</tt> ã¯ã€ãã® <tt>car</tt> ãŒ1ã§ã€<tt>cdr</tt> ã¯2ã‹ã‚‰å§‹ã¾ã‚‹æ•´æ•°ã‚’ä½œã‚Šå‡ºã™ã¨ã„ã†ç´„æŸã§ã‚ã‚‹ã€ã¨ã„ã†å¯¾ã¨ãªã‚‹ã ã‚ã†ã‹ã‚‰ã€ã“ã‚Œã¯ç­‹ãŒé€šã£ã¦ã„ã‚‹ã€‚
ã“ã‚Œã¯ç„¡é™ã«é•·ã„ã‚¹ãƒˆãƒªãƒ¼ãƒ ã ãŒã€ãã®ã†ã¡ã®æœ‰é™ãªéƒ¨åˆ†ã®ã¿ã‚’ã€ä¸ãˆã‚‰ã‚ŒãŸä»»æ„ã®æ™‚é–“ä»¥å†…ã§èª¿ã¹ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
ã‚ˆã£ã¦ã€å®Œå…¨ãªç„¡é™ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒãã“ã«ã¯å­˜åœ¨ã—ãªã„ã€ã¨ã„ã†ã“ã¨ã‚’ã€ç§ãŸã¡ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€ã¾ã£ãŸãçŸ¥ã‚‰ãªã„ã¾ã¾ã ã‚ã†ã€‚
</p>

<p class="orig" lang="en">
Using <tt>integers</tt> we can define other infinite streams, such as
the stream of integers that are not divisible by 7:</p>

<p class="trans" lang="ja">
<tt>integers</tt> ã‚’ä½¿ã†ã¨ã€ä¾‹ãˆã°7ã§ã¯å‰²ã‚Šåˆ‡ã‚Œãªã„æ•´æ•°ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ãªã©ã€ä»–ã®ç„¡é™ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å®šç¾©ã§ãã‚‹ã€‚
</p>


<p class="lisp"><a name="%_idx_3838"></a>(define (divisible? x y) (= (remainder x y) 0))
(define no-sevens
  (stream-filter (lambda (x) (not (divisible? x 7)))
                 integers))
</p>

<p class="orig" lang="en">
Then we can find integers not divisible by 7 simply by accessing
elements of this stream:</p>

<p class="trans" lang="ja">
ã™ã‚‹ã¨ã€å˜ã«ã“ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®è¦ç´ ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã“ã¨ã§ã€7ã§ã¯å‰²ã‚Šåˆ‡ã‚Œãªã„æ•´æ•°ã‚’è¦‹ã¤ã‘ã‚‰ã‚Œã‚‹ã€‚
</p>

<p class="lisp">(stream-ref no-sevens 100)
<i>117</i>
</p>

<p class="orig" lang="en">
In analogy with <tt>integers</tt>, we can define the infinite stream of
Fibonacci numbers:</p>

<p class="trans" lang="ja">
<tt>integers</tt> ã¨ã®é¡æ¨ã«ã‚ˆã‚Šã€ãƒ•ã‚£ãƒœãƒŠãƒƒãƒæ•°ã®ç„¡é™ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å®šç¾©ã§ãã‚‹ã€‚
</p>


<p class="lisp">(define (fibgen a b)
  (cons-stream a (fibgen b (+ a b))))
<a name="%_idx_3840"></a>(define fibs (fibgen 0 1))
</p>


<p class="orig" lang="en">
<tt>Fibs</tt> is a pair whose <tt>car</tt> is 0 and whose <tt>cdr</tt> is a
promise to evaluate <tt>(fibgen 1 1)</tt>.  When we evaluate this delayed
<tt>(fibgen 1 1)</tt>, it
will produce a pair whose <tt>car</tt> is 1 and whose <tt>cdr</tt> is a
promise to evaluate <tt>(fibgen 1 2)</tt>, and so on.</p>

<p class="trans" lang="ja">
<tt>fibs</tt> ã¯ã€ãã® <tt>car</tt>ãŒ0ã§ã€<tt>cdr</tt> ã¯ <tt>(fibgen 1 1)</tt> ã‚’è©•ä¾¡ã™ã‚‹ã¨ã„ã†ç´„æŸã§ã‚ã‚‹ã€ã¨ã„ã†å¯¾ã§ã‚ã‚‹ã€‚
ã“ã®é…å»¶ã•ã‚ŒãŸ <tt>(fibgen 1 1)</tt> ã‚’è©•ä¾¡ã™ã‚‹ã¨ãã€ã“ã‚Œã¯ã€ãã® <tt>car</tt>ãŒ1ã§ã€<tt>cdr</tt> ã¯ <tt>(fibgen 1 2)</tt> ã‚’è©•ä¾¡ã™ã‚‹ã¨ã„ã†ç´„æŸã§ã‚ã‚‹ã€ã¨ã„ã†å¯¾ã‚’ä½œã‚Šå‡ºã™ã ã‚ã†ã—ã€ä»¥ä¸‹åŒæ§˜ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_3842"></a>For a look at a more exciting infinite stream, we can generalize the
<tt>no-sevens</tt> example to construct the infinite stream of prime
numbers, using a method known as the <a name="%_idx_3844"></a><em>sieve of
Eratosthenes</em>.<a name="call_footnote_Temp_455" href="#footnote_Temp_455"><sup><small>60</small></sup></a> We
start with the integers beginning with 2, which is the first prime.
To get the rest of the primes, we start by filtering the multiples of
2 from the rest of the integers.  This leaves a stream beginning with
3, which is the next prime.  Now we filter the multiples of 3 from the
rest of this stream.  This leaves a stream beginning with 5, which is
the next prime, and so on.  In other words, we construct the primes by
a sieving process, described as follows: To sieve a stream <tt>S</tt>,
form a stream whose first element is the first element of <tt>S</tt> and
the rest of which is obtained by filtering all multiples of the first element
of <tt>S</tt> out of the rest of <tt>S</tt> and sieving the result. This
process is readily described in terms of stream operations:</p>

<p class="trans" lang="ja">
ã‚‚ã£ã¨ã‚ãã‚ãã™ã‚‹ã‚ˆã†ãªã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’è¦‹ã‚‹ãŸã‚ã«ã€ç§ãŸã¡ã¯ã€<tt>no-sevens</tt> ã®ä¾‹ã‚’ä¸€èˆ¬åŒ–ã—ã¦ã€ç´ æ•°ã®ç„¡é™ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’æ§‹ç¯‰ã™ã‚‹ã“ã¨ãŒã§ãã‚‹â€”â€”<em>ã‚¨ãƒ©ãƒˆã‚¹ãƒ†ãƒã‚¹ã®<ruby><rb>ç¯©</rb><rp> (</rp><rt>ãµã‚‹ã„</rt><rp>) </rp></ruby></em>ã¨ã—ã¦çŸ¥ã‚‰ã‚Œã‚‹æ–¹æ³•ã‚’ä½¿ã£ã¦<a href="#footnote_Temp_455"><sup><small>60</small></sup></a>ã€‚
2â€”â€”æœ€åˆã®ç´ æ•°â€”â€”ã‹ã‚‰å§‹ã¾ã‚‹æ•´æ•°ã¨ã¨ã‚‚ã«ã€å§‹ã‚ã‚‹ã€‚
æ®‹ã‚Šã®ç´ æ•°ã‚’å¾—ã‚‹ãŸã‚ã«ã¯ã€æ®‹ã‚Šã®æ•´æ•°ã‹ã‚‰ã€2ã®å€æ•°ã‚’ãƒ•ã‚£ãƒ«ã‚¿ã§é™¤å»ã™ã‚‹ã“ã¨ã‹ã‚‰å§‹ã‚ã‚‹ã€‚
ã“ã‚Œã«ã‚ˆã‚Šã€3â€”â€”æ¬¡ã®ç´ æ•°â€”â€”ã‹ã‚‰å§‹ã¾ã‚‹ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒæ®‹ã•ã‚Œã‚‹ã€‚
ã“ã“ã§ã€ã“ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®æ®‹ã‚Šã®éƒ¨åˆ†ã‹ã‚‰ã€3ã®å€æ•°ã‚’ãƒ•ã‚£ãƒ«ã‚¿ã§é™¤å»ã™ã‚‹ã€‚
ã“ã‚Œã«ã‚ˆã‚Šã€5â€”â€”æ¬¡ã®ç´ æ•°â€”â€”ã‹ã‚‰å§‹ã¾ã‚‹ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒæ®‹ã•ã‚Œã‚‹ã€‚ä»¥ä¸‹åŒæ§˜ã§ã‚ã‚‹ã€‚
æ›è¨€ã™ã‚Œã°ã€ä»¥ä¸‹ã«è¿°ã¹ã‚‹ã‚ˆã†ãªã€ç¯©ã«ã‹ã‘ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã«ã‚ˆã‚Šã€ç´ æ•°ã‚’æ§‹ç¯‰ã™ã‚‹ã®ã§ã‚ã‚‹ã€‚
ã™ãªã‚ã¡ã€<tt>S</tt> ã¨ã„ã†ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ç¯©ã«ã‹ã‘ã‚‹ãŸã‚ã«ã¯ã€ãã®æœ€åˆã®è¦ç´ ãŒ <tt>S</tt> ã®æœ€åˆã®è¦ç´ ã§ã‚ã£ã¦ã€ã‹ã¤ã€ãã®æ®‹ã‚Šã®éƒ¨åˆ†ã¯ã€<tt>S</tt> ã®æ®‹ã‚Šã®éƒ¨åˆ†ã‹ã‚‰<tt>S</tt> ã®æœ€åˆã®è¦ç´ ã®ã™ã¹ã¦ã®å€æ•°ã‚’ãƒ•ã‚£ãƒ«ã‚¿ã«ã‹ã‘ã¦ãã®çµæœã‚’ç¯©ã„è½ã¨ã™ã“ã¨ã§å¾—ã‚‰ã‚Œã‚‹ã€ã¨ã„ã†ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å½¢æˆã›ã‚ˆã€‚
ã“ã®ãƒ—ãƒ­ã‚»ã‚¹ã¯ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ æ“ä½œã‚’ä½¿ã£ã¦ã€ã‚ã£ã•ã‚Šè¨˜è¿°ã•ã‚Œã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_3852"></a>(define (sieve stream)
  (cons-stream
   (stream-car stream)
   (sieve (stream-filter
           (lambda (x)
             (not (divisible? x (stream-car stream))))
           (stream-cdr stream)))))

<a name="%_idx_3854"></a>(define primes (sieve (integers-starting-from 2)))
</p>


<p class="orig" lang="en">
Now to find a particular prime we need only ask for it:</p>

<p class="trans" lang="ja">
ã•ã¦ã€ç‰¹å®šã®ç´ æ•°ã‚’è¦‹ã¤ã‘ã‚‹ã«ã¯ã€ç§ãŸã¡ã¯ã€ãŸã ãã‚Œã‚’æ±‚ã‚ã‚‹ã ã‘ã§ã‚ˆã„ã€‚
</p>

<p class="lisp">(stream-ref primes 50)
<i>233</i>
</p>


<p class="orig" lang="en">
It is interesting to contemplate the signal-processing system set up
by <tt>sieve</tt>, shown in the <a name="%_idx_3856"></a>``Henderson diagram'' in
figure <a href="#%_fig_3.31">3.31</a>.<a name="call_footnote_Temp_456" href="#footnote_Temp_456"><sup><small>61</small></sup></a>
The input stream feeds into an
``un<tt>cons</tt>er'' that separates the first element of the stream from the
rest of the stream.
The first element is used to construct a divisibility filter, through
which the rest is passed, and the output of the filter is fed to
another sieve box.  Then the original first element is <tt>cons</tt>ed onto the
output of the internal sieve to form the output stream.  Thus, not
only is the stream infinite, but the signal processor is also
infinite, because the sieve contains a sieve within it.</p>

<p class="trans" lang="ja">
å›³<a href="#%_fig_3.31">3.31</a>ã®ã€Œãƒ˜ãƒ³ãƒ€ãƒ¼ã‚½ãƒ³å›³ã€ã«ç¤ºã•ã‚Œã‚‹ã€<tt>sieve</tt> ã«ã‚ˆã‚Šç¯‰ã‹ã‚Œã‚‹ä¿¡å·å‡¦ç†ã‚·ã‚¹ãƒ†ãƒ ã‚’è€ƒãˆã‚‹ã“ã¨ã¯ã€èˆˆå‘³æ·±ã„<a href="#footnote_Temp_456"><sup><small>61</small></sup></a>ã€‚
å…¥åŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¯ã€ãã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®æœ€åˆã®è¦ç´ ã‚’ãã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®æ®‹ã‚Šã®éƒ¨åˆ†ã‹ã‚‰åˆ†é›¢ã™ã‚‹ã€ã€Œé€†<tt>cons</tt>å™¨ã€ã¸ã¨æµã‚Œè¾¼ã‚€ã€‚
æœ€åˆã®è¦ç´ ã¯ã€æ•´é™¤æ€§ã®ãƒ•ã‚£ãƒ«ã‚¿â€”â€”ã“ã‚Œã‚’é€šã—ã¦ã€æ®‹ã‚Šã®éƒ¨åˆ†ãŒæ¸¡ã•ã‚Œã‚‹â€”â€”ã‚’æ§‹ç¯‰ã™ã‚‹ã®ã«ä½¿ã‚ã‚Œã€ãƒ•ã‚£ãƒ«ã‚¿ã®å‡ºåŠ›ãŒã€ã‚‚ã†ä¸€ã¤ã®ç¯©ã®ç®±ã«ä¸ãˆã‚‰ã‚Œã‚‹ã€‚
ãã—ã¦ã€å…ƒã®æœ€åˆã®è¦ç´ ãŒã€å†…éƒ¨ã®ç¯©ã®å‡ºåŠ›ã®ä¸Šã« <tt>cons</tt> ã•ã‚Œã¦ã€å‡ºåŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å½¢æˆã™ã‚‹ã€‚
ã“ã®ã‚ˆã†ã«ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒç„¡é™ã§ã‚ã‚‹ã ã‘ã§ãªãã€ä¿¡å·å‡¦ç†å™¨ã‚‚ã¾ãŸç„¡é™ãªã®ã§ã‚ã‚‹â€”â€”ãªãœãªã‚‰ã€ç¯©ã¯è‡ªåˆ†ã®å†…éƒ¨ã«ç¯©ã‚’å«ã‚€ã‹ã‚‰ã§ã‚ã‚‹ã€‚
</p>

<a name="%_fig_3.31"></a>
<figure>
<img src="ch3-Z-G-35.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.31:</b>  The prime sieve viewed as a signal-processing system.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³3.31:</b> ä¿¡å·å‡¦ç†ã‚·ã‚¹ãƒ†ãƒ ã¨ã—ã¦è¦‹ãŸã€ç´ æ•°ã®ç¯©</figcaption>
</figure>


<a name="%_sec_Temp_457"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_457">Defining streams implicitly</a></h4>
<h4 class="trans" lang="ja">ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’æš—é»™è£¡ã«å®šç¾©ã™ã‚‹</h4>

<p class="orig" lang="en">
<a name="%_idx_3860"></a>
The <tt>integers</tt> and <tt>fibs</tt> streams above were defined by
specifying ``generating'' procedures that explicitly compute the
stream elements one by one. An alternative way to specify streams is
to take advantage of delayed evaluation to define streams implicitly.
For example, the following expression defines the stream <tt>ones</tt> to
be an infinite stream of ones:</p>

<p class="trans" lang="ja">
ä¸Šè¨˜ã® <tt>integers</tt> ã¨ <tt>fibs</tt> ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¯ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ è¦ç´ ã‚’ä¸€ã¤ä¸€ã¤æ˜ç¤ºçš„ã«è¨ˆç®—ã™ã‚‹ã‚ˆã†ãªã€ã€Œç”Ÿæˆã™ã‚‹ã€æ‰‹ç¶šãã‚’æŒ‡å®šã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€å®šç¾©ã•ã‚ŒãŸã€‚
ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’è¦å®šã™ã‚‹ãŸã‚ã®åˆ¥ã®æ–¹æ³•ã¯ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’æš—é»™ã«å®šç¾©ã™ã‚‹ãŸã‚ã«é…å»¶è©•ä¾¡ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚
ãŸã¨ãˆã°ã€ä»¥ä¸‹ã®å¼ã¯ã€<tt>ones</tt> ã¨ã„ã†ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ã€1ã®ç„¡é™ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã ã¨å®šç¾©ã™ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_3862"></a>(define ones (cons-stream 1 ones))
</p>

<p class="orig" lang="en">
This works much like the definition of a recursive procedure: <tt>ones</tt> is a pair whose <tt>car</tt> is 1 and whose <tt>cdr</tt> is a promise
to evaluate <tt>ones</tt>.  Evaluating the <tt>cdr</tt> gives us again a 1
and a promise to evaluate <tt>ones</tt>, and so on.</p>

<p class="trans" lang="ja">
ã“ã‚Œã¯ã€å†å¸°çš„æ‰‹ç¶šãã®å®šç¾©ã¨ã»ã¨ã‚“ã©åŒã˜ã‚ˆã†ã«ã€ã†ã¾ãå‹•ãã€‚<tt>ones</tt> ã¯ã€ãã® <tt>car</tt> ãŒ1ã§ã€<tt>cdr</tt> ã¯ <tt>ones</tt> ã‚’è©•ä¾¡ã™ã‚‹ã¨ã„ã†ç´„æŸã§ã‚ã‚‹ã€ã¨ã„ã†å¯¾ã§ã‚ã‚‹ã€‚
<tt>cdr</tt> ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ã§ã€å†åº¦ã€1ã¨ã€<tt>ones</tt> ã‚’è©•ä¾¡ã™ã‚‹ã¨ã„ã†ç´„æŸã¨ãŒä¸ãˆã‚‰ã‚Œã€ä»¥ä¸‹åŒæ§˜ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
We can do more interesting things by manipulating streams with
operations such as <tt>add-streams</tt>, which produces the elementwise
sum of two given streams:<a name="call_footnote_Temp_458" href="#footnote_Temp_458"><sup><small>62</small></sup></a></p>

<p class="trans" lang="ja">
ãŸã¨ãˆã° <tt>add-streams</tt> â€”â€”ä¸ãˆã‚‰ã‚ŒãŸäºŒã¤ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®ã€è¦ç´ ã”ã¨ã®å’Œã‚’ä½œã‚Šå‡ºã™â€”â€”ãªã©ã®æ“ä½œã‚’ä½¿ã£ã¦ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’æ“ä½œã™ã‚‹ã“ã¨ã§ã€ã‚ˆã‚Šèˆˆå‘³æ·±ã„ã“ã¨ã‚’è¡Œã†ã“ã¨ãŒã§ãã‚‹<a href="#footnote_Temp_458"><sup><small>62</small></sup></a>ã€‚
</p>

<p class="lisp"><a name="%_idx_3864"></a>(define (add-streams s1 s2)
  (stream-map + s1 s2))
</p>

<p class="orig" lang="en">
Now we can define the integers as follows:
</p>

<p class="trans" lang="ja">
ä»Šã‚„ç§ãŸã¡ã¯ã€æ•´æ•°ã‚’ä»¥ä¸‹ã®ã‚ˆã†ã«å®šç¾©ã§ãã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_3866"></a>(define integers (cons-stream 1 (add-streams ones integers)))
</p>

<p class="orig" lang="en">
This defines <tt>integers</tt> to be a stream whose first element is 1
and the rest of which is the sum of <tt>ones</tt> and <tt>integers</tt>.  Thus, the
second element of <tt>integers</tt> is 1 plus the first element of <tt>integers</tt>,
or 2; the third element of <tt>integers</tt> is 1 plus the second
element of <tt>integers</tt>, or 3; and so on.  This definition works
because, at any point, enough of the <tt>integers</tt> stream has been
generated so that we can feed it back into the definition to produce
the next integer.</p>

<p class="trans" lang="ja">
ã“ã‚Œã¯ã€<tt>integers</tt> ã‚’ã€ãã®1ç•ªç›®ã®è¦ç´ ãŒ1ã§ã€æ®‹ã‚Šã®éƒ¨åˆ†ãŒ <tt>ones</tt> ã¨<tt>integers</tt> ã¨ã®å’Œã§ã‚ã‚‹ã‚ˆã†ãªã‚¹ãƒˆãƒªãƒ¼ãƒ ã§ã‚ã‚‹ã€ã¨å®šç¾©ã—ã¦ã„ã‚‹ã€‚
ã‚ˆã£ã¦ã€<tt>integers</tt> ã®2ç•ªç›®ã®è¦ç´ ã¯ã€1ã€è¶³ã™ã€<tt>integers</tt> ã®1ç•ªç›®ã®è¦ç´ ã§ã‚ã‚Šã€ã¤ã¾ã‚Šã€2ã§ã‚ã‚‹ã€‚<tt>integers</tt> ã®3ç•ªç›®ã®è¦ç´ ã¯ã€1ã€è¶³ã™ã€<tt>integers</tt> ã®2ç•ªç›®ã®è¦ç´ ã§ã‚ã‚Šã€ã¤ã¾ã‚Šã€3ã§ã‚ã‚‹ã€‚ä»¥ä¸‹åŒæ§˜ã ã€‚
ã“ã®å®šç¾©ã¯ã†ã¾ãã‚†ãã€‚ã¨ã„ã†ã®ã‚‚ã€ä»»æ„ã®æ™‚ç‚¹ã«ãŠã„ã¦ã€<tt>integers</tt> ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®ã†ã¡ååˆ†ãªé‡ãŒã€æ¬¡ã®æ•´æ•°ã‚’ä½œã‚Šå‡ºã™ãŸã‚ã®å®šç¾©ã¸ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã§ãã‚‹ã‚ˆã†ã«ã¨ç”Ÿæˆæ¸ˆã¿ã ã‹ã‚‰ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
We can define the Fibonacci numbers in the same style:</p>

<p class="trans" lang="ja">
åŒã˜ã‚„ã‚Šæ–¹ã§ãƒ•ã‚£ãƒœãƒŠãƒƒãƒæ•°ã‚’å®šç¾©ã§ãã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_3868"></a>(define fibs
  (cons-stream 0
               (cons-stream 1
                            (add-streams (stream-cdr fibs)
                                         fibs))))
</p>


<p class="orig" lang="en">
This definition says that <tt>fibs</tt> is a stream beginning with 0 and
1, such that the rest of the stream can be generated by adding <tt>fibs</tt>
to itself shifted by one place:</p>

<p class="trans" lang="ja">
ã“ã®å®šç¾©ã¯ã€<tt>fibs</tt> ã¨ã¯0ã¨1ã§å§‹ã¾ã‚‹ã‚¹ãƒˆãƒªãƒ¼ãƒ ã§ã‚ã£ã¦ã€å ´æ‰€ã‚’ä¸€ã¤åˆ†ã ã‘ãšã‚‰ã—ãŸ <tt>fibs</tt> è‡ªèº«ã« <tt>fibs</tt> ã‚’åŠ ãˆã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®æ®‹ã‚Šã®éƒ¨åˆ†ã‚’ç”Ÿæˆã§ãã‚‹ã‚ˆã†ã«ãªã£ã¦ã„ã‚‹ã®ã ã€ã¨è¨€ã£ã¦ã„ã‚‹ã€‚
</p>

<figure>
<table class="com-align-R">
<tr><td></td><td></td><td>1 </td><td>1 </td><td>2 </td><td>3 </td><td>5 </td><td>8 </td><td>13 </td><td>21 </td><td style="text-align: left; white-space: nowrap"><tt>...</tt> = <tt>(stream-cdr fibs)</tt></td></tr>

<tr><td></td><td></td><td>0 </td><td>1 </td><td>1 </td><td>2 </td><td>3 </td><td>5 </td><td> 8 </td><td>13 </td><td style="text-align: left;"><tt>...</tt> = <tt>fibs</tt></td></tr>

<tr><td>0 </td><td>1 </td><td>1 </td><td>2 </td><td>3 </td><td>5 </td><td>8 </td><td>13 </td><td>21 </td><td>34 </td><td style="text-align: left;"><tt>...</tt> = <tt>fibs</tt></td></tr>

</table>
</figure>

<p class="orig" lang="en">
<tt>Scale-stream</tt> is another useful procedure in formulating such stream definitions.
This multiplies each item in a stream by a given
constant:</p>

<p class="trans" lang="ja">
<tt>scale-stream</tt> ã¯ã€ãã†ã—ãŸã‚¹ãƒˆãƒªãƒ¼ãƒ å®šç¾©ã‚’å®šå¼åŒ–ã™ã‚‹éš›ã«æœ‰ç”¨ãªã€åˆ¥ã®æ‰‹ç¶šãã§ã‚ã‚‹ã€‚
ã“ã‚Œã¯ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ å†…ã®å„é …ç›®ã¨ã€ä¸ãˆã‚‰ã‚ŒãŸå®šæ•°ã¨ã‚’ä¹—ç®—ã™ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_3870"></a>(define (scale-stream stream factor)
  (stream-map (lambda (x) (* x factor)) stream))
</p>


<p class="orig" lang="en">
For example,</p>

<p class="trans" lang="ja">
ãŸã¨ãˆã°ã€
</p>

<p class="lisp">(define double (cons-stream 1 (scale-stream double 2)))
</p>

<p class="orig" lang="en">
produces the stream of powers of 2: 1, 2, 4, 8, 16, 32, <tt>...</tt>.</p>

<p class="trans" lang="ja">
ã¯ã€2ã®å†ªã®ã‚¹ãƒˆãƒªãƒ¼ãƒ â€”â€”ã¤ã¾ã‚Šã€1, 2, 4, 8, 16, 32, <tt>...</tt> â€”â€”ã‚’ä½œã‚Šå‡ºã™ã€‚
</p>

<p class="orig" lang="en">
An alternate definition of the stream of primes can be given by
starting with the integers and filtering them by testing for
primality.  We will need the first prime, 2, to get started:</p>

<p class="trans" lang="ja">
æ•´æ•°ã¨ã€ç´ æ•°æ€§ã‚’è©¦ã™ã“ã¨ã§ãã‚Œã‚‰ã®æ•´æ•°ã‚’ãƒ•ã‚£ãƒ«ã‚¿ã«ã‹ã‘ã‚‹ã“ã¨ã¨ã€ã‹ã‚‰å§‹ã‚ã‚‹ã“ã¨ã§ã€ç´ æ•°ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®ä»£æ›¿çš„ãªå®šç¾©ã‚’ä¸ãˆã‚‹ã“ã¨ãŒå¯èƒ½ã ã€‚
å§‹ã‚ã‚‹ã«ã¯ã€æœ€åˆã®ç´ æ•°â€”â€”ã¤ã¾ã‚Š2â€”â€”ãŒå¿…è¦ã«ãªã‚‹ã ã‚ã†ã€‚
</p>


<p class="lisp"><a name="%_idx_3872"></a>(define primes
  (cons-stream
   2
   (stream-filter prime? (integers-starting-from 3))))
</p>


<p class="orig" lang="en">
This definition is not so straightforward as it appears, because we
will test whether a number <em>n</em> is prime by checking whether <em>n</em> is
divisible by a prime (not by just any integer) less than or equal to
<img src="book-Z-G-D-13.gif" border="0"><em>n</em>:</p>

<p class="trans" lang="ja">
ã“ã®å®šç¾©ã¯ã€è¦‹ã‹ã‘ã»ã©åˆ†ã‹ã‚Šã‚„ã™ã„ã‚‚ã®ã§ã¯ãªã„ã€‚ãªãœãªã‚‰ã€
&radic;<em class="en">n</em> 
ä»¥ä¸‹ã®ï¼ˆå˜ãªã‚‹ä»»æ„ã®æ•´æ•°ã§ã¯ãªãã¦ï¼‰ç´ æ•°ã«ã‚ˆã£ã¦ <em class="en">n</em> ãŒå‰²ã‚Šåˆ‡ã‚Œã‚‹ã‹ã©ã†ã‹ã‚’ç¢ºã‹ã‚ã‚‹ã“ã¨ã§ã€<em class="en">n</em> ã¨ã„ã†æ•°ãŒç´ æ•°ã‹ã©ã†ã‹ã‚’èª¿ã¹ã‚‹ã§ã‚ã‚ã†ã‹ã‚‰ã€‚
</p>

<p class="lisp"><a name="%_idx_3874"></a>(define (prime? n)
  (define (iter ps)
    (cond ((&gt; (square (stream-car ps)) n) true)
          ((divisible? n (stream-car ps)) false)
          (else (iter (stream-cdr ps)))))
  (iter primes))
</p>

<p class="orig" lang="en">
This is a recursive definition, since <tt>primes</tt> is defined in terms
of the <tt>prime?</tt> predicate, which itself uses the <tt>primes</tt>
stream.  The reason this procedure works is that, at any point, enough
of the <tt>primes</tt> stream has been generated to test the primality of
the numbers we need to check next.  That is, for every <em>n</em> we test for
primality, either <em>n</em> is not prime (in which case there is a prime
already generated that divides it) or <em>n</em> is prime (in which case
there is a prime already generated -- i.e., a prime less than
<em>n</em> -- that is greater than <img src="book-Z-G-D-13.gif" border="0"><em>n</em>).<a name="call_footnote_Temp_459" href="#footnote_Temp_459"><sup><small>63</small></sup></a>

</p>

<p class="trans" lang="ja">
ã“ã‚Œã¯å†å¸°çš„å®šç¾©ã§ã‚ã‚‹ã€‚ã¨ã„ã†ã®ã‚‚ã€<tt>primes</tt> ãŒã€<tt>prime?</tt> ã¨ã„ã†è¿°èªâ€”â€”ã“ã‚Œè‡ªèº«ãŒ <tt>primes</tt> ã¨ã„ã†ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½¿ã£ã¦ã„ã‚‹â€”â€”ã‚’ä½¿ã£ã¦å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‹ã‚‰ã§ã‚ã‚‹ã€‚
ã“ã®æ‰‹ç¶šããŒã†ã¾ãå‹•ãç†ç”±ã¯ã€ã©ã®æ™‚ç‚¹ã«ãŠã„ã¦ã‚‚ã€<tt>primes</tt> ã¨ã„ã†ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®ã†ã¡ã®ååˆ†ãªé‡ãŒã€<!--ç§ãŸã¡ãŒæ¬¡ã«ç¢ºã‹ã‚ã‚‹ãŸã‚ã«å¿…è¦ã¨ã—ã¦ã„ã‚‹æ•°-->ç§ãŸã¡ãŒæ¬¡ã«ç¢ºã‹ã‚ãªãã¦ã¯ã„ã‘ãªã„æ•°ã®ç´ æ•°æ€§ã‚’èª¿ã¹ã‚‹ãŸã‚ã«ã€æ—¢ã«ç”Ÿæˆã•ã‚Œã¦ã„ã‚‹ã‹ã‚‰ã§ã‚ã‚‹ã€‚<span class="note">(ãªã‚“ã‹ä¸å®‰ãªè¨³ã ãªã€‚)</span>
ã¤ã¾ã‚Šã€ç§ãŸã¡ãŒç´ æ•°æ€§ã‚’è©¦ã™ã™ã¹ã¦ã® <em class="en">n</em> ã«ã¤ã„ã¦ã€<em class="en">n</em> ãŒç´ æ•°ã§ã¯ãªã„ (ãã®å ´åˆã€<em class="en">n</em> ã‚’å‰²ã‚Šåˆ‡ã‚‹ã‚ˆã†ãªã€æ—¢ã«ç”Ÿæˆã•ã‚ŒãŸç´ æ•°ãŒå­˜åœ¨ã™ã‚‹) ã‹ã€ã‚ã‚‹ã„ã¯ã€<em class="en">n</em> ãŒç´ æ•°ã§ã‚ã‚‹ (ãã®å ´åˆã€<!--æ—¢ã«ç”Ÿæˆã•ã‚ŒãŸç´ æ•°â€”â€”ã¤ã¾ã‚Šã€<em class="en">n</em> æœªæº€ã®ç´ æ•°â€”â€”ã§ã‚ã£ã¦ &radic;<em class="en">n</em> ã‚ˆã‚Šã¯å¤§ãã„ã‚‚ã®ãŒã€å­˜åœ¨ã™ã‚‹-->&radic;<em class="en">n</em> ã‚ˆã‚Šã¯å¤§ãã„ã‚ˆã†ãªã€æ—¢ã«ç”Ÿæˆã•ã‚ŒãŸç´ æ•°â€”â€”ã¤ã¾ã‚Šã€<em class="en">n</em> æœªæº€ã®ç´ æ•°â€”â€”ãŒå­˜åœ¨ã™ã‚‹)<a href="#footnote_Temp_459"><sup><small>63</small></sup></a>ã€‚
</p>

<p class="orig" lang="en"><a name="%_thm_3.53"></a>
<b>Exercise 3.53.</b>  Without running the program, describe the elements of the
stream defined by
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.53.</b> ä»¥ä¸‹ã«ã‚ˆã‚Šå®šç¾©ã•ã‚Œã‚‹ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®è¦ç´ ã‚’ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’å®Ÿè¡Œã›ãšã«èª¬æ˜ã›ã‚ˆã€‚
</p>

<p class="lisp">(define s (cons-stream 1 (add-streams s s)))
</p>

<p class="exercise"><span class="ex_comment"><tt>(cons-stream 1 ...</tt> ã¨ãªã£ã¦ã„ã‚‹ã®ã§ã€1ç•ªç›®ã®è¦ç´ ã¯1ã€‚
ãªãŠã€1=2<sup>0</sup>ã§ã‚ã‚‹ã€‚

2ç•ªç›®ã®è¦ç´ ã¯ã€1ã‹ã‚‰å§‹ã¾ã‚‹ <tt>s</tt> ã¨ã„ã†ã‚¹ãƒˆãƒªãƒ¼ãƒ åŒå£«ã‚’
è¶³ã—ãŸçµæœã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®1ç•ªç›®ã®è¦ç´ ã ã‹ã‚‰ã€
1+1=2=2<sup>1</sup>ã§ã‚ã‚‹ã€‚

3ç•ªç›®ã®è¦ç´ ã¯ã€1ã¨2ã‹ã‚‰å§‹ã¾ã‚‹ <tt>s</tt> ã¨ã„ã†ã‚¹ãƒˆãƒªãƒ¼ãƒ åŒå£«ã‚’
è¶³ã—ãŸçµæœã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®2ç•ªç›®ã®è¦ç´ ã ã‹ã‚‰ã€
2+2=4=2<sup>2</sup>ã§ã‚ã‚‹ã€‚

ä»¥ä¸‹åŒæ§˜ã§ã€kç•ªç›®ã®è¦ç´ ã¯ã€2<sup>k&minus;1</sup>ã§ã‚ã‚‹ã€‚</span>

               s  = (1  2  4   8 ...
               s  = (1  2  4   8 ...
(add-streams s s) = (2  4  8  16 ...
</p>

<p class="orig" lang="en"><a name="%_thm_3.54"></a>
<b>Exercise 3.54.</b>  Define a procedure <a name="%_idx_3886"></a><a name="%_idx_3888"></a><a name="%_idx_3890"></a><tt>mul-streams</tt>, analogous to <tt>add-streams</tt>,
that produces the elementwise product of its two input streams.
Use this together with the stream of <tt>integers</tt> to complete the
following definition of the stream whose <em>n</em>th element (counting from 0)
is <em>n</em> + 1 factorial:
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.54.</b> <tt>add-streams</tt> ã¨é¡ä¼¼ã—ãŸã€äºŒã¤ã®å…¥åŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®è¦ç´ ã”ã¨ã®ç©ã‚’ä½œã‚Šå‡ºã™ã‚ˆã†ãª <tt>mul-streams</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’ã€å®šç¾©ã›ã‚ˆã€‚
ã“ã‚Œã‚’ <tt>integers</tt> ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¨ã¨ã‚‚ã«ä½¿ã£ã¦ã€<em class="en">n</em> ç•ªç›®ã®è¦ç´  (0ã‹ã‚‰æ•°ãˆã‚‹) ãŒ
<span class="math"><em class="en">n</em> + 1</span>
ã®éšä¹—ã§ã‚ã‚‹ã‚ˆã†ãªã‚¹ãƒˆãƒªãƒ¼ãƒ ã«ã¤ã„ã¦ã®ä»¥ä¸‹ã®å®šç¾©ã‚’å®Œæˆã•ã›ã‚ˆã€‚
</p>

<p class="lisp">(define factorials (cons-stream 1 (mul-streams &lt;<em>??</em>&gt; &lt;<em>??</em>&gt;)))
</p>
<!--
     n:  0  1  2   3    4 ...
(n+1)!:  1  2  6  24  120 ...
-->
<p class="exercise"><span class="ex_comment">; ã¾ãšå®šç¾©ã€‚</span>
(define (mul-streams s1 s2) (stream-map * s1 s2))

<span class="ex_comment">ã“ã“ã§ã€ä»¥ä¸‹ã®ã‚ˆã†ã«è€ƒãˆã‚‰ã‚Œã‚‹ã€‚</span>
              n:  0  1  2   3    4 ...
    factorials = (1  2  6  24  120 ...
(cdr integers) = (2  3  4   5    6 ... 

<span class="ex_comment">; ã¨ã„ã†ã“ã¨ã¯ã€</span>
(define factorials (cons-stream 1 (mul-streams (cdr integers) factorials)))
<span class="ex_comment">; ã‚ã‚‹ã„ã¯ã€</span>
(define factorials (cons-stream 1 (mul-streams factorials (cdr integers))))
<span class="ex_comment">; ã¨å®šç¾©ã™ã‚Œã°è‰¯ã„ã ã‚ã†ã€‚
</p>

<p class="orig" lang="en"><a name="%_thm_3.55"></a>
<b>Exercise 3.55.</b>  Define a procedure <a name="%_idx_3892"></a><tt>partial-sums</tt> that takes as argument a
stream <em>S</em> and returns the stream whose
elements are <em>S</em><sub>0</sub>, <em>S</em><sub>0</sub> + <em>S</em><sub>1</sub>, <em>S</em><sub>0</sub> + <em>S</em><sub>1</sub> + <em>S</em><sub>2</sub>, <tt>...</tt>.  For example, <tt>(partial-sums integers)</tt> should be the stream
1, 3, 6, 10, 15, <tt>...</tt>.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.55.</b> <em class="en">S</em> ã¨ã„ã†ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å¼•æ•°ã¨ã—ã¦ã¨ã£ã¦ã€
<span class="math"><em class="en">S</em><sub>0</sub></span>, 
<span class="math"><em class="en">S</em><sub>0</sub> + <em class="en">S</em><sub>1</sub>, 
<span class="math"></span><em class="en">S</em><sub>0</sub> + <em class="en">S</em><sub>1</sub> + <em class="en">S</em><sub>2</sub>,</span> 
<tt>...</tt>
ã‚’è¦ç´ ã¨ã™ã‚‹ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’è¿”ã™ã‚ˆã†ãªã€<tt>partial-sums</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’å®šç¾©ã›ã‚ˆã€‚
ãŸã¨ãˆã°ã€<tt>(partial-sums integers)</tt> ã¯ã€1, 3, 6, 10, 15, <tt>...</tt> ã‚’è¿”ã™ã¯ãšã ã€‚
</p>

<p class="exercise">    S0   S1   S2   S3   S4 ...
     0   S0   S1   S2   S3 ...
     0    0   S0   S1   S2 ...
               ï¸™
+&#41;_______________________________

<span class="ex_comment">ã¨ã„ã†è¶³ã—ç®—ã‚’ã—ãŸã„ã®ã ãªã€‚ã§ã‚‚ç´ ç›´ã«ã“ã†ã„ã†è¨ˆç®—ã¯ã§ããªãã†ã€‚
ã§ã€è€ƒãˆç›´ã—ã¦ã¿ã‚‹ã¨ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã£ã¦ã„ã‚‹ã€‚</span>

                    S   = (S0  S1     S2        S3           S4 ...)
      (partial-sums S)  = (S0  S0+S1  S0+S1+S2  S0+S1+S2+S3  ...)
        (stream-cdr S)  = (S1  S2     S3        S4 ...)

<span class="ex_comment">; ã¨ã„ã†ã‚ã‘ã§ã€å¤šåˆ†ä»¥ä¸‹ã®å®šç¾©ã«ãªã‚‹ã¯ãšã€‚</span>

(define (partial-sums S)
  (cons (stream-car S)
        (add-streams (partial-sums S) (stream-cdr S))))
</p>


<p class="orig" lang="en"><a name="%_thm_3.56"></a>
<b>Exercise 3.56.</b>  A famous problem, first raised by <a name="%_idx_3894"></a>R. Hamming, is to enumerate, in
ascending order with no repetitions, all positive integers with no
prime factors other than 2, 3, or 5.  One obvious way to do this is to
simply test each integer in turn to see whether it has any factors
other than 2, 3, and 5.  But this is very inefficient, since, as the
integers get larger, fewer and fewer of them fit the requirement.  As
an alternative, let us call the required stream of numbers <tt>S</tt> and
notice the following facts about it.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.56.</b> ã‚ã‚‹æœ‰åãªå•é¡Œâ€”â€”æœ€åˆã«R. ãƒãƒŸãƒ³ã‚°ã«ã‚ˆã‚Šæèµ·ã•ã‚ŒãŸâ€”â€”ã¯ã€2ã¨3ã¨5ä»¥å¤–ã®ç´ æ•°ã®å› å­ã‚’æŒãŸãªã„ã™ã¹ã¦ã®æ­£æ•´æ•°ã‚’ã€ç¹°ã‚Šè¿”ã—ãªã—ã«æ˜‡é †ã§æ•°ãˆä¸Šã’ã‚‹ã“ã¨ã€ã¨ã„ã†ã‚‚ã®ã§ã‚ã‚‹ã€‚
ã“ã‚Œã‚’è¡Œã†ãŸã‚ã®ä¸€ã¤ã®è‡ªæ˜ãªæ–¹æ³•ã¯ã€å˜ã«ã€é †ç•ªã«å„æ•´æ•°ã‚’èª¿ã¹ã¦ã€ãã®æ•´æ•°ã«ã¯2ã¨3ã¨5ä»¥å¤–ã®å› å­ãŒä½•ã‹ã‚ã‚‹ã®ã‹å¦ã‹ã‚’ç¢ºã‹ã‚ã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚
ã—ã‹ã—ã“ã‚Œã¯ã€ã¨ã¦ã‚‚éåŠ¹ç‡ã§ã‚ã‚‹ã€‚ã¨ã„ã†ã®ã‚‚ã€æ•´æ•°ãŒå¤§ãããªã‚‹ã«ã¤ã‚Œã¦ã€ãã‚Œã‚‰ã®æ•´æ•°ã®ã†ã¡ã€ã¾ã™ã¾ã™ã‚ãšã‹ãªã‚‚ã®ã—ã‹ã€è¦ä»¶ã«åˆè‡´ã—ãªããªã‚‹ã‹ã‚‰ã§ã‚ã‚‹ã€‚
ä»£æ›¿ç­–ã¨ã—ã¦ã€æ±‚ã‚ã‚‰ã‚Œã¦ã„ã‚‹æ•°ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ <tt>S</tt> ã¨å‘¼ã¼ã†ã€‚ãã—ã¦ã€ã“ã‚Œã«é–¢ã™ã‚‹ä»¥ä¸‹ã®äº‹å®Ÿã«ç•™æ„ã—ã‚ˆã†ã€‚
</p>

<ul class="orig" lang="en">
<li><tt>S</tt> begins with 1.</li>

<li>The elements of <tt>(scale-stream S 2)</tt> are also 
elements of <tt>S</tt>.</li>

<li>The same is true for <tt>(scale-stream S 3)</tt> 
and <tt>(scale-stream 5 S)</tt>.</li>

<li>These are all the elements of <tt>S</tt>.</li>
</ul>

<ul class="trans" lang="ja">
<li><tt>S</tt> ã¯1ã§å§‹ã¾ã‚‹ã€‚</li>
<li><tt>(scale-stream S 2)</tt> ã®è¦ç´ ã¯ã€<tt>S</tt> ã®è¦ç´ ã§ã‚‚ã‚ã‚‹</li>
<li><tt>(scale-stream S 3)</tt> ã¨ <tt>(scale-stream 5 S)</tt> ã«ã¤ã„ã¦ã‚‚åŒã˜ã“ã¨ãŒæˆã‚Šç«‹ã¤ã€‚</li>
<li>ã“ã‚Œã‚‰ã¯ã™ã¹ã¦ <tt>S</tt> ã®è¦ç´ ã§ã‚ã‚‹ã€‚</li>
</ul>


<p class="orig" lang="en">
<a name="%_idx_3896"></a>Now all we have to do is combine elements from these sources.
For this we define a procedure <tt>merge</tt> that combines two ordered
streams into one ordered result stream, eliminating repetitions:</p>

<p class="trans" lang="ja">
ã•ã¦ã€ã‚ã¨ã¯ã€ã“ã‚Œã‚‰ã®æºã‹ã‚‰ã®è¦ç´ ã‚’ç¹‹ãåˆã‚ã›ã‚‹ã ã‘ã ã€‚
ã“ã®ã“ã¨ã®ãŸã‚ã«ã€ç§ãŸã¡ã¯ã€ç¹°ã‚Šè¿”ã—ã«ãªã£ã¦ã„ã‚‹ã‚‚ã®ã‚’å‰Šé™¤ã—ãªãŒã‚‰ã€é †åºã¥ã‘ã‚‰ã‚ŒãŸäºŒã¤ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’é †åºã¥ã‘ã‚‰ã‚ŒãŸä¸€ã¤ã®çµæœã‚¹ãƒˆãƒªãƒ¼ãƒ ã¸ã¨çµåˆã™ã‚‹ã€ <tt>merge</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’å®šç¾©ã™ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_3898"></a>(define (merge s1 s2)
  (cond ((stream-null? s1) s2)
        ((stream-null? s2) s1)
        (else
         (let ((s1car (stream-car s1))
               (s2car (stream-car s2)))
           (cond ((&lt; s1car s2car)
                  (cons-stream s1car (merge (stream-cdr s1) s2)))
                 ((&gt; s1car s2car)
                  (cons-stream s2car (merge s1 (stream-cdr s2))))
                 (else
                  (cons-stream s1car
                               (merge (stream-cdr s1)
                                      (stream-cdr s2)))))))))
</p>


<p class="orig" lang="en">
Then the required stream may be constructed with <tt>merge</tt>, as
follows:</p>

<p class="trans" lang="ja">
ã™ã‚‹ã¨ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¦ã€<tt>merge</tt> ã‚’ç”¨ã„ã¦ã€è¦æ±‚ã•ã‚Œã¦ã„ã‚‹ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’æ§‹ç¯‰ã—å¾—ã‚‹ã€‚
</p>

<p class="lisp">(define S (cons-stream 1 (merge &lt;<em>??</em>&gt; &lt;<em>??</em>&gt;)))
</p>


<p class="orig" lang="en">
Fill in the missing expressions in the places marked &lt;<em>??</em>&gt; above.
</p>

<p class="trans" lang="ja">
ä¸Šè¨˜ã§ &lt;<em class="en">??</em>&gt; ã¨ã„ã†å°ãŒä»˜ã„ã¦ã„ã‚‹å ´æ‰€ã«ã€æ¬ ã‘ã¦ã„ã‚‹å¼ã‚’æ›¸ãå…¥ã‚Œã‚ˆã€‚
</p>


<p class="exercise"><span class="ex_comment">; ã‚„ã£ã¤ã‘ã§æ›¸ãã¨ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚‹ã®ã ãŒã€‚ä»Šåº¦è€ƒãˆã‚ˆã†ã€‚</span>
(define S 
  (cons-stream
     1
     (merge (merge (scale-stream S 2) (scale-stream S 3))
            (scale-stream S 5))))

</p>

<p class="orig" lang="en"><a name="%_thm_3.57"></a>
<b>Exercise 3.57.</b>  <a name="%_idx_3900"></a>How many additions are performed when we compute the <em>n</em>th Fibonacci
number using the definition of <tt>fibs</tt> based on the <tt>add-streams</tt> procedure?  Show that the number of additions would be
exponentially greater if we had implemented
<tt>(delay &lt;<em>exp</em>&gt;)</tt> simply as <tt>(lambda () &lt;<em>exp</em>&gt;)</tt>, 
without using the optimization provided by the <tt>memo-proc</tt>
procedure described in section <a href="#%_sec_3.5.1">3.5.1</a>.<a name="call_footnote_Temp_465" href="#footnote_Temp_465"><sup><small>64</small></sup></a>
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.57.</b> <tt>add-streams</tt> ã®æ‰‹ç¶šãã«åŸºã¥ã <tt>fibs</tt> ã®å®šç¾©ã‚’ä½¿ã£ã¦ <em class="en">n</em> ç•ªç›®ã®ãƒ•ã‚£ãƒœãƒŠãƒƒãƒæ•°ã‚’è¨ˆç®—ã™ã‚‹ã¨ãã€åŠ ç®—ãŒä½•å›ãŠã“ãªã‚ã‚Œã‚‹ã ã‚ã†?
ã‚‚ã—ã€<a href="#%_sec_3.5.1">3.5.1</a>ç¯€ã§è¿°ã¹ãŸ <tt>memo-proc</tt> ã¨ã„ã†æ‰‹ç¶šãã«ã‚ˆã‚Šã‚‚ãŸã‚‰ã•ã‚Œã‚‹æœ€é©åŒ–ã‚’ä½¿ã‚ãªã„ã§ã€ãŸã å˜ç´”ã«ã€
<tt>(delay &lt;<em class="en">exp</em>&gt;)</tt> 
ã‚’
<tt>(lambda () &lt;<em class="en">exp</em>&gt;)</tt>
ã¨å®Ÿè£…ã—ã¦ã„ãŸã‚‰ã€åŠ ç®—ã®å›æ•°ã¯æŒ‡æ•°é–¢æ•°çš„ã«å¤§ãããªã£ãŸã ã‚ã†ã€ã¨ã„ã†ã“ã¨ã‚’ç¤ºã›<a name="call_footnote_Temp_465" href="#footnote_Temp_465"><sup><small>64</small></sup></a>ã€‚
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.58"></a>
<b>Exercise 3.58.</b>  Give an interpretation of the stream computed by the following
procedure:</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.58.</b> ä»¥ä¸‹ã®æ‰‹ç¶šãã«ã‚ˆã£ã¦è¨ˆç®—ã•ã‚Œã‚‹ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®è§£é‡ˆã‚’è¿°ã¹ã‚ˆã€‚
</p>


<p class="lisp">(define (expand num den radix)
  (cons-stream
   (quotient (* num radix) den)
   (expand (remainder (* num radix) den) den radix)))
</p>


<p class="orig" lang="en">
<a name="%_idx_3906"></a><a name="%_idx_3908"></a>(<tt>Quotient</tt> is a primitive that returns the integer quotient of
two integers.)  What are the successive elements produced by <tt>(expand 1 7 10)</tt> ?  What is produced by <tt>(expand 3 8 10)</tt> ?
</p>

<p class="trans" lang="ja">
(<tt>quotient</tt> ã¯ã€äºŒã¤ã®æ•´æ•°ã«ã¤ã„ã¦ã®æ•´æ•°ã®å•†ã‚’è¿”ã™ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã§ã‚ã‚‹ã€‚)
<tt>(expand 1 7 10)</tt> ã«ã‚ˆã‚Šä½œã‚Šå‡ºã•ã‚Œã‚‹ã€é€£ç¶šã™ã‚‹è¦ç´ ã¨ã¯ã€ã©ã®ã‚ˆã†ãªã‚‚ã®ã‹?  
<tt>(expand 3 8 10)</tt> ã«ã‚ˆã£ã¦ã€ä½•ãŒä½œã‚Šå‡ºã•ã‚Œã‚‹ã‹?
</p>


<p class="exercise"><span class="ex_comment">numã‚‚denã‚‚radixæœªæº€ã¨ã„ã†ã®ãŒã€ãŠãã‚‰ãæš—é»™ã®å‰æã€‚
ã§ã€åŸºæ•°ã‚’radixã¨ã—ã¦æ•°ã‚’è¡¨ç¾ã™ã‚‹å ´åˆã«ãŠã„ã¦ã€numã‚’denã§å‰²ã£ãŸã‚‰ã©ã†ãªã‚‹ã‹ã€ã¨ã„ã†ã®ã‚’ã€
   * ç¬¬1è¦ç´ ã¯ã€(æ•´æ•°éƒ¨ãŒ0ã§ãªã„å ´åˆã¯æ•´æ•°éƒ¨ã¨)å°æ•°ç¬¬1ä½ã€
   * ç¬¬2è¦ç´ ã¯ã€å°æ•°ç¬¬2ä½ã€
   * ç¬¬3è¦ç´ ã¯ã€å°æ•°ç¬¬3ä½ã€
   * ä»¥ä¸‹åŒæ§˜
ã¨ã‚„ã£ã¦ã„ã‚‹ã¯ãšã€‚
ã§ã€å¤šåˆ†ã€æš—é»™ã®å‰æã¨ã—ã¦ã•ã‚‰ã«ã€numãŒdenæœªæº€ã¨ã„ã†åˆ¶ç´„ãŒã‚ã‚‹ã®ã ã‚ã†ã€‚
ã“ã®åˆ¶ç´„ãŒã‚ã‚Œã°ã€æ•´æ•°éƒ¨ã¯0ã§ã‚ã‚Šã€ã“ã®0ã¯ã€å‡ºåŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«ã¯å‡ºã¦ã“ãªã„ã€‚
</span>
   (expand 1 7 10)
 = (cons-stream (quotient 10 7) (expand (remainder 10 7) 7 10)
 = (cons-stream 1 (expand 3 7 10))
 = (cons-stream 1
     (cons-stream (quotient 30 7) (expand (remainder 30 7) 7 10)))
 = (cons-stream 1
     (cons-stream 4 (expand 2 7 10)))
 = (cons-stream 1
     (cons-stream 4
       (cons-stream (quotient 20 7) (expand (remainder 20 7) 7 10))))
 = (cons-stream 1
     (cons-stream 4
       (cons-stream 2 (expand 6 7 10))))
 = ...
 = (1 4 2 ...)

<span class="ex_comment">ã¨ã€ãªã‚‹ã‚ã‘ã ãŒã€ã“ã‚Œã¯ã€ä»¥ä¸‹ã®ç­†ç®—ã‚’è¡¨ã—ã¦ã„ã‚‹ã€ã¨ã‚‚è¨€ãˆã‚‹ã€‚
1/7ã¯å¾ªç’°å°æ•°ã ã‹ã‚‰ã€å‡ºåŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¯å½“ç„¶ã€ç„¡é™ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«ãªã‚‹ã€‚</span>

    0.142857 ...
  ________________
7 &#41; 1.000000 ...
      7
   ---------------
      30
      28
   ---------------
       20
       14
   ---------------
        60
        56
   ---------------
         40
         35
   ---------------
          50
          49
   ---------------
           1
           (ä»¥ä¸‹ç•¥)

<span class="ex_comment">ä»–æ–¹ã€3/8 = 0.375 ã§ã€ã“ã‚Œã¯æœ‰é™å°æ•°ã€‚</span>
   (expand 3 8 10)
 = (cons-stream (quotient 30 8) (expand (remainder 30 8) 8 10))
 = (cons-stream 3 (expand 6 8 10))
 = (cons-stream 3
     (cons-stream (quotient 60 8) (expand (remainder 60 8) 8 10)))
 = (cons-stream 3
     (cons-stream 7 (expand 4 8 10)))
 = (cons-stream 3
     (cons-stream 7
       (cons-stream (quotient 40 8) (expand (remainder 40 8) 8 10))))
 = (cons-stream 3
     (cons-stream 7
       (cons-stream 5 (expand 0 8 10))))
 = (cons-stream 3 
     (cons-stream 7 
       (cons-stream 5 (cons-stream (quotient 0 8) (expand (remainder 0 8) 8 10)))))
 = (cons-stream 3 
     (cons-stream 7 
       (cons-stream 5 
         (cons-stream 0 (expand 0 8 10)))))
 = ...
 = (3 7 5 0 0 0 ...)

<span class="ex_comment">ã¨ã€ã¾ã‚ã€æœ‰é™å°æ•°ã§ã‚‚ã€ã“ã®ã‚ˆã†ã«ãªã‚‹ã®ã§ã€å‡ºåŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¯ç„¡é™ãªã®ã ã£ãŸã€‚</span>
</p>

<p class="orig" lang="en"><a name="%_thm_3.59"></a>
<b>Exercise 3.59.</b>  <a name="%_idx_3910"></a><a name="%_idx_3912"></a>In section <a href="18_sec2_5.html#%_sec_2.5.3">2.5.3</a> we saw how to implement a
polynomial arithmetic system representing polynomials as lists of
terms.  In a similar way, we can work with <em>power series</em>, such as</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.59.</b> <a href="18_sec2_5.html#%_sec_2.5.3">2.5.3</a>ç¯€ã§ã¯ã€å¤šé …å¼ã‚’é …ã®ãƒªã‚¹ãƒˆã¨ã—ã¦è¡¨ç¾ã™ã‚‹å¤šé …å¼ç®—è¡“ã‚·ã‚¹ãƒ†ãƒ ã‚’ã©ã†ã‚„ã£ã¦å®Ÿè£…ã™ã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’è¦‹ãŸã€‚
åŒæ§˜ã«ã—ã¦ã€ç§ãŸã¡ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ãª<em>å†ªç´šæ•°</em>ã‚’ä½¿ã£ã¦ã€ä½œæ¥­ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
</p>

<figure>
<a name="%_idx_3914"></a>
<img src="ch3-Z-G-36.gif" border="0"><br>
<a name="%_idx_3916"></a>
<img src="ch3-Z-G-37.gif" border="0"><br>
<a name="%_idx_3918"></a>
<img src="ch3-Z-G-38.gif" border="0">
</figure>

<p class="orig" lang="en">
represented as infinite streams.
We will represent the series
<em>a</em><sub>0</sub>  +  <em>a</em><sub>1</sub> <em>x</em>  +  <em>a</em><sub>2</sub> <em>x</em><sup>2</sup>  +  <em>a</em><sub>3</sub> <em>x</em><sup>3</sup>  +  <tt>&middot;&middot;&middot;</tt>
as the stream whose elements are the coefficients <em>a</em><sub>0</sub>, <em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, <em>a</em><sub>3</sub>, <tt>...</tt>.</p>

<p class="trans" lang="ja">
â€”â€”ãªãŠã€ã“ã‚Œã‚‰ã¯ç„¡é™ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¨ã—ã¦è¡¨ç¾ã•ã‚Œã¦ã„ã‚‹ã€‚
<span class="math"><em class="en">a</em><sub>0</sub>  +  <em class="en">a</em><sub>1</sub> <em class="en">x</em>  +  <em class="en">a</em><sub>2</sub> <em class="en">x</em><sup>2</sup>  +  <em class="en">a</em><sub>3</sub> <em class="en">x</em><sup>3</sup>  +  <tt>&middot;&middot;&middot;</tt></span>
ã¨ã„ã†ç´šæ•°ã‚’ã€
<em class="en">a</em><sub>0</sub>, <em class="en">a</em><sub>1</sub>, <em class="en">a</em><sub>2</sub>, <em class="en">a</em><sub>3</sub>, <tt>...</tt>
ã¨ã„ã†ä¿‚æ•°ã‚’ãã®è¦ç´ ã¨ã™ã‚‹ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¨ã—ã¦ã€è¡¨ç¾ã—ã‚ˆã†ã€‚
</p>

<p class="orig" lang="en"><a name="%_idx_3920"></a><a name="%_idx_3922"></a>a. The integral of the series <em>a</em><sub>0</sub>  +  <em>a</em><sub>1</sub> <em>x</em>  +  <em>a</em><sub>2</sub> <em>x</em><sup>2</sup>  +  <em>a</em><sub>3</sub> <em>x</em><sup>3</sup>  +  <tt>&middot;&middot;&middot;</tt>
is the series
</p>

<p class="trans" lang="ja">a. 
<span class="math"><em class="en">a</em><sub>0</sub>  +  <em class="en">a</em><sub>1</sub> <em class="en">x</em>  +  <em class="en">a</em><sub>2</sub> <em class="en">x</em><sup>2</sup>  +  <em class="en">a</em><sub>3</sub> <em class="en">x</em><sup>3</sup>  +  <tt>&middot;&middot;&middot;</tt></span>
ã¨ã„ã†ç´šæ•°ã®ç©åˆ†ã¯ã€ä»¥ä¸‹ã®ç´šæ•°ã§ã‚ã‚Šã€
</p>

<figure><img src="ch3-Z-G-39.gif" border="0"></figure>


<p class="orig" lang="en">
where <em>c</em> is any constant.
Define a procedure <a name="%_idx_3924"></a><tt>integrate-series</tt> that takes as input a stream
<em>a</em><sub>0</sub>, <em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, <tt>...</tt> representing a power series and returns the stream
<em>a</em><sub>0</sub>, (1/2)<em>a</em><sub>1</sub>, (1/3)<em>a</em><sub>2</sub>, <tt>...</tt> of coefficients of
the non-constant terms of the integral of the series.
(Since the result has no constant term, it doesn't represent a power
series; when we use <tt>integrate-series</tt>, we will <tt>cons</tt> on
the appropriate constant.) </p>

<p class="trans" lang="ja">
ã“ã“ã§ã€<em class="en">c</em> ã¯ä»»æ„ã®å®šæ•°ã§ã‚ã‚‹ã€‚
å†ªç´šæ•°ã‚’è¡¨ã™
<em class="en">a</em><sub>0</sub>, <em class="en">a</em><sub>1</sub>, <em class="en">a</em><sub>2</sub>, <tt>...</tt> 
ã¨ã„ã†ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å…¥åŠ›ã¨ã—ã¦ã¨ã‚Šã€
ãã®ç´šæ•°ã®ç©åˆ†ã®ã€å®šæ•°ã§ãªã„é …ã®ä¿‚æ•°ã®ã€
<em class="en">a</em><sub>0</sub>, (1/2)<em class="en">a</em><sub>1</sub>, (1/3)<em class="en">a</em><sub>2</sub>, <tt>...</tt> 
ã¨ã„ã†ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’è¿”ã™ã‚ˆã†ãªã€<tt>integrate-series</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’å®šç¾©ã›ã‚ˆã€‚
(çµæœã¯ã€å®šæ•°é …ã‚’æŒãŸãªã„ã®ã§ã€å†ªç´šæ•°ã‚’è¡¨ã—ã¦ã¯ã„ãªã„ã€‚<tt>integrate-series</tt> ã‚’ä½¿ã†å ´åˆã¯ã€é©åˆ‡ãªå®šæ•°ã«å¯¾ã—ã¦ <tt>cons</tt> ã™ã‚‹ã“ã¨ã«ãªã‚ã†ã€‚) 
</p>

<p class="exercise"><span class="ex_comment">; å†æ²</span><!--
(define ones (cons-stream 1 ones))
(define (add-streams s1 s2) (stream-map + s1 s2))
(define integers (cons-stream 1 (add-streams ones integers)))-->
(define (mul-streams s1 s2) (stream-map * s1 s2))

<span class="ex_comment">; ã•ã¦ã“ã“ã‹ã‚‰ã€‚ã¾ãšã¯ã€1/1, 1/2, 1/3, ... ã¨ã„ã†æ•°åˆ—ã‚’ä½œã‚‹ã€‚</span>
(define (inverse-of-integers-starting-from n)
  (cons-stream (/ 1 n) (inverse-of-integers-starting-from (+ n 1))))
(define inverses (inverses-of-integers-starting-from 1))
<span class="ex_comment">; ãã‚Œã§ã€æœ¬é¡Œã€‚</span>
(define (integrate-series power-series-coefficients)
  (mul-streams power-series-coefficients inverses))
</p>

<p class="orig" lang="en">b. The function <em>x</em> <img src="book-Z-G-D-17.gif" border="0">  <em>e</em><sup><em>x</em></sup> is its own
derivative.  This implies that <em>e</em><sup><em>x</em></sup> and the integral of <em>e</em><sup><em>x</em></sup> are the
same series, except for the constant term, which is <em>e</em><sup>0</sup>  = 1.
Accordingly, we can generate the series for 
<em>e</em><sup><em>x</em></sup> as
</p>

<p class="trans" lang="ja">b. 
<span class="math"><em class="en">x</em> &mapsto; <em class="en">e</em><sup><em class="en">x</em></sup></span>
ã¨ã„ã†é–¢æ•°ã¯ã€è‡ªåˆ†è‡ªèº«ã®å°é–¢æ•°ã§ã‚ã‚‹ã€‚
ã“ã‚Œã¯ã€
<span class="math"><em class="en">e</em><sup><em class="en">x</em></sup></span>
ã¨ã€
<span class="math"><em class="en">e</em><sup><em class="en">x</em></sup></span>
ã®ç©åˆ†ã¨ãŒã€å®šæ•°é …â€”â€”
<span class="math"><em class="en">e</em><sup>0</sup>  = 1</span> 
ã§ã‚ã‚‹â€”â€”ã‚’é™¤ã„ã¦ã¯åŒã˜ç´šæ•°ã§ã‚ã‚‹ã€ã¨ã„ã†ã“ã¨ã‚’æš—ç¤ºã—ã¦ã„ã‚‹ã€‚
ã—ãŸãŒã£ã¦ã€
<span class="math"><em class="en">e</em><sup><em class="en">x</em></sup></span> 
ã«ã¤ã„ã¦ã®ç´šæ•°ã‚’ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ç”Ÿæˆã§ãã‚‹ã€‚
</p>

<p class="lisp">(define exp-series
  (cons-stream 1 (integrate-series exp-series)))
</p>

<p class="orig" lang="en">
Show how to generate the series for sine and cosine, starting from the facts
that the derivative of sine is cosine and the derivative of cosine is
the negative of sine:
</p>

<p class="trans" lang="ja">ã‚µã‚¤ãƒ³ã®å°é–¢æ•°ã¯ã‚³ã‚µã‚¤ãƒ³ã§ã‚ã‚Šã€ã‚³ã‚µã‚¤ãƒ³ã®å°é–¢æ•°ã¯ã‚µã‚¤ãƒ³ã®æ­£è² ã‚’åè»¢ã—ãŸã‚‚ã®ã ã€ã¨ã„ã†äº‹å®Ÿã‹ã‚‰å§‹ã‚ã¦ã€ã‚µã‚¤ãƒ³ã¨ã‚³ã‚µã‚¤ãƒ³ã«å¯¾ã™ã‚‹ç´šæ•°ã‚’ã©ã†ã‚„ã£ã¦ç”Ÿæˆã™ã‚‹ã®ã‹ã‚’ç¤ºã›ã€‚
</p>


<p class="lisp">(define cosine-series
  (cons-stream 1 &lt;<em>??</em>&gt;))
(define sine-series
  (cons-stream 0 &lt;<em>??</em>&gt;))
</p>

<p class="exercise"><span class="ex_comment">ã‚ã‚ŠãŒãŸã„ã“ã¨ã«ã€å®šæ•°é …ã¯ç­”ãˆãŒæ›¸ã„ã¦ã‚ã‚‹ã€‚ã¨ã„ã†ã‚ã‘ã§ã€
cos x = 1 + c<sub>1</sub> x + c<sub>2</sub> x<sup>2</sup> + c<sub>3</sub> x<sup>3</sup> + ...
sin x = 0 + s<sub>1</sub> x + s<sub>2</sub> x<sup>2</sup> + s<sub>3</sub> x<sup>3</sup> + ...
ã¨ãŠãã“ã¨ãŒã§ãã‚‹ã€‚ãªãŠã€c<sub>0</sub>=1, s<sub>0</sub>=0 ã§ã‚ã‚‹ã€‚

  âˆ« cos x dx
= const. + c<sub>0</sub> x + c<sub>1</sub>/2 x<sup>2</sup> + c<sub>2</sub>/3 x<sup>3</sup> + c<sub>3</sub>/4 x<sup>4</sup> ...
= sin x + const. 
= const. + s<sub>1</sub> x + s<sub>2</sub> x<sup>2</sup> + s<sub>3</sub> x<sup>3</sup> + ...
ãªã®ã§ã€s<sub>1</sub>&equiv;c<sub>0</sub>, s<sub>2</sub>&equiv;c<sub>1</sub>/2, s<sub>3</sub>&equiv;c<sub>2</sub>/3, ... ã§ã‚ã‚‹ã€‚ã‚ˆã£ã¦ã€ä»¥ä¸‹ã®ã‚ˆã†ã«å®šç¾©ã§ãã‚‹ã€‚</span>

(define sine-series
  (cons-stream 0 (integrate-series cosine-series)))

<span class="ex_comment">åŒæ§˜ã«ã€
  âˆ« sin x dx
= const. + s<sub>0</sub> x + s<sub>1</sub>/2 x<sup>2</sup> + s<sub>2</sub>/3 x<sup>3</sup> + s<sub>3</sub>/4 x<sup>4</sup> ...
= &minus;cos x + const.
= (const. &minus; 1) &minus; c<sub>1</sub> x &minus; c<sub>2</sub> x<sup>2</sup> &minus; c<sub>3</sub> x<sup>3</sup> &minus; ...
ãªã®ã§ã€c<sub>1</sub>&equiv;&minus;s<sub>0</sub>, c<sub>2</sub>&equiv;&minus;s<sub>1</sub>/2, c<sub>3</sub>&equiv;&minus;s<sub>2</sub>/3, ... ã§ã‚ã‚‹ã€‚ã‚ˆã£ã¦ã€ä»¥ä¸‹ã®ã‚ˆã†ã«å®šç¾©ã§ãã‚‹ã€‚</span>

(define (minus-stream s) (stream-map (lambda (x) (- x)) s))
(define cosine-series
  (cons-stream 1 (minus-stream (integrate-series sine-series))))
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.60"></a>
<b>Exercise 3.60.</b>  <a name="%_idx_3926"></a><a name="%_idx_3928"></a><a name="%_idx_3930"></a><a name="%_idx_3932"></a>With power series represented as streams of coefficients as in
exercise <a href="#%_thm_3.59">3.59</a>, adding series is implemented by <tt>add-streams</tt>.  Complete the definition of the following procedure for
multiplying series:
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.60.</b> ç·´ç¿’å•é¡Œ<a href="#%_thm_3.59">3.59</a>ã§ã®ã‚ˆã†ã«ã€ä¿‚æ•°ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¨ã—ã¦è¡¨ã•ã‚ŒãŸå†ªç´šæ•°ã‚’ä½¿ã†ã¨ã€ç´šæ•°åŒå£«ã‚’è¶³ã™ã“ã¨ã¯ã€<tt>add-streams</tt> ã«ã‚ˆã‚Šå®Ÿè£…ã•ã‚Œã‚‹ã€‚
ç´šæ•°åŒå£«ã®ä¹—ç®—ã®ãŸã‚ã®ä»¥ä¸‹ã®æ‰‹ç¶šãã®å®šç¾©ã‚’å®Œæˆã•ã›ã‚ˆã€‚
</p>

<p class="lisp">(define (mul-series s1 s2)
  (cons-stream &lt;<em>??</em>&gt; (add-streams &lt;<em>??</em>&gt; &lt;<em>??</em>&gt;)))
</p>

<p class="orig" lang="en">
You can test your procedure by verifying that
<em>s</em><em>i</em><em>n</em><sup>2</sup> <em>x</em>  +  <em>c</em><em>o</em><em>s</em><sup>2</sup> <em>x</em>  =  1, using the series from exercise <a href="#%_thm_3.59">3.59</a>.
</p>

<p class="trans" lang="ja">
ç·´ç¿’å•é¡Œ<a href="#%_thm_3.59">3.59</a>ã®ç´šæ•°ã‚’ä½¿ã£ã¦ã€
<span class="math">sin<sup>2</sup> <em class="en">x</em> + cos<sup>2</sup> <em class="en">x</em> = 1</span>
ã¨ã„ã†ã“ã¨ã‚’ç¢ºã‹ã‚ã‚‹ã“ã¨ã§ã€å›ã¯ã€è‡ªåˆ†ã®æ‰‹ç¶šãã‚’è©¦ã™ã“ã¨ãŒå¯èƒ½ã ã€‚
</p>


<p class="exercise"><span class="ex_comment"><!--äºŒã¤ã®ç´šæ•°ã®ç©ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚‹ã€‚
  (a<sub>0</sub> + a<sub>1</sub>x + a<sub>2</sub>x<sup>2</sup> + a<sub>3</sub>x<sup>3</sup> + ...) &times; (b<sub>0</sub> + b<sub>1</sub>x + b<sub>2</sub>x<sup>2</sup> + b<sub>3</sub>x<sup>3</sup> + ...)
= a<sub>0</sub> b<sub>0</sub> + (a<sub>0</sub> b<sub>1</sub> + a<sub>1</sub> b<sub>0</sub>) x + (a<sub>0</sub> b<sub>2</sub> + a<sub>1</sub> b<sub>1</sub> + a<sub>2</sub> b<sub>0</sub>) x<sup>2</sup> + (a<sub>0</sub> b<sub>3</sub> + a<sub>1</sub> b<sub>2</sub> + a<sub>2</sub> b<sub>1</sub> + a<sub>3</sub> b<sub>0</sub>) x<sup>3</sup> + ...

ã®ã§ã¯ã‚ã‚‹ãŒã€ã“ã‚Œã‹ã‚‰ã©ã†ã‚„ã£ã¦é€²ã‚ã‚ˆã†ã‹ãªâ€¦â€¦ã€‚</span>

(define (mul-series s1 s2)
  (cons-stream
    (* (stream-car s1) (stream-car s2))
    (add-streams &lt;<em>??</em>&gt; &lt;<em>??</em>&gt;)))

<span class="ex_comment">ã¨ã„ã†å½¢ã«ãªã‚Šãã†ãªæ°—ã‚‚ã™ã‚‹ãŒã€å¾Œã‚ãŒåŸ‹ã¾ã‚‰ãªã„ã€‚

= a<sub>0</sub> (b<sub>0</sub> + b<sub>1</sub>x + b<sub>2</sub>x<sup>2</sup> + b<sub>3</sub>x<sup>3</sup> ...) + 
   a<sub>1</sub> (0 + b<sub>0</sub>x + b<sub>1</sub>x<sup>2</sup> + b<sub>2</sub>x<sup>3</sup> + b<sub>3</sub>x<sup>4</sup> ...) + 
   a<sub>2</sub> (0 + 0 + b<sub>0</sub>x<sup>2</sup> + b<sub>1</sub>x<sup>3</sup> + b<sub>2</sub>x<sup>4</sup> + b<sub>3</sub>x<sup>5</sup> ...) + ...

ã¨ã‹ã£ã¦å¤‰å½¢ã—ã¦ã¿ãŸã‘ã©ã€ãªã‚“ã‹ã†ã¾ãã„ããã†ã«ãªã„ãªã€‚ã‚€ã‚€ã€‚</span>

<span class="ex_comment">ã¨ã‚Šã‚ãˆãšã€æ¤œè¨¼ç”¨ã®ã‚³ãƒ¼ãƒ‰ã ã‘å…ˆã«æ›¸ã“ã†ã‹ãªã€‚ä»¥ä¸‹ã®ã‚ˆã†ãªæ„Ÿã˜ã ã‚ã†ã‹â€¦â€¦ã€‚</span>

<span class="ex_comment">; (1 x x<sup>2</sup> x<sup>3</sup> ...) ã‚’ä½œã‚‹</span>
(define (x-series x)
  (cons-stream
    1
    (stream-map (lambda (elem) (* x elem)) (x-series x))))--><!--
(define (unit-stream x) (cons-stream x (unit-stream x)))
(define (x-series x) (cons-stream 1 (mul-streams (unit-stream x) 
(define (verify-at x)
  (let
     <span class="ex_comment">; (x x x ...) ã‚’ä½œã‚‹</span>
    ((unit-stream (cons-stream x (unit-stream)))
     <span class="ex_comment">; (1 x x<sup>2</sup> x<sup>3</sup> ...) ã‚’ä½œã‚‹</span>
     (x-series (cons-stream 1 (mul-streams x-series unit-stream
-->
<!--<span class="ex_comment">; ç¢ºèªç”¨ã®æ‰‹ç¶šãã‚’ä½œã‚‹ã€‚ã“ã‚“ãªã‚“ã‹ãª?</span>
(define (verify-at x num-of-terms-to-be-considered)
  (define (iter accum n-more-elements s)
    (if (= n-more-elements 0)
        accum
        (iter (+ accum (stream-car s)) (- n-more-elements 1))))
  (iter 0 num-of-terms-to-be-considered 
       (add-stream
          (mul-stream (x-series x) (cons-stream 0 (mul-series sine-series sine-series)))
          (mul-stream (x-series x) (cons-stream 1 (mul-series cosine-series cosine-series))))))
<span class="ex_comment">; 8ã¨ã„ã†ã®ã¯é©å½“ã«æ±ºã‚ã¦ã¿ãŸå®šæ•°ã€‚ã“ã‚Œãã‚‰ã„ã¾ã§è¦‹ã‚Œã°å¤šåˆ†åæŸã—ã¦ã„ã‚‹ã ã‚ã€‚
; [0, 1] ã®ç¯„å›²å†…ã®ã„ãã¤ã‹ã® x ã«ã¤ã„ã¦ã€ç¢ºèªã—ã¦ã¿ã‚‹ã€‚</span>
(verify-at 0.0 8)

(verify-at 0.1 8)

(verify-at 0.5 8)

(verify-at 0.8 8)

(verify-at 1.0 8)
-->
</p>

<p class="orig" lang="en"><a name="%_thm_3.61"></a>
<b>Exercise 3.61.</b>  Let <em>S</em> be a power series (exercise <a href="#%_thm_3.59">3.59</a>)
whose constant term is 1.  Suppose we want
to find the power series 1/<em>S</em>, that is, the series <em>X</em> such that
<em>S</em> &middot;  <em>X</em> =  1.  Write <em>S</em> = 1 + <em>S</em><sub><em>R</em></sub> where <em>S</em><sub><em>R</em></sub> is the part of <em>S</em> after
the constant term.  Then we can solve for <em>X</em> as follows:
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.61.</b> <em class="en">S</em> ã‚’ã€å®šæ•°é …ãŒ 1 ã®å†ªç´šæ•° (ç·´ç¿’å•é¡Œ<a href="#%_thm_3.59">3.59</a>) ã¨ã™ã‚‹ã€‚
1/<em class="en">S</em> ã¨ã„ã†å†ªç´šæ•°â€”â€”ã¤ã¾ã‚Šã€
<span class="math"><em class="en">S</em> &middot; <em class="en">X</em> =  1</span>
ã§ã‚ã‚‹ã‚ˆã†ãª <em class="en">X</em> ã®ç´šæ•°â€”â€”ã‚’æ±‚ã‚ãŸã„ã‚‚ã®ã¨ã™ã‚‹ã€‚
<em class="en">S</em><sub><em class="en">R</em></sub> ãŒå®šæ•°é …ã‚ˆã‚Šå¾Œã® <em class="en">S</em> ã®éƒ¨åˆ†ã ã¨ã—ã¦ã€
<span class="math"><em class="en">S</em> = 1 + <em class="en">S</em><sub><em class="en">R</em></sub></span>
ã¨æ›¸ã“ã†ã€‚
ã™ã‚‹ã¨ã€<em class="en">X</em> ã«ã¤ã„ã¦æ¬¡ã®ã‚ˆã†ã«è§£ã‘ã‚‹ã€‚
</p>

<figure><img src="ch3-Z-G-40.gif" border="0"></figure>


<p class="orig" lang="en">
In other words, <em>X</em> is the power series whose constant term is 1 and
whose higher-order terms are given by the negative of <em>S</em><sub><em>R</em></sub> times <em>X</em>.
Use this idea to write a procedure <tt>invert-unit-series</tt> that computes 1/<em>S</em> for a power series <em>S</em> with
constant term 1.
You will need to use <tt>mul-series</tt> from exercise <a href="#%_thm_3.60">3.60</a>.
</p>

<p class="trans" lang="ja">
æ›è¨€ã™ã‚‹ã¨ã€<em class="en">X</em> ã¨ã¯ã€å®šæ•°é …ãŒ 1 ã§ã€ã‹ã¤ã€ã‚ˆã‚Šé«˜æ¬¡ã®é …ã¯ <em class="en">S<sub>R</sub></em> æ›ã‘ã‚‹ <em class="en">X</em> ã®æ­£è² ã‚’åè»¢ã—ãŸã‚‚ã®ã«ã‚ˆã£ã¦ä¸ãˆã‚‰ã‚Œã‚‹ã‚ˆã†ãªã€å†ªç´šæ•°ã§ã‚ã‚‹ã€‚
1 ã¨ã„ã†å®šæ•°é …ã‚’æœ‰ã™ã‚‹ <em class="en">S</em> ã¨ã„ã†å†ªç´šæ•°ã«å¯¾ã—ã¦ 1/<em class="en">S</em> ã‚’è¨ˆç®—ã™ã‚‹ã‚ˆã†ãªã€<tt>invert-unit-series</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’ã€ä¸Šè¨˜ã®è€ƒãˆæ–¹ã‚’ä½¿ã£ã¦æ›¸ã‘ã€‚
ç·´ç¿’å•é¡Œ<a href="#%_thm_3.60">3.60</a>ã® <tt>mul-series</tt> ãŒå¿…è¦ã«ãªã‚‹ã ã‚ã†ã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.62"></a>
<b>Exercise 3.62.</b>  <a name="%_idx_3934"></a><a name="%_idx_3936"></a><a name="%_idx_3938"></a>Use the results of exercises <a href="#%_thm_3.60">3.60</a>
and <a href="#%_thm_3.61">3.61</a> to define a procedure <tt>div-series</tt>
that divides two power series.  <tt>Div-series</tt> should work for any
two series, provided that the denominator series begins with a
nonzero constant term.  (If the denominator has a zero constant term,
then <tt>div-series</tt> should signal an error.)
Show how to use <tt>div-series</tt>
together with the result of exercise <a href="#%_thm_3.59">3.59</a> to generate
<a name="%_idx_3940"></a>the power series for tangent.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.62.</b> ç·´ç¿’å•é¡Œ<a href="#%_thm_3.60">3.60</a>ã¨<a href="#%_thm_3.61">3.61</a>ã®çµæœã‚’ä½¿ã£ã¦ã€äºŒã¤ã®å†ªç´šæ•°ã®é™¤ç®—ã‚’è¡Œã† <tt>div-series</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’å®šç¾©ã›ã‚ˆã€‚
åˆ†æ¯ã®ç´šæ•°ãŒéã‚¼ãƒ­ã®å®šæ•°é …ã§å§‹ã¾ã‚‹é™ã‚Šã€<tt>div-series</tt> ã¯ã€ã„ã‹ãªã‚‹äºŒã¤ã®ç´šæ•°ã«å¯¾ã—ã¦ã‚‚ã€ãã¡ã‚“ã¨å‹•ãã¹ãã§ã‚ã‚‹ã€‚
(ã‚‚ã—åˆ†æ¯ãŒã€ã‚¼ãƒ­ã®å®šæ•°é …ã‚’æœ‰ã™ã‚‹ãªã‚‰ã°ã€<tt>div-series</tt> ã¯ã€ã‚¨ãƒ©ãƒ¼ã‚’çŸ¥ã‚‰ã›ã‚‹ã¹ãã§ã‚ã‚‹ã€‚)
ã‚¿ãƒ³ã‚¸ã‚§ãƒ³ãƒˆã®å†ªç´šæ•°ã‚’ç”Ÿæˆã™ã‚‹ãŸã‚ã«ã¯ã€ç·´ç¿’å•é¡Œ<a href="#%_thm_3.59">3.59</a>ã®çµæœã¨ã¨ã‚‚ã« <tt>div-series</tt> ã‚’ã©ã®ã‚ˆã†ã«ä½¿ãˆã°ã‚ˆã„ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’ç¤ºã›ã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_3.5.3"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_3.5.3">3.5.3  Exploiting the Stream Paradigm</a></h3>
<h3 class="trans" lang="ja">3.5.3 ã‚¹ãƒˆãƒªãƒ¼ãƒ ãƒ»ãƒ‘ãƒ©ãƒ€ã‚¤ãƒ ã‚’ä½¿ã„å€’ã™</h3>

<p class="orig" lang="en">
Streams with delayed evaluation can be a powerful modeling tool,
providing many of the benefits of local state and assignment.
Moreover, they avoid some of the theoretical tangles that accompany
the introduction of assignment into a programming language.</p>

<p class="trans" lang="ja">
é…å»¶è©•ä¾¡ã‚’ä½¿ã£ãŸã‚¹ãƒˆãƒªãƒ¼ãƒ ã¯ã€å¼·åŠ›ãªãƒ¢ãƒ‡ãƒ«åŒ–æ‰‹æ®µãŸã‚Šå¾—ã‚‹ã—ã€ã¾ãŸã€å±€æ‰€çŠ¶æ…‹ã¨<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã®æ©æµã®å¤šãã‚’ã‚‚ãŸã‚‰ã—ã¦ãã‚Œã‚‹ã€‚
ã•ã‚‰ã«ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã«<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã‚’æŒã¡è¾¼ã‚€ã“ã¨ã«ä»˜éšã™ã‚‹ã€ç†è«–çš„ãªã‹ã‚‰ã¾ã‚Šã®ã†ã¡ã®ã„ãã¤ã‹ã‚’ã€å›é¿ã§ãã‚‹ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_3942"></a>The stream approach can be illuminating because it allows us to build
systems with different module boundaries than systems organized around
assignment to state variables.  For example, we can think of an entire
time series (or signal) as a focus of interest, rather than the values
of the state variables at individual moments.  This makes it
convenient to combine and compare components of state from different
moments.</p>

<p class="trans" lang="ja">
ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®æ‰‹æ³•ã¯ã€çŠ¶æ…‹å¤‰æ•°ã¸ã®<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã«åˆã‚ã›ã¦ä½“ç³»åŒ–ã•ã‚ŒãŸã‚·ã‚¹ãƒ†ãƒ ã¨ã¯ç•°ãªã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å¢ƒç•Œã‚’æŒã£ãŸã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰ã§ãã‚‹ã‚ˆã†ã«ã—ã¦ãã‚Œã‚‹ã®ã§ã€ç†è§£ã®åŠ©ã‘ã«ãªã‚Šå¾—ã‚‹ã€‚
ãŸã¨ãˆã°ã€å€‹ã€…ã®ç¬é–“ã«ãŠã‘ã‚‹çŠ¶æ…‹å¤‰æ•°ã®å€¤ã¨ã„ã†ã‚ˆã‚Šã‚€ã—ã‚ã€æ™‚é–“åˆ— (ã¾ãŸã¯ä¿¡å·) ã®å…¨ä½“ã‚’ã€èˆˆå‘³ã®ä¸­å¿ƒã¨ã—ã¦è€ƒãˆã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
ã“ã‚Œã«ã‚ˆã£ã¦ã€ç•°ãªã‚‹ç¬é–“ã®çŠ¶æ…‹ã®æˆåˆ†åŒå£«ã‚’çµåˆã—ãŸã‚Šæ¯”è¼ƒã—ãŸã‚Šã™ã‚‹ã“ã¨ãŒã€ç°¡ä¾¿åŒ–ã•ã‚Œã‚‹ã€‚
</p>

<a name="%_sec_Temp_471"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_471">Formulating iterations as stream processes</a></h4>
<h4 class="trans" lang="ja">åå¾©ã‚’ã‚¹ãƒˆãƒªãƒ¼ãƒ ãƒ»ãƒ—ãƒ­ã‚»ã‚¹ã¨ã—ã¦å®šå¼åŒ–ã™ã‚‹</h4>

<p class="orig" lang="en">
<a name="%_idx_3944"></a>
In section <a href="11_sec1_2.html#%_sec_1.2.1">1.2.1</a>, we introduced iterative
processes, which proceed by updating state variables.  We know now
that we can represent state as a ``timeless'' stream of values rather
than as a set of variables to be updated.  Let's adopt this
perspective in revisiting the square-root procedure from
section <a href="10_sec1_1.html#%_sec_1.1.7">1.1.7</a>.  Recall that the idea is to generate a
sequence of better and better guesses for the square root of <em>x</em> by
applying over and over again the procedure that improves guesses:</p>

<p class="trans" lang="ja">
<a href="11_sec1_2.html#%_sec_1.2.1">1.2.1</a>ç¯€ã§ã¯ã€åå¾©ãƒ—ãƒ­ã‚»ã‚¹â€”â€”çŠ¶æ…‹å¤‰æ•°ã‚’æ›´æ–°ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦é€²è¡Œã™ã‚‹â€”â€”ã‚’å°å…¥ã—ãŸã€‚
ä»Šã‚„ç§ãŸã¡ã¯ã€çŠ¶æ…‹ã‚’ã€æ›´æ–°ã™ã¹ãå¤‰æ•°ã®é›†åˆã¨ã„ã†ã‚ˆã‚Šã‚‚ã‚€ã—ã‚ã€å€¤ã®ã€Œæ™‚é–“ã‚’è¶…è¶Šã—ãŸã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¨ã—ã¦ã€è¡¨ç¾ã§ãã‚‹ã®ã ã€ã¨ã„ã†ã“ã¨ã‚’çŸ¥ã£ã¦ã„ã‚‹ã€‚
ã“ã®è¦³ç‚¹ã‚’ã€<a href="10_sec1_1.html#%_sec_1.1.7">1.1.7</a>ç¯€ã®äºŒä¹—æ ¹ã®æ‰‹ç¶šãã‚’å†æ¤œè¨ã™ã‚‹éš›ã«ã€å–ã‚Šå…¥ã‚Œã¦ã¿ã‚ˆã†ã€‚
é‡è¦ãªã“ã¨ã¯ã€æ¨å®šå€¤ã‚’æ”¹å–„ã™ã‚‹æ‰‹ç¶šãã‚’ä½•åº¦ã‚‚ç¹°ã‚Šè¿”ã—é©ç”¨ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€<em class="en">x</em> ã®äºŒä¹—æ ¹ã«ã¤ã„ã¦ã®ã©ã‚“ã©ã‚“è‰¯ããªã£ã¦ã„ãæ¨å®šå€¤ã®åˆ—ã‚’ç”Ÿæˆã™ã‚‹ã“ã¨ã ã€ã¨ã„ã†ã“ã¨ã‚’æ€ã„å‡ºãã†ã€‚
</p>


<p class="lisp">(define (sqrt-improve guess x)
  (average guess (/ x guess)))
</p>

<p class="orig" lang="en">
<a name="%_idx_3946"></a>In our original <tt>sqrt</tt> procedure, we made these guesses be the
successive values of a state variable. Instead we can generate the
infinite stream of guesses, starting with an initial guess of 1:<a name="call_footnote_Temp_472" href="#footnote_Temp_472"><sup><small>65</small></sup></a></p>

<p class="trans" lang="ja">
ç§ãŸã¡ã®å…ƒã€…ã® <tt>sqrt</tt> ã®æ‰‹ç¶šãã§ã¯ã€ã“ã‚Œã‚‰ã®æ¨å®šå€¤ã‚’ã€ã‚ã‚‹ä¸€ã¤ã®çŠ¶æ…‹å¤‰æ•°ã®é€£ç¶šçš„ãªå€¤ã¨ã—ã¦ã„ãŸã€‚
ãã®ä»£ã‚ã‚Šã«ã€ç§ãŸã¡ã¯ã€1ã¨ã„ã†åˆæœŸæ¨å®šå€¤ã‹ã‚‰å§‹ã‚ã¦ã€æ¨å®šå€¤ã®ç„¡é™ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ç”Ÿæˆã™ã‚‹ã“ã¨ãŒã§ãã‚‹<a href="#footnote_Temp_472"><sup><small>65</small></sup></a>ã€‚
</p>

<p class="lisp"><a name="%_idx_3948"></a>(define (sqrt-stream x)
  (define guesses
    (cons-stream 1.0
                 (stream-map (lambda (guess)
                               (sqrt-improve guess x))
                             guesses)))
  guesses)
(display-stream (sqrt-stream 2))
<i>1.</i>
<i>1.5</i>
<i>1.4166666666666665</i>
<i>1.4142156862745097</i>
<i>1.4142135623746899</i>
<tt>...</tt></p>

<p class="exercise"><span class="ex_comment">ã¡ãªã¿ã« &radic;2 ã‚’bc ã§è¨ˆç®—ã™ã‚‹ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
$ bc -l
scale=40
x=sqrt(2.0)
x
1.4142135623730950488016887242096980785696
</p>

<p class="orig" lang="en">
We can generate more and more terms of the stream to get better and
better guesses.  If we like, we can write a procedure that keeps
generating terms until the answer is good enough.  (See
exercise <a href="#%_thm_3.64">3.64</a>.)</p>

<p class="trans" lang="ja">
ã•ã‚‰ã«è‰¯ã„æ¨å®šå€¤ã‚’å¾—ã‚‹ãŸã‚ã«ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®ã•ã‚‰ã«å¤šãã®é …ã‚’ç”Ÿæˆã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
ã‚‚ã—æœ›ã‚€ãªã‚‰ã€ç­”ãˆãŒååˆ†ã‚ˆããªã‚‹ã¾ã§é …ã‚’ç”Ÿæˆã—ç¶šã‘ã‚‹æ‰‹ç¶šãã‚‚æ›¸ã‘ã‚‹ã€‚
(ç·´ç¿’å•é¡Œ<a href="#%_thm_3.64">3.64</a>ã‚’å‚ç…§ã€‚)
</p>

<p class="orig" lang="en">
<a name="%_idx_3950"></a><a name="%_idx_3952"></a><a name="%_idx_3954"></a><a name="%_idx_3956"></a><a name="%_idx_3958"></a><a name="%_idx_3960"></a>Another iteration that we can treat in the same way is to generate an
approximation to <img src="book-Z-G-D-9.gif" border="0">, based upon the alternating series that we saw
in section <a href="12_sec1_3.html#%_sec_1.3.1">1.3.1</a>:</p>

<p class="trans" lang="ja">
åŒæ§˜ã®æ–¹æ³•ã§æ‰±ãˆã‚‹åˆ¥ã®åå¾©ã¯ã€<a href="12_sec1_3.html#%_sec_1.3.1">1.3.1</a>ç¯€ã§è¦‹ãŸäº¤ä»£ç´šæ•°ã«åŸºã¥ã„ã¦ã€&pi; ã®è¿‘ä¼¼å€¤ã‚’ç”Ÿæˆã™ã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚
</p>


<figure><img src="ch3-Z-G-41.gif" border="0"></figure>


<p class="orig" lang="en">
We first generate the stream of summands of the series (the reciprocals
of the odd integers, with alternating signs).  Then we take the stream
of sums of more and more terms (using the <tt>partial-sums</tt> procedure
of exercise <a href="#%_thm_3.55">3.55</a>) and scale the result by 4:
</p>


<p class="trans" lang="ja">
ã¾ãšã€ã“ã®ç´šæ•°ã§è¶³ã•ã‚Œã‚‹ã‚‚ã® (äº¤ä»£äº¤ä»£ã®æ­£è² ç¬¦å·ã‚’æœ‰ã™ã‚‹ã€å¥‡æ•°ã®é€†æ•°) ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ç”Ÿæˆã™ã‚‹ã€‚
ãã‚Œã‹ã‚‰ã€ã©ã‚“ã©ã‚“å¤šããªã£ã¦ã‚†ãé …ã®å’Œã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ã¨ã‚‹ (ç·´ç¿’å•é¡Œ<a href="#%_thm_3.55">3.55</a>ã® <tt>partial-sums</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’ä½¿ã†)ã€‚
</p>

<p class="lisp">(define (pi-summands n)
  (cons-stream (/ 1.0 n)
               (stream-map - (pi-summands (+ n 2)))))
<a name="%_idx_3962"></a>(define pi-stream
  (scale-stream (partial-sums (pi-summands 1)) 4))
(display-stream pi-stream)
<i>4.</i>
<i>2.666666666666667</i>
<i>3.466666666666667</i>
<i>2.8952380952380956</i>
<i>3.3396825396825403</i>
<i>2.9760461760461765</i>
<i>3.2837384837384844</i>
<i>3.017071817071818</i>
<tt>...</tt></p>

<p class="exercise"><span class="ex_comment">ã¡ãªã¿ã« &pi; ã‚’bc ã§è¨ˆç®—ã™ã‚‹ã¨ä»¥ä¸‹ã®ã¨ãŠã‚Šã€‚</span>
$ bc -l
scale=40
p=a(sqrt(3.0))*3.0
p
3.1415926535897932384626433832795028841971
</p>

<p class="orig" lang="en">
This gives us a stream of better and better approximations to <img src="book-Z-G-D-9.gif" border="0">,
although the approximations converge rather slowly.  Eight terms of
the sequence bound the value of <img src="book-Z-G-D-9.gif" border="0"> between 3.284 and 3.017.</p>

<p class="trans" lang="ja">
ã“ã‚Œã«ã‚ˆã‚Šã€&pi; ã«å¯¾ã—ã¦ã©ã‚“ã©ã‚“è‰¯ããªã£ã¦ã‚†ãè¿‘ä¼¼å€¤ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒå¾—ã‚‰ã‚Œã‚‹â€”â€”ãŸã ã—ã€è¿‘ä¼¼å€¤ã¯ã‹ãªã‚Šã‚†ã£ãã‚ŠåæŸã™ã‚‹ã®ã§ã¯ã‚ã‚‹ãŒã€‚
åˆ—ã®ã†ã¡ã®8å€‹ã®é …ã«ã‚ˆã‚Šã€&pi; ã®å€¤ã¯ã€3.284 ã¨ 3.017 ã®é–“ã«çµã‚‰ã‚ŒãŸã€‚
</p>


<p class="orig" lang="en">
<a name="%_idx_3964"></a>So far, our use of the stream of states approach is not much different
from updating state variables.  But streams give us an opportunity to
do some interesting tricks.  For example, we can transform a stream
with a <a name="%_idx_3966"></a><em>sequence accelerator</em> that converts a sequence of
approximations to a new sequence that converges to the same value as
the original, only faster.</p>

<p class="trans" lang="ja">
ã“ã“ã¾ã§ã¯ã€çŠ¶æ…‹ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’åˆ©ç”¨ã™ã‚‹ç§ãŸã¡ã®æ‰‹æ³•ã¯ã€çŠ¶æ…‹å¤‰æ•°ã‚’æ›´æ–°ã™ã‚‹ã“ã¨ã¨ã•ã—ã¦å¤‰ã‚ã‚‰ãªã„ã€‚
ã—ã‹ã—ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¯ã€ã‚ã‚‹ç¨®ã®é¢ç™½ã„å¦™æŠ€ã‚’å®Ÿæ¼”ã™ã‚‹æ©Ÿä¼šã‚’ä¸ãˆã¦ãã‚Œã‚‹ã€‚
ãŸã¨ãˆã°ã€è¿‘ä¼¼å€¤ã®åˆ—ã‚’ã€åŒã˜å€¤ã¸ã¨â€”â€”ãŸã ã—ã‚ˆã‚Šé€Ÿãâ€”â€”åæŸã™ã‚‹æ–°ãŸãªåˆ—ã¸ã¨å¤‰æ›ã™ã‚‹ã€<em>æ•°åˆ—åŠ é€Ÿå™¨</em>ã‚’ä½¿ã£ã¦ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å¤‰å½¢ã§ãã‚‹ã€‚
</p>

<p class="orig" lang="en">
One such accelerator, due to the eighteenth-century Swiss mathematician
<a name="%_idx_3968"></a>Leonhard Euler, works well with sequences that are partial sums of
alternating series (series of terms with alternating signs).
In Euler's technique, if <em>S</em><sub><em>n</em></sub> is the <em>n</em>th term
of the original sum sequence, then the accelerated sequence has terms
</p>

<p class="trans" lang="ja">
ãã†ã—ãŸåŠ é€Ÿå™¨ã®ä¸€ã¤ã¯ã€18ç´€ã®ã‚¹ã‚¤ã‚¹ã®æ•°å­¦è€…ã®ãƒ¬ã‚ªãƒ³ãƒãƒ«ãƒˆãƒ»ã‚ªã‚¤ãƒ©ãƒ¼ã«ã‚ˆã‚‹ã‚‚ã®ãªã®ã ãŒã€ã“ã‚Œã¯ã€äº¤ä»£ç´šæ•° (äº¤ä»£äº¤ä»£ã®æ­£è² ç¬¦å·ã‚’æœ‰ã™ã‚‹é …ã‹ã‚‰ãªã‚‹æ•°åˆ—) ã®éƒ¨åˆ†å’Œã§ã‚ã‚‹ã‚ˆã†ãªåˆ—ã«å¯¾ã—ã¦ã€ã†ã¾ãæ©Ÿèƒ½ã™ã‚‹ã€‚
ã‚ªã‚¤ãƒ©ãƒ¼ã®æŠ€æ³•ã§ã¯ã€<em class="en">S<sub>n</sub></em> ãŒå…ƒã®å’Œã®åˆ—ã® <em class="en">n</em> ç•ªç›®ã®é …ã ã¨ã™ã‚‹ã¨ã€åŠ é€Ÿã•ã‚ŒãŸåˆ—ã«ã¯ã€æ¬¡ã®ã‚ˆã†ãªé …ãŒã‚ã‚‹ã€‚

</p>

<figure><img src="ch3-Z-G-42.gif" border="0"></figure>

<p class="orig" lang="en"> 
Thus, if the original sequence is represented as a stream of values,
the transformed sequence is given by</p>

<p class="trans" lang="ja">
ã‚ˆã£ã¦ã€ã‚‚ã—å…ƒã®åˆ—ãŒå€¤ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¨ã—ã¦è¡¨ã•ã‚Œã‚‹ãªã‚‰ã€å¤‰å½¢ã•ã‚ŒãŸåˆ—ã¯ã€ä»¥ä¸‹ã«ã‚ˆã‚Šä¸ãˆã‚‰ã‚Œã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_3970"></a>(define (euler-transform s)
  (let ((s0 (stream-ref s 0))           <em>; <em>S</em><sub><em>n</em>-1</sub></em>
        (s1 (stream-ref s 1))           <em>; <em>S</em><sub><em>n</em></sub></em>
        (s2 (stream-ref s 2)))          <em>; <em>S</em><sub><em>n</em>+1</sub></em>
    (cons-stream (- s2 (/ (square (- s2 s1))
                          (+ s0 (* -2 s1) s2)))
                 (euler-transform (stream-cdr s)))))
</p>


<p class="orig" lang="en">
We can demonstrate Euler acceleration with our sequence of
approximations to <img src="book-Z-G-D-9.gif" border="0">:</p>

<p class="trans" lang="ja">
&pi; ã«å¯¾ã™ã‚‹ç§ãŸã¡ã®è¿‘ä¼¼å€¤ã®åˆ—ã‚’ä½¿ã£ãŸã‚ªã‚¤ãƒ©ãƒ¼ã®åŠ é€Ÿã‚’ã€ç§ãŸã¡ã¯å®Ÿè¨¼ã§ãã‚‹ã€‚
</p>


<p class="lisp">(display-stream (euler-transform pi-stream))
<i>3.166666666666667</i>
<i>3.1333333333333337</i>
<i>3.1452380952380956</i>
<i>3.13968253968254</i>
<i>3.1427128427128435</i>
<i>3.1408813408813416</i>
<i>3.142071817071818</i>
<i>3.1412548236077655</i>
<tt>...</tt></p>

<p class="orig" lang="en">
Even better, we can accelerate the accelerated sequence, and
recursively accelerate that, and so on.  Namely, we create a stream of
streams (a structure we'll call a <a name="%_idx_3972"></a><em>tableau</em>) in which each stream
is the transform of the preceding one:</p>

<p class="trans" lang="ja">
ã•ã‚‰ã«è‰¯ã„ã“ã¨ã«ã¯ã€åŠ é€Ÿã•ã‚ŒãŸåˆ—ã‚’åŠ é€Ÿã§ãã€ãã‚Œã‚’ã¾ãŸå†å¸°çš„ã«åŠ é€Ÿã§ãã€ä»¥ä¸‹åŒæ§˜ã§ã‚ã‚‹ã€‚
ã¤ã¾ã‚Šã€ãã®ä¸­ã§ã¯å„ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒå…ˆè¡Œã‚¹ãƒˆãƒªãƒ¼ãƒ ã®å¤‰å½¢ã§ã‚ã‚‹ã‚ˆã†ãªã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ  (<em>ã‚¿ãƒ–ãƒ­ãƒ¼</em>ã¨å‘¼ã¶ã“ã¨ã«ã™ã‚‹æ§‹é€ ) ã‚’ä½œã‚‹ã®ã ã€‚
</p>

<p class="lisp"><a name="%_idx_3974"></a>(define (make-tableau transform s)
  (cons-stream s
               (make-tableau transform
                             (transform s))))
</p>

<p class="orig" lang="en">
The tableau has the form</p>

<p class="trans" lang="ja">
ã‚¿ãƒ–ãƒ­ãƒ¼ã¯ä»¥ä¸‹ã®å½¢ã‚’ã—ã¦ã„ã‚‹ã€‚
</p>

<figure><img src="ch3-Z-G-43.gif" border="0"></figure>

<p class="orig" lang="en">
Finally, we form a sequence by taking the first term in each row of
the tableau:</p>

<p class="trans" lang="ja">
æœ€å¾Œã«ã€ã‚¿ãƒ–ãƒ­ãƒ¼ã®å„è¡Œã«ãŠã‘ã‚‹æœ€åˆã®é …ã‚’å–ã‚Šå‡ºã™ã“ã¨ã§ã€åˆ—ã‚’å½¢æˆã™ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_3976"></a>(define (accelerated-sequence transform s)
  (stream-map stream-car
              (make-tableau transform s)))
</p>


<p class="orig" lang="en">
We can demonstrate this kind of ``super-acceleration'' of the <img src="book-Z-G-D-9.gif" border="0">
sequence:</p>

<p class="trans" lang="ja">
&pi; ã®åˆ—ã®ã€ã“ã®ç¨®ã®ã€Œè¶…åŠ é€Ÿã€ã‚’ã€ç§ãŸã¡ã¯å®Ÿè¨¼ã§ãã‚‹ã€‚

</p>


<p class="lisp">(display-stream (accelerated-sequence euler-transform
                                      pi-stream))
<i>4.</i>
<i>3.166666666666667</i>
<i>3.142105263157895</i>
<i>3.141599357319005</i>
<i>3.1415927140337785</i>
<i>3.1415926539752927</i>
<i>3.1415926535911765</i>
<i>3.141592653589778</i>
<tt>...</tt></p>


<p class="orig" lang="en">
The result is impressive.  Taking eight terms of the sequence yields
the correct value of <img src="book-Z-G-D-9.gif" border="0"> to 14 decimal places.  If we had used only
the original <img src="book-Z-G-D-9.gif" border="0"> sequence, we would need to compute on the order of
10<sup>13</sup> terms (i.e., expanding the series far enough so that the
individual terms are less then 10<sup>-13</sup>) to get that much accuracy!

We could have implemented these acceleration techniques without
using streams.  But the stream formulation is particularly elegant and
convenient because the entire sequence of states is available to us as a
data structure that can be manipulated with a uniform set of
operations.</p>

<p class="trans" lang="ja">
çµæœã¯å°è±¡çš„ã ã€‚
8å€‹ã®é …ã‚’ã¨ã‚Œã°ã€å°æ•°ç‚¹ä»¥ä¸‹14æ¡ã¾ã§ã® &pi; ã®æ­£ã—ã„å€¤ãŒç”Ÿã¿å‡ºã•ã‚Œã‚‹ã®ã ã€‚
ã‚‚ã—å…ƒã® &pi; ã®åˆ—ã ã‘ã‚’ä½¿ã£ã¦ã„ãŸã‚‰ã€ãã‚Œã ã‘å¤§ã—ãŸç²¾åº¦ã‚’å¾—ã‚‹ãŸã‚ã«ã¯ã€10<sup>13</sup> ã®ã‚ªãƒ¼ãƒ€ã®å€‹æ•°ã®é …ã«ã¤ã„ã¦è¨ˆç®—ã‚’ã™ã‚‹å¿…è¦ãŒã‚ã£ãŸã ã‚ã† (ã¤ã¾ã‚Šã€å€‹ã€…ã®é …ãŒ 10<sup>&minus;13</sup>æœªæº€ã¨ãªã‚‹ã‚ˆã†ã«ã€ååˆ†ã«å…ˆã¾ã§ç´šæ•°ã‚’å±•é–‹ã™ã‚‹ã¨ã„ã†ã“ã¨)!
ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½¿ã‚ãšã«ã€ã“ã‚Œã‚‰ã®åŠ é€ŸæŠ€æ³•ã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ã‚‚ã§ããŸã ã‚ã†ã€‚
ã—ã‹ã—ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®å®šå¼åŒ–ã¯ä¸¦å¤–ã‚Œã¦æ´—ç·´ã•ã‚Œã¦ã„ã¦ä¾¿åˆ©ã§ã‚ã‚‹ã€‚ã¨ã„ã†ã®ã‚‚ã€çŠ¶æ…‹ã®åˆ—å…¨ä½“ãŒã€ä¸€å¾‹ãªæ¼”ç®—ä¸€å¼ã‚’ä½¿ã£ã¦æ“ä½œã™ã‚‹ã“ã¨ã®ã§ãã‚‹ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã¨ã—ã¦ã€ç§ãŸã¡ã«ã¨ã£ã¦åˆ©ç”¨å¯èƒ½ã¨ãªã£ã¦ã„ã‚‹ã‹ã‚‰ã§ã‚ã‚‹ã€‚
</p>


<p class="orig" lang="en"><a name="%_thm_3.63"></a>
<b>Exercise 3.63.</b>  Louis Reasoner asks why the <tt>sqrt-stream</tt> procedure was not
written in the following more straightforward way, without
the local variable <tt>guesses</tt>:
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.63.</b> ãƒ«ã‚¤ã‚¹ãƒ»ãƒªãƒ¼ã‚ºãƒŠã¯ã€ãªãœ <tt>sqrt-stream</tt> ã®æ‰‹ç¶šããŒã€ä»¥ä¸‹ã®ã‚ˆã†ãªã‚ˆã‚Šåˆ†ã‹ã‚Šã‚„ã™ã„æ–¹æ³•â€”â€” <tt>guesses</tt> ã¨ã„ã†å±€æ‰€å¤‰æ•°ãªã—â€”â€”ã§ã¯æ›¸ã‹ã‚Œãªã‹ã£ãŸã®ã‹ã€ã¨å°‹ã­ã‚‹ã€‚
</p>


<p class="lisp">(define (sqrt-stream x)
  (cons-stream 1.0
               (stream-map (lambda (guess)
                             (sqrt-improve guess x))
                           (sqrt-stream x))))
</p>


<p class="orig" lang="en">
Alyssa P. Hacker replies that this version of the procedure is
considerably less efficient because it performs redundant computation.
Explain Alyssa's answer.  Would the two versions still differ in
efficiency if our implementation of <tt>delay</tt> used only <tt>(lambda
() &lt;<em>exp</em>&gt;)</tt> without using the optimization provided by <tt>memo-proc</tt> (section <a href="#%_sec_3.5.1">3.5.1</a>)?

</p>

<p class="trans" lang="ja">
ã‚¢ãƒªãƒƒã‚µãƒ»Pãƒ»ãƒãƒƒã‚«ã¯ã€ã“ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®æ‰‹ç¶šãã¯ã€å†—é•·ãªè¨ˆç®—ã‚’å®Ÿè¡Œã™ã‚‹ã›ã„ã§ã€ã‹ãªã‚ŠåŠ¹ç‡ãŒæ‚ªããªã£ã¦ã„ã‚‹ã‚“ã ã‚ˆã€ã¨ç­”ãˆã‚‹ã€‚
ã‚¢ãƒªãƒƒã‚µã®ç­”ãˆã«ã¤ã„ã¦èª¬æ˜ã›ã‚ˆã€‚
ã‚‚ã—ã€ç§ãŸã¡ã® <tt>delay</tt> ã®å®Ÿè£…ãŒã€<tt>memo-proc</tt> ã«ã‚ˆã‚Šã‚‚ãŸã‚‰ã•ã‚Œã‚‹æœ€é©åŒ– (<a href="#%_sec_3.5.1">3.5.1</a>ç¯€) ã‚’åˆ©ç”¨ã›ãšã€å˜ã«
<tt>(lambda () &lt;<em class="en">exp</em>&gt;)</tt> 
ã®ã¿ã‚’ä½¿ã£ã¦ã„ãŸã¨ã—ãŸã‚‰ã€ãã‚Œã§ã‚‚äºŒã¤ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯åŠ¹ç‡ã«å·®ãŒã‚ã£ãŸã ã‚ã†ã‹?
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.64"></a>
<b>Exercise 3.64.</b>  Write a procedure <a name="%_idx_3978"></a><tt>stream-limit</tt> that takes as arguments a stream
and a number (the tolerance).  It should examine the stream until it
finds two successive elements that differ in absolute value by less
than the tolerance, and return the second of the two elements.  Using
this, we could compute square roots up to a given tolerance by
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.64.</b> å¼•æ•°ã¨ã—ã¦ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¨æ•° (è¨±å®¹ç¯„å›²) ã‚’ã¨ã‚‹ã€<tt>stream-limit</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’æ›¸ã‘ã€‚
ãã®æ‰‹ç¶šãã¯ã€çµ¶å¯¾å€¤ãŒè¨±å®¹ç¯„å›²æœªæº€ã—ã‹é•ã‚ãªã„ã‚ˆã†ãªã€äºŒã¤ã®é€£ç¶šã™ã‚‹è¦ç´ ã‚’è¦‹ã¤ã‘ã‚‹ã¾ã§ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’æ¤œæŸ»ã™ã¹ãã§ã‚ã‚Šã€ãã®äºŒã¤ã®è¦ç´ ã®ã†ã¡2ç•ªç›®ã®æ–¹ã‚’è¿”ã™ã¹ãã§ã‚ã‚‹ã€‚
ã“ã‚Œã‚’ä½¿ã†ã¨ã€ä¸ãˆã‚‰ã‚ŒãŸè¨±å®¹ç¯„å›²ã¾ã§ã®äºŒä¹—æ ¹ã‚’ã€ä»¥ä¸‹ã«ã‚ˆã‚Šè¨ˆç®—ã§ãã‚‹ã ã‚ã†ã€‚
</p>

<p class="lisp"><a name="%_idx_3980"></a>(define (sqrt x tolerance)
  (stream-limit (sqrt-stream x) tolerance))
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.65"></a>
<b>Exercise 3.65.</b>  <a name="%_idx_3982"></a>Use the series
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.65.</b> ä»¥ä¸‹ã®ç´šæ•°ã‚’ä½¿ã£ã¦ã€
</p>

<figure><img src="ch3-Z-G-44.gif" border="0"></figure>

<p class="orig" lang="en">
to compute three sequences of approximations to the natural logarithm of 2,
in the same way we did above for <img src="book-Z-G-D-9.gif" border="0">.
How rapidly do these sequences converge?
</p>

<p class="trans" lang="ja">
&pi; ã«ã¤ã„ã¦ä¸Šè¨˜ã§è¡Œã£ãŸã®ã¨åŒæ§˜ã®æ–¹æ³•ã§ã€2ã®è‡ªç„¶å¯¾æ•°ã«å¯¾ã™ã‚‹è¿‘ä¼¼å€¤ã®ã€ä¸‰ã¤ã®åˆ—ã‚’è¨ˆç®—ã›ã‚ˆã€‚
ã“ã‚Œã‚‰ã®åˆ—ã¯ã€ã©ã‚Œã»ã©æ€¥é€Ÿã«åæŸã™ã‚‹ã ã‚ã†?
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_Temp_476"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_476">Infinite streams of pairs</a></h4>
<h4 class="trans" lang="ja">å¯¾ã®ç„¡é™ã‚¹ãƒˆãƒªãƒ¼ãƒ </h4>

<p class="orig" lang="en">
<a name="%_idx_3984"></a><a name="%_idx_3986"></a><a name="%_idx_3988"></a>
In section <a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a>, we saw how the sequence paradigm
handles traditional nested loops as processes defined on sequences of
pairs.  If we generalize this technique to infinite streams, then we
can write programs that are not easily represented as loops, because
the ``looping'' must range over an infinite set.</p>

<p class="trans" lang="ja">
<a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a>ç¯€ã§ã€åˆ—ã®ãƒ‘ãƒ©ãƒ€ã‚¤ãƒ ãŒã©ã®ã‚ˆã†ã«ã—ã¦ã€ä¼çµ±çš„ãªå…¥ã‚Œå­ã«ãªã£ãŸãƒ«ãƒ¼ãƒ—ã‚’ã€å¯¾ã®åˆ—ã®ä¸Šã§å®šç¾©ã•ã‚Œã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã¨ã—ã¦å–ã‚Šæ‰±ã†ã®ã‹ã€ã‚’è¦‹ãŸã€‚
ã“ã®æŠ€æ³•ã‚’ç„¡é™ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«ã¾ã§ä¸€èˆ¬åŒ–ã™ã‚‹ã¨ã€ã€Œãƒ«ãƒ¼ãƒ—ã™ã‚‹ã“ã¨ã€ãŒç„¡é™é›†åˆå…¨ä½“ã«æ¸¡ã‚‰ãªãã¦ã¯ãªã‚‰ãªã„ã›ã„ã§ç°¡å˜ã«ã¯ãƒ«ãƒ¼ãƒ—ã¨ã—ã¦è¡¨ç¾ã•ã‚Œãªã„ã‚ˆã†ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ã€æ›¸ãã“ã¨ãŒã§ãã‚‹ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_3990"></a>For example, suppose we want to generalize the <tt>prime-sum-pairs</tt>
procedure of section <a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a> to produce the stream
of pairs of <em>all</em> integers (<em>i</em>,<em>j</em>) with <em>i</em> <u>&lt;</u> <em>j</em> such that <em>i</em> + <em>j</em>
is prime.  If <tt>int-pairs</tt> is the sequence of all pairs of integers (<em>i</em>,<em>j</em>)
with <em>i</em> <u>&lt;</u> <em>j</em>, then our required stream is simply<a name="call_footnote_Temp_477" href="#footnote_Temp_477"><sup><small>66</small></sup></a></p>

<p class="trans" lang="ja">
ãŸã¨ãˆã°ã€
<span class="math"><em class="en">i</em> + <em class="en">j</em></span>
ãŒç´ æ•°ã§ã‚ã‚‹ã‚ˆã†ãªã€
<span class="math"><em class="en">i</em> &le; <em class="en">j</em></span>
ãªã‚‹<em>ã™ã¹ã¦ã®</em>æ•´æ•°
<span class="math">(<em class="en">i</em>, <em class="en">j</em>)</span>
ã®å¯¾ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½œã‚Šå‡ºã™ã‚ˆã†ã«ã€<a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a>ç¯€ã® <tt>prime-sum-pairs</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’ä¸€èˆ¬åŒ–ã—ãŸã„ã®ã ã¨ã—ã‚ˆã†ã€‚
ã‚‚ã—ã€<tt>int-pairs</tt> ãŒã€
<span class="math"><em class="en">i</em> &le; <em class="en">j</em></span>
ãªã‚‹æ•´æ•°
<span class="math">(<em class="en">i</em>, <em class="en">j</em>)</span>
ã®ã™ã¹ã¦ã®å¯¾ã®åˆ—ã§ã‚ã‚Œã°ã€æ±‚ã‚ã‚‰ã‚Œã¦ã„ã‚‹ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¯ã€å˜ã«ä»¥ä¸‹ã®ã¨ãŠã‚Šã§ã‚ã‚‹<a href="#footnote_Temp_477"><sup><small>66</small></sup></a>ã€‚
</p>


<p class="lisp">(stream-filter (lambda (pair)
                 (prime? (+ (car pair) (cadr pair))))
               int-pairs)
</p>

<p class="orig" lang="en">
Our problem, then, is to produce the stream <tt>int-pairs</tt>.  More
generally, suppose we have two streams <em>S</em>  =  (<em>S</em><sub><em>i</em></sub>) and <em>T</em>  =  (<em>T</em><sub><em>j</em></sub>),
and imagine the infinite rectangular array
</p>

<p class="trans" lang="ja">
ã™ã‚‹ã¨ã€å•é¡Œã¯ã€<tt>int-pairs</tt> ã¨ã„ã†ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½œã‚Šå‡ºã™ã“ã¨ã§ã‚ã‚‹ã€‚
ã‚ˆã‚Šä¸€èˆ¬çš„ã«ã€
<span class="math"><em class="en">S</em>  =  (<em class="en">S<sub>i</sub></em>)</span> 
ã¨
<span class="math"><em class="en">T</em>  =  (<em class="en">T<sub>j</sub></em>)</span>
ã¨ã„ã†äºŒã¤ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒã‚ã‚‹ã‚‚ã®ã¨ã—ã¦ã€ä»¥ä¸‹ã®ã‚ˆã†ãªç„¡é™ã®çŸ©å½¢é…åˆ—ã‚’æƒ³åƒã›ã‚ˆã€‚
</p>

<figure><img src="ch3-Z-G-45.gif" border="0"></figure>

<p class="orig" lang="en">
We wish to generate a stream that contains all the pairs in the array
that lie on or above the diagonal, i.e., the pairs
</p>

<p class="trans" lang="ja">
ç§ãŸã¡ã¯ã€é…åˆ—å†…ã®ã€å¯¾è§’ç·šä¸Šã¾ãŸã¯ãã‚Œã‚ˆã‚Šã‚‚ä¸Šå´ã«ã‚ã‚‹ã€ã™ã¹ã¦ã®å¯¾â€”â€”ã¤ã¾ã‚Šä»¥ä¸‹ã®å¯¾â€”â€”ã‚’å«ã‚€ã‚ˆã†ãªã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ç”Ÿæˆã—ãŸã„ã€‚
</p>

<figure><img src="ch3-Z-G-46.gif" border="0"></figure>

<p class="orig" lang="en">
(If we take both <em>S</em> and <em>T</em> to be the stream of integers, then this
will be our desired stream <tt>int-pairs</tt>.)  </p>

<p class="trans" lang="ja">
(ã“ã‚Œã¯ã€ã‚‚ã—ã€<em class="en">S</em> ã¨ <em class="en">T</em> ã®åŒæ–¹ã‚’ã€æ•´æ•°ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¨ãªã‚‹ã‚ˆã†ã«ã¨ã‚Œã°ã€ç§ãŸã¡ã®æ‰€æœ›ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ  ã®  <tt>int-pairs</tt> ã¨ãªã‚‹ã ã‚ã†ã€‚)
</p>

<p class="orig" lang="en">
Call the general stream of pairs <tt>(pairs S T)</tt>, and consider it to
be composed of three parts: the pair (<em>S</em><sub>0</sub>,<em>T</em><sub>0</sub>), the
rest of the pairs in the first row, and the remaining pairs:<a name="call_footnote_Temp_478" href="#footnote_Temp_478"><sup><small>67</small></sup></a>
</p>

<p class="trans" lang="ja">
 <tt>(pairs S T)</tt> ã¨ã„ã†ã€å¯¾ã®ä¸€èˆ¬çš„ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å‘¼ã³å‡ºã—ã€ãã‚ŒãŒä¸‰ã¤ã®éƒ¨åˆ†â€”â€”ã¤ã¾ã‚Šã€
 <span class="math">(<em class="en">S</em><sub>0</sub>,<em class="en">T</em><sub>0</sub>)</span>
ã¨ã„ã†å¯¾ã¨ã€æœ€åˆã®è¡Œã®æ®‹ã‚Šã®éƒ¨åˆ†ã¨ã€æ®‹ã‚Šã®å¯¾â€”â€”ã‹ã‚‰ãªã‚‹ã¨è€ƒãˆã‚ˆ<a href="#footnote_Temp_478"><sup><small>67</small></sup></a>ã€‚
</p>

<figure><img src="ch3-Z-G-47.gif" border="0"></figure>


<p class="orig" lang="en">
Observe that the third piece in this decomposition (pairs that are not in the
first row) is (recursively) the pairs formed from <tt>(stream-cdr S)</tt>
and <tt>(stream-cdr T)</tt>.  Also note that the second piece (the rest
of the first row) is
</p>


<p class="trans" lang="ja">
ã“ã®åˆ†è§£ã«ãŠã‘ã‚‹ä¸‰ç•ªç›®ã®éƒ¨å“ (æœ€åˆã®è¡Œã«ãªã„å¯¾) ãŒ (å†å¸°çš„ã«) <tt>(stream-cdr S)</tt> ã¨ <tt>(stream-cdr T)</tt> ã‹ã‚‰å½¢æˆã•ã‚Œã‚‹å¯¾ã§ã‚ã‚‹ã€ã¨ã„ã†ã“ã¨ã«æ°—ã¥ã„ã¦ã»ã—ã„ã€‚
ã¾ãŸã€äºŒç•ªç›®ã®éƒ¨å“ (æœ€åˆã®è¡Œã®æ®‹ã‚Š) ã¯ä»¥ä¸‹ã®ã¨ãŠã‚Šã§ã‚ã‚‹ã€ã¨ã„ã†ã“ã¨ã«æ³¨æ„ã›ã‚ˆã€‚
</p>

<p class="lisp">(stream-map (lambda (x) (list (stream-car s) x))
            (stream-cdr t))
</p>

<p class="orig" lang="en">
Thus we can form our stream of pairs as follows:
</p>

<p class="trans" lang="ja">
ã‚ˆã£ã¦ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¦ç§ãŸã¡ã®å¯¾ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å½¢æˆã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
</p>

<p class="lisp">(define (pairs s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (&lt;<em>combine-in-some-way</em>&gt;
       (stream-map (lambda (x) (list (stream-car s) x))
                   (stream-cdr t))
       (pairs (stream-cdr s) (stream-cdr t)))))
</p>


<p class="orig" lang="en">
<a name="%_idx_3992"></a>In order to complete the procedure, we must choose some way to combine
the two inner streams.  One idea is to use the stream analog of the
<tt>append</tt> procedure from section <a href="15_sec2_2.html#%_sec_2.2.1">2.2.1</a>:</p>

<p class="trans" lang="ja">
æ‰‹ç¶šãã‚’å®Œæˆã•ã›ã‚‹ã«ã¯ã€äºŒã¤ã®å†…éƒ¨ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’çµåˆã™ã‚‹ä½•ã‚‰ã‹ã®æ–¹æ³•ã‚’é¸ã°ã­ã°ãªã‚‰ãªã„ã€‚
ä¸€ã¤ã®è€ƒãˆã¯ã€<a href="15_sec2_2.html#%_sec_2.2.1">2.2.1</a>ç¯€ã® <tt>append</tt> ã¨ã„ã†æ‰‹ç¶šãã®ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ç‰ˆã®ç›¸ä¼¼ç‰©ã‚’ä½¿ã†ã“ã¨ã ã€‚
</p>

<p class="lisp"><a name="%_idx_3994"></a>(define (stream-append s1 s2)
  (if (stream-null? s1)
      s2
      (cons-stream (stream-car s1)
                   (stream-append (stream-cdr s1) s2))))
</p>


<p class="orig" lang="en">
This is unsuitable for infinite streams, however,
because it takes all the elements from the first stream before
incorporating the second stream.
In particular, if we try to generate all pairs of positive integers using</p>

<p class="trans" lang="ja">
ã ãŒã€ã“ã‚Œã¯ã€2ç•ªç›®ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å–ã‚Šè¾¼ã‚€ã‚ˆã‚Šã‚‚å‰ã«ã€1ç•ªç›®ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‹ã‚‰ã™ã¹ã¦ã®è¦ç´ ã‚’å–ã‚Šå‡ºã™ã®ã ã‹ã‚‰ã€ç„¡é™ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«ã¯ä¸é©åˆ‡ã ã€‚
ç‰¹ã«ã€ä»¥ä¸‹ã‚’ç”¨ã„ã¦æ­£æ•´æ•°ã®ã™ã¹ã¦ã®å¯¾ã‚’ç”Ÿæˆã—ã‚ˆã†ã¨ã™ã‚‹å ´åˆã«ã¯ã€
</p>

<p class="lisp">(pairs integers integers)
</p>


<p class="orig" lang="en">
our stream of results will first try to run through all pairs with the
first integer equal to 1, and hence will never produce pairs with any
other value of the first integer.</p>

<p class="trans" lang="ja">
çµæœã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¯ã€ã¾ãšã€1ç•ªç›®ã®æ•´æ•°ãŒ1ã«ç­‰ã—ã„ã™ã¹ã¦ã®å¯¾ã‚’ã²ã¨ã‚ãŸã‚Šè¦‹ã¦<!--èˆã‚ã¦--><!--é€šã£ã¦-->ã„ã“ã†ã¨ã™ã‚‹ã ã‚ã†ã—ã€ãã‚Œã‚†ãˆã€1ç•ªç›®ã®æ•´æ•°ãŒä»–ã®ä½•ã‚‰ã‹ã®å€¤ã§ã‚ã‚‹ã‚ˆã†ãªå¯¾ã‚’ã€æ±ºã—ã¦ä½œã‚Šå‡ºã•ãªã„ã ã‚ã†ã€‚
</p>

<p class="orig" lang="en">
To handle infinite streams, we need to devise an order of combination
that ensures that every element will eventually be reached if we let
our program run long enough.  An elegant way to accomplish this is
with the following <tt>interleave</tt> procedure:<a name="call_footnote_Temp_479" href="#footnote_Temp_479"><sup><small>68</small></sup></a></p>

<p class="trans" lang="ja">
ç„¡é™ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’æ‰±ã†ãŸã‚ã«ã€ç§ãŸã¡ã¯ã€ååˆ†ã«é•·ããƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’èµ°ã‚‰ã›ã‚Œã°ã€ã©ã®è¦ç´ ã«ã‚‚æœ€çµ‚çš„ã«ã¯åˆ°é”ã™ã‚‹ã§ã‚ã‚ã†ã€ã¨ä¿è¨¼ã™ã‚‹ã‚ˆã†ãªã€çµåˆã®é †åºã‚’ã€è€ƒæ¡ˆã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
ã“ã‚Œã‚’é”æˆã™ã‚‹ãŸã‚ã®æ´—ç·´ã•ã‚ŒãŸæ–¹æ³•ã§ã¯ã€ä»¥ä¸‹ã® <tt>interleave</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’ä½¿ã†<a href="#footnote_Temp_479"><sup><small>68</small></sup></a>ã€‚
</p>


<p class="lisp"><a name="%_idx_4000"></a>(define (interleave s1 s2)
  (if (stream-null? s1)
      s2
      (cons-stream (stream-car s1)
                   (interleave s2 (stream-cdr s1)))))
</p>


<p class="orig" lang="en">
Since <tt>interleave</tt> takes elements alternately from the two streams,
every element of the second stream will eventually find its way into
the interleaved stream, even if the first stream is infinite.</p>

<p class="trans" lang="ja">
<tt>interleave</tt> ã¯äºŒã¤ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‹ã‚‰äº¤äº’ã«è¦ç´ ã‚’å–ã‚Šå‡ºã™ã®ã§ã€2ç•ªç›®ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®ã©ã®è¦ç´ ã‚‚ã€æœ€çµ‚çš„ã«ã¯ã€äº’ã„é•ã„ã®æ··ãœã“ãœã«ãªã£ãŸã‚¹ãƒˆãƒªãƒ¼ãƒ ã®ä¸­ã«ç¾ã‚Œã‚‹ã ã‚ã†â€”â€”ãŸã¨ãˆ1ç•ªç›®ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒç„¡é™ã§ã‚ã£ã¦ã‚‚ã€‚
</p>

<p class="orig" lang="en">
We can thus generate the required stream of pairs as
</p>

<p class="trans" lang="ja">
ã‚ˆã£ã¦ã€æ±‚ã‚ã‚‰ã‚Œã¦ã„ã‚‹å¯¾ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ç”Ÿæˆã§ãã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_4002"></a>(define (pairs s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (interleave
    (stream-map (lambda (x) (list (stream-car s) x))
                (stream-cdr t))
    (pairs (stream-cdr s) (stream-cdr t)))))
</p>

<p class="orig" lang="en"><a name="%_thm_3.66"></a>
<b>Exercise 3.66.</b>  Examine the stream <tt>(pairs integers integers)</tt>. Can you make any general
comments about the order in which the pairs are placed into the
stream? For example, about how many pairs precede the pair (1,100)?
the pair (99,100)? the pair (100,100)? (If you can make precise
mathematical statements here, all the better. But feel free to give
more qualitative answers if you find yourself getting bogged down.)
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.66.</b> <tt>(pairs integers integers)</tt> ã¨ã„ã†ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’åŸå‘³ã—ã‚ˆã†ã€‚
å¯¾ãŒå½“è©²ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«é…ç½®ã•ã‚Œã‚‹é †åºã«ã¤ã„ã¦ã€å›ã¯ä½•ã‹ä¸€èˆ¬çš„ãªã‚³ãƒ¡ãƒ³ãƒˆã‚’ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã‹ãª?
ãŸã¨ãˆã°ã€ã„ãã¤ã®å¯¾ãŒã€
<span class="math">(1, 100)</span>
ã¨ã„ã†å¯¾ã‚ˆã‚Šå‰ã«ã‚ã‚‹ã‹ã€ã¨ã„ã†ã“ã¨ã«ã¤ã„ã¦ã¯?
<span class="math">(99, 100)</span>
ã¨ã„ã†å¯¾ã«ã¤ã„ã¦ã¯ã©ã†ã‹ãª?
<span class="math">(100, 100)</span>
ã¨ã„ã†å¯¾ã«ã¤ã„ã¦ã¯ã©ã†ã‹ãª?
(ã‚‚ã—å›ãŒæ­£ç¢ºãªæ•°å­¦çš„é™³è¿°ã‚’ã“ã“ã§è¡Œã†ã“ã¨ãŒã§ãã‚‹ãªã‚‰ã€ã•ã‚‰ã«è‰¯ã„ã€‚
ã‘ã‚Œã©ã‚‚ã€è‡ªåˆ†ãŒè¡Œãè©°ã¾ã£ã¦ã„ã‚‹ã¨æ°—ã¥ã„ãŸã‚‰ã€é æ…®ãªãã€ã‚‚ã£ã¨å¤šãã®é‡çš„ãªç­”ãˆã‚’æ›¸ã„ã¦ãã‚ŒãŸã¾ãˆã€‚)
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.67"></a>
<b>Exercise 3.67.</b>  Modify the <tt>pairs</tt> procedure so that <tt>(pairs integers
integers)</tt> will produce the stream of <em>all</em> pairs of integers
(<em>i</em>,<em>j</em>) (without the condition <em>i</em> <u>&lt;</u> <em>j</em>).  Hint: You will need to
mix in an additional stream.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.67.</b>  <tt>(pairs integers integers)</tt> ãŒã€
<span class="math">(<em class="en">i</em>,<em class="en">j</em>)</span>
ãªã‚‹æ•´æ•°åŒå£«ã®<em>ã™ã¹ã¦ã®</em>å¯¾
(<span class="math"><em class="en">i</em> &le; <em class="en">j</em></span> ã¨ã„ã†æ¡ä»¶ã¯ç„¡ã—) 
ã‚’ä½œã‚Šå‡ºã™ã‚ˆã†ã«ã€<tt>pairs</tt> ã‚’æ”¹å¤‰ã›ã‚ˆã€‚
ãƒ’ãƒ³ãƒˆ: è¿½åŠ ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®ä¸­ã«æ··ãœã‚‹å¿…è¦ãŒã‚ã‚‹ã ã‚ã†ã€‚
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.68"></a>
<b>Exercise 3.68.</b>  Louis Reasoner thinks that building a stream of pairs from three
parts is unnecessarily complicated.  Instead of separating the
pair (<em>S</em><sub>0</sub>,<em>T</em><sub>0</sub>) from the rest of the pairs in the first row,
he proposes to work with the whole first row, as follows:
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.68.</b> ãƒ«ã‚¤ã‚¹ãƒ»ãƒªãƒ¼ã‚ºãƒŠã¯ã€ä¸‰ã¤ã®éƒ¨åˆ†ã‹ã‚‰å¯¾ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’æ§‹ç¯‰ã™ã‚‹ã“ã¨ã¯ä¸å¿…è¦ã«è¤‡é›‘ã§ã‚ã‚‹ã€ã¨è€ƒãˆã¦ã„ã‚‹ã€‚
æœ€åˆã®è¡Œã«ãŠã„ã¦ã€
<span class="math">(<em class="en">S</em><sub>0</sub>,<em class="en">T</em><sub>0</sub>)</span>
ã¨ã„ã†å¯¾ã‚’æ®‹ã‚Šã®éƒ¨åˆ†ã‹ã‚‰åˆ†é›¢ã™ã‚‹ä»£ã‚ã‚Šã«ã€
ä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¦æœ€åˆã®è¡Œå…¨ä½“ã‚’ä½¿ã£ã¦ä½œæ¥­ã™ã‚‹ã“ã¨ã‚’ã€ãƒ«ã‚¤ã‚¹ã¯ææ¡ˆã™ã‚‹ã€‚
</p>

<p class="lisp">(define (pairs s t)
  (interleave
   (stream-map (lambda (x) (list (stream-car s) x))
               t)
   (pairs (stream-cdr s) (stream-cdr t))))
</p>


<p class="orig" lang="en">
Does this work?  Consider what happens if we evaluate
<tt>(pairs integers integers)</tt> using Louis's definition of <tt>pairs</tt>.

</p>

<p class="trans" lang="ja">
ã“ã‚Œã¯ã†ã¾ãã„ãã ã‚ã†ã‹?
ã‚‚ã—ã€<tt>pairs</tt> ã«ã¤ã„ã¦ã®ãƒ«ã‚¤ã‚¹ã®å®šç¾©ã‚’ä½¿ã£ã¦ã€<tt>(pairs integers integers)</tt> ã‚’è©•ä¾¡ã—ãŸã¨ã™ã‚‹ã¨ã€ä½•ãŒèµ·ã“ã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’è€ƒãˆã‚ˆã€‚

</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.69"></a>
<b>Exercise 3.69.</b>  Write a procedure <tt>triples</tt> that takes three infinite
streams, <em>S</em>, <em>T</em>, and <em>U</em>, and produces the stream of triples
(<em>S</em><sub><em>i</em></sub>,<em>T</em><sub><em>j</em></sub>,<em>U</em><sub><em>k</em></sub>) such that <em>i</em> <u>&lt;</u> <em>j</em> <u>&lt;</u> <em>k</em>.
Use <tt>triples</tt> to
generate the stream of all <a name="%_idx_4004"></a>Pythagorean triples of positive integers,
i.e., the triples (<em>i</em>,<em>j</em>,<em>k</em>) such that <em>i</em> <u>&lt;</u> <em>j</em> and <em>i</em><sup>2</sup>  +  <em>j</em><sup>2</sup>  = <em>k</em><sup>2</sup>.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.69.</b> <em class="en">S</em> ã¨ <em class="en">T</em> ã¨ <em class="en">U</em> ã¨ã„ã†ä¸‰ã¤ã®ç„¡é™ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ã¨ã‚Šã€
<em class="en">i</em> <u>&lt;</u> <em class="en">j</em> <u>&lt;</u> <em class="en">k</em>
ã§ã‚ã‚‹ã‚ˆã†ãª
<span class="math">(<em class="en">S</em><sub><em class="en">i</em></sub>,<em class="en">T</em><sub><em class="en">j</em></sub>,<em class="en">U</em><sub><em class="en">k</em></sub>)</span>
ã¨ã„ã†ä¸‰ã¤çµ„ã‹ã‚‰ãªã‚‹ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½œã‚Šå‡ºã™ã€<tt>triples</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’æ›¸ã‘ã€‚
<tt>triples</tt> ã‚’ä½¿ã£ã¦ã€ã™ã¹ã¦ã®ã€æ­£æ•´æ•°ã®ãƒ”ã‚¿ã‚´ãƒ©ã‚¹ã®ä¸‰ã¤çµ„â€”â€”ã¤ã¾ã‚Šã€
<span class="math"><em class="en">i</em> &le; <em class="en">j</em></span>
ã‹ã¤ 
<span class="math"><em class="en">i</em><sup>2</sup>  +  <em class="en">j</em><sup>2</sup>  = <em class="en">k</em><sup>2</sup></span>
ã§ã‚ã‚‹ã‚ˆã†ãªã€
<span class="math">(<em class="en">i</em>, <em class="en">j</em>, <em class="en">k</em>)</span>
ã¨ã„ã†ä¸‰ã¤çµ„
â€”â€”ã‹ã‚‰ãªã‚‹ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ç”Ÿæˆã›ã‚ˆã€‚
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.70"></a>
<b>Exercise 3.70.</b>  <a name="%_idx_4006"></a><a name="%_idx_4008"></a>It would be nice to be able to generate streams in which the pairs
appear in some useful order, rather than in the order that results
from an <em>ad hoc</em> interleaving process.  We can use a technique
similar to the <tt>merge</tt> procedure of exercise <a href="#%_thm_3.56">3.56</a>, if we
define a way to say that one pair of integers is ``less than''
another.  One way to do this is to define a ``weighting function''
<em>W</em>(<em>i</em>,<em>j</em>) and stipulate that (<em>i</em><sub>1</sub>,<em>j</em><sub>1</sub>) is less than (<em>i</em><sub>2</sub>,<em>j</em><sub>2</sub>) if
<em>W</em>(<em>i</em><sub>1</sub>,<em>j</em><sub>1</sub>) &lt; <em>W</em>(<em>i</em><sub>2</sub>,<em>j</em><sub>2</sub>).  Write a procedure <tt>merge-weighted</tt>
that is like <tt>merge</tt>, except that <tt>merge-weighted</tt> takes an
additional argument <tt>weight</tt>, which is a procedure that computes
the weight of a pair, and is used to determine the order in which
elements should appear in the resulting merged stream.<a name="call_footnote_Temp_485" href="#footnote_Temp_485"><sup><small>69</small></sup></a>
Using this,
generalize <tt>pairs</tt> to a procedure <tt>weighted-pairs</tt> that
takes two streams, together with a procedure that computes a weighting
function, and generates the stream of pairs, ordered according to
weight.  Use your procedure to generate</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.70.</b> <em><ruby><rb>å ´å½“ãŸã‚Šçš„</rb><rp> (</rp><rt>ã‚¢ãƒ‰ãƒ›ãƒƒã‚¯</rt><rp>) </rp></ruby>ã«</em>æ··ãœã“ãœã«ã™ã‚‹å‡¦ç†ã®çµæœã‹ã‚‰ç”Ÿã˜ã‚‹é †åºã§ã¯ãªãã€ã‚€ã—ã‚ã€ä½•ã‚‰ã‹ã®æœ‰ç”¨ãªé †åºã§å¯¾ãŒç¾ã‚Œã‚‹ã‚ˆã†ãªã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ç”Ÿæˆã§ããŸã‚‰ã€ç´ æ™´ã‚‰ã—ã„ã“ã¨ã ã‚ã†ã€‚
ã‚‚ã—ã€æ•´æ•°åŒå£«ã®ã‚ã‚‹ä¸€å¯¾ãŒåˆ¥ã®å¯¾ã€Œã‚ˆã‚Šã‚‚å°ã•ã„ã€ã¨è¨€ã†ãŸã‚ã®æ–¹æ³•ã‚’å®šç¾©ã™ã‚Œã°ã€ç·´ç¿’å•é¡Œ<a href="#%_thm_3.56">3.56</a>ã® <tt>merge</tt> ã®æ‰‹ç¶šãã¨ä¼¼ãŸæŠ€æ³•ã‚’ä½¿ã†ã“ã¨ãŒå¯èƒ½ã§ã‚ã‚‹ã€‚
ã“ã‚Œã‚’è¡Œã†ãŸã‚ã®ä¸€ã¤ã®æ–¹æ³•ã¯ã€
<em class="en">W</em>(<em class="en">i</em>, <em class="en">j</em>) 
ã¨ã„ã†ã€Œé‡ã¿ã¥ã‘é–¢æ•°ã€ã‚’å®šç¾©ã—ã€ãã—ã¦ã€
<em class="en">W</em>(<em class="en">i</em><sub>1</sub>, <em class="en">j</em><sub>1</sub>) &lt; 
<em class="en">W</em>(<em class="en">i</em><sub>2</sub>, <em class="en">j</em><sub>2</sub>)
ã®å ´åˆã¯
(<em class="en">i</em><sub>1</sub>, <em class="en">j</em><sub>1</sub>)
ãŒ
(<em class="en">i</em><sub>2</sub>, <em class="en">j</em><sub>2</sub>)
ã‚ˆã‚Šã‚‚å°ã•ã„ã€ã¨è¦å®šã™ã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚
<tt>merge</tt> ã¨ä¼¼ãŸ <tt>merge-weighted</tt> ã¨ã„ã†æ‰‹ç¶šãâ€”â€”ãŸã ã—ã€<tt>merge-weighted</tt> ã¯ã€<tt>weight</tt> ã¨ã„ã†è¿½åŠ ã®å¼•æ•°ã‚’å–ã‚Šã€ã“ã‚Œã¯å¯¾ã®é‡ã¿ã‚’è¨ˆç®—ã™ã‚‹æ‰‹ç¶šãã§ã‚ã£ã¦ã€çµæœã¨ã—ã¦ç”Ÿã˜ã‚‹ä½µåˆã•ã‚ŒãŸã‚¹ãƒˆãƒªãƒ¼ãƒ ã«ãŠã„ã¦è¦ç´ ãŒå‡ºç¾ã™ã¹ãé †åºã‚’å®šã‚ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã‚‹ã€ã¨ã„ã†ç‚¹ãŒé•ã†â€”â€”ã‚’æ›¸ã‘<a href="#footnote_Temp_485"><sup><small>69</small></sup></a>ã€‚
ã“ã‚Œã‚’ç”¨ã„ã¦ã€<tt>pairs</tt> ã‚’ã€é‡ã¿ã¥ã‘é–¢æ•°ã‚’è¨ˆç®—ã™ã‚‹æ‰‹ç¶šãã¨ã¨ã‚‚ã«äºŒã¤ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ã¨ã‚Šã€é‡ã¿ã«ã—ãŸãŒã£ã¦é †åºã¥ã‘ã‚‰ã‚ŒãŸå¯¾ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ç”Ÿæˆã™ã‚‹ã‚ˆã†ãªã€<tt>weighted-pairs</tt> ã¨ã„ã†æ‰‹ç¶šãã¸ã¨ã€ä¸€èˆ¬åŒ–ã›ã‚ˆã€‚
å›ã®æ‰‹ç¶šãã‚’ä½¿ã£ã¦ã€ä»¥ä¸‹ã®ã‚‚ã®ã‚’ç”Ÿæˆã›ã‚ˆã€‚
</p>

<p class="orig" lang="en">
a. the stream of all pairs of positive integers (<em>i</em>,<em>j</em>) with <em>i</em> <u>&lt;</u>
<em>j</em> ordered according to the sum <em>i</em>  +  <em>j</em></p>

<p class="trans" lang="ja">
a. 
<span class="math"><em class="en">i</em> &le;  <em class="en">j</em>
</span>
ã§ã‚ã‚‹ã‚ˆã†ãªæ­£æ•´æ•°ã®å¯¾
<span class="math">(<em class="en">i</em>,<em class="en">j</em>)
</span>
ã™ã¹ã¦ã‹ã‚‰ãªã‚‹ã€
<span class="math"><em class="en">i</em>  +  <em class="en">j</em></span>
ã¨ã„ã†å’Œã«ã‚ˆã£ã¦é †åºã¥ã‘ã‚‰ã‚ŒãŸã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã€‚
</p>



<p class="orig" lang="en">b.  the stream of all pairs of positive integers (<em>i</em>,<em>j</em>) with <em>i</em> <u>&lt;</u>
<em>j</em>, where neither <em>i</em> nor <em>j</em> is divisible by 2, 3, or 5, and the
pairs are ordered according to the sum 2 <em>i</em>  +  3 <em>j</em>  +  5 <em>i</em> <em>j</em>.
</p>

<p class="trans" lang="ja">
b. 2ã€3ã€5ã®ã„ãšã‚Œã«ã‚ˆã£ã¦ã‚‚ã€<em class="en">i</em> ã‚‚ <em class="en">j</em> ã‚‚å‰²ã‚Šåˆ‡ã‚Œãªã„ã‚‚ã®ã¨ã—ã¦ã€
<span class="math"><em class="en">i</em> &le;  <em class="en">j</em>
</span>
ã§ã‚ã‚‹ã‚ˆã†ãªæ­£æ•´æ•°ã®å¯¾
<span class="math">(<em class="en">i</em>,<em class="en">j</em>)
</span>
ã™ã¹ã¦ã‹ã‚‰ãªã‚‹ã€
<span class="math">2<em class="en">i</em>  +  3<em class="en">j</em>  +  5<em class="en">ij</em></span>
ã¨ã„ã†å’Œã«ã‚ˆã£ã¦é †åºã¥ã‘ã‚‰ã‚ŒãŸã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.71"></a>
<b>Exercise 3.71.</b>  <a name="%_idx_4010"></a>Numbers that can be expressed as the sum of two cubes in more than one
way are sometimes called <em>Ramanujan numbers</em>, in honor of the
mathematician Srinivasa Ramanujan.<a name="call_footnote_Temp_487" href="#footnote_Temp_487"><sup><small>70</small></sup></a>
Ordered streams of pairs provide an elegant solution to the problem of
computing these numbers.  To find a number that can be written as the
sum of two cubes in two different ways, we need only generate the
stream of pairs of integers (<em>i</em>,<em>j</em>) weighted according to the sum <em>i</em><sup>3</sup>
 +  <em>j</em><sup>3</sup> (see exercise <a href="#%_thm_3.70">3.70</a>),
then search the stream for two consecutive pairs with the same
weight.  Write a procedure to generate the Ramanujan numbers.  The first
such number is 1,729.  What are the next five?

</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.71.</b> ä¸€ã¤ã‚ˆã‚Šã‚‚å¤šã„ã‚„ã‚Šæ–¹ã§äºŒã¤ã®ç«‹æ³•æ•°ã®å’Œã¨ã—ã¦è¡¨ã›ã‚‹æ•°ã¯ã€æ™‚ã¨ã—ã¦ã€ã‚·ãƒ¥ãƒªãƒ‹ãƒ´ã‚¡ãƒ¼ã‚µãƒ»ãƒ©ãƒãƒŒã‚¸ãƒ£ãƒ³ã«æ•¬æ„ã‚’è¡¨ã—ã¦ã€<em>ãƒ©ãƒãƒŒã‚¸ãƒ£ãƒ³æ•°</em>ã¨å‘¼ã°ã‚Œã‚‹<a href="#footnote_Temp_487"><sup><small>70</small></sup></a>ã€‚
å¯¾ã‹ã‚‰ãªã‚‹é †åºã¥ã‘ã‚‰ã‚ŒãŸã‚¹ãƒˆãƒªãƒ¼ãƒ ã¯ã€ã“ã‚Œã‚‰ã®æ•°ã‚’è¨ˆç®—ã™ã‚‹ã¨ã„ã†å•é¡Œã«å¯¾ã™ã‚‹ã€æ´—ç·´ã•ã‚ŒãŸè§£æ³•ã‚’ä¸ãˆã¦ãã‚Œã‚‹ã€‚
2é€šã‚Šã®ç•°ãªã‚‹æ–¹æ³•ã§2å€‹ã®ç«‹æ³•æ•°ã®å’Œã¨ã—ã¦æ›¸ã‘ã‚‹æ•°ã‚’è¦‹ã¤ã‘ã‚‹ãŸã‚ã«ã¯ã€ãŸã å˜ã«ã€
<span class="math"><em class="en">i</em><sup>3</sup> + <em class="en">j</em><sup>3</sup></span>
ã¨ã„ã†å’Œã«ã‚ˆã£ã¦é‡ã¿ã¥ã‘ã‚‰ã‚ŒãŸã€
<span class="math">(<em class="en">i</em>, <em class="en">j</em>)</span>
ã¨ã„ã†æ•´æ•°åŒå£«ã®å¯¾ã‹ã‚‰ãªã‚‹ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ç”Ÿæˆã—ã¦ (ç·´ç¿’å•é¡Œ<a href="#%_thm_3.70">3.70</a>ã‚’å‚ç…§)ã€ãã‚Œã‹ã‚‰ã€åŒã˜é‡ã¿ã‚’æŒã£ãŸé€£ç¶šã™ã‚‹2å€‹ã®å¯¾ã‚’ãã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«ãŠã„ã¦æ¢ç´¢ã™ã‚‹ã ã‘ã§ã‚ˆã„ã®ã ã€‚
ãƒ©ãƒãƒŒã‚¸ãƒ£ãƒ³æ•°ã‚’ç”Ÿæˆã™ã‚‹æ‰‹ç¶šãã‚’æ›¸ã‘ã€‚
æœ€åˆã®ãã†ã„ã†æ•°ã¯ã€1,729ã§ã‚ã‚‹ã€‚
æ¬¡ã®5å€‹ã¯ä½•ã ã‚ã†?
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.72"></a>
<b>Exercise 3.72.</b>  In a similar way to exercise <a href="#%_thm_3.71">3.71</a> generate
a stream of
all numbers that can be written as the sum of two squares in three
different ways (showing how they can be so written).
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.72.</b> ç•°ãªã‚‹3é€šã‚Šã®æ–¹æ³•ã§ã€2å€‹ã®å¹³æ–¹æ•°ã®å’Œã¨ã—ã¦æ›¸ã‘ã‚‹ã‚ˆã†ãªã€ã™ã¹ã¦ã®æ•°ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ã€ç·´ç¿’å•é¡Œ<a href="#%_thm_3.71">3.71</a>ã¨ä¼¼ãŸæ–¹æ³•ã§ç”Ÿæˆã›ã‚ˆ (ãã‚Œã‚‰ã®æ•°ã‚’ãã®ã‚ˆã†ã«æ›¸ã‘ã‚‹æ–¹æ³•ã‚’ç¤ºã—ãªãŒã‚‰)ã€‚
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_Temp_489"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_489">Streams as signals</a></h4>
<h4 class="trans" lang="ja">ä¿¡å·ã¨ã—ã¦ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ </h4>

<p class="orig" lang="en">
<a name="%_idx_4018"></a><a name="%_idx_4020"></a>
We began our discussion of streams by describing them as computational
analogs of the ``signals'' in signal-processing systems.  In fact, we
can use streams to model signal-processing systems in a very direct
way, representing the values of a signal at successive time intervals
as consecutive elements of a stream.  For instance, we can implement
an <a name="%_idx_4022"></a><em>integrator</em> or <em>summer</em> that, for an input stream
<em>x</em> = (<em>x</em><sub><em>i</em></sub>), an initial value <em>C</em>, and a small increment <em>d</em><em>t</em>,
accumulates the sum
</p>

<p class="trans" lang="ja">
ä¿¡å·å‡¦ç†ã‚·ã‚¹ãƒ†ãƒ ã«ãŠã‘ã‚‹ã€Œä¿¡å·ã€ã®ã€è¨ˆç®—æ©Ÿä¸Šã®ç›¸ä¼¼ç‰©ã¨ã—ã¦ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’èª¬æ˜ã™ã‚‹ã“ã¨ã‹ã‚‰ã€ç§ãŸã¡ã¯ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«ã¤ã„ã¦ã®è­°è«–ã‚’å§‹ã‚ãŸã€‚
é€£ç¶šã™ã‚‹æ™‚é–“åŒºé–“ã§ã®ä¿¡å·ã®å€¤ã‚’ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã§ã®é€£ç¶šã™ã‚‹è¦ç´ ã¨ã—ã¦è¡¨ç¾ã™ã‚Œã°ã€å®Ÿéš›ã®ã¨ã“ã‚ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ç”¨ã„ã¦ä¿¡å·å‡¦ç†ã‚·ã‚¹ãƒ†ãƒ ã‚’éå¸¸ã«ç›´æˆªçš„ãªæ–¹æ³•ã§ãƒ¢ãƒ‡ãƒ«åŒ–ã§ãã‚‹ã€‚
ãŸã¨ãˆã°ã€
<span class="math"><em class="en">x</em> = (<em class="en">x<sub>i</sub></em>) 
</span>ã¨ã„ã†å…¥åŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¨ã€
<em class="en">C</em>
ã¨ã„ã†åˆæœŸå€¤ã¨ã€
<em class="en">dt</em>
ã¨ã„ã†å°ã•ãªå¢—åˆ†ã«å¯¾ã—ã¦ã€ä»¥ä¸‹ã®å’Œã‚’ç´¯ç®—ã™ã‚‹ã‚ˆã†ãªã€<em>ç©åˆ†å™¨</em>ãªã„ã—<em>ç·å’Œå™¨</em>ã‚’å®Ÿè£…ã§ãã¦ã€
</p>

<figure><img src="ch3-Z-G-48.gif" border="0"></figure>


<p class="orig" lang="en">
and returns the stream of values <em>S</em> = (<em>S</em><sub><em>i</em></sub>).  The following <tt>integral</tt>
procedure is reminiscent of the ``implicit style'' definition of the
stream of integers (section <a href="#%_sec_3.5.2">3.5.2</a>):</p>

<p class="trans" lang="ja">
ã“ã‚Œã¯ã€<span class="math"><em class="en">S</em> = (<em class="en">S<sub>i</sub></em>)</span>
ã¨ã„ã†å€¤ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’è¿”ã™ã€‚
ä»¥ä¸‹ã® <tt>integral</tt> ã¨ã„ã†æ‰‹ç¶šãã¯ã€æ•´æ•°ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®ã€Œæš—é»™çš„æ§˜å¼ã€ã®å®šç¾© (<a href="#%_sec_3.5.2">3.5.2</a>ç¯€) ã‚’å½·å½¿ã¨ã•ã›ã‚‹ã€‚
</p>


<p class="lisp"><a name="%_idx_4024"></a>(define (integral integrand initial-value dt)
  (define int
    (cons-stream initial-value
                 (add-streams (scale-stream integrand dt)
                              int)))
  int)
</p>

<a name="%_fig_3.32"></a>
<figure>
<img src="ch3-Z-G-49.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.32:</b>  The <tt>integral</tt> procedure viewed as a
signal-processing system.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³3.32:</b> ä¿¡å·å‡¦ç†ã‚·ã‚¹ãƒ†ãƒ ã¨ã—ã¦è¦‹ãŸã€<tt>integral</tt> ã®æ‰‹ç¶šã</figcaption>
</figure>

<p class="orig" lang="en">
Figure <a href="#%_fig_3.32">3.32</a> is a picture of a signal-processing system that
corresponds to the <tt>integral</tt> procedure.  The input stream is
scaled by <em>d</em><em>t</em> and passed through an adder, whose output is passed
back through the same adder.  The self-reference in the definition of
<tt>int</tt> is reflected in the figure by the feedback loop that
connects the output of the adder to one of the inputs.</p>

<p class="trans" lang="ja">
å›³<a href="#%_fig_3.32">3.32</a>ã¯ã€<tt>integral</tt> ã¨ã„ã†æ‰‹ç¶šãã«å¯¾å¿œã™ã‚‹ä¿¡å·å‡¦ç†ã‚·ã‚¹ãƒ†ãƒ ã®çµµã§ã‚ã‚‹ã€‚
å…¥åŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¯ã€<em class="en">dt</em>å€ã•ã‚Œã¦ã€åŠ ç®—å™¨â€”â€”ãã®å‡ºåŠ›ã¯ã€åŒã˜åŠ ç®—å™¨ã‚’é€šã£ã¦æˆ»ã•ã‚Œã‚‹â€”â€”ã‚’é€šã£ã¦æ¸¡ã•ã‚Œã‚‹ã€‚
<tt>int</tt> ã®å®šç¾©ã«ãŠã‘ã‚‹è‡ªå·±å‚ç…§ãŒã€åŠ ç®—å™¨ã®å‡ºåŠ›ã‚’å…¥åŠ›ã®ã†ã¡ã®ä¸€ã¤ã«ã¤ãªããƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãƒ»ãƒ«ãƒ¼ãƒ—ã«ã‚ˆã‚Šã€å›³ã«åæ˜ ã•ã‚Œã¦ã„ã‚‹ã€‚
</p>


<p class="orig" lang="en"><a name="%_thm_3.73"></a>
<b>Exercise 3.73.</b>  <a name="%_fig_3.33"></a></p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.73.</b> 
</p>

<figure>
<div style="text-align: right">
<img src="ch3-Z-G-50.gif" border="0">&nbsp;&nbsp;
<em>v</em>  =  <em>v</em><sub>0</sub>  +  (1/<em>C</em>)<img src="book-Z-G-D-19.gif" border="0"><sub>0</sub><sup><em>t</em></sup><em>i</em> <em>d</em><em>t</em>  +  <em>R</em> <em>i</em>
&nbsp;&nbsp;
</div>
<img src="ch3-Z-G-51.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.33:</b>  An RC circuit and the associated signal-flow diagram.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³3.33:</b> RCå›è·¯ã¨ãã‚Œã«é–¢é€£ã¥ã‘ã‚‰ã‚ŒãŸä¿¡å·æµã‚Œå›³</figcaption>
</figure>

<p class="orig" lang="en">
<a name="%_idx_4028"></a><a name="%_idx_4030"></a><a name="%_idx_4032"></a>We can model electrical circuits using streams to represent the values
of currents or voltages at a sequence of times.  For instance, suppose
we have an <em>RC circuit</em> consisting of a resistor of resistance <em>R</em>
and a capacitor of capacitance <em>C</em> in series.  The voltage response
<em>v</em> of the circuit to an injected current <em>i</em> is determined by the
formula in figure <a href="#%_fig_3.33">3.33</a>, whose structure is shown by the accompanying
signal-flow diagram.</p>

<p class="trans" lang="ja">
ä¸€é€£ã®æ™‚ç‚¹ã«ãŠã‘ã‚‹é›»æµã¾ãŸã¯é›»åœ§ã®å€¤ã‚’è¡¨ã™ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½¿ã£ã¦ã€é›»æ°—å›è·¯ã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã§ãã‚‹ã€‚
ãŸã¨ãˆã°ã€ç›´åˆ—ã«ã¤ãªãŒã£ã¦ã„ã‚‹ã€<em class="en" >R</em> ã¨ã„ã†æŠµæŠ—å€¤ã®æŠµæŠ—å™¨ã¨ã€<em class="en">C</em> ã¨ã„ã†å®¹é‡ã®ã‚­ãƒ£ãƒ‘ã‚·ã‚¿ã¨ã‹ã‚‰ãªã‚‹ã€<em>RCå›è·¯</em>ãŒã‚ã‚‹ã‚‚ã®ã¨ã—ã‚ˆã†ã€‚
<em class="en">i</em> ã¨ã„ã†æŠ•å…¥é›»æµã«å¯¾ã™ã‚‹ã€ã“ã®å›è·¯ã® <em class="en">v</em> ã¨ã„ã†é›»åœ§å¿œç­”ã¯ã€å›³<a href="#%_fig_3.33">3.33</a>ã®å…¬å¼â€”â€”ãã®æ§‹é€ ã¯ã€ä»˜éšã—ã¦ã„ã‚‹ä¿¡å·æµã‚Œå›³ã«ã‚ˆã£ã¦ç¤ºã•ã‚Œã¦ã„ã‚‹â€”â€”ã«ã‚ˆã‚Šã€æ±ºå®šã¥ã‘ã‚‰ã‚Œã‚‹ã€‚
</p>

<p class="orig" lang="en">
Write a procedure <tt>RC</tt> that models this circuit.  <tt>RC</tt> should
take as inputs the values of <em>R</em>, <em>C</em>, and <em>d</em><em>t</em> and should return a
procedure that takes as inputs a stream representing the current <em>i</em>
and an initial value for the capacitor voltage <em>v</em><sub>0</sub> and produces as
output the stream of voltages <em>v</em>.  For example, you should be able to
use <tt>RC</tt> to model an RC circuit with <em>R</em>  =  5 ohms, <em>C</em>  =  1 farad,
and a 0.5-second time step by evaluating <tt>(define RC1 (RC 5 1
0.5))</tt>.  This defines <tt>RC1</tt> as a procedure that takes a stream
representing the time sequence of currents and an initial capacitor
voltage and produces the output stream of voltages.
</p>

<p class="trans" lang="ja">
ã“ã®å›è·¯ã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã™ã‚‹ã€<tt>RC</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’æ›¸ã‘ã€‚
<tt>RC</tt> ã¯ã€å…¥åŠ›ã¨ã—ã¦ã€<em class="en">R</em> ã¨ <em class="en">C</em> ã¨ <em class="en">dt</em> ã®å€¤ã‚’ã¨ã‚‹ã¹ãã§ã‚ã‚‹ã€‚ãã—ã¦ã€<em class="en">i</em> ã¨ã„ã†é›»æµã‚’è¡¨ã™ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¨ <em class="en">v</em><sub>0</sub> ã¨ã„ã†ã‚­ãƒ£ãƒ‘ã‚·ã‚¿é›»åœ§ã®åˆæœŸå€¤ã¨ã‚’å…¥åŠ›ã¨ã—ã¦ã¨ã£ã¦ã€å‡ºåŠ›ã¨ã—ã¦ã¯ <em class="en">v</em> ã¨ã„ã†é›»åœ§ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½œã‚Šå‡ºã™ã‚ˆã†ãªæ‰‹ç¶šãã‚’ã€<tt>RC</tt> ã¯ã€è¿”ã™ã¹ãã§ã‚ã‚‹ã€‚
ãŸã¨ãˆã°ã€<tt>RC</tt> ã‚’ä½¿ã£ã¦ã€<tt>(define RC1 (RC 5 1 0.5))</tt>ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€<em class="en">R</em> ãŒ5ã‚ªãƒ¼ãƒ ã§ã€<em class="en">C</em> ãŒ1ãƒ•ã‚¡ãƒ©ãƒƒãƒ‰ã§ã€æ™‚é–“ã®åˆ»ã¿ãŒ0.5ç§’ã®RCå›è·¯ã‚’ã€ãƒ¢ãƒ‡ãƒ«åŒ–ã§ãã‚‹ã¯ãšã§ã‚ã‚‹ã€‚
ã“ã‚Œã¯ã€<tt>RC1</tt> ã‚’ã€é›»æµã®æ™‚ç³»åˆ—ã‚’è¡¨ã™ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¨åˆæœŸã‚­ãƒ£ãƒ‘ã‚·ã‚¿é›»åœ§ã¨ã‚’ã¨ã£ã¦é›»åœ§ã®å‡ºåŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½œã‚Šå‡ºã™ã‚ˆã†ãªæ‰‹ç¶šãã¨ã—ã¦ã€å®šç¾©ã™ã‚‹ã€‚
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.74"></a>
<b>Exercise 3.74.</b>  <a name="%_idx_4034"></a><a name="%_idx_4036"></a>Alyssa P. Hacker is designing a system to process signals coming from
physical sensors.  One important feature she wishes to produce is a
signal that describes the <em>zero crossings</em> of the input signal.
That is, the resulting signal should be  + 1 whenever the input signal
changes from negative to positive,  - 1 whenever the input signal
changes from positive to negative, and 0 otherwise.  (Assume that the
sign of a 0 input is positive.)  For example, a typical input signal
with its associated zero-crossing signal would be
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.74.</b> ã‚¢ãƒªãƒƒã‚µãƒ»Pãƒ»ãƒãƒƒã‚«ã¯ã€ç‰©ç†ã‚»ãƒ³ã‚µã‹ã‚‰ã‚„ã£ã¦æ¥ã‚‹ä¿¡å·ã‚’å‡¦ç†ã™ã‚‹ã‚·ã‚¹ãƒ†ãƒ ã‚’è¨­è¨ˆã—ã¦ã„ã‚‹ã¨ã“ã‚ã ã€‚
ã‚¢ãƒªãƒƒã‚µãŒä½œã‚Šå‡ºã—ãŸã„ã¨æœ›ã‚“ã§ã„ã‚‹ä¸€ã¤ã®é‡è¦ãªç‰¹å¾´ã¯ã€å…¥åŠ›ä¿¡å·ã®<em>ã‚¼ãƒ­äº¤å·®</em>ã‚’è¨˜è¿°ã™ã‚‹ä¿¡å·ã§ã‚ã‚‹ã€‚
ã¤ã¾ã‚Šã€çµæœã¨ã—ã¦ç”Ÿã˜ã‚‹ä¿¡å·ã¯ã€å…¥åŠ›ä¿¡å·ãŒè² ã‹ã‚‰æ­£ã¸ã¨å¤‰åŒ–ã™ã‚‹ã¨ãã¯å¿…ãš +1 ã¨ãªã‚‹ã¹ãã§ã‚ã‚Šã€å…¥åŠ›ä¿¡å·ãŒæ­£ã‹ã‚‰è² ã¸ã¨å¤‰åŒ–ã™ã‚‹ã¨ãã¯å¿…ãš &minus;1 ã¨ãªã‚‹ã¹ãã§ã‚ã‚Šã€ãã®ä»–ã®å ´åˆã¯ 0 ã¨ãªã‚‹ã¹ãã‚‚ã®ã§ã‚ã‚‹ã€‚
(0 ã¨ã„ã†å…¥åŠ›ã®ç¬¦å·ã¯æ­£ã§ã‚ã‚‹ã‚‚ã®ã¨ã›ã‚ˆã€‚)
ãŸã¨ãˆã°ã€é–¢é€£ã—ãŸã‚¼ãƒ­äº¤å·®ä¿¡å·ã‚’ä¼´ã£ãŸå…¸å‹çš„å…¥åŠ›ä¿¡å·ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã§ã‚ã‚‹ã ã‚ã†ã€‚
</p>

<p class="lisp"><tt>...</tt>1  2  1.5  1  0.5  -0.1  -2  -3  -2  -0.5  0.2  3  4 <tt>...</tt>
<tt>...</tt>0  0    0  0    0    -1   0   0   0     0    1  0  0 <tt>...</tt></p>


<p class="orig" lang="en">
In Alyssa's system, the signal from the sensor is represented as a
stream <tt>sense-data</tt> and the stream <tt>zero-crossings</tt> is
the corresponding stream of zero crossings.  Alyssa first writes a
procedure <tt>sign-change-detector</tt> that takes two values as
arguments and compares the signs of the values to produce an
appropriate 0, 1, or  - 1.  She then constructs her zero-crossing
stream as follows:</p>

<p class="trans" lang="ja">
ã‚¢ãƒªãƒƒã‚µã®ã‚·ã‚¹ãƒ†ãƒ ã§ã¯ã€ã‚»ãƒ³ã‚µã‹ã‚‰ã®ä¿¡å·ãŒ <tt>sense-data</tt> ã¨ã„ã†ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¨ã—ã¦è¡¨ã•ã‚Œã€<tt>zero-crossings</tt> ã¨ã„ã†ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¯ã€ãã‚Œã«å¯¾å¿œã™ã‚‹ã€ã‚¼ãƒ­äº¤å·®ã‹ã‚‰ãªã‚‹ã‚¹ãƒˆãƒªãƒ¼ãƒ ã§ã‚ã‚‹ã€‚
ã‚¢ãƒªãƒƒã‚µã¯ã¾ãšã€äºŒã¤ã®å€¤ã‚’å¼•æ•°ã¨ã—ã¦ã¨ã‚Šã€ãã‚Œã‚‰ã®å€¤ã®ç¬¦å·åŒå£«ã‚’æ¯”è¼ƒã—ã¦é©åˆ‡ãª 0 ã‹ 1 ã‹ &minus;1 ã‚’ä½œã‚Šå‡ºã™ã‚ˆã†ãªã€<tt>sign-change-detector</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’æ›¸ãã€‚
ãã‚Œã‹ã‚‰å½¼å¥³ã¯ã€è‡ªåˆ†ã®ã‚¼ãƒ­äº¤å·®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä»¥ä¸‹ã®ã‚ˆã†ã«æ§‹ç¯‰ã™ã‚‹ã€‚
</p>

<p class="lisp">(define (make-zero-crossings input-stream last-value)
  (cons-stream
   (sign-change-detector (stream-car input-stream) last-value)
   (make-zero-crossings (stream-cdr input-stream)
                        (stream-car input-stream))))

(define zero-crossings (make-zero-crossings sense-data 0))
</p>

<p class="orig" lang="en">
Alyssa's boss, Eva Lu Ator, walks by and suggests that this program is
approximately equivalent to the following one, which
uses the generalized version
of <tt>stream-map</tt> from exercise <a href="#%_thm_3.50">3.50</a>:</p>

<p class="trans" lang="ja">
ã‚¢ãƒªãƒƒã‚µã®ä¸Šå¸ã€ã™ãªã‚ã¡ã‚¨ãƒ´ã‚¡ãƒ»ãƒªãƒ¥ãƒ»ã‚¨ã‚¤ã‚¿ãŒã€é€šã‚Šã™ãŒã‚Šã€ãã—ã¦ã€ã“ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ä»¥ä¸‹ã®ã‚‚ã®â€”â€”ç·´ç¿’å•é¡Œ<a href="#%_thm_3.50">3.50</a>ã® <tt>stream-map</tt> ã®ä¸€èˆ¬åŒ–ã•ã‚ŒãŸãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ä½¿ã†â€”â€”ã¨ãŠãŠã‚ˆãç­‰ä¾¡ã ã€ã¨ç¤ºå”†ã™ã‚‹ã€‚
</p>

<p class="lisp">(define zero-crossings
  (stream-map sign-change-detector sense-data &lt;<em>expression</em>&gt;))
</p>


<p class="orig" lang="en">
Complete the program by supplying the indicated &lt;<em>expression</em>&gt;.
</p>

<p class="trans" lang="ja">
ç¤ºã•ã‚ŒãŸ &lt;<em class="en">expression</em>&gt; ã‚’åŸ‹ã‚ã‚‹ã“ã¨ã§ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’å®Œæˆã•ã›ã‚ˆã€‚
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.75"></a>
<b>Exercise 3.75.</b>  <a name="%_idx_4038"></a><a name="%_idx_4040"></a><a name="%_idx_4042"></a><a name="%_idx_4044"></a>Unfortunately, Alyssa's zero-crossing detector in
exercise <a href="#%_thm_3.74">3.74</a> proves to be insufficient, because the
noisy signal from the sensor leads to spurious zero crossings.  Lem E.
Tweakit, a hardware specialist, suggests that Alyssa smooth the signal
to filter out the noise before extracting the zero crossings.  Alyssa
takes his advice and decides to extract the zero crossings from the
signal constructed by averaging each value of the sense data with the
previous value.  She explains the problem to her assistant, Louis
Reasoner, who attempts to implement the idea, altering Alyssa's program as
follows:</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.75.</b> ã‚ã„ã«ãã€ç·´ç¿’å•é¡Œ<a href="#%_thm_3.74">3.74</a>ã®ã‚¢ãƒªãƒƒã‚µã®ã‚¼ãƒ­äº¤å·®æ¤œå‡ºå™¨ã¯ã€ã‚»ãƒ³ã‚µã‹ã‚‰ã®é›‘éŸ³ã ã‚‰ã‘ã®ä¿¡å·ãŒå½ç‰©ã®ã‚¼ãƒ­äº¤å·®ã‚’æ‹›ããŸã‚ã€ä¸ååˆ†ã ã€ã¨ã„ã†ã“ã¨ãŒåˆ¤æ˜ã—ãŸã€‚
ãƒ¬ãƒ ãƒ»Eãƒ»ãƒˆã‚¥ã‚¦ã‚£ãƒ¼ã‚­ãƒƒãƒˆâ€”â€”ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢å°‚é–€å®¶ã§ã‚ã‚‹â€”â€”ã¯ã€ã‚¢ãƒªãƒƒã‚µãŒã€ã‚¼ãƒ­äº¤å·®ã‚’æŠ½å‡ºã™ã‚‹å‰ã«ä¿¡å·ã‚’å¹³æ»‘åŒ–ã—ã¦é›‘éŸ³ã‚’ãƒ•ã‚£ãƒ«ã‚¿ã§é™¤å»ã—ãŸã‚‰ã‚ˆã„ã€ã¨ææ¡ˆã—ãŸã€‚
ã‚¢ãƒªãƒƒã‚µã¯å½¼ã®åŠ©è¨€ã‚’å–ã‚Šä¸Šã’ã¦ã€æ„ŸçŸ¥ãƒ‡ãƒ¼ã‚¿ã®ãã‚Œãã‚Œã®å€¤ã‚’å‰ã®å€¤ã¨å¹³å‡åŒ–ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦æ§‹ç¯‰ã—ãŸä¿¡å·ã‹ã‚‰ã€ã‚¼ãƒ­äº¤å·®ã‚’æŠ½å‡ºã™ã‚‹ã“ã¨ã«æ±ºã‚ã‚‹ã€‚
ã‚¢ãƒªãƒƒã‚µã¯åŠ©æ‰‹ã®ãƒ«ã‚¤ã‚¹ãƒ»ãƒªãƒ¼ã‚ºãƒŠã«å•é¡Œã‚’èª¬æ˜ã—ã€ãƒ«ã‚¤ã‚¹ã¯ãã®è€ƒãˆã‚’å®Ÿè£…ã—ã‚ˆã†ã¨ã—ã¦ã€ã‚¢ãƒªãƒƒã‚µã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ä»¥ä¸‹ã®ã‚ˆã†ã«å¤‰ãˆã‚‹ã€‚
</p>


<p class="lisp">(define (make-zero-crossings input-stream last-value)
  (let ((avpt (/ (+ (stream-car input-stream) last-value) 2)))
    (cons-stream (sign-change-detector avpt last-value)
                 (make-zero-crossings (stream-cdr input-stream)
                                      avpt))))
</p>


<p class="orig" lang="en">
This does not correctly implement Alyssa's plan.
Find the bug that Louis has installed
and fix it without changing the structure of the program.  (Hint: You
will need to increase the number of arguments to <tt>make-zero-crossings</tt>.)
</p>

<p class="trans" lang="ja">
ã“ã‚Œã¯ã€ã‚¢ãƒªãƒƒã‚µã®è¨ˆç”»ã‚’æ­£ã—ãå®Ÿè£…ã—ã¦ã¯ã„ãªã„ã€‚
ãƒ«ã‚¤ã‚¹ãŒä»•è¾¼ã‚“ã§ã—ã¾ã£ãŸãƒã‚°ã‚’è¦‹ã¤ã‘ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®æ§‹é€ ã‚’å¤‰ãˆãªã„ã§ã€ãã®ãƒã‚°ã‚’ä¿®æ­£ã›ã‚ˆã€‚
(ãƒ’ãƒ³ãƒˆ: <tt>make-zero-crossings</tt> ã«å¯¾ã™ã‚‹å¼•æ•°ã®å€‹æ•°ã‚’å¢—ã‚„ã™å¿…è¦ãŒã‚ã‚‹ã ã‚ã†ã€‚)
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.76"></a>
<b>Exercise 3.76.</b>  <a name="%_idx_4046"></a><a name="%_idx_4048"></a><a name="%_idx_4050"></a><a name="%_idx_4052"></a>Eva Lu Ator has a criticism of Louis's approach in
exercise <a href="#%_thm_3.75">3.75</a>.  The program he wrote is not modular,
because it intermixes the operation of smoothing with the
zero-crossing extraction.  For example, the extractor should not have
to be changed if Alyssa finds a better way to condition her input
signal.  Help Louis by writing a procedure <tt>smooth</tt> that takes a
stream as input and produces a stream in which each element is the
average of two successive input stream elements.  Then use <tt>smooth</tt> as a component to implement the zero-crossing detector in a
more modular style.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.76.</b> ã‚¨ãƒ´ã‚¡ãƒ»ãƒªãƒ¥ãƒ»ã‚¨ã‚¤ã‚¿ã¯ã€ç·´ç¿’å•é¡Œ<a href="#%_thm_3.75">3.75</a>ã§ã®ãƒ«ã‚¤ã‚¹ã®æ‰‹æ³•ã«æ‰¹åˆ¤çš„ã ã€‚
ãƒ«ã‚¤ã‚¹ãŒæ›¸ã„ãŸãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€å¹³æ»‘åŒ–ã®æ“ä½œã‚’ã‚¼ãƒ­äº¤å·®ã®æŠ½å‡ºã¨æ··ãœåˆã‚ã›ã¦ã„ã‚‹ã®ã§ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ€§ãŒãªã„ã€‚
ãŸã¨ãˆã°ã€å…¥åŠ›ä¿¡å·ã‚’èª¿æ•´ã™ã‚‹ãŸã‚ã®ã‚ˆã‚Šè‰¯ã„æ–¹æ³•ã‚’ã‚¢ãƒªãƒƒã‚µãŒè¦‹ã¤ã‘ãŸ<!--ã¨ãã«ã€--><!--æŠ½å‡ºå™¨ã‚’å¤‰ãˆã­ã°ãªã‚‰ãªã„ã®ã¯é§„ç›®ã ã€‚--><!--æŠ½å‡ºå™¨ã‚’å¤‰ãˆã‚‹å¿…è¦ãŒã‚ã‚‹ã¹ãã§ã¯ãªã„ã€‚--><!--æŠ½å‡ºå™¨ã‚’å¤‰ãˆã‚‹å¿…è¦ã¯ã€ãªãã¦ã—ã‹ã‚‹ã¹ãã‚‚ã®ã ã€‚--><!--ã¨ã—ã¦ã‚‚ã€-->å ´åˆã€æŠ½å‡ºå™¨ã‚’å¤‰æ›´ã™ã‚‹å¿…è¦ã¯ãªã„ã¯ãšã ã€‚
ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å…¥åŠ›ã¨ã—ã¦ã¨ã£ã¦ã€å„è¦ç´ ãŒäºŒã¤ã®é€£ç¶šã™ã‚‹å…¥åŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ è¦ç´ ã®å¹³å‡ã§ã‚ã‚‹ã‚ˆã†ãªã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½œã‚Šã ã™ <tt>smooth</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’æ›¸ãã“ã¨ã«ã‚ˆã‚Šã€ãƒ«ã‚¤ã‚¹ã‚’æ‰‹åŠ©ã‘ã›ã‚ˆã€‚
ãã—ã¦ã€ã‚ˆã‚Šãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ€§ã®ã‚ã‚‹æ§˜å¼ã§ã‚¼ãƒ­äº¤å·®æ¤œå‡ºå™¨ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã®æ§‹æˆè¦ç´ ã¨ã—ã¦ã€<tt>smooth</tt> ã‚’ä½¿ãˆã€‚
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_3.5.4"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_3.5.4">3.5.4  Streams and Delayed Evaluation</a></h3>
<h3 class="trans" lang="ja">3.5.4 ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¨é…å»¶è©•ä¾¡</h3>

<p class="orig" lang="en">
<a name="%_idx_4054"></a><a name="%_idx_4056"></a>
The <tt>integral</tt> procedure at the end of the preceding section shows
how we can use streams to model signal-processing systems that contain
<a name="%_idx_4058"></a>feedback loops.  The feedback loop for the adder shown in
figure <a href="#%_fig_3.32">3.32</a> is modeled by the fact that <tt>integral</tt>'s
<a name="%_idx_4060"></a>internal stream <tt>int</tt> is defined in terms of itself:</p>

<p class="trans" lang="ja">
å‰ã®ç¯€ã®æœ€å¾Œã«ã‚ã‚‹ <tt>integral</tt> ã¨ã„ã†æ‰‹ç¶šãã¯ã€ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãƒ«ãƒ¼ãƒ—ã‚’å«ã‚€ä¿¡å·å‡¦ç†ã‚·ã‚¹ãƒ†ãƒ ã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã™ã‚‹ãŸã‚ã«ç§ãŸã¡ãŒã©ã®ã‚ˆã†ã«ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’åˆ©ç”¨ã§ãã‚‹ã‹ã€ã¨ã„ã†ã“ã¨ã‚’ç¤ºã—ã¦ã„ã‚‹ã€‚
å›³<a href="#%_fig_3.32">3.32</a>ã«ç¤ºã—ãŸåŠ ç®—ã®ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãƒ«ãƒ¼ãƒ—ã¯ã€<tt>integral</tt> ã® <tt>int</tt> ã¨ã„ã†å†…éƒ¨ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒãã‚Œè‡ªä½“ã‚’ä½¿ã£ã¦å®šç¾©ã•ã‚Œã‚‹ã€ã¨ã„ã†äº‹å®Ÿã«ã‚ˆã‚Šã€ãƒ¢ãƒ‡ãƒ«åŒ–ã•ã‚Œã¦ã„ã‚‹ã€‚
</p>


<p class="lisp">(define int
  (cons-stream initial-value
               (add-streams (scale-stream integrand dt)
                            int)))
</p>

<p class="orig" lang="en">
The interpreter's ability to deal with such an implicit definition
depends on the <tt>delay</tt> that is incorporated into <tt>cons-stream</tt>.  Without this <tt>delay</tt>, the interpreter could not
construct <tt>int</tt> before evaluating both arguments to <tt>cons-stream</tt>, which would require that <tt>int</tt> already be defined.
In general, <tt>delay</tt> is crucial for using streams to model
signal-processing systems that contain loops.  Without <tt>delay</tt>,
our models would have to be formulated so that the inputs to any
signal-processing component would be fully evaluated before the output
could be produced.  This would outlaw loops.</p>

<p class="trans" lang="ja">
ã“ã†ã„ã†æš—é»™ã®å®šç¾©ã‚’æ‰±ã†ã“ã¨ãŒã§ãã‚‹ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã®èƒ½åŠ›ã¯ã€<tt>cons-stream</tt> ã®ä¸­ã«çµ„ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹ <tt>delay</tt> ã«ä¾å­˜ã—ã¦ã„ã‚‹ã€‚
ã“ã® <tt>delay</tt> ãŒãªã‘ã‚Œã°ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã¯ã€<tt>cons-stream</tt> ã¸ã®ä¸¡æ–¹ã®å¼•æ•°ã‚’è©•ä¾¡ã™ã‚‹â€”â€”ã“ã‚Œã¯ã€<tt>int</tt> ãŒæ—¢ã«å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’è¦è«‹ã™ã‚‹ã ã‚ã† â€”â€”ã¾ã§ã¯ã€<tt>int</tt> ã‚’æ§‹ç¯‰ã™ã‚‹ã“ã¨ãŒã§ããªã‹ã£ãŸã ã‚ã†ã€‚
ä¸€èˆ¬ã«ã€ãƒ«ãƒ¼ãƒ—ã‚’å«ã‚€ä¿¡å·å‡¦ç†ã‚·ã‚¹ãƒ†ãƒ ã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã™ã‚‹ãŸã‚ã«ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½¿ã†ã®ã«ã¯ã€<tt>delay</tt> ãŒå¿…è¦ä¸å¯æ¬ ã ã€‚
ã‚‚ã— <tt>delay</tt> ãŒãªã‹ã£ãŸã‚‰ã€ã„ã‹ãªã‚‹ä¿¡å·å‡¦ç†ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã¸ã®å…¥åŠ›ã‚‚ã€å‡ºåŠ›ã‚’ä½œã‚Šå‡ºã›ã‚‹ã‚ˆã†ã«ãªã‚‹å‰ã«å®Œå…¨ã«è©•ä¾¡ã•ã‚Œã¦ã„ã‚‹ã€ã¨ã„ã†ãµã†ã«ã€ç§ãŸã¡ã®ãƒ¢ãƒ‡ãƒ«ã‚’å®šå¼åŒ–ã›ã­ã°ãªã‚‰ãªã‹ã£ãŸã ã‚ã†ã€‚
ã“ã‚Œã§ã¯ã€ãƒ«ãƒ¼ãƒ—ã‚’éåˆæ³•ãªã‚‚ã®ã¨ã—ã¦ç¦æ­¢ã™ã‚‹ã“ã¨ã«ãªã‚‹ã ã‚ã†ã€‚
</p>

<p class="orig" lang="en">
Unfortunately, stream models of systems with loops
may require uses of <tt>delay</tt> beyond the ``hidden'' <tt>delay</tt>
supplied by <tt>cons-stream</tt>.  For instance,
figure <a href="#%_fig_3.34">3.34</a> shows a signal-processing system for
solving the <a name="%_idx_4062"></a>differential equation <em>d</em><em>y</em>/<em>d</em><em>t</em> = <em>f</em>(<em>y</em>) where <em>f</em> is a given
function.  The figure shows a mapping component, which
applies <em>f</em> to its input signal, linked in a feedback loop to an
integrator in a manner very similar to that of the analog computer
circuits that are actually used to solve such equations.</p>

<p class="trans" lang="ja">
ã‚ã„ã«ãã€ãƒ«ãƒ¼ãƒ—ã®ã‚ã‚‹ã‚·ã‚¹ãƒ†ãƒ ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ãƒ»ãƒ¢ãƒ‡ãƒ«ã¯ã€ <tt>cons-stream</tt> ã«ã‚ˆã‚Šæä¾›ã•ã‚Œã‚‹ã€Œéš ã‚ŒãŸã€<tt>delay</tt> ã‚’è¶ŠãˆãŸ <tt>delay</tt> ã®ä½¿ç”¨ã‚’å¿…è¦ã¨ã™ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚
ãŸã¨ãˆã°ã€å›³<a href="#%_fig_3.34">3.34</a>ã¯ã€
<span class="math"><em class="en">dy</em>/<em class="en">dt</em> = <em class="en">f</em>(<em class="en">y</em>)</span>
ã¨ã„ã†å¾®åˆ†æ–¹ç¨‹å¼â€”â€”ãŸã ã— <em class="en">f</em> ã¯ä¸ãˆã‚‰ã‚ŒãŸé–¢æ•°ã§ã‚ã‚‹â€”â€”ã‚’è§£ããŸã‚ã®ä¿¡å·å‡¦ç†ã‚·ã‚¹ãƒ†ãƒ ã‚’ç¤ºã—ã¦ã„ã‚‹ã€‚
ã“ã†ã—ãŸæ–¹ç¨‹å¼ã‚’è§£ããŸã‚ã«å®Ÿéš›ã«ä½¿ã‚ã‚Œã‚‹ã‚¢ãƒŠãƒ­ã‚°ãƒ»ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿å›è·¯ã§ã®ã‚„ã‚Šæ–¹ã¨éå¸¸ã«ä¼¼ãŸã‚„ã‚Šæ–¹ã§ã€ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãƒ«ãƒ¼ãƒ—ã«ãŠã„ã¦ç©åˆ†å™¨ã«ã¤ãªãŒã‚ŒãŸãƒãƒƒãƒ”ãƒ³ã‚°ãƒ»ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆâ€”â€” <em class="en">f</em> ã‚’å…¥åŠ›ä¿¡å·ã«é©ç”¨ã™ã‚‹â€”â€”ã‚’ã€ã“ã®å›³ã¯ç¤ºã—ã¦ã„ã‚‹ã€‚
</p>

<a name="%_fig_3.34"></a>
<figure>
<img src="ch3-Z-G-52.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.34:</b>  An ``analog computer circuit'' that solves the
equation
<em>d</em><em>y</em>/<em>d</em><em>t</em> = <em>f</em>(<em>y</em>).</figcaption>
<figcaption class="trans" lang="ja"><b>å›³3.34:</b> <em class="en">dy</em>/<em class="en">dt</em> = <em class="en">f</em>(<em class="en">y</em>) ã¨ã„ã†æ–¹ç¨‹å¼ã‚’è§£ãã€Œã‚¢ãƒŠãƒ­ã‚°ãƒ»ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿å›è·¯ã€</figcaption>
<a name="%_idx_4064"></a>
</figure>
<!--
<p class="exercise"><span class="ex_comment"><em class="en">dy</em>/<em class="en">dt</em> = <em class="en">f</em>(<em class="en">y</em>)  ãªã®ã§ã€
<em class="en">y</em> = <em class="en">y</em><sub>0</sub> + <span style="font-size: larger;">&int;</span> <em class="en">f</em>(<em class="en">y</em>)<em class="en">dt</em>  ã¨æ›¸ã‘ã‚‹ã‹ã¨æ€ã†ã‚“ã ãŒã€å›³ã« <em class="en">dt</em> ã§ãªã <em class="en">dy</em> ã¨è¦‹ãˆã‚‹ã®ã¯ä½•æ•…ã‹ãªâ€¦â€¦
</span></p>
-->

<p class="orig" lang="en">
Assuming we are given an initial value <em>y</em><sub>0</sub> for <em>y</em>, we
could try to model this system using the procedure</p>

<p class="trans" lang="ja">
<em class="en">y</em> ã«ã¤ã„ã¦ <em class="en">y</em><sub>0</sub> ã¨ã„ã†åˆæœŸå€¤ãŒä¸ãˆã‚‰ã‚Œã¦ã„ã‚‹ã¨ã™ã‚‹ã¨ã€ä»¥ä¸‹ã®æ‰‹ç¶šãã‚’ç”¨ã„ã¦ã“ã®ã‚·ã‚¹ãƒ†ãƒ ã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã—ã‚ˆã†ã¨è©¦ã¿ã‚‹ã“ã¨ãŒã‚ã‚Šå¾—ã‚‹ã ã‚ã†ã€‚
</p>

<p class="lisp"><a name="%_idx_4066"></a>(define (solve f y0 dt)
  (define y (integral dy y0 dt))
  (define dy (stream-map f y))
  y)
</p>

<p class="orig" lang="en">
This procedure does not work, because in the first line of <tt>solve</tt>
the call to <tt>integral</tt> requires that the input <tt>dy</tt> be
defined, which does not happen until the second line of <tt>solve</tt>.</p>

<p class="trans" lang="ja">
ã“ã®æ‰‹ç¶šãã¯ã†ã¾ãå‹•ã‹ãªã„ã€‚ã¨ã„ã†ã®ã‚‚ã€<tt>solve</tt> ã®1è¡Œç›®ã§ã€<tt>integral</tt> ã¸ã®å‘¼ã³å‡ºã—ãŒã€<tt>dy</tt> ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’è¦è«‹ã—ã¦ã„ã‚‹ã®ã ãŒã€ãã†ã„ã†ã“ã¨ã¯ã€<tt>solve</tt> ã®2è¡Œç›®ã¾ã§ã¯èµ·ã“ã‚‰ãªã„ã‹ã‚‰ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
On the other hand, the intent of our definition does make sense,
because we can, in principle, begin to generate the <tt>y</tt> stream
without knowing <tt>dy</tt>.  Indeed, <tt>integral</tt> and many other
stream operations have properties similar to those of <tt>cons-stream</tt>, in that we can generate part of the answer given only
partial information about the arguments.  For <tt>integral</tt>, the
first element of the output stream is the specified <tt>initial-value</tt>.  Thus, we can generate the first element of the output
stream without evaluating the integrand <tt>dy</tt>.  Once we know the
first element of <tt>y</tt>, the <tt>stream-map</tt> in the second line of
<tt>solve</tt> can begin working to generate the first element of <tt>dy</tt>, which will produce the next element of <tt>y</tt>, and so on.</p>

<p class="trans" lang="ja">
ãã®ä¸€æ–¹ã€å®šç¾©ã®æ„å›³ã¯æ„å‘³ã‚’ãªã—ã¦ã„ã‚‹ã€‚ã¨ã„ã†ã®ã‚‚ã€åŸç†çš„ã«ã¯ã€<tt>dy</tt> ã‚’çŸ¥ã‚‹ã“ã¨ãªã—ã« <tt>y</tt> ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ç”Ÿæˆã—å§‹ã‚ã‚‹ã“ã¨ãŒã§ãã‚‹ã‹ã‚‰ã ã€‚
å®Ÿã®ã¨ã“ã‚ã€<tt>integral</tt> ã‚„ãã®ä»–ã®å¤šãã®ã‚¹ãƒˆãƒªãƒ¼ãƒ æ¼”ç®—ã«ã¯ã€å¼•æ•°ã«ã¤ã„ã¦ã®éƒ¨åˆ†çš„ãªæƒ…å ±ã‚’ä¸ãˆã‚‰ã‚Œã‚‹ã ã‘ã§ç­”ãˆã®ä¸€éƒ¨ã‚’ç”Ÿæˆã§ãã‚‹ã¨ã„ã†ç‚¹ã§ã€<tt>cons-stream</tt> ã®æ€§è³ªã¨ä¼¼ãŸæ€§è³ªãŒã‚ã‚‹ã®ã ã€‚
<tt>integral</tt> ã«ã¤ã„ã¦è¨€ã†ã¨ã€å‡ºåŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®æœ€åˆã®è¦ç´ ã¯ã€æŒ‡å®šã•ã‚ŒãŸ <tt>initial-value</tt> ã§ã‚ã‚‹ã€‚
ã‚ˆã£ã¦ã€è¢«ç©åˆ†é–¢æ•°ã® <tt>dy</tt> ã‚’è©•ä¾¡ã—ãªã„ã§ã‚‚ã€å‡ºåŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®æœ€åˆã®è¦ç´ ã‚’ç”Ÿæˆã§ãã‚‹ã€‚
<tt>y</tt> ã®æœ€åˆã®è¦ç´ ãŒä¸€æ—¦ã‚ã‹ã£ãŸã‚‰ã€<tt>solve</tt> ã®2è¡Œç›®ã® <tt>stream-map</tt> ã¯ã€<tt>dy</tt> ã®æœ€åˆã®è¦ç´ ã‚’ç”Ÿæˆã™ã‚‹ãŸã‚ã«å‹•ãå§‹ã‚ã‚‹ã“ã¨ãŒã§ãã¦ã€ã™ã‚‹ã¨ <tt>y</tt> ã®æ¬¡ã®è¦ç´ ã‚’ä½œã‚Šå‡ºã™ã“ã¨ã«ãªã‚Šã€ä»¥ä¸‹åŒæ§˜ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
To take advantage of this idea, we will redefine <tt>integral</tt> to
expect the integrand stream to be a <a name="%_idx_4068"></a><a name="%_idx_4070"></a><a name="%_idx_4072"></a><em>delayed argument</em>.  <tt>Integral</tt> will <tt>force</tt> the integrand to be evaluated only when it
is required to generate more than the first element of the output stream:</p>

<p class="trans" lang="ja">
ã“ã®è€ƒãˆæ–¹ã‚’åˆ©ç”¨ã™ã‚‹ãŸã‚ã«ã€<tt>integral</tt> ã‚’ã€è¢«ç©åˆ†é–¢æ•°ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¯<em>é…å»¶ã•ã‚ŒãŸå¼•æ•°</em>ã ã‚ã†ã¨äºˆæœŸã™ã‚‹ã‚ˆã†ã«ã€å†å®šç¾©ã—ã‚ˆã†ã€‚
<tt>integral</tt> ã¯ã€å‡ºåŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®æœ€åˆã®è¦ç´ ä»¥ä¸Šã®ã‚‚ã®ã‚’ç”Ÿæˆã™ã‚‹ã“ã¨ã‚’æ±‚ã‚ã‚‰ã‚ŒãŸå ´åˆã«ã®ã¿ã€è¢«ç©åˆ†é–¢æ•°ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ã‚’ <tt>force</tt> ã™ã‚‹ (å¼·åˆ¶ã™ã‚‹) ã ã‚ã†ã€‚
</p>

<p class="lisp"><a name="%_idx_4074"></a>(define (integral delayed-integrand initial-value dt)
  (define int
    (cons-stream initial-value
                 (let ((integrand (force delayed-integrand)))
                   (add-streams (scale-stream integrand dt)
                                int))))
  int)
</p>


<p class="orig" lang="en">
Now we can implement our <tt>solve</tt> procedure by delaying the
evaluation of <tt>dy</tt> in the definition of <tt>y</tt>:<a name="call_footnote_Temp_494" href="#footnote_Temp_494"><sup><small>71</small></sup></a></p>

<p class="trans" lang="ja">
ã•ã¦ä»Šã‚„ã€<tt>y</tt> ã®å®šç¾©ã®ä¸­ã§ã® <tt>dy</tt> ã®è©•ä¾¡ã‚’é…å»¶ã•ã›ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€<tt>solve</tt> ã®æ‰‹ç¶šãã‚’å®Ÿè£…ã§ãã‚‹<a href="#footnote_Temp_494"><sup><small>71</small></sup></a>ã€‚
</p>


<p class="lisp"><a name="%_idx_4076"></a>(define (solve f y0 dt)
  (define y (integral (delay dy) y0 dt))
  (define dy (stream-map f y))
  y)
</p>

<p class="orig" lang="en">
In general, every caller of <tt>integral</tt> must now <tt>delay</tt> the
integrand argument.  We can demonstrate that the <tt>solve</tt> procedure
works by approximating <a name="%_idx_4078"></a><em>e</em> <img src="book-Z-G-D-20.gif" border="0">  2.718 by computing the value at
<em>y</em> = 1 of the solution to the differential equation <em>d</em><em>y</em>/<em>d</em><em>t</em> = <em>y</em> with
initial condition <em>y</em>(0) = 1:</p>

<p class="trans" lang="ja">
ä¸€èˆ¬ã«ã€<tt>integral</tt> ã®å‘¼ã³å‡ºã—å´ã¯ã©ã‚Œã‚‚ã€ä»Šã‚„ã€è¢«ç©åˆ†é–¢æ•°ã®å¼•æ•°ã‚’ <tt>delay</tt> (é…å»¶) ã•ã›ã­ã°ãªã‚‰ãªã„ã€‚
<span class="math"><em class="en">y</em>(0) = 1</span>
ã¨ã„ã†åˆæœŸæ¡ä»¶ã§ã®ã€
<span class="math"><em class="en">dy</em>/<em class="en">dt</em> = <em class="en">y</em></span>
ã¨ã„ã†å¾®åˆ†æ–¹ç¨‹å¼ã®è§£ã®ã€
<span class="math"><em class="en">y</em> = 1</span>
ã§ã®å€¤ã‚’è¨ˆç®—ã™ã‚‹ã“ã¨ã§ã€
<span class="math"><em class="en">e</em> &asymp; 2.718</span>
ã¨è¿‘ä¼¼ã—ã€ãã‚Œã«ã‚ˆã£ã¦ã€
<tt>solve</tt> ã®æ‰‹ç¶šããŒã¡ã‚ƒã‚“ã¨å‹•ãã“ã¨ã‚’å®Ÿè¨¼ã§ãã‚‹ã€‚
</p>

<p class="lisp">(stream-ref (solve (lambda (y) y) 1 0.001) 1000)
<i>2.716924</i></p>

<p class="orig" lang="en"><a name="%_thm_3.77"></a>
<b>Exercise 3.77.</b>  The <tt>integral</tt> procedure used above was analogous to the
``implicit'' definition of the infinite stream of integers in
section <a href="#%_sec_3.5.2">3.5.2</a>.  Alternatively, we can give a
definition of <tt>integral</tt> that is more like <tt>integers-starting-from</tt> (also in section <a href="#%_sec_3.5.2">3.5.2</a>):</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.77.</b> ä¸Šã§ä½¿ã£ãŸ <tt>integral</tt> ã¨ã„ã†æ‰‹ç¶šãã¯ã€<a href="#%_sec_3.5.2">3.5.2</a>ç¯€ã§ã®æ•´æ•°ã®ç„¡é™ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®ã€Œæš—é»™ã®ã€å®šç¾©ã«å¯¾ã™ã‚‹ç›¸ä¼¼ç‰©ã§ã‚ã£ãŸã€‚
ä»£ã‚ã‚Šã«ã€ã‚ˆã‚Š  <tt>integers-starting-from</tt>  (ã“ã‚Œã‚‚<a href="#%_sec_3.5.2">3.5.2</a>ç¯€ã«ã‚ã‚‹) ã«ä¼¼ã¦ã„ã‚‹ã‚ˆã†ãª <tt>integral</tt> ã®å®šç¾©ã‚’ä¸ãˆã‚‹ã“ã¨ã‚‚ã§ãã‚‹
</p>


<p class="lisp"><a name="%_idx_4080"></a>(define (integral integrand initial-value dt)
  (cons-stream initial-value
               (if (stream-null? integrand)
                   the-empty-stream
                   (integral (stream-cdr integrand)
                             (+ (* dt (stream-car integrand))
                                initial-value)
                             dt))))
</p>


<p class="orig" lang="en">
When used in systems with loops, this procedure has the same problem
as does our original version of <tt>integral</tt>.  Modify the procedure
so that it expects the <tt>integrand</tt> as a delayed argument and hence
can be used in the <tt>solve</tt> procedure shown above.
</p>

<p class="trans" lang="ja">
ãƒ«ãƒ¼ãƒ—ã®ã‚ã‚‹ã‚·ã‚¹ãƒ†ãƒ ã§ä½¿ã†å ´åˆã€ã“ã®æ‰‹ç¶šãã«ã¯ã€<tt>integral</tt> ã®å…ƒã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«ã‚ã£ãŸã®ã¨åŒã˜å•é¡ŒãŒã‚ã‚‹ã€‚
ã“ã®æ‰‹ç¶šããŒã€<tt>integrand</tt> ã®ã“ã¨ã‚’ã€é…å»¶ã•ã‚ŒãŸå¼•æ•°ã ã‚ã†ã¨äºˆæœŸã™ã‚‹ã‚ˆã†ã«ã€ãã—ã¦ã¾ãŸã€ãã®çµæœã¨ã—ã¦ã€ã“ã®æ‰‹ç¶šãã‚’ä¸Šè¨˜ã® <tt>solve</tt> ã®æ‰‹ç¶šãã«ãŠã„ã¦ä½¿ã†ã“ã¨ãŒã§ãã‚‹ã‚ˆã†ã«ã€ã“ã®æ‰‹ç¶šãã‚’ä¿®æ­£ã›ã‚ˆã€‚
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.78"></a>
<b>Exercise 3.78.</b>  <a name="%_fig_3.35"></a></p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.78.</b> 
</p>

<figure>
<img src="ch3-Z-G-53.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.35:</b>  Signal-flow diagram for the solution to a second-order
linear differential equation.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³3.35:</b> 2æ¬¡ç·šå½¢å¾®åˆ†æ–¹ç¨‹å¼ç”¨ã®ä¿¡å·æµã‚Œå›³</figcaption>
</figure>

<p class="orig" lang="en">
<a name="%_idx_4082"></a>Consider the problem of designing a signal-processing system to study
the homogeneous second-order linear differential equation
</p>

<p class="trans" lang="ja">
æ–‰æ¬¡2æ¬¡ç·šå½¢å¾®åˆ†æ–¹ç¨‹å¼ã‚’æ¤œè¨ã™ã‚‹ãŸã‚ã®ä¿¡å·å‡¦ç†ã‚·ã‚¹ãƒ†ãƒ ã‚’è¨­è¨ˆã™ã‚‹å•é¡Œã‚’è€ƒãˆã‚ˆã†ã€‚
</p>

<figure><img src="ch3-Z-G-54.gif" border="0"></figure>


<p class="orig" lang="en">
The output stream, modeling <em>y</em>, is generated by a network that
contains a loop. This is because the value of <em>d</em><sup>2</sup><em>y</em>/<em>d</em><em>t</em><sup>2</sup> depends
upon the values of <em>y</em> and <em>d</em><em>y</em>/<em>d</em><em>t</em> and both of these are determined by
integrating <em>d</em><sup>2</sup><em>y</em>/<em>d</em><em>t</em><sup>2</sup>.  The diagram we would like to encode is
shown in figure <a href="#%_fig_3.35">3.35</a>.  Write a procedure <tt>solve-2nd</tt> that
takes as arguments the constants <em>a</em>, <em>b</em>, and <em>d</em><em>t</em> and the initial
values <em>y</em><sub>0</sub> and <em>d</em><em>y</em><sub>0</sub> for <em>y</em> and <em>d</em><em>y</em>/<em>d</em><em>t</em> and generates the
stream of successive values of <em>y</em>.

</p>

<p class="trans" lang="ja">
å‡ºåŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ â€”â€” <em class="en">y</em> ã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã—ã¦ã„ã‚‹â€”â€”ã¯ã€ãƒ«ãƒ¼ãƒ—ã‚’å«ã‚€ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã«ã‚ˆã£ã¦ç”Ÿæˆã•ã‚Œã‚‹ã€‚
ãã®ç†ç”±ã¯ã€
<em class="en">d</em><sup>2</sup><em class="en">y</em>/<em class="en">d</em><em class="en">t</em><sup>2</sup>
ãŒ
<em class="en">y</em> 
ã¨
<em class="en">d</em><em class="en">y</em>/<em class="en">d</em><em class="en">t</em>
ã®å€¤ã«ä¾å­˜ã—ã¦ãŠã‚Šã€ã‹ã¤ã€ã“ã‚Œã‚‰ã®å€¤ã®åŒæ–¹ãŒã€
<em class="en">d</em><sup>2</sup><em class="en">y</em>/<em class="en">d</em><em class="en">t</em><sup>2</sup>
ã‚’ç©åˆ†ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦æ±ºå®šã¥ã‘ã‚‰ã‚Œã‚‹ã‹ã‚‰ã§ã‚ã‚‹ã€‚
ç§ãŸã¡ãŒã‚³ãƒ¼ãƒ‰ã«è½ã¨ã—è¾¼ã¿ãŸã„å›³ã¯ã€å›³<a href="#%_fig_3.35">3.35</a>ã«ç¤ºã•ã‚Œã¦ã„ã‚‹ã€‚
<em class="en">a</em> ã¨ <em class="en">b</em> ã¨ <em class="en">dt</em> ã¨ã„ã†å®šæ•°ã¨ã€
<em class="en">y</em> ãŠã‚ˆã³ <em class="en">dy</em>/<em class="en">dt</em> ã«å¯¾ã™ã‚‹
<em class="en">y</em><sub>0</sub> ãŠã‚ˆã³ <em class="en">dy</em><sub>0</sub> ã¨ã„ã†åˆæœŸå€¤ã‚’å¼•æ•°ã¨ã—ã¦ã¨ã‚Šã€å¼•ãç¶šã <em class="en">y</em> ã®å€¤ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ç”Ÿæˆã™ã‚‹ã‚ˆã†ãªã€<tt>solve-2nd</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’æ›¸ã‘ã€‚
</p> 


<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.79"></a>
<b>Exercise 3.79.</b>  <a name="%_idx_4084"></a>Generalize the <tt>solve-2nd</tt> procedure of exercise <a href="#%_thm_3.78">3.78</a> so
that it can be used to solve general second-order differential
equations <em>d</em><sup>2</sup> <em>y</em>/<em>d</em><em>t</em><sup>2</sup> = <em>f</em>(<em>d</em><em>y</em>/<em>d</em><em>t</em>,  <em>y</em>).
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.79.</b> ç·´ç¿’å•é¡Œ<a href="#%_thm_3.78">3.78</a>ã® <tt>solve-2nd</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’ã€
<span class="math"><em class="en">d</em><sup>2</sup> <em class="en">y</em>/<em class="en">dt</em><sup>2</sup> = <em class="en">f</em>(<em class="en">dy</em>/<em class="en">dt</em>,  <em class="en">y</em>)</span>
ã¨ã„ã†ä¸€èˆ¬ã®2æ¬¡å¾®åˆ†æ–¹ç¨‹å¼ã‚’è§£ãã®ã«ä½¿ãˆã‚‹ã‚ˆã†ã«ã€ä¸€èˆ¬åŒ–ã›ã‚ˆã€‚
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.80"></a>
<b>Exercise 3.80.</b>  <a name="%_idx_4086"></a><a name="%_idx_4088"></a><a name="%_idx_4090"></a>A <em>series RLC circuit</em> consists of a resistor, a capacitor, and an
inductor connected in series, as shown in figure <a href="#%_fig_3.36">3.36</a>.
If <em>R</em>, <em>L</em>, and <em>C</em> are the resistance, inductance, and capacitance,
then the relations between voltage (<em>v</em>) and current (<em>i</em>)
for the three components are described by the equations
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.80.</b> <em>ç›´åˆ—RLCå›è·¯</em>ã¯ã€å›³<a href="#%_fig_3.36">3.36</a>ã«ç¤ºã™ã‚ˆã†ã«ã€ç›´åˆ—ã«æ¥ç¶šã•ã‚ŒãŸã€æŠµæŠ—å™¨ã¨ã‚­ãƒ£ãƒ‘ã‚·ã‚¿ã¨ã‚¤ãƒ³ãƒ€ã‚¯ã‚¿ã‹ã‚‰ãªã‚‹ã€‚
<em class="en">R</em> ã¨ <em class="en">L</em> ã¨ <em class="en">C</em> ãŒã€æŠµæŠ—å€¤ã¨ã‚¤ãƒ³ãƒ€ã‚¯ã‚¿ãƒ³ã‚¹ã¨ã‚­ãƒ£ãƒ‘ã‚·ã‚¿ãƒ³ã‚¹ã§ã‚ã‚‹ã¨ã™ã‚‹ã¨ã€ä¸‰ã¤ã®éƒ¨å“ã«ã¤ã„ã¦ã®ã€é›»åœ§ (<em class="en">v</em>) ã¨é›»æµ (<em class="en">i</em>) ã®é–“ã®é–¢ä¿‚ã¯ã€ä»¥ä¸‹ã®æ–¹ç¨‹å¼ã®ã‚ˆã†ã«è¨˜è¿°ã•ã‚Œã€
</p>

<figure><img src="ch3-Z-G-55.gif" border="0"></figure>


<p class="orig" lang="en">
and the circuit connections dictate the relations
</p>

<p class="trans" lang="ja">
å›è·¯ã®æ¥ç¶šãŒã€ä»¥ä¸‹ã®é–¢ä¿‚ã‚’æ±ºå®šã™ã‚‹ã€‚
</p>

<figure><img src="ch3-Z-G-56.gif" border="0"></figure>


<p class="orig" lang="en">
Combining these equations shows that the state of the circuit
(summarized by <em>v</em><sub><em>C</em></sub>, the voltage across the capacitor, and <em>i</em><sub><em>L</em></sub>, the
current in the inductor)
is described by the pair of differential equations
</p>

<p class="trans" lang="ja">
ã“ã‚Œã‚‰ã®æ–¹ç¨‹å¼ã‚’çµã³ã¤ã‘ã‚‹ã¨ã€å›è·¯ã®çŠ¶æ…‹ (<em class="en">v<sub>C</sub></em> â€”â€”ã™ãªã‚ã¡ã‚­ãƒ£ãƒ‘ã‚·ã‚¿ã®ä¸¡ç«¯ã®é›»åœ§â€”â€”ã¨ã€<em class="en">i<sub>L</sub></em> â€”â€”ã™ãªã‚ã¡ã‚¤ãƒ³ãƒ€ã‚¯ã‚¿ã‚’æµã‚Œã‚‹é›»æµâ€”â€”ã«ã‚ˆã‚Šè¦ç´„ã•ã‚Œã‚‹) ãŒä»¥ä¸‹ã®ä¸€å¯¾ã®å¾®åˆ†æ–¹ç¨‹å¼ã«ã‚ˆã‚Šè¨˜è¿°ã•ã‚Œã‚‹ã€ã¨ã„ã†ã“ã¨ãŒç¤ºã•ã‚Œã‚‹ã€‚
</p>

<figure><img src="ch3-Z-G-57.gif" border="0"></figure>


<p class="orig" lang="en">
The signal-flow diagram representing this system of differential
equations is shown in figure <a href="#%_fig_3.37">3.37</a>.
</p>

<p class="trans" lang="ja">
å¾®åˆ†æ–¹ç¨‹å¼ã®ã“ã®ã‚ˆã†ãªä½“ç³»ã‚’è¡¨ã™ä¿¡å·æµã‚Œå›³ãŒã€å›³<a href="#%_fig_3.37">3.37</a>ã«ç¤ºã•ã‚Œã¦ã„ã‚‹ã€‚
</p>

<a name="%_fig_3.36"></a>
<figure>
<img src="ch3-Z-G-58.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.36:</b>  A series RLC circuit.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³3.36:</b> ç›´åˆ—RLCå›è·¯</figcaption>
</figure>

<a name="%_fig_3.37"></a>
<figure>
<img src="ch3-Z-G-59.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.37:</b>  A signal-flow diagram for the solution
to a series RLC circuit.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³3. 37:</b> ç›´åˆ—RLCå›è·¯ã«å¯¾ã™ã‚‹è§£ã®ãŸã‚ã®ä¿¡å·æµã‚Œå›³</figcaption>
</figure>


<p class="orig" lang="en">
Write a procedure <tt>RLC</tt> that takes as arguments the parameters
<em>R</em>, <em>L</em>, and <em>C</em> of the circuit and the time increment <em>d</em><em>t</em>.  In a
manner similar to that of the <tt>RC</tt> procedure of
exercise <a href="#%_thm_3.73">3.73</a>, <tt>RLC</tt> should produce a procedure
that takes the initial values of the state variables, <em>v</em><sub><em>C</em><sub>0</sub></sub> and
<em>i</em><sub><em>L</em><sub>0</sub></sub>, and produces a pair (using <tt>cons</tt>) of the streams of
states <em>v</em><sub><em>C</em></sub> and <em>i</em><sub><em>L</em></sub>.  Using <tt>RLC</tt>, generate the pair of
streams that models the behavior of a series RLC circuit with <em>R</em>  =  1
ohm, <em>C</em> =  0.2 farad, <em>L</em>  =  1 henry, <em>d</em><em>t</em>  =  0.1 second, and initial
values <em>i</em><sub><em>L</em><sub>0</sub></sub>  =  0 amps and <em>v</em><sub><em>C</em><sub>0</sub></sub>  =  10 volts.
</p>

<p class="trans" lang="ja">
ã“ã®å›è·¯ã® <em class="en">R</em> ã¨ <em class="en">L</em> ã¨ <em class="en">C</em> ã¨ã„ã†ãƒ‘ãƒ©ãƒ¡ã‚¿ã¨ã€<em class="en">dt</em> ã¨ã„ã†æ™‚é–“å¢—åˆ†ã¨ã‚’å¼•æ•°ã¨ã—ã¦ã¨ã‚‹ã€<tt>RLC</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’æ›¸ã‘ã€‚
çŠ¶æ…‹å¤‰æ•°ã®åˆæœŸå€¤â€”â€”ã¤ã¾ã‚Šã€
<span class="math"><em class="en">v</em><sub><em class="en">C</em><sub>0</sub></sub></span> ã¨
<span class="math"><em class="en">i</em><sub><em class="en">L</em><sub>0</sub></sub></span>
â€”â€”ã‚’ã¨ã‚Šã€
<span class="math"><em class="en">v<sub>C</sub></em></span> ã¨
<span class="math"><em class="en">i<sub>L</sub></em></span>
ã¨ã„ã†çŠ¶æ…‹ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ åŒå£«ã® (<tt>cons</tt> ã‚’ç”¨ã„ãŸ) å¯¾ã‚’ä½œã‚Šå‡ºã™æ‰‹ç¶šãã‚’ã€<tt>RLC</tt> ã¯ã€ç·´ç¿’å•é¡Œ<a href="#%_thm_3.73">3.73</a>ã® <tt>RC</tt> ã¨ã„ã†æ‰‹ç¶šãã§ã®ã‚„ã‚Šæ–¹ã¨ä¼¼ãŸã‚„ã‚Šæ–¹ã§ã€ä½œã‚Šå‡ºã™ã¯ãšã§ã‚ã‚‹ã€‚
<em class="en">R</em> ãŒ 1 Î© (ã‚ªãƒ¼ãƒ ) ã§ã€<em class="en">C</em> ãŒ 0.2 F (ãƒ•ã‚¡ãƒ©ãƒƒãƒ‰) ã§ã€<em class="en">L</em> ãŒ 1 H (ãƒ˜ãƒ³ãƒªãƒ¼)ã§ã€<em class="en">dt</em> ãŒ 0.1 ç§’ã§ã€åˆæœŸå€¤ã¯
<span class="math"><em class="en">i</em><sub><em class="en">L</em><sub>0</sub></sub></span> ãŒ 0 A (ã‚¢ãƒ³ãƒšã‚¢) ã§
<span class="math"><em class="en">i</em><sub><em class="en">L</em><sub>0</sub></sub></span> ãŒ 10 V (ãƒœãƒ«ãƒˆ) ã§ã‚ã‚‹ã‚ˆã†ãªç›´åˆ—RLCå›è·¯ã®æŒ¯ã‚‹èˆã„ã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã™ã‚‹ä¸€å¯¾ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ã€<tt>RLC</tt> ã‚’ç”¨ã„ã¦ç”Ÿæˆã›ã‚ˆã€‚
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_Temp_499"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_499">Normal-order evaluation</a></h4>
<h4 class="trans" lang="ja">æ­£è¦é †ã®è©•ä¾¡</h4>

<p class="orig" lang="en">
<a name="%_idx_4092"></a><a name="%_idx_4094"></a>
The examples in this section illustrate how the explicit use of <tt>delay</tt> and <tt>force</tt> provides great programming flexibility, but the
same examples also show how this can make our programs more complex.
Our new <tt>integral</tt> procedure, for instance, gives us the power to
model systems with loops, but we must now remember that <tt>integral</tt>
should be called with a delayed integrand, and every procedure that
uses <tt>integral</tt> must be aware of this.  In effect, we have created
two classes of procedures: ordinary procedures and procedures that
take delayed arguments.  In general, creating separate classes of
procedures forces us to create separate classes of higher-order
procedures as well.<a name="call_footnote_Temp_500" href="#footnote_Temp_500"><sup><small>72</small></sup></a></p>

<p class="trans" lang="ja">
æœ¬ç¯€ã®äº‹ä¾‹ã¯ã€<tt>delay</tt> ã¨ <tt>force</tt> ã®æ˜ç¤ºçš„ãªä½¿ç”¨ãŒã€ã©ã®ã‚ˆã†ã«ã—ã¦ç´ æ™´ã‚‰ã—ã„ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®æŸ”è»Ÿæ€§ã‚’ã‚‚ãŸã‚‰ã—ã¦ãã‚Œã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’ç¤ºã—ã¦ã„ã‚‹ãŒã€åŒã˜äº‹ä¾‹ãŒã€ã“ã® <tt>delay</tt> ã¨ <tt>force</tt> ã®æ˜ç¤ºçš„ãªä½¿ç”¨ã«ã‚ˆã£ã¦ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒã©ã®ã‚ˆã†ã«ã—ã¦ä¸€å±¤è¤‡é›‘ã«ãªã‚Šã†ã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’ã‚‚ç¤ºã—ã¦ã„ã‚‹ã€‚
ãŸã¨ãˆã°ã€æ–°ã—ã„æ–¹ã® <tt>integral</tt> ã®æ‰‹ç¶šãã¯ã€ãƒ«ãƒ¼ãƒ—ã®ã‚ã‚‹ã‚·ã‚¹ãƒ†ãƒ ã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã™ã‚‹åŠ›ã‚’ä¸ãˆã¦ãã‚Œã‚‹ãŒã€ç§ãŸã¡ã¯ã“ã“ã§ã€<tt>integral</tt> ã¯é…å»¶ã•ã‚ŒãŸè¢«ç©åˆ†é–¢æ•°ã¨ã¨ã‚‚ã«å‘¼ã°ã‚Œã‚‹ã¹ãã§ã‚ã‚‹ã€ã¨ã„ã†ã“ã¨ã‚’è¦šãˆã¦ã„ãªãã¦ã¯ãªã‚‰ãšã€<tt>integral</tt> ã‚’ä½¿ã†ã©ã®æ‰‹ç¶šãã‚‚ã€ã“ã®ã“ã¨ã«è‡ªè¦šçš„ã§ãªãã¦ã¯ãªã‚‰ãªã„ã®ã§ã‚ã‚‹ã€‚
äº‹å®Ÿä¸Šã€ç§ãŸã¡ã¯ã€æ‰‹ç¶šãã®äºŒã¤ã®ã‚¯ãƒ©ã‚¹â€”â€”ã¤ã¾ã‚Šã€æ™®é€šã®æ‰‹ç¶šãã¨ã€é…å»¶ã•ã‚ŒãŸå¼•æ•°ã‚’å–ã‚‹æ‰‹ç¶šãâ€”â€”ã‚’ä½œæˆã—ãŸã‚ã‘ã ã€‚
ä¸€èˆ¬ã«ã€æ‰‹ç¶šãã®åˆ¥ã€…ã®ã‚¯ãƒ©ã‚¹ã‚’ä½œæˆã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€ç§ãŸã¡ã¯ã€ã‚ˆã‚Šé«˜æ¬¡ã®æ‰‹ç¶šãã®åˆ¥ã€…ã®ã‚¯ãƒ©ã‚¹ã‚‚ã€ä½œã‚‰ã–ã‚‹ã‚’å¾—ãªããªã‚‹<a href="#footnote_Temp_500"><sup><small>72</small></sup></a>ã€‚

</p>

<p class="orig" lang="en">
One way to avoid the need for two different classes of procedures is
to make all procedures take delayed arguments.  We could adopt a model
of evaluation in which all arguments to procedures are automatically
delayed and arguments are forced only when they are actually needed
(for example, when they are required by a primitive operation).  This
would transform our language to use normal-order evaluation, which we
first described when we introduced the substitution model for
evaluation in section <a href="10_sec1_1.html#%_sec_1.1.5">1.1.5</a>.  Converting to
normal-order evaluation provides a uniform and elegant way to simplify
the use of delayed evaluation, and this would be a natural strategy to
adopt if we were concerned only with stream processing.  In
section <a href="27_sec4_2.html#%_sec_4.2">4.2</a>, after we have studied the evaluator, we
will see how to transform our language in just this way.
Unfortunately, including delays in procedure calls wreaks havoc with
our ability to design programs that depend on the order of events,
such as programs that use assignment, mutate data, or perform input or
output.  Even the single <tt>delay</tt> in <tt>cons-stream</tt> can cause
great confusion, as illustrated by exercises <a href="#%_thm_3.51">3.51</a>
and <a href="#%_thm_3.52">3.52</a>.  As far as anyone knows, mutability and delayed
evaluation do not mix well in programming languages, and devising ways
to deal with both of these at once is an active area of research.</p>

<p class="trans" lang="ja">
æ‰‹ç¶šãã®äºŒã¤ã®ç•°ãªã‚‹ã‚¯ãƒ©ã‚¹ã«å¯¾ã™ã‚‹å¿…è¦æ€§ã‚’é¿ã‘ã‚‹ãŸã‚ã®ä¸€ã¤ã®æ–¹æ³•ã¯ã€ã™ã¹ã¦ã®æ‰‹ç¶šãã«ã€é…å»¶ã•ã‚ŒãŸå¼•æ•°ã‚’ã¨ã‚‰ã›ã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚
æ‰‹ç¶šãã«å¯¾ã™ã‚‹ã™ã¹ã¦ã®å¼•æ•°ãŒè‡ªå‹•çš„ã«é…å»¶ã•ã‚Œã€ã‹ã¤ã€å¼•æ•°ãŒå®Ÿéš›ã«å¿…è¦ã¨ã•ã‚Œã‚‹ã¨ã (ãŸã¨ãˆã°ã€å¼•æ•°ãŒåŸå§‹çš„ãªæ¼”ç®—ã‹ã‚‰å¿…è¦ã¨ã•ã‚Œã‚‹ã¨ã) ã«ã ã‘ã€å¼•æ•°ãŒå¼·åˆ¶ (<tt>force</tt>) ã•ã‚Œã‚‹ã‚ˆã†ãªè©•ä¾¡ã®ãƒ¢ãƒ‡ãƒ«ã‚’ã€æ¡ç”¨ã™ã‚‹ã“ã¨ã‚‚ã§ããŸã ã‚ã†ã€‚
ã“ã‚Œã¯ã€ç§ãŸã¡ã®è¨€èªã‚’ã€æ­£è¦é †ã®è©•ä¾¡â€”â€”è©•ä¾¡ã®ãŸã‚ã®<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ãŠãã‹ãˆ</rt><rp>) </rp></ruby>ãƒ¢ãƒ‡ãƒ«ã‚’<a href="10_sec1_1.html#%_sec_1.1.5">1.1.5</a>ç¯€ã§å°å…¥ã—ãŸã¨ãã«ã€æœ€åˆã«èª¬æ˜ã—ãŸâ€”â€”ã‚’ç”¨ã„ã‚‹ã‚ˆã†ã«ã€å¤‰å½¢ã•ã›ã‚‹ã“ã¨ã ã‚ã†ã€‚
æ­£è¦é †ã®è©•ä¾¡ã¸ã®è»¢æ›ã¯ã€é…å»¶è©•ä¾¡ã®ä½¿ç”¨ã‚’ç°¡ç´ åŒ–ã™ã‚‹ãŸã‚ã®ã€ä¸€å¾‹ã§æ´—ç·´ã•ã‚ŒãŸæ–¹æ³•ã§ã‚ã‚‹ã—ã€ã“ã‚Œã¯ã€ã‚‚ã—ç§ãŸã¡ãŒã‚¹ãƒˆãƒªãƒ¼ãƒ å‡¦ç†ã«ã ã‘é–¢å¿ƒãŒã‚ã£ãŸãªã‚‰ã°ã€æ¡ç”¨ã™ã¹ãè‡ªç„¶ãªæˆ¦ç•¥ã§ã‚ã£ãŸã ã‚ã†ã€‚
<a href="27_sec4_2.html#%_sec_4.2">4.2</a>ç¯€ã§ã€è©•ä¾¡å™¨ã«ã¤ã„ã¦æ¤œè¨ã—ãŸå¾Œã«ã€ã¾ã•ã«ã“ã®æ–¹æ³•ã§ç§ãŸã¡ã®è¨€èªã‚’å¤‰å½¢ã™ã‚‹ã«ã¯ã©ã†ã™ã‚Œã°ã‚ˆã„ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’è¦‹ã‚‹ã“ã¨ã«ã—ã‚ˆã†ã€‚
ã‚ã„ã«ãã€æ‰‹ç¶šãå‘¼ã³å‡ºã—ã«é…å»¶ã‚’å«ã‚ã‚‹ã“ã¨ã¯ã€å‡ºæ¥äº‹ã®é †åºã«ä¾å­˜ã™ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ â€”â€”<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã‚’ä½¿ã£ãŸã‚Šã€ãƒ‡ãƒ¼ã‚¿ã‚’å¤‰æ›´ã—ãŸã‚Šã€å…¥å‡ºåŠ›ã‚’è¡Œã£ãŸã‚Šã™ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãªã©â€”â€”ã‚’è¨­è¨ˆã™ã‚‹ã¨ã„ã†ç§ãŸã¡ã®èƒ½åŠ›ã«ã€å¤§æ‰“æ’ƒã‚’ä¸ãˆã‚‹ã€‚
<tt>cons-stream</tt> ã®ä¸­ã®å˜ä¸€ã® <tt>delay</tt> ã§ã•ãˆã€ç·´ç¿’å•é¡Œ<a href="#%_thm_3.51">3.51</a>ã¨ç·´ç¿’å•é¡Œ<a href="#%_thm_3.52">3.52</a>ã«ã‚ˆã‚Šä¾‹ç¤ºã•ã‚Œã‚‹ã¨ãŠã‚Šã€å¤§ããªæ··ä¹±ã‚’å¼•ãèµ·ã“ã—å¾—ã‚‹ã€‚
çŸ¥ã‚‰ã‚Œã¦ã„ã‚‹é™ã‚Šã§ã¯ã€å¤‰æ›´å¯èƒ½ã§ã‚ã‚‹ã“ã¨ã¨é…å»¶è©•ä¾¡ã¨ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã«ãŠã„ã¦ã†ã¾ãä¸¡ç«‹ã—ãªã„ã—ã€ã“ã‚Œã‚‰ä¸¡è€…ã‚’ä¸€åº¦ã«æ‰±ã†ãŸã‚ã®æ–¹æ³•ã‚’è€ƒæ¡ˆã™ã‚‹ã“ã¨ã¯ã€ç ”ç©¶ã«ãŠã‘ã‚‹æ´»ç™ºãªåˆ†é‡ãªã®ã§ã‚ã‚‹ã€‚
</p>

<a name="%_sec_3.5.5"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_3.5.5">3.5.5  Modularity of Functional Programs and Modularity of Objects</a></h3>
<h3 class="trans" lang="ja">3.5.5 é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ€§ã¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ€§</h3>

<p class="orig" lang="en">
<a name="%_idx_4116"></a><a name="%_idx_4118"></a>
As we saw in section <a href="20_sec3_1.html#%_sec_3.1.2">3.1.2</a>, one of the
major benefits of introducing assignment is that we can increase the
modularity of our systems by encapsulating, or ``hiding,'' parts of
the state of a large system within local variables.  Stream models can
provide an equivalent modularity without the use of assignment.  As an
<a name="%_idx_4120"></a><a name="%_idx_4122"></a>illustration, we can reimplement the Monte Carlo estimation of <img src="book-Z-G-D-9.gif" border="0">,
which we examined in section <a href="20_sec3_1.html#%_sec_3.1.2">3.1.2</a>, from a
stream-processing point of view.</p>

<p class="trans" lang="ja">
<a href="20_sec3_1.html#%_sec_3.1.2">3.1.2</a>ç¯€ã§è¦‹ãŸã¨ãŠã‚Šã€<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã‚’å°å…¥ã™ã‚‹ã“ã¨ã®ä¸»è¦ãªåˆ©ç‚¹ã®ä¸€ã¤ã¯ã€å¤§ããªã‚·ã‚¹ãƒ†ãƒ ã®çŠ¶æ…‹ã®ä¸€éƒ¨ã‚’ã€å±€æ‰€å¤‰æ•°ã®ä¸­ã«ã‚«ãƒ—ã‚»ãƒ«åŒ–ã™ã‚‹â€”â€”ã™ãªã‚ã¡ã€Œéš ã™ã€â€”â€”ã“ã¨ã«ã‚ˆã‚Šã€ã‚·ã‚¹ãƒ†ãƒ ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ€§ã‚’å¢—ã™ã“ã¨ãŒã§ãã‚‹ç‚¹ã§ã‚ã‚‹ã€‚
ã‚¹ãƒˆãƒªãƒ¼ãƒ ãƒ»ãƒ¢ãƒ‡ãƒ«ã¯ã€<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã‚’ä½¿ã†ã“ã¨ãªãã€ç­‰ä¾¡ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ€§ã‚’æä¾›ã§ãã‚‹ã€‚
ä¾‹ç¤ºã¨ã—ã¦ã€&pi; ã®ãƒ¢ãƒ³ãƒ†ã‚«ãƒ«ãƒ­æ¨å®šâ€”â€”<a href="20_sec3_1.html#%_sec_3.1.2">3.1.2</a>ç¯€ã§æ¤œè¨ã—ãŸâ€”â€”ã‚’ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ å‡¦ç†ã®è¦³ç‚¹ã‹ã‚‰ã€å®Ÿè£…ã—ç›´ã™ã“ã¨ãŒã§ãã‚‹ã€‚
</p>

<p class="orig" lang="en">
The key modularity issue was that we wished to hide the internal state
of a random-number generator from programs that used random numbers.
We began with a procedure <tt>rand-update</tt>, whose successive values
furnished our supply of random numbers, and used this to produce a
random-number generator:</p>

<p class="trans" lang="ja">
éµã¨ãªã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ€§ã®è«–ç‚¹ã¯ã€ä¹±æ•°ç”Ÿæˆå™¨ã®å†…éƒ¨çŠ¶æ…‹ã‚’ã€ä¹±æ•°ã‚’ä½¿ã†ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‹ã‚‰ã¯éš ã—ã¦ãŠããŸã„ã€ã¨ã„ã†ç‚¹ã§ã‚ã£ãŸã€‚
ç§ãŸã¡ã¯ã€<tt>rand-update</tt> ã¨ã„ã†æ‰‹ç¶šãâ€”â€”ã“ã‚Œã®é€£ç¶šã™ã‚‹å€¤ãŒã€ä¹±æ•°ã®ä¾›çµ¦ã‚’ä¸ãˆã¦ãã‚Œã‚‹â€”â€”ã‹ã‚‰å§‹ã‚ã€ã“ã‚Œã‚’ç”¨ã„ã¦ä¹±æ•°ç”Ÿæˆå™¨ã‚’ä½œã‚Šå‡ºã—ãŸã€‚
</p>


<p class="lisp">(define rand
  (let ((x random-init))
    (lambda ()
      (set! x (rand-update x))
      x)))
</p>

<p class="orig" lang="en">
In the stream formulation there is no random-number generator <em>per
se</em>, just a stream of random numbers produced by successive calls to
<tt>rand-update</tt>:</p>

<p class="trans" lang="ja">
ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«ã‚ˆã‚‹å®šå¼åŒ–ã«ãŠã„ã¦ã¯ã€ä¹±æ•°ç”Ÿæˆå™¨ãã®ã‚‚ã®ã¯å­˜åœ¨ã›ãšã€ãŸã ã€<tt>rand-update</tt> ã«å¯¾ã™ã‚‹é€£ç¶šã™ã‚‹å‘¼ã³å‡ºã—ã«ã‚ˆã£ã¦ä½œã‚Šå‡ºã•ã‚Œã‚‹ã€ä¹±æ•°ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒã‚ã‚‹ã ã‘ã§ã‚ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_4124"></a><a name="%_idx_4126"></a>(define random-numbers
  (cons-stream random-init
               (stream-map rand-update random-numbers)))
</p>

<p class="orig" lang="en">
We use this to construct the stream of outcomes of the Ces&agrave;ro
experiment performed on consecutive pairs in the <tt>random-numbers</tt>
stream:</p>

<p class="trans" lang="ja">
ã“ã‚Œã‚’ä½¿ã£ã¦ã€ç§ãŸã¡ã¯ã€<tt>random-numbers</tt> ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®ä¸­ã®ã€é€£ç¶šã™ã‚‹å¯¾ã«å¯¾ã—ã¦è¡Œã‚ã‚Œã‚‹ã€Ces&agrave;ro ã®å®Ÿé¨“ã®çµæœã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’æ§‹ç¯‰ã™ã‚‹ã€‚
</p>


<p class="lisp"><a name="%_idx_4128"></a>(define cesaro-stream
  (map-successive-pairs (lambda (r1 r2) (= (gcd r1 r2) 1))
                        random-numbers))

<a name="%_idx_4130"></a>(define (map-successive-pairs f s)
  (cons-stream
   (f (stream-car s) (stream-car (stream-cdr s)))
   (map-successive-pairs f (stream-cdr (stream-cdr s)))))
</p>

<p class="orig" lang="en">
The <tt>cesaro-stream</tt> is now fed to a <tt>monte-carlo</tt> procedure,
which produces a stream of estimates of probabilities.  The results
are then converted into a stream of estimates of <img src="book-Z-G-D-9.gif" border="0">.  This version
of the program doesn't need a parameter telling how many trials to
perform.  Better estimates of <img src="book-Z-G-D-9.gif" border="0"> (from performing more experiments)
are obtained by looking farther into the <tt>pi</tt> stream:</p>

<p class="trans" lang="ja">
ã•ã¦ä»Šã‚„ã€<tt>cesaro-stream</tt> ã¯ã€<tt>monte-carlo</tt> ã®æ‰‹ç¶šãâ€”â€”ç¢ºç‡ã®æ¨å®šå€¤ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½œã‚Šå‡ºã™â€”â€”ã¸ã¨ä¸ãˆã‚‰ã‚Œã‚‹ã€‚
ãã‚Œã‹ã‚‰ã€çµæœãŒã€&pi; ã®æ¨å®šå€¤ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¸ã¨å¤‰æ›ã•ã‚Œã‚‹ã€‚
ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ã“ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯ã€è©¦è¡Œã‚’ä½•å›ãŠã“ãªã†ã®ã‹ã‚’çŸ¥ã‚‰ã›ã‚‹ãƒ‘ãƒ©ãƒ¡ã‚¿ã‚’å¿…è¦ã¨ã—ãªã„ã€‚
(ã‚ˆã‚Šå¤šãã®å®Ÿé¨“ã‚’è¡Œã†ã“ã¨ã«ã‚ˆã‚‹) &pi; ã®ã‚ˆã‚Šè‰¯ã„æ¨å®šå€¤ã¯ã€<tt>pi</tt> ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ã‚‚ã£ã¨å…ˆã¾ã§è¦‹ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€å¾—ã‚‰ã‚Œã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_4132"></a>(define (monte-carlo experiment-stream passed failed)
  (define (next passed failed)
    (cons-stream
     (/ passed (+ passed failed))
     (monte-carlo
      (stream-cdr experiment-stream) passed failed)))
  (if (stream-car experiment-stream)
      (next (+ passed 1) failed)
      (next passed (+ failed 1))))

(define pi
  (stream-map (lambda (p) (sqrt (/ 6 p)))
              (monte-carlo cesaro-stream 0 0)))
</p>

<p class="orig" lang="en">
<a name="%_idx_4134"></a>There is considerable modularity in this approach, because we still
can formulate a general <tt>monte-carlo</tt> procedure that can deal with
arbitrary experiments.  Yet there is no assignment or local state.</p>

<p class="trans" lang="ja">
ã“ã®æ‰‹æ³•ã«ã¯ã€æ³¨ç›®ã«å€¤ã™ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ€§ãŒã‚ã‚‹ã€‚ã¨ã„ã†ã®ã‚‚ã€ä¾ç„¶ã¨ã—ã¦ç§ãŸã¡ã¯ã€ä»»æ„ã®å®Ÿé¨“ã‚’æ‰±ãˆã‚‹ä¸€èˆ¬çš„ãª <tt>monte-carlo</tt> ã®æ‰‹ç¶šãã‚’ã€å®šå¼åŒ–ã§ãã‚‹ã‹ã‚‰ã§ã‚ã‚‹ã€‚
ã—ã‹ã—ã€<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã‚‚å±€æ‰€çŠ¶æ…‹ã‚‚å­˜åœ¨ã—ãªã„ã®ã ã€‚
</p>


<p class="orig" lang="en"><a name="%_thm_3.81"></a>
<b>Exercise 3.81.</b>  <a name="%_idx_4136"></a>Exercise <a href="20_sec3_1.html#%_thm_3.6">3.6</a>
discussed generalizing the random-number generator to
allow one to reset the random-number sequence so as to produce
repeatable sequences of ``random'' numbers.  Produce a stream
formulation of this same generator that operates on an input stream of
requests to <tt>generate</tt> a new random number or to <tt>reset</tt> the
sequence to a specified value and that produces the desired stream of
random numbers.  Don't use assignment in your solution.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.81.</b> ã€Œãƒ©ãƒ³ãƒ€ãƒ ãªã€æ•°ã®åå¾©å¯èƒ½ãªåˆ—ã‚’ä½œã‚Šå‡ºã™ãŸã‚ã«äººãŒä¹±æ•°åˆ—ã‚’ãƒªã‚»ãƒƒãƒˆã™ã‚‹ã“ã¨ã‚’å¯èƒ½ã¨ã™ã‚‹ã‚ˆã†ã€ä¹±æ•°ç”Ÿæˆå™¨ã‚’ä¸€èˆ¬åŒ–ã™ã‚‹ã“ã¨ã«ã¤ã„ã¦ã€ç·´ç¿’å•é¡Œ<a href="20_sec3_1.html#%_thm_3.6">3.6</a>ã§è«–ã˜ãŸã€‚
ã“ã®åŒã˜ç”Ÿæˆå™¨ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ çš„ãªå®šå¼åŒ–ã§ã‚ã£ã¦ã€æ–°ãŸãªä¹±æ•°ã‚’ç”Ÿæˆã™ã‚‹ (<tt>generate</tt>) ãŸã‚ã€ã¾ãŸã¯ã€æŒ‡å®šã•ã‚ŒãŸå€¤ã«åˆ—ã‚’ãƒªã‚»ãƒƒãƒˆã™ã‚‹ (<tt>reset</tt>) ãŸã‚ã®è¦æ±‚ã‹ã‚‰ãªã‚‹å…¥åŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«å¯¾ã—ã¦å‹•ä½œã—ã€ã‹ã¤ã€ä¹±æ•°ã‹ã‚‰ãªã‚‹æ‰€æœ›ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½œã‚Šå‡ºã™ã‚‚ã®ã‚’ã€ä½œã‚Šå‡ºã›ã€‚
å›ã®è§£æ±ºç­–ã®ä¸­ã§ã¯ã€<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã‚’ä½¿ã£ã¦ã¯ãªã‚‰ãªã„ã€‚
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.82"></a>
<b>Exercise 3.82.</b>  <a name="%_idx_4138"></a><a name="%_idx_4140"></a><a name="%_idx_4142"></a>Redo exercise <a href="20_sec3_1.html#%_thm_3.5">3.5</a> on Monte Carlo
integration in terms of streams.  The stream version of <tt>estimate-integral</tt> will not have an argument telling how many trials
to perform.  Instead, it will produce a stream of estimates based on
successively more trials.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.82.</b> ãƒ¢ãƒ³ãƒ†ã‚«ãƒ«ãƒ­ç©åˆ†ã«é–¢ã™ã‚‹ç·´ç¿’å•é¡Œ<a href="20_sec3_1.html#%_thm_3.5">3.5</a>ã‚’ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®è¦³ç‚¹ã‹ã‚‰ã€ã‚„ã‚Šç›´ã›ã€‚
<tt>estimate-integral</tt> ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ç‰ˆã¯ã€è©¦è¡Œã‚’ä½•å›è¡Œã†ã‹ã‚’çŸ¥ã‚‰ã›ã‚‹å¼•æ•°ã‚’æŒãŸãªã„ã ã‚ã†ã€‚
<tt>estimate-integral</tt> ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ç‰ˆã¯ã€ä»£ã‚ã‚Šã«ã€é€£ç¶šã—ãŸæ›´ãªã‚‹è©¦è¡Œã«ã‚‚ã¨ã¥ãæ¨å®šå€¤ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½œã‚Šå‡ºã™ã ã‚ã†ã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_Temp_503"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_503">A functional-programming view of time</a></h4>
<h4 class="trans" lang="ja">æ™‚é–“ã«ã¤ã„ã¦ã®é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã§ã®è¦‹æ–¹</h4>

<p class="orig" lang="en">
<a name="%_idx_4144"></a><a name="%_idx_4146"></a>
Let us now return to the issues of objects and state that were raised
at the beginning of this chapter and examine them in a new light.  We
introduced assignment and mutable objects to provide a mechanism for
modular construction of programs that model systems with state.
We constructed computational
objects with local state variables and used assignment to modify these
variables.  We modeled the temporal behavior of the objects in the
world by the temporal behavior of the corresponding computational
objects.</p>

<p class="trans" lang="ja">
ã•ã¦ã€æœ¬ç« ã®å§‹ã‚ã«æèµ·ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨çŠ¶æ…‹ã®å•é¡Œã«æˆ»ã£ã¦ã€ã“ã‚Œã‚‰ã®å•é¡Œã‚’æ–°ãŸãªè¦³ç‚¹ã‹ã‚‰åŸå‘³ã—ã‚ˆã†ã€‚
ç§ãŸã¡ã¯ã€çŠ¶æ…‹ã‚’æœ‰ã™ã‚‹<ruby><rb>ç³»</rb><rp> (</rp><rt>ã‚·ã‚¹ãƒ†ãƒ </rt><rp>) </rp></ruby>ã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã™ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ€§ã®ã‚ã‚‹æ§‹ç¯‰ã®ãŸã‚ã®ä»•çµ„ã¿ã‚’æä¾›ã™ã‚‹ãŸã‚ã«ã€<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã¨å¤‰æ›´å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å°å…¥ã—ãŸã€‚
ç§ãŸã¡ã¯ã€å±€æ‰€çŠ¶æ…‹å¤‰æ•°ã‚’æœ‰ã™ã‚‹ã€è¨ˆç®—æ©Ÿä¸Šã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ§‹ç¯‰ã—ã€ã“ã‚Œã‚‰ã®å¤‰æ•°ã‚’å¤‰æ›´ã™ã‚‹ãŸã‚ã«ã€<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã‚’ç”¨ã„ãŸã€‚
ç§ãŸã¡ã¯ã€ä¸–ç•Œã®ä¸­ã§ã®<ruby><rb>ç‰©</rb><rp> (</rp><rt>ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ</rt><rp>) </rp></ruby>ã®æ™‚é–“çš„ãªæŒ¯ã‚‹èˆã„ã‚’ã€ãã‚Œã«å¯¾å¿œã™ã‚‹è¨ˆç®—æ©Ÿä¸Šã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ™‚é–“çš„ãªæŒ¯ã‚‹èˆã„ã«ã‚ˆã£ã¦ã€ãƒ¢ãƒ‡ãƒ«åŒ–ã—ãŸã€‚
</p>

<p class="orig" lang="en">
Now we have seen that streams provide an alternative way to model
objects with local state.  We can model a changing quantity, such as
the local state of some object, using a stream that represents the
time history of successive states.  In essence, we represent time
explicitly, using streams, so that we decouple time in our simulated
world from the sequence of events that take place during evaluation.
Indeed, because of the presence of <tt>delay</tt> there may be little
relation between simulated time in the model and the order of events
during the evaluation.</p>

<p class="trans" lang="ja">
ã•ã¦ã€ç§ãŸã¡ã¯ã€å±€æ‰€çŠ¶æ…‹ã‚’æœ‰ã™ã‚‹<ruby><rb>ç‰©</rb><rp> (</rp><rt>ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ</rt><rp>) </rp></ruby>ã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã™ã‚‹ãŸã‚ã®ä»£ã‚ã‚Šã®æ–¹æ³•ã‚’ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒä¸ãˆã¦ãã‚Œã‚‹ã®ã ã€ã¨ã„ã†ã“ã¨ã‚’è¦‹ã¦ããŸã¨ã“ã‚ã§ã‚ã‚‹ã€‚
ä½•ã‚‰ã‹ã®<ruby><rb>ç‰©</rb><rp> (</rp><rt>ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ</rt><rp>) </rp></ruby>ã®å±€æ‰€çŠ¶æ…‹ãªã©ã¨ã„ã£ãŸã€å¤‰åŒ–ã—ã¦ã„ã‚‹é‡ã‚’ã€ç§ãŸã¡ã¯ã€é€£ç¶šã™ã‚‹çŠ¶æ…‹ã®æ™‚é–“å±¥æ­´ã‚’è¡¨ã™ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ç”¨ã„ã¦ãƒ¢ãƒ‡ãƒ«åŒ–ã§ãã‚‹ã€‚
æœ¬è³ªçš„ã«ã¯ã€ç§ãŸã¡ã¯ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½¿ã£ã¦æ™‚é–“ã‚’æ˜ç¤ºçš„ã«è¡¨ç¾ã—ã€ã™ã‚‹ã¨ãã®çµæœã€ç§ãŸã¡ã¯ã€ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã•ã‚ŒãŸä¸–ç•Œã«ãŠã‘ã‚‹æ™‚é–“ã‚’ã€è©•ä¾¡ã®é–“ã«èµ·ã“ã‚‹å‡ºæ¥äº‹ã®ä¸¦ã³ã‹ã‚‰ã€åˆ‡ã‚Šé›¢ã™ã“ã¨ã«ãªã‚‹ã€‚
å®Ÿéš›ã€<tt>delay</tt> ã®å­˜åœ¨ã®ãŠã‹ã’ã§ã€ãƒ¢ãƒ‡ãƒ«å†…ã§ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã•ã‚ŒãŸæ™‚é–“ã¨ã€è©•ä¾¡ã®é–“ã®å‡ºæ¥äº‹ã®é †åºã¨ã®é–“ã«ã¯ã€ã»ã¨ã‚“ã©é–¢ä¿‚ãŒãªã„ã“ã¨ã‚‚ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
In order to contrast these two approaches to modeling, let us
reconsider the implementation of a ``withdrawal processor'' that
<a name="%_idx_4148"></a>monitors the balance in a bank account.  In
section <a href="20_sec3_1.html#%_sec_3.1.3">3.1.3</a> we implemented a simplified
version of such a processor:</p>

<p class="trans" lang="ja">
ãƒ¢ãƒ‡ãƒ«åŒ–ã«å¯¾ã™ã‚‹ã“ã‚Œã‚‰äºŒã¤ã®å–ã‚Šçµ„ã¿æ–¹ã‚’å¯¾æ¯”ã™ã‚‹ãŸã‚ã«ã€éŠ€è¡Œå£åº§ã®æ®‹é«˜ã‚’ç›£è¦–ã™ã‚‹ã€Œå¼•ãå‡ºã—å‡¦ç†å™¨ã€ã®å®Ÿè£…ã«ã¤ã„ã¦ã€ã‚‚ã†ä¸€åº¦è€ƒãˆã‚ˆã†ã€‚
<a href="20_sec3_1.html#%_sec_3.1.3">3.1.3</a>ç¯€ã§ã¯ã€ãã†ã—ãŸå‡¦ç†å™¨ã®ç°¡å˜åŒ–ã•ã‚ŒãŸãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’å®Ÿè£…ã—ãŸã€‚
</p>

<p class="lisp"><a name="%_idx_4150"></a>(define (make-simplified-withdraw balance)
  (lambda (amount)
    (set! balance (- balance amount))
    balance))
</p>

<p class="orig" lang="en">
Calls to <tt>make-simplified-withdraw</tt> produce computational objects,
each with a local state variable <tt>balance</tt> that is decremented by
successive calls to the object.  The object takes an <tt>amount</tt> as
an argument and returns the new balance.  We can imagine the user of a
bank account typing a sequence of inputs to such an object and
observing the sequence of returned values shown on a display screen.</p>

<p class="trans" lang="ja">
<tt>make-simplified-withdraw</tt> ã«å¯¾ã™ã‚‹å‘¼ã³å‡ºã—ã¯ã€è¨ˆç®—æ©Ÿä¸Šã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œã‚Šå‡ºã—ã€ãã‚Œã‚‰ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å„ã€…ã¯ã€å½“è©²ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã™ã‚‹å¾Œç¶šã®å‘¼ã³å‡ºã—ã«ã‚ˆã£ã¦æ¸›ã‚‰ã•ã‚Œã‚‹ã€<tt>balance</tt> (æ®‹é«˜) ã¨ã„ã†å±€æ‰€çŠ¶æ…‹å¤‰æ•°ã‚’æœ‰ã™ã‚‹ã€‚
ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å¼•æ•°ã¨ã—ã¦ <tt>amount</tt> ã‚’ã¨ã‚Šã€æ–°ãŸãªæ®‹é«˜ã‚’è¿”ã™ã€‚
ãã†ã„ã†ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å…¥åŠ›åˆ—ã‚’ã‚¿ã‚¤ãƒ—ã—ã¦ã€ãƒ‡ã‚£ã‚¹ãƒ—ãƒ¬ã‚¤ã®ç”»é¢ä¸Šã«ç¤ºã•ã‚Œã‚‹è¿”ã‚Šå€¤ã®åˆ—ã‚’è¦³å¯Ÿã™ã‚‹ã€éŠ€è¡Œå£åº§ã®åˆ©ç”¨è€…ã‚’ã€ç§ãŸã¡ã¯æƒ³åƒã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
</p>

<p class="orig" lang="en">
Alternatively, we can model a withdrawal processor as a procedure that
takes as input a balance and a stream of amounts to withdraw and
produces the stream of successive balances in the account:</p>

<p class="trans" lang="ja">
ã‚ã‚‹ã„ã¯ã€æ®‹é«˜ã¨ã€å¼•ãå‡ºã™ã¹ãé‡‘é¡ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¨ã‚’å…¥åŠ›ã¨ã—ã¦ã¨ã‚Šã€ãã®å£åº§ã«ãŠã‘ã‚‹é€£ç¶šã™ã‚‹æ®‹é«˜ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½œã‚Šå‡ºã™ã‚ˆã†ãªæ‰‹ç¶šãã¨ã—ã¦ã€ç§ãŸã¡ã¯ã€å¼•ãå‡ºã—å‡¦ç†å™¨ã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã§ãã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_4152"></a>(define (stream-withdraw balance amount-stream)
  (cons-stream
   balance
   (stream-withdraw (- balance (stream-car amount-stream))
                    (stream-cdr amount-stream))))
</p>

<p class="orig" lang="en">
<tt>Stream-withdraw</tt> implements a well-defined mathematical function whose
output is fully determined by its input.  Suppose, however, that the
input <tt>amount-stream</tt> is the stream of successive values typed by
the user and that the resulting stream of balances is displayed.
Then, from the perspective of the user who is typing values and
watching results, the stream process has the same behavior as the
object created by <tt>make-simplified-withdraw</tt>.  However, with the
stream version, there is no assignment, no local state variable, and
consequently none of the theoretical difficulties that we encountered
<a name="%_idx_4154"></a>in section <a href="20_sec3_1.html#%_sec_3.1.3">3.1.3</a>.  Yet the system has state!</p>

<p class="trans" lang="ja">
<tt>stream-withdraw</tt> ã¯ã€ãã®å‡ºåŠ›ãŒå®Œå…¨ã«å…¥åŠ›ã«ã‚ˆã£ã¦å®šã‚ã‚‰ã‚Œã‚‹ã‚ˆã†ãªã€ã†ã¾ãå®šç¾©ã•ã‚ŒãŸæ•°å­¦çš„é–¢æ•°ã§ã‚ã‚‹ã€‚
ã—ã‹ã—ã€<tt>amount-stream</tt> ã¨ã„ã†å…¥åŠ›ãŒã€ãƒ¦ãƒ¼ã‚¶ã«ã‚ˆã£ã¦ã‚¿ã‚¤ãƒ—ã•ã‚ŒãŸé€£ç¶šã™ã‚‹å€¤ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã§ã‚ã‚Šã€ã‹ã¤ã€çµæœã¨ã—ã¦ç”Ÿã˜ã‚‹æ®‹é«˜ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒè¡¨ç¤ºã•ã‚Œã‚‹ã€ã¨ä»®å®šã—ã‚ˆã†ã€‚
ã™ã‚‹ã¨ã€å€¤ã‚’ã‚¿ã‚¤ãƒ—ã—ã¦çµæœã‚’è¦‹ã¦ã„ã‚‹ãƒ¦ãƒ¼ã‚¶ã®è¦³ç‚¹ã‹ã‚‰ã™ã‚‹ã¨ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ãƒ»ãƒ—ãƒ­ã‚»ã‚¹ã¯ã€<tt>make-simplified-withdraw</tt> ã«ã‚ˆã‚Šä½œæˆã•ã‚Œã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨åŒã˜æŒ¯ã‚‹èˆã„ã‚’è¦‹ã›ã‚‹ã€‚
ã—ã‹ã—ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ç‰ˆã‚’ä½¿ã†ã¨ã€<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ãŒãªãã€å±€æ‰€çŠ¶æ…‹å¤‰æ•°ãŒãªãã€ã—ãŸãŒã£ã¦ã€ç§ãŸã¡ãŒ<a href="20_sec3_1.html#%_sec_3.1.3">3.1.3</a>ç¯€ã§é­é‡ã—ãŸç†è«–ä¸Šã®å›°é›£ãŒä½•ã‚‚ãªã„ã€‚
ãã‚Œã§ã‚‚ã‚·ã‚¹ãƒ†ãƒ ã«ã¯çŠ¶æ…‹ãŒã‚ã‚‹!
</p>

<p class="orig" lang="en">
This is really remarkable.  Even though <tt>stream-withdraw</tt> implements a
well-defined mathematical function whose behavior does not change, the
user's perception here is one of interacting with a system that has a
changing state.  One way to resolve this paradox is to realize that it
is the user's temporal existence that imposes state on the system.  If
the user could step back from the interaction and think in terms of
streams of balances rather than individual transactions, the system
would appear stateless.<a name="call_footnote_Temp_504" href="#footnote_Temp_504"><sup><small>73</small></sup></a></p>

<p class="trans" lang="ja">
ã“ã‚Œã¯ã€ã¾ã“ã¨ã«ã‚‚ã£ã¦é©šãã¹ãã“ã¨ã ã€‚
<tt>stream-withdraw</tt> ãŒã€æŒ¯ã‚‹èˆã„ã®å¤‰ã‚ã‚‰ãªã„ã€ã‚ˆãå®šç¾©ã•ã‚ŒãŸæ•°å­¦çš„é–¢æ•°ã‚’å®Ÿè£…ã—ã¦ã„ã¦ã•ãˆã€ã“ã“ã§ã®ãƒ¦ãƒ¼ã‚¶ã®èªè­˜ã¯ã€å¤‰åŒ–ã™ã‚‹çŠ¶æ…‹ã‚’æœ‰ã™ã‚‹ã‚·ã‚¹ãƒ†ãƒ ã¨ç›¸äº’ä½œç”¨ã—ã¦ã„ã‚‹ã€ã¨ã„ã†ã‚‚ã®ãªã®ã ã€‚
ã“ã®çŸ›ç›¾ã‚’è§£ãä¸€ã¤ã®æ–¹æ³•ã¯ã€ã‚·ã‚¹ãƒ†ãƒ ã«å¯¾ã—ã¦çŠ¶æ…‹ã‚’æŠ¼ã—ã¤ã‘ã‚‹ã®ã¯ãƒ¦ãƒ¼ã‚¶ã®æ™‚é–“çš„å­˜åœ¨ãªã®ã ã€ã¨ã„ã†ã“ã¨ã‚’å®Ÿç¾ã™ã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚
ã‚‚ã—ã€ãƒ¦ãƒ¼ã‚¶ãŒç›¸äº’ä½œç”¨ã‹ã‚‰ä¸€æ­©æˆ»ã£ã¦ã€å€‹ã€…ã®å–å¼•ã¨ã„ã†ã‚ˆã‚Šã‚‚ã‚€ã—ã‚æ®‹é«˜ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®è¦³ç‚¹ã‹ã‚‰è€ƒãˆã‚‹ã“ã¨ãŒã§ããŸãªã‚‰ã€ã‚·ã‚¹ãƒ†ãƒ ã¯çŠ¶æ…‹ãªã—ã«è¦‹ãˆãŸã“ã¨ã ã‚ã†ã€‚
</p>

<p class="orig" lang="en">
From the point of view of one part of a complex process, the other
parts appear to change with time.  They have hidden time-varying local
state.  If we wish to write programs that model this kind of natural
decomposition in our world (as we see it from our viewpoint as a part of
that world) with
structures in our computer, we make computational objects that are not
functional -- they must change with time.  We model state with local
state variables, and we model the changes of state with assignments to
those variables.  By doing this we make the time of execution of a
computation model time in the world that we are part of, and thus we
get ``objects'' in our computer.</p>

<p class="trans" lang="ja">
è¤‡é›‘ãªã‚·ã‚¹ãƒ†ãƒ ã®ä¸€ã¤ã®éƒ¨åˆ†ã¨ã„ã†è¦³ç‚¹ã‹ã‚‰ã™ã‚‹ã¨ã€æ®‹ã‚Šã®éƒ¨åˆ†ã¯ã€æ™‚ã¨ã¨ã‚‚ã«å¤‰åŒ–ã™ã‚‹ã‚ˆã†ã«è¦‹ãˆã‚‹ã€‚
ãã‚Œã‚‰æ®‹ã‚Šã®éƒ¨åˆ†ã¯ã€çµŒæ™‚å¤‰åŒ–ã™ã‚‹å±€æ‰€çŠ¶æ…‹ã‚’éš ã—ãŸã®ã ã€‚
ã‚‚ã—ã€ä¸–ç•Œã«ãŠã‘ã‚‹ã“ã®ç¨®ã®è‡ªç„¶ãªåˆ†è§£ã‚’ (ãã®ä¸–ç•Œã®ä¸€éƒ¨ã¨ã—ã¦ã®ç§ãŸã¡ã®è¦–ç‚¹ã‹ã‚‰ã€ç§ãŸã¡ãŒãã®åˆ†è§£ã‚’è¦‹ã¦ã„ã‚‹ã¨ãŠã‚Šã«) ãƒ¢ãƒ‡ãƒ«åŒ–ã™ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿å†…ã®æ§‹é€ ç‰©ã‚’ä½¿ã£ã¦æ›¸ããŸã‘ã‚Œã°ã€ç§ãŸã¡ã¯ã€é–¢æ•°å‹ã§ã¯ãªã„è¨ˆç®—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆâ€”â€”ãã‚Œã‚‰ã¯æ™‚ã¨ã¨ã‚‚ã«å¤‰åŒ–ã™ã‚‹ã«é•ã„ãªã„â€”â€”ã‚’ä½œã‚‹ã€‚
ç§ãŸã¡ã¯ã€å±€æ‰€çŠ¶æ…‹å¤‰æ•°ã§çŠ¶æ…‹ã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã™ã‚‹ã—ã€ãã‚Œã‚‰ã®å¤‰æ•°ã¸ã®<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã§çŠ¶æ…‹ã®å¤‰åŒ–ã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã™ã‚‹ã€‚
ã“ã†ã™ã‚‹ã“ã¨ã§ã€ç§ãŸã¡ã¯ã€ç§ãŸã¡ãŒãã®ä¸€éƒ¨ã‚’ãªã—ã¦ã„ã‚‹ä¸–ç•Œã«ãŠã‘ã‚‹è¨ˆç®—ãƒ¢ãƒ‡ãƒ«æ™‚é–“ã®å®Ÿè¡Œã®æ™‚é–“ã‚’ä½œã‚‹ã®ã ã—ã€ã‚ˆã£ã¦ã€ç§ãŸã¡ã®ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿å†…ã®ã€Œã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ã‚’å¾—ã‚‹ã®ã§ã‚ã‚‹ã€‚<span class="note">(ãªã‚“ã‹ã„ã¾ã„ã¡ãªè¨³ã ãª)</span>
</p>

<p class="orig" lang="en">
Modeling with objects is powerful and intuitive, largely because this
matches the perception of interacting with a world of which we are
part.  However, as we've seen repeatedly throughout this chapter,
these models raise thorny problems of constraining the order of events
and of synchronizing multiple processes.  The possibility of avoiding
these problems has stimulated the development of <a name="%_idx_4158"></a><a name="%_idx_4160"></a><em>functional
programming languages</em>, which do not include any provision for
assignment or mutable data.  In such a language, all procedures
implement well-defined mathematical functions of their arguments,
whose behavior does not change.  The functional approach is extremely
<a name="%_idx_4162"></a><a name="%_idx_4164"></a>attractive for dealing with concurrent systems.<a name="call_footnote_Temp_505" href="#footnote_Temp_505"><sup><small>74</small></sup></a></p>

<p class="trans" lang="ja">
ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½¿ã†ãƒ¢ãƒ‡ãƒ«åŒ–ã¯å¼·åŠ›ã§ç›´è¦³çš„ã ãŒã€ãã‚Œã¯ä¸»ã«ã€ç§ãŸã¡ãŒãã®ä¸€éƒ¨ã‚’ãªã—ã¦ã„ã‚‹ä¸–ç•Œã¨ç›¸äº’ä½œç”¨ã—ã¦ã„ã‚‹ã®ã ã¨ã„ã†èªè­˜ã¨ã€ã“ã®ãƒ¢ãƒ‡ãƒ«åŒ–ã¨ãŒã€é©åˆã—ã¦ã„ã‚‹ã‹ã‚‰ã§ã‚ã‚‹ã€‚
ã—ã‹ã—ã€æœ¬ç« ã‚’é€šã—ã¦ãšã£ã¨ç¹°ã‚Šè¿”ã—è¦‹ã¦ããŸã¨ãŠã‚Šã€ã“ã†ã„ã†ãƒ¢ãƒ‡ãƒ«ã¯ã€å‡ºæ¥äº‹ã®é †åºã‚’åˆ¶ç´„ã™ã‚‹ã ã¨ã‹ã€è¤‡æ•°ã®ãƒ—ãƒ­ã‚»ã‚¹ã‚’åŒæœŸã•ã›ã‚‹ã ã¨ã‹ã®ã€å„ä»‹ãªå•é¡Œã‚’å¼•ãèµ·ã“ã™ã€‚
ã“ã‚Œã‚‰ã®å•é¡Œã‚’å›é¿ã™ã‚‹ã¨ã„ã†å¯èƒ½æ€§ãŒã€<em>é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èª</em>â€”â€”<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã‚‚ã—ãã¯å¤‰æ›´å¯èƒ½ãªãƒ‡ãƒ¼ã‚¿ã«ã¤ã„ã¦ã®æº–å‚™ã‚’ä½•ã‚‚å«ã¾ãªã„â€”â€”ã®é–‹ç™ºã‚’åˆºæ¿€ã—ã¦ããŸã€‚
ãã†ã—ãŸè¨€èªã§ã¯ã€ã™ã¹ã¦ã®æ‰‹ç¶šãã¯ã€ãã®æ‰‹ç¶šãã®å¼•æ•°ã®ã€ã‚ˆãå®šç¾©ã•ã‚ŒãŸæ•°å­¦çš„é–¢æ•°ã‚’å®Ÿè£…ã—ã¦ãŠã‚Šã€ãã®æ‰‹ç¶šãã®æŒ¯ã‚‹èˆã„ã¯å¤‰åŒ–ã—ãªã„ã€‚
é–¢æ•°å‹ã®æ‰‹æ³•ã¯ã€ä¸¦è¡Œã‚·ã‚¹ãƒ†ãƒ ã‚’æ‰±ã†ã®ã«æ¥µã‚ã¦é­…åŠ›çš„ã§ã‚ã‚‹<a href="#footnote_Temp_505"><sup><small>74</small></sup></a>ã€‚
</p>

<p class="orig" lang="en">
On the other hand, if we look closely, we can see time-related
problems creeping into functional models as well.  One particularly
troublesome area arises when we wish to design interactive systems,
especially ones that model interactions between independent entities.
For instance, consider once more the implementation a banking system
that permits joint bank accounts.  In a conventional system using
assignment and objects, we would model the fact that Peter and Paul
share an account by having both Peter and Paul send their transaction
requests to the same bank-account object, as we saw in
section <a href="20_sec3_1.html#%_sec_3.1.3">3.1.3</a>.
From the stream point of view, where there are no ``objects'' <em>per
se</em>, we have already indicated that a bank account can be modeled as a
process that operates on a stream of transaction requests to produce a
stream of responses.  Accordingly, we could model the fact that Peter
and Paul have a joint bank account by merging Peter's stream of
transaction requests with Paul's stream of requests and feeding the
result to the bank-account stream process, as shown in
figure <a href="#%_fig_3.38">3.38</a>.</p>

<p class="trans" lang="ja">
ä¸€æ–¹ã§ã€ã‚‚ã—ã‚ˆãè¦‹ã‚‹ãªã‚‰ã°ã€ç§ãŸã¡ã¯ã€æ™‚é–“ã«é–¢é€£ã™ã‚‹å•é¡ŒãŒé–¢æ•°å‹ã®ãƒ¢ãƒ‡ãƒ«ã«ã‚‚åŒæ§˜ã«å…¥ã‚Šè¾¼ã‚“ã§ã„ã‚‹ã®ã‚’è¦‹ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
ç‰¹ã«é¢å€’ãªä¸€ã¤ã®åˆ†é‡ã¯ã€å¯¾è©±å‹ã‚·ã‚¹ãƒ†ãƒ â€”â€”ã¨ã‚Šã‚ã‘ã€ç‹¬ç«‹ã—ãŸå®Ÿä½“é–“ã®ã‚„ã‚Šã¨ã‚Šã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã™ã‚‹ã‚‚ã®â€”â€”ã‚’è¨­è¨ˆã—ãŸã„ã¨æ€ã†ã¨ãã«ã€ç”Ÿã˜ã‚‹ã€‚
ãŸã¨ãˆã°ã€å…±åŒéŠ€è¡Œå£åº§ã‚’è¨±ã™éŠ€è¡Œã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…ã‚’ã€ã‚‚ã†ä¸€åº¦ã€è€ƒãˆã‚ˆã†ã€‚
<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½¿ã†å¾“æ¥ã®ã‚·ã‚¹ãƒ†ãƒ ã§ã¯ã€<a href="20_sec3_1.html#%_sec_3.1.3">3.1.3</a>ç¯€ã§è¦‹ãŸã¨ãŠã‚Šã€ãƒ”ãƒ¼ã‚¿ãƒ¼ã¨ãƒãƒ¼ãƒ«ã®ä¸¡äººã«å¯¾ã—ã¦ã€è‡ªåˆ†ã®å–å¼•è¦æ±‚ã‚’åŒã˜éŠ€è¡Œå£åº§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã¨é€ã‚‰ã›ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€ç§ãŸã¡ã¯ã€ãƒ”ãƒ¼ã‚¿ãƒ¼ã¨ãƒãƒ¼ãƒ«ãŒå£åº§ã‚’å…±æœ‰ã—ã¦ã„ã‚‹ã¨ã„ã†äº‹å®Ÿã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã—ãŸã§ã‚ã‚ã†ã€‚
ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®è¦³ç‚¹â€”â€”ã€Œã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ãã®ã‚‚ã®ãŒãªã„ã¨ã“ã‚â€”â€”ã‹ã‚‰ã€ç§ãŸã¡ã¯æ—¢ã«ã€ã“ã†æŒ‡æ‘˜ã—ãŸã€‚ã™ãªã‚ã¡ã€å–å¼•è¦æ±‚ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«å¯¾ã—ã¦å‹•ä½œã—ã¦ã€å¿œç­”ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ä½œã‚Šå‡ºã™ã‚ˆã†ãªæ‰‹ç¶šãã¨ã—ã¦ã€éŠ€è¡Œå£åº§ã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã§ãã‚‹ã®ã ã€ã¨ã€‚
ã—ãŸãŒã£ã¦ã€ãƒ”ãƒ¼ã‚¿ãƒ¼ã¨ãƒãƒ¼ãƒ«ãŒå…±åŒéŠ€è¡Œå£åº§ã‚’æŒã£ã¦ã„ã‚‹ã¨ã„ã†äº‹å®Ÿã‚’ã€ç§ãŸã¡ã¯ã€å›³<a href="#%_fig_3.38">3.38</a>ã«ç¤ºã™ã‚ˆã†ã«ã€ãƒ”ãƒ¼ã‚¿ãƒ¼ã®å–å¼•è¦æ±‚ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¨ãƒãƒ¼ãƒ«ã®å–å¼•è¦æ±‚ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¨ã‚’åˆä½µã—ã€ãã®çµæœã‚’éŠ€è¡Œå£åº§ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ãƒ»ãƒ—ãƒ­ã‚»ã‚¹ã«ä¸ãˆã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€ãƒ¢ãƒ‡ãƒ«åŒ–ã§ãã‚‹ã ã‚ã†ã€‚
</p>

<a name="%_fig_3.38"></a>
<figure>
<img src="ch3-Z-G-60.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.38:</b>  A joint bank account, modeled by merging two streams of
transaction requests.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³3.38:</b> å–å¼•è¦æ±‚ã®äºŒã¤ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’åˆä½µã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ãƒ¢ãƒ‡ãƒ«åŒ–ã•ã‚Œã‚‹ã€å…±åŒå£åº§</figcaption>
<a name="%_idx_4176"></a>
</figure>

<p class="orig" lang="en">
<a name="%_idx_4178"></a>The trouble with this formulation is in the notion of <em>merge</em>.  It
will not do to merge the two streams by simply taking alternately one
request from Peter and one request from Paul. Suppose Paul accesses
the account only very rarely.  We could hardly force Peter to wait for
Paul to access the account before he could issue a second transaction.
However such a merge is implemented, it must interleave the two
transaction streams in some way that is constrained by ``real
time'' as perceived by Peter and Paul, in the sense that, if Peter and
Paul meet, they can agree that certain transactions were processed
before the meeting, and other transactions were processed after the
meeting.<a name="call_footnote_Temp_506" href="#footnote_Temp_506"><sup><small>75</small></sup></a>
This is precisely the same constraint that we had to deal with in
section <a href="23_sec3_4.html#%_sec_3.4.1">3.4.1</a>, where we found the need to introduce
explicit synchronization to ensure a ``correct'' order of events in
concurrent processing of objects with state.  Thus, in an attempt to
support the functional style, the need to merge inputs from different
agents reintroduces the same problems that the functional style was
meant to eliminate.</p>

<p class="trans" lang="ja">
ã“ã®å®šå¼åŒ–ã«é–¢ã™ã‚‹å•é¡Œã¯ã€<em><ruby><rb>åˆä½µ</rb><rp> (</rp><rt>ãƒãƒ¼ã‚¸</rt><rp>) </rp></ruby></em>ã®æ¦‚å¿µã®ä¸­ã«ã‚ã‚‹ã€‚
å˜ç´”ã«ã€ãƒ”ãƒ¼ã‚¿ãƒ¼ã‹ã‚‰ã®ä¸€ã¤ã®è¦æ±‚ã¨ã€ãƒãƒ¼ãƒ«ã‹ã‚‰ã®ä¸€ã¤ã®è¦æ±‚ã¨ã‚’äº¤äº’ã«å–ã‚Šã‚ã’ã‚‹ã“ã¨ã§ã€äºŒã¤ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’åˆä½µã™ã‚‹ã®ã§ã¯ã€ã†ã¾ãã„ã‹ãªã„ã ã‚ã†ã€‚
ãƒãƒ¼ãƒ«ãŒéå¸¸ã«ç¨€ã«ã—ã‹å£åº§ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ãªã„ã‚‚ã®ã¨ä»®å®šã—ã‚ˆã†ã€‚
<!--ãƒãƒ¼ãƒ«ãŒäºŒåº¦ç›®ã®å–å¼•ã‚’ç™ºã™ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã¨ãã‚ˆã‚Šå‰ã«ã€ãƒ”ãƒ¼ã‚¿ãƒ¼ã«å¯¾ã—ã€ãƒãƒ¼ãƒ«ãŒå£åº§ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã®ã‚’ç„¡ç†ã‚„ã‚Šå¾…ãŸã›ã¦ãŠãã“ã¨ã¯ã€ã»ã¨ã‚“ã©ã§ããªã„-->
<!--he=Peter? Paul?-->
<!--ãƒãƒ¼ãƒ«ãŒå£åº§ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã®ã‚’ãƒ”ãƒ¼ã‚¿ãƒ¼ã«ç„¡ç†ã‚„ã‚Šå¾…ãŸã›ã¦ãŠã„ã¦ã€ãã‚Œã§ã‚„ã£ã¨ãƒ”ãƒ¼ã‚¿ãƒ¼ãŒäºŒåº¦ç›®ã®å–å¼•ã‚’ç™ºã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€ã¨ã„ã†ãµã†ã«ã™ã‚‹ã®ã¯ã€ã»ã¨ã‚“ã©ç„¡ç†ã§ã‚ã‚‹ã€‚-->
ãƒ”ãƒ¼ã‚¿ãƒ¼ã«ã¯ã€ãƒãƒ¼ãƒ«ãŒå£åº§ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã®ã‚’å¾…ã¤ã‚ˆã†ã«å¼·åˆ¶ã—ã¦ãŠã„ã¦ã€ãã†ãªã£ã¦ã‚„ã£ã¨ãƒ”ãƒ¼ã‚¿ãƒ¼ãŒäºŒåº¦ç›®ã®å–å¼•ã‚’ç™ºã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€ã¨ã„ã†ãµã†ã«ã™ã‚‹ã®ã¯ã€ã»ã¨ã‚“ã©ç„¡ç†ã§ã‚ã‚‹ã€‚
<span class="note">(ã¡ã‚‡ã£ã¨ã“ã®æ–‡ã®è¨³ã¯å¿ƒã‚‚ã¨ãªã„ã€‚)</span>
ã—ã‹ã—ã€ãã†ã„ã†åˆä½µã¯å®Ÿè£…ã•ã‚Œã‚‹ã—ã€ãã‚Œã¯ã€ãƒ”ãƒ¼ã‚¿ãƒ¼ã¨ãƒãƒ¼ãƒ«ã«ã‚ˆã‚Šèªè­˜ã•ã‚Œã‚‹ã¨ãŠã‚Šã®ã€Œå®Ÿæ™‚é–“ã€ã«ã‚ˆã‚Šåˆ¶ç´„ã•ã‚Œã‚‹â€”â€”ã‚‚ã—ãƒ”ãƒ¼ã‚¿ãƒ¼ã¨ãƒãƒ¼ãƒ«ãŒä¼šãˆã°ã€ã‚ã‚‹å–å¼•ã¯ãã®å‡ºä¼šã„ã®å‰ã«å‡¦ç†ã•ã‚Œã‚‹ã ã‚ã†ã—ã€ä»–ã®å–å¼•ã¯ãã®å‡ºä¼šã„ã®å¾Œã«å‡¦ç†ã•ã‚Œã‚‹ã ã‚ã†ã€ã¨ã„ã†ã“ã¨ã«äºŒäººãŒåŒæ„ã§ãã‚‹ã€ã¨ã„ã†æ„å‘³ã§ã‚ã‚‹â€”â€”ä½•ã‚‰ã‹ã®æ–¹æ³•ã§ã€äºŒã¤ã®å–å¼•ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’<ruby><rb>äº’ã„ã®é–“ã«æŒŸã¿è¾¼ã‚€</rb><rp> (</rp><rt>ã‚¤ãƒ³ã‚¿ãƒªãƒ¼ãƒ–ã™ã‚‹</rt><rp>) </rp></ruby>ã«é•ã„ãªã„<a href="#footnote_Temp_506"><sup><small>75</small></sup></a>ã€‚
ã“ã‚Œã¯ã€<a href="23_sec3_4.html#%_sec_3.4.1">3.4.1</a>ç¯€â€”â€”çŠ¶æ…‹ã‚’æœ‰ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä¸¦è¡Œå‡¦ç†ã«ãŠã‘ã‚‹ã€å‡ºæ¥äº‹ã®ã€Œæ­£ã—ã„ã€é †åºã‚’ä¿è¨¼ã™ã‚‹ãŸã‚ã®ã€æ˜ç¤ºçš„ãªåŒæœŸã‚’å°å…¥ã™ã‚‹å¿…è¦æ€§ã«æ°—ã¥ã„ãŸç®‡æ‰€ã§ã‚ã‚‹â€”â€”ã§ç§ãŸã¡ãŒæ‰±ã‚ã­ã°ãªã‚‰ãªã‹ã£ãŸã‚‚ã®ã¨ã€ã¾ã•ã«åŒã˜åˆ¶ç´„ã§ã‚ã‚‹ã€‚
ã‚ˆã£ã¦ã€é–¢æ•°å‹ã®æµå„€ã‚’ã‚µãƒãƒ¼ãƒˆã—ã‚ˆã†ã¨ã„ã†è©¦ã¿ã«ãŠã„ã¦ã¯ã€é–¢æ•°å‹ã®æµå„€ãŒæ’é™¤ã™ã‚‹ã“ã¨ã«ãªã£ã¦ã„ã‚‹ã¯ãšã®åŒã˜å•é¡ŒãŒã€ç•°ãªã‚‹<ruby><rb>å‹•ä½œä¸»</rb><rp> (</rp><rt>ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ</rt><rp>) </rp></ruby>ã‹ã‚‰ã®å…¥åŠ›ã‚’åˆä½µã›ã­ã°ãªã‚‰ãªã„ã¨ã„ã†å¿…è¦æ€§ã«ã‚ˆã£ã¦ã€å†ã³æŒã¡è¾¼ã¾ã‚Œã¦ã—ã¾ã†ã®ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
We began this chapter with the goal of building computational models
whose structure matches our perception of the real world we are trying
to model.  We can model the world as a collection of separate,
time-bound, interacting objects with state, or we can model the world
as a single, timeless, stateless unity.  Each view has powerful
advantages, but neither view alone is completely satisfactory.  A
grand unification has yet to emerge.<a name="call_footnote_Temp_507" href="#footnote_Temp_507"><sup><small>76</small></sup></a>
</p>

<p class="trans" lang="ja">
ç§ãŸã¡ãŒãƒ¢ãƒ‡ãƒ«åŒ–ã—ã‚ˆã†ã¨ã—ã¦ã„ã‚‹å®Ÿä¸–ç•Œã«ã¤ã„ã¦ã®ç§ãŸã¡ã®èªè­˜ã«ã€ãã®æ§‹é€ ãŒé©åˆã™ã‚‹ã‚ˆã†ãªè¨ˆç®—ãƒ¢ãƒ‡ãƒ«ã‚’æ§‹ç¯‰ã™ã‚‹ã€ã¨ã„ã†ç›®æ¨™ã‹ã‚‰ã€ç§ãŸã¡ã¯æœ¬ç« ã‚’å§‹ã‚ãŸã€‚
ç§ãŸã¡ã¯ã€ç®‡ã€…åˆ¥ã€…ã®ã€æ™‚é–“ã«ç¸›ã‚‰ã‚ŒãŸã€äº’ã„ã«ä½œç”¨ã—ã‚ã†ã€çŠ¶æ…‹ã‚’ã¨ã‚‚ãªã£ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é›†ã¾ã‚Š<!--ç®‡ã€…åˆ¥ã€…ã§æ™‚é–“ã«ç¸›ã‚‰ã‚Œã¦ã„ã¦äº’ã„ã«ä½œç”¨ã—ã‚ã£ã¦ãŠã‚ŠçŠ¶æ…‹ã‚’æœ‰ã—ã¦ã„ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é›†ã¾ã‚Š-->ã¨ã—ã¦ã€ä¸–ç•Œã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã™ã‚‹ã“ã¨ã‚‚ã§ãã‚‹ã—ã€ã‚ã‚‹ã„ã¯ã€å”¯ä¸€ã®ã€æ™‚é–“ã‚‚çŠ¶æ…‹ã‚‚ãªã„å˜ä¸€ä½“ã¨ã—ã¦ã€ä¸–ç•Œã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã™ã‚‹ã“ã¨ã‚‚ã§ãã‚‹ã€‚
ãã‚Œãã‚Œã®è€ƒãˆæ–¹ã«ã¯å¼·åŠ›ãªåˆ©ç‚¹ãŒã‚ã‚‹ãŒã€ã©ã¡ã‚‰ã®è€ƒãˆæ–¹ã‚‚ã€ãã‚Œã®ã¿ã§ã¯ã€å®Œå…¨ã«æº€è¶³ã®ã„ãã‚‚ã®ã§ã¯ãªã„ã€‚
å¤§ã„ãªã‚‹çµ±ä¸€åŒ–ã¯ã€ã¾ã ç¾ã‚Œå‡ºã§ã¦ã„ãªã„ã®ã <a href="#footnote_Temp_507"><sup><small>76</small></sup></a>ã€‚
</p>

<a name="footnotes"></a>
<hr>

<p class="orig" lang="en"><a name="footnote_Temp_442" href="#call_footnote_Temp_442"><sup><small>52</small></sup></a> Physicists sometimes adopt this view by introducing the
<a name="%_idx_3728"></a>``world lines'' of particles as a device for reasoning about motion.
We've also already mentioned
(section <a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a>) that this is the
natural way to think about signal-processing systems.  We will explore
applications of streams to signal processing in
section <a href="#%_sec_3.5.3">3.5.3</a>.
</p>

<p class="trans" lang="ja">
ç‰©ç†å­¦è€…ã¯ã¨ãã©ãã€å‹•ãã«ã¤ã„ã¦ã®æ¨å®šã®ãŸã‚ã®æ‰‹æ®µã¨ã—ã¦ã®ã€ç²’å­ã®ã€Œä¸–ç•Œç·šã€ã‚’å°å…¥ã™ã‚‹ã“ã¨ã§ã€ã“ã®è¦‹æ–¹ã‚’æ¡ç”¨ã™ã‚‹ã€‚
ã“ã‚ŒãŒä¿¡å·å‡¦ç†ã‚·ã‚¹ãƒ†ãƒ ã«ã¤ã„ã¦è€ƒãˆã‚‹ãŸã‚ã®è‡ªç„¶ãªæ–¹æ³•ã ã€ã¨ã„ã†ã“ã¨ã‚‚ã€æ—¢ã«è¿°ã¹ãŸ (<a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a>ç¯€)ã€‚
<a href="#%_sec_3.5.3">3.5.3</a>ç¯€ã§ã¯ã€ä¿¡å·å‡¦ç†ã¸ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®å¿œç”¨ã‚’æ¤œè¨ã—ã‚ˆã†ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_443" href="#call_footnote_Temp_443"><sup><small>53</small></sup></a> Assume that we have a
predicate <tt>prime?</tt> (e.g., as in section <a href="11_sec1_2.html#%_sec_1.2.6">1.2.6</a>) that
tests for primality.
</p>

<p class="trans" lang="ja">
ç´ æ•°æ€§ã‚’è©¦ã™ã€(<a href="11_sec1_2.html#%_sec_1.2.6">1.2.6</a>ç¯€ã§ã®ã‚ˆã†ãª) <tt>prime?</tt> ã¨ã„ã†è¿°èªãŒã‚ã‚‹ã‚‚ã®ã¨ã—ã‚ˆã†ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_444" href="#call_footnote_Temp_444"><sup><small>54</small></sup></a> In the MIT implementation, <a name="%_idx_3752"></a><a name="%_idx_3754"></a><a name="%_idx_3756"></a><tt>the-empty-stream</tt> is the
same as the empty list <tt>'()</tt>, and <tt>stream-null?</tt> is the same
as <tt>null?</tt>.
</p>

<p class="trans" lang="ja">
MITã®å‡¦ç†ç³»ã§ã¯ã€<tt>the-empty-stream</tt> ã¯ç©ºãƒªã‚¹ãƒˆ <tt>'()</tt> ã¨åŒã˜ã§ã‚ã‚Šã€<tt>stream-null?</tt> ã¯ <tt>null?</tt> ã¨åŒã˜ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_445" href="#call_footnote_Temp_445"><sup><small>55</small></sup></a> This should bother you.  The fact that we are defining such
similar procedures for streams and lists indicates that we are missing some
underlying abstraction.  Unfortunately, in order to exploit this
abstraction, we will need to exert finer control over the process of
evaluation than we can at present.  We will discuss this point further
at the end of section <a href="#%_sec_3.5.4">3.5.4</a>.
In section <a href="27_sec4_2.html#%_sec_4.2">4.2</a>, we'll develop a framework that
unifies lists and streams.
</p>

<p class="trans" lang="ja">
ã“ã‚Œã¯å›ã‚’æ‚©ã¾ã›ã‚‹ã¯ãšã ã€‚
ã‚¹ãƒˆãƒªãƒ¼ãƒ ç”¨ã¨ãƒªã‚¹ãƒˆç”¨ã®ãã†ã—ãŸé¡ä¼¼ã®æ‰‹ç¶šãã‚’å®šç¾©ã—ã¦ã„ã‚‹ã¨ã“ã‚ã ã€ã¨ã„ã†äº‹å®Ÿã¯ã€æ ¹åº•ã«ã‚ã‚‹ä½•ã‚‰ã‹ã®æŠ½è±¡åŒ–ã‚’å–ã‚Šé€ƒãŒã—ã¦ã„ã‚‹ã¨ã“ã‚ã ã€ã¨ã„ã†ã“ã¨ã‚’ç¤ºã™ã€‚
<span class="note">(é¡ä¼¼ã®ã“ã¨ã‚’ç¹°ã‚Šè¿”ã—è¡Œã£ã¦ã„ã‚‹ã®ã¯ã€å…±é€šã®éƒ¨åˆ†ã‚’ã†ã¾ãæŠœãå‡ºã›ã¦ã„ãªã„è¨¼æ‹ ã ã‚ˆã€ã£ã¦ã„ã†æ„å‘³)</span>
ã‚ã„ã«ãã€ã“ã®æŠ½è±¡åŒ–ã‚’åˆ©ç”¨ã™ã‚‹ãŸã‚ã«ã¯ã€è©•ä¾¡ã®ãƒ—ãƒ­ã‚»ã‚¹ã«å¯¾ã—ã¦ã€ç›®ä¸‹ã®ã¨ã“ã‚å¯èƒ½ã§ã‚ã‚‹ã‚ˆã‚Šã‚‚æ›´ã«ç´°ã‹ã„åˆ¶å¾¡ã‚’åŠã¼ã™ã“ã¨ãŒå¿…è¦ã§ã‚ã‚ã†ã€‚
ã“ã®ç‚¹ã«ã¤ã„ã¦ã¯ã€<a href="#%_sec_3.5.4">3.5.4</a>ç¯€ã®æœ€å¾Œã§ã•ã‚‰ã«è­°è«–ã—ã‚ˆã†ã€‚
<a href="27_sec4_2.html#%_sec_4.2">4.2</a>ç¯€ã§ã¯ã€ãƒªã‚¹ãƒˆã¨ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’çµ±ä¸€ã™ã‚‹æ çµ„ã¿ã‚’é–‹ç™ºã—ã‚ˆã†ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_446" href="#call_footnote_Temp_446"><sup><small>56</small></sup></a> Although <tt>stream-car</tt> and
<a name="%_idx_3784"></a><a name="%_idx_3786"></a><tt>stream-cdr</tt> can be defined as procedures, <tt>cons-stream</tt> must
be a special form.  If <tt>cons-stream</tt> were a procedure, then,
according to our model of evaluation, evaluating <tt>(cons-stream
&lt;<em>a</em>&gt; &lt;<em>b</em>&gt;)</tt> would automatically cause &lt;<em>b</em>&gt; to be evaluated, which is
precisely what we do not want to happen.  For the same reason, <tt>delay</tt> must be a special form, though <tt>force</tt> can be an ordinary
procedure.
</p>

<p class="trans" lang="ja">
<tt>stream-car</tt> ã¨ <tt>stream-cdr</tt> ã¯æ‰‹ç¶šãã¨ã—ã¦å®šç¾©ã§ãã‚‹ãŒã€<tt>cons-stream</tt> ã¯ç‰¹æ®Šå½¢å¼ã§ãªã‘ã‚Œã°ãªã‚‰ãªã„ã€‚
ã‚‚ã— <tt>cons-stream</tt> ãŒæ‰‹ç¶šãã§ã‚ã£ãŸã¨ã—ãŸã‚‰ã€ç§ãŸã¡ã®è©•ä¾¡ã®ãƒ¢ãƒ‡ãƒ«ã«ã‚ˆã‚Œã°ã€
<tt>(cons-stream &lt;<em class="en">a</em>&gt; &lt;<em class="en">b</em>&gt;)</tt>
ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ã§ã€è‡ªå‹•çš„ã«ã€&lt;<em class="en">b</em>&gt; ã‚’è©•ä¾¡ã•ã›ã‚‹ã“ã¨ã«ãªã‚Šã€ãã‚Œã“ããŒã¾ã•ã«ã€èµ·ãã¦ã»ã—ããªã„ã€ã¨ç§ãŸã¡ãŒæ€ã†ã“ã¨ãªã®ã ã€‚
åŒã˜ç†ç”±ã§ã€<tt>delay</tt> ã¯ç‰¹æ®Šå½¢å¼ã§ãªã‘ã‚Œã°ãªã‚‰ãªã„â€”â€” <tt>force</tt> ã¯æ™®é€šã®æ‰‹ç¶šãã§ã‚ã£ã¦ã‚‚ã‚ˆã„ã®ã ã‘ã‚Œã©ã‚‚ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_448" href="#call_footnote_Temp_448"><sup><small>57</small></sup></a> The numbers shown here do
not really appear in the delayed expression.  What actually appears is
the original expression, in an environment in which the variables are
bound to the appropriate numbers.  For example, <tt>(+ low 1)</tt> with
<tt>low</tt> bound to 10,000 actually appears where <tt>10001</tt> is
shown.
</p>

<p class="trans" lang="ja">
ã“ã“ã«ç¤ºã—ãŸæ•°ã¯ã€é…å»¶ã•ã‚ŒãŸå¼ã®ä¸­ã«ç¾å®Ÿã«ç¾ã‚Œã‚‹ã“ã¨ã¯ãªã„ã€‚
å®Ÿéš›ã«ç¾ã‚Œã‚‹ã‚‚ã®ã¯ã€å¤‰æ•°ãŒé©åˆ‡ãªæ•°ã«æŸç¸›ã•ã‚Œã¦ã„ã‚‹ç’°å¢ƒã«ãŠã‘ã‚‹ã€å…ƒã®å¼ã§ã‚ã‚‹ã€‚
ãŸã¨ãˆã°ã€<tt>low</tt> ãŒ 10,000 ã«æŸç¸›ã•ã‚Œã¦ã„ã‚‹çŠ¶æ…‹ã® <tt>(+ low 1)</tt> ã¯ã€å®Ÿéš›ã«ã¯ã€<tt>10001</tt> ãŒç¤ºã•ã‚Œã‚‹å ´æ‰€ã«ç¾ã‚Œã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_450" href="#call_footnote_Temp_450"><sup><small>58</small></sup></a> There are many
possible implementations of streams other than the one described in
this section.  Delayed evaluation, which is the key to making streams
practical, was inherent in <a name="%_idx_3806"></a><a name="%_idx_3808"></a>Algol 60's <em>call-by-name</em>
parameter-passing method.  The use of this mechanism to implement
streams was first described by <a name="%_idx_3810"></a>Landin (1965).  Delayed evaluation for
streams was introduced into Lisp by <a name="%_idx_3812"></a><a name="%_idx_3814"></a>Friedman and Wise (1976). In their
implementation, <tt>cons</tt> always delays evaluating its arguments, so
that lists automatically behave as streams.  The memoizing
optimization is also known as <a name="%_idx_3816"></a><a name="%_idx_3818"></a><a name="%_idx_3820"></a><a name="%_idx_3822"></a><em>call-by-need</em>.  The Algol community
would refer to our original delayed objects as <em>call-by-name
thunks</em> and to the optimized versions as <em>call-by-need thunks</em>.
</p>

<p class="trans" lang="ja">
æœ¬ç¯€ã§è¿°ã¹ãŸä»¥å¤–ã«ã‚‚ã€å¯èƒ½ãªã‚¹ãƒˆãƒªãƒ¼ãƒ ã®å®Ÿè£…ãŒå¤šãã‚ã‚‹ã€‚
é…å»¶è©•ä¾¡â€”â€”ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å®Ÿç”¨çš„ãªã‚‚ã®ã¨ã™ã‚‹ãŸã‚ã®éµã§ã‚ã‚‹â€”â€”ã¯ã€Algol 60ã®<em>åå‰ã«ã‚ˆã‚‹å‘¼ã³å‡ºã—</em>ã«ã‚ˆã‚‹ãƒ‘ãƒ©ãƒ¡ã‚¿æ¸¡ã—ã®æ–¹æ³•ã«å†…åœ¨ã™ã‚‹ã‚‚ã®ã§ã‚ã‚‹ã€‚
ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã«ã“ã®ä»•çµ„ã¿ã‚’ä½¿ã†ã“ã¨ã¯ã€Landin (1965) ã«ã‚ˆã‚Šæœ€åˆã«è¨˜è¿°ã•ã‚ŒãŸã€‚
ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®ãŸã‚ã®é…å»¶è©•ä¾¡ã¯ã€Friedman and Wise (1976) ã«ã‚ˆã‚ŠLispã«å°å…¥ã•ã‚ŒãŸã€‚
ã‹ã‚Œã‚‰ã®å®Ÿè£…ã§ã¯ã€<tt>cons</tt> ã¯å¸¸ã«ã€å¼•æ•°ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ã‚’é…ã‚‰ã›ã¦ãŠã‚Šã€ãã®çµæœã€ãƒªã‚¹ãƒˆã¯è‡ªå‹•çš„ã«ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¨ã—ã¦æŒ¯ã‚‹èˆã†ã€‚
ãƒ¡ãƒ¢åŒ–ã®æœ€é©åŒ–ã¯ã€<em>å¿…è¦ã«ã‚ˆã‚‹å‘¼ã³å‡ºã—</em>ã¨ã—ã¦ã‚‚çŸ¥ã‚‰ã‚Œã‚‹ã€‚
Algolç•Œã ã£ãŸã‚‰ã€ç§ãŸã¡ã®å…ƒã€…ã®é…å»¶ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã“ã¨ã‚’<em>åå‰ã«ã‚ˆã‚‹å‘¼ã³å‡ºã—ã®ã‚µãƒ³ã‚¯</em>ã¨å‘¼ã‚“ã ã“ã¨ã ã‚ã†ã—ã€æœ€é©åŒ–ã—ãŸãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®ã“ã¨ã¯<em>å¿…è¦ã«ã‚ˆã‚‹å‘¼ã³å‡ºã—ã®ã‚µãƒ³ã‚¯</em>ã¨å‘¼ã‚“ã ã“ã¨ã ã‚ã†ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_453" href="#call_footnote_Temp_453"><sup><small>59</small></sup></a> Exercises such as <a href="#%_thm_3.51">3.51</a> and <a href="#%_thm_3.52">3.52</a>
are valuable for testing our understanding of how <tt>delay</tt> works.
On the other hand, intermixing delayed evaluation with printing -- and,
even worse, with assignment -- is extremely confusing, and instructors
of courses on computer languages have traditionally tormented their
students with examination questions such as the ones in this section.
Needless to say, writing programs that depend on such subtleties is
<a name="%_idx_3828"></a>odious programming style.  Part of the power of stream processing is
that it lets us ignore the order in which events actually happen in
our programs.  Unfortunately, this is precisely what we cannot afford
to do in the presence of assignment, which forces us to be concerned
with time and change.
</p>

<p class="trans" lang="ja">
ç·´ç¿’å•é¡Œ<a href="#%_thm_3.51">3.51</a>ã‚„ç·´ç¿’å•é¡Œ<a href="#%_thm_3.52">3.52</a>ã®ã‚ˆã†ãªç·´ç¿’å•é¡Œã¯ã€<tt>delay</tt> ãŒã©ã®ã‚ˆã†ã«å‹•ä½œã™ã‚‹ã‹ã€ã¨ã„ã†ã“ã¨ã«ã¤ã„ã¦ã®ã€ç§ãŸã¡ã®ç†è§£ã‚’è©¦ã™å½¹ã«ç«‹ã¤ã€‚
ä¸€æ–¹ã€é…å»¶è©•ä¾¡ã‚’å°å­—ã¨æ··ãœã“ãœã«ã™ã‚‹ã“ã¨â€”â€”ãã—ã¦ã€ã•ã‚‰ã«æ‚ªã„ã“ã¨ã«ã¯ã€<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã¨æ··ãœã“ãœã«ã™ã‚‹ã“ã¨â€”â€”ã¯ã€ã¨ã¦ã‚‚æ··ä¹±ã‚’æ‹›ãã‚‚ã®ã ã—ã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿è¨€èªã«ã¤ã„ã¦ã®èª²ç¨‹ã®æŒ‡å°è€…ã¯ã€ä¼çµ±çš„ã«ã€æœ¬ç¯€ã«ã‚ã‚‹ã‚ˆã†ãªè©¦é¨“å•é¡Œã§å­¦ç”Ÿã‚’ã²ã©ãè‹¦ã—ã‚ã¦ããŸã€‚
è¨€ã†ã¾ã§ã‚‚ãªãã€ãã†ã—ãŸå¾®å¦™ã•ã«ä¾å­˜ã™ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ãã“ã¨ã¯ã€ä¸æ„‰å¿«æ¥µã¾ã‚Šãªã„ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®æµå„€ã§ã‚ã‚‹ã€‚
ã‚¹ãƒˆãƒªãƒ¼ãƒ å‡¦ç†ã®èƒ½åŠ›ã®ä¸€éƒ¨ã¯ã€<!--è‡ªåˆ†ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ãŠã„ã¦å‡ºæ¥äº‹ãŒå®Ÿéš›ã«èµ·ã“ã‚‹é †åºã‚’ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ å‡¦ç†ã¯ç§ãŸã¡ã«ç„¡è¦–ã•ã›ã¦ãã‚Œã‚‹ã€--><!--ã‚¹ãƒˆãƒªãƒ¼ãƒ å‡¦ç†ãŒç§ãŸã¡ã«ã€è‡ªåˆ†ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ãŠã„ã¦å‡ºæ¥äº‹ãŒå®Ÿéš›ã«èµ·ã“ã‚‹é †åºã‚’ç„¡è¦–ã•ã›ã¦ãã‚Œã‚‹ã€-->ã‚¹ãƒˆãƒªãƒ¼ãƒ å‡¦ç†ã®ãŠã‹ã’ã§ç§ãŸã¡ãŒã€è‡ªåˆ†ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ãŠã„ã¦å‡ºæ¥äº‹ãŒå®Ÿéš›ã«èµ·ã“ã‚‹é †åºã‚’ç„¡è¦–ã§ãã‚‹ã€ã¨ã„ã†ç‚¹ãªã®ã ã€‚
ã‚ã„ã«ãã€ã“ã‚Œã¯ã¾ã•ã«ã€<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>â€”â€”ç§ãŸã¡ã‚’ç„¡ç†ã‚„ã‚Šæ™‚é–“ã¨å¤‰åŒ–ã«æ³¨æ„ã‚’å‘ã‘ã‚‹ã‚ˆã†ã«ã•ã›ã‚‹ã‚‚ã®â€”â€”ãŒã‚ã‚‹ã¨å‡ºæ¥ãªã„ã“ã¨ãªã®ã ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_455" href="#call_footnote_Temp_455"><sup><small>60</small></sup></a> Eratosthenes, a third-century <font size=-2>B</font>.<font size=-2>C</font>.
<a name="%_idx_3846"></a><a name="%_idx_3848"></a>Alexandrian Greek philosopher, is famous for giving the first accurate
estimate of the circumference of the Earth, which he computed by
observing shadows cast at noon on the day of the summer solstice.
Eratosthenes's sieve method, although ancient, has formed the basis
for special-purpose hardware ``sieves'' that, until recently, were the
most powerful tools in existence for locating large primes.  Since the
70s, however, these methods have been superseded by outgrowths of the
<a name="%_idx_3850"></a>probabilistic techniques discussed in section <a href="11_sec1_2.html#%_sec_1.2.6">1.2.6</a>.

</p>

<p class="trans" lang="ja">
ã‚¨ãƒ©ãƒˆã‚¹ãƒ†ãƒã‚¹â€”â€”ç´€å…ƒå‰3ä¸–ç´€ã®ã‚¢ãƒ¬ã‚¯ã‚µãƒ³ãƒ‰ãƒªã‚¢ã®ã‚®ãƒªã‚·ãƒ£äººå“²å­¦è€…â€”â€”ã¯ã€åœ°çƒã®å‘¨å›²ã®æœ€åˆã®æ­£ç¢ºãªæ¨å®šå€¤â€”â€”ã“ã‚Œã‚’å½¼ã¯ã€å¤è‡³ã®æ—¥ã®æ­£åˆã«æŠ•ã’ã‹ã‘ã‚‰ã‚Œã‚‹å½±ã‚’è¦³å¯Ÿã™ã‚‹ã“ã¨ã§ã€è¨ˆç®—ã—ãŸâ€”â€”ã‚’ä¸ãˆãŸã“ã¨ã§ã€æœ‰åã§ã‚ã‚‹ã€‚
æœ€è¿‘ã¾ã§ã¯å¤§ããªç´ æ•°ã‚’çªãæ­¢ã‚ã‚‹ãŸã‚ã®ç¾å­˜ã™ã‚‹æœ€ã‚‚å¼·åŠ›ãªæ‰‹æ®µã§ã‚ã£ãŸã€ã€Œç¯©ã€ã¨ã„ã†ç‰¹æ®Šç”¨é€”ã®ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ã®åŸºç¤ã‚’ã€ã‚¨ãƒ©ãƒˆã‚¹ãƒ†ãƒã‚¹ã®ç¯©ã®æ‰‹æ³•ã¯ã€æ—§ãã¯ã‚ã‚‹ã‚‚ã®ã®ã€å½¢ã¥ãã£ã¦ããŸã®ã ã€‚
ã—ã‹ã—ã€70å¹´ä»£ã‹ã‚‰ã€ã“ã‚Œã‚‰ã®æ–¹æ³•ã¯ã€<a href="11_sec1_2.html#%_sec_1.2.6">1.2.6</a>ç¯€ã§è­°è«–ã—ãŸç¢ºç‡çš„æŠ€æ³•ã«å–ã£ã¦ä»£ã‚ã‚‰ã‚ŒãŸã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_456" href="#call_footnote_Temp_456"><sup><small>61</small></sup></a> We have named these figures after <a name="%_idx_3858"></a>Peter Henderson, who
was the first person to show us diagrams of this sort as a way of
thinking about stream processing.  Each solid line represents a stream
of values being transmitted.  The dashed line from the <tt>car</tt> to
the <tt>cons</tt> and the <tt>filter</tt> indicates that this is a single
value rather than a stream.
</p>

<p class="trans" lang="ja">
ãƒ”ãƒ¼ã‚¿ãƒ¼ãƒ»ãƒ˜ãƒ³ãƒ€ãƒ¼ã‚½ãƒ³â€”â€”ã“ã®ç¨®ã®å›³ã‚’ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ å‡¦ç†ã«ã¤ã„ã¦è€ƒãˆã‚‹ãŸã‚ã®æ–¹æ³•ã¨ã—ã¦ã€æœ€åˆã«ç§ãŸã¡ã«è¦‹ã›ã¦ãã‚ŒãŸäººâ€”â€”ã«ã¡ãªã‚“ã§ã€ã“ã‚Œã‚‰ã®å›³ã‚’åã¥ã‘ãŸã€‚
å„å®Ÿç·šã¯ã€é€ä¿¡ã•ã‚Œã‚‹å€¤ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’è¡¨ã—ã¦ã„ã‚‹ã€‚
 <tt>car</tt> ã‹ã‚‰ <tt>cons</tt> ã¨ <tt>filter</tt> ã¸ã®ç ´ç·šã¯ã€ã“ã‚ŒãŒã‚¹ãƒˆãƒªãƒ¼ãƒ ã¨è¨€ã†ã‚ˆã‚Šã‚€ã—ã‚å˜ä¸€ã®å€¤ã§ã‚ã‚‹ã€ã¨ã„ã†ã“ã¨ã‚’ç¤ºã—ã¦ã„ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_458" href="#call_footnote_Temp_458"><sup><small>62</small></sup></a> This uses the generalized version
of <tt>stream-map</tt> from exercise <a href="#%_thm_3.50">3.50</a>.
</p>

<p class="trans" lang="ja">
ã“ã‚Œã¯ã€ç·´ç¿’å•é¡Œ<a href="#%_thm_3.50">3.50</a>ã§ã®ã€ä¸€èˆ¬åŒ–ã•ã‚ŒãŸãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®  <tt>stream-map</tt> ã‚’ä½¿ã£ã¦ã„ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_459" href="#call_footnote_Temp_459"><sup><small>63</small></sup></a> This last point is
very subtle and relies on the fact that <em>p</em><sub><em>n</em>+1</sub> <u>&lt;</u> <em>p</em><sub><em>n</em></sub><sup>2</sup>.
(Here, <em>p</em><sub><em>k</em></sub> denotes the <em>k</em>th prime.)  Estimates such as these are
very difficult to establish.  The ancient proof by <a name="%_idx_3876"></a>Euclid that there
are an infinite number of primes shows that <em>p</em><sub><em>n</em>+1</sub><u>&lt;</u> <em>p</em><sub>1</sub> <em>p</em><sub>2</sub> 
<tt>&middot;&middot;&middot;</tt>   <em>p</em><sub><em>n</em></sub>  + 1, and no substantially better result was proved
until 1851, when the Russian mathematician P. L. Chebyshev established
<a name="%_idx_3878"></a><a name="%_idx_3880"></a><a name="%_idx_3882"></a><a name="%_idx_3884"></a>that <em>p</em><sub><em>n</em>+1</sub><u>&lt;</u> 2<em>p</em><sub><em>n</em></sub> for all <em>n</em>.  This result, originally
conjectured in 1845, is known as <em>Bertrand's hypothesis</em>.  A proof
can be found in section 22.3 of Hardy and Wright 1960.
</p>

<p class="trans" lang="ja">
ã“ã®æœ€å¾Œã®ç‚¹ã¯ã€éå¸¸ã«å¾®å¦™ã§ã‚ã‚Šã€
<span class="math"><em class="en">p<sub>n+1</sub></em> &le; <em class="en">p<sub>n</sub><sup>2</sup></em></span>
ã¨ã„ã†äº‹å®Ÿã«é ¼ã£ã¦ã„ã‚‹ã€‚
(ã“ã“ã§ <em class="en">p<sub>k</sub></em> ã¯ <em class="en">k</em> ç•ªç›®ã®ç´ æ•°ã§ã‚ã‚‹ã€‚)
ã“ã®ã‚ˆã†ãªè¦‹ç©ã‚‚ã‚Šã¯ã€ç«‹è¨¼ã™ã‚‹ã®ãŒã¨ã¦ã‚‚é›£ã—ã„ã€‚
ç„¡é™å€‹ã®ç´ æ•°ãŒå­˜åœ¨ã™ã‚‹ã®ã ã¨ã„ã†ã€ãƒ¦ãƒ¼ã‚¯ãƒªãƒƒãƒ‰ã«ã‚ˆã‚‹å¤ä»£ã®è¨¼æ˜ã¯ã€
<span class="math"><em class="en">p<sub>n+1</sub></em> &le; 
<em class="en">p</em><sub>1</sub> <em class="en">p</em><sub>2</sub> 
&hellip;
<em class="en">p<sub>n</sub></em>  + 1</span>
ã¨ã„ã†ã“ã¨ã‚’ç¤ºã—ã¦ãŠã‚Šã€1851å¹´â€”â€”ãƒ­ã‚·ã‚¢ã®æ•°å­¦è€…ã® P. L. ãƒã‚§ãƒ“ã‚·ã‚§ãƒ•ãŒã€ã™ã¹ã¦ã® <em class="en">n</em> ã«ã¤ã„ã¦ <span class="math"><em class="en">p<sub>n+1</sub></em> &le; 2<em class="en">p<sub>n</sub></em></span> ã ã¨ç«‹è¨¼ã—ãŸâ€”â€”ã¾ã§ã¯ã€å®Ÿè³ªçš„ã«ã“ã‚Œã‚ˆã‚Šè‰¯ã„çµæœã¯è¨¼æ˜ã•ã‚Œã¦ã„ãªã‹ã£ãŸã€‚
ã“ã®çµæœã¯ã€ã‚‚ã¨ã‚‚ã¨ã¯1845å¹´ã«æ¨æ¸¬ã•ã‚Œã¦ã„ãŸã‚‚ã®ã§ã€<em>ãƒãƒ¼ãƒˆãƒ©ãƒ³ãƒ‰ã®ä»®èª¬</em>ã¨ã—ã¦çŸ¥ã‚‰ã‚Œã¦ã„ã‚‹ã€‚
Hardy and Wright 1960 ã®22.3ç¯€ã«ã€è¨¼æ˜ã‚’è¦‹å‡ºã™ã“ã¨ãŒã§ãã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_465" href="#call_footnote_Temp_465"><sup><small>64</small></sup></a> This exercise shows how call-by-need is closely related to
<a name="%_idx_3902"></a><a name="%_idx_3904"></a>ordinary memoization as described in exercise <a href="22_sec3_3.html#%_thm_3.27">3.27</a>.
In that exercise, we used assignment to explicitly construct a local
table.  Our call-by-need stream optimization effectively constructs
such a table automatically, storing values in the previously forced
parts of the stream.
</p>

<p class="trans" lang="ja">
ã“ã®ç·´ç¿’å•é¡Œã¯ã€å¿…è¦ã«ã‚ˆã‚‹å‘¼ã³å‡ºã—ãŒã€ç·´ç¿’å•é¡Œ<a href="22_sec3_3.html#%_thm_3.27">3.27</a>ã§èª¬æ˜ã—ãŸã‚ˆã†ãªæ™®é€šã®ãƒ¡ãƒ¢åŒ–ã¨ã€ã©ã®ã‚ˆã†ã«ã—ã¦å¯†æ¥ã«é–¢é€£ã¥ã‘ã‚‰ã‚Œã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’ç¤ºã—ã¦ã„ã‚‹ã€‚
ç·´ç¿’å•é¡Œ<a href="22_sec3_3.html#%_thm_3.27">3.27</a>ã§ã¯ã€å±€æ‰€çš„ãªè¡¨ã‚’æ˜ç¤ºçš„ã«æ§‹ç¯‰ã™ã‚‹ãŸã‚ã«ã€<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã‚’ä½¿ã£ãŸã€‚
ç§ãŸã¡ã®ã€å¿…è¦ã«ã‚ˆã‚‹å‘¼ã³å‡ºã—å¼ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ æœ€é©åŒ–ã¯ã€åŠ¹æœçš„ã«ã€ãã®ã‚ˆã†ãªè¡¨ã‚’è‡ªå‹•çš„ã«æ§‹ç¯‰ã—ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®ã†ã¡ã§ä»¥å‰ã«<ruby><rb>å¼·åˆ¶</rb><rp> (</rp><rt><tt>force</tt></rt><rp>) </rp></ruby>ã•ã‚ŒãŸéƒ¨åˆ†ã®å€¤ã‚’æ ¼ç´ã™ã‚‹ã€‚

</p>

<p class="orig" lang="en"><a name="footnote_Temp_472" href="#call_footnote_Temp_472"><sup><small>65</small></sup></a> We can't use <tt>let</tt> to bind the local variable
<tt>guesses</tt>, because the value of <tt>guesses</tt> depends on <tt>guesses</tt> itself.  Exercise <a href="#%_thm_3.63">3.63</a> addresses why
we want a local variable here.
</p>

<p class="trans" lang="ja">
<tt>guesses</tt> ã¨ã„ã†å±€æ‰€å¤‰æ•°ã‚’æŸç¸›ã™ã‚‹ãŸã‚ã« <tt>let</tt> ã‚’ä½¿ã†ã“ã¨ã¯ã§ããªã„ã€‚ãªãœãªã‚‰ã€<tt>guesses</tt> ã®å€¤ã¯ã€<tt>guesses</tt> è‡ªä½“ã«ä¾å­˜ã™ã‚‹ã‹ã‚‰ã§ã‚ã‚‹ã€‚
ç·´ç¿’å•é¡Œ<a href="#%_thm_3.63">3.63</a>ã¯ã€ãªãœç§ãŸã¡ãŒã“ã“ã§å±€æ‰€å¤‰æ•°ã‚’æ¬²ã—ã¦ã„ã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã«å–ã‚Šçµ„ã‚“ã§ã„ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_477" href="#call_footnote_Temp_477"><sup><small>66</small></sup></a> As in section <a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a>,
we represent a pair of integers as a list rather than a Lisp pair.
</p>

<p class="trans" lang="ja">
<a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a>ç¯€ã§ãã†ã—ãŸã®ã¨åŒæ§˜ã«ã€æ•´æ•°åŒå£«ã®å¯¾ã‚’ã€Lispã®å¯¾ã§ã¯ãªãã€ã‚€ã—ã‚ãƒªã‚¹ãƒˆã¨ã—ã¦ã€è¡¨ç¾ã—ã¦ã„ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_478" href="#call_footnote_Temp_478"><sup><small>67</small></sup></a> See exercise <a href="#%_thm_3.68">3.68</a> for some insight
into why we chose this decomposition.
</p>

<p class="trans" lang="ja">
ãªãœç§ãŸã¡ãŒã“ã®ã‚ˆã†ãªåˆ†è§£ã‚’é¸ã¶ã®ã‹ã€ã¨ã„ã†ã“ã¨ã«å¯¾ã™ã‚‹ã€ã„ãã°ãã‹ã®æ´å¯Ÿã®ãŸã‚ã«ã¯ã€ç·´ç¿’å•é¡Œ<a href="#%_thm_3.68">3.68</a>ã‚’å‚ç…§ã›ã‚ˆã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_479" href="#call_footnote_Temp_479"><sup><small>68</small></sup></a> The precise statement of the
required property on the order of combination is as follows: There
should be a function <em>f</em> of two arguments such that the pair
corresponding to element <em>i</em> of the first stream and element <em>j</em> of
the second stream will appear as element number <em>f</em>(<em>i</em>,<em>j</em>) of the output
stream.  The trick of using <tt>interleave</tt> to accomplish this was
shown to us by <a name="%_idx_3996"></a>David Turner, who employed it in the language <a name="%_idx_3998"></a>KRC
(Turner 1981).
</p>

<p class="trans" lang="ja">
çµåˆã®é †åºã«ã¤ã„ã¦è¦æ±‚ã•ã‚Œã‚‹æ€§è³ªã®æ­£ç¢ºãªé™³è¿°ã¯ã€ä»¥ä¸‹ã®é€šã‚Šã§ã‚ã‚‹ã€‚
ã™ãªã‚ã¡ã€ç¬¬1ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã® <em class="en">i</em> ã¨ã„ã†è¦ç´ ã¨ç¬¬2ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã® <em class="en">j</em> ã¨ã„ã†è¦ç´ ã«å¯¾å¿œã™ã‚‹å¯¾ãŒã€å‡ºåŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ ã® 
<em class="en">f</em>(<em class="en">i</em>, <em class="en">j</em>) 
ã¨ã„ã†è¦ç´ ç•ªå·ã¨ã—ã¦ç¾ã‚Œã‚‹ã‚ˆã†ã«ã€2å¼•æ•°ã® <em class="en">f</em> ã¨ã„ã†é–¢æ•°ãŒã€å­˜åœ¨ã™ã‚‹ã¯ãšã§ã‚ã‚‹ã€‚
ã“ã‚Œã‚’é”æˆã™ã‚‹ãŸã‚ã« <tt>interleave</tt> ã‚’ä½¿ã†ã¨ã„ã†æŠ€ã¯ã€ãƒ‡ã‚¤ãƒ“ãƒƒãƒ‰ãƒ»ã‚¿ãƒ¼ãƒŠâ€”â€”ã“ã®æŠ€ã‚’KRCã¨ã„ã†è¨€èªã§ä½¿ã£ãŸäººâ€”â€”ãŒç§ãŸã¡ã«ç¤ºã—ã¦ãã‚ŒãŸ (Turner 1981)ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_485" href="#call_footnote_Temp_485"><sup><small>69</small></sup></a> We will require that the weighting function be such that
the weight of a pair increases as we move out along a row or down
along a column of the array of pairs.
</p>

<p class="trans" lang="ja">
é‡ã¿ã¥ã‘é–¢æ•°ã¨ã¯ã€å¯¾ã®é…åˆ—ã®è¡Œã«æ²¿ã£ã¦å¤–ã¸ã€ã‚ã‚‹ã„ã¯ã€åˆ—ã«æ²¿ã£ã¦ä¸‹ã¸ã€ã¨å‹•ãã«ã¤ã‚Œã¦ã€å¯¾ã®é‡ã¿ãŒå¢—ã™ã‚ˆã†ãªã‚‚ã®ã§ã‚ã‚‹ã€ã¨ã„ã†ã“ã¨ã‚’ã€ç§ãŸã¡ã¯è¦è«‹ã™ã‚‹ã“ã¨ã«ãªã‚‹ã ã‚ã†ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_487" href="#call_footnote_Temp_487"><sup><small>70</small></sup></a> To quote from G. H. Hardy's obituary of
<a name="%_idx_4012"></a><a name="%_idx_4014"></a><a name="%_idx_4016"></a>Ramanujan (Hardy 1921): ``It was Mr. Littlewood (I believe) who remarked that
`every positive integer was one of his friends.'  I remember once
going to see him when he was lying ill at Putney.  I had ridden in
taxi-cab No. 1729, and remarked that the number seemed to me a rather
dull one, and that I hoped it was not an unfavorable omen.  `No,' he
replied, `it is a very interesting number; it is the smallest number
expressible as the sum of two cubes in two different ways.' ''
The trick of using weighted pairs to generate the Ramanujan numbers
was shown to us by Charles Leiserson.
</p>

<p class="trans" lang="ja">
G. H. ãƒãƒ¼ãƒ‡ã‚£ã«ã‚ˆã‚‹ãƒ©ãƒãƒŒã‚¸ãƒ£ãƒ³ã®æ­»äº¡è¨˜äº‹ (Hardy 1921) ã‹ã‚‰å¼•ç”¨ã™ã‚‹ã¨ã€
ã€Œã€ã©ã®æ­£æ•´æ•°ã‚‚å½¼ã®å‹é”ã®ä¸€äººã ã€ã¨è¿°ã¹ãŸã®ã¯ã€(ç§ãŒä¿¡ã˜ã‚‹ã¨ã“ã‚ã§ã¯) ãƒªãƒˆãƒ«ã‚¦ãƒƒãƒ‰æ°ã§ã‚ã£ãŸã€‚ãƒ‘ãƒƒãƒˆãƒ‹ãƒ¼ã§ãƒ©ãƒãƒŒã‚¸ãƒ£ãƒ³æ°ãŒç—…æ°—ã§å¯ã¦ã„ãŸã¨ãã«ã€å½¼ã«ä¸€åº¦ä¼šã„ã«è¡Œã£ãŸã“ã¨ã‚’ã€ç§ã¯è¦šãˆã¦ã„ã‚‹ã€‚ç§ã¯ã€ç•ªå·ãŒ1729ã®ã‚¿ã‚¯ã‚·ãƒ¼ã«ä¹—ã£ã¦ã€ãã—ã¦ã€ã“ã†è¿°ã¹ãŸâ€”â€”ã“ã®æ•°ã¯è‡ªåˆ†ã«ã¨ã£ã¦ã¯ã‹ãªã‚Šé€€å±ˆãªæ•°ã®ã‚ˆã†ã«è¦‹ãˆã‚‹ã‚“ã ãŒã€ã“ã‚ŒãŒè‰¯ããªã„äºˆå…†ã§ã¯ãªã„ã“ã¨ã‚’æœ›ã‚€ã‚ˆã€ã¨ã€‚å½¼ã¯ã€ã€é•ã„ã¾ã™ã€‚ã“ã‚Œã¯ã¨ã¦ã‚‚èˆˆå‘³æ·±ã„æ•°ã§ã™ã‚ˆã€‚ã“ã‚Œã¯ã€äºŒã¤ã®ç•°ãªã‚‹æ–¹æ³•ã§äºŒã¤ã®ç«‹æ³•æ•°ã®å’Œã¨ã—ã¦è¡¨ç¾å¯èƒ½ãªã€æœ€å°ã®æ•°ã§ã™ã‚ˆã€ã¨è¿”ç­”ã—ãŸã€‚ã€ã¨ã®ã“ã¨ã€‚
é‡ã¿ã¥ã‘ã•ã‚ŒãŸå¯¾ã‚’ã€ãƒ©ãƒãƒŒã‚¸ãƒ£ãƒ³æ•°ã‚’ç”Ÿæˆã™ã‚‹ãŸã‚ã«ä½¿ã†ã€ã¨ã„ã†æŠ€ã¯ã€ãƒãƒ£ãƒ¼ãƒ«ã‚ºãƒ»ãƒ©ã‚¤ã‚¶ãƒ¼ã‚¹ãƒ³ãŒç§ãŸã¡ã«ç¤ºã—ã¦ãã‚ŒãŸã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_494" href="#call_footnote_Temp_494"><sup><small>71</small></sup></a> This procedure is not guaranteed to work in all Scheme
implementations, although for any implementation there is a simple
variation that will work.  The problem has to do with subtle
differences in the ways that Scheme implementations handle internal
definitions.  (See section <a href="26_sec4_1.html#%_sec_4.1.6">4.1.6</a>.)
</p>

<p class="trans" lang="ja">
ã“ã®æ‰‹ç¶šãã¯ã€ã™ã¹ã¦ã®Schemeå‡¦ç†ç³»ã§ã†ã¾ãå‹•ãã¨ã¯ä¿è¨¼ã•ã‚Œã¦ã„ãªã„â€”â€”ã‚‚ã£ã¨ã‚‚ã€ã©ã®å‡¦ç†ç³»ã«ã¤ã„ã¦ã‚‚ã€ã†ã¾ãå‹•ãã§ã‚ã‚ã†ç°¡å˜ãªå¤‰ç¨®ãŒå­˜åœ¨ã™ã‚‹ã®ã§ã¯ã‚ã‚‹ãŒã€‚
ã“ã®å•é¡Œã¯ã€Schemeå‡¦ç†ç³»ãŒå†…éƒ¨å®šç¾©ã‚’æ‰±ã†æ–¹æ³•ã«ãŠã‘ã‚‹å¾®å¦™ãªå·®ç•°ã¨é–¢é€£ã—ã¦ã„ã‚‹ã€‚
(<a href="26_sec4_1.html#%_sec_4.1.6">4.1.6</a>ç¯€ã‚’å‚ç…§ã€‚)
</p>

<p class="orig" lang="en"><a name="footnote_Temp_500" href="#call_footnote_Temp_500"><sup><small>72</small></sup></a> This is a small reflection, in Lisp, of the difficulties
that conventional strongly typed languages such as <a name="%_idx_4096"></a><a name="%_idx_4098"></a><a name="%_idx_4100"></a><a name="%_idx_4102"></a><a name="%_idx_4104"></a>Pascal have in
coping with higher-order procedures.  In such languages, the
programmer must specify the data types of the arguments and the result
of each procedure: number, logical value, sequence, and so on.
Consequently, we could not express an abstraction such as ``map a
given procedure <tt>proc</tt> over all the elements in a sequence'' by a
single higher-order procedure such as <tt>stream-map</tt>.  Rather, we
would need a different mapping procedure for each different
combination of argument and result data types that might be specified
for a <tt>proc</tt>.  Maintaining a practical notion of ``data type'' in
the presence of higher-order procedures raises many difficult issues.
One way of dealing with this problem is illustrated by the language ML
<a name="%_idx_4106"></a><a name="%_idx_4108"></a><a name="%_idx_4110"></a><a name="%_idx_4112"></a>(Gordon, Milner, and Wadsworth 1979), whose ``polymorphic data types''
include templates for higher-order transformations between data types.
Moreover, data types for most procedures in ML are never explicitly
declared by the programmer.  Instead, ML includes a <a name="%_idx_4114"></a><em>type-inferencing</em> mechanism that uses information in the environment
to deduce the data types for newly defined procedures.
</p>

<p class="trans" lang="ja">
ã“ã‚Œã¯ã€Pascalã®ã‚ˆã†ãªå¾“æ¥ã®å¼·åŠ›ã«å‹ä»˜ã‘ã•ã‚Œã¦ã„ã‚‹è¨€èªãŒé«˜éšæ‰‹ç¶šãã«å¯¾å‡¦ã™ã‚‹éš›ã«æŠ±ãˆã‚‹å›°é›£ã®ã€Lispã«ãŠã‘ã‚‹ã•ã•ã‚„ã‹ãªåæ˜ ã§ã‚ã‚‹ã€‚
ãã†ã—ãŸè¨€èªã§ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒã¯ã€å„æ‰‹ç¶šãã®å¼•æ•°ã¨çµæœã®ãƒ‡ãƒ¼ã‚¿å‹â€”â€”æ•°ã€è«–ç†å€¤ã€åˆ—ã€ãªã©ãªã©â€”â€”ã‚’æŒ‡å®šã›ã­ã°ãªã‚‰ãªã„ã€‚
ãã®çµæœã€ã€Œåˆ—ã®ä¸­ã®ã™ã¹ã¦ã®è¦ç´ ã«å¯¾ã—ã¦ã€ä¸ãˆã‚‰ã‚ŒãŸ <tt>proc</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’é©ç”¨ã—ã¦å†™åƒã™ã‚‹ã€ã®ã‚ˆã†ãªæŠ½è±¡åŒ–ã‚’ã€<tt>stream-map</tt> ã®ã‚ˆã†ãªå˜ä¸€ã®é«˜éšæ‰‹ç¶šãã«ã‚ˆã£ã¦è¡¨ç¾ã™ã‚‹ã“ã¨ãŒã§ããªã‹ã£ãŸã€‚
ã‚€ã—ã‚ã€<tt>proc</tt> ã«å¯¾ã—ã¦æŒ‡å®šã•ã‚Œå¾—ã‚‹å¼•æ•°ã¨çµæœã®ãƒ‡ãƒ¼ã‚¿å‹ã®ã€ç•°ãªã‚‹çµ„ã¿åˆã‚ã›ãã‚Œãã‚Œã«å¯¾ã—ã¦ã€ç•°ãªã‚‹å†™åƒæ‰‹ç¶šãã‚’å¿…è¦ã¨ã—ãŸã ã‚ã†ã€‚
é«˜éšæ‰‹ç¶šãã®å­˜åœ¨ã™ã‚‹ã¨ã“ã‚ã§ã€ã€Œãƒ‡ãƒ¼ã‚¿å‹ã€ã«ã¤ã„ã¦ã®å®Ÿè·µçš„ãªæ¦‚å¿µã‚’ç¶­æŒã™ã‚‹ã“ã¨ã¯ã€å¤šãã®é›£ã—ã„å•é¡Œã‚’æèµ·ã™ã‚‹ã€‚
ã“ã®å•é¡Œã‚’æ‰±ã†ä¸€ã¤ã®æ–¹æ³•ã¯ã€MLè¨€èªã«ã‚ˆã‚Šä¾‹ç¤ºã•ã‚Œã¦ã„ã¦ (Gordon, Milner, and Wadsworth 1979)ã€MLè¨€èªã®ã€Œ<ruby><rb>å¤šæ…‹çš„</rb><rp> (</rp><rt>ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ãƒƒã‚¯</rt><rp>) </rp></ruby>ãƒ‡ãƒ¼ã‚¿å‹ã€ã¯ã€ãƒ‡ãƒ¼ã‚¿å‹åŒå£«ã®é–“ã®é«˜éšå¤‰æ›ã®ãŸã‚ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’å«ã‚“ã§ã„ã‚‹ã€‚
ã•ã‚‰ã«ã€MLã®ã»ã¨ã‚“ã©ã®æ‰‹ç¶šãã®ãƒ‡ãƒ¼ã‚¿å‹ã¯ã€æ±ºã—ã¦ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒã«ã‚ˆã‚Šæ˜ç¤ºçš„ã«å®£è¨€ã•ã‚Œã‚‹ã“ã¨ã¯ãªã„ã€‚
ä»£ã‚ã‚Šã«ã€MLã¯ã€ç’°å¢ƒå†…ã®æƒ…å ±ã‚’ä½¿ã£ã¦ã€æ–°ãŸã«å®šç¾©ã•ã‚ŒãŸæ‰‹ç¶šãã«ã¤ã„ã¦ã®å‹ã‚’æ¼”ç¹¹ã™ã‚‹ã€<em>å‹æ¨è«–</em>ã®ä»•çµ„ã¿ã‚’å‚™ãˆã¦ã„ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_504" href="#call_footnote_Temp_504"><sup><small>73</small></sup></a> Similarly in physics, when we observe a moving particle, we
say that the position (state) of the particle is changing.  However,
from the perspective of the particle's <a name="%_idx_4156"></a>world line in space-time there
is no change involved.
</p>

<p class="trans" lang="ja">
ç‰©ç†å­¦ã¨åŒæ§˜ã«ã€å‹•ãç²’å­ã‚’è¦³å¯Ÿã—ã¦ã„ã‚‹ã¨ãã€ç§ãŸã¡ã¯ã€ãã®ç²’å­ã®ä½ç½® (çŠ¶æ…‹) ãŒå¤‰åŒ–ã—ã¦ã„ã‚‹ã¨ã“ã‚ã§ã‚ã‚‹ã€ã¨è¨€ã†ã€‚
ã—ã‹ã—ã€æ™‚ç©ºé–“ã«ãŠã‘ã‚‹ç²’å­ã®ä¸–ç•Œç·šã¨ã„ã†è¦³ç‚¹ã‹ã‚‰ã¯ã€ä½•ã®å¤‰åŒ–ã‚‚ä¼´ã£ã¦ã„ãªã„ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_505" href="#call_footnote_Temp_505"><sup><small>74</small></sup></a> John Backus, the inventor of Fortran, gave high
<a name="%_idx_4166"></a><a name="%_idx_4168"></a><a name="%_idx_4170"></a><a name="%_idx_4172"></a><a name="%_idx_4174"></a>visibility to functional programming when he was awarded
the ACM Turing award in 1978.  His acceptance speech (Backus 1978)
strongly advocated the functional approach.  A good overview of
functional programming is given in Henderson 1980 and in Darlington,
Henderson, and Turner 1982.
</p>

<p class="trans" lang="ja">
ã‚¸ãƒ§ãƒ³ãƒ»ãƒãƒƒã‚«ã‚¹â€”â€”Fortranã®ç™ºæ˜è€…â€”â€”ã¯ã€1978å¹´ã«ACMã®ãƒãƒ¥ãƒ¼ãƒªãƒ³ã‚°è³ã‚’å—è³ã—ãŸã¨ãã«ã€é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã«å¯¾ã™ã‚‹é«˜åº¦ãªè¦–é‡ã‚’ä¸ãˆãŸã€‚
å½¼ã®å—è³ã‚¹ãƒ”ãƒ¼ãƒ (Backus 1978) ã¯ã€é–¢æ•°å‹ã®æ‰‹æ³•ã‚’å¼·ãä¸»å¼µã™ã‚‹ã‚‚ã®ã§ã‚ã£ãŸã€‚
é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã«ã¤ã„ã¦ã®è‰¯ã„æ¦‚è«–ã¯ã€Henderson 1980 ã‚„ã€Darlington,
Henderson, and Turner 1982 ã®ä¸­ã«ä¸ãˆã‚‰ã‚Œã¦ã„ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_506" href="#call_footnote_Temp_506"><sup><small>75</small></sup></a> Observe that, for any two streams, there is in general more than one
<a name="%_idx_4180"></a><a name="%_idx_4182"></a>acceptable order of interleaving.  Thus, technically, ``merge'' is a
relation rather than a function -- the answer is not a deterministic
function of the inputs.  We already mentioned
(footnote <a href="23_sec3_4.html#footnote_Temp_411">39</a>) that nondeterminism is
essential when dealing with concurrency.  The merge relation
illustrates the same essential nondeterminism, from the functional
perspective.  In section <a href="28_sec4_3.html#%_sec_4.3">4.3</a>, we
will look at nondeterminism from yet another point of view.
</p>

<p class="trans" lang="ja">
ä»»æ„ã®äºŒã¤ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«å¯¾ã—ã¦ã€ãŠäº’ã„ã‚’é–“ã«æŒŸã¿è¾¼ã‚€è¨±å®¹å¯èƒ½ãªé †åºãŒã€ä¸€èˆ¬ã«ã¯ä¸€ã¤ã‚ˆã‚Šã‚‚å¤šãå­˜åœ¨ã™ã‚‹ã€ã¨ã„ã†ã“ã¨ã«æ°—ã¥ã„ã¦ã»ã—ã„ã€‚
ã‚ˆã£ã¦ã€æŠ€è¡“çš„ã«ã¯ã€ã€Œåˆä½µã€ã¯é–¢æ•°ã§ã‚ã‚‹ã¨ã„ã†ã‚ˆã‚Šã‚‚é–¢ä¿‚ãªã®ã§ã‚ã‚‹â€”â€”ã¤ã¾ã‚Šã€ç­”ãˆã¯ã€å…¥åŠ›ã®æ±ºå®šè«–çš„é–¢æ•°ã§ã¯ãªã„ã®ã ã€‚
ä¸¦è¡Œæ€§ã‚’å–ã‚Šæ‰±ã†å ´åˆã«ã¯éæ±ºå®šè«–ãŒæœ¬è³ªçš„ã§ã‚ã‚‹ã€ã¨ã„ã†ã“ã¨ã‚’ã€ç§ãŸã¡ã¯æ—¢ã«è¿°ã¹ãŸ (è„šæ³¨<a href="23_sec3_4.html#footnote_Temp_411">39</a>)ã€‚
åˆä½µé–¢ä¿‚ã¯ã€åŒã˜æœ¬è³ªçš„éæ±ºå®šè«–ã‚’ã€é–¢æ•°å‹ã®è¦³ç‚¹ã‹ã‚‰ä¾‹ç¤ºã—ã¦ã„ã‚‹ã€‚
<a href="28_sec4_3.html#%_sec_4.3">4.3</a>ç¯€ã§ã¯ã€ã•ã‚‰ã«åˆ¥ã®è¦³ç‚¹ã‹ã‚‰éæ±ºå®šè«–ã«ã¤ã„ã¦ã‚ˆãè¦‹ã‚‹ã“ã¨ã«ã—ã‚ˆã†ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_507" href="#call_footnote_Temp_507"><sup><small>76</small></sup></a> The object model approximates the world by
dividing it into separate pieces.  The functional model does not
modularize along object boundaries.  The object model is useful when
<a name="%_idx_4184"></a>the unshared state of the ``objects'' is much larger than the state
that they share.  An example of a place where the object viewpoint
fails is <a name="%_idx_4186"></a>quantum
mechanics, where thinking of things as individual particles leads to
paradoxes and confusions.  Unifying the object view with the
functional view may have little to do with programming, but rather
with fundamental epistemological issues.
</p>

<p class="trans" lang="ja">
ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ¢ãƒ‡ãƒ«ã¯ã€ä¸–ç•Œã‚’åˆ¥ã€…ã®éƒ¨åˆ†ã¸ã¨åˆ†å‰²ã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€ä¸–ç•Œã‚’è¿‘ä¼¼ã™ã‚‹ã€‚
é–¢æ•°å‹ã®ãƒ¢ãƒ‡ãƒ«ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå¢ƒç•Œã«æ²¿ã£ã¦ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åŒ–ã™ã‚‹ã“ã¨ã¯ãªã„ã€‚
ã€Œã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ã®éå…±æœ‰çŠ¶æ…‹ãŒã€ãã‚Œã‚‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå…±æœ‰ã™ã‚‹çŠ¶æ…‹ã‚ˆã‚Šã‚‚ã€é¥ã‹ã«å¤šé‡ã§ã‚ã‚‹å ´åˆã«ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ¢ãƒ‡ãƒ«ã¯æœ‰ç”¨ã§ã‚ã‚‹ã€‚
ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®è¦–ç‚¹ãŒã†ã¾ãã„ã‹ãªã„å ´æ‰€ã®ä¾‹ã¯ã€é‡å­åŠ›å­¦ã§ã‚ã‚Šã€ãã“ã§ã¯ã€ç‰©äº‹ã‚’å€‹åˆ¥ã®ç²’å­ã¨ã—ã¦è€ƒãˆã‚‹ã“ã¨ãŒçŸ›ç›¾ã‚„æ··ä¹±ã«ã¤ãªãŒã‚‹ã€‚
ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆçš„ãªè¦‹æ–¹ã¨é–¢æ•°å‹ã®è¦‹æ–¹ã‚’çµ±ä¸€ã™ã‚‹ã“ã¨ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã¨ã¯ã»ã¨ã‚“ã©é–¢ä¿‚ãªã„ã‹ã‚‚ã—ã‚Œãšã€ã‚€ã—ã‚ã€æ ¹æœ¬çš„ãªèªè­˜è«–çš„å•é¡Œã¨é–¢ä¿‚ãŒã‚ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚
</p>

</div>

</body>
</html>
