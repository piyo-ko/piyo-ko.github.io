<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="sicp.css" type="text/css">
<base target="_top">
<title>SICP私訳: 3.5 ストリーム</title>
<link rel="canonical" href="https://piyo-ko.github.io/SICP/24_sec3_5.html" />
</head>
<body>

<div class="idx-bar">
<nav>
<a href="https://twitter.com/share" class="twitter-share-button" data-lang="ja">ツイート</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
<span class="status">推敲待ち</span>
[
<a href="00_cover.html">先頭へ</a> |
<a href="23_sec3_4.html">前へ</a> |
<a href="25_chap4.html">次へ</a> |
<a href="04_toc.html#%_toc_start">目次</a> |
<a href="38_index.html#%_index_start">索引</a>
] [<a href="99_about.html">この対訳版について</a> | <a href="../index.html">ホーム</a>]
[
§<a href="#%_sec_3.5">3.5</a>
§<a href="#%_sec_3.5.1">3.5.1</a>
📚<a href="#%_sec_Temp_447">&hellip;</a>
📚<a href="#%_sec_Temp_449">&hellip;</a>
📝<a href="#%_thm_3.50">3.50</a>
📝<a href="#%_thm_3.51">3.51</a>
📝<a href="#%_thm_3.52">3.52</a>
§<a href="#%_sec_3.5.2">3.5.2</a>
🎨<a href="#%_fig_3.31">3.31</a>
📚<a href="#%_sec_Temp_457">&hellip;</a>
📝<a href="#%_thm_3.53">3.53</a>
📝<a href="#%_thm_3.54">3.54</a>
📝<a href="#%_thm_3.55">3.55</a>
📝<a href="#%_thm_3.56">3.56</a>
📝<a href="#%_thm_3.57">3.57</a>
📝<a href="#%_thm_3.58">3.58</a>
📝<a href="#%_thm_3.59">3.59</a>
📝<a href="#%_thm_3.60">3.60</a>
📝<a href="#%_thm_3.61">3.61</a>
📝<a href="#%_thm_3.62">3.62</a>
§<a href="#%_sec_3.5.3">3.5.3</a>
📚<a href="#%_sec_Temp_471">&hellip;</a>
📝<a href="#%_thm_3.63">3.63</a>
📝<a href="#%_thm_3.64">3.64</a>
📝<a href="#%_thm_3.65">3.65</a>
📚<a href="#%_sec_Temp_476">&hellip;</a>
📝<a href="#%_thm_3.66">3.66</a>
📝<a href="#%_thm_3.67">3.67</a>
📝<a href="#%_thm_3.68">3.68</a>
📝<a href="#%_thm_3.69">3.69</a>
📝<a href="#%_thm_3.70">3.70</a>
📝<a href="#%_thm_3.71">3.71</a>
📝<a href="#%_thm_3.72">3.72</a>
📚<a href="#%_sec_Temp_489">&hellip;</a>
🎨<a href="#%_fig_3.32">3.32</a>
📝<a href="#%_thm_3.73">3.73</a>
🎨<a href="#%_fig_3.33">3.33</a>
📝<a href="#%_thm_3.74">3.74</a>
📝<a href="#%_thm_3.75">3.75</a>
📝<a href="#%_thm_3.76">3.76</a>
§<a href="#%_sec_3.5.4">3.5.4</a>
🎨<a href="#%_fig_3.34">3.34</a>
📝<a href="#%_thm_3.77">3.77</a>
📝<a href="#%_thm_3.78">3.78</a>
🎨<a href="#%_fig_3.35">3.35</a>
📝<a href="#%_thm_3.79">3.79</a>
📝<a href="#%_thm_3.80">3.80</a>
🎨<a href="#%_fig_3.36">3.36</a>
🎨<a href="#%_fig_3.37">3.37</a>
📚<a href="#%_sec_Temp_499">&hellip;</a>
§<a href="#%_sec_3.5.5">3.5.5</a>
📝<a href="#%_thm_3.81">3.81</a>
📝<a href="#%_thm_3.82">3.82</a>
📚<a href="#%_sec_Temp_503">&hellip;</a>
🎨<a href="#%_fig_3.38">3.38</a>
<a href="#footnotes">脚注</a>
]
</nav>

</div>

<!--
$ curl -o ch3-Z-G-#1.gif https://mitpress.mit.edu/sicp/full-text/book/ch3-Z-G-[34-60].gif
$ curl -o book-Z-G-D-19.gif https://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-19.gif
-->

<div class="main-txt">
<a name="%_sec_3.5"></a>
<h2 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_3.5">3.5  Streams</a></h2>
<h2 class="trans" lang="ja">3.5 ストリーム</h2>

<p class="orig" lang="en">
<a name="%_idx_3726"></a>
We've gained a good understanding of assignment as a tool in modeling,
as well as an appreciation of the complex problems that assignment
raises. It is time to ask whether we could have gone about things in a
different way, so as to avoid some of these problems.  In this
section, we explore an alternative approach to modeling state, based
on data structures called <em>streams</em>.  As we shall see, streams can
mitigate some of the complexity of modeling state.</p>

<p class="trans" lang="ja">
私たちは、モデル化における手段としての<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>について、よく理解したし、それとともに、<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>が提起する複雑な問題も、きちんと認識した。
今や、これらの問題を避けるように、物事に別の方法で取り組むことができ得たのかどうか、ということを問うべきときである。
本節では、<em>ストリーム</em>と呼ばれるデータ構造に基づいて、状態をモデル化するための代替的手法を、探求する。
これから見ることになるとおり、ストリームは、状態をモデル化することの複雑さのうちのいくばくかを、やわらげることができる。
</p>

<p class="orig" lang="en">
Let's step back and review where this complexity comes from.  In an
attempt to model real-world phenomena, we made some apparently
reasonable decisions: We modeled real-world objects with local state
by computational objects with local variables.  We identified time
variation in the real world with time variation in the computer.  We
implemented the time variation of the states of the model objects in
the computer with assignments to the local variables of the model
objects.</p>

<p class="trans" lang="ja">
この複雑さの<ruby><rb>因</rb><rp> (</rp><rt>よ</rt><rp>) </rp></ruby>って<ruby><rb>来</rb><rp> (</rp><rt>きた</rt><rp>) </rp></ruby>るところまで戻って、そこを再検討しよう。
現実世界の現象をモデル化しようという試みにおいて、私たちは、以下のように、一見したところは理にかなった、いくつかの決定を下した。
私たちは、局所状態のある、実世界の<ruby><rb>物</rb><rp> (</rp><rt>オブジェクト</rt><rp>) </rp></ruby>を、局所変数を持った計算オブジェクトにより、モデル化した。
私たちは、現実世界における時間変化を、コンピュータにおける時間変化と同一視した。
私たちは、コンピュータ内のモデル・オブジェクトの状態の時間変化を、モデル・オブジェクトの局所変数への<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>を使って、実装した。
</p>

<p class="orig" lang="en">
Is there another approach?  Can we avoid identifying time in the
computer with time in the modeled world?  Must we make the model
change with time in order to model phenomena in a changing world?
Think about the issue in terms of mathematical functions.  We can
describe the time-varying behavior of a quantity <em>x</em> as a function of
time <em>x</em>(<em>t</em>).  If we concentrate on <em>x</em> instant by instant, we think of
it as a changing quantity.  Yet if we concentrate on the entire
time history of values, we do not emphasize change -- the function
itself does not change.<a name="call_footnote_Temp_442" href="#footnote_Temp_442"><sup><small>52</small></sup></a></p>

<p class="trans" lang="ja">
他の手法があるだろうか?
コンピュータ内での時間を、モデル化される世界での時間と同一視することは、避けられるだろうか?
変化しつつある世界における現象をモデル化するために、時間とともにモデルを変化させなくてはならないのだろうか?
数学的関数の観点から、問題について考えよう。
<em class="en">x</em> という量の、経時変化する振る舞いを、
<span class="math"><em class="en">x</em>(<em class="en">t</em>) </span>
という時間の関数として記述できる。
各瞬間ごとの <em class="en">x</em> に注意を集中させる場合、私たちは、<em class="en">x</em> を、変化する量だと見なす。
それでも、値の全時間にわたる履歴に注意を集中させる場合、私たちは、変化を重要視しない——関数自体は変化しないのだ<a href="#footnote_Temp_442"><sup><small>52</small></sup></a>。
</p>

<p class="orig" lang="en">
If time is measured in discrete steps, then we can model a time function as
a (possibly infinite) sequence.  In this section, we will see how to
model change in terms of sequences that represent the time histories
of the systems being modeled.  To accomplish this, we introduce new
data structures called <em>streams</em>.  From an abstract point of view,
a stream is simply a sequence.  However, we will find that the
straightforward implementation of streams as lists (as in
section <a href="15_sec2_2.html#%_sec_2.2.1">2.2.1</a>) doesn't fully reveal
the power of stream processing.  As an alternative, we introduce the
technique of <a name="%_idx_3730"></a><em>delayed evaluation</em>, which enables us to represent
very large (even infinite) sequences as streams.</p>

<p class="trans" lang="ja">
もし時間が離散的な幅で計測されるなら、時間関数を（ひょっとすると無限の）数列としてモデル化できる。
本節では、モデル化されているシステムの時間履歴を表す数列の観点から、変化をモデル化する方法を、見ることにしよう。
これを達成するために、<em>ストリーム</em>と呼ばれる新しいデータ構造を導入する。
抽象的な視点から言うと、ストリームは単純に列である。
しかし、<!--ストリームをリストとして分かりやすく実装すること-->（<a href="15_sec2_2.html#%_sec_2.2.1">2.2.1</a>節のように）ストリームをリストとする分かりやすい実装<!--リストとしてのストリームの分かりやすい実装-->は、ストリーム処理の力を完全に明らかにはしない。
その代替策として、<em>遅延評価</em>という技法——これによって、非常に長い列（無限列でさえ）もストリームとして表現できるようになる——を導入する。
</p>

<p class="orig" lang="en">
Stream processing lets us model systems that have state without ever
using assignment or mutable data.  This has important implications,
both theoretical and practical, because we can build models that avoid
the drawbacks inherent in introducing assignment.  On the other hand,
the stream framework raises difficulties of its own, and the question
of which modeling technique leads to more modular and more easily
maintained systems remains open.</p>

<p class="trans" lang="ja">
<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>ないし<ruby><rb>変更可能</rb><rp> (</rp><rt>ミュータブル</rt><rp>) </rp></ruby>なデータをまったく使わずに、状態を持つシステムをモデル化することが、ストリーム処理によって可能となる。
このことは、理論上と実用上の双方の面で、重要な含みを持つ——というのも、<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>を持ち込むことにつきものの欠点を回避するモデルを構築できるからである。
一方で、ストリームの枠組は、それ自身に特有の難しさを提示するし、それに、どのモデル化技法が、よりモジュール性があってより簡単に保守されるシステムにつながるのか、という疑問は、未解決のままである。
</p>


<a name="%_sec_3.5.1"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_3.5.1">3.5.1  Streams Are Delayed Lists</a></h3>
<h3 class="trans" lang="ja">3.5.1 ストリームは遅延されたリストだ</h3>

<p class="orig" lang="en">
<a name="%_idx_3732"></a>
As we saw in section <a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a>,
sequences can serve as standard interfaces for combining program
modules.  We formulated powerful abstractions for manipulating
sequences, such as <tt>map</tt>, <tt>filter</tt>, and <tt>accumulate</tt>, that
capture a wide variety of operations in a manner that is both succinct
and elegant.</p>

<p class="trans" lang="ja">
<a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a>節で見たとおり、列は、プログラムモジュール同士を結合するための標準的インタフェイスとして機能できる。
簡潔でもあり洗練されてもいるようなやり方で広範囲の演算を捕まえる、<tt>map</tt> や <tt>filter</tt> や <tt>accumulate</tt> などといった、列操作用の強力な抽象化を、私たちは定式化した。
</p>

<p class="orig" lang="en">
Unfortunately, if we represent sequences as lists, this elegance is
bought at the price of severe inefficiency with respect to both the
time and space required by our computations.
When we represent manipulations on sequences as transformations
of lists, our programs must construct and copy data structures (which
may be huge) at every step of a process.</p>

<p class="trans" lang="ja">
しかしあいにく、列をリストとして表現する場合、こうした洗練は、自分の計算に必要な時間と空間の双方に関するひどい非効率性、という代償のもとに、もたらされるのである。
列に対する演算をリストの変形として表現するとき、私たちのプログラムは、（巨大かもしれない）データ構造を、プロセスの全ステップにおいて、構築・複製しなくてはならない。
</p>

<p class="orig" lang="en">
To see why this is true, let us compare two programs for computing the
sum of all the prime numbers in an interval.  The first program is
written in standard iterative style:<a name="call_footnote_Temp_443" href="#footnote_Temp_443"><sup><small>53</small></sup></a></p>

<p class="trans" lang="ja">
これがなぜ本当なのかを見るために、ある区間内のすべての素数の和を計算するための二つのプログラムを比較しよう。
一番目のプログラムは、標準的な反復方式で書かれている<a href="#footnote_Temp_443"><sup><small>53</small></sup></a>。
</p>

<p class="lisp"><a name="%_idx_3734"></a>(define (sum-primes a b)
  (define (iter count accum)
    (cond ((&gt; count b) accum)
          ((prime? count) (iter (+ count 1) (+ count accum)))
          (else (iter (+ count 1) accum))))
  (iter a 0))
</p>



<p class="orig" lang="en">
The second program performs the same computation using the sequence
operations of section <a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a>:</p>

<p class="trans" lang="ja">
二番目のプログラムは、 <a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a>節の列操作を使って、同じ計算を行う。
</p>


<p class="lisp"><a name="%_idx_3736"></a>(define (sum-primes a b)
  (accumulate +
              0
              (filter prime? (enumerate-interval a b))))
</p>


<p class="orig" lang="en">
In carrying out the computation, the first program needs to store only
the sum being accumulated.  In contrast, the filter in the second
program cannot do any testing until <tt>enumerate-interval</tt> has
constructed a complete list of the numbers in the interval.  The
filter generates another list, which in turn is passed to <tt>accumulate</tt> before being collapsed to form a sum.  Such large
intermediate storage is not needed by the first program, which we can
think of as enumerating the interval incrementally, adding each prime
to the sum as it is generated.</p>

<p class="trans" lang="ja">
計算を実行する際に、一番目のプログラムは、累積されている和だけを記憶する必要がある。
それに対して、二番目のプログラムにおけるフィルタは、<tt>enumerate-interval</tt> が区間内の数の完全なリストを構築するまでは、何のテストもできない。
フィルタは別のリストを構築し、今度はそのリストが、圧縮されて和の形をとるよりも前に、<tt>accumulate</tt> に渡される。
こうした巨大で中間的な格納は、一番目のプログラム——私たちはこれを、当該区間を少しずつ数えていって、各素数を、その素数が生成されるときに和に加えるものだ、と見なせる——では、必要がない。
</p>

<p class="orig" lang="en">
The inefficiency in using lists becomes painfully apparent if we use
the sequence paradigm to compute the second prime in the interval from
10,000 to 1,000,000 by evaluating the expression</p>

<p class="trans" lang="ja">
列のパラダイムを使って、以下の式を評価することにより、10,000 から 1,000,000 までの区間のうちで二番目の素数を計算するとき、リストを使う際の非効率性は、いやになるほど明らかになる。
</p>


<p class="lisp">(car (cdr (filter prime?
                  (enumerate-interval 10000 1000000))))
</p>


<p class="orig" lang="en">
This expression does find the second prime, but the computational
overhead is outrageous.  We construct a list of almost a million
integers, filter this list by testing each element for primality, and
then ignore almost all of the result.  In a more traditional
programming style, we would interleave the enumeration and the
filtering, and stop when we reached the second prime.</p>

<p class="trans" lang="ja">
この式は、二番目の素数を確かに見つけ出すのだが、計算上のオーバヘッドは法外である。
私たちは、ほとんど百万個の整数のリストを構築して、素数性について各要素を調べることでこのリストをフィルタにかけ、それから、結果のほとんどすべてを無視するのだ。
より伝統的なプログラミングの様式では、私たちは、数え上げとフィルタリングを互い違いにして、二番目の素数に到達したときに停止するだろう。
</p>

<p class="orig" lang="en">
Streams are a clever idea that allows one to use sequence
manipulations without incurring the costs of manipulating sequences as
lists.  With streams we can achieve the best of both worlds: We can
formulate programs elegantly as sequence manipulations, while attaining the
efficiency of incremental computation.  The basic idea is to arrange
to construct a stream only partially, and to pass the partial
construction to the program that consumes the stream.  If the consumer
attempts to access a part of the stream that has not yet been
constructed, the stream will automatically construct just enough more
of itself to produce the required part, thus preserving the illusion
that the entire stream exists.  In other words, although we will write
programs as if we were processing complete sequences, we design our
stream implementation to automatically and transparently interleave
the construction of the stream with its use.</p>

<p class="trans" lang="ja">
ストリームは、列をリストとして操作するという犠牲を招くことなく、列操作を使うことを可能にしてくれる、賢い考え方だ。
ストリームがあれば、双方の世界の最善を達成できる。
つまり、<ruby><rb>一歩ずつ進める方式の</rb><rp> (</rp><rt>インクリメンタルな</rt><rp>) </rp></ruby>計算の効率性を達成しつつ、洗練されたやり方で列操作としてプログラムを定式化できるのだ。
基本的な考え方は、ただ部分的にだけストリームを構築できるように手筈を整えて、その部分的な構築を、そのストリームを消費するプログラムへ渡すことである。
もし消費側が、まだ構築されていないストリームの一部にアクセスしようと試みたら、ストリームは自動的に、そのストリーム自身の、ちょうど十分なだけ先までの部分を構築して、求められた部分を作り出すだろうし、したがって、ストリーム全体が存在している、という幻想を保つだろう。
換言すれば、私たちは、あたかも自分が完全な列を処理しているところであるかのように、プログラムを書くだろうが、ストリームの構築をそのストリームの使用の間に自動的かつ透過的に挟み込むように、ストリームの実装を設計するのである。
</p>

<p class="orig" lang="en">
On the surface, streams are just lists with different names for the
procedures that manipulate them.  There is a constructor,
<a name="%_idx_3738"></a><tt>cons-stream</tt>, and two selectors, <a name="%_idx_3740"></a><tt>stream-car</tt> and <a name="%_idx_3742"></a><tt>stream-cdr</tt>, which satisfy the constraints
</p>

<p class="trans" lang="ja">
表面的には、ストリームとは、ストリームを操作する手続きに対して別の名前がついているような、単なるリストである。
コンストラクタ——すなわち <tt>cons-stream</tt> ——と、二つのセレクタ——すなわち、<tt>stream-car</tt> と <tt>stream-cdr</tt> ——があり、これらは以下の制約を満たす。
</p>

<figure><img src="ch3-Z-G-34.gif" border="0"></figure>


<p class="orig" lang="en">
There is a distinguishable object, <a name="%_idx_3744"></a><a name="%_idx_3746"></a><a name="%_idx_3748"></a><tt>the-empty-stream</tt>, which
cannot be the result of any <tt>cons-stream</tt> operation, and which can
be identified with the predicate <a name="%_idx_3750"></a><tt>stream-null?</tt>.<a name="call_footnote_Temp_444" href="#footnote_Temp_444"><sup><small>54</small></sup></a>
Thus we can make and use streams, in just the same way as we can make
and use lists, to represent aggregate data arranged in a sequence.  In
particular, we can build stream analogs of the list operations from
chapter 2, such as <tt>list-ref</tt>, <tt>map</tt>, and <tt>for-each</tt>:<a name="call_footnote_Temp_445" href="#footnote_Temp_445"><sup><small>55</small></sup></a>
</p>


<p class="trans" lang="ja">
識別しやすいオブジェクト——すなわち <tt>the-empty-stream</tt> ——があり、これは、どの <tt>cons-stream</tt> 操作の結果でもあり得ず、<tt>stream-null?</tt> という述語により同定される<a href="#footnote_Temp_444"><sup><small>54</small></sup></a>。
よって、私たちは、一列に並んだ集合的データを表現するためにリストを作ったり使ったりできるのとちょうど同じようにして、ストリームを作ったり使ったりできる。
特に、2章のリスト操作——例えば <tt>list-ref</tt> や <tt>map</tt> や <tt>for-each</tt> など——に対するストリーム版の相似物を、構築できるのだ<a href="#footnote_Temp_445"><sup><small>55</small></sup></a>。
</p>

<p class="lisp"><a name="%_idx_3758"></a>(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))
<a name="%_idx_3760"></a>(define (stream-map proc s)
  (if (stream-null? s)
      the-empty-stream
      (cons-stream (proc (stream-car s))
                   (stream-map proc (stream-cdr s)))))
<a name="%_idx_3762"></a>(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each proc (stream-cdr s)))))
</p>


<p class="orig" lang="en">
<tt>Stream-for-each</tt> is useful for viewing streams:
</p>

<p class="trans" lang="ja">
<tt>stream-for-each</tt> は、ストリームを眺めるのに有用である。
</p>

<p class="lisp"><a name="%_idx_3764"></a>(define (display-stream s)
  (stream-for-each display-line s))

<a name="%_idx_3766"></a>(define (display-line x)
  (newline)
  (display x))
</p>

<p class="orig" lang="en">
To make the stream implementation automatically and transparently
interleave the construction of a stream with its use, we will arrange
for the <tt>cdr</tt> of a stream to be evaluated when it is accessed by
the <tt>stream-cdr</tt> procedure rather than when the stream is
constructed by <tt>cons-stream</tt>.  This implementation choice is
reminiscent of our discussion of rational numbers in
section <a href="14_sec2_1.html#%_sec_2.1.2">2.1.2</a>, where we saw that we can
choose to implement rational numbers so that the reduction of
numerator and denominator to lowest terms is performed either at
construction time or at selection time.  The two rational-number
implementations produce the same data abstraction, but the choice has
an effect on efficiency.  There is a similar relationship between
streams and ordinary lists.  As a data abstraction, streams are the
same as lists.  The difference is the time at which the elements are
evaluated.  With ordinary lists, both the <tt>car</tt> and the <tt>cdr</tt>
are evaluated at construction time.  With streams, the <tt>cdr</tt> is
evaluated at selection time.</p>

<p class="trans" lang="ja">
ストリームの実装<!--を-->に、ストリームの構築をそのストリームの使用の間に自動的かつ透過的に挟み込<!--むようなものとする-->むようにさせるために、私たちは、ストリームが <tt>cons-stream</tt> によって構築されるときにストリームの <tt>cdr</tt> を評価するのではなく、むしろ、ストリームの <tt>cdr</tt> が <tt>stream-cdr</tt> という手続きによってアクセスされるときにストリームの <tt>cdr</tt> を評価することができるように、手筈を整えよう。
<!--ストリームの <tt>cdr</tt> が、そのストリームが <tt>cons-stream</tt> によって構築されるときに評価されるのではなく、むしろ、その <tt>cdr</tt> が <tt>stream-cdr</tt> によってアクセスされるときに評価されるように、-->
こうした実装の選択は、<a href="14_sec2_1.html#%_sec_2.1.2">2.1.2</a>節での有理数についての議論——分子と分母の既約化を、構築時か選択時のどちらかで実行するように、有理数を実装することを選ぶことができるのだ、ということを見た——を彷彿とさせる。
二つの有理数の実装は、同じデータ抽象化物を生み出すが、どちらを選ぶかは効率に影響を及ぼす。
似たような関係が、ストリームと普通のリストの間にもある。
データ抽象化物としては、ストリームはリストと同じである。
その違いは、要素が評価される時点である。
普通のリストだと、<tt>car</tt> と <tt>cdr</tt> の双方は、構築時に評価される。
ストリームだと、<tt>cdr</tt> は、選択時に評価される。
</p>

<p class="orig" lang="en">
<a name="%_idx_3768"></a><a name="%_idx_3770"></a>Our implementation of streams will be based on a special form called
<tt>delay</tt>.  Evaluating <tt>(delay &lt;<em>exp</em>&gt;)</tt> does not
evaluate the expression &lt;<em>exp</em>&gt;, but rather returns a so-called <a name="%_idx_3772"></a><em>delayed object</em>, which we can think of as a ``promise'' to evaluate
&lt;<em>exp</em>&gt; at some future time.  As a companion to <tt>delay</tt>, there is
a procedure called <a name="%_idx_3774"></a><tt>force</tt> that takes a delayed object as
argument and performs the evaluation -- in effect, forcing the
<tt>delay</tt> to fulfill its promise.  We will see below how <tt>delay</tt>
and <tt>force</tt> can be implemented, but first let us use these to
construct streams.</p>

<p class="trans" lang="ja">
私たちのストリームの実装は、<tt>delay</tt> と呼ばれる特殊形式に基づくことだろう。
<tt>(delay &lt;<em class="en">exp</em>&gt;)</tt>
の評価では、
&lt;<em class="en">exp</em>&gt;
を評価したりせず、むしろ、いわゆる<em>遅延オブジェクト</em>—— &lt;<em class="en">exp</em>&gt; を未来のどこかの時点で評価するという「<ruby><rb>約束</rb><rp> (</rp><rt>プロミス</rt><rp>) </rp></ruby>」と見なせる——を返すのだ。
<tt>delay</tt> と対をなす片割れとしては、遅延オブジェクトを引数としてとって評価を実行する、<tt>force</tt> と呼ばれる手続きがあり、これは、事実上、<tt>delay</tt> に約束を守らせるものである。
以下では、どのようにしたら <tt>delay</tt> と <tt>force</tt> を実装できるのかを見ることにするが、まずは、これらを使ってストリームを作ろう。
</p>

<p class="orig" lang="en">
<a name="%_idx_3776"></a><a name="%_idx_3778"></a><tt>Cons-stream</tt> is a special form defined so that</p>

<p class="trans" lang="ja">
<tt>cons-stream</tt> は以下のように定義される特殊形式である——すなわち、
</p>

<p class="lisp">(cons-stream &lt;<em>a</em>&gt; &lt;<em>b</em>&gt;)
</p>

<p class="orig" lang="en">
is equivalent to</p>

<p class="trans" lang="ja">
が、以下のものと等価となるように、定義されるものである。
</p>

<p class="lisp">(cons &lt;<em>a</em>&gt; (delay &lt;<em>b</em>&gt;))
</p>

<p class="orig" lang="en">
What this means is that we will construct streams using pairs.  However,
rather than placing the value of the rest of the stream
into the <tt>cdr</tt> of the
pair we will put there a promise to compute the rest if it is ever
requested.  <tt>Stream-car</tt> and <tt>stream-cdr</tt> can now be defined as
procedures:</p>

<p class="trans" lang="ja">
これが意味することは、対を使ってストリームを構築することになるだろう、ということだ。
しかし、ストリームの残りの部分の値を、対の <tt>cdr</tt> に配置することよりもむしろ、そこには、いつか求められたときにその残りの部分を計算するよ、という約束を、置くことになるだろう。
<tt>stream-car</tt> と <tt>stream-cdr</tt> は、ここで、以下のような手続きとして定義できる。
</p>


<p class="lisp"><a name="%_idx_3780"></a>(define (stream-car stream) (car stream))

<a name="%_idx_3782"></a>(define (stream-cdr stream) (force (cdr stream)))
</p>

<p class="orig" lang="en">
<tt>Stream-car</tt> selects the <tt>car</tt> of the pair; <tt>stream-cdr</tt>
selects the <tt>cdr</tt> of the pair and evaluates the delayed expression
found there to obtain the rest of the stream.<a name="call_footnote_Temp_446" href="#footnote_Temp_446"><sup><small>56</small></sup></a>

<p class="trans" lang="ja">
<tt>stream-car</tt> は、対の <tt>car</tt> を選択する。<tt>stream-cdr</tt> は、対の <tt>cdr</tt> を選択し、そこで見つかった遅延された式を評価して、ストリームの残りの部分を求める<a href="#footnote_Temp_446"><sup><small>56</small></sup></a>。
</p>

<a name="%_sec_Temp_447"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_447">The stream implementation in action</a></h4>
<h4 class="trans" lang="ja">動作しているストリーム実装</h4>

<p class="orig" lang="en">
To see how this implementation behaves, let us analyze the
``outrageous'' prime computation we saw above, reformulated in terms
of streams:</p>

<p class="trans" lang="ja">
この実装がどう振る舞うのかを見るために、上で見た「法外な」素数計算——ストリームを使って、以下のように定式化し直されたもの——を分析しよう。
</p>

<p class="lisp">(stream-car
 (stream-cdr
  (stream-filter prime?
                 (stream-enumerate-interval 10000 1000000))))
</p>


<p class="orig" lang="en">
We will see that it does indeed work efficiently.</p>

<p class="trans" lang="ja">
これが確かに効率的に動くことが分かるであろう。
</p>

<p class="orig" lang="en">
We begin by calling <tt>stream-enumerate-interval</tt> with
the arguments 10,000 and 1,000,000.  <tt>Stream-enumerate-interval</tt>
is the stream analog of <tt>enumerate-interval</tt>
(section <a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a>):</p>

<p class="trans" lang="ja">
10,000 および 1,000,000 という引数とともに <tt>stream-enumerate-interval</tt> を呼び出すことから始める。
<tt>stream-enumerate-interval</tt> は、<tt>enumerate-interval</tt> (<a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a>節) のストリーム版の相似物である。
</p>

<p class="lisp"><a name="%_idx_3788"></a>(define (stream-enumerate-interval low high)
  (if (&gt; low high)
      the-empty-stream
      (cons-stream
       low
       (stream-enumerate-interval (+ low 1) high))))
</p>

<p class="orig" lang="en">
and thus the result returned by <tt>stream-enumerate-interval</tt>,
formed by the <tt>cons-stream</tt>, is<a name="call_footnote_Temp_448" href="#footnote_Temp_448"><sup><small>57</small></sup></a></p>

<p class="trans" lang="ja">
したがって、<tt>stream-enumerate-interval</tt> により返される結果—— <tt>cons-stream</tt> により作られる——は、以下のとおりである<a  href="#footnote_Temp_448"><sup><small>57</small></sup></a>。
</p>


<p class="lisp">(cons 10000
      (delay (stream-enumerate-interval 10001 1000000)))
</p>

<p class="orig" lang="en">
That is, <tt>stream-enumerate-interval</tt>
returns a stream represented as a pair whose <tt>car</tt>
is 10,000 and whose <tt>cdr</tt> is a promise to enumerate more of the
interval if so requested.  This stream is now filtered for primes,
using the stream analog of the <tt>filter</tt> procedure
(section <a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a>):</p>

<p class="trans" lang="ja">
つまり、<tt>car</tt> が 10,000 であり、かつ、<tt>cdr</tt> は、もしその区間のさらに先を数え上げるように求められたらそうするよ、という<ruby><rb>約束</rb><rp> (</rp><rt>プロミス</rt><rp>) </rp></ruby>である、というような対として表されるストリームを、<tt>stream-enumerate-interval</tt> が返すのである。
このストリームがここで、<tt>filter</tt> の手続き (<a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a>節) のストリーム版の相似物を使って、素数用のフィルタにかけられる。
</p>


<p class="lisp"><a name="%_idx_3790"></a>(define (stream-filter pred stream)
  (cond ((stream-null? stream) the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream (stream-car stream)
                      (stream-filter pred
                                     (stream-cdr stream))))
        (else (stream-filter pred (stream-cdr stream)))))
</p>


<p class="orig" lang="en">
<tt>Stream-filter</tt> tests the <tt>stream-car</tt> of the stream (the <tt>car</tt> of the pair, which is 10,000).  Since this is not prime,
<tt>stream-filter</tt> examines the <tt>stream-cdr</tt> of its input
stream.  The call to <tt>stream-cdr</tt> forces evaluation of the delayed
<tt>stream-enumerate-interval</tt>, which now returns</p>

<p class="trans" lang="ja">
<tt>stream-filter</tt> は、当該ストリームの <tt>stream-car</tt> (対の <tt>car</tt>、つまり、10,000) を調べる。
これは素数ではないから、<tt>stream-filter</tt> は、自分への入力ストリームの <tt>stream-cdr</tt> を検査する。
<tt>stream-cdr</tt> に対する呼び出しは、遅延された <tt>stream-enumerate-interval</tt> の評価を強制し、それが今度は以下のように返してくる。
</p>


<p class="lisp">(cons 10001
      (delay (stream-enumerate-interval 10002 1000000)))
</p>


<p class="orig" lang="en">
<tt>Stream-filter</tt> now looks at the <tt>stream-car</tt> of this stream,
10,001, sees that this is not prime either, forces another <tt>stream-cdr</tt>, and so on, until <tt>stream-enumerate-interval</tt> yields
the prime 10,007, whereupon <tt>stream-filter</tt>, according to its
definition, returns</p>

<p class="trans" lang="ja">
<tt>stream-filter</tt> は、今度はこのストリームの <tt>stream-car</tt> ——つまり 10,001 ——を見て、これも素数ではないな、と理解し、もう一回 <tt>stream-cdr</tt> を強制的に行い、……というふうに続く—— <tt>stream-enumerate-interval</tt> が 10,007 という素数を作り出して、その結果、<tt>stream-filter</tt> がその定義に基づいて以下のように返すまで。
</p>


<p class="lisp">(cons-stream (stream-car stream)
             (stream-filter pred (stream-cdr stream)))
</p>


<p class="orig" lang="en">
which in this case is</p>

<p class="trans" lang="ja">
この場合、これは以下のとおりである。
</p>


<p class="lisp">(cons 10007
      (delay
        (stream-filter
         prime?
         (cons 10008
               (delay
                 (stream-enumerate-interval 10009
                                            1000000))))))
</p>

<p class="exercise"><span class="ex_comment">ちなみに、
10000 = 2<sup>4</sup> &middot; 5<sup>4</sup>
10001 = 73 &middot; 137
10002 = 2 &middot; 3 &middot; 1667
10003 = 7 &middot; 1429
10004 = 2<sup>2</sup> &middot; 41 &middot; 61
10005 = 3 &middot; 5 &middot; 23 &middot; 29
10006 = 2 &middot; 5003
10007 = 10007
10008 = 2<sup>3</sup> &middot; 3<sup>2</sup> &middot; 139
10009 = 10009
ですよ。</span></p>

<p class="orig" lang="en">
This result is now passed to <tt>stream-cdr</tt> in our
original expression.  This forces the delayed <tt>stream-filter</tt>, which in turn keeps forcing the delayed <tt>stream-enumerate-interval</tt> until it finds the next prime, which is
10,009.  Finally, the result passed to <tt>stream-car</tt> in our
original expression is</p>

<p class="trans" lang="ja">
この結果がここで、元々の式における <tt>stream-cdr</tt> に渡される。
このことにより、遅延された <tt>stream-filter</tt> を強制的に行うことになり、その <tt>stream-filter</tt> が今度は、次の素数——つまり 10,009 ——を見つけ出すまでずっと <tt>stream-enumerate-interval</tt> を強制的に行い続けるのである。
最終的に、元々の式における <tt>stream-car</tt> に渡される結果は、以下のとおりである。
</p>


<p class="lisp">(cons 10009
      (delay
        (stream-filter
         prime?
         (cons 10010
               (delay
                 (stream-enumerate-interval 10011
                                            1000000))))))
</p>



<p class="orig" lang="en">
<tt>Stream-car</tt> returns 10,009, and the computation is complete.  Only as
many integers were tested for primality as were necessary to find the
second prime, and the interval was enumerated only as far as was
necessary to feed the prime filter.</p>

<p class="trans" lang="ja">
<tt>stream-car</tt> は 10,009 を返し、計算が完了する。
二番目の素数を見つけるのに必要なのと同じ個数だけの整数が、素数性を調べられたのだし、区間は、素数フィルタに投入するのに必要な限りにおいてだけ、数え上げられた。
</p>

<p class="orig" lang="en">
In general, we can think of delayed evaluation as <a name="%_idx_3792"></a>``demand-driven''
programming, whereby each stage in the stream process is activated
only enough to satisfy the next stage.  What we have done is to
<a name="%_idx_3794"></a>decouple the actual order of events in the computation from the
apparent structure of our procedures.  We write procedures as if the
streams existed ``all at once'' when, in reality, the computation is
performed incrementally, as in traditional programming styles.</p>

<p class="trans" lang="ja">
一般に、遅延評価は、「需要駆動の」プログラミング——これにより、ストリーム処理における各段階は、次の段階を充足させるのに十分な分だけ、活性化される——である、と見なせる。
私たちが行ったことは、計算における出来事の実際の順序を、手続きのうわべの構造から切り離すことである。
実際には計算が一歩ずつ実行されるにもかかわらず、私たちは、伝統的なプログラミング流儀と同様に、あたかもストリームが「すべてが一度に」存在しているかのように、手続きを書く。
</p>


<a name="%_sec_Temp_449"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_449">Implementing <tt>delay</tt> and <tt>force</tt></a></h4>
<h4 class="trans" lang="ja"><tt>delay</tt> と <tt>force</tt> を実装する</h4>


<p class="orig" lang="en">
<a name="%_idx_3796"></a>Although <tt>delay</tt> and <tt>force</tt> may seem like mysterious
operations, their implementation is really quite straightforward.
<tt>Delay</tt> must package an expression so that it can be evaluated
later on demand, and we can accomplish this simply by treating the
expression as the body of a procedure.  <tt>Delay</tt> can be a special
form such that</p>

<p class="trans" lang="ja">
<tt>delay</tt> と <tt>force</tt> は神秘的な演算のように見えるのだが、これらの実装は本当にとてもわかりやすい。
<tt>delay</tt> は、後で需要があり次第、式を評価できるように、式を包み込まねばならないわけだが、私たちはこれを、その式を手続きの本体として扱うことで、簡単に達成できる。
<tt>delay</tt> は、次のような特殊形式であってよい。すなわち、
</p>


<p class="lisp">(delay &lt;<em>exp</em>&gt;)
</p>


<p class="orig" lang="en">
is syntactic sugar for</p>

<p class="trans" lang="ja">
が、以下のものの糖衣構文であるような特殊形式であってよい。
</p>

<p class="lisp">(lambda () &lt;<em>exp</em>&gt;)
</p>


<p class="orig" lang="en">
<tt>Force</tt> simply calls the procedure (of no
arguments) produced by <tt>delay</tt>, so we can implement <tt>force</tt> as
a procedure:</p>

<p class="trans" lang="ja">
<tt>force</tt> は単に、<tt>delay</tt> により作り出された (引数なしの) 手続きを呼び出すだけであり、よって私たちは、<tt>force</tt> を以下の手続きとして実装できる。
</p>


<p class="lisp"><a name="%_idx_3798"></a>(define (force delayed-object)
  (delayed-object))
</p>


<p class="orig" lang="en">
<a name="%_idx_3800"></a><a name="%_idx_3802"></a>This implementation suffices for <tt>delay</tt> and <tt>force</tt> to work
as advertised, but there is an important optimization that we can
include.  In many applications, we end up forcing the same delayed object
many times.  This can lead to serious inefficiency in recursive
programs involving streams.  (See
exercise <a href="#%_thm_3.57">3.57</a>.)  The solution is to build
delayed objects so that the first time they are forced, they store the
value that is computed.  Subsequent forcings will simply return the
stored value without repeating the computation.  In other words, we
implement <tt>delay</tt> as a special-purpose memoized procedure similar
to the one described in exercise <a href="22_sec3_3.html#%_thm_3.27">3.27</a>.  One way to
accomplish this is to use the following procedure, which takes as
argument a procedure (of no arguments) and returns a memoized version
of the procedure.  The first time the memoized procedure is run, it
saves the computed result.  On subsequent evaluations, it simply
returns the result.</p>

<p class="trans" lang="ja">
この実装は、<tt>delay</tt> と <tt>force</tt> が宣伝どおりにうまく動くのに十分であるが、私たちが含めることのできる重要な最適化がある。
多くのアプリケーションにおいて、私たちは最終的に、何回も同じ遅延オブジェクトを強制的に行うことになる。
このことは、ストリームを伴う再帰的プログラムにおける深刻な非効率につながることがある (練習問題 <a href="#%_thm_3.57">3.57</a>を参照)。
解決法は、遅延オブジェクトが最初に強制されたときに、計算した値を遅延オブジェクトが記憶しておくように、遅延オブジェクトを構築することである。
その後の強制は、計算を繰り返さずに、単に記憶された値を返すことになるだろう。
換言すれば、私たちは、練習問題<a href="22_sec3_3.html#%_thm_3.27">3.27</a>で述べたものと似たような、特定目的のメモ化された手続きとして、<tt>delay</tt> を実装する。
これを達成するための一つの方法は、以下のような手続き——つまり、引数として、(引数のない) 手続きをとり、その手続きのメモ化されたバージョンを返すもの——を使うことである。
メモ化された手続きが最初に実行されるとき、メモ化された手続きは、計算した結果を保存する。
後続の評価の際には、メモ化された手続きは単にその結果を返すだけである。
</p>

<p class="lisp"><a name="%_idx_3804"></a>(define (memo-proc proc)
  (let ((already-run? false) (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))
</p>


<p class="orig" lang="en">
<tt>Delay</tt> is then defined so that <tt>(delay &lt;<em>exp</em>&gt;)</tt> is
equivalent to</p>

<p class="trans" lang="ja">
そして、<tt>delay</tt> は、
<tt>(delay &lt;<em class="en">exp</em>&gt;)</tt> 
が以下のものと等価となるように定義され、
</p>

<p class="lisp">(memo-proc (lambda () &lt;<em>exp</em>&gt;))
</p>

<p class="orig" lang="en">
and <tt>force</tt> is as defined previously.<a name="call_footnote_Temp_450" href="#footnote_Temp_450"><sup><small>58</small></sup></a></p>

<p class="trans" lang="ja">
また、<tt>force</tt> は、以前定義したとおりである<a href="#footnote_Temp_450"><sup><small>58</small></sup></a>。
</p>


<p class="orig" lang="en"><a name="%_thm_3.50"></a>
<b>Exercise 3.50.</b>  Complete the following definition, which
generalizes <tt>stream-map</tt> to allow procedures that
take multiple arguments, analogous to <tt>map</tt> in
section <a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a>, footnote <a href="15_sec2_2.html#footnote_Temp_166">12</a>.</p>

<p class="trans" lang="ja">
<b>練習問題3.50.</b> <a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a>節の <tt>map</tt> や 脚注<a href="15_sec2_2.html#footnote_Temp_166">12</a>と類似した以下の定義——複数の引数を取る手続きを許すように、<tt>stream-map</tt> を一般化している——を完成させよ。
</p>

<p class="lisp"><a name="%_idx_3824"></a>(define (stream-map proc . argstreams)
  (if (&lt;<em>??</em>&gt; (car argstreams))
      the-empty-stream
      (&lt;<em>??</em>&gt;
       (apply proc (map &lt;<em>??</em>&gt; argstreams))
       (apply stream-map
              (cons proc (map &lt;<em>??</em>&gt; argstreams))))))
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.51"></a>
<b>Exercise 3.51.</b>  <a name="%_idx_3826"></a>In order to take a closer look at delayed evaluation, we will use the
following procedure, which simply returns its argument after printing it:</p>

<p class="trans" lang="ja">
<b>練習問題3.51.</b> 遅延評価をもっとじっとよく見るために、以下の手続き——単に、引数を印字してから返すだけである——を使おう。
</p>


<p class="lisp">(define (show x)
  (display-line x)
  x)
</p>


<p class="orig" lang="en">
What does the interpreter print in response to evaluating each
expression in the following sequence?<a name="call_footnote_Temp_453" href="#footnote_Temp_453"><sup><small>59</small></sup></a></p>

<p class="trans" lang="ja">
インタプリタは、以下の一連の式の各々を評価するのに応じて、何を印字するだろう?<a href="#footnote_Temp_453"><sup><small>59</small></sup></a>
</p>


<p class="lisp">(define x (stream-map show (stream-enumerate-interval 0 10)))
(stream-ref x 5)
(stream-ref x 7)
</p>


<p class="exercise"><span class="ex_comment">
</span></p>


<p class="orig" lang="en"><a name="%_thm_3.52"></a>
<b>Exercise 3.52.</b>  <a name="%_idx_3830"></a>Consider the sequence of expressions</p>

<p class="trans" lang="ja">
<b>練習問題3.52.</b> 以下のような一連の式を考えよう。
</p>

<p class="lisp">(define sum 0)
(define (accum x)
  (set! sum (+ x sum))
  sum)
(define seq (stream-map accum (stream-enumerate-interval 1 20)))
(define y (stream-filter even? seq))
(define z (stream-filter (lambda (x) (= (remainder x 5) 0))
                         seq))
(stream-ref y 7)
(display-stream z)
</p>

<p class="orig" lang="en">
What is the value of <tt>sum</tt> after each of the above expressions is
evaluated?  What is the printed response to evaluating the <tt>stream-ref</tt> and <tt>display-stream</tt> expressions?  Would these responses
differ if we had implemented <tt>(delay &lt;<em>exp</em>&gt;)</tt> simply as
<tt>(lambda () &lt;<em>exp</em>&gt;)</tt> without using the optimization provided by
<tt>memo-proc</tt> ?  Explain.
</p>

<p class="trans" lang="ja">
上記の式のそれぞれが評価された後の、<tt>sum</tt> の値は、どのようなものか?
<tt>stream-ref</tt> と <tt>display-stream</tt> の式の評価に対して印字される応答とは、どういうものか?
もし、<tt>memo-proc</tt> によりもたらされる最適化を使わないで、単純に
<tt>(delay &lt;<em class="en">exp</em>&gt;)</tt>
を
<tt>(lambda () &lt;<em class="en">exp</em>&gt;)</tt> 
と実装していたら、これらの応答は違っていただろうか?
説明せよ。
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_3.5.2"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_3.5.2">3.5.2  Infinite Streams</a></h3>
<h3 class="trans" lang="ja">3.5.2 無限ストリーム</h3>


<p class="orig" lang="en">
<a name="%_idx_3832"></a>
We have seen how to support the illusion of manipulating streams
as complete entities even though, in actuality, we compute only
as much of the stream as we need to access.  We can exploit this
technique to represent sequences efficiently as streams, even if the
sequences are very long.  What is more striking, we can use streams to
represent sequences that are infinitely long.  For instance, consider
the following definition of the stream of positive integers:</p>

<p class="trans" lang="ja">
たとえ現実には、ストリームのうちでアクセスする必要がある分だけを計算するのだとしても、完全な実体としてストリームを操作しているのだという幻想を、どうやって支えるのか、ということをこれまで見てきた。
たとえ列が非常に長くても、効率的に列をストリームとして表現するために、この技法を利用することができる。
より魅力的なことには、無限に長い列を表現するのにストリームを使えるのだ。
たとえば、正整数のストリームの、以下のような定義を考えよう。
</p>


<p class="lisp"><a name="%_idx_3834"></a>(define (integers-starting-from n)
  (cons-stream n (integers-starting-from (+ n 1))))

<a name="%_idx_3836"></a>(define integers (integers-starting-from 1))
</p>


<p class="orig" lang="en">
This makes sense because <tt>integers</tt> will be a pair whose <tt>car</tt>
is 1 and whose <tt>cdr</tt> is a promise to produce the integers
beginning with 2.  This is an infinitely long stream, but in any given
time we can examine only a finite portion of it.  Thus, our programs
will never know that the entire infinite stream is not there.</p>

<p class="trans" lang="ja">
<tt>integers</tt> は、その <tt>car</tt> が1で、<tt>cdr</tt> は2から始まる整数を作り出すという約束である、という対となるだろうから、これは筋が通っている。
これは無限に長いストリームだが、そのうちの有限な部分のみを、与えられた任意の時間以内で調べることができる。
よって、完全な無限のストリームがそこには存在しない、ということを、私たちのプログラムは、まったく知らないままだろう。
</p>

<p class="orig" lang="en">
Using <tt>integers</tt> we can define other infinite streams, such as
the stream of integers that are not divisible by 7:</p>

<p class="trans" lang="ja">
<tt>integers</tt> を使うと、例えば7では割り切れない整数のストリームなど、他の無限ストリームを定義できる。
</p>


<p class="lisp"><a name="%_idx_3838"></a>(define (divisible? x y) (= (remainder x y) 0))
(define no-sevens
  (stream-filter (lambda (x) (not (divisible? x 7)))
                 integers))
</p>

<p class="orig" lang="en">
Then we can find integers not divisible by 7 simply by accessing
elements of this stream:</p>

<p class="trans" lang="ja">
すると、単にこのストリームの要素にアクセスすることで、7では割り切れない整数を見つけられる。
</p>

<p class="lisp">(stream-ref no-sevens 100)
<i>117</i>
</p>

<p class="orig" lang="en">
In analogy with <tt>integers</tt>, we can define the infinite stream of
Fibonacci numbers:</p>

<p class="trans" lang="ja">
<tt>integers</tt> との類推により、フィボナッチ数の無限ストリームを定義できる。
</p>


<p class="lisp">(define (fibgen a b)
  (cons-stream a (fibgen b (+ a b))))
<a name="%_idx_3840"></a>(define fibs (fibgen 0 1))
</p>


<p class="orig" lang="en">
<tt>Fibs</tt> is a pair whose <tt>car</tt> is 0 and whose <tt>cdr</tt> is a
promise to evaluate <tt>(fibgen 1 1)</tt>.  When we evaluate this delayed
<tt>(fibgen 1 1)</tt>, it
will produce a pair whose <tt>car</tt> is 1 and whose <tt>cdr</tt> is a
promise to evaluate <tt>(fibgen 1 2)</tt>, and so on.</p>

<p class="trans" lang="ja">
<tt>fibs</tt> は、その <tt>car</tt>が0で、<tt>cdr</tt> は <tt>(fibgen 1 1)</tt> を評価するという約束である、という対である。
この遅延された <tt>(fibgen 1 1)</tt> を評価するとき、これは、その <tt>car</tt>が1で、<tt>cdr</tt> は <tt>(fibgen 1 2)</tt> を評価するという約束である、という対を作り出すだろうし、以下同様である。
</p>

<p class="orig" lang="en">
<a name="%_idx_3842"></a>For a look at a more exciting infinite stream, we can generalize the
<tt>no-sevens</tt> example to construct the infinite stream of prime
numbers, using a method known as the <a name="%_idx_3844"></a><em>sieve of
Eratosthenes</em>.<a name="call_footnote_Temp_455" href="#footnote_Temp_455"><sup><small>60</small></sup></a> We
start with the integers beginning with 2, which is the first prime.
To get the rest of the primes, we start by filtering the multiples of
2 from the rest of the integers.  This leaves a stream beginning with
3, which is the next prime.  Now we filter the multiples of 3 from the
rest of this stream.  This leaves a stream beginning with 5, which is
the next prime, and so on.  In other words, we construct the primes by
a sieving process, described as follows: To sieve a stream <tt>S</tt>,
form a stream whose first element is the first element of <tt>S</tt> and
the rest of which is obtained by filtering all multiples of the first element
of <tt>S</tt> out of the rest of <tt>S</tt> and sieving the result. This
process is readily described in terms of stream operations:</p>

<p class="trans" lang="ja">
もっとわくわくするようなストリームを見るために、私たちは、<tt>no-sevens</tt> の例を一般化して、素数の無限ストリームを構築することができる——<em>エラトステネスの<ruby><rb>篩</rb><rp> (</rp><rt>ふるい</rt><rp>) </rp></ruby></em>として知られる方法を使って<a href="#footnote_Temp_455"><sup><small>60</small></sup></a>。
2——最初の素数——から始まる整数とともに、始める。
残りの素数を得るためには、残りの整数から、2の倍数をフィルタで除去することから始める。
これにより、3——次の素数——から始まるストリームが残される。
ここで、このストリームの残りの部分から、3の倍数をフィルタで除去する。
これにより、5——次の素数——から始まるストリームが残される。以下同様である。
換言すれば、以下に述べるような、篩にかけるプロセスにより、素数を構築するのである。
すなわち、<tt>S</tt> というストリームを篩にかけるためには、その最初の要素が <tt>S</tt> の最初の要素であって、かつ、その残りの部分は、<tt>S</tt> の残りの部分から<tt>S</tt> の最初の要素のすべての倍数をフィルタにかけてその結果を篩い落とすことで得られる、というストリームを形成せよ。
このプロセスは、ストリーム操作を使って、あっさり記述される。
</p>

<p class="lisp"><a name="%_idx_3852"></a>(define (sieve stream)
  (cons-stream
   (stream-car stream)
   (sieve (stream-filter
           (lambda (x)
             (not (divisible? x (stream-car stream))))
           (stream-cdr stream)))))

<a name="%_idx_3854"></a>(define primes (sieve (integers-starting-from 2)))
</p>


<p class="orig" lang="en">
Now to find a particular prime we need only ask for it:</p>

<p class="trans" lang="ja">
さて、特定の素数を見つけるには、私たちは、ただそれを求めるだけでよい。
</p>

<p class="lisp">(stream-ref primes 50)
<i>233</i>
</p>


<p class="orig" lang="en">
It is interesting to contemplate the signal-processing system set up
by <tt>sieve</tt>, shown in the <a name="%_idx_3856"></a>``Henderson diagram'' in
figure <a href="#%_fig_3.31">3.31</a>.<a name="call_footnote_Temp_456" href="#footnote_Temp_456"><sup><small>61</small></sup></a>
The input stream feeds into an
``un<tt>cons</tt>er'' that separates the first element of the stream from the
rest of the stream.
The first element is used to construct a divisibility filter, through
which the rest is passed, and the output of the filter is fed to
another sieve box.  Then the original first element is <tt>cons</tt>ed onto the
output of the internal sieve to form the output stream.  Thus, not
only is the stream infinite, but the signal processor is also
infinite, because the sieve contains a sieve within it.</p>

<p class="trans" lang="ja">
図<a href="#%_fig_3.31">3.31</a>の「ヘンダーソン図」に示される、<tt>sieve</tt> により築かれる信号処理システムを考えることは、興味深い<a href="#footnote_Temp_456"><sup><small>61</small></sup></a>。
入力ストリームは、そのストリームの最初の要素をそのストリームの残りの部分から分離する、「逆<tt>cons</tt>器」へと流れ込む。
最初の要素は、整除性のフィルタ——これを通して、残りの部分が渡される——を構築するのに使われ、フィルタの出力が、もう一つの篩の箱に与えられる。
そして、元の最初の要素が、内部の篩の出力の上に <tt>cons</tt> されて、出力ストリームを形成する。
このように、ストリームが無限であるだけでなく、信号処理器もまた無限なのである——なぜなら、篩は自分の内部に篩を含むからである。
</p>

<a name="%_fig_3.31"></a>
<figure>
<img src="ch3-Z-G-35.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.31:</b>  The prime sieve viewed as a signal-processing system.</figcaption>
<figcaption class="trans" lang="ja"><b>図3.31:</b> 信号処理システムとして見た、素数の篩</figcaption>
</figure>


<a name="%_sec_Temp_457"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_457">Defining streams implicitly</a></h4>
<h4 class="trans" lang="ja">ストリームを暗黙裡に定義する</h4>

<p class="orig" lang="en">
<a name="%_idx_3860"></a>
The <tt>integers</tt> and <tt>fibs</tt> streams above were defined by
specifying ``generating'' procedures that explicitly compute the
stream elements one by one. An alternative way to specify streams is
to take advantage of delayed evaluation to define streams implicitly.
For example, the following expression defines the stream <tt>ones</tt> to
be an infinite stream of ones:</p>

<p class="trans" lang="ja">
上記の <tt>integers</tt> と <tt>fibs</tt> のストリームは、ストリーム要素を一つ一つ明示的に計算するような、「生成する」手続きを指定することによって、定義された。
ストリームを規定するための別の方法は、ストリームを暗黙に定義するために遅延評価を利用することである。
たとえば、以下の式は、<tt>ones</tt> というストリームを、1の無限のストリームだと定義する。
</p>

<p class="lisp"><a name="%_idx_3862"></a>(define ones (cons-stream 1 ones))
</p>

<p class="orig" lang="en">
This works much like the definition of a recursive procedure: <tt>ones</tt> is a pair whose <tt>car</tt> is 1 and whose <tt>cdr</tt> is a promise
to evaluate <tt>ones</tt>.  Evaluating the <tt>cdr</tt> gives us again a 1
and a promise to evaluate <tt>ones</tt>, and so on.</p>

<p class="trans" lang="ja">
これは、再帰的手続きの定義とほとんど同じように、うまく動く。<tt>ones</tt> は、その <tt>car</tt> が1で、<tt>cdr</tt> は <tt>ones</tt> を評価するという約束である、という対である。
<tt>cdr</tt> を評価することで、再度、1と、<tt>ones</tt> を評価するという約束とが与えられ、以下同様である。
</p>

<p class="orig" lang="en">
We can do more interesting things by manipulating streams with
operations such as <tt>add-streams</tt>, which produces the elementwise
sum of two given streams:<a name="call_footnote_Temp_458" href="#footnote_Temp_458"><sup><small>62</small></sup></a></p>

<p class="trans" lang="ja">
たとえば <tt>add-streams</tt> ——与えられた二つのストリームの、要素ごとの和を作り出す——などの操作を使って、ストリームを操作することで、より興味深いことを行うことができる<a href="#footnote_Temp_458"><sup><small>62</small></sup></a>。
</p>

<p class="lisp"><a name="%_idx_3864"></a>(define (add-streams s1 s2)
  (stream-map + s1 s2))
</p>

<p class="orig" lang="en">
Now we can define the integers as follows:
</p>

<p class="trans" lang="ja">
今や私たちは、整数を以下のように定義できる。
</p>

<p class="lisp"><a name="%_idx_3866"></a>(define integers (cons-stream 1 (add-streams ones integers)))
</p>

<p class="orig" lang="en">
This defines <tt>integers</tt> to be a stream whose first element is 1
and the rest of which is the sum of <tt>ones</tt> and <tt>integers</tt>.  Thus, the
second element of <tt>integers</tt> is 1 plus the first element of <tt>integers</tt>,
or 2; the third element of <tt>integers</tt> is 1 plus the second
element of <tt>integers</tt>, or 3; and so on.  This definition works
because, at any point, enough of the <tt>integers</tt> stream has been
generated so that we can feed it back into the definition to produce
the next integer.</p>

<p class="trans" lang="ja">
これは、<tt>integers</tt> を、その1番目の要素が1で、残りの部分が <tt>ones</tt> と<tt>integers</tt> との和であるようなストリームである、と定義している。
よって、<tt>integers</tt> の2番目の要素は、1、足す、<tt>integers</tt> の1番目の要素であり、つまり、2である。<tt>integers</tt> の3番目の要素は、1、足す、<tt>integers</tt> の2番目の要素であり、つまり、3である。以下同様だ。
この定義はうまくゆく。というのも、任意の時点において、<tt>integers</tt> のストリームのうち十分な量が、次の整数を作り出すための定義へフィードバックできるようにと生成済みだからである。
</p>

<p class="orig" lang="en">
We can define the Fibonacci numbers in the same style:</p>

<p class="trans" lang="ja">
同じやり方でフィボナッチ数を定義できる。
</p>

<p class="lisp"><a name="%_idx_3868"></a>(define fibs
  (cons-stream 0
               (cons-stream 1
                            (add-streams (stream-cdr fibs)
                                         fibs))))
</p>


<p class="orig" lang="en">
This definition says that <tt>fibs</tt> is a stream beginning with 0 and
1, such that the rest of the stream can be generated by adding <tt>fibs</tt>
to itself shifted by one place:</p>

<p class="trans" lang="ja">
この定義は、<tt>fibs</tt> とは0と1で始まるストリームであって、場所を一つ分だけずらした <tt>fibs</tt> 自身に <tt>fibs</tt> を加えることによって、ストリームの残りの部分を生成できるようになっているのだ、と言っている。
</p>

<figure>
<table class="com-align-R">
<tr><td></td><td></td><td>1 </td><td>1 </td><td>2 </td><td>3 </td><td>5 </td><td>8 </td><td>13 </td><td>21 </td><td style="text-align: left; white-space: nowrap"><tt>...</tt> = <tt>(stream-cdr fibs)</tt></td></tr>

<tr><td></td><td></td><td>0 </td><td>1 </td><td>1 </td><td>2 </td><td>3 </td><td>5 </td><td> 8 </td><td>13 </td><td style="text-align: left;"><tt>...</tt> = <tt>fibs</tt></td></tr>

<tr><td>0 </td><td>1 </td><td>1 </td><td>2 </td><td>3 </td><td>5 </td><td>8 </td><td>13 </td><td>21 </td><td>34 </td><td style="text-align: left;"><tt>...</tt> = <tt>fibs</tt></td></tr>

</table>
</figure>

<p class="orig" lang="en">
<tt>Scale-stream</tt> is another useful procedure in formulating such stream definitions.
This multiplies each item in a stream by a given
constant:</p>

<p class="trans" lang="ja">
<tt>scale-stream</tt> は、そうしたストリーム定義を定式化する際に有用な、別の手続きである。
これは、ストリーム内の各項目と、与えられた定数とを乗算する。
</p>

<p class="lisp"><a name="%_idx_3870"></a>(define (scale-stream stream factor)
  (stream-map (lambda (x) (* x factor)) stream))
</p>


<p class="orig" lang="en">
For example,</p>

<p class="trans" lang="ja">
たとえば、
</p>

<p class="lisp">(define double (cons-stream 1 (scale-stream double 2)))
</p>

<p class="orig" lang="en">
produces the stream of powers of 2: 1, 2, 4, 8, 16, 32, <tt>...</tt>.</p>

<p class="trans" lang="ja">
は、2の冪のストリーム——つまり、1, 2, 4, 8, 16, 32, <tt>...</tt> ——を作り出す。
</p>

<p class="orig" lang="en">
An alternate definition of the stream of primes can be given by
starting with the integers and filtering them by testing for
primality.  We will need the first prime, 2, to get started:</p>

<p class="trans" lang="ja">
整数と、素数性を試すことでそれらの整数をフィルタにかけることと、から始めることで、素数のストリームの代替的な定義を与えることが可能だ。
始めるには、最初の素数——つまり2——が必要になるだろう。
</p>


<p class="lisp"><a name="%_idx_3872"></a>(define primes
  (cons-stream
   2
   (stream-filter prime? (integers-starting-from 3))))
</p>


<p class="orig" lang="en">
This definition is not so straightforward as it appears, because we
will test whether a number <em>n</em> is prime by checking whether <em>n</em> is
divisible by a prime (not by just any integer) less than or equal to
<img src="book-Z-G-D-13.gif" border="0"><em>n</em>:</p>

<p class="trans" lang="ja">
この定義は、見かけほど分かりやすいものではない。なぜなら、
&radic;<em class="en">n</em> 
以下の（単なる任意の整数ではなくて）素数によって <em class="en">n</em> が割り切れるかどうかを確かめることで、<em class="en">n</em> という数が素数かどうかを調べるであろうから。
</p>

<p class="lisp"><a name="%_idx_3874"></a>(define (prime? n)
  (define (iter ps)
    (cond ((&gt; (square (stream-car ps)) n) true)
          ((divisible? n (stream-car ps)) false)
          (else (iter (stream-cdr ps)))))
  (iter primes))
</p>

<p class="orig" lang="en">
This is a recursive definition, since <tt>primes</tt> is defined in terms
of the <tt>prime?</tt> predicate, which itself uses the <tt>primes</tt>
stream.  The reason this procedure works is that, at any point, enough
of the <tt>primes</tt> stream has been generated to test the primality of
the numbers we need to check next.  That is, for every <em>n</em> we test for
primality, either <em>n</em> is not prime (in which case there is a prime
already generated that divides it) or <em>n</em> is prime (in which case
there is a prime already generated -- i.e., a prime less than
<em>n</em> -- that is greater than <img src="book-Z-G-D-13.gif" border="0"><em>n</em>).<a name="call_footnote_Temp_459" href="#footnote_Temp_459"><sup><small>63</small></sup></a>

</p>

<p class="trans" lang="ja">
これは再帰的定義である。というのも、<tt>primes</tt> が、<tt>prime?</tt> という述語——これ自身が <tt>primes</tt> というストリームを使っている——を使って定義されているからである。
この手続きがうまく動く理由は、どの時点においても、<tt>primes</tt> というストリームのうちの十分な量が、<!--私たちが次に確かめるために必要としている数-->私たちが次に確かめなくてはいけない数の素数性を調べるために、既に生成されているからである。<span class="note">(なんか不安な訳だな。)</span>
つまり、私たちが素数性を試すすべての <em class="en">n</em> について、<em class="en">n</em> が素数ではない (その場合、<em class="en">n</em> を割り切るような、既に生成された素数が存在する) か、あるいは、<em class="en">n</em> が素数である (その場合、<!--既に生成された素数——つまり、<em class="en">n</em> 未満の素数——であって &radic;<em class="en">n</em> よりは大きいものが、存在する-->&radic;<em class="en">n</em> よりは大きいような、既に生成された素数——つまり、<em class="en">n</em> 未満の素数——が存在する)<a href="#footnote_Temp_459"><sup><small>63</small></sup></a>。
</p>

<p class="orig" lang="en"><a name="%_thm_3.53"></a>
<b>Exercise 3.53.</b>  Without running the program, describe the elements of the
stream defined by
</p>

<p class="trans" lang="ja">
<b>練習問題3.53.</b> 以下により定義されるストリームの要素を、プログラムを実行せずに説明せよ。
</p>

<p class="lisp">(define s (cons-stream 1 (add-streams s s)))
</p>

<p class="exercise"><span class="ex_comment"><tt>(cons-stream 1 ...</tt> となっているので、1番目の要素は1。
なお、1=2<sup>0</sup>である。

2番目の要素は、1から始まる <tt>s</tt> というストリーム同士を
足した結果のストリームの1番目の要素だから、
1+1=2=2<sup>1</sup>である。

3番目の要素は、1と2から始まる <tt>s</tt> というストリーム同士を
足した結果のストリームの2番目の要素だから、
2+2=4=2<sup>2</sup>である。

以下同様で、k番目の要素は、2<sup>k&minus;1</sup>である。</span>

               s  = (1  2  4   8 ...
               s  = (1  2  4   8 ...
(add-streams s s) = (2  4  8  16 ...
</p>

<p class="orig" lang="en"><a name="%_thm_3.54"></a>
<b>Exercise 3.54.</b>  Define a procedure <a name="%_idx_3886"></a><a name="%_idx_3888"></a><a name="%_idx_3890"></a><tt>mul-streams</tt>, analogous to <tt>add-streams</tt>,
that produces the elementwise product of its two input streams.
Use this together with the stream of <tt>integers</tt> to complete the
following definition of the stream whose <em>n</em>th element (counting from 0)
is <em>n</em> + 1 factorial:
</p>

<p class="trans" lang="ja">
<b>練習問題3.54.</b> <tt>add-streams</tt> と類似した、二つの入力ストリームの要素ごとの積を作り出すような <tt>mul-streams</tt> という手続きを、定義せよ。
これを <tt>integers</tt> のストリームとともに使って、<em class="en">n</em> 番目の要素 (0から数える) が
<span class="math"><em class="en">n</em> + 1</span>
の階乗であるようなストリームについての以下の定義を完成させよ。
</p>

<p class="lisp">(define factorials (cons-stream 1 (mul-streams &lt;<em>??</em>&gt; &lt;<em>??</em>&gt;)))
</p>
<!--
     n:  0  1  2   3    4 ...
(n+1)!:  1  2  6  24  120 ...
-->
<p class="exercise"><span class="ex_comment">; まず定義。</span>
(define (mul-streams s1 s2) (stream-map * s1 s2))

<span class="ex_comment">ここで、以下のように考えられる。</span>
              n:  0  1  2   3    4 ...
    factorials = (1  2  6  24  120 ...
(cdr integers) = (2  3  4   5    6 ... 

<span class="ex_comment">; ということは、</span>
(define factorials (cons-stream 1 (mul-streams (cdr integers) factorials)))
<span class="ex_comment">; あるいは、</span>
(define factorials (cons-stream 1 (mul-streams factorials (cdr integers))))
<span class="ex_comment">; と定義すれば良いだろう。
</p>

<p class="orig" lang="en"><a name="%_thm_3.55"></a>
<b>Exercise 3.55.</b>  Define a procedure <a name="%_idx_3892"></a><tt>partial-sums</tt> that takes as argument a
stream <em>S</em> and returns the stream whose
elements are <em>S</em><sub>0</sub>, <em>S</em><sub>0</sub> + <em>S</em><sub>1</sub>, <em>S</em><sub>0</sub> + <em>S</em><sub>1</sub> + <em>S</em><sub>2</sub>, <tt>...</tt>.  For example, <tt>(partial-sums integers)</tt> should be the stream
1, 3, 6, 10, 15, <tt>...</tt>.
</p>

<p class="trans" lang="ja">
<b>練習問題3.55.</b> <em class="en">S</em> というストリームを引数としてとって、
<span class="math"><em class="en">S</em><sub>0</sub></span>, 
<span class="math"><em class="en">S</em><sub>0</sub> + <em class="en">S</em><sub>1</sub>, 
<span class="math"></span><em class="en">S</em><sub>0</sub> + <em class="en">S</em><sub>1</sub> + <em class="en">S</em><sub>2</sub>,</span> 
<tt>...</tt>
を要素とするストリームを返すような、<tt>partial-sums</tt> という手続きを定義せよ。
たとえば、<tt>(partial-sums integers)</tt> は、1, 3, 6, 10, 15, <tt>...</tt> を返すはずだ。
</p>

<p class="exercise">    S0   S1   S2   S3   S4 ...
     0   S0   S1   S2   S3 ...
     0    0   S0   S1   S2 ...
               ︙
+&#41;_______________________________

<span class="ex_comment">という足し算をしたいのだな。でも素直にこういう計算はできなそう。
で、考え直してみると、以下のようになっている。</span>

                    S   = (S0  S1     S2        S3           S4 ...)
      (partial-sums S)  = (S0  S0+S1  S0+S1+S2  S0+S1+S2+S3  ...)
        (stream-cdr S)  = (S1  S2     S3        S4 ...)

<span class="ex_comment">; というわけで、多分以下の定義になるはず。</span>

(define (partial-sums S)
  (cons (stream-car S)
        (add-streams (partial-sums S) (stream-cdr S))))
</p>


<p class="orig" lang="en"><a name="%_thm_3.56"></a>
<b>Exercise 3.56.</b>  A famous problem, first raised by <a name="%_idx_3894"></a>R. Hamming, is to enumerate, in
ascending order with no repetitions, all positive integers with no
prime factors other than 2, 3, or 5.  One obvious way to do this is to
simply test each integer in turn to see whether it has any factors
other than 2, 3, and 5.  But this is very inefficient, since, as the
integers get larger, fewer and fewer of them fit the requirement.  As
an alternative, let us call the required stream of numbers <tt>S</tt> and
notice the following facts about it.
</p>

<p class="trans" lang="ja">
<b>練習問題3.56.</b> ある有名な問題——最初にR. ハミングにより提起された——は、2と3と5以外の素数の因子を持たないすべての正整数を、繰り返しなしに昇順で数え上げること、というものである。
これを行うための一つの自明な方法は、単に、順番に各整数を調べて、その整数には2と3と5以外の因子が何かあるのか否かを確かめることである。
しかしこれは、とても非効率である。というのも、整数が大きくなるにつれて、それらの整数のうち、ますますわずかなものしか、要件に合致しなくなるからである。
代替策として、求められている数のストリームを <tt>S</tt> と呼ぼう。そして、これに関する以下の事実に留意しよう。
</p>

<ul class="orig" lang="en">
<li><tt>S</tt> begins with 1.</li>

<li>The elements of <tt>(scale-stream S 2)</tt> are also 
elements of <tt>S</tt>.</li>

<li>The same is true for <tt>(scale-stream S 3)</tt> 
and <tt>(scale-stream 5 S)</tt>.</li>

<li>These are all the elements of <tt>S</tt>.</li>
</ul>

<ul class="trans" lang="ja">
<li><tt>S</tt> は1で始まる。</li>
<li><tt>(scale-stream S 2)</tt> の要素は、<tt>S</tt> の要素でもある</li>
<li><tt>(scale-stream S 3)</tt> と <tt>(scale-stream 5 S)</tt> についても同じことが成り立つ。</li>
<li>これらはすべて <tt>S</tt> の要素である。</li>
</ul>


<p class="orig" lang="en">
<a name="%_idx_3896"></a>Now all we have to do is combine elements from these sources.
For this we define a procedure <tt>merge</tt> that combines two ordered
streams into one ordered result stream, eliminating repetitions:</p>

<p class="trans" lang="ja">
さて、あとは、これらの源からの要素を繋ぎ合わせるだけだ。
このことのために、私たちは、繰り返しになっているものを削除しながら、順序づけられた二つのストリームを順序づけられた一つの結果ストリームへと結合する、 <tt>merge</tt> という手続きを定義する。
</p>

<p class="lisp"><a name="%_idx_3898"></a>(define (merge s1 s2)
  (cond ((stream-null? s1) s2)
        ((stream-null? s2) s1)
        (else
         (let ((s1car (stream-car s1))
               (s2car (stream-car s2)))
           (cond ((&lt; s1car s2car)
                  (cons-stream s1car (merge (stream-cdr s1) s2)))
                 ((&gt; s1car s2car)
                  (cons-stream s2car (merge s1 (stream-cdr s2))))
                 (else
                  (cons-stream s1car
                               (merge (stream-cdr s1)
                                      (stream-cdr s2)))))))))
</p>


<p class="orig" lang="en">
Then the required stream may be constructed with <tt>merge</tt>, as
follows:</p>

<p class="trans" lang="ja">
すると、以下のようにして、<tt>merge</tt> を用いて、要求されているストリームを構築し得る。
</p>

<p class="lisp">(define S (cons-stream 1 (merge &lt;<em>??</em>&gt; &lt;<em>??</em>&gt;)))
</p>


<p class="orig" lang="en">
Fill in the missing expressions in the places marked &lt;<em>??</em>&gt; above.
</p>

<p class="trans" lang="ja">
上記で &lt;<em class="en">??</em>&gt; という印が付いている場所に、欠けている式を書き入れよ。
</p>


<p class="exercise"><span class="ex_comment">; やっつけで書くと、以下のようになるのだが。今度考えよう。</span>
(define S 
  (cons-stream
     1
     (merge (merge (scale-stream S 2) (scale-stream S 3))
            (scale-stream S 5))))

</p>

<p class="orig" lang="en"><a name="%_thm_3.57"></a>
<b>Exercise 3.57.</b>  <a name="%_idx_3900"></a>How many additions are performed when we compute the <em>n</em>th Fibonacci
number using the definition of <tt>fibs</tt> based on the <tt>add-streams</tt> procedure?  Show that the number of additions would be
exponentially greater if we had implemented
<tt>(delay &lt;<em>exp</em>&gt;)</tt> simply as <tt>(lambda () &lt;<em>exp</em>&gt;)</tt>, 
without using the optimization provided by the <tt>memo-proc</tt>
procedure described in section <a href="#%_sec_3.5.1">3.5.1</a>.<a name="call_footnote_Temp_465" href="#footnote_Temp_465"><sup><small>64</small></sup></a>
</p>

<p class="trans" lang="ja">
<b>練習問題3.57.</b> <tt>add-streams</tt> の手続きに基づく <tt>fibs</tt> の定義を使って <em class="en">n</em> 番目のフィボナッチ数を計算するとき、加算が何回おこなわれるだろう?
もし、<a href="#%_sec_3.5.1">3.5.1</a>節で述べた <tt>memo-proc</tt> という手続きによりもたらされる最適化を使わないで、ただ単純に、
<tt>(delay &lt;<em class="en">exp</em>&gt;)</tt> 
を
<tt>(lambda () &lt;<em class="en">exp</em>&gt;)</tt>
と実装していたら、加算の回数は指数関数的に大きくなっただろう、ということを示せ<a name="call_footnote_Temp_465" href="#footnote_Temp_465"><sup><small>64</small></sup></a>。
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.58"></a>
<b>Exercise 3.58.</b>  Give an interpretation of the stream computed by the following
procedure:</p>

<p class="trans" lang="ja">
<b>練習問題3.58.</b> 以下の手続きによって計算されるストリームの解釈を述べよ。
</p>


<p class="lisp">(define (expand num den radix)
  (cons-stream
   (quotient (* num radix) den)
   (expand (remainder (* num radix) den) den radix)))
</p>


<p class="orig" lang="en">
<a name="%_idx_3906"></a><a name="%_idx_3908"></a>(<tt>Quotient</tt> is a primitive that returns the integer quotient of
two integers.)  What are the successive elements produced by <tt>(expand 1 7 10)</tt> ?  What is produced by <tt>(expand 3 8 10)</tt> ?
</p>

<p class="trans" lang="ja">
(<tt>quotient</tt> は、二つの整数についての整数の商を返すプリミティブである。)
<tt>(expand 1 7 10)</tt> により作り出される、連続する要素とは、どのようなものか?  
<tt>(expand 3 8 10)</tt> によって、何が作り出されるか?
</p>


<p class="exercise"><span class="ex_comment">numもdenもradix未満というのが、おそらく暗黙の前提。
で、基数をradixとして数を表現する場合において、numをdenで割ったらどうなるか、というのを、
   * 第1要素は、(整数部が0でない場合は整数部と)小数第1位、
   * 第2要素は、小数第2位、
   * 第3要素は、小数第3位、
   * 以下同様
とやっているはず。
で、多分、暗黙の前提としてさらに、numがden未満という制約があるのだろう。
この制約があれば、整数部は0であり、この0は、出力ストリームには出てこない。
</span>
   (expand 1 7 10)
 = (cons-stream (quotient 10 7) (expand (remainder 10 7) 7 10)
 = (cons-stream 1 (expand 3 7 10))
 = (cons-stream 1
     (cons-stream (quotient 30 7) (expand (remainder 30 7) 7 10)))
 = (cons-stream 1
     (cons-stream 4 (expand 2 7 10)))
 = (cons-stream 1
     (cons-stream 4
       (cons-stream (quotient 20 7) (expand (remainder 20 7) 7 10))))
 = (cons-stream 1
     (cons-stream 4
       (cons-stream 2 (expand 6 7 10))))
 = ...
 = (1 4 2 ...)

<span class="ex_comment">と、なるわけだが、これは、以下の筆算を表している、とも言える。
1/7は循環小数だから、出力ストリームは当然、無限ストリームになる。</span>

    0.142857 ...
  ________________
7 &#41; 1.000000 ...
      7
   ---------------
      30
      28
   ---------------
       20
       14
   ---------------
        60
        56
   ---------------
         40
         35
   ---------------
          50
          49
   ---------------
           1
           (以下略)

<span class="ex_comment">他方、3/8 = 0.375 で、これは有限小数。</span>
   (expand 3 8 10)
 = (cons-stream (quotient 30 8) (expand (remainder 30 8) 8 10))
 = (cons-stream 3 (expand 6 8 10))
 = (cons-stream 3
     (cons-stream (quotient 60 8) (expand (remainder 60 8) 8 10)))
 = (cons-stream 3
     (cons-stream 7 (expand 4 8 10)))
 = (cons-stream 3
     (cons-stream 7
       (cons-stream (quotient 40 8) (expand (remainder 40 8) 8 10))))
 = (cons-stream 3
     (cons-stream 7
       (cons-stream 5 (expand 0 8 10))))
 = (cons-stream 3 
     (cons-stream 7 
       (cons-stream 5 (cons-stream (quotient 0 8) (expand (remainder 0 8) 8 10)))))
 = (cons-stream 3 
     (cons-stream 7 
       (cons-stream 5 
         (cons-stream 0 (expand 0 8 10)))))
 = ...
 = (3 7 5 0 0 0 ...)

<span class="ex_comment">と、まあ、有限小数でも、このようになるので、出力ストリームは無限なのだった。</span>
</p>

<p class="orig" lang="en"><a name="%_thm_3.59"></a>
<b>Exercise 3.59.</b>  <a name="%_idx_3910"></a><a name="%_idx_3912"></a>In section <a href="18_sec2_5.html#%_sec_2.5.3">2.5.3</a> we saw how to implement a
polynomial arithmetic system representing polynomials as lists of
terms.  In a similar way, we can work with <em>power series</em>, such as</p>

<p class="trans" lang="ja">
<b>練習問題3.59.</b> <a href="18_sec2_5.html#%_sec_2.5.3">2.5.3</a>節では、多項式を項のリストとして表現する多項式算術システムをどうやって実装するのか、ということを見た。
同様にして、私たちは、以下のような<em>冪級数</em>を使って、作業することができる。
</p>

<figure>
<a name="%_idx_3914"></a>
<img src="ch3-Z-G-36.gif" border="0"><br>
<a name="%_idx_3916"></a>
<img src="ch3-Z-G-37.gif" border="0"><br>
<a name="%_idx_3918"></a>
<img src="ch3-Z-G-38.gif" border="0">
</figure>

<p class="orig" lang="en">
represented as infinite streams.
We will represent the series
<em>a</em><sub>0</sub>  +  <em>a</em><sub>1</sub> <em>x</em>  +  <em>a</em><sub>2</sub> <em>x</em><sup>2</sup>  +  <em>a</em><sub>3</sub> <em>x</em><sup>3</sup>  +  <tt>&middot;&middot;&middot;</tt>
as the stream whose elements are the coefficients <em>a</em><sub>0</sub>, <em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, <em>a</em><sub>3</sub>, <tt>...</tt>.</p>

<p class="trans" lang="ja">
——なお、これらは無限ストリームとして表現されている。
<span class="math"><em class="en">a</em><sub>0</sub>  +  <em class="en">a</em><sub>1</sub> <em class="en">x</em>  +  <em class="en">a</em><sub>2</sub> <em class="en">x</em><sup>2</sup>  +  <em class="en">a</em><sub>3</sub> <em class="en">x</em><sup>3</sup>  +  <tt>&middot;&middot;&middot;</tt></span>
という級数を、
<em class="en">a</em><sub>0</sub>, <em class="en">a</em><sub>1</sub>, <em class="en">a</em><sub>2</sub>, <em class="en">a</em><sub>3</sub>, <tt>...</tt>
という係数をその要素とするストリームとして、表現しよう。
</p>

<p class="orig" lang="en"><a name="%_idx_3920"></a><a name="%_idx_3922"></a>a. The integral of the series <em>a</em><sub>0</sub>  +  <em>a</em><sub>1</sub> <em>x</em>  +  <em>a</em><sub>2</sub> <em>x</em><sup>2</sup>  +  <em>a</em><sub>3</sub> <em>x</em><sup>3</sup>  +  <tt>&middot;&middot;&middot;</tt>
is the series
</p>

<p class="trans" lang="ja">a. 
<span class="math"><em class="en">a</em><sub>0</sub>  +  <em class="en">a</em><sub>1</sub> <em class="en">x</em>  +  <em class="en">a</em><sub>2</sub> <em class="en">x</em><sup>2</sup>  +  <em class="en">a</em><sub>3</sub> <em class="en">x</em><sup>3</sup>  +  <tt>&middot;&middot;&middot;</tt></span>
という級数の積分は、以下の級数であり、
</p>

<figure><img src="ch3-Z-G-39.gif" border="0"></figure>


<p class="orig" lang="en">
where <em>c</em> is any constant.
Define a procedure <a name="%_idx_3924"></a><tt>integrate-series</tt> that takes as input a stream
<em>a</em><sub>0</sub>, <em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, <tt>...</tt> representing a power series and returns the stream
<em>a</em><sub>0</sub>, (1/2)<em>a</em><sub>1</sub>, (1/3)<em>a</em><sub>2</sub>, <tt>...</tt> of coefficients of
the non-constant terms of the integral of the series.
(Since the result has no constant term, it doesn't represent a power
series; when we use <tt>integrate-series</tt>, we will <tt>cons</tt> on
the appropriate constant.) </p>

<p class="trans" lang="ja">
ここで、<em class="en">c</em> は任意の定数である。
冪級数を表す
<em class="en">a</em><sub>0</sub>, <em class="en">a</em><sub>1</sub>, <em class="en">a</em><sub>2</sub>, <tt>...</tt> 
というストリームを入力としてとり、
その級数の積分の、定数でない項の係数の、
<em class="en">a</em><sub>0</sub>, (1/2)<em class="en">a</em><sub>1</sub>, (1/3)<em class="en">a</em><sub>2</sub>, <tt>...</tt> 
というストリームを返すような、<tt>integrate-series</tt> という手続きを定義せよ。
(結果は、定数項を持たないので、冪級数を表してはいない。<tt>integrate-series</tt> を使う場合は、適切な定数に対して <tt>cons</tt> することになろう。) 
</p>

<p class="exercise"><span class="ex_comment">; 再掲</span><!--
(define ones (cons-stream 1 ones))
(define (add-streams s1 s2) (stream-map + s1 s2))
(define integers (cons-stream 1 (add-streams ones integers)))-->
(define (mul-streams s1 s2) (stream-map * s1 s2))

<span class="ex_comment">; さてここから。まずは、1/1, 1/2, 1/3, ... という数列を作る。</span>
(define (inverse-of-integers-starting-from n)
  (cons-stream (/ 1 n) (inverse-of-integers-starting-from (+ n 1))))
(define inverses (inverses-of-integers-starting-from 1))
<span class="ex_comment">; それで、本題。</span>
(define (integrate-series power-series-coefficients)
  (mul-streams power-series-coefficients inverses))
</p>

<p class="orig" lang="en">b. The function <em>x</em> <img src="book-Z-G-D-17.gif" border="0">  <em>e</em><sup><em>x</em></sup> is its own
derivative.  This implies that <em>e</em><sup><em>x</em></sup> and the integral of <em>e</em><sup><em>x</em></sup> are the
same series, except for the constant term, which is <em>e</em><sup>0</sup>  = 1.
Accordingly, we can generate the series for 
<em>e</em><sup><em>x</em></sup> as
</p>

<p class="trans" lang="ja">b. 
<span class="math"><em class="en">x</em> &mapsto; <em class="en">e</em><sup><em class="en">x</em></sup></span>
という関数は、自分自身の導関数である。
これは、
<span class="math"><em class="en">e</em><sup><em class="en">x</em></sup></span>
と、
<span class="math"><em class="en">e</em><sup><em class="en">x</em></sup></span>
の積分とが、定数項——
<span class="math"><em class="en">e</em><sup>0</sup>  = 1</span> 
である——を除いては同じ級数である、ということを暗示している。
したがって、
<span class="math"><em class="en">e</em><sup><em class="en">x</em></sup></span> 
についての級数を、以下のように生成できる。
</p>

<p class="lisp">(define exp-series
  (cons-stream 1 (integrate-series exp-series)))
</p>

<p class="orig" lang="en">
Show how to generate the series for sine and cosine, starting from the facts
that the derivative of sine is cosine and the derivative of cosine is
the negative of sine:
</p>

<p class="trans" lang="ja">サインの導関数はコサインであり、コサインの導関数はサインの正負を反転したものだ、という事実から始めて、サインとコサインに対する級数をどうやって生成するのかを示せ。
</p>


<p class="lisp">(define cosine-series
  (cons-stream 1 &lt;<em>??</em>&gt;))
(define sine-series
  (cons-stream 0 &lt;<em>??</em>&gt;))
</p>

<p class="exercise"><span class="ex_comment">ありがたいことに、定数項は答えが書いてある。というわけで、
cos x = 1 + c<sub>1</sub> x + c<sub>2</sub> x<sup>2</sup> + c<sub>3</sub> x<sup>3</sup> + ...
sin x = 0 + s<sub>1</sub> x + s<sub>2</sub> x<sup>2</sup> + s<sub>3</sub> x<sup>3</sup> + ...
とおくことができる。なお、c<sub>0</sub>=1, s<sub>0</sub>=0 である。

  ∫ cos x dx
= const. + c<sub>0</sub> x + c<sub>1</sub>/2 x<sup>2</sup> + c<sub>2</sub>/3 x<sup>3</sup> + c<sub>3</sub>/4 x<sup>4</sup> ...
= sin x + const. 
= const. + s<sub>1</sub> x + s<sub>2</sub> x<sup>2</sup> + s<sub>3</sub> x<sup>3</sup> + ...
なので、s<sub>1</sub>&equiv;c<sub>0</sub>, s<sub>2</sub>&equiv;c<sub>1</sub>/2, s<sub>3</sub>&equiv;c<sub>2</sub>/3, ... である。よって、以下のように定義できる。</span>

(define sine-series
  (cons-stream 0 (integrate-series cosine-series)))

<span class="ex_comment">同様に、
  ∫ sin x dx
= const. + s<sub>0</sub> x + s<sub>1</sub>/2 x<sup>2</sup> + s<sub>2</sub>/3 x<sup>3</sup> + s<sub>3</sub>/4 x<sup>4</sup> ...
= &minus;cos x + const.
= (const. &minus; 1) &minus; c<sub>1</sub> x &minus; c<sub>2</sub> x<sup>2</sup> &minus; c<sub>3</sub> x<sup>3</sup> &minus; ...
なので、c<sub>1</sub>&equiv;&minus;s<sub>0</sub>, c<sub>2</sub>&equiv;&minus;s<sub>1</sub>/2, c<sub>3</sub>&equiv;&minus;s<sub>2</sub>/3, ... である。よって、以下のように定義できる。</span>

(define (minus-stream s) (stream-map (lambda (x) (- x)) s))
(define cosine-series
  (cons-stream 1 (minus-stream (integrate-series sine-series))))
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.60"></a>
<b>Exercise 3.60.</b>  <a name="%_idx_3926"></a><a name="%_idx_3928"></a><a name="%_idx_3930"></a><a name="%_idx_3932"></a>With power series represented as streams of coefficients as in
exercise <a href="#%_thm_3.59">3.59</a>, adding series is implemented by <tt>add-streams</tt>.  Complete the definition of the following procedure for
multiplying series:
</p>

<p class="trans" lang="ja">
<b>練習問題3.60.</b> 練習問題<a href="#%_thm_3.59">3.59</a>でのように、係数のストリームとして表された冪級数を使うと、級数同士を足すことは、<tt>add-streams</tt> により実装される。
級数同士の乗算のための以下の手続きの定義を完成させよ。
</p>

<p class="lisp">(define (mul-series s1 s2)
  (cons-stream &lt;<em>??</em>&gt; (add-streams &lt;<em>??</em>&gt; &lt;<em>??</em>&gt;)))
</p>

<p class="orig" lang="en">
You can test your procedure by verifying that
<em>s</em><em>i</em><em>n</em><sup>2</sup> <em>x</em>  +  <em>c</em><em>o</em><em>s</em><sup>2</sup> <em>x</em>  =  1, using the series from exercise <a href="#%_thm_3.59">3.59</a>.
</p>

<p class="trans" lang="ja">
練習問題<a href="#%_thm_3.59">3.59</a>の級数を使って、
<span class="math">sin<sup>2</sup> <em class="en">x</em> + cos<sup>2</sup> <em class="en">x</em> = 1</span>
ということを確かめることで、君は、自分の手続きを試すことが可能だ。
</p>


<p class="exercise"><span class="ex_comment"><!--二つの級数の積は、以下のようになる。
  (a<sub>0</sub> + a<sub>1</sub>x + a<sub>2</sub>x<sup>2</sup> + a<sub>3</sub>x<sup>3</sup> + ...) &times; (b<sub>0</sub> + b<sub>1</sub>x + b<sub>2</sub>x<sup>2</sup> + b<sub>3</sub>x<sup>3</sup> + ...)
= a<sub>0</sub> b<sub>0</sub> + (a<sub>0</sub> b<sub>1</sub> + a<sub>1</sub> b<sub>0</sub>) x + (a<sub>0</sub> b<sub>2</sub> + a<sub>1</sub> b<sub>1</sub> + a<sub>2</sub> b<sub>0</sub>) x<sup>2</sup> + (a<sub>0</sub> b<sub>3</sub> + a<sub>1</sub> b<sub>2</sub> + a<sub>2</sub> b<sub>1</sub> + a<sub>3</sub> b<sub>0</sub>) x<sup>3</sup> + ...

のではあるが、これからどうやって進めようかな……。</span>

(define (mul-series s1 s2)
  (cons-stream
    (* (stream-car s1) (stream-car s2))
    (add-streams &lt;<em>??</em>&gt; &lt;<em>??</em>&gt;)))

<span class="ex_comment">という形になりそうな気もするが、後ろが埋まらない。

= a<sub>0</sub> (b<sub>0</sub> + b<sub>1</sub>x + b<sub>2</sub>x<sup>2</sup> + b<sub>3</sub>x<sup>3</sup> ...) + 
   a<sub>1</sub> (0 + b<sub>0</sub>x + b<sub>1</sub>x<sup>2</sup> + b<sub>2</sub>x<sup>3</sup> + b<sub>3</sub>x<sup>4</sup> ...) + 
   a<sub>2</sub> (0 + 0 + b<sub>0</sub>x<sup>2</sup> + b<sub>1</sub>x<sup>3</sup> + b<sub>2</sub>x<sup>4</sup> + b<sub>3</sub>x<sup>5</sup> ...) + ...

とかって変形してみたけど、なんかうまくいきそうにないな。むむ。</span>

<span class="ex_comment">とりあえず、検証用のコードだけ先に書こうかな。以下のような感じだろうか……。</span>

<span class="ex_comment">; (1 x x<sup>2</sup> x<sup>3</sup> ...) を作る</span>
(define (x-series x)
  (cons-stream
    1
    (stream-map (lambda (elem) (* x elem)) (x-series x))))--><!--
(define (unit-stream x) (cons-stream x (unit-stream x)))
(define (x-series x) (cons-stream 1 (mul-streams (unit-stream x) 
(define (verify-at x)
  (let
     <span class="ex_comment">; (x x x ...) を作る</span>
    ((unit-stream (cons-stream x (unit-stream)))
     <span class="ex_comment">; (1 x x<sup>2</sup> x<sup>3</sup> ...) を作る</span>
     (x-series (cons-stream 1 (mul-streams x-series unit-stream
-->
<!--<span class="ex_comment">; 確認用の手続きを作る。こんなんかな?</span>
(define (verify-at x num-of-terms-to-be-considered)
  (define (iter accum n-more-elements s)
    (if (= n-more-elements 0)
        accum
        (iter (+ accum (stream-car s)) (- n-more-elements 1))))
  (iter 0 num-of-terms-to-be-considered 
       (add-stream
          (mul-stream (x-series x) (cons-stream 0 (mul-series sine-series sine-series)))
          (mul-stream (x-series x) (cons-stream 1 (mul-series cosine-series cosine-series))))))
<span class="ex_comment">; 8というのは適当に決めてみた定数。これくらいまで見れば多分収束しているだろ。
; [0, 1] の範囲内のいくつかの x について、確認してみる。</span>
(verify-at 0.0 8)

(verify-at 0.1 8)

(verify-at 0.5 8)

(verify-at 0.8 8)

(verify-at 1.0 8)
-->
</p>

<p class="orig" lang="en"><a name="%_thm_3.61"></a>
<b>Exercise 3.61.</b>  Let <em>S</em> be a power series (exercise <a href="#%_thm_3.59">3.59</a>)
whose constant term is 1.  Suppose we want
to find the power series 1/<em>S</em>, that is, the series <em>X</em> such that
<em>S</em> &middot;  <em>X</em> =  1.  Write <em>S</em> = 1 + <em>S</em><sub><em>R</em></sub> where <em>S</em><sub><em>R</em></sub> is the part of <em>S</em> after
the constant term.  Then we can solve for <em>X</em> as follows:
</p>

<p class="trans" lang="ja">
<b>練習問題3.61.</b> <em class="en">S</em> を、定数項が 1 の冪級数 (練習問題<a href="#%_thm_3.59">3.59</a>) とする。
1/<em class="en">S</em> という冪級数——つまり、
<span class="math"><em class="en">S</em> &middot; <em class="en">X</em> =  1</span>
であるような <em class="en">X</em> の級数——を求めたいものとする。
<em class="en">S</em><sub><em class="en">R</em></sub> が定数項より後の <em class="en">S</em> の部分だとして、
<span class="math"><em class="en">S</em> = 1 + <em class="en">S</em><sub><em class="en">R</em></sub></span>
と書こう。
すると、<em class="en">X</em> について次のように解ける。
</p>

<figure><img src="ch3-Z-G-40.gif" border="0"></figure>


<p class="orig" lang="en">
In other words, <em>X</em> is the power series whose constant term is 1 and
whose higher-order terms are given by the negative of <em>S</em><sub><em>R</em></sub> times <em>X</em>.
Use this idea to write a procedure <tt>invert-unit-series</tt> that computes 1/<em>S</em> for a power series <em>S</em> with
constant term 1.
You will need to use <tt>mul-series</tt> from exercise <a href="#%_thm_3.60">3.60</a>.
</p>

<p class="trans" lang="ja">
換言すると、<em class="en">X</em> とは、定数項が 1 で、かつ、より高次の項は <em class="en">S<sub>R</sub></em> 掛ける <em class="en">X</em> の正負を反転したものによって与えられるような、冪級数である。
1 という定数項を有する <em class="en">S</em> という冪級数に対して 1/<em class="en">S</em> を計算するような、<tt>invert-unit-series</tt> という手続きを、上記の考え方を使って書け。
練習問題<a href="#%_thm_3.60">3.60</a>の <tt>mul-series</tt> が必要になるだろう。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.62"></a>
<b>Exercise 3.62.</b>  <a name="%_idx_3934"></a><a name="%_idx_3936"></a><a name="%_idx_3938"></a>Use the results of exercises <a href="#%_thm_3.60">3.60</a>
and <a href="#%_thm_3.61">3.61</a> to define a procedure <tt>div-series</tt>
that divides two power series.  <tt>Div-series</tt> should work for any
two series, provided that the denominator series begins with a
nonzero constant term.  (If the denominator has a zero constant term,
then <tt>div-series</tt> should signal an error.)
Show how to use <tt>div-series</tt>
together with the result of exercise <a href="#%_thm_3.59">3.59</a> to generate
<a name="%_idx_3940"></a>the power series for tangent.
</p>

<p class="trans" lang="ja">
<b>練習問題3.62.</b> 練習問題<a href="#%_thm_3.60">3.60</a>と<a href="#%_thm_3.61">3.61</a>の結果を使って、二つの冪級数の除算を行う <tt>div-series</tt> という手続きを定義せよ。
分母の級数が非ゼロの定数項で始まる限り、<tt>div-series</tt> は、いかなる二つの級数に対しても、きちんと動くべきである。
(もし分母が、ゼロの定数項を有するならば、<tt>div-series</tt> は、エラーを知らせるべきである。)
タンジェントの冪級数を生成するためには、練習問題<a href="#%_thm_3.59">3.59</a>の結果とともに <tt>div-series</tt> をどのように使えばよいのか、ということを示せ。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_3.5.3"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_3.5.3">3.5.3  Exploiting the Stream Paradigm</a></h3>
<h3 class="trans" lang="ja">3.5.3 ストリーム・パラダイムを使い倒す</h3>

<p class="orig" lang="en">
Streams with delayed evaluation can be a powerful modeling tool,
providing many of the benefits of local state and assignment.
Moreover, they avoid some of the theoretical tangles that accompany
the introduction of assignment into a programming language.</p>

<p class="trans" lang="ja">
遅延評価を使ったストリームは、強力なモデル化手段たり得るし、また、局所状態と<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>の恩恵の多くをもたらしてくれる。
さらに、プログラミング言語に<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>を持ち込むことに付随する、理論的なからまりのうちのいくつかを、回避できる。
</p>

<p class="orig" lang="en">
<a name="%_idx_3942"></a>The stream approach can be illuminating because it allows us to build
systems with different module boundaries than systems organized around
assignment to state variables.  For example, we can think of an entire
time series (or signal) as a focus of interest, rather than the values
of the state variables at individual moments.  This makes it
convenient to combine and compare components of state from different
moments.</p>

<p class="trans" lang="ja">
ストリームの手法は、状態変数への<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>に合わせて体系化されたシステムとは異なるモジュール境界を持ったシステムを構築できるようにしてくれるので、理解の助けになり得る。
たとえば、個々の瞬間における状態変数の値というよりむしろ、時間列 (または信号) の全体を、興味の中心として考えることができる。
これによって、異なる瞬間の状態の成分同士を結合したり比較したりすることが、簡便化される。
</p>

<a name="%_sec_Temp_471"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_471">Formulating iterations as stream processes</a></h4>
<h4 class="trans" lang="ja">反復をストリーム・プロセスとして定式化する</h4>

<p class="orig" lang="en">
<a name="%_idx_3944"></a>
In section <a href="11_sec1_2.html#%_sec_1.2.1">1.2.1</a>, we introduced iterative
processes, which proceed by updating state variables.  We know now
that we can represent state as a ``timeless'' stream of values rather
than as a set of variables to be updated.  Let's adopt this
perspective in revisiting the square-root procedure from
section <a href="10_sec1_1.html#%_sec_1.1.7">1.1.7</a>.  Recall that the idea is to generate a
sequence of better and better guesses for the square root of <em>x</em> by
applying over and over again the procedure that improves guesses:</p>

<p class="trans" lang="ja">
<a href="11_sec1_2.html#%_sec_1.2.1">1.2.1</a>節では、反復プロセス——状態変数を更新することによって進行する——を導入した。
今や私たちは、状態を、更新すべき変数の集合というよりもむしろ、値の「時間を超越した」ストリームとして、表現できるのだ、ということを知っている。
この観点を、<a href="10_sec1_1.html#%_sec_1.1.7">1.1.7</a>節の二乗根の手続きを再検討する際に、取り入れてみよう。
重要なことは、推定値を改善する手続きを何度も繰り返し適用することによって、<em class="en">x</em> の二乗根についてのどんどん良くなっていく推定値の列を生成することだ、ということを思い出そう。
</p>


<p class="lisp">(define (sqrt-improve guess x)
  (average guess (/ x guess)))
</p>

<p class="orig" lang="en">
<a name="%_idx_3946"></a>In our original <tt>sqrt</tt> procedure, we made these guesses be the
successive values of a state variable. Instead we can generate the
infinite stream of guesses, starting with an initial guess of 1:<a name="call_footnote_Temp_472" href="#footnote_Temp_472"><sup><small>65</small></sup></a></p>

<p class="trans" lang="ja">
私たちの元々の <tt>sqrt</tt> の手続きでは、これらの推定値を、ある一つの状態変数の連続的な値としていた。
その代わりに、私たちは、1という初期推定値から始めて、推定値の無限ストリームを生成することができる<a href="#footnote_Temp_472"><sup><small>65</small></sup></a>。
</p>

<p class="lisp"><a name="%_idx_3948"></a>(define (sqrt-stream x)
  (define guesses
    (cons-stream 1.0
                 (stream-map (lambda (guess)
                               (sqrt-improve guess x))
                             guesses)))
  guesses)
(display-stream (sqrt-stream 2))
<i>1.</i>
<i>1.5</i>
<i>1.4166666666666665</i>
<i>1.4142156862745097</i>
<i>1.4142135623746899</i>
<tt>...</tt></p>

<p class="exercise"><span class="ex_comment">ちなみに &radic;2 をbc で計算すると以下のとおり。</span>
$ bc -l
scale=40
x=sqrt(2.0)
x
1.4142135623730950488016887242096980785696
</p>

<p class="orig" lang="en">
We can generate more and more terms of the stream to get better and
better guesses.  If we like, we can write a procedure that keeps
generating terms until the answer is good enough.  (See
exercise <a href="#%_thm_3.64">3.64</a>.)</p>

<p class="trans" lang="ja">
さらに良い推定値を得るために、ストリームのさらに多くの項を生成することができる。
もし望むなら、答えが十分よくなるまで項を生成し続ける手続きも書ける。
(練習問題<a href="#%_thm_3.64">3.64</a>を参照。)
</p>

<p class="orig" lang="en">
<a name="%_idx_3950"></a><a name="%_idx_3952"></a><a name="%_idx_3954"></a><a name="%_idx_3956"></a><a name="%_idx_3958"></a><a name="%_idx_3960"></a>Another iteration that we can treat in the same way is to generate an
approximation to <img src="book-Z-G-D-9.gif" border="0">, based upon the alternating series that we saw
in section <a href="12_sec1_3.html#%_sec_1.3.1">1.3.1</a>:</p>

<p class="trans" lang="ja">
同様の方法で扱える別の反復は、<a href="12_sec1_3.html#%_sec_1.3.1">1.3.1</a>節で見た交代級数に基づいて、&pi; の近似値を生成することである。
</p>


<figure><img src="ch3-Z-G-41.gif" border="0"></figure>


<p class="orig" lang="en">
We first generate the stream of summands of the series (the reciprocals
of the odd integers, with alternating signs).  Then we take the stream
of sums of more and more terms (using the <tt>partial-sums</tt> procedure
of exercise <a href="#%_thm_3.55">3.55</a>) and scale the result by 4:
</p>


<p class="trans" lang="ja">
まず、この級数で足されるもの (交代交代の正負符号を有する、奇数の逆数) のストリームを生成する。
それから、どんどん多くなってゆく項の和のストリームをとる (練習問題<a href="#%_thm_3.55">3.55</a>の <tt>partial-sums</tt> という手続きを使う)。
</p>

<p class="lisp">(define (pi-summands n)
  (cons-stream (/ 1.0 n)
               (stream-map - (pi-summands (+ n 2)))))
<a name="%_idx_3962"></a>(define pi-stream
  (scale-stream (partial-sums (pi-summands 1)) 4))
(display-stream pi-stream)
<i>4.</i>
<i>2.666666666666667</i>
<i>3.466666666666667</i>
<i>2.8952380952380956</i>
<i>3.3396825396825403</i>
<i>2.9760461760461765</i>
<i>3.2837384837384844</i>
<i>3.017071817071818</i>
<tt>...</tt></p>

<p class="exercise"><span class="ex_comment">ちなみに &pi; をbc で計算すると以下のとおり。</span>
$ bc -l
scale=40
p=a(sqrt(3.0))*3.0
p
3.1415926535897932384626433832795028841971
</p>

<p class="orig" lang="en">
This gives us a stream of better and better approximations to <img src="book-Z-G-D-9.gif" border="0">,
although the approximations converge rather slowly.  Eight terms of
the sequence bound the value of <img src="book-Z-G-D-9.gif" border="0"> between 3.284 and 3.017.</p>

<p class="trans" lang="ja">
これにより、&pi; に対してどんどん良くなってゆく近似値のストリームが得られる——ただし、近似値はかなりゆっくり収束するのではあるが。
列のうちの8個の項により、&pi; の値は、3.284 と 3.017 の間に絞られた。
</p>


<p class="orig" lang="en">
<a name="%_idx_3964"></a>So far, our use of the stream of states approach is not much different
from updating state variables.  But streams give us an opportunity to
do some interesting tricks.  For example, we can transform a stream
with a <a name="%_idx_3966"></a><em>sequence accelerator</em> that converts a sequence of
approximations to a new sequence that converges to the same value as
the original, only faster.</p>

<p class="trans" lang="ja">
ここまでは、状態のストリームを利用する私たちの手法は、状態変数を更新することとさして変わらない。
しかし、ストリームは、ある種の面白い妙技を実演する機会を与えてくれる。
たとえば、近似値の列を、同じ値へと——ただしより速く——収束する新たな列へと変換する、<em>数列加速器</em>を使って、ストリームを変形できる。
</p>

<p class="orig" lang="en">
One such accelerator, due to the eighteenth-century Swiss mathematician
<a name="%_idx_3968"></a>Leonhard Euler, works well with sequences that are partial sums of
alternating series (series of terms with alternating signs).
In Euler's technique, if <em>S</em><sub><em>n</em></sub> is the <em>n</em>th term
of the original sum sequence, then the accelerated sequence has terms
</p>

<p class="trans" lang="ja">
そうした加速器の一つは、18紀のスイスの数学者のレオンハルト・オイラーによるものなのだが、これは、交代級数 (交代交代の正負符号を有する項からなる数列) の部分和であるような列に対して、うまく機能する。
オイラーの技法では、<em class="en">S<sub>n</sub></em> が元の和の列の <em class="en">n</em> 番目の項だとすると、加速された列には、次のような項がある。

</p>

<figure><img src="ch3-Z-G-42.gif" border="0"></figure>

<p class="orig" lang="en"> 
Thus, if the original sequence is represented as a stream of values,
the transformed sequence is given by</p>

<p class="trans" lang="ja">
よって、もし元の列が値のストリームとして表されるなら、変形された列は、以下により与えられる。
</p>

<p class="lisp"><a name="%_idx_3970"></a>(define (euler-transform s)
  (let ((s0 (stream-ref s 0))           <em>; <em>S</em><sub><em>n</em>-1</sub></em>
        (s1 (stream-ref s 1))           <em>; <em>S</em><sub><em>n</em></sub></em>
        (s2 (stream-ref s 2)))          <em>; <em>S</em><sub><em>n</em>+1</sub></em>
    (cons-stream (- s2 (/ (square (- s2 s1))
                          (+ s0 (* -2 s1) s2)))
                 (euler-transform (stream-cdr s)))))
</p>


<p class="orig" lang="en">
We can demonstrate Euler acceleration with our sequence of
approximations to <img src="book-Z-G-D-9.gif" border="0">:</p>

<p class="trans" lang="ja">
&pi; に対する私たちの近似値の列を使ったオイラーの加速を、私たちは実証できる。
</p>


<p class="lisp">(display-stream (euler-transform pi-stream))
<i>3.166666666666667</i>
<i>3.1333333333333337</i>
<i>3.1452380952380956</i>
<i>3.13968253968254</i>
<i>3.1427128427128435</i>
<i>3.1408813408813416</i>
<i>3.142071817071818</i>
<i>3.1412548236077655</i>
<tt>...</tt></p>

<p class="orig" lang="en">
Even better, we can accelerate the accelerated sequence, and
recursively accelerate that, and so on.  Namely, we create a stream of
streams (a structure we'll call a <a name="%_idx_3972"></a><em>tableau</em>) in which each stream
is the transform of the preceding one:</p>

<p class="trans" lang="ja">
さらに良いことには、加速された列を加速でき、それをまた再帰的に加速でき、以下同様である。
つまり、その中では各ストリームが先行ストリームの変形であるような、ストリームのストリーム (<em>タブロー</em>と呼ぶことにする構造) を作るのだ。
</p>

<p class="lisp"><a name="%_idx_3974"></a>(define (make-tableau transform s)
  (cons-stream s
               (make-tableau transform
                             (transform s))))
</p>

<p class="orig" lang="en">
The tableau has the form</p>

<p class="trans" lang="ja">
タブローは以下の形をしている。
</p>

<figure><img src="ch3-Z-G-43.gif" border="0"></figure>

<p class="orig" lang="en">
Finally, we form a sequence by taking the first term in each row of
the tableau:</p>

<p class="trans" lang="ja">
最後に、タブローの各行における最初の項を取り出すことで、列を形成する。
</p>

<p class="lisp"><a name="%_idx_3976"></a>(define (accelerated-sequence transform s)
  (stream-map stream-car
              (make-tableau transform s)))
</p>


<p class="orig" lang="en">
We can demonstrate this kind of ``super-acceleration'' of the <img src="book-Z-G-D-9.gif" border="0">
sequence:</p>

<p class="trans" lang="ja">
&pi; の列の、この種の「超加速」を、私たちは実証できる。

</p>


<p class="lisp">(display-stream (accelerated-sequence euler-transform
                                      pi-stream))
<i>4.</i>
<i>3.166666666666667</i>
<i>3.142105263157895</i>
<i>3.141599357319005</i>
<i>3.1415927140337785</i>
<i>3.1415926539752927</i>
<i>3.1415926535911765</i>
<i>3.141592653589778</i>
<tt>...</tt></p>


<p class="orig" lang="en">
The result is impressive.  Taking eight terms of the sequence yields
the correct value of <img src="book-Z-G-D-9.gif" border="0"> to 14 decimal places.  If we had used only
the original <img src="book-Z-G-D-9.gif" border="0"> sequence, we would need to compute on the order of
10<sup>13</sup> terms (i.e., expanding the series far enough so that the
individual terms are less then 10<sup>-13</sup>) to get that much accuracy!

We could have implemented these acceleration techniques without
using streams.  But the stream formulation is particularly elegant and
convenient because the entire sequence of states is available to us as a
data structure that can be manipulated with a uniform set of
operations.</p>

<p class="trans" lang="ja">
結果は印象的だ。
8個の項をとれば、小数点以下14桁までの &pi; の正しい値が生み出されるのだ。
もし元の &pi; の列だけを使っていたら、それだけ大した精度を得るためには、10<sup>13</sup> のオーダの個数の項について計算をする必要があっただろう (つまり、個々の項が 10<sup>&minus;13</sup>未満となるように、十分に先まで級数を展開するということ)!
ストリームを使わずに、これらの加速技法を実装することもできただろう。
しかし、ストリームの定式化は並外れて洗練されていて便利である。というのも、状態の列全体が、一律な演算一式を使って操作することのできるデータ構造として、私たちにとって利用可能となっているからである。
</p>


<p class="orig" lang="en"><a name="%_thm_3.63"></a>
<b>Exercise 3.63.</b>  Louis Reasoner asks why the <tt>sqrt-stream</tt> procedure was not
written in the following more straightforward way, without
the local variable <tt>guesses</tt>:
</p>

<p class="trans" lang="ja">
<b>練習問題3.63.</b> ルイス・リーズナは、なぜ <tt>sqrt-stream</tt> の手続きが、以下のようなより分かりやすい方法—— <tt>guesses</tt> という局所変数なし——では書かれなかったのか、と尋ねる。
</p>


<p class="lisp">(define (sqrt-stream x)
  (cons-stream 1.0
               (stream-map (lambda (guess)
                             (sqrt-improve guess x))
                           (sqrt-stream x))))
</p>


<p class="orig" lang="en">
Alyssa P. Hacker replies that this version of the procedure is
considerably less efficient because it performs redundant computation.
Explain Alyssa's answer.  Would the two versions still differ in
efficiency if our implementation of <tt>delay</tt> used only <tt>(lambda
() &lt;<em>exp</em>&gt;)</tt> without using the optimization provided by <tt>memo-proc</tt> (section <a href="#%_sec_3.5.1">3.5.1</a>)?

</p>

<p class="trans" lang="ja">
アリッサ・P・ハッカは、このバージョンの手続きは、冗長な計算を実行するせいで、かなり効率が悪くなっているんだよ、と答える。
アリッサの答えについて説明せよ。
もし、私たちの <tt>delay</tt> の実装が、<tt>memo-proc</tt> によりもたらされる最適化 (<a href="#%_sec_3.5.1">3.5.1</a>節) を利用せず、単に
<tt>(lambda () &lt;<em class="en">exp</em>&gt;)</tt> 
のみを使っていたとしたら、それでも二つのバージョンは効率に差があっただろうか?
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.64"></a>
<b>Exercise 3.64.</b>  Write a procedure <a name="%_idx_3978"></a><tt>stream-limit</tt> that takes as arguments a stream
and a number (the tolerance).  It should examine the stream until it
finds two successive elements that differ in absolute value by less
than the tolerance, and return the second of the two elements.  Using
this, we could compute square roots up to a given tolerance by
</p>

<p class="trans" lang="ja">
<b>練習問題3.64.</b> 引数としてストリームと数 (許容範囲) をとる、<tt>stream-limit</tt> という手続きを書け。
その手続きは、絶対値が許容範囲未満しか違わないような、二つの連続する要素を見つけるまで、ストリームを検査すべきであり、その二つの要素のうち2番目の方を返すべきである。
これを使うと、与えられた許容範囲までの二乗根を、以下により計算できるだろう。
</p>

<p class="lisp"><a name="%_idx_3980"></a>(define (sqrt x tolerance)
  (stream-limit (sqrt-stream x) tolerance))
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.65"></a>
<b>Exercise 3.65.</b>  <a name="%_idx_3982"></a>Use the series
</p>

<p class="trans" lang="ja">
<b>練習問題3.65.</b> 以下の級数を使って、
</p>

<figure><img src="ch3-Z-G-44.gif" border="0"></figure>

<p class="orig" lang="en">
to compute three sequences of approximations to the natural logarithm of 2,
in the same way we did above for <img src="book-Z-G-D-9.gif" border="0">.
How rapidly do these sequences converge?
</p>

<p class="trans" lang="ja">
&pi; について上記で行ったのと同様の方法で、2の自然対数に対する近似値の、三つの列を計算せよ。
これらの列は、どれほど急速に収束するだろう?
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_Temp_476"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_476">Infinite streams of pairs</a></h4>
<h4 class="trans" lang="ja">対の無限ストリーム</h4>

<p class="orig" lang="en">
<a name="%_idx_3984"></a><a name="%_idx_3986"></a><a name="%_idx_3988"></a>
In section <a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a>, we saw how the sequence paradigm
handles traditional nested loops as processes defined on sequences of
pairs.  If we generalize this technique to infinite streams, then we
can write programs that are not easily represented as loops, because
the ``looping'' must range over an infinite set.</p>

<p class="trans" lang="ja">
<a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a>節で、列のパラダイムがどのようにして、伝統的な入れ子になったループを、対の列の上で定義されるプロセスとして取り扱うのか、を見た。
この技法を無限ストリームにまで一般化すると、「ループすること」が無限集合全体に渡らなくてはならないせいで簡単にはループとして表現されないようなプログラムを、書くことができる。
</p>

<p class="orig" lang="en">
<a name="%_idx_3990"></a>For example, suppose we want to generalize the <tt>prime-sum-pairs</tt>
procedure of section <a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a> to produce the stream
of pairs of <em>all</em> integers (<em>i</em>,<em>j</em>) with <em>i</em> <u>&lt;</u> <em>j</em> such that <em>i</em> + <em>j</em>
is prime.  If <tt>int-pairs</tt> is the sequence of all pairs of integers (<em>i</em>,<em>j</em>)
with <em>i</em> <u>&lt;</u> <em>j</em>, then our required stream is simply<a name="call_footnote_Temp_477" href="#footnote_Temp_477"><sup><small>66</small></sup></a></p>

<p class="trans" lang="ja">
たとえば、
<span class="math"><em class="en">i</em> + <em class="en">j</em></span>
が素数であるような、
<span class="math"><em class="en">i</em> &le; <em class="en">j</em></span>
なる<em>すべての</em>整数
<span class="math">(<em class="en">i</em>, <em class="en">j</em>)</span>
の対のストリームを作り出すように、<a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a>節の <tt>prime-sum-pairs</tt> という手続きを一般化したいのだとしよう。
もし、<tt>int-pairs</tt> が、
<span class="math"><em class="en">i</em> &le; <em class="en">j</em></span>
なる整数
<span class="math">(<em class="en">i</em>, <em class="en">j</em>)</span>
のすべての対の列であれば、求められているストリームは、単に以下のとおりである<a href="#footnote_Temp_477"><sup><small>66</small></sup></a>。
</p>


<p class="lisp">(stream-filter (lambda (pair)
                 (prime? (+ (car pair) (cadr pair))))
               int-pairs)
</p>

<p class="orig" lang="en">
Our problem, then, is to produce the stream <tt>int-pairs</tt>.  More
generally, suppose we have two streams <em>S</em>  =  (<em>S</em><sub><em>i</em></sub>) and <em>T</em>  =  (<em>T</em><sub><em>j</em></sub>),
and imagine the infinite rectangular array
</p>

<p class="trans" lang="ja">
すると、問題は、<tt>int-pairs</tt> というストリームを作り出すことである。
より一般的に、
<span class="math"><em class="en">S</em>  =  (<em class="en">S<sub>i</sub></em>)</span> 
と
<span class="math"><em class="en">T</em>  =  (<em class="en">T<sub>j</sub></em>)</span>
という二つのストリームがあるものとして、以下のような無限の矩形配列を想像せよ。
</p>

<figure><img src="ch3-Z-G-45.gif" border="0"></figure>

<p class="orig" lang="en">
We wish to generate a stream that contains all the pairs in the array
that lie on or above the diagonal, i.e., the pairs
</p>

<p class="trans" lang="ja">
私たちは、配列内の、対角線上またはそれよりも上側にある、すべての対——つまり以下の対——を含むような、ストリームを生成したい。
</p>

<figure><img src="ch3-Z-G-46.gif" border="0"></figure>

<p class="orig" lang="en">
(If we take both <em>S</em> and <em>T</em> to be the stream of integers, then this
will be our desired stream <tt>int-pairs</tt>.)  </p>

<p class="trans" lang="ja">
(これは、もし、<em class="en">S</em> と <em class="en">T</em> の双方を、整数のストリームとなるようにとれば、私たちの所望のストリーム の  <tt>int-pairs</tt> となるだろう。)
</p>

<p class="orig" lang="en">
Call the general stream of pairs <tt>(pairs S T)</tt>, and consider it to
be composed of three parts: the pair (<em>S</em><sub>0</sub>,<em>T</em><sub>0</sub>), the
rest of the pairs in the first row, and the remaining pairs:<a name="call_footnote_Temp_478" href="#footnote_Temp_478"><sup><small>67</small></sup></a>
</p>

<p class="trans" lang="ja">
 <tt>(pairs S T)</tt> という、対の一般的ストリームを呼び出し、それが三つの部分——つまり、
 <span class="math">(<em class="en">S</em><sub>0</sub>,<em class="en">T</em><sub>0</sub>)</span>
という対と、最初の行の残りの部分と、残りの対——からなると考えよ<a href="#footnote_Temp_478"><sup><small>67</small></sup></a>。
</p>

<figure><img src="ch3-Z-G-47.gif" border="0"></figure>


<p class="orig" lang="en">
Observe that the third piece in this decomposition (pairs that are not in the
first row) is (recursively) the pairs formed from <tt>(stream-cdr S)</tt>
and <tt>(stream-cdr T)</tt>.  Also note that the second piece (the rest
of the first row) is
</p>


<p class="trans" lang="ja">
この分解における三番目の部品 (最初の行にない対) が (再帰的に) <tt>(stream-cdr S)</tt> と <tt>(stream-cdr T)</tt> から形成される対である、ということに気づいてほしい。
また、二番目の部品 (最初の行の残り) は以下のとおりである、ということに注意せよ。
</p>

<p class="lisp">(stream-map (lambda (x) (list (stream-car s) x))
            (stream-cdr t))
</p>

<p class="orig" lang="en">
Thus we can form our stream of pairs as follows:
</p>

<p class="trans" lang="ja">
よって、以下のようにして私たちの対のストリームを形成することができる。
</p>

<p class="lisp">(define (pairs s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (&lt;<em>combine-in-some-way</em>&gt;
       (stream-map (lambda (x) (list (stream-car s) x))
                   (stream-cdr t))
       (pairs (stream-cdr s) (stream-cdr t)))))
</p>


<p class="orig" lang="en">
<a name="%_idx_3992"></a>In order to complete the procedure, we must choose some way to combine
the two inner streams.  One idea is to use the stream analog of the
<tt>append</tt> procedure from section <a href="15_sec2_2.html#%_sec_2.2.1">2.2.1</a>:</p>

<p class="trans" lang="ja">
手続きを完成させるには、二つの内部ストリームを結合する何らかの方法を選ばねばならない。
一つの考えは、<a href="15_sec2_2.html#%_sec_2.2.1">2.2.1</a>節の <tt>append</tt> という手続きの、ストリーム版の相似物を使うことだ。
</p>

<p class="lisp"><a name="%_idx_3994"></a>(define (stream-append s1 s2)
  (if (stream-null? s1)
      s2
      (cons-stream (stream-car s1)
                   (stream-append (stream-cdr s1) s2))))
</p>


<p class="orig" lang="en">
This is unsuitable for infinite streams, however,
because it takes all the elements from the first stream before
incorporating the second stream.
In particular, if we try to generate all pairs of positive integers using</p>

<p class="trans" lang="ja">
だが、これは、2番目のストリームを取り込むよりも前に、1番目のストリームからすべての要素を取り出すのだから、無限ストリームには不適切だ。
特に、以下を用いて正整数のすべての対を生成しようとする場合には、
</p>

<p class="lisp">(pairs integers integers)
</p>


<p class="orig" lang="en">
our stream of results will first try to run through all pairs with the
first integer equal to 1, and hence will never produce pairs with any
other value of the first integer.</p>

<p class="trans" lang="ja">
結果のストリームは、まず、1番目の整数が1に等しいすべての対をひとわたり見て<!--舐めて--><!--通って-->いこうとするだろうし、それゆえ、1番目の整数が他の何らかの値であるような対を、決して作り出さないだろう。
</p>

<p class="orig" lang="en">
To handle infinite streams, we need to devise an order of combination
that ensures that every element will eventually be reached if we let
our program run long enough.  An elegant way to accomplish this is
with the following <tt>interleave</tt> procedure:<a name="call_footnote_Temp_479" href="#footnote_Temp_479"><sup><small>68</small></sup></a></p>

<p class="trans" lang="ja">
無限ストリームを扱うために、私たちは、十分に長くプログラムを走らせれば、どの要素にも最終的には到達するであろう、と保証するような、結合の順序を、考案する必要がある。
これを達成するための洗練された方法では、以下の <tt>interleave</tt> という手続きを使う<a href="#footnote_Temp_479"><sup><small>68</small></sup></a>。
</p>


<p class="lisp"><a name="%_idx_4000"></a>(define (interleave s1 s2)
  (if (stream-null? s1)
      s2
      (cons-stream (stream-car s1)
                   (interleave s2 (stream-cdr s1)))))
</p>


<p class="orig" lang="en">
Since <tt>interleave</tt> takes elements alternately from the two streams,
every element of the second stream will eventually find its way into
the interleaved stream, even if the first stream is infinite.</p>

<p class="trans" lang="ja">
<tt>interleave</tt> は二つのストリームから交互に要素を取り出すので、2番目のストリームのどの要素も、最終的には、互い違いの混ぜこぜになったストリームの中に現れるだろう——たとえ1番目のストリームが無限であっても。
</p>

<p class="orig" lang="en">
We can thus generate the required stream of pairs as
</p>

<p class="trans" lang="ja">
よって、求められている対のストリームを、以下のように生成できる。
</p>

<p class="lisp"><a name="%_idx_4002"></a>(define (pairs s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (interleave
    (stream-map (lambda (x) (list (stream-car s) x))
                (stream-cdr t))
    (pairs (stream-cdr s) (stream-cdr t)))))
</p>

<p class="orig" lang="en"><a name="%_thm_3.66"></a>
<b>Exercise 3.66.</b>  Examine the stream <tt>(pairs integers integers)</tt>. Can you make any general
comments about the order in which the pairs are placed into the
stream? For example, about how many pairs precede the pair (1,100)?
the pair (99,100)? the pair (100,100)? (If you can make precise
mathematical statements here, all the better. But feel free to give
more qualitative answers if you find yourself getting bogged down.)
</p>

<p class="trans" lang="ja">
<b>練習問題3.66.</b> <tt>(pairs integers integers)</tt> というストリームを吟味しよう。
対が当該ストリームに配置される順序について、君は何か一般的なコメントをすることができるかな?
たとえば、いくつの対が、
<span class="math">(1, 100)</span>
という対より前にあるか、ということについては?
<span class="math">(99, 100)</span>
という対についてはどうかな?
<span class="math">(100, 100)</span>
という対についてはどうかな?
(もし君が正確な数学的陳述をここで行うことができるなら、さらに良い。
けれども、自分が行き詰まっていると気づいたら、遠慮なく、もっと多くの量的な答えを書いてくれたまえ。)
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.67"></a>
<b>Exercise 3.67.</b>  Modify the <tt>pairs</tt> procedure so that <tt>(pairs integers
integers)</tt> will produce the stream of <em>all</em> pairs of integers
(<em>i</em>,<em>j</em>) (without the condition <em>i</em> <u>&lt;</u> <em>j</em>).  Hint: You will need to
mix in an additional stream.
</p>

<p class="trans" lang="ja">
<b>練習問題3.67.</b>  <tt>(pairs integers integers)</tt> が、
<span class="math">(<em class="en">i</em>,<em class="en">j</em>)</span>
なる整数同士の<em>すべての</em>対
(<span class="math"><em class="en">i</em> &le; <em class="en">j</em></span> という条件は無し) 
を作り出すように、<tt>pairs</tt> を改変せよ。
ヒント: 追加のストリームの中に混ぜる必要があるだろう。
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.68"></a>
<b>Exercise 3.68.</b>  Louis Reasoner thinks that building a stream of pairs from three
parts is unnecessarily complicated.  Instead of separating the
pair (<em>S</em><sub>0</sub>,<em>T</em><sub>0</sub>) from the rest of the pairs in the first row,
he proposes to work with the whole first row, as follows:
</p>

<p class="trans" lang="ja">
<b>練習問題3.68.</b> ルイス・リーズナは、三つの部分から対のストリームを構築することは不必要に複雑である、と考えている。
最初の行において、
<span class="math">(<em class="en">S</em><sub>0</sub>,<em class="en">T</em><sub>0</sub>)</span>
という対を残りの部分から分離する代わりに、
以下のようにして最初の行全体を使って作業することを、ルイスは提案する。
</p>

<p class="lisp">(define (pairs s t)
  (interleave
   (stream-map (lambda (x) (list (stream-car s) x))
               t)
   (pairs (stream-cdr s) (stream-cdr t))))
</p>


<p class="orig" lang="en">
Does this work?  Consider what happens if we evaluate
<tt>(pairs integers integers)</tt> using Louis's definition of <tt>pairs</tt>.

</p>

<p class="trans" lang="ja">
これはうまくいくだろうか?
もし、<tt>pairs</tt> についてのルイスの定義を使って、<tt>(pairs integers integers)</tt> を評価したとすると、何が起こるのか、ということを考えよ。

</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.69"></a>
<b>Exercise 3.69.</b>  Write a procedure <tt>triples</tt> that takes three infinite
streams, <em>S</em>, <em>T</em>, and <em>U</em>, and produces the stream of triples
(<em>S</em><sub><em>i</em></sub>,<em>T</em><sub><em>j</em></sub>,<em>U</em><sub><em>k</em></sub>) such that <em>i</em> <u>&lt;</u> <em>j</em> <u>&lt;</u> <em>k</em>.
Use <tt>triples</tt> to
generate the stream of all <a name="%_idx_4004"></a>Pythagorean triples of positive integers,
i.e., the triples (<em>i</em>,<em>j</em>,<em>k</em>) such that <em>i</em> <u>&lt;</u> <em>j</em> and <em>i</em><sup>2</sup>  +  <em>j</em><sup>2</sup>  = <em>k</em><sup>2</sup>.
</p>

<p class="trans" lang="ja">
<b>練習問題3.69.</b> <em class="en">S</em> と <em class="en">T</em> と <em class="en">U</em> という三つの無限ストリームをとり、
<em class="en">i</em> <u>&lt;</u> <em class="en">j</em> <u>&lt;</u> <em class="en">k</em>
であるような
<span class="math">(<em class="en">S</em><sub><em class="en">i</em></sub>,<em class="en">T</em><sub><em class="en">j</em></sub>,<em class="en">U</em><sub><em class="en">k</em></sub>)</span>
という三つ組からなるストリームを作り出す、<tt>triples</tt> という手続きを書け。
<tt>triples</tt> を使って、すべての、正整数のピタゴラスの三つ組——つまり、
<span class="math"><em class="en">i</em> &le; <em class="en">j</em></span>
かつ 
<span class="math"><em class="en">i</em><sup>2</sup>  +  <em class="en">j</em><sup>2</sup>  = <em class="en">k</em><sup>2</sup></span>
であるような、
<span class="math">(<em class="en">i</em>, <em class="en">j</em>, <em class="en">k</em>)</span>
という三つ組
——からなる、ストリームを生成せよ。
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.70"></a>
<b>Exercise 3.70.</b>  <a name="%_idx_4006"></a><a name="%_idx_4008"></a>It would be nice to be able to generate streams in which the pairs
appear in some useful order, rather than in the order that results
from an <em>ad hoc</em> interleaving process.  We can use a technique
similar to the <tt>merge</tt> procedure of exercise <a href="#%_thm_3.56">3.56</a>, if we
define a way to say that one pair of integers is ``less than''
another.  One way to do this is to define a ``weighting function''
<em>W</em>(<em>i</em>,<em>j</em>) and stipulate that (<em>i</em><sub>1</sub>,<em>j</em><sub>1</sub>) is less than (<em>i</em><sub>2</sub>,<em>j</em><sub>2</sub>) if
<em>W</em>(<em>i</em><sub>1</sub>,<em>j</em><sub>1</sub>) &lt; <em>W</em>(<em>i</em><sub>2</sub>,<em>j</em><sub>2</sub>).  Write a procedure <tt>merge-weighted</tt>
that is like <tt>merge</tt>, except that <tt>merge-weighted</tt> takes an
additional argument <tt>weight</tt>, which is a procedure that computes
the weight of a pair, and is used to determine the order in which
elements should appear in the resulting merged stream.<a name="call_footnote_Temp_485" href="#footnote_Temp_485"><sup><small>69</small></sup></a>
Using this,
generalize <tt>pairs</tt> to a procedure <tt>weighted-pairs</tt> that
takes two streams, together with a procedure that computes a weighting
function, and generates the stream of pairs, ordered according to
weight.  Use your procedure to generate</p>

<p class="trans" lang="ja">
<b>練習問題3.70.</b> <em><ruby><rb>場当たり的</rb><rp> (</rp><rt>アドホック</rt><rp>) </rp></ruby>に</em>混ぜこぜにする処理の結果から生じる順序ではなく、むしろ、何らかの有用な順序で対が現れるようなストリームを生成できたら、素晴らしいことだろう。
もし、整数同士のある一対が別の対「よりも小さい」と言うための方法を定義すれば、練習問題<a href="#%_thm_3.56">3.56</a>の <tt>merge</tt> の手続きと似た技法を使うことが可能である。
これを行うための一つの方法は、
<em class="en">W</em>(<em class="en">i</em>, <em class="en">j</em>) 
という「重みづけ関数」を定義し、そして、
<em class="en">W</em>(<em class="en">i</em><sub>1</sub>, <em class="en">j</em><sub>1</sub>) &lt; 
<em class="en">W</em>(<em class="en">i</em><sub>2</sub>, <em class="en">j</em><sub>2</sub>)
の場合は
(<em class="en">i</em><sub>1</sub>, <em class="en">j</em><sub>1</sub>)
が
(<em class="en">i</em><sub>2</sub>, <em class="en">j</em><sub>2</sub>)
よりも小さい、と規定することである。
<tt>merge</tt> と似た <tt>merge-weighted</tt> という手続き——ただし、<tt>merge-weighted</tt> は、<tt>weight</tt> という追加の引数を取り、これは対の重みを計算する手続きであって、結果として生じる併合されたストリームにおいて要素が出現すべき順序を定めるために使われる、という点が違う——を書け<a href="#footnote_Temp_485"><sup><small>69</small></sup></a>。
これを用いて、<tt>pairs</tt> を、重みづけ関数を計算する手続きとともに二つのストリームをとり、重みにしたがって順序づけられた対のストリームを生成するような、<tt>weighted-pairs</tt> という手続きへと、一般化せよ。
君の手続きを使って、以下のものを生成せよ。
</p>

<p class="orig" lang="en">
a. the stream of all pairs of positive integers (<em>i</em>,<em>j</em>) with <em>i</em> <u>&lt;</u>
<em>j</em> ordered according to the sum <em>i</em>  +  <em>j</em></p>

<p class="trans" lang="ja">
a. 
<span class="math"><em class="en">i</em> &le;  <em class="en">j</em>
</span>
であるような正整数の対
<span class="math">(<em class="en">i</em>,<em class="en">j</em>)
</span>
すべてからなる、
<span class="math"><em class="en">i</em>  +  <em class="en">j</em></span>
という和によって順序づけられた、ストリーム。
</p>



<p class="orig" lang="en">b.  the stream of all pairs of positive integers (<em>i</em>,<em>j</em>) with <em>i</em> <u>&lt;</u>
<em>j</em>, where neither <em>i</em> nor <em>j</em> is divisible by 2, 3, or 5, and the
pairs are ordered according to the sum 2 <em>i</em>  +  3 <em>j</em>  +  5 <em>i</em> <em>j</em>.
</p>

<p class="trans" lang="ja">
b. 2、3、5のいずれによっても、<em class="en">i</em> も <em class="en">j</em> も割り切れないものとして、
<span class="math"><em class="en">i</em> &le;  <em class="en">j</em>
</span>
であるような正整数の対
<span class="math">(<em class="en">i</em>,<em class="en">j</em>)
</span>
すべてからなる、
<span class="math">2<em class="en">i</em>  +  3<em class="en">j</em>  +  5<em class="en">ij</em></span>
という和によって順序づけられた、ストリーム。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.71"></a>
<b>Exercise 3.71.</b>  <a name="%_idx_4010"></a>Numbers that can be expressed as the sum of two cubes in more than one
way are sometimes called <em>Ramanujan numbers</em>, in honor of the
mathematician Srinivasa Ramanujan.<a name="call_footnote_Temp_487" href="#footnote_Temp_487"><sup><small>70</small></sup></a>
Ordered streams of pairs provide an elegant solution to the problem of
computing these numbers.  To find a number that can be written as the
sum of two cubes in two different ways, we need only generate the
stream of pairs of integers (<em>i</em>,<em>j</em>) weighted according to the sum <em>i</em><sup>3</sup>
 +  <em>j</em><sup>3</sup> (see exercise <a href="#%_thm_3.70">3.70</a>),
then search the stream for two consecutive pairs with the same
weight.  Write a procedure to generate the Ramanujan numbers.  The first
such number is 1,729.  What are the next five?

</p>

<p class="trans" lang="ja">
<b>練習問題3.71.</b> 一つよりも多いやり方で二つの立法数の和として表せる数は、時として、シュリニヴァーサ・ラマヌジャンに敬意を表して、<em>ラマヌジャン数</em>と呼ばれる<a href="#footnote_Temp_487"><sup><small>70</small></sup></a>。
対からなる順序づけられたストリームは、これらの数を計算するという問題に対する、洗練された解法を与えてくれる。
2通りの異なる方法で2個の立法数の和として書ける数を見つけるためには、ただ単に、
<span class="math"><em class="en">i</em><sup>3</sup> + <em class="en">j</em><sup>3</sup></span>
という和によって重みづけられた、
<span class="math">(<em class="en">i</em>, <em class="en">j</em>)</span>
という整数同士の対からなるストリームを生成して (練習問題<a href="#%_thm_3.70">3.70</a>を参照)、それから、同じ重みを持った連続する2個の対をそのストリームにおいて探索するだけでよいのだ。
ラマヌジャン数を生成する手続きを書け。
最初のそういう数は、1,729である。
次の5個は何だろう?
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.72"></a>
<b>Exercise 3.72.</b>  In a similar way to exercise <a href="#%_thm_3.71">3.71</a> generate
a stream of
all numbers that can be written as the sum of two squares in three
different ways (showing how they can be so written).
</p>

<p class="trans" lang="ja">
<b>練習問題3.72.</b> 異なる3通りの方法で、2個の平方数の和として書けるような、すべての数のストリームを、練習問題<a href="#%_thm_3.71">3.71</a>と似た方法で生成せよ (それらの数をそのように書ける方法を示しながら)。
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_Temp_489"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_489">Streams as signals</a></h4>
<h4 class="trans" lang="ja">信号としてのストリーム</h4>

<p class="orig" lang="en">
<a name="%_idx_4018"></a><a name="%_idx_4020"></a>
We began our discussion of streams by describing them as computational
analogs of the ``signals'' in signal-processing systems.  In fact, we
can use streams to model signal-processing systems in a very direct
way, representing the values of a signal at successive time intervals
as consecutive elements of a stream.  For instance, we can implement
an <a name="%_idx_4022"></a><em>integrator</em> or <em>summer</em> that, for an input stream
<em>x</em> = (<em>x</em><sub><em>i</em></sub>), an initial value <em>C</em>, and a small increment <em>d</em><em>t</em>,
accumulates the sum
</p>

<p class="trans" lang="ja">
信号処理システムにおける「信号」の、計算機上の相似物として、ストリームを説明することから、私たちはストリームについての議論を始めた。
連続する時間区間での信号の値を、ストリームでの連続する要素として表現すれば、実際のところ、ストリームを用いて信号処理システムを非常に直截的な方法でモデル化できる。
たとえば、
<span class="math"><em class="en">x</em> = (<em class="en">x<sub>i</sub></em>) 
</span>という入力ストリームと、
<em class="en">C</em>
という初期値と、
<em class="en">dt</em>
という小さな増分に対して、以下の和を累算するような、<em>積分器</em>ないし<em>総和器</em>を実装できて、
</p>

<figure><img src="ch3-Z-G-48.gif" border="0"></figure>


<p class="orig" lang="en">
and returns the stream of values <em>S</em> = (<em>S</em><sub><em>i</em></sub>).  The following <tt>integral</tt>
procedure is reminiscent of the ``implicit style'' definition of the
stream of integers (section <a href="#%_sec_3.5.2">3.5.2</a>):</p>

<p class="trans" lang="ja">
これは、<span class="math"><em class="en">S</em> = (<em class="en">S<sub>i</sub></em>)</span>
という値のストリームを返す。
以下の <tt>integral</tt> という手続きは、整数のストリームの「暗黙的様式」の定義 (<a href="#%_sec_3.5.2">3.5.2</a>節) を彷彿とさせる。
</p>


<p class="lisp"><a name="%_idx_4024"></a>(define (integral integrand initial-value dt)
  (define int
    (cons-stream initial-value
                 (add-streams (scale-stream integrand dt)
                              int)))
  int)
</p>

<a name="%_fig_3.32"></a>
<figure>
<img src="ch3-Z-G-49.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.32:</b>  The <tt>integral</tt> procedure viewed as a
signal-processing system.</figcaption>
<figcaption class="trans" lang="ja"><b>図3.32:</b> 信号処理システムとして見た、<tt>integral</tt> の手続き</figcaption>
</figure>

<p class="orig" lang="en">
Figure <a href="#%_fig_3.32">3.32</a> is a picture of a signal-processing system that
corresponds to the <tt>integral</tt> procedure.  The input stream is
scaled by <em>d</em><em>t</em> and passed through an adder, whose output is passed
back through the same adder.  The self-reference in the definition of
<tt>int</tt> is reflected in the figure by the feedback loop that
connects the output of the adder to one of the inputs.</p>

<p class="trans" lang="ja">
図<a href="#%_fig_3.32">3.32</a>は、<tt>integral</tt> という手続きに対応する信号処理システムの絵である。
入力ストリームは、<em class="en">dt</em>倍されて、加算器——その出力は、同じ加算器を通って戻される——を通って渡される。
<tt>int</tt> の定義における自己参照が、加算器の出力を入力のうちの一つにつなぐフィードバック・ループにより、図に反映されている。
</p>


<p class="orig" lang="en"><a name="%_thm_3.73"></a>
<b>Exercise 3.73.</b>  <a name="%_fig_3.33"></a></p>

<p class="trans" lang="ja">
<b>練習問題3.73.</b> 
</p>

<figure>
<div style="text-align: right">
<img src="ch3-Z-G-50.gif" border="0">&nbsp;&nbsp;
<em>v</em>  =  <em>v</em><sub>0</sub>  +  (1/<em>C</em>)<img src="book-Z-G-D-19.gif" border="0"><sub>0</sub><sup><em>t</em></sup><em>i</em> <em>d</em><em>t</em>  +  <em>R</em> <em>i</em>
&nbsp;&nbsp;
</div>
<img src="ch3-Z-G-51.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.33:</b>  An RC circuit and the associated signal-flow diagram.</figcaption>
<figcaption class="trans" lang="ja"><b>図3.33:</b> RC回路とそれに関連づけられた信号流れ図</figcaption>
</figure>

<p class="orig" lang="en">
<a name="%_idx_4028"></a><a name="%_idx_4030"></a><a name="%_idx_4032"></a>We can model electrical circuits using streams to represent the values
of currents or voltages at a sequence of times.  For instance, suppose
we have an <em>RC circuit</em> consisting of a resistor of resistance <em>R</em>
and a capacitor of capacitance <em>C</em> in series.  The voltage response
<em>v</em> of the circuit to an injected current <em>i</em> is determined by the
formula in figure <a href="#%_fig_3.33">3.33</a>, whose structure is shown by the accompanying
signal-flow diagram.</p>

<p class="trans" lang="ja">
一連の時点における電流または電圧の値を表すストリームを使って、電気回路をモデル化できる。
たとえば、直列につながっている、<em class="en" >R</em> という抵抗値の抵抗器と、<em class="en">C</em> という容量のキャパシタとからなる、<em>RC回路</em>があるものとしよう。
<em class="en">i</em> という投入電流に対する、この回路の <em class="en">v</em> という電圧応答は、図<a href="#%_fig_3.33">3.33</a>の公式——その構造は、付随している信号流れ図によって示されている——により、決定づけられる。
</p>

<p class="orig" lang="en">
Write a procedure <tt>RC</tt> that models this circuit.  <tt>RC</tt> should
take as inputs the values of <em>R</em>, <em>C</em>, and <em>d</em><em>t</em> and should return a
procedure that takes as inputs a stream representing the current <em>i</em>
and an initial value for the capacitor voltage <em>v</em><sub>0</sub> and produces as
output the stream of voltages <em>v</em>.  For example, you should be able to
use <tt>RC</tt> to model an RC circuit with <em>R</em>  =  5 ohms, <em>C</em>  =  1 farad,
and a 0.5-second time step by evaluating <tt>(define RC1 (RC 5 1
0.5))</tt>.  This defines <tt>RC1</tt> as a procedure that takes a stream
representing the time sequence of currents and an initial capacitor
voltage and produces the output stream of voltages.
</p>

<p class="trans" lang="ja">
この回路をモデル化する、<tt>RC</tt> という手続きを書け。
<tt>RC</tt> は、入力として、<em class="en">R</em> と <em class="en">C</em> と <em class="en">dt</em> の値をとるべきである。そして、<em class="en">i</em> という電流を表すストリームと <em class="en">v</em><sub>0</sub> というキャパシタ電圧の初期値とを入力としてとって、出力としては <em class="en">v</em> という電圧のストリームを作り出すような手続きを、<tt>RC</tt> は、返すべきである。
たとえば、<tt>RC</tt> を使って、<tt>(define RC1 (RC 5 1 0.5))</tt>を評価することによって、<em class="en">R</em> が5オームで、<em class="en">C</em> が1ファラッドで、時間の刻みが0.5秒のRC回路を、モデル化できるはずである。
これは、<tt>RC1</tt> を、電流の時系列を表すストリームと初期キャパシタ電圧とをとって電圧の出力ストリームを作り出すような手続きとして、定義する。
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.74"></a>
<b>Exercise 3.74.</b>  <a name="%_idx_4034"></a><a name="%_idx_4036"></a>Alyssa P. Hacker is designing a system to process signals coming from
physical sensors.  One important feature she wishes to produce is a
signal that describes the <em>zero crossings</em> of the input signal.
That is, the resulting signal should be  + 1 whenever the input signal
changes from negative to positive,  - 1 whenever the input signal
changes from positive to negative, and 0 otherwise.  (Assume that the
sign of a 0 input is positive.)  For example, a typical input signal
with its associated zero-crossing signal would be
</p>

<p class="trans" lang="ja">
<b>練習問題3.74.</b> アリッサ・P・ハッカは、物理センサからやって来る信号を処理するシステムを設計しているところだ。
アリッサが作り出したいと望んでいる一つの重要な特徴は、入力信号の<em>ゼロ交差</em>を記述する信号である。
つまり、結果として生じる信号は、入力信号が負から正へと変化するときは必ず +1 となるべきであり、入力信号が正から負へと変化するときは必ず &minus;1 となるべきであり、その他の場合は 0 となるべきものである。
(0 という入力の符号は正であるものとせよ。)
たとえば、関連したゼロ交差信号を伴った典型的入力信号は、以下のようであるだろう。
</p>

<p class="lisp"><tt>...</tt>1  2  1.5  1  0.5  -0.1  -2  -3  -2  -0.5  0.2  3  4 <tt>...</tt>
<tt>...</tt>0  0    0  0    0    -1   0   0   0     0    1  0  0 <tt>...</tt></p>


<p class="orig" lang="en">
In Alyssa's system, the signal from the sensor is represented as a
stream <tt>sense-data</tt> and the stream <tt>zero-crossings</tt> is
the corresponding stream of zero crossings.  Alyssa first writes a
procedure <tt>sign-change-detector</tt> that takes two values as
arguments and compares the signs of the values to produce an
appropriate 0, 1, or  - 1.  She then constructs her zero-crossing
stream as follows:</p>

<p class="trans" lang="ja">
アリッサのシステムでは、センサからの信号が <tt>sense-data</tt> というストリームとして表され、<tt>zero-crossings</tt> というストリームは、それに対応する、ゼロ交差からなるストリームである。
アリッサはまず、二つの値を引数としてとり、それらの値の符号同士を比較して適切な 0 か 1 か &minus;1 を作り出すような、<tt>sign-change-detector</tt> という手続きを書く。
それから彼女は、自分のゼロ交差ストリームを以下のように構築する。
</p>

<p class="lisp">(define (make-zero-crossings input-stream last-value)
  (cons-stream
   (sign-change-detector (stream-car input-stream) last-value)
   (make-zero-crossings (stream-cdr input-stream)
                        (stream-car input-stream))))

(define zero-crossings (make-zero-crossings sense-data 0))
</p>

<p class="orig" lang="en">
Alyssa's boss, Eva Lu Ator, walks by and suggests that this program is
approximately equivalent to the following one, which
uses the generalized version
of <tt>stream-map</tt> from exercise <a href="#%_thm_3.50">3.50</a>:</p>

<p class="trans" lang="ja">
アリッサの上司、すなわちエヴァ・リュ・エイタが、通りすがり、そして、このプログラムは以下のもの——練習問題<a href="#%_thm_3.50">3.50</a>の <tt>stream-map</tt> の一般化されたバージョンを使う——とおおよそ等価だ、と示唆する。
</p>

<p class="lisp">(define zero-crossings
  (stream-map sign-change-detector sense-data &lt;<em>expression</em>&gt;))
</p>


<p class="orig" lang="en">
Complete the program by supplying the indicated &lt;<em>expression</em>&gt;.
</p>

<p class="trans" lang="ja">
示された &lt;<em class="en">expression</em>&gt; を埋めることで、プログラムを完成させよ。
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.75"></a>
<b>Exercise 3.75.</b>  <a name="%_idx_4038"></a><a name="%_idx_4040"></a><a name="%_idx_4042"></a><a name="%_idx_4044"></a>Unfortunately, Alyssa's zero-crossing detector in
exercise <a href="#%_thm_3.74">3.74</a> proves to be insufficient, because the
noisy signal from the sensor leads to spurious zero crossings.  Lem E.
Tweakit, a hardware specialist, suggests that Alyssa smooth the signal
to filter out the noise before extracting the zero crossings.  Alyssa
takes his advice and decides to extract the zero crossings from the
signal constructed by averaging each value of the sense data with the
previous value.  She explains the problem to her assistant, Louis
Reasoner, who attempts to implement the idea, altering Alyssa's program as
follows:</p>

<p class="trans" lang="ja">
<b>練習問題3.75.</b> あいにく、練習問題<a href="#%_thm_3.74">3.74</a>のアリッサのゼロ交差検出器は、センサからの雑音だらけの信号が偽物のゼロ交差を招くため、不十分だ、ということが判明した。
レム・E・トゥウィーキット——ハードウェア専門家である——は、アリッサが、ゼロ交差を抽出する前に信号を平滑化して雑音をフィルタで除去したらよい、と提案した。
アリッサは彼の助言を取り上げて、感知データのそれぞれの値を前の値と平均化することによって構築した信号から、ゼロ交差を抽出することに決める。
アリッサは助手のルイス・リーズナに問題を説明し、ルイスはその考えを実装しようとして、アリッサのプログラムを以下のように変える。
</p>


<p class="lisp">(define (make-zero-crossings input-stream last-value)
  (let ((avpt (/ (+ (stream-car input-stream) last-value) 2)))
    (cons-stream (sign-change-detector avpt last-value)
                 (make-zero-crossings (stream-cdr input-stream)
                                      avpt))))
</p>


<p class="orig" lang="en">
This does not correctly implement Alyssa's plan.
Find the bug that Louis has installed
and fix it without changing the structure of the program.  (Hint: You
will need to increase the number of arguments to <tt>make-zero-crossings</tt>.)
</p>

<p class="trans" lang="ja">
これは、アリッサの計画を正しく実装してはいない。
ルイスが仕込んでしまったバグを見つけ、プログラムの構造を変えないで、そのバグを修正せよ。
(ヒント: <tt>make-zero-crossings</tt> に対する引数の個数を増やす必要があるだろう。)
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.76"></a>
<b>Exercise 3.76.</b>  <a name="%_idx_4046"></a><a name="%_idx_4048"></a><a name="%_idx_4050"></a><a name="%_idx_4052"></a>Eva Lu Ator has a criticism of Louis's approach in
exercise <a href="#%_thm_3.75">3.75</a>.  The program he wrote is not modular,
because it intermixes the operation of smoothing with the
zero-crossing extraction.  For example, the extractor should not have
to be changed if Alyssa finds a better way to condition her input
signal.  Help Louis by writing a procedure <tt>smooth</tt> that takes a
stream as input and produces a stream in which each element is the
average of two successive input stream elements.  Then use <tt>smooth</tt> as a component to implement the zero-crossing detector in a
more modular style.
</p>

<p class="trans" lang="ja">
<b>練習問題3.76.</b> エヴァ・リュ・エイタは、練習問題<a href="#%_thm_3.75">3.75</a>でのルイスの手法に批判的だ。
ルイスが書いたプログラムは、平滑化の操作をゼロ交差の抽出と混ぜ合わせているので、モジュール性がない。
たとえば、入力信号を調整するためのより良い方法をアリッサが見つけた<!--ときに、--><!--抽出器を変えねばならないのは駄目だ。--><!--抽出器を変える必要があるべきではない。--><!--抽出器を変える必要は、なくてしかるべきものだ。--><!--としても、-->場合、抽出器を変更する必要はないはずだ。
ストリームを入力としてとって、各要素が二つの連続する入力ストリーム要素の平均であるようなストリームを作りだす <tt>smooth</tt> という手続きを書くことにより、ルイスを手助けせよ。
そして、よりモジュール性のある様式でゼロ交差検出器を実装するための構成要素として、<tt>smooth</tt> を使え。
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_3.5.4"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_3.5.4">3.5.4  Streams and Delayed Evaluation</a></h3>
<h3 class="trans" lang="ja">3.5.4 ストリームと遅延評価</h3>

<p class="orig" lang="en">
<a name="%_idx_4054"></a><a name="%_idx_4056"></a>
The <tt>integral</tt> procedure at the end of the preceding section shows
how we can use streams to model signal-processing systems that contain
<a name="%_idx_4058"></a>feedback loops.  The feedback loop for the adder shown in
figure <a href="#%_fig_3.32">3.32</a> is modeled by the fact that <tt>integral</tt>'s
<a name="%_idx_4060"></a>internal stream <tt>int</tt> is defined in terms of itself:</p>

<p class="trans" lang="ja">
前の節の最後にある <tt>integral</tt> という手続きは、フィードバックループを含む信号処理システムをモデル化するために私たちがどのようにストリームを利用できるか、ということを示している。
図<a href="#%_fig_3.32">3.32</a>に示した加算のフィードバックループは、<tt>integral</tt> の <tt>int</tt> という内部ストリームがそれ自体を使って定義される、という事実により、モデル化されている。
</p>


<p class="lisp">(define int
  (cons-stream initial-value
               (add-streams (scale-stream integrand dt)
                            int)))
</p>

<p class="orig" lang="en">
The interpreter's ability to deal with such an implicit definition
depends on the <tt>delay</tt> that is incorporated into <tt>cons-stream</tt>.  Without this <tt>delay</tt>, the interpreter could not
construct <tt>int</tt> before evaluating both arguments to <tt>cons-stream</tt>, which would require that <tt>int</tt> already be defined.
In general, <tt>delay</tt> is crucial for using streams to model
signal-processing systems that contain loops.  Without <tt>delay</tt>,
our models would have to be formulated so that the inputs to any
signal-processing component would be fully evaluated before the output
could be produced.  This would outlaw loops.</p>

<p class="trans" lang="ja">
こういう暗黙の定義を扱うことができるインタプリタの能力は、<tt>cons-stream</tt> の中に組み込まれている <tt>delay</tt> に依存している。
この <tt>delay</tt> がなければ、インタプリタは、<tt>cons-stream</tt> への両方の引数を評価する——これは、<tt>int</tt> が既に定義されていることを要請するだろう ——までは、<tt>int</tt> を構築することができなかっただろう。
一般に、ループを含む信号処理システムをモデル化するためにストリームを使うのには、<tt>delay</tt> が必要不可欠だ。
もし <tt>delay</tt> がなかったら、いかなる信号処理コンポーネントへの入力も、出力を作り出せるようになる前に完全に評価されている、というふうに、私たちのモデルを定式化せねばならなかっただろう。
これでは、ループを非合法なものとして禁止することになるだろう。
</p>

<p class="orig" lang="en">
Unfortunately, stream models of systems with loops
may require uses of <tt>delay</tt> beyond the ``hidden'' <tt>delay</tt>
supplied by <tt>cons-stream</tt>.  For instance,
figure <a href="#%_fig_3.34">3.34</a> shows a signal-processing system for
solving the <a name="%_idx_4062"></a>differential equation <em>d</em><em>y</em>/<em>d</em><em>t</em> = <em>f</em>(<em>y</em>) where <em>f</em> is a given
function.  The figure shows a mapping component, which
applies <em>f</em> to its input signal, linked in a feedback loop to an
integrator in a manner very similar to that of the analog computer
circuits that are actually used to solve such equations.</p>

<p class="trans" lang="ja">
あいにく、ループのあるシステムのストリーム・モデルは、 <tt>cons-stream</tt> により提供される「隠れた」<tt>delay</tt> を越えた <tt>delay</tt> の使用を必要とするかもしれない。
たとえば、図<a href="#%_fig_3.34">3.34</a>は、
<span class="math"><em class="en">dy</em>/<em class="en">dt</em> = <em class="en">f</em>(<em class="en">y</em>)</span>
という微分方程式——ただし <em class="en">f</em> は与えられた関数である——を解くための信号処理システムを示している。
こうした方程式を解くために実際に使われるアナログ・コンピュータ回路でのやり方と非常に似たやり方で、フィードバックループにおいて積分器につながれたマッピング・コンポーネント—— <em class="en">f</em> を入力信号に適用する——を、この図は示している。
</p>

<a name="%_fig_3.34"></a>
<figure>
<img src="ch3-Z-G-52.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.34:</b>  An ``analog computer circuit'' that solves the
equation
<em>d</em><em>y</em>/<em>d</em><em>t</em> = <em>f</em>(<em>y</em>).</figcaption>
<figcaption class="trans" lang="ja"><b>図3.34:</b> <em class="en">dy</em>/<em class="en">dt</em> = <em class="en">f</em>(<em class="en">y</em>) という方程式を解く「アナログ・コンピュータ回路」</figcaption>
<a name="%_idx_4064"></a>
</figure>
<!--
<p class="exercise"><span class="ex_comment"><em class="en">dy</em>/<em class="en">dt</em> = <em class="en">f</em>(<em class="en">y</em>)  なので、
<em class="en">y</em> = <em class="en">y</em><sub>0</sub> + <span style="font-size: larger;">&int;</span> <em class="en">f</em>(<em class="en">y</em>)<em class="en">dt</em>  と書けるかと思うんだが、図に <em class="en">dt</em> でなく <em class="en">dy</em> と見えるのは何故かな……
</span></p>
-->

<p class="orig" lang="en">
Assuming we are given an initial value <em>y</em><sub>0</sub> for <em>y</em>, we
could try to model this system using the procedure</p>

<p class="trans" lang="ja">
<em class="en">y</em> について <em class="en">y</em><sub>0</sub> という初期値が与えられているとすると、以下の手続きを用いてこのシステムをモデル化しようと試みることがあり得るだろう。
</p>

<p class="lisp"><a name="%_idx_4066"></a>(define (solve f y0 dt)
  (define y (integral dy y0 dt))
  (define dy (stream-map f y))
  y)
</p>

<p class="orig" lang="en">
This procedure does not work, because in the first line of <tt>solve</tt>
the call to <tt>integral</tt> requires that the input <tt>dy</tt> be
defined, which does not happen until the second line of <tt>solve</tt>.</p>

<p class="trans" lang="ja">
この手続きはうまく動かない。というのも、<tt>solve</tt> の1行目で、<tt>integral</tt> への呼び出しが、<tt>dy</tt> が定義されていることを要請しているのだが、そういうことは、<tt>solve</tt> の2行目までは起こらないからである。
</p>

<p class="orig" lang="en">
On the other hand, the intent of our definition does make sense,
because we can, in principle, begin to generate the <tt>y</tt> stream
without knowing <tt>dy</tt>.  Indeed, <tt>integral</tt> and many other
stream operations have properties similar to those of <tt>cons-stream</tt>, in that we can generate part of the answer given only
partial information about the arguments.  For <tt>integral</tt>, the
first element of the output stream is the specified <tt>initial-value</tt>.  Thus, we can generate the first element of the output
stream without evaluating the integrand <tt>dy</tt>.  Once we know the
first element of <tt>y</tt>, the <tt>stream-map</tt> in the second line of
<tt>solve</tt> can begin working to generate the first element of <tt>dy</tt>, which will produce the next element of <tt>y</tt>, and so on.</p>

<p class="trans" lang="ja">
その一方、定義の意図は意味をなしている。というのも、原理的には、<tt>dy</tt> を知ることなしに <tt>y</tt> のストリームを生成し始めることができるからだ。
実のところ、<tt>integral</tt> やその他の多くのストリーム演算には、引数についての部分的な情報を与えられるだけで答えの一部を生成できるという点で、<tt>cons-stream</tt> の性質と似た性質があるのだ。
<tt>integral</tt> について言うと、出力ストリームの最初の要素は、指定された <tt>initial-value</tt> である。
よって、被積分関数の <tt>dy</tt> を評価しないでも、出力ストリームの最初の要素を生成できる。
<tt>y</tt> の最初の要素が一旦わかったら、<tt>solve</tt> の2行目の <tt>stream-map</tt> は、<tt>dy</tt> の最初の要素を生成するために動き始めることができて、すると <tt>y</tt> の次の要素を作り出すことになり、以下同様である。
</p>

<p class="orig" lang="en">
To take advantage of this idea, we will redefine <tt>integral</tt> to
expect the integrand stream to be a <a name="%_idx_4068"></a><a name="%_idx_4070"></a><a name="%_idx_4072"></a><em>delayed argument</em>.  <tt>Integral</tt> will <tt>force</tt> the integrand to be evaluated only when it
is required to generate more than the first element of the output stream:</p>

<p class="trans" lang="ja">
この考え方を利用するために、<tt>integral</tt> を、被積分関数のストリームは<em>遅延された引数</em>だろうと予期するように、再定義しよう。
<tt>integral</tt> は、出力ストリームの最初の要素以上のものを生成することを求められた場合にのみ、被積分関数を評価することを <tt>force</tt> する (強制する) だろう。
</p>

<p class="lisp"><a name="%_idx_4074"></a>(define (integral delayed-integrand initial-value dt)
  (define int
    (cons-stream initial-value
                 (let ((integrand (force delayed-integrand)))
                   (add-streams (scale-stream integrand dt)
                                int))))
  int)
</p>


<p class="orig" lang="en">
Now we can implement our <tt>solve</tt> procedure by delaying the
evaluation of <tt>dy</tt> in the definition of <tt>y</tt>:<a name="call_footnote_Temp_494" href="#footnote_Temp_494"><sup><small>71</small></sup></a></p>

<p class="trans" lang="ja">
さて今や、<tt>y</tt> の定義の中での <tt>dy</tt> の評価を遅延させることによって、<tt>solve</tt> の手続きを実装できる<a href="#footnote_Temp_494"><sup><small>71</small></sup></a>。
</p>


<p class="lisp"><a name="%_idx_4076"></a>(define (solve f y0 dt)
  (define y (integral (delay dy) y0 dt))
  (define dy (stream-map f y))
  y)
</p>

<p class="orig" lang="en">
In general, every caller of <tt>integral</tt> must now <tt>delay</tt> the
integrand argument.  We can demonstrate that the <tt>solve</tt> procedure
works by approximating <a name="%_idx_4078"></a><em>e</em> <img src="book-Z-G-D-20.gif" border="0">  2.718 by computing the value at
<em>y</em> = 1 of the solution to the differential equation <em>d</em><em>y</em>/<em>d</em><em>t</em> = <em>y</em> with
initial condition <em>y</em>(0) = 1:</p>

<p class="trans" lang="ja">
一般に、<tt>integral</tt> の呼び出し側はどれも、今や、被積分関数の引数を <tt>delay</tt> (遅延) させねばならない。
<span class="math"><em class="en">y</em>(0) = 1</span>
という初期条件での、
<span class="math"><em class="en">dy</em>/<em class="en">dt</em> = <em class="en">y</em></span>
という微分方程式の解の、
<span class="math"><em class="en">y</em> = 1</span>
での値を計算することで、
<span class="math"><em class="en">e</em> &asymp; 2.718</span>
と近似し、それによって、
<tt>solve</tt> の手続きがちゃんと動くことを実証できる。
</p>

<p class="lisp">(stream-ref (solve (lambda (y) y) 1 0.001) 1000)
<i>2.716924</i></p>

<p class="orig" lang="en"><a name="%_thm_3.77"></a>
<b>Exercise 3.77.</b>  The <tt>integral</tt> procedure used above was analogous to the
``implicit'' definition of the infinite stream of integers in
section <a href="#%_sec_3.5.2">3.5.2</a>.  Alternatively, we can give a
definition of <tt>integral</tt> that is more like <tt>integers-starting-from</tt> (also in section <a href="#%_sec_3.5.2">3.5.2</a>):</p>

<p class="trans" lang="ja">
<b>練習問題3.77.</b> 上で使った <tt>integral</tt> という手続きは、<a href="#%_sec_3.5.2">3.5.2</a>節での整数の無限ストリームの「暗黙の」定義に対する相似物であった。
代わりに、より  <tt>integers-starting-from</tt>  (これも<a href="#%_sec_3.5.2">3.5.2</a>節にある) に似ているような <tt>integral</tt> の定義を与えることもできる
</p>


<p class="lisp"><a name="%_idx_4080"></a>(define (integral integrand initial-value dt)
  (cons-stream initial-value
               (if (stream-null? integrand)
                   the-empty-stream
                   (integral (stream-cdr integrand)
                             (+ (* dt (stream-car integrand))
                                initial-value)
                             dt))))
</p>


<p class="orig" lang="en">
When used in systems with loops, this procedure has the same problem
as does our original version of <tt>integral</tt>.  Modify the procedure
so that it expects the <tt>integrand</tt> as a delayed argument and hence
can be used in the <tt>solve</tt> procedure shown above.
</p>

<p class="trans" lang="ja">
ループのあるシステムで使う場合、この手続きには、<tt>integral</tt> の元のバージョンにあったのと同じ問題がある。
この手続きが、<tt>integrand</tt> のことを、遅延された引数だろうと予期するように、そしてまた、その結果として、この手続きを上記の <tt>solve</tt> の手続きにおいて使うことができるように、この手続きを修正せよ。
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.78"></a>
<b>Exercise 3.78.</b>  <a name="%_fig_3.35"></a></p>

<p class="trans" lang="ja">
<b>練習問題3.78.</b> 
</p>

<figure>
<img src="ch3-Z-G-53.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.35:</b>  Signal-flow diagram for the solution to a second-order
linear differential equation.</figcaption>
<figcaption class="trans" lang="ja"><b>図3.35:</b> 2次線形微分方程式用の信号流れ図</figcaption>
</figure>

<p class="orig" lang="en">
<a name="%_idx_4082"></a>Consider the problem of designing a signal-processing system to study
the homogeneous second-order linear differential equation
</p>

<p class="trans" lang="ja">
斉次2次線形微分方程式を検討するための信号処理システムを設計する問題を考えよう。
</p>

<figure><img src="ch3-Z-G-54.gif" border="0"></figure>


<p class="orig" lang="en">
The output stream, modeling <em>y</em>, is generated by a network that
contains a loop. This is because the value of <em>d</em><sup>2</sup><em>y</em>/<em>d</em><em>t</em><sup>2</sup> depends
upon the values of <em>y</em> and <em>d</em><em>y</em>/<em>d</em><em>t</em> and both of these are determined by
integrating <em>d</em><sup>2</sup><em>y</em>/<em>d</em><em>t</em><sup>2</sup>.  The diagram we would like to encode is
shown in figure <a href="#%_fig_3.35">3.35</a>.  Write a procedure <tt>solve-2nd</tt> that
takes as arguments the constants <em>a</em>, <em>b</em>, and <em>d</em><em>t</em> and the initial
values <em>y</em><sub>0</sub> and <em>d</em><em>y</em><sub>0</sub> for <em>y</em> and <em>d</em><em>y</em>/<em>d</em><em>t</em> and generates the
stream of successive values of <em>y</em>.

</p>

<p class="trans" lang="ja">
出力ストリーム—— <em class="en">y</em> をモデル化している——は、ループを含むネットワークによって生成される。
その理由は、
<em class="en">d</em><sup>2</sup><em class="en">y</em>/<em class="en">d</em><em class="en">t</em><sup>2</sup>
が
<em class="en">y</em> 
と
<em class="en">d</em><em class="en">y</em>/<em class="en">d</em><em class="en">t</em>
の値に依存しており、かつ、これらの値の双方が、
<em class="en">d</em><sup>2</sup><em class="en">y</em>/<em class="en">d</em><em class="en">t</em><sup>2</sup>
を積分することによって決定づけられるからである。
私たちがコードに落とし込みたい図は、図<a href="#%_fig_3.35">3.35</a>に示されている。
<em class="en">a</em> と <em class="en">b</em> と <em class="en">dt</em> という定数と、
<em class="en">y</em> および <em class="en">dy</em>/<em class="en">dt</em> に対する
<em class="en">y</em><sub>0</sub> および <em class="en">dy</em><sub>0</sub> という初期値を引数としてとり、引き続く <em class="en">y</em> の値のストリームを生成するような、<tt>solve-2nd</tt> という手続きを書け。
</p> 


<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.79"></a>
<b>Exercise 3.79.</b>  <a name="%_idx_4084"></a>Generalize the <tt>solve-2nd</tt> procedure of exercise <a href="#%_thm_3.78">3.78</a> so
that it can be used to solve general second-order differential
equations <em>d</em><sup>2</sup> <em>y</em>/<em>d</em><em>t</em><sup>2</sup> = <em>f</em>(<em>d</em><em>y</em>/<em>d</em><em>t</em>,  <em>y</em>).
</p>

<p class="trans" lang="ja">
<b>練習問題3.79.</b> 練習問題<a href="#%_thm_3.78">3.78</a>の <tt>solve-2nd</tt> という手続きを、
<span class="math"><em class="en">d</em><sup>2</sup> <em class="en">y</em>/<em class="en">dt</em><sup>2</sup> = <em class="en">f</em>(<em class="en">dy</em>/<em class="en">dt</em>,  <em class="en">y</em>)</span>
という一般の2次微分方程式を解くのに使えるように、一般化せよ。
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.80"></a>
<b>Exercise 3.80.</b>  <a name="%_idx_4086"></a><a name="%_idx_4088"></a><a name="%_idx_4090"></a>A <em>series RLC circuit</em> consists of a resistor, a capacitor, and an
inductor connected in series, as shown in figure <a href="#%_fig_3.36">3.36</a>.
If <em>R</em>, <em>L</em>, and <em>C</em> are the resistance, inductance, and capacitance,
then the relations between voltage (<em>v</em>) and current (<em>i</em>)
for the three components are described by the equations
</p>

<p class="trans" lang="ja">
<b>練習問題3.80.</b> <em>直列RLC回路</em>は、図<a href="#%_fig_3.36">3.36</a>に示すように、直列に接続された、抵抗器とキャパシタとインダクタからなる。
<em class="en">R</em> と <em class="en">L</em> と <em class="en">C</em> が、抵抗値とインダクタンスとキャパシタンスであるとすると、三つの部品についての、電圧 (<em class="en">v</em>) と電流 (<em class="en">i</em>) の間の関係は、以下の方程式のように記述され、
</p>

<figure><img src="ch3-Z-G-55.gif" border="0"></figure>


<p class="orig" lang="en">
and the circuit connections dictate the relations
</p>

<p class="trans" lang="ja">
回路の接続が、以下の関係を決定する。
</p>

<figure><img src="ch3-Z-G-56.gif" border="0"></figure>


<p class="orig" lang="en">
Combining these equations shows that the state of the circuit
(summarized by <em>v</em><sub><em>C</em></sub>, the voltage across the capacitor, and <em>i</em><sub><em>L</em></sub>, the
current in the inductor)
is described by the pair of differential equations
</p>

<p class="trans" lang="ja">
これらの方程式を結びつけると、回路の状態 (<em class="en">v<sub>C</sub></em> ——すなわちキャパシタの両端の電圧——と、<em class="en">i<sub>L</sub></em> ——すなわちインダクタを流れる電流——により要約される) が以下の一対の微分方程式により記述される、ということが示される。
</p>

<figure><img src="ch3-Z-G-57.gif" border="0"></figure>


<p class="orig" lang="en">
The signal-flow diagram representing this system of differential
equations is shown in figure <a href="#%_fig_3.37">3.37</a>.
</p>

<p class="trans" lang="ja">
微分方程式のこのような体系を表す信号流れ図が、図<a href="#%_fig_3.37">3.37</a>に示されている。
</p>

<a name="%_fig_3.36"></a>
<figure>
<img src="ch3-Z-G-58.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.36:</b>  A series RLC circuit.</figcaption>
<figcaption class="trans" lang="ja"><b>図3.36:</b> 直列RLC回路</figcaption>
</figure>

<a name="%_fig_3.37"></a>
<figure>
<img src="ch3-Z-G-59.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.37:</b>  A signal-flow diagram for the solution
to a series RLC circuit.</figcaption>
<figcaption class="trans" lang="ja"><b>図3. 37:</b> 直列RLC回路に対する解のための信号流れ図</figcaption>
</figure>


<p class="orig" lang="en">
Write a procedure <tt>RLC</tt> that takes as arguments the parameters
<em>R</em>, <em>L</em>, and <em>C</em> of the circuit and the time increment <em>d</em><em>t</em>.  In a
manner similar to that of the <tt>RC</tt> procedure of
exercise <a href="#%_thm_3.73">3.73</a>, <tt>RLC</tt> should produce a procedure
that takes the initial values of the state variables, <em>v</em><sub><em>C</em><sub>0</sub></sub> and
<em>i</em><sub><em>L</em><sub>0</sub></sub>, and produces a pair (using <tt>cons</tt>) of the streams of
states <em>v</em><sub><em>C</em></sub> and <em>i</em><sub><em>L</em></sub>.  Using <tt>RLC</tt>, generate the pair of
streams that models the behavior of a series RLC circuit with <em>R</em>  =  1
ohm, <em>C</em> =  0.2 farad, <em>L</em>  =  1 henry, <em>d</em><em>t</em>  =  0.1 second, and initial
values <em>i</em><sub><em>L</em><sub>0</sub></sub>  =  0 amps and <em>v</em><sub><em>C</em><sub>0</sub></sub>  =  10 volts.
</p>

<p class="trans" lang="ja">
この回路の <em class="en">R</em> と <em class="en">L</em> と <em class="en">C</em> というパラメタと、<em class="en">dt</em> という時間増分とを引数としてとる、<tt>RLC</tt> という手続きを書け。
状態変数の初期値——つまり、
<span class="math"><em class="en">v</em><sub><em class="en">C</em><sub>0</sub></sub></span> と
<span class="math"><em class="en">i</em><sub><em class="en">L</em><sub>0</sub></sub></span>
——をとり、
<span class="math"><em class="en">v<sub>C</sub></em></span> と
<span class="math"><em class="en">i<sub>L</sub></em></span>
という状態のストリーム同士の (<tt>cons</tt> を用いた) 対を作り出す手続きを、<tt>RLC</tt> は、練習問題<a href="#%_thm_3.73">3.73</a>の <tt>RC</tt> という手続きでのやり方と似たやり方で、作り出すはずである。
<em class="en">R</em> が 1 Ω (オーム) で、<em class="en">C</em> が 0.2 F (ファラッド) で、<em class="en">L</em> が 1 H (ヘンリー)で、<em class="en">dt</em> が 0.1 秒で、初期値は
<span class="math"><em class="en">i</em><sub><em class="en">L</em><sub>0</sub></sub></span> が 0 A (アンペア) で
<span class="math"><em class="en">i</em><sub><em class="en">L</em><sub>0</sub></sub></span> が 10 V (ボルト) であるような直列RLC回路の振る舞いをモデル化する一対のストリームを、<tt>RLC</tt> を用いて生成せよ。
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_Temp_499"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_499">Normal-order evaluation</a></h4>
<h4 class="trans" lang="ja">正規順の評価</h4>

<p class="orig" lang="en">
<a name="%_idx_4092"></a><a name="%_idx_4094"></a>
The examples in this section illustrate how the explicit use of <tt>delay</tt> and <tt>force</tt> provides great programming flexibility, but the
same examples also show how this can make our programs more complex.
Our new <tt>integral</tt> procedure, for instance, gives us the power to
model systems with loops, but we must now remember that <tt>integral</tt>
should be called with a delayed integrand, and every procedure that
uses <tt>integral</tt> must be aware of this.  In effect, we have created
two classes of procedures: ordinary procedures and procedures that
take delayed arguments.  In general, creating separate classes of
procedures forces us to create separate classes of higher-order
procedures as well.<a name="call_footnote_Temp_500" href="#footnote_Temp_500"><sup><small>72</small></sup></a></p>

<p class="trans" lang="ja">
本節の事例は、<tt>delay</tt> と <tt>force</tt> の明示的な使用が、どのようにして素晴らしいプログラミングの柔軟性をもたらしてくれるのか、ということを示しているが、同じ事例が、この <tt>delay</tt> と <tt>force</tt> の明示的な使用によってプログラムがどのようにして一層複雑になりうるのか、ということをも示している。
たとえば、新しい方の <tt>integral</tt> の手続きは、ループのあるシステムをモデル化する力を与えてくれるが、私たちはここで、<tt>integral</tt> は遅延された被積分関数とともに呼ばれるべきである、ということを覚えていなくてはならず、<tt>integral</tt> を使うどの手続きも、このことに自覚的でなくてはならないのである。
事実上、私たちは、手続きの二つのクラス——つまり、普通の手続きと、遅延された引数を取る手続き——を作成したわけだ。
一般に、手続きの別々のクラスを作成することにより、私たちは、より高次の手続きの別々のクラスも、作らざるを得なくなる<a href="#footnote_Temp_500"><sup><small>72</small></sup></a>。

</p>

<p class="orig" lang="en">
One way to avoid the need for two different classes of procedures is
to make all procedures take delayed arguments.  We could adopt a model
of evaluation in which all arguments to procedures are automatically
delayed and arguments are forced only when they are actually needed
(for example, when they are required by a primitive operation).  This
would transform our language to use normal-order evaluation, which we
first described when we introduced the substitution model for
evaluation in section <a href="10_sec1_1.html#%_sec_1.1.5">1.1.5</a>.  Converting to
normal-order evaluation provides a uniform and elegant way to simplify
the use of delayed evaluation, and this would be a natural strategy to
adopt if we were concerned only with stream processing.  In
section <a href="27_sec4_2.html#%_sec_4.2">4.2</a>, after we have studied the evaluator, we
will see how to transform our language in just this way.
Unfortunately, including delays in procedure calls wreaks havoc with
our ability to design programs that depend on the order of events,
such as programs that use assignment, mutate data, or perform input or
output.  Even the single <tt>delay</tt> in <tt>cons-stream</tt> can cause
great confusion, as illustrated by exercises <a href="#%_thm_3.51">3.51</a>
and <a href="#%_thm_3.52">3.52</a>.  As far as anyone knows, mutability and delayed
evaluation do not mix well in programming languages, and devising ways
to deal with both of these at once is an active area of research.</p>

<p class="trans" lang="ja">
手続きの二つの異なるクラスに対する必要性を避けるための一つの方法は、すべての手続きに、遅延された引数をとらせることである。
手続きに対するすべての引数が自動的に遅延され、かつ、引数が実際に必要とされるとき (たとえば、引数が原始的な演算から必要とされるとき) にだけ、引数が強制 (<tt>force</tt>) されるような評価のモデルを、採用することもできただろう。
これは、私たちの言語を、正規順の評価——評価のための<ruby><rb>代入</rb><rp> (</rp><rt>おきかえ</rt><rp>) </rp></ruby>モデルを<a href="10_sec1_1.html#%_sec_1.1.5">1.1.5</a>節で導入したときに、最初に説明した——を用いるように、変形させることだろう。
正規順の評価への転換は、遅延評価の使用を簡素化するための、一律で洗練された方法であるし、これは、もし私たちがストリーム処理にだけ関心があったならば、採用すべき自然な戦略であっただろう。
<a href="27_sec4_2.html#%_sec_4.2">4.2</a>節で、評価器について検討した後に、まさにこの方法で私たちの言語を変形するにはどうすればよいのか、ということを見ることにしよう。
あいにく、手続き呼び出しに遅延を含めることは、出来事の順序に依存するプログラム——<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>を使ったり、データを変更したり、入出力を行ったりするプログラムなど——を設計するという私たちの能力に、大打撃を与える。
<tt>cons-stream</tt> の中の単一の <tt>delay</tt> でさえ、練習問題<a href="#%_thm_3.51">3.51</a>と練習問題<a href="#%_thm_3.52">3.52</a>により例示されるとおり、大きな混乱を引き起こし得る。
知られている限りでは、変更可能であることと遅延評価とは、プログラミング言語においてうまく両立しないし、これら両者を一度に扱うための方法を考案することは、研究における活発な分野なのである。
</p>

<a name="%_sec_3.5.5"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_3.5.5">3.5.5  Modularity of Functional Programs and Modularity of Objects</a></h3>
<h3 class="trans" lang="ja">3.5.5 関数型プログラムのモジュール性とオブジェクトのモジュール性</h3>

<p class="orig" lang="en">
<a name="%_idx_4116"></a><a name="%_idx_4118"></a>
As we saw in section <a href="20_sec3_1.html#%_sec_3.1.2">3.1.2</a>, one of the
major benefits of introducing assignment is that we can increase the
modularity of our systems by encapsulating, or ``hiding,'' parts of
the state of a large system within local variables.  Stream models can
provide an equivalent modularity without the use of assignment.  As an
<a name="%_idx_4120"></a><a name="%_idx_4122"></a>illustration, we can reimplement the Monte Carlo estimation of <img src="book-Z-G-D-9.gif" border="0">,
which we examined in section <a href="20_sec3_1.html#%_sec_3.1.2">3.1.2</a>, from a
stream-processing point of view.</p>

<p class="trans" lang="ja">
<a href="20_sec3_1.html#%_sec_3.1.2">3.1.2</a>節で見たとおり、<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>を導入することの主要な利点の一つは、大きなシステムの状態の一部を、局所変数の中にカプセル化する——すなわち「隠す」——ことにより、システムのモジュール性を増すことができる点である。
ストリーム・モデルは、<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>を使うことなく、等価なモジュール性を提供できる。
例示として、&pi; のモンテカルロ推定——<a href="20_sec3_1.html#%_sec_3.1.2">3.1.2</a>節で検討した——を、ストリーム処理の観点から、実装し直すことができる。
</p>

<p class="orig" lang="en">
The key modularity issue was that we wished to hide the internal state
of a random-number generator from programs that used random numbers.
We began with a procedure <tt>rand-update</tt>, whose successive values
furnished our supply of random numbers, and used this to produce a
random-number generator:</p>

<p class="trans" lang="ja">
鍵となるモジュール性の論点は、乱数生成器の内部状態を、乱数を使うプログラムからは隠しておきたい、という点であった。
私たちは、<tt>rand-update</tt> という手続き——これの連続する値が、乱数の供給を与えてくれる——から始め、これを用いて乱数生成器を作り出した。
</p>


<p class="lisp">(define rand
  (let ((x random-init))
    (lambda ()
      (set! x (rand-update x))
      x)))
</p>

<p class="orig" lang="en">
In the stream formulation there is no random-number generator <em>per
se</em>, just a stream of random numbers produced by successive calls to
<tt>rand-update</tt>:</p>

<p class="trans" lang="ja">
ストリームによる定式化においては、乱数生成器そのものは存在せず、ただ、<tt>rand-update</tt> に対する連続する呼び出しによって作り出される、乱数のストリームがあるだけである。
</p>

<p class="lisp"><a name="%_idx_4124"></a><a name="%_idx_4126"></a>(define random-numbers
  (cons-stream random-init
               (stream-map rand-update random-numbers)))
</p>

<p class="orig" lang="en">
We use this to construct the stream of outcomes of the Ces&agrave;ro
experiment performed on consecutive pairs in the <tt>random-numbers</tt>
stream:</p>

<p class="trans" lang="ja">
これを使って、私たちは、<tt>random-numbers</tt> のストリームの中の、連続する対に対して行われる、Ces&agrave;ro の実験の結果のストリームを構築する。
</p>


<p class="lisp"><a name="%_idx_4128"></a>(define cesaro-stream
  (map-successive-pairs (lambda (r1 r2) (= (gcd r1 r2) 1))
                        random-numbers))

<a name="%_idx_4130"></a>(define (map-successive-pairs f s)
  (cons-stream
   (f (stream-car s) (stream-car (stream-cdr s)))
   (map-successive-pairs f (stream-cdr (stream-cdr s)))))
</p>

<p class="orig" lang="en">
The <tt>cesaro-stream</tt> is now fed to a <tt>monte-carlo</tt> procedure,
which produces a stream of estimates of probabilities.  The results
are then converted into a stream of estimates of <img src="book-Z-G-D-9.gif" border="0">.  This version
of the program doesn't need a parameter telling how many trials to
perform.  Better estimates of <img src="book-Z-G-D-9.gif" border="0"> (from performing more experiments)
are obtained by looking farther into the <tt>pi</tt> stream:</p>

<p class="trans" lang="ja">
さて今や、<tt>cesaro-stream</tt> は、<tt>monte-carlo</tt> の手続き——確率の推定値のストリームを作り出す——へと与えられる。
それから、結果が、&pi; の推定値のストリームへと変換される。
プログラムのこのバージョンは、試行を何回おこなうのかを知らせるパラメタを必要としない。
(より多くの実験を行うことによる) &pi; のより良い推定値は、<tt>pi</tt> のストリームをもっと先まで見ることによって、得られる。
</p>

<p class="lisp"><a name="%_idx_4132"></a>(define (monte-carlo experiment-stream passed failed)
  (define (next passed failed)
    (cons-stream
     (/ passed (+ passed failed))
     (monte-carlo
      (stream-cdr experiment-stream) passed failed)))
  (if (stream-car experiment-stream)
      (next (+ passed 1) failed)
      (next passed (+ failed 1))))

(define pi
  (stream-map (lambda (p) (sqrt (/ 6 p)))
              (monte-carlo cesaro-stream 0 0)))
</p>

<p class="orig" lang="en">
<a name="%_idx_4134"></a>There is considerable modularity in this approach, because we still
can formulate a general <tt>monte-carlo</tt> procedure that can deal with
arbitrary experiments.  Yet there is no assignment or local state.</p>

<p class="trans" lang="ja">
この手法には、注目に値するモジュール性がある。というのも、依然として私たちは、任意の実験を扱える一般的な <tt>monte-carlo</tt> の手続きを、定式化できるからである。
しかし、<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>も局所状態も存在しないのだ。
</p>


<p class="orig" lang="en"><a name="%_thm_3.81"></a>
<b>Exercise 3.81.</b>  <a name="%_idx_4136"></a>Exercise <a href="20_sec3_1.html#%_thm_3.6">3.6</a>
discussed generalizing the random-number generator to
allow one to reset the random-number sequence so as to produce
repeatable sequences of ``random'' numbers.  Produce a stream
formulation of this same generator that operates on an input stream of
requests to <tt>generate</tt> a new random number or to <tt>reset</tt> the
sequence to a specified value and that produces the desired stream of
random numbers.  Don't use assignment in your solution.
</p>

<p class="trans" lang="ja">
<b>練習問題3.81.</b> 「ランダムな」数の反復可能な列を作り出すために人が乱数列をリセットすることを可能とするよう、乱数生成器を一般化することについて、練習問題<a href="20_sec3_1.html#%_thm_3.6">3.6</a>で論じた。
この同じ生成器のストリーム的な定式化であって、新たな乱数を生成する (<tt>generate</tt>) ため、または、指定された値に列をリセットする (<tt>reset</tt>) ための要求からなる入力ストリームに対して動作し、かつ、乱数からなる所望のストリームを作り出すものを、作り出せ。
君の解決策の中では、<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>を使ってはならない。
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.82"></a>
<b>Exercise 3.82.</b>  <a name="%_idx_4138"></a><a name="%_idx_4140"></a><a name="%_idx_4142"></a>Redo exercise <a href="20_sec3_1.html#%_thm_3.5">3.5</a> on Monte Carlo
integration in terms of streams.  The stream version of <tt>estimate-integral</tt> will not have an argument telling how many trials
to perform.  Instead, it will produce a stream of estimates based on
successively more trials.
</p>

<p class="trans" lang="ja">
<b>練習問題3.82.</b> モンテカルロ積分に関する練習問題<a href="20_sec3_1.html#%_thm_3.5">3.5</a>を、ストリームの観点から、やり直せ。
<tt>estimate-integral</tt> のストリーム版は、試行を何回行うかを知らせる引数を持たないだろう。
<tt>estimate-integral</tt> のストリーム版は、代わりに、連続した更なる試行にもとづく推定値のストリームを作り出すだろう。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_Temp_503"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_503">A functional-programming view of time</a></h4>
<h4 class="trans" lang="ja">時間についての関数型プログラミングでの見方</h4>

<p class="orig" lang="en">
<a name="%_idx_4144"></a><a name="%_idx_4146"></a>
Let us now return to the issues of objects and state that were raised
at the beginning of this chapter and examine them in a new light.  We
introduced assignment and mutable objects to provide a mechanism for
modular construction of programs that model systems with state.
We constructed computational
objects with local state variables and used assignment to modify these
variables.  We modeled the temporal behavior of the objects in the
world by the temporal behavior of the corresponding computational
objects.</p>

<p class="trans" lang="ja">
さて、本章の始めに提起されたオブジェクトと状態の問題に戻って、これらの問題を新たな観点から吟味しよう。
私たちは、状態を有する<ruby><rb>系</rb><rp> (</rp><rt>システム</rt><rp>) </rp></ruby>をモデル化するプログラムの、モジュール性のある構築のための仕組みを提供するために、<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>と変更可能なオブジェクトを導入した。
私たちは、局所状態変数を有する、計算機上のオブジェクトを構築し、これらの変数を変更するために、<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>を用いた。
私たちは、世界の中での<ruby><rb>物</rb><rp> (</rp><rt>オブジェクト</rt><rp>) </rp></ruby>の時間的な振る舞いを、それに対応する計算機上のオブジェクトの時間的な振る舞いによって、モデル化した。
</p>

<p class="orig" lang="en">
Now we have seen that streams provide an alternative way to model
objects with local state.  We can model a changing quantity, such as
the local state of some object, using a stream that represents the
time history of successive states.  In essence, we represent time
explicitly, using streams, so that we decouple time in our simulated
world from the sequence of events that take place during evaluation.
Indeed, because of the presence of <tt>delay</tt> there may be little
relation between simulated time in the model and the order of events
during the evaluation.</p>

<p class="trans" lang="ja">
さて、私たちは、局所状態を有する<ruby><rb>物</rb><rp> (</rp><rt>オブジェクト</rt><rp>) </rp></ruby>をモデル化するための代わりの方法をストリームが与えてくれるのだ、ということを見てきたところである。
何らかの<ruby><rb>物</rb><rp> (</rp><rt>オブジェクト</rt><rp>) </rp></ruby>の局所状態などといった、変化している量を、私たちは、連続する状態の時間履歴を表すストリームを用いてモデル化できる。
本質的には、私たちは、ストリームを使って時間を明示的に表現し、するとその結果、私たちは、シミュレートされた世界における時間を、評価の間に起こる出来事の並びから、切り離すことになる。
実際、<tt>delay</tt> の存在のおかげで、モデル内でのシミュレートされた時間と、評価の間の出来事の順序との間には、ほとんど関係がないこともある。
</p>

<p class="orig" lang="en">
In order to contrast these two approaches to modeling, let us
reconsider the implementation of a ``withdrawal processor'' that
<a name="%_idx_4148"></a>monitors the balance in a bank account.  In
section <a href="20_sec3_1.html#%_sec_3.1.3">3.1.3</a> we implemented a simplified
version of such a processor:</p>

<p class="trans" lang="ja">
モデル化に対するこれら二つの取り組み方を対比するために、銀行口座の残高を監視する「引き出し処理器」の実装について、もう一度考えよう。
<a href="20_sec3_1.html#%_sec_3.1.3">3.1.3</a>節では、そうした処理器の簡単化されたバージョンを実装した。
</p>

<p class="lisp"><a name="%_idx_4150"></a>(define (make-simplified-withdraw balance)
  (lambda (amount)
    (set! balance (- balance amount))
    balance))
</p>

<p class="orig" lang="en">
Calls to <tt>make-simplified-withdraw</tt> produce computational objects,
each with a local state variable <tt>balance</tt> that is decremented by
successive calls to the object.  The object takes an <tt>amount</tt> as
an argument and returns the new balance.  We can imagine the user of a
bank account typing a sequence of inputs to such an object and
observing the sequence of returned values shown on a display screen.</p>

<p class="trans" lang="ja">
<tt>make-simplified-withdraw</tt> に対する呼び出しは、計算機上のオブジェクトを作り出し、それらのオブジェクトの各々は、当該オブジェクトに対する後続の呼び出しによって減らされる、<tt>balance</tt> (残高) という局所状態変数を有する。
オブジェクトは引数として <tt>amount</tt> をとり、新たな残高を返す。
そういうオブジェクトへの入力列をタイプして、ディスプレイの画面上に示される返り値の列を観察する、銀行口座の利用者を、私たちは想像することができる。
</p>

<p class="orig" lang="en">
Alternatively, we can model a withdrawal processor as a procedure that
takes as input a balance and a stream of amounts to withdraw and
produces the stream of successive balances in the account:</p>

<p class="trans" lang="ja">
あるいは、残高と、引き出すべき金額のストリームとを入力としてとり、その口座における連続する残高のストリームを作り出すような手続きとして、私たちは、引き出し処理器をモデル化できる。
</p>

<p class="lisp"><a name="%_idx_4152"></a>(define (stream-withdraw balance amount-stream)
  (cons-stream
   balance
   (stream-withdraw (- balance (stream-car amount-stream))
                    (stream-cdr amount-stream))))
</p>

<p class="orig" lang="en">
<tt>Stream-withdraw</tt> implements a well-defined mathematical function whose
output is fully determined by its input.  Suppose, however, that the
input <tt>amount-stream</tt> is the stream of successive values typed by
the user and that the resulting stream of balances is displayed.
Then, from the perspective of the user who is typing values and
watching results, the stream process has the same behavior as the
object created by <tt>make-simplified-withdraw</tt>.  However, with the
stream version, there is no assignment, no local state variable, and
consequently none of the theoretical difficulties that we encountered
<a name="%_idx_4154"></a>in section <a href="20_sec3_1.html#%_sec_3.1.3">3.1.3</a>.  Yet the system has state!</p>

<p class="trans" lang="ja">
<tt>stream-withdraw</tt> は、その出力が完全に入力によって定められるような、うまく定義された数学的関数である。
しかし、<tt>amount-stream</tt> という入力が、ユーザによってタイプされた連続する値のストリームであり、かつ、結果として生じる残高のストリームが表示される、と仮定しよう。
すると、値をタイプして結果を見ているユーザの観点からすると、ストリーム・プロセスは、<tt>make-simplified-withdraw</tt> により作成されるオブジェクトと同じ振る舞いを見せる。
しかし、ストリーム版を使うと、<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>がなく、局所状態変数がなく、したがって、私たちが<a href="20_sec3_1.html#%_sec_3.1.3">3.1.3</a>節で遭遇した理論上の困難が何もない。
それでもシステムには状態がある!
</p>

<p class="orig" lang="en">
This is really remarkable.  Even though <tt>stream-withdraw</tt> implements a
well-defined mathematical function whose behavior does not change, the
user's perception here is one of interacting with a system that has a
changing state.  One way to resolve this paradox is to realize that it
is the user's temporal existence that imposes state on the system.  If
the user could step back from the interaction and think in terms of
streams of balances rather than individual transactions, the system
would appear stateless.<a name="call_footnote_Temp_504" href="#footnote_Temp_504"><sup><small>73</small></sup></a></p>

<p class="trans" lang="ja">
これは、まことにもって驚くべきことだ。
<tt>stream-withdraw</tt> が、振る舞いの変わらない、よく定義された数学的関数を実装していてさえ、ここでのユーザの認識は、変化する状態を有するシステムと相互作用している、というものなのだ。
この矛盾を解く一つの方法は、システムに対して状態を押しつけるのはユーザの時間的存在なのだ、ということを実現することである。
もし、ユーザが相互作用から一歩戻って、個々の取引というよりもむしろ残高のストリームの観点から考えることができたなら、システムは状態なしに見えたことだろう。
</p>

<p class="orig" lang="en">
From the point of view of one part of a complex process, the other
parts appear to change with time.  They have hidden time-varying local
state.  If we wish to write programs that model this kind of natural
decomposition in our world (as we see it from our viewpoint as a part of
that world) with
structures in our computer, we make computational objects that are not
functional -- they must change with time.  We model state with local
state variables, and we model the changes of state with assignments to
those variables.  By doing this we make the time of execution of a
computation model time in the world that we are part of, and thus we
get ``objects'' in our computer.</p>

<p class="trans" lang="ja">
複雑なシステムの一つの部分という観点からすると、残りの部分は、時とともに変化するように見える。
それら残りの部分は、経時変化する局所状態を隠したのだ。
もし、世界におけるこの種の自然な分解を (その世界の一部としての私たちの視点から、私たちがその分解を見ているとおりに) モデル化するプログラムを、コンピュータ内の構造物を使って書きたければ、私たちは、関数型ではない計算オブジェクト——それらは時とともに変化するに違いない——を作る。
私たちは、局所状態変数で状態をモデル化するし、それらの変数への<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>で状態の変化をモデル化する。
こうすることで、私たちは、私たちがその一部をなしている世界における計算モデル時間の実行の時間を作るのだし、よって、私たちのコンピュータ内の「オブジェクト」を得るのである。<span class="note">(なんかいまいちな訳だな)</span>
</p>

<p class="orig" lang="en">
Modeling with objects is powerful and intuitive, largely because this
matches the perception of interacting with a world of which we are
part.  However, as we've seen repeatedly throughout this chapter,
these models raise thorny problems of constraining the order of events
and of synchronizing multiple processes.  The possibility of avoiding
these problems has stimulated the development of <a name="%_idx_4158"></a><a name="%_idx_4160"></a><em>functional
programming languages</em>, which do not include any provision for
assignment or mutable data.  In such a language, all procedures
implement well-defined mathematical functions of their arguments,
whose behavior does not change.  The functional approach is extremely
<a name="%_idx_4162"></a><a name="%_idx_4164"></a>attractive for dealing with concurrent systems.<a name="call_footnote_Temp_505" href="#footnote_Temp_505"><sup><small>74</small></sup></a></p>

<p class="trans" lang="ja">
オブジェクトを使うモデル化は強力で直観的だが、それは主に、私たちがその一部をなしている世界と相互作用しているのだという認識と、このモデル化とが、適合しているからである。
しかし、本章を通してずっと繰り返し見てきたとおり、こういうモデルは、出来事の順序を制約するだとか、複数のプロセスを同期させるだとかの、厄介な問題を引き起こす。
これらの問題を回避するという可能性が、<em>関数型プログラミング言語</em>——<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>もしくは変更可能なデータについての準備を何も含まない——の開発を刺激してきた。
そうした言語では、すべての手続きは、その手続きの引数の、よく定義された数学的関数を実装しており、その手続きの振る舞いは変化しない。
関数型の手法は、並行システムを扱うのに極めて魅力的である<a href="#footnote_Temp_505"><sup><small>74</small></sup></a>。
</p>

<p class="orig" lang="en">
On the other hand, if we look closely, we can see time-related
problems creeping into functional models as well.  One particularly
troublesome area arises when we wish to design interactive systems,
especially ones that model interactions between independent entities.
For instance, consider once more the implementation a banking system
that permits joint bank accounts.  In a conventional system using
assignment and objects, we would model the fact that Peter and Paul
share an account by having both Peter and Paul send their transaction
requests to the same bank-account object, as we saw in
section <a href="20_sec3_1.html#%_sec_3.1.3">3.1.3</a>.
From the stream point of view, where there are no ``objects'' <em>per
se</em>, we have already indicated that a bank account can be modeled as a
process that operates on a stream of transaction requests to produce a
stream of responses.  Accordingly, we could model the fact that Peter
and Paul have a joint bank account by merging Peter's stream of
transaction requests with Paul's stream of requests and feeding the
result to the bank-account stream process, as shown in
figure <a href="#%_fig_3.38">3.38</a>.</p>

<p class="trans" lang="ja">
一方で、もしよく見るならば、私たちは、時間に関連する問題が関数型のモデルにも同様に入り込んでいるのを見ることができる。
特に面倒な一つの分野は、対話型システム——とりわけ、独立した実体間のやりとりをモデル化するもの——を設計したいと思うときに、生じる。
たとえば、共同銀行口座を許す銀行システムの実装を、もう一度、考えよう。
<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>とオブジェクトを使う従来のシステムでは、<a href="20_sec3_1.html#%_sec_3.1.3">3.1.3</a>節で見たとおり、ピーターとポールの両人に対して、自分の取引要求を同じ銀行口座オブジェクトへと送らせることによって、私たちは、ピーターとポールが口座を共有しているという事実をモデル化したであろう。
ストリームの観点——「オブジェクト」そのものがないところ——から、私たちは既に、こう指摘した。すなわち、取引要求のストリームに対して動作して、応答のストリーム作り出すような手続きとして、銀行口座をモデル化できるのだ、と。
したがって、ピーターとポールが共同銀行口座を持っているという事実を、私たちは、図<a href="#%_fig_3.38">3.38</a>に示すように、ピーターの取引要求のストリームとポールの取引要求のストリームとを合併し、その結果を銀行口座のストリーム・プロセスに与えることによって、モデル化できるだろう。
</p>

<a name="%_fig_3.38"></a>
<figure>
<img src="ch3-Z-G-60.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.38:</b>  A joint bank account, modeled by merging two streams of
transaction requests.</figcaption>
<figcaption class="trans" lang="ja"><b>図3.38:</b> 取引要求の二つのストリームを合併することによってモデル化される、共同口座</figcaption>
<a name="%_idx_4176"></a>
</figure>

<p class="orig" lang="en">
<a name="%_idx_4178"></a>The trouble with this formulation is in the notion of <em>merge</em>.  It
will not do to merge the two streams by simply taking alternately one
request from Peter and one request from Paul. Suppose Paul accesses
the account only very rarely.  We could hardly force Peter to wait for
Paul to access the account before he could issue a second transaction.
However such a merge is implemented, it must interleave the two
transaction streams in some way that is constrained by ``real
time'' as perceived by Peter and Paul, in the sense that, if Peter and
Paul meet, they can agree that certain transactions were processed
before the meeting, and other transactions were processed after the
meeting.<a name="call_footnote_Temp_506" href="#footnote_Temp_506"><sup><small>75</small></sup></a>
This is precisely the same constraint that we had to deal with in
section <a href="23_sec3_4.html#%_sec_3.4.1">3.4.1</a>, where we found the need to introduce
explicit synchronization to ensure a ``correct'' order of events in
concurrent processing of objects with state.  Thus, in an attempt to
support the functional style, the need to merge inputs from different
agents reintroduces the same problems that the functional style was
meant to eliminate.</p>

<p class="trans" lang="ja">
この定式化に関する問題は、<em><ruby><rb>合併</rb><rp> (</rp><rt>マージ</rt><rp>) </rp></ruby></em>の概念の中にある。
単純に、ピーターからの一つの要求と、ポールからの一つの要求とを交互に取りあげることで、二つのストリームを合併するのでは、うまくいかないだろう。
ポールが非常に稀にしか口座にアクセスしないものと仮定しよう。
<!--ポールが二度目の取引を発するかもしれないときより前に、ピーターに対し、ポールが口座にアクセスするのを無理やり待たせておくことは、ほとんどできない-->
<!--he=Peter? Paul?-->
<!--ポールが口座にアクセスするのをピーターに無理やり待たせておいて、それでやっとピーターが二度目の取引を発することができる、というふうにするのは、ほとんど無理である。-->
ピーターには、ポールが口座にアクセスするのを待つように強制しておいて、そうなってやっとピーターが二度目の取引を発することができる、というふうにするのは、ほとんど無理である。
<span class="note">(ちょっとこの文の訳は心もとない。)</span>
しかし、そういう合併は実装されるし、それは、ピーターとポールにより認識されるとおりの「実時間」により制約される——もしピーターとポールが会えば、ある取引はその出会いの前に処理されるだろうし、他の取引はその出会いの後に処理されるだろう、ということに二人が同意できる、という意味である——何らかの方法で、二つの取引ストリームを<ruby><rb>互いの間に挟み込む</rb><rp> (</rp><rt>インタリーブする</rt><rp>) </rp></ruby>に違いない<a href="#footnote_Temp_506"><sup><small>75</small></sup></a>。
これは、<a href="23_sec3_4.html#%_sec_3.4.1">3.4.1</a>節——状態を有するオブジェクトの並行処理における、出来事の「正しい」順序を保証するための、明示的な同期を導入する必要性に気づいた箇所である——で私たちが扱わねばならなかったものと、まさに同じ制約である。
よって、関数型の流儀をサポートしようという試みにおいては、関数型の流儀が排除することになっているはずの同じ問題が、異なる<ruby><rb>動作主</rb><rp> (</rp><rt>エージェント</rt><rp>) </rp></ruby>からの入力を合併せねばならないという必要性によって、再び持ち込まれてしまうのである。
</p>

<p class="orig" lang="en">
We began this chapter with the goal of building computational models
whose structure matches our perception of the real world we are trying
to model.  We can model the world as a collection of separate,
time-bound, interacting objects with state, or we can model the world
as a single, timeless, stateless unity.  Each view has powerful
advantages, but neither view alone is completely satisfactory.  A
grand unification has yet to emerge.<a name="call_footnote_Temp_507" href="#footnote_Temp_507"><sup><small>76</small></sup></a>
</p>

<p class="trans" lang="ja">
私たちがモデル化しようとしている実世界についての私たちの認識に、その構造が適合するような計算モデルを構築する、という目標から、私たちは本章を始めた。
私たちは、箇々別々の、時間に縛られた、互いに作用しあう、状態をともなったオブジェクトの集まり<!--箇々別々で時間に縛られていて互いに作用しあっており状態を有しているオブジェクトの集まり-->として、世界をモデル化することもできるし、あるいは、唯一の、時間も状態もない単一体として、世界をモデル化することもできる。
それぞれの考え方には強力な利点があるが、どちらの考え方も、それのみでは、完全に満足のいくものではない。
大いなる統一化は、まだ現れ出でていないのだ<a href="#footnote_Temp_507"><sup><small>76</small></sup></a>。
</p>

<a name="footnotes"></a>
<hr>

<p class="orig" lang="en"><a name="footnote_Temp_442" href="#call_footnote_Temp_442"><sup><small>52</small></sup></a> Physicists sometimes adopt this view by introducing the
<a name="%_idx_3728"></a>``world lines'' of particles as a device for reasoning about motion.
We've also already mentioned
(section <a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a>) that this is the
natural way to think about signal-processing systems.  We will explore
applications of streams to signal processing in
section <a href="#%_sec_3.5.3">3.5.3</a>.
</p>

<p class="trans" lang="ja">
物理学者はときどき、動きについての推定のための手段としての、粒子の「世界線」を導入することで、この見方を採用する。
これが信号処理システムについて考えるための自然な方法だ、ということも、既に述べた (<a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a>節)。
<a href="#%_sec_3.5.3">3.5.3</a>節では、信号処理へのストリームの応用を検討しよう。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_443" href="#call_footnote_Temp_443"><sup><small>53</small></sup></a> Assume that we have a
predicate <tt>prime?</tt> (e.g., as in section <a href="11_sec1_2.html#%_sec_1.2.6">1.2.6</a>) that
tests for primality.
</p>

<p class="trans" lang="ja">
素数性を試す、(<a href="11_sec1_2.html#%_sec_1.2.6">1.2.6</a>節でのような) <tt>prime?</tt> という述語があるものとしよう。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_444" href="#call_footnote_Temp_444"><sup><small>54</small></sup></a> In the MIT implementation, <a name="%_idx_3752"></a><a name="%_idx_3754"></a><a name="%_idx_3756"></a><tt>the-empty-stream</tt> is the
same as the empty list <tt>'()</tt>, and <tt>stream-null?</tt> is the same
as <tt>null?</tt>.
</p>

<p class="trans" lang="ja">
MITの処理系では、<tt>the-empty-stream</tt> は空リスト <tt>'()</tt> と同じであり、<tt>stream-null?</tt> は <tt>null?</tt> と同じである。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_445" href="#call_footnote_Temp_445"><sup><small>55</small></sup></a> This should bother you.  The fact that we are defining such
similar procedures for streams and lists indicates that we are missing some
underlying abstraction.  Unfortunately, in order to exploit this
abstraction, we will need to exert finer control over the process of
evaluation than we can at present.  We will discuss this point further
at the end of section <a href="#%_sec_3.5.4">3.5.4</a>.
In section <a href="27_sec4_2.html#%_sec_4.2">4.2</a>, we'll develop a framework that
unifies lists and streams.
</p>

<p class="trans" lang="ja">
これは君を悩ませるはずだ。
ストリーム用とリスト用のそうした類似の手続きを定義しているところだ、という事実は、根底にある何らかの抽象化を取り逃がしているところだ、ということを示す。
<span class="note">(類似のことを繰り返し行っているのは、共通の部分をうまく抜き出せていない証拠だよ、っていう意味)</span>
あいにく、この抽象化を利用するためには、評価のプロセスに対して、目下のところ可能であるよりも更に細かい制御を及ぼすことが必要であろう。
この点については、<a href="#%_sec_3.5.4">3.5.4</a>節の最後でさらに議論しよう。
<a href="27_sec4_2.html#%_sec_4.2">4.2</a>節では、リストとストリームを統一する枠組みを開発しよう。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_446" href="#call_footnote_Temp_446"><sup><small>56</small></sup></a> Although <tt>stream-car</tt> and
<a name="%_idx_3784"></a><a name="%_idx_3786"></a><tt>stream-cdr</tt> can be defined as procedures, <tt>cons-stream</tt> must
be a special form.  If <tt>cons-stream</tt> were a procedure, then,
according to our model of evaluation, evaluating <tt>(cons-stream
&lt;<em>a</em>&gt; &lt;<em>b</em>&gt;)</tt> would automatically cause &lt;<em>b</em>&gt; to be evaluated, which is
precisely what we do not want to happen.  For the same reason, <tt>delay</tt> must be a special form, though <tt>force</tt> can be an ordinary
procedure.
</p>

<p class="trans" lang="ja">
<tt>stream-car</tt> と <tt>stream-cdr</tt> は手続きとして定義できるが、<tt>cons-stream</tt> は特殊形式でなければならない。
もし <tt>cons-stream</tt> が手続きであったとしたら、私たちの評価のモデルによれば、
<tt>(cons-stream &lt;<em class="en">a</em>&gt; &lt;<em class="en">b</em>&gt;)</tt>
を評価することで、自動的に、&lt;<em class="en">b</em>&gt; を評価させることになり、それこそがまさに、起きてほしくない、と私たちが思うことなのだ。
同じ理由で、<tt>delay</tt> は特殊形式でなければならない—— <tt>force</tt> は普通の手続きであってもよいのだけれども。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_448" href="#call_footnote_Temp_448"><sup><small>57</small></sup></a> The numbers shown here do
not really appear in the delayed expression.  What actually appears is
the original expression, in an environment in which the variables are
bound to the appropriate numbers.  For example, <tt>(+ low 1)</tt> with
<tt>low</tt> bound to 10,000 actually appears where <tt>10001</tt> is
shown.
</p>

<p class="trans" lang="ja">
ここに示した数は、遅延された式の中に現実に現れることはない。
実際に現れるものは、変数が適切な数に束縛されている環境における、元の式である。
たとえば、<tt>low</tt> が 10,000 に束縛されている状態の <tt>(+ low 1)</tt> は、実際には、<tt>10001</tt> が示される場所に現れる。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_450" href="#call_footnote_Temp_450"><sup><small>58</small></sup></a> There are many
possible implementations of streams other than the one described in
this section.  Delayed evaluation, which is the key to making streams
practical, was inherent in <a name="%_idx_3806"></a><a name="%_idx_3808"></a>Algol 60's <em>call-by-name</em>
parameter-passing method.  The use of this mechanism to implement
streams was first described by <a name="%_idx_3810"></a>Landin (1965).  Delayed evaluation for
streams was introduced into Lisp by <a name="%_idx_3812"></a><a name="%_idx_3814"></a>Friedman and Wise (1976). In their
implementation, <tt>cons</tt> always delays evaluating its arguments, so
that lists automatically behave as streams.  The memoizing
optimization is also known as <a name="%_idx_3816"></a><a name="%_idx_3818"></a><a name="%_idx_3820"></a><a name="%_idx_3822"></a><em>call-by-need</em>.  The Algol community
would refer to our original delayed objects as <em>call-by-name
thunks</em> and to the optimized versions as <em>call-by-need thunks</em>.
</p>

<p class="trans" lang="ja">
本節で述べた以外にも、可能なストリームの実装が多くある。
遅延評価——ストリームを実用的なものとするための鍵である——は、Algol 60の<em>名前による呼び出し</em>によるパラメタ渡しの方法に内在するものである。
ストリームを実装するためにこの仕組みを使うことは、Landin (1965) により最初に記述された。
ストリームのための遅延評価は、Friedman and Wise (1976) によりLispに導入された。
かれらの実装では、<tt>cons</tt> は常に、引数を評価することを遅らせており、その結果、リストは自動的にストリームとして振る舞う。
メモ化の最適化は、<em>必要による呼び出し</em>としても知られる。
Algol界だったら、私たちの元々の遅延オブジェクトのことを<em>名前による呼び出しのサンク</em>と呼んだことだろうし、最適化したバージョンのことは<em>必要による呼び出しのサンク</em>と呼んだことだろう。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_453" href="#call_footnote_Temp_453"><sup><small>59</small></sup></a> Exercises such as <a href="#%_thm_3.51">3.51</a> and <a href="#%_thm_3.52">3.52</a>
are valuable for testing our understanding of how <tt>delay</tt> works.
On the other hand, intermixing delayed evaluation with printing -- and,
even worse, with assignment -- is extremely confusing, and instructors
of courses on computer languages have traditionally tormented their
students with examination questions such as the ones in this section.
Needless to say, writing programs that depend on such subtleties is
<a name="%_idx_3828"></a>odious programming style.  Part of the power of stream processing is
that it lets us ignore the order in which events actually happen in
our programs.  Unfortunately, this is precisely what we cannot afford
to do in the presence of assignment, which forces us to be concerned
with time and change.
</p>

<p class="trans" lang="ja">
練習問題<a href="#%_thm_3.51">3.51</a>や練習問題<a href="#%_thm_3.52">3.52</a>のような練習問題は、<tt>delay</tt> がどのように動作するか、ということについての、私たちの理解を試す役に立つ。
一方、遅延評価を印字と混ぜこぜにすること——そして、さらに悪いことには、<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>と混ぜこぜにすること——は、とても混乱を招くものだし、コンピュータ言語についての課程の指導者は、伝統的に、本節にあるような試験問題で学生をひどく苦しめてきた。
言うまでもなく、そうした微妙さに依存するプログラムを書くことは、不愉快極まりないプログラミングの流儀である。
ストリーム処理の能力の一部は、<!--自分のプログラムにおいて出来事が実際に起こる順序を、ストリーム処理は私たちに無視させてくれる、--><!--ストリーム処理が私たちに、自分のプログラムにおいて出来事が実際に起こる順序を無視させてくれる、-->ストリーム処理のおかげで私たちが、自分のプログラムにおいて出来事が実際に起こる順序を無視できる、という点なのだ。
あいにく、これはまさに、<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>——私たちを無理やり時間と変化に注意を向けるようにさせるもの——があると出来ないことなのだ。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_455" href="#call_footnote_Temp_455"><sup><small>60</small></sup></a> Eratosthenes, a third-century <font size=-2>B</font>.<font size=-2>C</font>.
<a name="%_idx_3846"></a><a name="%_idx_3848"></a>Alexandrian Greek philosopher, is famous for giving the first accurate
estimate of the circumference of the Earth, which he computed by
observing shadows cast at noon on the day of the summer solstice.
Eratosthenes's sieve method, although ancient, has formed the basis
for special-purpose hardware ``sieves'' that, until recently, were the
most powerful tools in existence for locating large primes.  Since the
70s, however, these methods have been superseded by outgrowths of the
<a name="%_idx_3850"></a>probabilistic techniques discussed in section <a href="11_sec1_2.html#%_sec_1.2.6">1.2.6</a>.

</p>

<p class="trans" lang="ja">
エラトステネス——紀元前3世紀のアレクサンドリアのギリシャ人哲学者——は、地球の周囲の最初の正確な推定値——これを彼は、夏至の日の正午に投げかけられる影を観察することで、計算した——を与えたことで、有名である。
最近までは大きな素数を突き止めるための現存する最も強力な手段であった、「篩」という特殊用途のハードウェアの基礎を、エラトステネスの篩の手法は、旧くはあるものの、形づくってきたのだ。
しかし、70年代から、これらの方法は、<a href="11_sec1_2.html#%_sec_1.2.6">1.2.6</a>節で議論した確率的技法に取って代わられた。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_456" href="#call_footnote_Temp_456"><sup><small>61</small></sup></a> We have named these figures after <a name="%_idx_3858"></a>Peter Henderson, who
was the first person to show us diagrams of this sort as a way of
thinking about stream processing.  Each solid line represents a stream
of values being transmitted.  The dashed line from the <tt>car</tt> to
the <tt>cons</tt> and the <tt>filter</tt> indicates that this is a single
value rather than a stream.
</p>

<p class="trans" lang="ja">
ピーター・ヘンダーソン——この種の図を、ストリーム処理について考えるための方法として、最初に私たちに見せてくれた人——にちなんで、これらの図を名づけた。
各実線は、送信される値のストリームを表している。
 <tt>car</tt> から <tt>cons</tt> と <tt>filter</tt> への破線は、これがストリームと言うよりむしろ単一の値である、ということを示している。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_458" href="#call_footnote_Temp_458"><sup><small>62</small></sup></a> This uses the generalized version
of <tt>stream-map</tt> from exercise <a href="#%_thm_3.50">3.50</a>.
</p>

<p class="trans" lang="ja">
これは、練習問題<a href="#%_thm_3.50">3.50</a>での、一般化されたバージョンの  <tt>stream-map</tt> を使っている。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_459" href="#call_footnote_Temp_459"><sup><small>63</small></sup></a> This last point is
very subtle and relies on the fact that <em>p</em><sub><em>n</em>+1</sub> <u>&lt;</u> <em>p</em><sub><em>n</em></sub><sup>2</sup>.
(Here, <em>p</em><sub><em>k</em></sub> denotes the <em>k</em>th prime.)  Estimates such as these are
very difficult to establish.  The ancient proof by <a name="%_idx_3876"></a>Euclid that there
are an infinite number of primes shows that <em>p</em><sub><em>n</em>+1</sub><u>&lt;</u> <em>p</em><sub>1</sub> <em>p</em><sub>2</sub> 
<tt>&middot;&middot;&middot;</tt>   <em>p</em><sub><em>n</em></sub>  + 1, and no substantially better result was proved
until 1851, when the Russian mathematician P. L. Chebyshev established
<a name="%_idx_3878"></a><a name="%_idx_3880"></a><a name="%_idx_3882"></a><a name="%_idx_3884"></a>that <em>p</em><sub><em>n</em>+1</sub><u>&lt;</u> 2<em>p</em><sub><em>n</em></sub> for all <em>n</em>.  This result, originally
conjectured in 1845, is known as <em>Bertrand's hypothesis</em>.  A proof
can be found in section 22.3 of Hardy and Wright 1960.
</p>

<p class="trans" lang="ja">
この最後の点は、非常に微妙であり、
<span class="math"><em class="en">p<sub>n+1</sub></em> &le; <em class="en">p<sub>n</sub><sup>2</sup></em></span>
という事実に頼っている。
(ここで <em class="en">p<sub>k</sub></em> は <em class="en">k</em> 番目の素数である。)
このような見積もりは、立証するのがとても難しい。
無限個の素数が存在するのだという、ユークリッドによる古代の証明は、
<span class="math"><em class="en">p<sub>n+1</sub></em> &le; 
<em class="en">p</em><sub>1</sub> <em class="en">p</em><sub>2</sub> 
&hellip;
<em class="en">p<sub>n</sub></em>  + 1</span>
ということを示しており、1851年——ロシアの数学者の P. L. チェビシェフが、すべての <em class="en">n</em> について <span class="math"><em class="en">p<sub>n+1</sub></em> &le; 2<em class="en">p<sub>n</sub></em></span> だと立証した——までは、実質的にこれより良い結果は証明されていなかった。
この結果は、もともとは1845年に推測されていたもので、<em>バートランドの仮説</em>として知られている。
Hardy and Wright 1960 の22.3節に、証明を見出すことができる。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_465" href="#call_footnote_Temp_465"><sup><small>64</small></sup></a> This exercise shows how call-by-need is closely related to
<a name="%_idx_3902"></a><a name="%_idx_3904"></a>ordinary memoization as described in exercise <a href="22_sec3_3.html#%_thm_3.27">3.27</a>.
In that exercise, we used assignment to explicitly construct a local
table.  Our call-by-need stream optimization effectively constructs
such a table automatically, storing values in the previously forced
parts of the stream.
</p>

<p class="trans" lang="ja">
この練習問題は、必要による呼び出しが、練習問題<a href="22_sec3_3.html#%_thm_3.27">3.27</a>で説明したような普通のメモ化と、どのようにして密接に関連づけられるのか、ということを示している。
練習問題<a href="22_sec3_3.html#%_thm_3.27">3.27</a>では、局所的な表を明示的に構築するために、<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>を使った。
私たちの、必要による呼び出し式のストリーム最適化は、効果的に、そのような表を自動的に構築し、ストリームのうちで以前に<ruby><rb>強制</rb><rp> (</rp><rt><tt>force</tt></rt><rp>) </rp></ruby>された部分の値を格納する。

</p>

<p class="orig" lang="en"><a name="footnote_Temp_472" href="#call_footnote_Temp_472"><sup><small>65</small></sup></a> We can't use <tt>let</tt> to bind the local variable
<tt>guesses</tt>, because the value of <tt>guesses</tt> depends on <tt>guesses</tt> itself.  Exercise <a href="#%_thm_3.63">3.63</a> addresses why
we want a local variable here.
</p>

<p class="trans" lang="ja">
<tt>guesses</tt> という局所変数を束縛するために <tt>let</tt> を使うことはできない。なぜなら、<tt>guesses</tt> の値は、<tt>guesses</tt> 自体に依存するからである。
練習問題<a href="#%_thm_3.63">3.63</a>は、なぜ私たちがここで局所変数を欲しているのか、ということに取り組んでいる。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_477" href="#call_footnote_Temp_477"><sup><small>66</small></sup></a> As in section <a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a>,
we represent a pair of integers as a list rather than a Lisp pair.
</p>

<p class="trans" lang="ja">
<a href="15_sec2_2.html#%_sec_2.2.3">2.2.3</a>節でそうしたのと同様に、整数同士の対を、Lispの対ではなく、むしろリストとして、表現している。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_478" href="#call_footnote_Temp_478"><sup><small>67</small></sup></a> See exercise <a href="#%_thm_3.68">3.68</a> for some insight
into why we chose this decomposition.
</p>

<p class="trans" lang="ja">
なぜ私たちがこのような分解を選ぶのか、ということに対する、いくばくかの洞察のためには、練習問題<a href="#%_thm_3.68">3.68</a>を参照せよ。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_479" href="#call_footnote_Temp_479"><sup><small>68</small></sup></a> The precise statement of the
required property on the order of combination is as follows: There
should be a function <em>f</em> of two arguments such that the pair
corresponding to element <em>i</em> of the first stream and element <em>j</em> of
the second stream will appear as element number <em>f</em>(<em>i</em>,<em>j</em>) of the output
stream.  The trick of using <tt>interleave</tt> to accomplish this was
shown to us by <a name="%_idx_3996"></a>David Turner, who employed it in the language <a name="%_idx_3998"></a>KRC
(Turner 1981).
</p>

<p class="trans" lang="ja">
結合の順序について要求される性質の正確な陳述は、以下の通りである。
すなわち、第1のストリームの <em class="en">i</em> という要素と第2のストリームの <em class="en">j</em> という要素に対応する対が、出力ストリームの 
<em class="en">f</em>(<em class="en">i</em>, <em class="en">j</em>) 
という要素番号として現れるように、2引数の <em class="en">f</em> という関数が、存在するはずである。
これを達成するために <tt>interleave</tt> を使うという技は、デイビッド・ターナ——この技をKRCという言語で使った人——が私たちに示してくれた (Turner 1981)。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_485" href="#call_footnote_Temp_485"><sup><small>69</small></sup></a> We will require that the weighting function be such that
the weight of a pair increases as we move out along a row or down
along a column of the array of pairs.
</p>

<p class="trans" lang="ja">
重みづけ関数とは、対の配列の行に沿って外へ、あるいは、列に沿って下へ、と動くにつれて、対の重みが増すようなものである、ということを、私たちは要請することになるだろう。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_487" href="#call_footnote_Temp_487"><sup><small>70</small></sup></a> To quote from G. H. Hardy's obituary of
<a name="%_idx_4012"></a><a name="%_idx_4014"></a><a name="%_idx_4016"></a>Ramanujan (Hardy 1921): ``It was Mr. Littlewood (I believe) who remarked that
`every positive integer was one of his friends.'  I remember once
going to see him when he was lying ill at Putney.  I had ridden in
taxi-cab No. 1729, and remarked that the number seemed to me a rather
dull one, and that I hoped it was not an unfavorable omen.  `No,' he
replied, `it is a very interesting number; it is the smallest number
expressible as the sum of two cubes in two different ways.' ''
The trick of using weighted pairs to generate the Ramanujan numbers
was shown to us by Charles Leiserson.
</p>

<p class="trans" lang="ja">
G. H. ハーディによるラマヌジャンの死亡記事 (Hardy 1921) から引用すると、
「『どの正整数も彼の友達の一人だ』と述べたのは、(私が信じるところでは) リトルウッド氏であった。パットニーでラマヌジャン氏が病気で寝ていたときに、彼に一度会いに行ったことを、私は覚えている。私は、番号が1729のタクシーに乗って、そして、こう述べた——この数は自分にとってはかなり退屈な数のように見えるんだが、これが良くない予兆ではないことを望むよ、と。彼は、『違います。これはとても興味深い数ですよ。これは、二つの異なる方法で二つの立法数の和として表現可能な、最小の数ですよ』と返答した。」とのこと。
重みづけされた対を、ラマヌジャン数を生成するために使う、という技は、チャールズ・ライザースンが私たちに示してくれた。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_494" href="#call_footnote_Temp_494"><sup><small>71</small></sup></a> This procedure is not guaranteed to work in all Scheme
implementations, although for any implementation there is a simple
variation that will work.  The problem has to do with subtle
differences in the ways that Scheme implementations handle internal
definitions.  (See section <a href="26_sec4_1.html#%_sec_4.1.6">4.1.6</a>.)
</p>

<p class="trans" lang="ja">
この手続きは、すべてのScheme処理系でうまく動くとは保証されていない——もっとも、どの処理系についても、うまく動くであろう簡単な変種が存在するのではあるが。
この問題は、Scheme処理系が内部定義を扱う方法における微妙な差異と関連している。
(<a href="26_sec4_1.html#%_sec_4.1.6">4.1.6</a>節を参照。)
</p>

<p class="orig" lang="en"><a name="footnote_Temp_500" href="#call_footnote_Temp_500"><sup><small>72</small></sup></a> This is a small reflection, in Lisp, of the difficulties
that conventional strongly typed languages such as <a name="%_idx_4096"></a><a name="%_idx_4098"></a><a name="%_idx_4100"></a><a name="%_idx_4102"></a><a name="%_idx_4104"></a>Pascal have in
coping with higher-order procedures.  In such languages, the
programmer must specify the data types of the arguments and the result
of each procedure: number, logical value, sequence, and so on.
Consequently, we could not express an abstraction such as ``map a
given procedure <tt>proc</tt> over all the elements in a sequence'' by a
single higher-order procedure such as <tt>stream-map</tt>.  Rather, we
would need a different mapping procedure for each different
combination of argument and result data types that might be specified
for a <tt>proc</tt>.  Maintaining a practical notion of ``data type'' in
the presence of higher-order procedures raises many difficult issues.
One way of dealing with this problem is illustrated by the language ML
<a name="%_idx_4106"></a><a name="%_idx_4108"></a><a name="%_idx_4110"></a><a name="%_idx_4112"></a>(Gordon, Milner, and Wadsworth 1979), whose ``polymorphic data types''
include templates for higher-order transformations between data types.
Moreover, data types for most procedures in ML are never explicitly
declared by the programmer.  Instead, ML includes a <a name="%_idx_4114"></a><em>type-inferencing</em> mechanism that uses information in the environment
to deduce the data types for newly defined procedures.
</p>

<p class="trans" lang="ja">
これは、Pascalのような従来の強力に型付けされている言語が高階手続きに対処する際に抱える困難の、Lispにおけるささやかな反映である。
そうした言語では、プログラマは、各手続きの引数と結果のデータ型——数、論理値、列、などなど——を指定せねばならない。
その結果、「列の中のすべての要素に対して、与えられた <tt>proc</tt> という手続きを適用して写像する」のような抽象化を、<tt>stream-map</tt> のような単一の高階手続きによって表現することができなかった。
むしろ、<tt>proc</tt> に対して指定され得る引数と結果のデータ型の、異なる組み合わせそれぞれに対して、異なる写像手続きを必要としただろう。
高階手続きの存在するところで、「データ型」についての実践的な概念を維持することは、多くの難しい問題を提起する。
この問題を扱う一つの方法は、ML言語により例示されていて (Gordon, Milner, and Wadsworth 1979)、ML言語の「<ruby><rb>多態的</rb><rp> (</rp><rt>ポリモーフィック</rt><rp>) </rp></ruby>データ型」は、データ型同士の間の高階変換のためのテンプレートを含んでいる。
さらに、MLのほとんどの手続きのデータ型は、決して、プログラマにより明示的に宣言されることはない。
代わりに、MLは、環境内の情報を使って、新たに定義された手続きについての型を演繹する、<em>型推論</em>の仕組みを備えている。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_504" href="#call_footnote_Temp_504"><sup><small>73</small></sup></a> Similarly in physics, when we observe a moving particle, we
say that the position (state) of the particle is changing.  However,
from the perspective of the particle's <a name="%_idx_4156"></a>world line in space-time there
is no change involved.
</p>

<p class="trans" lang="ja">
物理学と同様に、動く粒子を観察しているとき、私たちは、その粒子の位置 (状態) が変化しているところである、と言う。
しかし、時空間における粒子の世界線という観点からは、何の変化も伴っていない。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_505" href="#call_footnote_Temp_505"><sup><small>74</small></sup></a> John Backus, the inventor of Fortran, gave high
<a name="%_idx_4166"></a><a name="%_idx_4168"></a><a name="%_idx_4170"></a><a name="%_idx_4172"></a><a name="%_idx_4174"></a>visibility to functional programming when he was awarded
the ACM Turing award in 1978.  His acceptance speech (Backus 1978)
strongly advocated the functional approach.  A good overview of
functional programming is given in Henderson 1980 and in Darlington,
Henderson, and Turner 1982.
</p>

<p class="trans" lang="ja">
ジョン・バッカス——Fortranの発明者——は、1978年にACMのチューリング賞を受賞したときに、関数型プログラミングに対する高度な視野を与えた。
彼の受賞スピーチ (Backus 1978) は、関数型の手法を強く主張するものであった。
関数型プログラミングについての良い概論は、Henderson 1980 や、Darlington,
Henderson, and Turner 1982 の中に与えられている。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_506" href="#call_footnote_Temp_506"><sup><small>75</small></sup></a> Observe that, for any two streams, there is in general more than one
<a name="%_idx_4180"></a><a name="%_idx_4182"></a>acceptable order of interleaving.  Thus, technically, ``merge'' is a
relation rather than a function -- the answer is not a deterministic
function of the inputs.  We already mentioned
(footnote <a href="23_sec3_4.html#footnote_Temp_411">39</a>) that nondeterminism is
essential when dealing with concurrency.  The merge relation
illustrates the same essential nondeterminism, from the functional
perspective.  In section <a href="28_sec4_3.html#%_sec_4.3">4.3</a>, we
will look at nondeterminism from yet another point of view.
</p>

<p class="trans" lang="ja">
任意の二つのストリームに対して、お互いを間に挟み込む許容可能な順序が、一般には一つよりも多く存在する、ということに気づいてほしい。
よって、技術的には、「合併」は関数であるというよりも関係なのである——つまり、答えは、入力の決定論的関数ではないのだ。
並行性を取り扱う場合には非決定論が本質的である、ということを、私たちは既に述べた (脚注<a href="23_sec3_4.html#footnote_Temp_411">39</a>)。
合併関係は、同じ本質的非決定論を、関数型の観点から例示している。
<a href="28_sec4_3.html#%_sec_4.3">4.3</a>節では、さらに別の観点から非決定論についてよく見ることにしよう。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_507" href="#call_footnote_Temp_507"><sup><small>76</small></sup></a> The object model approximates the world by
dividing it into separate pieces.  The functional model does not
modularize along object boundaries.  The object model is useful when
<a name="%_idx_4184"></a>the unshared state of the ``objects'' is much larger than the state
that they share.  An example of a place where the object viewpoint
fails is <a name="%_idx_4186"></a>quantum
mechanics, where thinking of things as individual particles leads to
paradoxes and confusions.  Unifying the object view with the
functional view may have little to do with programming, but rather
with fundamental epistemological issues.
</p>

<p class="trans" lang="ja">
オブジェクトモデルは、世界を別々の部分へと分割することにより、世界を近似する。
関数型のモデルは、オブジェクト境界に沿ってモジュール化することはない。
「オブジェクト」の非共有状態が、それらオブジェクトが共有する状態よりも、遥かに多量である場合には、オブジェクトモデルは有用である。
オブジェクトの視点がうまくいかない場所の例は、量子力学であり、そこでは、物事を個別の粒子として考えることが矛盾や混乱につながる。
オブジェクト的な見方と関数型の見方を統一することは、プログラミングとはほとんど関係ないかもしれず、むしろ、根本的な認識論的問題と関係があるかもしれない。
</p>

</div>

</body>
</html>
