<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<link rel="stylesheet" href="sicp.css" type="text/css">
	<base target="_top">
	<title>SICP私訳: 2.4 抽象的データに対する複数の表現</title>
    <link rel="canonical" href="https://piyo-ko.github.io/SICP/17_sec2_4.html" />
</head>

<body>

<div class="idx-bar">
<nav>
<a href="https://twitter.com/share" class="twitter-share-button" data-lang="ja">ツイート</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
<span class="status">推敲待ち</span>
[
<a href="00_cover.html">先頭へ</a> |
<a href="16_sec2_3.html">前へ</a> |
<a href="18_sec2_5.html">次へ</a> | 
<a href="04_toc.html#%_toc_start">目次</a> |
<a href="38_index.html#%_index_start">索引</a>
] [<a href="99_about.html">この対訳版について</a> | <a href="../index.html">ホーム</a>]
[
§<a href="#%_sec_2.4">2.4</a>
🎨<a href="#%_fig_2.19">2.19</a>
§<a href="#%_sec_2.4.1">2.4.1</a>
🎨<a href="#%_fig_2.20">2.20</a>
§<a href="#%_sec_2.4.2">2.4.2</a>
🎨<a href="#%_fig_2.21">2.21</a>
§<a href="#%_sec_2.4.3">2.4.3</a>
🎨<a href="#%_fig_2.22">2.22</a>
📝<a href="#%_thm_2.73">2.73</a>
📝<a href="#%_thm_2.74">2.74</a>
📚<a href="#%_sec_Temp_275">&hellip;</a>
📝<a href="#%_thm_2.75">2.75</a>
📝<a href="#%_thm_2.76">2.76</a>
<a href="#footnotes">脚注</a>
]
</nav>
</div>

<div class="main-txt">

<a name="%_sec_2.4"></a>
<h2 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_2.4">2.4  Multiple Representations for Abstract Data</a></h2>
<h2 class="trans" lang="ja">2.4 抽象的データに対する複数の表現</h2>

<p class="orig" lang="en">
<a name="%_idx_2286"></a><a name="%_idx_2288"></a>
We have introduced data abstraction, a methodology for structuring
systems in such a way that much of a program can be specified
independent of the choices involved in implementing the data objects
that the program manipulates.  For example, we saw in
section <a href="14_sec2_1.html#%_sec_2.1.1">2.1.1</a> how to separate the task of designing a
program that uses rational numbers from the task of implementing
rational numbers in terms of the computer language's primitive
mechanisms for constructing compound data.  The key idea was to erect
an abstraction barrier -- in this case, the selectors and constructors
for rational numbers (<tt>make-rat</tt>, <tt>numer</tt>, <tt>denom</tt>) -- that
isolates the way rational numbers are used from their underlying
representation in terms of list structure.  A similar abstraction
barrier isolates the details of the procedures that perform rational
arithmetic (<tt>add-rat</tt>, <tt>sub-rat</tt>, <tt>mul-rat</tt>, and <tt>div-rat</tt>) from the ``higher-level'' procedures that use rational
numbers.  The resulting program has the structure shown in
figure <a href="14_sec2_1.html#%_fig_2.1">2.1</a>.</p>

<p class="trans" lang="ja">
私たちは、データ抽象化を導入した——つまり、プログラムが操作するデータオブジェクトを実装するのに伴う選択とは関わりなく、プログラムの大部分を細かく規定できるような方法で、システムを構造化するための方法論を、導入した。
たとえば、複合的データを構築するための、コンピュータ言語の原始的な仕組みを使って有理数を実装するという課題から、有理数を使うプログラムを設計するという課題を切り離す方法を、<a href="14_sec2_1.html#%_sec_2.1.1">2.1.1</a>節で見た。
鍵となる考え方は、有理数の基礎をなしている、リスト構造を使った表現から、有理数の使われ方を隔離する、抽象化の防壁——この場合だと、有理数用のセレクタとコンストラクタ (<tt>make-rat</tt> と <tt>numer</tt> と <tt>denom</tt>) ——を築くことだった。
同様の抽象化の防壁が、有理数の算術演算を実行する手続き (<tt>add-rat</tt> と <tt>sub-rat</tt> と <tt>mul-rat</tt> と <tt>div-rat</tt>) の詳細を、有理数を使用する「より高い水準の」手続きから、隔離している。
結果として生じるプログラムは、図<a href="14_sec2_1.html#%_fig_2.1">2.1</a>に示す構造を有する。
</p>

<p class="orig" lang="en">
These data-abstraction barriers are powerful tools for controlling
complexity.  By isolating the underlying representations of data
objects, we can divide the task of designing a large program into
smaller tasks that can be performed separately.  But this kind of data
abstraction is not yet powerful enough, because it may not always make
sense to speak of ``the underlying representation'' for a data object.</p>

<p class="trans" lang="ja">
これらのデータ抽象化の防壁は、複雑さを抑えるための強力な手立てである。
データオブジェクトの、根底にある表現を隔離することで、大きなプログラムを設計するという課題を、別々に実行できる、より小さないくつかの課題へと、分割できるのだ。
しかし、この種のデータ抽象化は、まだ十分に強力ではない。というのも、データオブジェクトの「根底にある表現」について語ることが、常に意味を持つとは限らないからだ。
</p>

<p class="orig" lang="en">
For one thing, there might be more than one useful representation for
a data object, and we might like to design systems that can deal with
multiple representations.  To take a simple example, complex numbers
may be represented in two almost equivalent ways: in rectangular form
(real and imaginary parts) and in polar form (magnitude and angle).
Sometimes rectangular form is more appropriate and sometimes polar
form is more appropriate.  Indeed, it is perfectly plausible to
imagine a system in which complex numbers are represented in both
ways, and in which the procedures for manipulating complex numbers work
with either representation.</p>

<p class="trans" lang="ja">
理由の一つは、あるデータオブジェクトのための有用な表現が、一つより多く存在するかもしれず、そのため、複数の表現を扱えるシステムを設計したい、と私たちが思うかもしれない、ということである。
簡単な例をとると、複素数は、二つのほとんど等価な方法で——つまり、直交形式 (実部と虚部) と極形式 (大きさと角度) で——表現されうる。
ときには、直交形式の方がより適切であり、ときには、極形式の方がより適切である。
複素数が双方のやり方で表現されていて、かつ、複素数を操作するための手続きが、どちらの表現を使っても動作する、といったシステムを想像することは、実際、完璧に尤もらしいことである。
</p>

<p class="orig" lang="en">
More importantly, programming systems are often designed by many
people working over extended periods of time, subject to requirements
that change over time.  In such an environment, it is simply not
possible for everyone to agree in advance on choices of data
representation.  So in addition to the data-abstraction barriers that
isolate representation from use, we need abstraction barriers that
isolate different design choices from each other and permit different
choices to coexist in a single program.  Furthermore, since large
programs are often created by combining pre-existing modules that were
designed in isolation, we need conventions that permit programmers to
incorporate modules into larger systems <a name="%_idx_2290"></a><em>additively</em>, that is,
without having to redesign or reimplement these modules.</p>

<p class="trans" lang="ja">
さらに重要なことには、プログラミング・システムは、しばしば、長期間にわたって働く大勢の人たちによって、設計されるのだ——しかも、時間とともに変化する要件に従って。
そんな環境では、全員が前もってデータ表現の選択について同意することは、単純に不可能だ。
だから、使用から表現を隔離するデータ抽象化の防壁に加えて、さらに、異なる設計の選択肢同士をお互いから隔離しつつも異なる選択肢が単一のプログラムの中に共存することを許すような抽象化の防壁も、必要である。
さらに、大きなプログラムはしばしば、隔離されて設計された既存のモジュール同士を組み合わせることによって作成されるため、プログラマがモジュールをより大きなシステムに<em>加法的に</em>——つまりそれらのモジュールを設計しなおしたり、あるいは、実装しなおしたりする必要なしに——組み込むこむことを許すような習慣も必要だ。
</p>

<p class="orig" lang="en">
In this section, we will learn how to cope with data that may be
represented in different ways by different parts of a program.  This
requires constructing <a name="%_idx_2292"></a><a name="%_idx_2294"></a><em>generic procedures</em> -- procedures that can
operate on data that may be represented in more than one way.  Our
main technique for building generic procedures will be to work in terms
of data objects that have <a name="%_idx_2296"></a><em>type tags</em>, that is, data objects
that include explicit information about how they are to be processed.
We will also discuss <a name="%_idx_2298"></a><em>data-directed</em> programming, a powerful and
convenient implementation strategy for additively assembling systems
with generic operations.</p>

<p class="trans" lang="ja">
本節では、プログラムの異なる部分により異なる方法で表現される可能性のあるデータへの対処の仕方を学ぼう。
これには、<em>総称的手続き</em>——ひとつより多い方法で表現される可能性のあるデータ上で動作できる手続き——を構築することが必要だ。
総称的手続きを構築するための主要な技法は、<em>型タグ</em>のあるデータオブジェクト——つまり、どう処理すべきものなのかについての明示的情報を含むデータオブジェクト——を使って作業することであろう。
<em>データ指向</em>プログラミング——総称的な演算を用いてシステムを加法的に組み立てるための、強力で便利な実装戦略——についても、議論しよう。
</p>

<p class="orig" lang="en">
We begin with the simple complex-number example. We will see how
type tags and data-directed style enable us to design separate
rectangular and polar representations for complex numbers while
maintaining the notion of an abstract ``complex-number'' data object.
<a name="%_idx_2300"></a><a name="%_idx_2302"></a>We will accomplish this by defining arithmetic procedures for complex
numbers (<tt>add-complex</tt>, <tt>sub-complex</tt>, <tt>mul-complex</tt>, and
<tt>div-complex</tt>) in terms of generic selectors that access parts of
a complex number independent of how the number is represented.  The
resulting complex-number system, as shown in
figure <a href="#%_fig_2.19">2.19</a>, contains two different kinds of
<a name="%_idx_2304"></a>abstraction barriers.  The ``horizontal'' abstraction barriers play
the same role as the ones in
figure <a href="14_sec2_1.html#%_fig_2.1">2.1</a>.  They isolate ``higher-level''
operations from ``lower-level'' representations.  In addition, there
is a ``vertical'' barrier that gives us the ability to separately
design and install alternative representations.</p>

<p class="trans" lang="ja">
単純な複素数の例から始める。
抽象的な「複素数の」データオブジェクトという概念を保ちながらも、複素数の、直交表現と極表現という別々の表現を設計することが、型タグとデータ指向スタイルとによって、いかにして可能となるのか、ということを見ていこう。
その数がどう表現されているのかということには関係なく、複素数の構成部分にアクセスするような、総称的なセレクタを使って、複素数用の算術手続き (<tt>add-complex</tt> と <tt>sub-complex</tt> と <tt>mul-complex</tt> と <tt>div-complex</tt>) を定義することにより、以上のような設計を達成しよう。
結果としてできあがる複素数のシステムは、図<a href="#%_fig_2.19">2.19</a>に示すように、二種類の異なる抽象化の防壁を含む。
「横方向の」抽象化の防壁は、図<a href="14_sec2_1.html#%_fig_2.1">2.1</a>の者と同様の役目を果たす。
これらは、「低レベルの」表現から、「高レベルの」演算を隔離する。
さらに、代替表現同士を別々に設計してインストールすることを可能にしてくれる、「縦方向の」防壁がある。
</p>

<figure>
<a name="%_fig_2.19"></a>
<img src="ch2-Z-G-54.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 2.19:</b>  Data-abstraction barriers in the complex-number system.</figcaption>
<figcaption class="trans" lang="ja"><b>図2.19:</b> 複素数システムにおける、データ抽象化の防壁</figcaption>
</figure>

<p class="orig" lang="en">
In section <a href="18_sec2_5.html#%_sec_2.5">2.5</a> we will show how to use
type tags and data-directed style to develop a generic arithmetic
package.  This provides procedures (<tt>add</tt>, <tt>mul</tt>, and so on)
that can be used to manipulate all sorts of ``numbers'' and can be
easily extended when a new kind of number is needed.
In section <a href="18_sec2_5.html#%_sec_2.5.3">2.5.3</a>, we'll show how to use generic
arithmetic in a system that performs symbolic algebra.</p>

<p class="trans" lang="ja">
総称的算術パッケージを開発するために、どのようにして型タグとデータ指向スタイルを使うのか、ということを<a href="18_sec2_5.html#%_sec_2.5">2.5</a>節で示そう。
このときに、あらゆる種類の「数」を操作するのに使えて、かつ、新たな種類の数が必要になったら簡単に拡張できるような、諸手続き (<tt>add</tt> や <tt>mul</tt> など) を示す。
<a href="18_sec2_5.html#%_sec_2.5.3">2.5.3</a>節では、記号代数を実行するシステムにおいてどのように総称的算術を使うのか、ということを示そう。
</p>

<a name="%_sec_2.4.1"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_2.4.1">2.4.1  Representations for Complex Numbers</a></h3>
<h3 class="trans" lang="ja">2.4.1 複素数の表現</h3>

<p class="orig" lang="en">
<a name="%_idx_2306"></a>We will develop a system that performs arithmetic operations on
complex numbers as a simple but unrealistic example of a program that
uses generic operations.  We begin by discussing two plausible
representations for complex numbers as ordered pairs: rectangular form
(real part and imaginary part) and polar form (magnitude and
angle).<a name="call_footnote_Temp_268" href="#footnote_Temp_268"><sup><small>43</small></sup></a>  Section <a href="#%_sec_2.4.2">2.4.2</a>
will show how both representations can be made to coexist in a single
system through the use of type tags and generic operations.</p>

<p class="trans" lang="ja">
総称的演算を使うプログラムの、簡潔だが非現実的な例として、複素数上の算術演算を行うシステムを開発しよう。
順序付きの対としての、複素数の二つのもっともらしい表現——直交形式 (実部と虚部) と、極形式 (大きさと角度) ——について議論することから始める<a href="#footnote_Temp_268"><sup><small>43</small></sup></a>。
<a href="#%_sec_2.4.2">2.4.2</a>節では、型タグと総称的演算を使うことを通じて、双方の表現をどのようにして単一のシステム内に共存させられるのか、ということを示そう。
</p>

<p class="orig" lang="en">
Like rational numbers, complex numbers are naturally represented as
ordered pairs.  The set of complex numbers can be thought of as a
two-dimensional space with two orthogonal axes, the ``real'' axis and
the ``imaginary'' axis. (See figure <a href="#%_fig_2.20">2.20</a>.)  From
this point of view, the complex number <em>z</em> = <em>x</em> + <em>i</em><em>y</em> (where <em>i</em><sup>2</sup>  =  - 1)
can be thought of as the point in the plane whose real coordinate is <em>x</em> and whose
imaginary coordinate is <em>y</em>.  Addition of complex numbers reduces in
this representation to addition of coordinates:</p>

<p class="trans" lang="ja">
有理数と同様に、複素数は、当然に順序付きの対として表現される。
複素数の集合は、二つの直交する軸——つまり、「実」軸と「虚」軸——のある二次元空間だと見なせる。
(図<a href="#%_fig_2.20">2.20</a>を見よ。)
この観点からは、
<span class="math"><em class="en">z</em> = <em class="en">x</em> + <em class="en">i</em><em class="en">y</em></span>
という複素数 (ここで
<span class="math"><em class="en">i</em><sup>2</sup>  =  &minus;1</span> 
である) は、この平面における、実座標が <em class="en">x</em> で虚座標が <em class="en">y</em> の点である、と見なせる。
複素数同士の加算は、この表現では、座標同士の加算に帰着する。
</p>

<figure>
<img src="ch2-Z-G-55.gif" border="0"><br>
<img src="ch2-Z-G-56.gif" border="0">
</figure>


<p class="orig" lang="en">
When multiplying complex numbers, it is more natural to think in terms
of representing a complex number in polar form, as a magnitude and an
angle (<em>r</em> and <em>A</em> in figure <a href="#%_fig_2.20">2.20</a>).
The product of two complex numbers is the vector obtained by
stretching one complex number by the length of the other and then
rotating it through the angle of the other:</p>

<p class="trans" lang="ja">
複素数同士を掛けるときには、複素数を極形式で——大きさと角度 (図<a href="#%_fig_2.20">2.20</a>の <em class="en">r</em> と <em class="en">A</em>) として——表現することを考えるのが、より自然である。
二つの複素数の積は、一方の複素数を、他方の長さ倍に引き伸ばしてから、他方の角度のぶんだけ回転させることで得られる、ベクトルである。
</p>

<figure>
<img src="ch2-Z-G-57.gif" border="0"><br>
<img src="ch2-Z-G-58.gif" border="0">
</figure>

<p class="orig" lang="en">
Thus, there are two different representations for complex numbers,
which are appropriate for different operations.  Yet, from the
viewpoint of someone writing a program that uses complex numbers, the
principle of data abstraction suggests that all the operations for
manipulating complex numbers should be available regardless of which
representation is used by the computer.  For example, it is often
useful to be able to find the magnitude of a complex number that is
specified by rectangular coordinates.  Similarly, it is often useful
to be able to determine the real part of a complex number that is
specified by polar coordinates.</p>

<p class="trans" lang="ja">
このように、複素数には二つの異なる表現があり、それらは異なる演算に適している。
それでもやはり、複素数を使うプログラムを書く誰か、という観点からすると、複素数を操作するためのすべての演算は、コンピュータがどの表現を使っているのかに関係なく利用可能であるべきだ、ということを、データ抽象化の原則は示唆している。
たとえば、直交座標で指定された複素数の大きさを知ることができる、ということが有益な場合が、よくある。
同様に、極座標で指定された複素数の実部を特定できる、ということが有益な場合が、よくある。
</p>

<a name="%_fig_2.20"></a>
<figure>
<img src="ch2-Z-G-59.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 2.20:</b>  Complex numbers as points in the plane.</figcaption>
<figcaption class="trans" lang="ja"><b>図2.20:</b> 平面内の点としての複素数</figcaption>
</figure>

<p class="orig" lang="en">
To design such a system, we can follow the same <a name="%_idx_2310"></a>data-abstraction
strategy we followed in designing the rational-number package in
section <a href="14_sec2_1.html#%_sec_2.1.1">2.1.1</a>.  Assume that the operations on complex numbers are
implemented in terms of four selectors: <tt>real-part</tt>,
<tt>imag-part</tt>, <tt>magnitude</tt>, and <tt>angle</tt>.  Also assume that
we have two procedures for constructing complex numbers: <tt>make-from-real-imag</tt> returns a complex number with specified real and
imaginary parts, and <tt>make-from-mag-ang</tt> returns a complex number with
specified magnitude and angle.  These procedures have the property that,
for any complex number <tt>z</tt>, both</p>

<p class="trans" lang="ja">
そういうシステムを設計するために、私たちは、<a href="14_sec2_1.html#%_sec_2.1.1">2.1.1</a>節で有理数パッケージを設計する際にしたがったのと同じデータ抽象化戦略に、したがうことができる。
複素数上の演算が、四つのセレクタ——<tt>real-part</tt> と <tt>imag-part</tt> と <tt>magnitude</tt> と <tt>angle</tt>——を用いて実装される、と仮定せよ。
また、複素数を構築するための二つの手続きがある——すなわち、<tt>make-from-real-imag</tt> は、指定された実部と虚部を有する複素数を返し、<tt>make-from-mag-ang</tt> は、指定された大きさと角度を有する複素数を返す——と、仮定せよ。
これらの手続きには、任意の複素数 <tt>z</tt> に対して、以下の性質がある。すなわち、
</p>


<p class="lisp">(make-from-real-imag (real-part z) (imag-part z))</p>

<p class="orig" lang="en">and</p>

<p class="trans" lang="ja">
および
</p>

<p class="lisp">(make-from-mag-ang (magnitude z) (angle z))</p>

<p class="orig" lang="en">
produce complex numbers that are equal to <tt>z</tt>.
</p>

<p class="trans" lang="ja">
の双方とも、<tt>z</tt> に等しい複素数を作り出す。
</p>

<p class="orig" lang="en">
Using these constructors and selectors, we can implement
arithmetic on complex numbers using the ``abstract data'' specified by
the constructors and selectors, just as we did for rational numbers in
section <a href="14_sec2_1.html#%_sec_2.1.1">2.1.1</a>.  As shown in the formulas above, we can add and
subtract complex numbers in terms of real and imaginary parts while
multiplying and dividing complex numbers in terms of magnitudes and
angles:</p>

<p class="trans" lang="ja">
これらのコンストラクタとセレクタを使って、私たちは、コンストラクタとセレクタにより指定される「抽象的データ」を用いた複素数上の算術演算を、<a href="14_sec2_1.html#%_sec_2.1.1">2.1.1</a>節で有理数に対して行ったのとちょうど同じようにして、実装することができる。
上記の式に示したように、実部と虚部を使って複素数を足したり引いたりする一方で、大きさと角度を使って複素数を掛けたり割ったりすることが、可能である。
</p>

<p class="lisp"><a name="%_idx_2312"></a>(define (add-complex z1 z2)
  (make-from-real-imag (+ (real-part z1) (real-part z2))
                       (+ (imag-part z1) (imag-part z2))))
<a name="%_idx_2314"></a>(define (sub-complex z1 z2)
  (make-from-real-imag (- (real-part z1) (real-part z2))
                       (- (imag-part z1) (imag-part z2))))
<a name="%_idx_2316"></a>(define (mul-complex z1 z2)
  (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                     (+ (angle z1) (angle z2))))
<a name="%_idx_2318"></a>(define (div-complex z1 z2)
  (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                     (- (angle z1) (angle z2))))
</p>

<p class="orig" lang="en">
To complete the complex-number package, we must choose a
representation and we must implement the constructors and selectors in
terms of primitive numbers and primitive list structure.
There are two obvious ways to do this: We can represent a complex
number in ``rectangular form'' as a pair (real part, imaginary part)
or in ``polar form'' as a pair (magnitude, angle).  Which shall we
choose?</p>

<p class="trans" lang="ja">
複素数パッケージを完成させるには、表現を選ばねばならないし、原始的な数と原始的なリスト構造を使って、コンストラクタとセレクタを実装せねばならない。
これを行うには、二つの自明な方法がある——複素数を、「直交形式」で対 (実部と虚部) として表現すること、あるいは、「極形式」で対 (大きさと角度) として表現することが、可能である。
どちらを選ぶべきだろう?
</p>

<p class="orig" lang="en">
In order to make the different choices concrete, imagine that there
are two programmers, Ben Bitdiddle and Alyssa P. Hacker, who are
independently designing representations for the complex-number system.
<a name="%_idx_2320"></a>Ben chooses to represent complex numbers in rectangular form.  With
this choice, selecting the real and imaginary parts of a complex
number is straightforward, as is constructing a complex number with
given real and imaginary parts.  To find the magnitude and the angle,
or to construct a complex number with a given magnitude and angle, he
uses the trigonometric relations</p>

<p class="trans" lang="ja">
異なる選択肢を具体的にするために、ベン・ビットディドルとアリッサ・P・ハッカという、二人のプログラマがいて、二人は複素数システムのための表現を互いに無関係に設計している、と想像しよう。
ベンは、複素数を直交形式で表現することにする。
この選択では、複素数の実部と虚部を選ぶことは単純だ——与えられた実部と虚部を有する複素数を構築することが単純なのと同様に。
大きさと角度を知るには、あるいは、与えられた大きさと角度を有する複素数を構築するには、彼は、以下のような三角関数による関係を用いる。
</p>

<figure>
<img src="ch2-Z-G-60.gif" border="0"><br>
<img src="ch2-Z-G-61.gif" border="0">
</figure>

<p class="orig" lang="en">
which relate the real and imaginary parts (<em>x</em>, <em>y</em>) to the magnitude
and the angle (<em>r</em>, <em>A</em>).<a name="call_footnote_Temp_269" href="#footnote_Temp_269"><sup><small>44</small></sup></a>  Ben's representation is
therefore given by the following selectors and constructors:
</p>

<p class="trans" lang="ja">
——これらは、実部と虚部 (<em class="en">x</em>, <em class="en">y</em>) を、大きさと角度 (<em class="en">r</em>, <em class="en">A</em>) に関連づける<a href="#footnote_Temp_269"><sup><small>44</small></sup></a>。
したがって、ベンの表現は、以下のセレクタとコンストラクタにより与えられる。
</p>

<p class="lisp"><a name="%_idx_2328"></a>(define (real-part z) (car z))
<a name="%_idx_2330"></a>(define (imag-part z) (cdr z))
<a name="%_idx_2332"></a>(define (magnitude z)
  (sqrt (+ (square (real-part z)) (square (imag-part z)))))
<a name="%_idx_2334"></a>(define (angle z)
  (atan (imag-part z) (real-part z)))
<a name="%_idx_2336"></a>(define (make-from-real-imag x y) (cons x y))
<a name="%_idx_2338"></a>(define (make-from-mag-ang r a) 
  (cons (* r (cos a)) (* r (sin a))))
</p>

<p class="orig" lang="en">
<a name="%_idx_2340"></a>Alyssa, in contrast, chooses to represent complex numbers in polar
form.  For her, selecting the magnitude and angle is straightforward,
but she has to use the <a name="%_idx_2342"></a>trigonometric relations to obtain the real and
imaginary parts.  Alyssa's representation is:
</p>


<p class="trans" lang="ja">
それに対してアリッサは、極形式で複素数を表現することにする。
彼女にとって、大きさと角度を選ぶことは単純だが、実部と虚部を得るには三角関数の関係を使わなくてはならない。
アリッサの表現は以下のとおりだ。
</p>

<p class="lisp"><a name="%_idx_2344"></a>(define (real-part z)
  (* (magnitude z) (cos (angle z))))
<a name="%_idx_2346"></a>(define (imag-part z)
  (* (magnitude z) (sin (angle z))))
<a name="%_idx_2348"></a>(define (magnitude z) (car z))
<a name="%_idx_2350"></a>(define (angle z) (cdr z))
<a name="%_idx_2352"></a>(define (make-from-real-imag x y) 
  (cons (sqrt (+ (square x) (square y)))
        (atan y x)))
<a name="%_idx_2354"></a>(define (make-from-mag-ang r a) (cons r a))
</p>

<p class="orig" lang="en">
The discipline of data abstraction ensures that the same implementation of
<tt>add-complex</tt>, <tt>sub-complex</tt>, <tt>mul-complex</tt>, and <tt>div-complex</tt> will work with either Ben's representation or Alyssa's
representation. </p>

<p class="trans" lang="ja">
<tt>add-complex</tt> と <tt>sub-complex</tt> と <tt>mul-complex</tt> と <tt>div-complex</tt> についての同じ実装が、ベンの表現とアリッサの表現のいずれを使った場合にもちゃんと動く、ということを、データ抽象化の規律は保証する。
</p>

<a name="%_sec_2.4.2"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_2.4.2">2.4.2  Tagged data</a></h3>
<h3 class="trans" lang="ja">2.4.2 タグ付けされたデータ</h3>

<p class="orig" lang="en">
<a name="%_idx_2356"></a><a name="%_idx_2358"></a><a name="%_idx_2360"></a>
One way to view data abstraction is as an application of the
<a name="%_idx_2362"></a><a name="%_idx_2364"></a>``principle of least commitment.''  In implementing the complex-number
system in section <a href="#%_sec_2.4.1">2.4.1</a>, we can
use either Ben's rectangular representation or Alyssa's polar
representation.  The abstraction barrier formed by the selectors and
constructors permits us to defer to the last possible moment the
choice of a concrete representation for our data objects and thus
retain maximum flexibility in our system design.</p>

<p class="trans" lang="ja">
データ抽象化の一つの眺め方は、「最小の関わりの原則」の適用として、というものである。
<a href="#%_sec_2.4.1">2.4.1</a>節で複素数システムを実装する際には、ベンの直交表現またはアリッサの極表現を使うことができる。
セレクタとコンストラクタにより形成される抽象化の防壁のおかげで、自分のデータオブジェクト用の具体的な表現の選択を、可能な限り最後の時点まで延期することができ、ゆえに、自分のシステム設計において最大限の柔軟性を保ち続けることができる。
</p>

<p class="orig" lang="en">
The principle of least commitment can be carried to even further
extremes.  If we desire, we can maintain the ambiguity of
representation even <em>after</em> we have designed the selectors and
constructors, and elect to use both Ben's representation <em>and</em>
Alyssa's representation.  If both representations are included in a
single system, however, we will need some way to distinguish data in
polar form from data in rectangular form.  Otherwise, if we were
asked, for instance, to find the <tt>magnitude</tt> of the pair (3,4),
we wouldn't know whether to answer 5 (interpreting the number in
rectangular form) or 3 (interpreting the number in polar form).  A
straightforward way to accomplish this distinction is to include a
<a name="%_idx_2366"></a><em>type tag</em> -- the symbol <tt>rectangular</tt> or <tt>polar</tt> -- as
part of each complex number.  Then when we need to manipulate a
complex number we can use the tag to decide which selector to apply.</p>

<p class="trans" lang="ja">
最小の関わりの原則を、もっと極端なところまで推し進めることさえ可能だ。
私たちは、もし望むならば、セレクタとコンストラクタを設計した<em>後</em>でさえも、表現の曖昧性を保てるし、ベンの表現<em>および</em>アリッサの表現の双方を、使うことに決めることもできる。
しかし、もし単一のシステム内に双方の表現が含まれていたら、極形式のデータを直交形式のデータと区別するための、何らかの方法が必要になるだろう。
さもなければ、もし、たとえば (3, 4) という対の <tt>magnitude</tt> を求めてほしいと言われたら、私たちは、5 と答える (数を直交形式で解釈する) べきか、それとも 3 と答える (数を極形式で解釈する) べきかが、分からないだろう。
この区別を成し遂げるための単純な方法は、<em>型タグ</em>——<tt>rectangular</tt> または <tt>polar</tt> という記号——を、各複素数の一部として含めることである。
すると、複素数を操作しなくてはならないときには、私たちは、どちらのセレクタを適用すべきかを決めるためにタグを使える。
</p>

<p class="orig" lang="en">
In order to manipulate tagged data,
we will assume that we have procedures <tt>type-tag</tt> and <tt>contents</tt> that extract from a data object the tag and the actual
contents (the polar or rectangular coordinates, in the case of a
complex number).  We will also postulate a procedure <tt>attach-tag</tt> that takes a tag and contents and produces a tagged data
object.  A straightforward way to implement this is to use ordinary
list structure:
</p>


<p class="trans" lang="ja">
タグ付けされたデータを操作するために、タグと実際の中身 (複素数の場合は、極座標または直交座標) をデータオブジェクトから抽出する、<tt>type-tag</tt> および <tt>contents</tt> という手続きがあるものとしよう。
また、タグと中身をもらって、タグ付けされたデータオブジェクトを作り出す、<tt>attach-tag</tt> という手続きも、仮定しておこう。
これを実装する単純な方法は、普通のリスト構造を使うことである。
</p>

<p class="lisp"><a name="%_idx_2368"></a>(define (attach-tag type-tag contents)
  (cons type-tag contents))
<a name="%_idx_2370"></a>(define (type-tag datum)
  (if (pair? datum)
      (car datum)
      (error &quot;Bad tagged datum -- TYPE-TAG&quot; datum)))
<a name="%_idx_2372"></a>(define (contents datum)
  (if (pair? datum)
      (cdr datum)
      (error &quot;Bad tagged datum -- CONTENTS&quot; datum)))
</p>

<p class="orig" lang="en">
Using these procedures, we can define predicates <tt>rectangular?</tt>
and <tt>polar?</tt>, which recognize polar and rectangular numbers,
respectively:</p>

<p class="trans" lang="ja">
これらの手続きを使うと、<tt>rectangular?</tt> および <tt>polar?</tt> という述語——それぞれ、直交形式の数と極形式の数を認識する——を定義できる。
<span class="note">(respectively とあるので、述べる順が揃っていないと変なのだが、逆順になっている。おそらく原文の書き間違い。)</span>
</p>

<p class="lisp"><a name="%_idx_2374"></a>(define (rectangular? z)
  (eq? (type-tag z) 'rectangular))
<a name="%_idx_2376"></a>(define (polar? z)
  (eq? (type-tag z) 'polar))
</p>

<p class="orig" lang="en">
With type tags, Ben and Alyssa can now modify their code so that
their two different representations can coexist in the same system.
Whenever Ben constructs a complex number, he tags it as rectangular.
Whenever Alyssa constructs a complex number, she tags it as polar.
In addition, Ben and Alyssa must make sure that the names of their
procedures do not conflict.  One way to do this is for Ben to append
the suffix <tt>rectangular</tt> to the name of each of his representation
procedures and for Alyssa to append <tt>polar</tt> to the names of hers.
Here is Ben's revised rectangular representation from
section <a href="#%_sec_2.4.1">2.4.1</a>:</p>

<p class="trans" lang="ja">
さて、型タグを使って、ベンとアリッサは、同じシステム内に自分たちの二つの異なるコードが共存できるように、自分たちのコードを修正できる。
ベンは、複素数を構築するときはいつでも、その複素数を、直交形式だとタグ付けする。
アリッサは、複素数を構築するときはいつでも、その複素数を、極形式だとタグ付けする。
さらに、ベンとアリッサは、自分たちの手続きの名前が重ならないことを保証せねばならない。
こうするための一つの方法は、ベンが、自分の表現手続きの各々の名前に <tt>rectangular</tt> という接尾辞を付加し、アリッサが、自分の表現手続きの名前に <tt>polar</tt> と付加することである。
ここに、<a href="#%_sec_2.4.1">2.4.1</a>節から改変した後の、ベンの直交表現を示す。
</p>

<p class="lisp"><a name="%_idx_2378"></a>(define (real-part-rectangular z) (car z))
<a name="%_idx_2380"></a>(define (imag-part-rectangular z) (cdr z))
<a name="%_idx_2382"></a>(define (magnitude-rectangular z)
  (sqrt (+ (square (real-part-rectangular z))
           (square (imag-part-rectangular z)))))
<a name="%_idx_2384"></a>(define (angle-rectangular z)
  (atan (imag-part-rectangular z)
        (real-part-rectangular z)))
<a name="%_idx_2386"></a>(define (make-from-real-imag-rectangular x y)
  (attach-tag 'rectangular (cons x y)))
<a name="%_idx_2388"></a>(define (make-from-mag-ang-rectangular r a) 
  (attach-tag 'rectangular
              (cons (* r (cos a)) (* r (sin a)))))
</p>

<p class="orig" lang="en">
and here is Alyssa's revised polar representation:
</p>

<p class="trans" lang="ja">
そして、ここに、アリッサの改変後の極表現を示す。
</p>

<p class="lisp"><a name="%_idx_2390"></a>(define (real-part-polar z)
  (* (magnitude-polar z) (cos (angle-polar z))))
<a name="%_idx_2392"></a>(define (imag-part-polar z)
  (* (magnitude-polar z) (sin (angle-polar z))))
<a name="%_idx_2394"></a>(define (magnitude-polar z) (car z))
<a name="%_idx_2396"></a>(define (angle-polar z) (cdr z))
<a name="%_idx_2398"></a>(define (make-from-real-imag-polar x y) 
  (attach-tag 'polar
               (cons (sqrt (+ (square x) (square y)))
                     (atan y x))))
<a name="%_idx_2400"></a>(define (make-from-mag-ang-polar r a)
  (attach-tag 'polar (cons r a)))
</p>

<p class="orig" lang="en">
<a name="%_idx_2402"></a><a name="%_idx_2404"></a>Each generic selector is implemented as a procedure that checks the
tag of its argument and calls the appropriate procedure for handling
data of that type.  For example, to obtain the real part of a complex
number, <tt>real-part</tt> examines the tag to determine whether to use
Ben's <tt>real-part-rectangular</tt> or Alyssa's <tt>real-part-polar</tt>.
In either case, we use <tt>contents</tt> to extract the bare, untagged
datum and send this to the rectangular or polar procedure as required:
</p>

<p class="trans" lang="ja">
総称的なセレクタの各々は、そのセレクタへの引数のタグを検査して、その型のデータを扱うための適宜の手続きを呼び出すような手続きとして、実装される。
たとえば、複素数の実部を得るために、<tt>real-part</tt> は、タグを調べて、ベンの <tt>real-part-rectangular</tt> を使うべきか、それともアリッサの <tt>real-part-polar</tt> を使うべきかを決定する。
いずれの場合でも、私たちは、裸の、タグ付けされていないデータを抜き出すために <tt>contents</tt> を使い、このデータを、求められるとおりに、直交形式用の手続きか、または極形式用の手続きへと、送り出す。
</p>

<p class="lisp"><a name="%_idx_2406"></a>(define (real-part z)
  (cond ((rectangular? z) 
         (real-part-rectangular (contents z)))
        ((polar? z)
         (real-part-polar (contents z)))
        (else (error &quot;Unknown type -- REAL-PART&quot; z))))
<a name="%_idx_2408"></a>(define (imag-part z)
  (cond ((rectangular? z)
         (imag-part-rectangular (contents z)))
        ((polar? z)
         (imag-part-polar (contents z)))
        (else (error &quot;Unknown type -- IMAG-PART&quot; z))))
<a name="%_idx_2410"></a>(define (magnitude z)
  (cond ((rectangular? z)
         (magnitude-rectangular (contents z)))
        ((polar? z)
         (magnitude-polar (contents z)))
        (else (error &quot;Unknown type -- MAGNITUDE&quot; z))))
<a name="%_idx_2412"></a>(define (angle z)
  (cond ((rectangular? z)
         (angle-rectangular (contents z)))
        ((polar? z)
         (angle-polar (contents z)))
        (else (error &quot;Unknown type -- ANGLE&quot; z))))
</p>

<p class="orig" lang="en">
To implement the complex-number arithmetic operations, we can use the
same procedures <tt>add-complex</tt>, <tt>sub-complex</tt>, <tt>mul-complex</tt>, and <tt>div-complex</tt> from
section <a href="#%_sec_2.4.1">2.4.1</a>, because the
selectors they call are generic, and so will work with either
representation.  For example, the procedure <tt>add-complex</tt> is still
</p>

<p class="trans" lang="ja">
複素数の算術演算を実装するために、私たちは、<a href="#%_sec_2.4.1">2.4.1</a>のと同じ、<tt>add-complex</tt> と <tt>sub-complex</tt> と <tt>mul-complex</tt> と <tt>div-complex</tt> という手続きを、使うことができる。というのも、これらの手続きが呼び出すセレクタは、総称的であり、そのため、どちらの表現に対してもちゃんと動くからである。
たとえば、<tt>add-complex</tt> という手続きは、依然として、以下のとおりのままである。
</p>

<p class="lisp">(define (add-complex z1 z2)
  (make-from-real-imag (+ (real-part z1) (real-part z2))
                       (+ (imag-part z1) (imag-part z2))))
</p>

<p class="orig" lang="en">
Finally, we must choose whether to construct complex numbers using
Ben's representation or Alyssa's representation.  One reasonable
choice is to construct rectangular numbers whenever we have real and
imaginary parts and to construct polar numbers whenever we have
magnitudes and angles:
</p>

<p class="trans" lang="ja">
最後に、私たちは、ベンの表現を使って複素数を構築するのか、それとも、アリッサの表現を使って複素数を構築するのかを、選ばなくてはならない。
理にかなった一つの選択は、実部と虚部が分かっているときはいつでも直交形式の数を構築し、かつ、大きさと角度が分かっているときはいつでも極形式の数を構築する、という方法だ。
</p>

<p class="lisp"><a name="%_idx_2414"></a>(define (make-from-real-imag x y)
  (make-from-real-imag-rectangular x y))
<a name="%_idx_2416"></a>(define (make-from-mag-ang r a)
  (make-from-mag-ang-polar r a))
</p>

<figure>
<a name="%_fig_2.21"></a>
<img src="ch2-Z-G-62.gif" border="0">
<figcaption class="orig" lang="en"><div align=left><b>Figure 2.21:</b>  Structure of the generic complex-arithmetic system.</figcaption>
<figcaption class="trans" lang="ja"><b>図2.21:</b> 総称的な複素数算術システムの構造</figcaption>
</figure>

<p class="orig" lang="en">
The resulting complex-number system has the structure shown in
figure <a href="#%_fig_2.21">2.21</a>.  The system has been
decomposed into three relatively independent parts: the
complex-number-arithmetic operations, Alyssa's polar
implementation, and Ben's rectangular implementation.  The polar and
rectangular implementations could have been written by Ben and Alyssa
working separately, and both of these can be used as underlying
representations by a third programmer implementing the
complex-arithmetic procedures in terms of the abstract
constructor/selector interface.</p>

<p class="trans" lang="ja">
できあがった複素数システムには、図<a href="#%_fig_2.21">2.21</a>に示すような構造がある。
システムは、比較的独立した三つの部分へと分解された——すなわち、複素数算術演算と、アリッサの極形式の実装と、ベンの直交形式の実装である。
極形式と直交形式の実装は、別々に働いているベンとアリッサによって書かれ得ただろうし、これらの実装の双方は、抽象的なコンストラクタ/セレクタというインタフェイスを使って複素数算術手続きを実装する第三者のプログラマによって、根底にある表現として使われ得る。
</p>

<p class="orig" lang="en">
<a name="%_idx_2420"></a><a name="%_idx_2422"></a>Since each data object is tagged with its type, the selectors operate
on the data in a generic manner.  That is, each selector is defined to
have a behavior that depends upon the particular type of data it is
applied to.  Notice the general mechanism for interfacing the separate
representations: Within a given representation implementation (say,
Alyssa's polar package) a complex number is an untyped pair
(magnitude, angle).  When a generic selector operates on a number of
<tt>polar</tt> type, it strips off the tag and passes the contents on to
Alyssa's code.  Conversely, when Alyssa constructs a number for general
use, she tags it with a type so that it can be appropriately
recognized by the higher-level procedures.  This discipline of
stripping off and attaching tags as data objects are passed from level
to level can be an important organizational strategy, as we shall see
in section <a href="18_sec2_5.html#%_sec_2.5">2.5</a>.

</p>

<p class="trans" lang="ja">
各データオブジェクトが型でタグ付けされているため、セレクタは、そのデータ上で総称的なやり方で動作する。
つまり、各セレクタは、そのセレクタが適用されるデータの、特定の型に依存する振る舞いをするように、定義される。
別々の表現同士の間のインタフェイスをとるための、一般的な仕組みに注意せよ——与えられた表現実装 (たとえば、アリッサの極形式のパッケージ) の内部では、複素数は、型のない対 (大きさと角度) なのだ。
総称的なセレクタは、<tt>polar</tt> 型の数の上で動作するとき、タグを剥ぎ取って、中身をアリッサのコードに渡す。
逆に、一般的用途のためにアリッサが数を構築するときには、アリッサは、より高いレベルの手続きによりその数が適切に認識されるように、その数を型でタグ付けする。
データオブジェクトがレベルからレベルへと受け渡されるのにつれて、タグを剥ぎ取ったり取りつけたりする、というこの規律は、重要な組織立ての戦略になり得る——<a href="18_sec2_5.html#%_sec_2.5">2.5</a>節で見ることになるとおり。
</p>

<a name="%_sec_2.4.3"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_2.4.3">2.4.3  Data-Directed Programming and Additivity</a></h3>
<h3 class="trans" lang="ja">2.4.3 データ指向プログラミングと加法性</h3>

<p class="orig" lang="en">
<a name="%_idx_2424"></a><a name="%_idx_2426"></a>
<a name="%_idx_2428"></a>The general strategy of checking the type of a datum and calling an
appropriate procedure is called <a name="%_idx_2430"></a><a name="%_idx_2432"></a><em>dispatching on type</em>.  This is a
powerful strategy for obtaining modularity in system design.  On
the other hand, implementing the dispatch as in
section <a href="#%_sec_2.4.2">2.4.2</a> has two significant weaknesses.  One
weakness is that the generic interface procedures (<tt>real-part</tt>,
<tt>imag-part</tt>, <tt>magnitude</tt>, and <tt>angle</tt>) must know about all
the different representations.  For instance, suppose we wanted to
incorporate a new representation for complex numbers into our
complex-number system.  We would need to identify this new
representation with a type, and then add a clause to each of the
generic interface procedures to check for the new type and apply the
appropriate selector for that representation.</p>

<p class="trans" lang="ja">
データの型を調べて適切な手続きを呼び出す、という一般的な戦略は、<em>型による<!--送り出し-->振り分け</em>と呼ばれる。
これは、システム設計においてモジュール性を獲得するための、強力な戦略である。
一方、<a href="#%_sec_2.4.2">2.4.2</a>節のように<!--送り出し-->振り分けを実装することには、二つの重大な弱点がある。
一つの弱点は、総称的なインタフェイス手続き  (<tt>real-part</tt> と <tt>imag-part</tt> と <tt>magnitude</tt> と <tt>angle</tt>) が、すべての異なる表現について知っていなくてはならない、という点だ。
たとえば、私たちの複素数システムに、複素数用の新たな表現を組み込みたいのだ、と仮定しよう。
この新たな表現を、ある型だと同定する必要があるだろうし、さらに、その新たな型なのかを調べてその表現に適したセレクタを適用するために、総称的なインタフェイス手続きの各々に節を追加する必要があるだろう。
</p>

<p class="orig" lang="en">
Another weakness of the technique is that even though the individual
representations can be designed separately, we must guarantee that
no two procedures in the entire system have the same name.  This is
why Ben and Alyssa had to change the names of their original
procedures from section <a href="#%_sec_2.4.1">2.4.1</a>.</p>

<p class="trans" lang="ja">
当技法のもう一つの弱点は、たとえ個々の表現を別々に設計できるのであってさえも、全システム内のどの二つの手続きも同じ名前ではないということを保証しなくてはならない、という点だ。
このことは、なぜベンとアリッサが、<a href="#%_sec_2.4.1">2.4.1</a>節以来の自分たちの元の手続きの名前を変えなくてはならなかったのか、ということの理由である。
</p>

<p class="orig" lang="en">
The issue underlying both of these weaknesses is that the technique
for implementing generic interfaces is not <em>additive</em>.  The person
implementing the generic selector procedures must modify those
procedures each time a new representation is installed, and the people
interfacing the individual representations must modify their
code to avoid name conflicts.  In each of these cases, the changes
that must be made to the code are straightforward, but they must be
made nonetheless, and this is a source of inconvenience and error.
This is not much of a problem for the complex-number system as it
stands, but suppose there were not two but hundreds of different
representations for complex numbers.  And suppose that there were many
generic selectors to be maintained in the abstract-data interface.
Suppose, in fact, that no one programmer knew all the interface
procedures or all the representations.  The problem is real and must
be addressed in such programs as large-scale data-base-management
systems.</p>

<p class="trans" lang="ja">
これらの弱点双方の背後にある問題は、総称的なインタフェイスを実装するための技法が<em>加法的</em>ではないことである。
総称的なセレクタ手続きを実装する人は、新しい表現が取り入れられるたびに、それらの手続きを修正せねばならないし、個々の表現をインタフェイスでつなぐ人たちは、名前の衝突を避けるために、自分たちのコードを修正せねばならない。
これらの状況のそれぞれにおいて、コードに対してしなくてはならない変更は、単純ではあるが、それでもやはり、しなくてはならないのであり、そして、このことが、不便とエラーの源なのだ。
これは、現状の複素数システムにとっては大した問題ではないが、複素数に対して二つどころか何百もの異なる表現があった、と仮定してみたまえ。
そして、抽象データインタフェイスのうちには、<!--を使って-->保守すべき総称的セレクタがたくさんあった、と仮定してみたまえ。<!--span class="note">(inを手段と見て訳したが、「の中で」でなくてよいか、文章の意味内容をもう一度見直すこと。)</span-->
この問題は、現実的だし、大規模データベース管理システムのようなプログラムでは、対処しなくてはならないものである。
</p>

<p class="orig" lang="en">
What we need is a means for modularizing the system design even
further.  This is provided by the programming technique known as <em>data-directed programming</em>.  To understand how data-directed
programming works, begin with the observation that whenever we deal
with a set of generic operations that are common to a set of
different types we are, in effect, dealing with a two-dimensional
table that contains the possible operations on one axis and the
possible types on the other axis.  The entries in the table are the
procedures that implement each operation for each type of argument
presented.  In the complex-number system developed in the previous
section, the correspondence between operation name, data type, and
actual procedure was spread out among the various conditional clauses
in the generic interface procedures.  But the same information could
have been organized in a table, as shown in
figure <a href="#%_fig_2.22">2.22</a>.</p>

<p class="trans" lang="ja">
必要なのは、システム設計をさらにモジュール化するための手段である。
これは、<em>データ指向プログラミング</em>として知られるプログラミング技法により、与えられる。
データ指向プログラミングがどのようにしてうまく動くのか、ということを理解するために、このような観察から始めよう——すなわち、私たちは、異なる型の一揃いに対して共通な総称的演算の一揃いを扱うときにはいつでも、実際のところ、一方の軸に沿って可能な演算を含み、かつ、他方の軸に沿って可能な型を含むような、二次元の表を扱っているのである。
この表のエントリは、それぞれの型の、提示されている引数のための各演算を、実装する手続きである。
前節で開発した複素数システムでは、演算名と、データ型と、実際の手続きとの間の対応関係は、総称的なインタフェイス手続きの中の様々な条件節の間に蔓延していた。
しかし、同じ情報は、表にまとめられ得たのだ——図<a href="#%_fig_2.22">2.22</a>に示すとおり。
</p>

<p class="orig" lang="en">
<a name="%_idx_2434"></a>Data-directed programming is the technique of designing programs to
work with such a table directly.  Previously, we implemented the
mechanism that interfaces the complex-arithmetic code with the two
representation packages as a set of procedures that each perform an
explicit dispatch on type.  Here we will implement the interface as a single
procedure that looks up the combination of the operation name and
argument type in
the table to find the correct procedure to apply, and then applies it
to the contents of the argument.  If we do this, then to add a new
representation package to the system we need not change any existing
procedures; we need only add new entries to the table.</p>

<p class="trans" lang="ja">
データ指向プログラミングは、こういう表を直接使って動くように、プログラムを設計する技法だ。
以前、私たちは、複素数算術のコードを二つの表現パッケージにインタフェイスでつなぐ仕組みを、型による<!--送り出し-->振り分けをそれぞれが明示的に行うような一群の手続きとして、実装した。
ここでは、適用すべき正しい手続きを見つけるために、演算名と引数の型の組み合わせを表で調べて、それからその手続きを引数の中身に適用するような、単一の手続きとして、インタフェイスを実装しよう。
もしこうすれば、システムに新たな表現パッケージを追加するために、既存のどの手続きも変更しなくてよい——ただ、表に新たなエントリを加えるだけでよいのだ。
</p>

<figure>
<a name="%_fig_2.22"></a>
<img src="ch2-Z-G-63.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 2.22:</b>  Table of operations for the complex-number system.</figcaption>
<figcaption class="trans" lang="ja"><b>図2.22:</b> 複素数システム用の演算の表</figcaption>
</figure>

<p class="orig" lang="en">
To implement this plan, assume that we have two procedures,
<tt>put</tt> and <tt>get</tt>, for manipulating the
operation-and-type table:
<a name="%_idx_2436"></a>

<p class="trans" lang="ja">
この計画を実装するために、<tt>put</tt> と <tt>get</tt> という二つの手続き——演算・型の表を操作するためのもの——がある、と仮定しよう。
</p>

<ul class="orig" lang="en">
<a name="%_idx_2438"></a>
<li><tt>(put &lt;<em>op</em>&gt; &lt;<em>type</em>&gt; &lt;<em>item</em>&gt;)</tt><br>
installs the <tt>&lt;<em>item</em>&gt;</tt> in the table, indexed by the
<tt>&lt;<em>op</em>&gt;</tt> and the <tt>&lt;<em>type</em>&gt;</tt>.</li>

<a name="%_idx_2440"></a>
<li><tt>(get &lt;<em>op</em>&gt; &lt;<em>type</em>&gt;)</tt><br>
looks up the <tt>&lt;<em>op</em>&gt;</tt>, <tt>&lt;<em>type</em>&gt;</tt> entry in the table
and returns the item found there.  If no item is found, <tt>get</tt>
returns false.</li>
</ul>

<ul class="trans" lang="ja">
<li><tt>(put &lt;<em class="en">op</em>&gt; &lt;<em class="en">type</em>&gt; &lt;<em class="en">item</em>&gt;)</tt>
は、表に <tt>&lt;<em class="en">item</em>&gt;</tt> を取り込み、これは、<tt>&lt;<em class="en">op</em>&gt;</tt> と the <tt>&lt;<em class="en">type</em>&gt;</tt> で索引づけられる。
</li>
<li><tt>(get &lt;<em class="en">op</em>&gt; &lt;<em class="en">type</em>&gt;)</tt> は、表内の、<tt>&lt;<em class="en">op</em>&gt;</tt>, <tt>&lt;<em class="en">type</em>&gt;</tt> のエントリを調べて、そこで見つかったものを返す。もし何も見つからなかったら、<tt>get</tt> は偽を返す。
</li>
</ul>

<p class="orig" lang="en">
For now, we can assume that <tt>put</tt> and <tt>get</tt> are
included in our language.  In chapter 3
(section <a href="22_sec3_3.html#%_sec_3.3.3">3.3.3</a>, exercise <a href="22_sec3_3.html#%_thm_3.24">3.24</a>)
we will see how to implement these and
other operations for manipulating tables.</p>

<p class="trans" lang="ja">
これからは、私たちの言語に <tt>put</tt> と <tt>get</tt> が含まれている、と仮定できる。
3章 (<a href="22_sec3_3.html#%_sec_3.3.3">3.3.3</a>節の練習問題<a href="22_sec3_3.html#%_thm_3.24">3.24</a>) では、<tt>put</tt> と <tt>get</tt> および表を操作するための他の演算をどう実装するのかを見ることにしよう。
</p>

<p class="orig" lang="en">
Here is how data-directed programming can be used in the
complex-number system.  Ben, who developed the rectangular
representation, implements his code just as he did originally.  He
defines a collection of procedures, or a <a name="%_idx_2442"></a><em>package</em>, and interfaces
these to the rest of the system by adding entries to the table that
tell the system how to operate on rectangular numbers.
This is accomplished by calling the following procedure:
<a name="%_idx_2444"></a><a name="%_idx_2446"></a></p>

<p class="trans" lang="ja">
複素数システムにおいてデータ指向プログラミングをどのように使えるか、ということを、ここに示す。
ベン——直交表現を開発した——は、自分のコードを、最初に開発したのとちょうど同じように、実装する。
彼は、手続きの集まり——つまり、<em>パッケージ</em>——を定義して、そして、直交形式の数の上で動作する方法をシステムに伝える表にエントリを加えることによって、これらの手続きを、システムの残りの部分へと、インタフェイスでつなぐ。
これは、以下の手続きを呼び出すことで、成し遂げられる。
</p>

<p class="lisp"><a name="%_idx_2448"></a>(define (install-rectangular-package)
  <em>;; internal procedures</em>
  (define (real-part z) (car z))
  (define (imag-part z) (cdr z))
  (define (make-from-real-imag x y) (cons x y))
  (define (magnitude z)
    (sqrt (+ (square (real-part z))
             (square (imag-part z)))))
  (define (angle z)
    (atan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a) 
    (cons (* r (cos a)) (* r (sin a))))
  <em>;; interface to the rest of the system</em>
  (define (tag x) (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular 
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular 
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)
</p>

<p class="orig" lang="en">
Notice that the internal procedures here are the same procedures from
section <a href="#%_sec_2.4.1">2.4.1</a> that Ben wrote when
he was working in isolation.  No changes are necessary in order to
interface them to the rest of the system.  Moreover, since these
procedure definitions are internal to the installation procedure, Ben
needn't worry about name conflicts with other procedures outside the
rectangular package.  To interface these to the rest of the system,
Ben installs his <tt>real-part</tt> procedure under the operation name
<tt>real-part</tt> and the type <tt>(rectangular)</tt>, and similarly
for the other selectors.<a name="call_footnote_Temp_270" href="#footnote_Temp_270"><sup><small>45</small></sup></a>  The interface also defines
the constructors to be used by the external system.<a name="call_footnote_Temp_271" href="#footnote_Temp_271"><sup><small>46</small></sup></a>
These are
identical to Ben's internally defined constructors, except that they
attach the tag.</p>

<p class="trans" lang="ja">
ここでの内部手続きが、<a href="#%_sec_2.4.1">2.4.1</a>節でベンが隔離されて働いていたときに書いたものと同じ手続きであることに、注意せよ。
これらの手続きをシステムの残りの部分へとインタフェイスでつなぐためには、何の変更も必要ない。
さらに、これらの手続き定義は、インストレーション手続きの内部のものだから、ベンは、直交表現パッケージの外部の他の手続きとの間での名前の衝突について、心配する必要がない。
これらの手続きをシステムの残りの部分へとインタフェイスでつなぐために、ベンは、自分の <tt>real-part</tt> という手続きを、<tt>real-part</tt> という演算名と <tt>(rectangular)</tt> という型のもとにインストールし、他のセレクタについても同様のことをする<a href="#footnote_Temp_270"><sup><small>45</small></sup></a>。
インタフェイスは、外部のシステムにより使われるべきコンストラクタをも、定義している<a href="#footnote_Temp_271"><sup><small>46</small></sup></a>。
これらのコンストラクタは、タグをくっつけるという点を除けば、ベンが内部的に定義したコンストラクタとそっくり同じである。
</p>

<p class="orig" lang="en">
<a name="%_idx_2450"></a><a name="%_idx_2452"></a>Alyssa's polar package is analogous:</p>

<p class="trans" lang="ja">
アリッサの極表現パッケージも同様だ。
</p>

<p class="lisp"><a name="%_idx_2454"></a>(define (install-polar-package)
  <em>;; internal procedures</em>
  (define (magnitude z) (car z))
  (define (angle z) (cdr z))
  (define (make-from-mag-ang r a) (cons r a))
  (define (real-part z)
    (* (magnitude z) (cos (angle z))))
  (define (imag-part z)
    (* (magnitude z) (sin (angle z))))
  (define (make-from-real-imag x y) 
    (cons (sqrt (+ (square x) (square y)))
          (atan y x)))
  <em>;; interface to the rest of the system</em>
  (define (tag x) (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar 
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)
</p>

<p class="orig" lang="en">
Even though Ben and Alyssa both still use their original procedures
defined with the same names as each other's (e.g., <tt>real-part</tt>), these
definitions are now internal to different procedures (see
section <a href="10_sec1_1.html#%_sec_1.1.8">1.1.8</a>), so there is no name
conflict.</p>

<p class="trans" lang="ja">
ベンとアリッサは、二人とも依然として、お互いのものと同じ名前で定義した、自分の元の手続き (たとえば <tt>real-part</tt>) を使っているのだが、それでも、これらの定義は今や、異なる手続きの内部にあり (<a href="10_sec1_1.html#%_sec_1.1.8">1.1.8</a>節を参照)、よって、名前の衝突はない。
</p>

<p class="orig" lang="en">
The complex-arithmetic selectors access the table by means of a
general ``operation'' procedure called <tt>apply-generic</tt>, which
applies a generic operation to some arguments.  <tt>Apply-generic</tt>
looks in the table under the name of the operation and the types of the
arguments and applies the resulting procedure if one is present:<a name="call_footnote_Temp_272" href="#footnote_Temp_272"><sup><small>47</small></sup></a>
</p>

<p class="trans" lang="ja">
複素数算術のセレクタは、<tt>apply-generic</tt> と呼ばれる汎用の「演算」手続き——総称的演算を何らかの引数に適用する——を介して、表にアクセスする。
<tt>apply-generic</tt> は、その演算の名前と引数の型で表を調べて、もし手続きがあれば、結果として得られた手続きを適用する<a href="#footnote_Temp_272"><sup><small>47</small></sup></a>。
***
</p>

<p class="lisp"><a name="%_idx_2462"></a>(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args))
          (error
            &quot;No method for these types -- APPLY-GENERIC&quot;
            (list op type-tags))))))
</p>

<p class="orig" lang="en">
Using <tt>apply-generic</tt>, we can define our generic selectors as follows:
</p>

<p class="trans" lang="ja">
<tt>apply-generic</tt> を使うと、以下のように総称的なセレクタを定義できる。
</p>

<p class="lisp"><a name="%_idx_2464"></a>(define (real-part z) (apply-generic 'real-part z))
<a name="%_idx_2466"></a>(define (imag-part z) (apply-generic 'imag-part z))
<a name="%_idx_2468"></a>(define (magnitude z) (apply-generic 'magnitude z))
<a name="%_idx_2470"></a>(define (angle z) (apply-generic 'angle z))
</p>

<p class="orig" lang="en">
Observe that these do not change at all if a new representation is
added to the system.</p>

<p class="trans" lang="ja">
新たな表現がシステムに追加されたとしても、これらがまったく変わらない、ということに気づいてほしい。
</p>

<p class="orig" lang="en">
We can also extract from the table the
constructors to be used by the programs external to the packages in
making complex numbers from real and imaginary parts and from
magnitudes and angles.
As in section <a href="#%_sec_2.4.2">2.4.2</a>, we
construct rectangular numbers whenever we have real and
imaginary parts, and polar numbers whenever we have magnitudes and angles:
</p>

<p class="trans" lang="ja">
複素数を実部と虚部から作ったり、大きさと角度から作ったりする際に、パッケージの外部のプログラムによって使われるべきコンストラクタを、表から取り出すこともできる。
<a href="#%_sec_2.4.2">2.4.2</a>節のとおり、私たちは、実部と虚部を知っているときはいつでも直交形式の数を構築し、大きさと角度を知っているときはいつでも極形式の数を構築する。
</p>

<p class="lisp"><a name="%_idx_2472"></a>(define (make-from-real-imag x y)
  ((get 'make-from-real-imag 'rectangular) x y))
<a name="%_idx_2474"></a>(define (make-from-mag-ang r a)
  ((get 'make-from-mag-ang 'polar) r a))
</p>

<p class="orig" lang="en">
<a name="%_thm_2.73"></a>
<b>Exercise 2.73.</b>  Section <a href="16_sec2_3.html#%_sec_2.3.2">2.3.2</a> described a program that
performs symbolic differentiation:</p>

<p class="trans" lang="ja">
<b>練習問題 2.73</b> <a href="16_sec2_3.html#%_sec_2.3.2">2.3.2</a>節では、記号微分を行うプログラムについて説明した。
</p>

<a name="%_idx_2476"></a><a name="%_idx_2478"></a>
<p class="lisp">(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp) (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
           (make-product (multiplier exp)
                         (deriv (multiplicand exp) var))
           (make-product (deriv (multiplier exp) var)
                         (multiplicand exp))))
        &lt;<em>more rules can be added here</em>&gt;
        (else (error &quot;unknown expression type -- DERIV&quot; exp))))
</p>

<p class="orig" lang="en">
We can regard this program as performing a dispatch on the type of the
expression to be differentiated.  In this situation the ``type tag'' of the
datum is the algebraic operator symbol (such as <tt>+</tt>) and the
operation being performed is <tt>deriv</tt>.  We can transform this
program into data-directed style by rewriting the basic derivative
procedure as</p>

<p class="trans" lang="ja">
このプログラムを、微分すべき式の型による<!--送り出し-->振り分けを行っているものと見なせる。
この立場では、データの「型タグ」は、(<tt>+</tt> などの) 代数的演算子記号であり、実行される演算とは、<tt>deriv</tt> である。
基本的な微分手続きを次のように書き換えることによって、このプログラムを、データ指向スタイルに変形できる。
</p>

<p class="lisp"><a name="%_idx_2480"></a>(define (deriv exp var)
   (cond ((number? exp) 0)
         ((variable? exp) (if (same-variable? exp var) 1 0))
         (else ((get 'deriv (operator exp)) (operands exp)
                                            var))))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
</p>

<ol class="orig" lang="en" style="list-style-type: lower-alpha;" start="1">
<li>Explain what was done above.
Why can't we assimilate the predicates <tt>number?</tt> and <tt>same-variable?</tt> into the data-directed dispatch?</li>
</ol>

<ol class="trans" lang="ja" style="list-style-type: lower-alpha;" start="1">
<li>上記で行われたことを説明せよ。
なぜ、<tt>number?</tt> と <tt>same-variable?</tt> という述語を、データ指向の<!--送り出し-->振り分けに融合することができないのか?
</li>
</ol>

<p class="exercise"><span class="ex_comment"></span>
</p>

<ol class="orig" lang="en" style="list-style-type: lower-alpha;" start="2">
<li>Write the procedures for derivatives of sums and products, and the
auxiliary code required to install them in the table used by the
program above.</li>
</ol>

<ol class="trans" lang="ja"  style="list-style-type: lower-alpha;" start="2">
<li>
和と積の微分についての手続きを書け。そして、上記のプログラムにより使われる表にそれらの手続きを取り込むために必要な、補助コードを書け。
</li>
</ol>

<p class="exercise"><span class="ex_comment"></span>
</p>

<ol class="orig" lang="en" style="list-style-type: lower-alpha;" start="3">
<li>Choose any additional differentiation rule that you like, such as
the one for exponents (exercise <a href="16_sec2_3.html#%_thm_2.56">2.56</a>),
and install it in this data-directed system.</li>
</ol>

<ol class="trans" lang="ja" style="list-style-type: lower-alpha;" start="3">
<li>何でもよいから君の好きな追加の微分規則——たとえば、指数についての微分規則 (練習問題<a href="16_sec2_3.html#%_thm_2.56">2.56</a>)——を選んで、それを、このデータ指向システムに取り入れよ。</li>
</ol>

<p class="exercise"><span class="ex_comment"></span>
</p>

<ol class="orig" lang="en" style="list-style-type: lower-alpha;" start="4">
<li>In this simple algebraic manipulator the type of an expression is
the algebraic operator that binds it together.  Suppose, however, we
indexed the procedures in the opposite way, so that the dispatch line
in <tt>deriv</tt> looked like</li>
</ol>

<ol class="trans" lang="ja" style="list-style-type: lower-alpha;" start="4">
<li>この簡単な代数的操作器では、式の型とは、その式を束ねあげている代数的演算子だ。
しかし、逆のやり方で手続きを索引化して、その結果、<tt>deriv</tt> 内の<!--送り出し-->振り分けの行が、以下のようになったのだ、と仮定せよ。
</li>
</ol>

<p class="lisp">((get (operator exp) 'deriv) (operands exp) var)</p>

<p class="orig" lang="en">
What corresponding changes to the derivative system are required?
</p>

<p class="trans" lang="ja">
対応するどのような変更が、微分システムに対して必要だろうか?
</p>


<p class="exercise"><span class="ex_comment"></span>
</p>

<p class="orig" lang="en">
<a name="%_thm_2.74"></a>
<b>Exercise 2.74.</b>  <a name="%_idx_2482"></a><a name="%_idx_2484"></a>Insatiable Enterprises, Inc., is a highly decentralized conglomerate
company consisting of a large number of independent divisions located
all over the world.  The company's computer facilities have just been
interconnected by means of a clever network-interfacing scheme that
makes the entire network appear to any user to be a single computer.
Insatiable's president, in her first attempt to exploit the ability of
the network to extract administrative information from division files,
is dismayed to discover that, although all the division files have
been implemented as data structures in Scheme, the particular data
structure used varies from division to division.  A meeting of
division managers is hastily called to search for a strategy to
integrate the files that will satisfy headquarters' needs while
preserving the existing autonomy of the divisions.</p>

<p class="trans" lang="ja">
<b>練習問題2.74.</b> 貪欲事業社は、世界中にある多数の独立した部門からなる、とても分権化された複合企業体の会社だ。
この会社のコンピュータ施設は、ネットワーク全体をどのユーザに対しても単一のコンピュータのように見せかける、賢いネットワーク・インタフェイス接続の体系を用いて、ちょうど相互接続されたところだ。
貪欲社の社長は、ネットワークの能力を活用して部門ファイルから経営に関する情報を抽出しようという最初の試みでは、以下のことに気づいて失望する。すなわち、部門ファイルのすべてが、Schemeのデータ構造として既に実装されていたにもかかわらず、使われている特定のデータ構造は、部門ごとに違うのだ。
諸部門の既存の自立性を保ちつつも、本部の要求を満たすような、ファイルを統合するための戦略を探すために、部門長たちの会議が大急ぎで召集される。
</p>

<p class="orig" lang="en">
Show how such a strategy can be implemented with data-directed
programming.  As an example, suppose that each division's personnel
records consist of a single file, which contains a set of records
keyed on employees' names.  The structure of the set varies from
division to division.  Furthermore, each employee's record is itself a
set (structured differently from division to division) that contains
information keyed under identifiers such as <tt>address</tt> and <tt>salary</tt>.  In particular:</p>

<p class="trans" lang="ja">
いかにしてそういう戦略を、データ指向プログラミングを使って実装できるのか、ということを示せ。
例として、各部門の人事記録が、単一のファイル——従業員の名前によるキーがつけられたレコードの集合を含んでいる——からなる、と仮定しよう。
その集合の構造は、部門ごとに違う。
さらに、各従業員の記録は、それ自体が、<tt>address</tt> や <tt>salary</tt> などの識別子のもとにキーがつけられた情報を含むような集合 (部門ごとに異なる方法で構造化されている) なのだ。
特に、
</p>

<ol class="orig" lang="en" style="list-style-type: lower-alpha;" start="1">
<li> Implement for headquarters a <tt>get-record</tt> procedure that
retrieves a specified employee's record from a specified personnel
file.  The procedure should be applicable to any division's file.
Explain how the individual divisions' files should be structured.  In
particular, what type information must be supplied?</li>
</ol>

<ol class="trans" lang="ja" style="list-style-type: lower-alpha;" start="1">
<li>指定された従業員の記録を、指定された人事ファイルから取り出すような、<tt>get-record</tt> という手続きを、本部のために実装せよ。
その手続きは、どの部門のファイルにも適用可能であるべきだ。
個々の部門のファイルが、どのように構造化されているべきなのか、説明せよ。
特に、どのような型情報が提供されねばならないのか?
</li>
</ol>

<p class="exercise"><span class="ex_comment"></span>
</p>

<ol class="orig" lang="en" style="list-style-type: lower-alpha;" start="2">
<li>Implement for headquarters a <tt>get-salary</tt> procedure that
returns the salary information from a given employee's record from any
division's personnel file.  How should the record be structured in
order to make this operation work?</li>
</ol>

<ol class="trans" lang="ja" style="list-style-type: lower-alpha;" start="2">
<li>任意の部門の人事ファイルから与えられた従業員のレコードから、給料情報を返すような、<tt>get-salary</tt> という手続きを、本部のために実装せよ。
この演算がうまくいくようにするためには、そのレコードは、どのように構造化されているべきだろうか?
</li>
</ol>

<p class="exercise"><span class="ex_comment"></span>
</p>

<ol class="orig" lang="en" style="list-style-type: lower-alpha;" start="3">
<li>Implement for headquarters a <tt>find-employee-record</tt> procedure.
This should search all the divisions' files for the record of a given
employee and return the record.  Assume that this procedure takes as
arguments an employee's name and a list of all the divisions' files.</li>
</ol>

<ol class="trans" lang="ja" style="list-style-type: lower-alpha;" start="3">
<li><tt>find-employee-record</tt> という手続きを本部のために実装せよ。
これは、与えられた従業員のレコードを求めて全部門のファイルを探索し、そのレコードを返すべきである。
この手続きが、従業員の名前と、諸部門のファイルすべてのリストを、引数としてとるものと仮定せよ。
</li>
</ol>

<p class="exercise"><span class="ex_comment"></span>
</p>

<ol class="orig" lang="en" style="list-style-type: lower-alpha;" start="4">
<li>When Insatiable takes over a new company, what changes must
be made in order to incorporate the new personnel information into the
central system?</li>
</ol>

<ol class="trans" lang="ja" style="list-style-type: lower-alpha;" start="4">
<li>貪欲社が新しい会社を買収する場合、中央システムに新しい人事ファイルを取り込むためには、どのような変更がなされなくてはならないか?
</li>
</ol>

<p class="exercise"><span class="ex_comment"></span>
</p>

<a name="%_sec_Temp_275"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_275">Message passing</a></h4>
<h4 class="trans" lang="ja">メッセージ・パッシング</h4>

<p class="orig" lang="en">
<a name="%_idx_2486"></a>
The key idea of data-directed programming is to handle generic
operations in programs by dealing explicitly with operation-and-type
tables, such as the table in figure <a href="#%_fig_2.22">2.22</a>.  The
style of programming we used in section <a href="#%_sec_2.4.2">2.4.2</a>
organized the required dispatching on type by having each operation
take care of its own dispatching.  In effect, this decomposes the
operation-and-type table into rows, with each generic operation
procedure representing a row of the table.</p>

<p class="trans" lang="ja">
データ指向プログラミングの鍵となる考え方は、図<a href="#%_fig_2.22">2.22</a>のような、演算と型の表を、明示的に扱うことにより、プログラム内の総称的な演算を処理することである。
<a href="#%_sec_2.4.2">2.4.2</a>節で使ったプログラミングの流儀では、各演算に当該演算自体の<!--送り出しを処理させる-->振り分けの面倒を見させることによって、必要とされる、型による<!--送り出し-->振り分けを、組織化した。
実際のところ、これは、演算と型の表を行へと分解するものであり、ここで、総称的演算手続きの各々は、表の一つの行を代表している。
</p>

<p class="orig" lang="en">
An alternative implementation strategy is to decompose the table into
columns and, instead of using ``intelligent operations'' that dispatch
on data types, to work with ``intelligent data objects'' that dispatch
on operation names.  We can do this by arranging things so that a data
object, such as a rectangular number, is represented as a procedure
that takes as input the required operation name and performs the
operation indicated.  In such a discipline, <tt>make-from-real-imag</tt>
could be written as
</p>


<p class="trans" lang="ja">
別の実装戦略は、表を列へと分解すること、そして、データ型による<!--送り出し-->振り分けを行う「賢い演算」を使う代わりに、演算名による<!--送り出し-->振り分けを行う「賢いデータオブジェクト」を用いて作業すること、である。
求められる演算名を入力として取って、その示された演算を実行するような手続きとして、データオブジェクト——たとえば、直交形式の数など——が表現されるように、ものごとを手配することによって、この実装戦略を遂行できる。
そういう規律によれば、<tt>make-from-real-imag</tt> は以下のように書けただろう。
</p>

<p class="lisp"><a name="%_idx_2488"></a>(define (make-from-real-imag x y)
  (define (dispatch op)
    (cond ((eq? op 'real-part) x)
          ((eq? op 'imag-part) y)
          ((eq? op 'magnitude)
           (sqrt (+ (square x) (square y))))
          ((eq? op 'angle) (atan y x))
          (else
           (error &quot;Unknown op -- MAKE-FROM-REAL-IMAG&quot; op))))
  dispatch)
</p>

<p class="orig" lang="en">
The corresponding <tt>apply-generic</tt> procedure, which applies a
generic operation to an argument, now simply feeds the operation's
name to the data object and lets the object do the work:<a name="call_footnote_Temp_276" href="#footnote_Temp_276"><sup><small>48</small></sup></a>
</p>

<p class="trans" lang="ja">
対応する <tt>apply-generic</tt> の手続き——これは、総称的な演算を引数に適用する——は、ここでは単純に、演算の名前をデータオブジェクトに与えて、そのオブジェクトが働くのにまかせる<a href="#footnote_Temp_276"><sup><small>48</small></sup></a>。
</p>

<p class="lisp"><a name="%_idx_2490"></a>(define (apply-generic op arg) (arg op))
</p>

<p class="orig" lang="en">
Note that the value returned by <tt>make-from-real-imag</tt> is a
procedure -- the internal <tt>dispatch</tt> procedure.  This is the
procedure that is invoked when <tt>apply-generic</tt> requests an operation to
be performed.</p>

<p class="trans" lang="ja">
<tt>make-from-real-imag</tt> により返される値が、手続き——つまり、内部の <tt>dispatch</tt> という手続き——であることに、気をつけよ。
これは、演算を実行するよう <tt>apply-generic</tt> が求めるときに呼び出される手続きだ。</p>

<p class="orig" lang="en">
This style of programming is called <em>message passing</em>.  The name
comes from the image that a data object is an entity that receives the
requested operation name as a ``message.''  We have already seen an
example of message passing in section <a href="14_sec2_1.html#%_sec_2.1.3">2.1.3</a>, where we saw
how <tt>cons</tt>, <tt>car</tt>, and <tt>cdr</tt> could be defined with no data
objects but only procedures.  Here we see that message passing is not
a mathematical trick but a useful technique for organizing systems
with generic operations.  In the remainder of this chapter we will
continue to use data-directed programming, rather than message
passing, to discuss generic arithmetic operations.  In chapter 3 we
will return to message passing, and we will see that it can be a
powerful tool for structuring simulation programs.</p>

<p class="trans" lang="ja">
このようなプログラミングの流儀は、<em>メッセージ・パッシング</em>と呼ばれる。
この名前は、データオブジェクトとは要求された演算名を「メッセージ」として受け取る実体である、という印象に由来する。
私たちはメッセージ・パッシングの例を既に<a href="14_sec2_1.html#%_sec_2.1.3">2.1.3</a>節で見た——そこでは、データオブジェクトなしに、ただ手続きのみで、どうやったら <tt>cons</tt> と <tt>car</tt> と <tt>cdr</tt> を定義できるのかを見た。
ここでは、メッセージ・パッシングは数学的な芸当ではなく、総称的演算を使ったシステムを組織化するための有用な技法だ、ということを見ている。
本章の残りでは、総称的な算術演算について議論するために、メッセージ・パッシングではなく、むしろデータ指向プログラミングを使い続けよう。
3章では、メッセージ・パッシングに戻ることにし、また、メッセージ・パッシングが、シミュレーション・プログラムを構造化するための強力な手段たり得る、ということを見ていこう。
</p>

<p class="orig" lang="en">
<a name="%_thm_2.75"></a>
<b>Exercise 2.75.</b>  <a name="%_idx_2492"></a>Implement the constructor <tt>make-from-mag-ang</tt> in message-passing style.
This procedure should be analogous to the <tt>make-from-real-imag</tt>
procedure given above.
</p>

<p class="trans" lang="ja">
<b>練習問題2.75.</b> メッセージ・パッシングの流儀で、<tt>make-from-mag-ang</tt> というコンストラクタを実装せよ。
この手続きは、上述の <tt>make-from-real-imag</tt> という手続きと類似である。
</p>

<p class="exercise"><span class="ex_comment"></span>
</p>

<p class="orig" lang="en">
<a name="%_thm_2.76"></a>
<b>Exercise 2.76.</b>  <a name="%_idx_2494"></a>As a large system with generic operations evolves, new types of data
objects or new operations may be needed.  For each of the three
strategies -- generic operations with explicit dispatch, data-directed
style, and message-passing-style -- describe the changes that must be
made to a system in order to add new types or new operations.  Which
organization would be most appropriate for a system in which new types
must often be added?  Which would be most appropriate for a system in
which new operations must often be added?
</p>

<p class="trans" lang="ja">
<b>練習問題2.76.</b> 総称的演算を使った大規模システムが進化するにつれて、データオブジェクトの新たな型か、新たな演算が必要になるかもしれない。
三つの戦略——明示的な振り分けを伴う総称的演算、データ指向の流儀、メッセージ・パッシング——の各々について、新たな型または新たな演算を追加するために、システムに対してなされなくてはならない変更を、説明せよ。
新たな型がしばしば追加されねばならないようなシステムに対して、もっとも適切なのは、どの組織化の仕方だろう?
新たな演算がしばしば追加されねばならないようなシステムに対して、もっとも適切なのは、どれだろう?
</p>

<p class="exercise"><span class="ex_comment"></span>
</p>


<a name="footnotes"></a>
<hr>
<p class="orig" lang="en">
<a name="footnote_Temp_268" href="#call_footnote_Temp_268"><sup><small>43</small></sup></a> In actual computational systems, rectangular form is
preferable to polar form most of the time because of <a name="%_idx_2308"></a>roundoff errors
in conversion between rectangular and polar form.  This is why the
complex-number example is unrealistic.  Nevertheless, it provides a
clear illustration of the design of a system using generic operations
and a good introduction to the more substantial systems to be
developed later in this chapter.</p>

<p class="trans" lang="ja">
実際の計算システムでは、直交形式と極形式の間での変換における丸め誤差が原因で、大体いつもは、極形式よりも直交形式の方が好ましい。
これが、複素数の例がなぜ非現実的なのか、という理由だ。
それにもかかわらず、複素数の例は、総称的演算を使うシステムの設計についての明快な解説を示しているし、本章で後に開発すべき、より重要な諸システムへの、良い導入部となっている。
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_269" href="#call_footnote_Temp_269"><sup><small>44</small></sup></a> The arctangent function referred to
<a name="%_idx_2322"></a><a name="%_idx_2324"></a><a name="%_idx_2326"></a>here, computed by Scheme's <tt>atan</tt> procedure,
is defined so as to take two arguments <em>y</em> and <em>x</em> and to return
the angle whose tangent is <em>y</em>/<em>x</em>.  The signs of the arguments
determine the quadrant of the angle.</p>

<p class="trans" lang="ja">
ここで参照されているアークタンジェント関数——Schemeの <tt>atan</tt> という手続きにより計算される——は、<em class="en">y</em> と <em class="en">x</em> という二つの引数をとって、タンジェントが <em class="en">y</em>/<em class="en">x</em> であるような角度を返すように、定義されている。
これら引数の符号により、当該角度の象限が決まる。
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_270" href="#call_footnote_Temp_270"><sup><small>45</small></sup></a> We use the list <tt>(rectangular)</tt>
rather than the symbol <tt>rectangular</tt> to allow for the possibility
of operations with multiple arguments, not all of the same
type.</p>

<p class="trans" lang="ja">
すべてが同じ型だとは限らない複数の引数をとる演算の可能性を見越して、私たちは、<tt>rectangular</tt> という記号よりむしろ、<tt>(rectangular)</tt> というリストを使う。
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_271" href="#call_footnote_Temp_271"><sup><small>46</small></sup></a> The
type the constructors are installed under needn't be a list because
a constructor is always used to make an object of one particular
type.</p>

<p class="trans" lang="ja">
その型のもとにコンストラクタが組み入れられる、という型は、リストでなくてもよい。というのも、コンストラクタは常に、特定の一つの型のオブジェクトを作るために、使われるからだ。
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_272" href="#call_footnote_Temp_272"><sup><small>47</small></sup></a> <tt>Apply-generic</tt> uses the <a name="%_idx_2456"></a>dotted-tail notation described in
exercise <a href="15_sec2_2.html#%_thm_2.20">2.20</a>, because different generic operations
may take different numbers of arguments.  In <tt>apply-generic</tt>, <tt>op</tt> has as its value the first argument to <tt>apply-generic</tt> and
<tt>args</tt> has as its value a list of the remaining arguments.</p>

<p class="trans" lang="ja">
<tt>apply-generic</tt> は、練習問題<a href="15_sec2_2.html#%_thm_2.20">2.20</a>で説明した、ドット付き末尾の記法を使っている。というのも、異なる総称的演算は、異なる数の引数をとるかもしれないからだ。
<tt>apply-generic</tt> の中では、<tt>op</tt> は、その値として、<tt>apply-generic</tt> の第一引数を有し、<tt>args</tt> は、その値として、残りの引数のリストを有する。
</p>

<p class="orig" lang="en">
<tt>Apply-generic</tt> also uses the primitive procedure <a name="%_idx_2458"></a><a name="%_idx_2460"></a><tt>apply</tt>,
which takes two arguments, a procedure and a list.  <tt>Apply</tt>
applies the procedure, using the elements in the list as arguments.
For example,</p>

<p class="trans" lang="ja">
<tt>apply-generic</tt> は、<tt>apply</tt> という原始的手続き——手続きとリストという、二つの引数をとる——も使う。
<tt>apply</tt> は、そのリスト内の要素を引数として用いて、その手続きを適用する。例えば、
</p>

<p class="lisp">(apply + (list 1 2 3 4))</p>

<p class="orig" lang="en">returns 10.</p>

<p class="trans" lang="ja">
は、10を返す。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_276" href="#call_footnote_Temp_276"><sup><small>48</small></sup></a> One
limitation of this organization is it permits only generic procedures
of one argument.</p>

<p class="trans" lang="ja">
この組織化の仕方一つの限界は、この組織化の仕方では、一引数の総称的演算しか許されない点だ。
</p>

</div>

</body>
</html>
