<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<link rel="stylesheet" href="sicp.css" type="text/css">
	<base target="_top">
	<title>SICPç§è¨³: 2.4 æŠ½è±¡çš„ãƒ‡ãƒ¼ã‚¿ã«å¯¾ã™ã‚‹è¤‡æ•°ã®è¡¨ç¾</title>
    <link rel="canonical" href="https://piyo-ko.github.io/SICP/17_sec2_4.html" />
</head>

<body>

<div class="idx-bar">
<nav>
<a href="https://twitter.com/share" class="twitter-share-button" data-lang="ja">ãƒ„ã‚¤ãƒ¼ãƒˆ</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
<span class="status">æ¨æ•²å¾…ã¡</span>
[
<a href="00_cover.html">å…ˆé ­ã¸</a> |
<a href="16_sec2_3.html">å‰ã¸</a> |
<a href="18_sec2_5.html">æ¬¡ã¸</a> | 
<a href="04_toc.html#%_toc_start">ç›®æ¬¡</a> |
<a href="38_index.html#%_index_start">ç´¢å¼•</a>
] [<a href="99_about.html">ã“ã®å¯¾è¨³ç‰ˆã«ã¤ã„ã¦</a> | <a href="../index.html">ãƒ›ãƒ¼ãƒ </a>]
[
Â§<a href="#%_sec_2.4">2.4</a>
ğŸ¨<a href="#%_fig_2.19">2.19</a>
Â§<a href="#%_sec_2.4.1">2.4.1</a>
ğŸ¨<a href="#%_fig_2.20">2.20</a>
Â§<a href="#%_sec_2.4.2">2.4.2</a>
ğŸ¨<a href="#%_fig_2.21">2.21</a>
Â§<a href="#%_sec_2.4.3">2.4.3</a>
ğŸ¨<a href="#%_fig_2.22">2.22</a>
ğŸ“<a href="#%_thm_2.73">2.73</a>
ğŸ“<a href="#%_thm_2.74">2.74</a>
ğŸ“š<a href="#%_sec_Temp_275">&hellip;</a>
ğŸ“<a href="#%_thm_2.75">2.75</a>
ğŸ“<a href="#%_thm_2.76">2.76</a>
<a href="#footnotes">è„šæ³¨</a>
]
</nav>
</div>

<div class="main-txt">

<a name="%_sec_2.4"></a>
<h2 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_2.4">2.4  Multiple Representations for Abstract Data</a></h2>
<h2 class="trans" lang="ja">2.4 æŠ½è±¡çš„ãƒ‡ãƒ¼ã‚¿ã«å¯¾ã™ã‚‹è¤‡æ•°ã®è¡¨ç¾</h2>

<p class="orig" lang="en">
<a name="%_idx_2286"></a><a name="%_idx_2288"></a>
We have introduced data abstraction, a methodology for structuring
systems in such a way that much of a program can be specified
independent of the choices involved in implementing the data objects
that the program manipulates.  For example, we saw in
section <a href="14_sec2_1.html#%_sec_2.1.1">2.1.1</a> how to separate the task of designing a
program that uses rational numbers from the task of implementing
rational numbers in terms of the computer language's primitive
mechanisms for constructing compound data.  The key idea was to erect
an abstraction barrier -- in this case, the selectors and constructors
for rational numbers (<tt>make-rat</tt>, <tt>numer</tt>, <tt>denom</tt>) -- that
isolates the way rational numbers are used from their underlying
representation in terms of list structure.  A similar abstraction
barrier isolates the details of the procedures that perform rational
arithmetic (<tt>add-rat</tt>, <tt>sub-rat</tt>, <tt>mul-rat</tt>, and <tt>div-rat</tt>) from the ``higher-level'' procedures that use rational
numbers.  The resulting program has the structure shown in
figure <a href="14_sec2_1.html#%_fig_2.1">2.1</a>.</p>

<p class="trans" lang="ja">
ç§ãŸã¡ã¯ã€ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ã‚’å°å…¥ã—ãŸâ€”â€”ã¤ã¾ã‚Šã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒæ“ä½œã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å®Ÿè£…ã™ã‚‹ã®ã«ä¼´ã†é¸æŠã¨ã¯é–¢ã‚ã‚Šãªãã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®å¤§éƒ¨åˆ†ã‚’ç´°ã‹ãè¦å®šã§ãã‚‹ã‚ˆã†ãªæ–¹æ³•ã§ã€ã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹é€ åŒ–ã™ã‚‹ãŸã‚ã®æ–¹æ³•è«–ã‚’ã€å°å…¥ã—ãŸã€‚
ãŸã¨ãˆã°ã€è¤‡åˆçš„ãƒ‡ãƒ¼ã‚¿ã‚’æ§‹ç¯‰ã™ã‚‹ãŸã‚ã®ã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿è¨€èªã®åŸå§‹çš„ãªä»•çµ„ã¿ã‚’ä½¿ã£ã¦æœ‰ç†æ•°ã‚’å®Ÿè£…ã™ã‚‹ã¨ã„ã†èª²é¡Œã‹ã‚‰ã€æœ‰ç†æ•°ã‚’ä½¿ã†ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’è¨­è¨ˆã™ã‚‹ã¨ã„ã†èª²é¡Œã‚’åˆ‡ã‚Šé›¢ã™æ–¹æ³•ã‚’ã€<a href="14_sec2_1.html#%_sec_2.1.1">2.1.1</a>ç¯€ã§è¦‹ãŸã€‚
éµã¨ãªã‚‹è€ƒãˆæ–¹ã¯ã€æœ‰ç†æ•°ã®åŸºç¤ã‚’ãªã—ã¦ã„ã‚‹ã€ãƒªã‚¹ãƒˆæ§‹é€ ã‚’ä½¿ã£ãŸè¡¨ç¾ã‹ã‚‰ã€æœ‰ç†æ•°ã®ä½¿ã‚ã‚Œæ–¹ã‚’éš”é›¢ã™ã‚‹ã€æŠ½è±¡åŒ–ã®é˜²å£â€”â€”ã“ã®å ´åˆã ã¨ã€æœ‰ç†æ•°ç”¨ã®ã‚»ãƒ¬ã‚¯ã‚¿ã¨ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ (<tt>make-rat</tt> ã¨ <tt>numer</tt> ã¨ <tt>denom</tt>) â€”â€”ã‚’ç¯‰ãã“ã¨ã ã£ãŸã€‚
åŒæ§˜ã®æŠ½è±¡åŒ–ã®é˜²å£ãŒã€æœ‰ç†æ•°ã®ç®—è¡“æ¼”ç®—ã‚’å®Ÿè¡Œã™ã‚‹æ‰‹ç¶šã (<tt>add-rat</tt> ã¨ <tt>sub-rat</tt> ã¨ <tt>mul-rat</tt> ã¨ <tt>div-rat</tt>) ã®è©³ç´°ã‚’ã€æœ‰ç†æ•°ã‚’ä½¿ç”¨ã™ã‚‹ã€Œã‚ˆã‚Šé«˜ã„æ°´æº–ã®ã€æ‰‹ç¶šãã‹ã‚‰ã€éš”é›¢ã—ã¦ã„ã‚‹ã€‚
çµæœã¨ã—ã¦ç”Ÿã˜ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€å›³<a href="14_sec2_1.html#%_fig_2.1">2.1</a>ã«ç¤ºã™æ§‹é€ ã‚’æœ‰ã™ã‚‹ã€‚
</p>

<p class="orig" lang="en">
These data-abstraction barriers are powerful tools for controlling
complexity.  By isolating the underlying representations of data
objects, we can divide the task of designing a large program into
smaller tasks that can be performed separately.  But this kind of data
abstraction is not yet powerful enough, because it may not always make
sense to speak of ``the underlying representation'' for a data object.</p>

<p class="trans" lang="ja">
ã“ã‚Œã‚‰ã®ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ã®é˜²å£ã¯ã€è¤‡é›‘ã•ã‚’æŠ‘ãˆã‚‹ãŸã‚ã®å¼·åŠ›ãªæ‰‹ç«‹ã¦ã§ã‚ã‚‹ã€‚
ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã€æ ¹åº•ã«ã‚ã‚‹è¡¨ç¾ã‚’éš”é›¢ã™ã‚‹ã“ã¨ã§ã€å¤§ããªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’è¨­è¨ˆã™ã‚‹ã¨ã„ã†èª²é¡Œã‚’ã€åˆ¥ã€…ã«å®Ÿè¡Œã§ãã‚‹ã€ã‚ˆã‚Šå°ã•ãªã„ãã¤ã‹ã®èª²é¡Œã¸ã¨ã€åˆ†å‰²ã§ãã‚‹ã®ã ã€‚
ã—ã‹ã—ã€ã“ã®ç¨®ã®ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ã¯ã€ã¾ã ååˆ†ã«å¼·åŠ›ã§ã¯ãªã„ã€‚ã¨ã„ã†ã®ã‚‚ã€ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã€Œæ ¹åº•ã«ã‚ã‚‹è¡¨ç¾ã€ã«ã¤ã„ã¦èªã‚‹ã“ã¨ãŒã€å¸¸ã«æ„å‘³ã‚’æŒã¤ã¨ã¯é™ã‚‰ãªã„ã‹ã‚‰ã ã€‚
</p>

<p class="orig" lang="en">
For one thing, there might be more than one useful representation for
a data object, and we might like to design systems that can deal with
multiple representations.  To take a simple example, complex numbers
may be represented in two almost equivalent ways: in rectangular form
(real and imaginary parts) and in polar form (magnitude and angle).
Sometimes rectangular form is more appropriate and sometimes polar
form is more appropriate.  Indeed, it is perfectly plausible to
imagine a system in which complex numbers are represented in both
ways, and in which the procedures for manipulating complex numbers work
with either representation.</p>

<p class="trans" lang="ja">
ç†ç”±ã®ä¸€ã¤ã¯ã€ã‚ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãŸã‚ã®æœ‰ç”¨ãªè¡¨ç¾ãŒã€ä¸€ã¤ã‚ˆã‚Šå¤šãå­˜åœ¨ã™ã‚‹ã‹ã‚‚ã—ã‚Œãšã€ãã®ãŸã‚ã€è¤‡æ•°ã®è¡¨ç¾ã‚’æ‰±ãˆã‚‹ã‚·ã‚¹ãƒ†ãƒ ã‚’è¨­è¨ˆã—ãŸã„ã€ã¨ç§ãŸã¡ãŒæ€ã†ã‹ã‚‚ã—ã‚Œãªã„ã€ã¨ã„ã†ã“ã¨ã§ã‚ã‚‹ã€‚
ç°¡å˜ãªä¾‹ã‚’ã¨ã‚‹ã¨ã€è¤‡ç´ æ•°ã¯ã€äºŒã¤ã®ã»ã¨ã‚“ã©ç­‰ä¾¡ãªæ–¹æ³•ã§â€”â€”ã¤ã¾ã‚Šã€ç›´äº¤å½¢å¼ (å®Ÿéƒ¨ã¨è™šéƒ¨) ã¨æ¥µå½¢å¼ (å¤§ãã•ã¨è§’åº¦) ã§â€”â€”è¡¨ç¾ã•ã‚Œã†ã‚‹ã€‚
ã¨ãã«ã¯ã€ç›´äº¤å½¢å¼ã®æ–¹ãŒã‚ˆã‚Šé©åˆ‡ã§ã‚ã‚Šã€ã¨ãã«ã¯ã€æ¥µå½¢å¼ã®æ–¹ãŒã‚ˆã‚Šé©åˆ‡ã§ã‚ã‚‹ã€‚
è¤‡ç´ æ•°ãŒåŒæ–¹ã®ã‚„ã‚Šæ–¹ã§è¡¨ç¾ã•ã‚Œã¦ã„ã¦ã€ã‹ã¤ã€è¤‡ç´ æ•°ã‚’æ“ä½œã™ã‚‹ãŸã‚ã®æ‰‹ç¶šããŒã€ã©ã¡ã‚‰ã®è¡¨ç¾ã‚’ä½¿ã£ã¦ã‚‚å‹•ä½œã™ã‚‹ã€ã¨ã„ã£ãŸã‚·ã‚¹ãƒ†ãƒ ã‚’æƒ³åƒã™ã‚‹ã“ã¨ã¯ã€å®Ÿéš›ã€å®Œç’§ã«å°¤ã‚‚ã‚‰ã—ã„ã“ã¨ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
More importantly, programming systems are often designed by many
people working over extended periods of time, subject to requirements
that change over time.  In such an environment, it is simply not
possible for everyone to agree in advance on choices of data
representation.  So in addition to the data-abstraction barriers that
isolate representation from use, we need abstraction barriers that
isolate different design choices from each other and permit different
choices to coexist in a single program.  Furthermore, since large
programs are often created by combining pre-existing modules that were
designed in isolation, we need conventions that permit programmers to
incorporate modules into larger systems <a name="%_idx_2290"></a><em>additively</em>, that is,
without having to redesign or reimplement these modules.</p>

<p class="trans" lang="ja">
ã•ã‚‰ã«é‡è¦ãªã“ã¨ã«ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ãƒ»ã‚·ã‚¹ãƒ†ãƒ ã¯ã€ã—ã°ã—ã°ã€é•·æœŸé–“ã«ã‚ãŸã£ã¦åƒãå¤§å‹¢ã®äººãŸã¡ã«ã‚ˆã£ã¦ã€è¨­è¨ˆã•ã‚Œã‚‹ã®ã â€”â€”ã—ã‹ã‚‚ã€æ™‚é–“ã¨ã¨ã‚‚ã«å¤‰åŒ–ã™ã‚‹è¦ä»¶ã«å¾“ã£ã¦ã€‚
ãã‚“ãªç’°å¢ƒã§ã¯ã€å…¨å“¡ãŒå‰ã‚‚ã£ã¦ãƒ‡ãƒ¼ã‚¿è¡¨ç¾ã®é¸æŠã«ã¤ã„ã¦åŒæ„ã™ã‚‹ã“ã¨ã¯ã€å˜ç´”ã«ä¸å¯èƒ½ã ã€‚
ã ã‹ã‚‰ã€ä½¿ç”¨ã‹ã‚‰è¡¨ç¾ã‚’éš”é›¢ã™ã‚‹ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ã®é˜²å£ã«åŠ ãˆã¦ã€ã•ã‚‰ã«ã€ç•°ãªã‚‹è¨­è¨ˆã®é¸æŠè‚¢åŒå£«ã‚’ãŠäº’ã„ã‹ã‚‰éš”é›¢ã—ã¤ã¤ã‚‚ç•°ãªã‚‹é¸æŠè‚¢ãŒå˜ä¸€ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ä¸­ã«å…±å­˜ã™ã‚‹ã“ã¨ã‚’è¨±ã™ã‚ˆã†ãªæŠ½è±¡åŒ–ã®é˜²å£ã‚‚ã€å¿…è¦ã§ã‚ã‚‹ã€‚
ã•ã‚‰ã«ã€å¤§ããªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã—ã°ã—ã°ã€éš”é›¢ã•ã‚Œã¦è¨­è¨ˆã•ã‚ŒãŸæ—¢å­˜ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åŒå£«ã‚’çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ä½œæˆã•ã‚Œã‚‹ãŸã‚ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒãŒãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚ˆã‚Šå¤§ããªã‚·ã‚¹ãƒ†ãƒ ã«<em>åŠ æ³•çš„ã«</em>â€”â€”ã¤ã¾ã‚Šãã‚Œã‚‰ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è¨­è¨ˆã—ãªãŠã—ãŸã‚Šã€ã‚ã‚‹ã„ã¯ã€å®Ÿè£…ã—ãªãŠã—ãŸã‚Šã™ã‚‹å¿…è¦ãªã—ã«â€”â€”çµ„ã¿è¾¼ã‚€ã“ã‚€ã“ã¨ã‚’è¨±ã™ã‚ˆã†ãªç¿’æ…£ã‚‚å¿…è¦ã ã€‚
</p>

<p class="orig" lang="en">
In this section, we will learn how to cope with data that may be
represented in different ways by different parts of a program.  This
requires constructing <a name="%_idx_2292"></a><a name="%_idx_2294"></a><em>generic procedures</em> -- procedures that can
operate on data that may be represented in more than one way.  Our
main technique for building generic procedures will be to work in terms
of data objects that have <a name="%_idx_2296"></a><em>type tags</em>, that is, data objects
that include explicit information about how they are to be processed.
We will also discuss <a name="%_idx_2298"></a><em>data-directed</em> programming, a powerful and
convenient implementation strategy for additively assembling systems
with generic operations.</p>

<p class="trans" lang="ja">
æœ¬ç¯€ã§ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ç•°ãªã‚‹éƒ¨åˆ†ã«ã‚ˆã‚Šç•°ãªã‚‹æ–¹æ³•ã§è¡¨ç¾ã•ã‚Œã‚‹å¯èƒ½æ€§ã®ã‚ã‚‹ãƒ‡ãƒ¼ã‚¿ã¸ã®å¯¾å‡¦ã®ä»•æ–¹ã‚’å­¦ã¼ã†ã€‚
ã“ã‚Œã«ã¯ã€<em>ç·ç§°çš„æ‰‹ç¶šã</em>â€”â€”ã²ã¨ã¤ã‚ˆã‚Šå¤šã„æ–¹æ³•ã§è¡¨ç¾ã•ã‚Œã‚‹å¯èƒ½æ€§ã®ã‚ã‚‹ãƒ‡ãƒ¼ã‚¿ä¸Šã§å‹•ä½œã§ãã‚‹æ‰‹ç¶šãâ€”â€”ã‚’æ§‹ç¯‰ã™ã‚‹ã“ã¨ãŒå¿…è¦ã ã€‚
ç·ç§°çš„æ‰‹ç¶šãã‚’æ§‹ç¯‰ã™ã‚‹ãŸã‚ã®ä¸»è¦ãªæŠ€æ³•ã¯ã€<em>å‹ã‚¿ã‚°</em>ã®ã‚ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆâ€”â€”ã¤ã¾ã‚Šã€ã©ã†å‡¦ç†ã™ã¹ãã‚‚ã®ãªã®ã‹ã«ã¤ã„ã¦ã®æ˜ç¤ºçš„æƒ…å ±ã‚’å«ã‚€ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆâ€”â€”ã‚’ä½¿ã£ã¦ä½œæ¥­ã™ã‚‹ã“ã¨ã§ã‚ã‚ã†ã€‚
<em>ãƒ‡ãƒ¼ã‚¿æŒ‡å‘</em>ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°â€”â€”ç·ç§°çš„ãªæ¼”ç®—ã‚’ç”¨ã„ã¦ã‚·ã‚¹ãƒ†ãƒ ã‚’åŠ æ³•çš„ã«çµ„ã¿ç«‹ã¦ã‚‹ãŸã‚ã®ã€å¼·åŠ›ã§ä¾¿åˆ©ãªå®Ÿè£…æˆ¦ç•¥â€”â€”ã«ã¤ã„ã¦ã‚‚ã€è­°è«–ã—ã‚ˆã†ã€‚
</p>

<p class="orig" lang="en">
We begin with the simple complex-number example. We will see how
type tags and data-directed style enable us to design separate
rectangular and polar representations for complex numbers while
maintaining the notion of an abstract ``complex-number'' data object.
<a name="%_idx_2300"></a><a name="%_idx_2302"></a>We will accomplish this by defining arithmetic procedures for complex
numbers (<tt>add-complex</tt>, <tt>sub-complex</tt>, <tt>mul-complex</tt>, and
<tt>div-complex</tt>) in terms of generic selectors that access parts of
a complex number independent of how the number is represented.  The
resulting complex-number system, as shown in
figure <a href="#%_fig_2.19">2.19</a>, contains two different kinds of
<a name="%_idx_2304"></a>abstraction barriers.  The ``horizontal'' abstraction barriers play
the same role as the ones in
figure <a href="14_sec2_1.html#%_fig_2.1">2.1</a>.  They isolate ``higher-level''
operations from ``lower-level'' representations.  In addition, there
is a ``vertical'' barrier that gives us the ability to separately
design and install alternative representations.</p>

<p class="trans" lang="ja">
å˜ç´”ãªè¤‡ç´ æ•°ã®ä¾‹ã‹ã‚‰å§‹ã‚ã‚‹ã€‚
æŠ½è±¡çš„ãªã€Œè¤‡ç´ æ•°ã®ã€ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã„ã†æ¦‚å¿µã‚’ä¿ã¡ãªãŒã‚‰ã‚‚ã€è¤‡ç´ æ•°ã®ã€ç›´äº¤è¡¨ç¾ã¨æ¥µè¡¨ç¾ã¨ã„ã†åˆ¥ã€…ã®è¡¨ç¾ã‚’è¨­è¨ˆã™ã‚‹ã“ã¨ãŒã€å‹ã‚¿ã‚°ã¨ãƒ‡ãƒ¼ã‚¿æŒ‡å‘ã‚¹ã‚¿ã‚¤ãƒ«ã¨ã«ã‚ˆã£ã¦ã€ã„ã‹ã«ã—ã¦å¯èƒ½ã¨ãªã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’è¦‹ã¦ã„ã“ã†ã€‚
ãã®æ•°ãŒã©ã†è¡¨ç¾ã•ã‚Œã¦ã„ã‚‹ã®ã‹ã¨ã„ã†ã“ã¨ã«ã¯é–¢ä¿‚ãªãã€è¤‡ç´ æ•°ã®æ§‹æˆéƒ¨åˆ†ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã‚ˆã†ãªã€ç·ç§°çš„ãªã‚»ãƒ¬ã‚¯ã‚¿ã‚’ä½¿ã£ã¦ã€è¤‡ç´ æ•°ç”¨ã®ç®—è¡“æ‰‹ç¶šã (<tt>add-complex</tt> ã¨ <tt>sub-complex</tt> ã¨ <tt>mul-complex</tt> ã¨ <tt>div-complex</tt>) ã‚’å®šç¾©ã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€ä»¥ä¸Šã®ã‚ˆã†ãªè¨­è¨ˆã‚’é”æˆã—ã‚ˆã†ã€‚
çµæœã¨ã—ã¦ã§ãã‚ãŒã‚‹è¤‡ç´ æ•°ã®ã‚·ã‚¹ãƒ†ãƒ ã¯ã€å›³<a href="#%_fig_2.19">2.19</a>ã«ç¤ºã™ã‚ˆã†ã«ã€äºŒç¨®é¡ã®ç•°ãªã‚‹æŠ½è±¡åŒ–ã®é˜²å£ã‚’å«ã‚€ã€‚
ã€Œæ¨ªæ–¹å‘ã®ã€æŠ½è±¡åŒ–ã®é˜²å£ã¯ã€å›³<a href="14_sec2_1.html#%_fig_2.1">2.1</a>ã®è€…ã¨åŒæ§˜ã®å½¹ç›®ã‚’æœãŸã™ã€‚
ã“ã‚Œã‚‰ã¯ã€ã€Œä½ãƒ¬ãƒ™ãƒ«ã®ã€è¡¨ç¾ã‹ã‚‰ã€ã€Œé«˜ãƒ¬ãƒ™ãƒ«ã®ã€æ¼”ç®—ã‚’éš”é›¢ã™ã‚‹ã€‚
ã•ã‚‰ã«ã€ä»£æ›¿è¡¨ç¾åŒå£«ã‚’åˆ¥ã€…ã«è¨­è¨ˆã—ã¦ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã™ã‚‹ã“ã¨ã‚’å¯èƒ½ã«ã—ã¦ãã‚Œã‚‹ã€ã€Œç¸¦æ–¹å‘ã®ã€é˜²å£ãŒã‚ã‚‹ã€‚
</p>

<figure>
<a name="%_fig_2.19"></a>
<img src="ch2-Z-G-54.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 2.19:</b>  Data-abstraction barriers in the complex-number system.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³2.19:</b> è¤‡ç´ æ•°ã‚·ã‚¹ãƒ†ãƒ ã«ãŠã‘ã‚‹ã€ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ã®é˜²å£</figcaption>
</figure>

<p class="orig" lang="en">
In section <a href="18_sec2_5.html#%_sec_2.5">2.5</a> we will show how to use
type tags and data-directed style to develop a generic arithmetic
package.  This provides procedures (<tt>add</tt>, <tt>mul</tt>, and so on)
that can be used to manipulate all sorts of ``numbers'' and can be
easily extended when a new kind of number is needed.
In section <a href="18_sec2_5.html#%_sec_2.5.3">2.5.3</a>, we'll show how to use generic
arithmetic in a system that performs symbolic algebra.</p>

<p class="trans" lang="ja">
ç·ç§°çš„ç®—è¡“ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’é–‹ç™ºã™ã‚‹ãŸã‚ã«ã€ã©ã®ã‚ˆã†ã«ã—ã¦å‹ã‚¿ã‚°ã¨ãƒ‡ãƒ¼ã‚¿æŒ‡å‘ã‚¹ã‚¿ã‚¤ãƒ«ã‚’ä½¿ã†ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’<a href="18_sec2_5.html#%_sec_2.5">2.5</a>ç¯€ã§ç¤ºãã†ã€‚
ã“ã®ã¨ãã«ã€ã‚ã‚‰ã‚†ã‚‹ç¨®é¡ã®ã€Œæ•°ã€ã‚’æ“ä½œã™ã‚‹ã®ã«ä½¿ãˆã¦ã€ã‹ã¤ã€æ–°ãŸãªç¨®é¡ã®æ•°ãŒå¿…è¦ã«ãªã£ãŸã‚‰ç°¡å˜ã«æ‹¡å¼µã§ãã‚‹ã‚ˆã†ãªã€è«¸æ‰‹ç¶šã (<tt>add</tt> ã‚„ <tt>mul</tt> ãªã©) ã‚’ç¤ºã™ã€‚
<a href="18_sec2_5.html#%_sec_2.5.3">2.5.3</a>ç¯€ã§ã¯ã€è¨˜å·ä»£æ•°ã‚’å®Ÿè¡Œã™ã‚‹ã‚·ã‚¹ãƒ†ãƒ ã«ãŠã„ã¦ã©ã®ã‚ˆã†ã«ç·ç§°çš„ç®—è¡“ã‚’ä½¿ã†ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’ç¤ºãã†ã€‚
</p>

<a name="%_sec_2.4.1"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_2.4.1">2.4.1  Representations for Complex Numbers</a></h3>
<h3 class="trans" lang="ja">2.4.1 è¤‡ç´ æ•°ã®è¡¨ç¾</h3>

<p class="orig" lang="en">
<a name="%_idx_2306"></a>We will develop a system that performs arithmetic operations on
complex numbers as a simple but unrealistic example of a program that
uses generic operations.  We begin by discussing two plausible
representations for complex numbers as ordered pairs: rectangular form
(real part and imaginary part) and polar form (magnitude and
angle).<a name="call_footnote_Temp_268" href="#footnote_Temp_268"><sup><small>43</small></sup></a>  Section <a href="#%_sec_2.4.2">2.4.2</a>
will show how both representations can be made to coexist in a single
system through the use of type tags and generic operations.</p>

<p class="trans" lang="ja">
ç·ç§°çš„æ¼”ç®—ã‚’ä½¿ã†ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ã€ç°¡æ½”ã ãŒéç¾å®Ÿçš„ãªä¾‹ã¨ã—ã¦ã€è¤‡ç´ æ•°ä¸Šã®ç®—è¡“æ¼”ç®—ã‚’è¡Œã†ã‚·ã‚¹ãƒ†ãƒ ã‚’é–‹ç™ºã—ã‚ˆã†ã€‚
é †åºä»˜ãã®å¯¾ã¨ã—ã¦ã®ã€è¤‡ç´ æ•°ã®äºŒã¤ã®ã‚‚ã£ã¨ã‚‚ã‚‰ã—ã„è¡¨ç¾â€”â€”ç›´äº¤å½¢å¼ (å®Ÿéƒ¨ã¨è™šéƒ¨) ã¨ã€æ¥µå½¢å¼ (å¤§ãã•ã¨è§’åº¦) â€”â€”ã«ã¤ã„ã¦è­°è«–ã™ã‚‹ã“ã¨ã‹ã‚‰å§‹ã‚ã‚‹<a href="#footnote_Temp_268"><sup><small>43</small></sup></a>ã€‚
<a href="#%_sec_2.4.2">2.4.2</a>ç¯€ã§ã¯ã€å‹ã‚¿ã‚°ã¨ç·ç§°çš„æ¼”ç®—ã‚’ä½¿ã†ã“ã¨ã‚’é€šã˜ã¦ã€åŒæ–¹ã®è¡¨ç¾ã‚’ã©ã®ã‚ˆã†ã«ã—ã¦å˜ä¸€ã®ã‚·ã‚¹ãƒ†ãƒ å†…ã«å…±å­˜ã•ã›ã‚‰ã‚Œã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’ç¤ºãã†ã€‚
</p>

<p class="orig" lang="en">
Like rational numbers, complex numbers are naturally represented as
ordered pairs.  The set of complex numbers can be thought of as a
two-dimensional space with two orthogonal axes, the ``real'' axis and
the ``imaginary'' axis. (See figure <a href="#%_fig_2.20">2.20</a>.)  From
this point of view, the complex number <em>z</em> = <em>x</em> + <em>i</em><em>y</em> (where <em>i</em><sup>2</sup>  =  - 1)
can be thought of as the point in the plane whose real coordinate is <em>x</em> and whose
imaginary coordinate is <em>y</em>.  Addition of complex numbers reduces in
this representation to addition of coordinates:</p>

<p class="trans" lang="ja">
æœ‰ç†æ•°ã¨åŒæ§˜ã«ã€è¤‡ç´ æ•°ã¯ã€å½“ç„¶ã«é †åºä»˜ãã®å¯¾ã¨ã—ã¦è¡¨ç¾ã•ã‚Œã‚‹ã€‚
è¤‡ç´ æ•°ã®é›†åˆã¯ã€äºŒã¤ã®ç›´äº¤ã™ã‚‹è»¸â€”â€”ã¤ã¾ã‚Šã€ã€Œå®Ÿã€è»¸ã¨ã€Œè™šã€è»¸â€”â€”ã®ã‚ã‚‹äºŒæ¬¡å…ƒç©ºé–“ã ã¨è¦‹ãªã›ã‚‹ã€‚
(å›³<a href="#%_fig_2.20">2.20</a>ã‚’è¦‹ã‚ˆã€‚)
ã“ã®è¦³ç‚¹ã‹ã‚‰ã¯ã€
<span class="math"><em class="en">z</em> = <em class="en">x</em> + <em class="en">i</em><em class="en">y</em></span>
ã¨ã„ã†è¤‡ç´ æ•° (ã“ã“ã§
<span class="math"><em class="en">i</em><sup>2</sup>  =  &minus;1</span> 
ã§ã‚ã‚‹) ã¯ã€ã“ã®å¹³é¢ã«ãŠã‘ã‚‹ã€å®Ÿåº§æ¨™ãŒ <em class="en">x</em> ã§è™šåº§æ¨™ãŒ <em class="en">y</em> ã®ç‚¹ã§ã‚ã‚‹ã€ã¨è¦‹ãªã›ã‚‹ã€‚
è¤‡ç´ æ•°åŒå£«ã®åŠ ç®—ã¯ã€ã“ã®è¡¨ç¾ã§ã¯ã€åº§æ¨™åŒå£«ã®åŠ ç®—ã«å¸°ç€ã™ã‚‹ã€‚
</p>

<figure>
<img src="ch2-Z-G-55.gif" border="0"><br>
<img src="ch2-Z-G-56.gif" border="0">
</figure>


<p class="orig" lang="en">
When multiplying complex numbers, it is more natural to think in terms
of representing a complex number in polar form, as a magnitude and an
angle (<em>r</em> and <em>A</em> in figure <a href="#%_fig_2.20">2.20</a>).
The product of two complex numbers is the vector obtained by
stretching one complex number by the length of the other and then
rotating it through the angle of the other:</p>

<p class="trans" lang="ja">
è¤‡ç´ æ•°åŒå£«ã‚’æ›ã‘ã‚‹ã¨ãã«ã¯ã€è¤‡ç´ æ•°ã‚’æ¥µå½¢å¼ã§â€”â€”å¤§ãã•ã¨è§’åº¦ (å›³<a href="#%_fig_2.20">2.20</a>ã® <em class="en">r</em> ã¨ <em class="en">A</em>) ã¨ã—ã¦â€”â€”è¡¨ç¾ã™ã‚‹ã“ã¨ã‚’è€ƒãˆã‚‹ã®ãŒã€ã‚ˆã‚Šè‡ªç„¶ã§ã‚ã‚‹ã€‚
äºŒã¤ã®è¤‡ç´ æ•°ã®ç©ã¯ã€ä¸€æ–¹ã®è¤‡ç´ æ•°ã‚’ã€ä»–æ–¹ã®é•·ã•å€ã«å¼•ãä¼¸ã°ã—ã¦ã‹ã‚‰ã€ä»–æ–¹ã®è§’åº¦ã®ã¶ã‚“ã ã‘å›è»¢ã•ã›ã‚‹ã“ã¨ã§å¾—ã‚‰ã‚Œã‚‹ã€ãƒ™ã‚¯ãƒˆãƒ«ã§ã‚ã‚‹ã€‚
</p>

<figure>
<img src="ch2-Z-G-57.gif" border="0"><br>
<img src="ch2-Z-G-58.gif" border="0">
</figure>

<p class="orig" lang="en">
Thus, there are two different representations for complex numbers,
which are appropriate for different operations.  Yet, from the
viewpoint of someone writing a program that uses complex numbers, the
principle of data abstraction suggests that all the operations for
manipulating complex numbers should be available regardless of which
representation is used by the computer.  For example, it is often
useful to be able to find the magnitude of a complex number that is
specified by rectangular coordinates.  Similarly, it is often useful
to be able to determine the real part of a complex number that is
specified by polar coordinates.</p>

<p class="trans" lang="ja">
ã“ã®ã‚ˆã†ã«ã€è¤‡ç´ æ•°ã«ã¯äºŒã¤ã®ç•°ãªã‚‹è¡¨ç¾ãŒã‚ã‚Šã€ãã‚Œã‚‰ã¯ç•°ãªã‚‹æ¼”ç®—ã«é©ã—ã¦ã„ã‚‹ã€‚
ãã‚Œã§ã‚‚ã‚„ã¯ã‚Šã€è¤‡ç´ æ•°ã‚’ä½¿ã†ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ãèª°ã‹ã€ã¨ã„ã†è¦³ç‚¹ã‹ã‚‰ã™ã‚‹ã¨ã€è¤‡ç´ æ•°ã‚’æ“ä½œã™ã‚‹ãŸã‚ã®ã™ã¹ã¦ã®æ¼”ç®—ã¯ã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãŒã©ã®è¡¨ç¾ã‚’ä½¿ã£ã¦ã„ã‚‹ã®ã‹ã«é–¢ä¿‚ãªãåˆ©ç”¨å¯èƒ½ã§ã‚ã‚‹ã¹ãã ã€ã¨ã„ã†ã“ã¨ã‚’ã€ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ã®åŸå‰‡ã¯ç¤ºå”†ã—ã¦ã„ã‚‹ã€‚
ãŸã¨ãˆã°ã€ç›´äº¤åº§æ¨™ã§æŒ‡å®šã•ã‚ŒãŸè¤‡ç´ æ•°ã®å¤§ãã•ã‚’çŸ¥ã‚‹ã“ã¨ãŒã§ãã‚‹ã€ã¨ã„ã†ã“ã¨ãŒæœ‰ç›Šãªå ´åˆãŒã€ã‚ˆãã‚ã‚‹ã€‚
åŒæ§˜ã«ã€æ¥µåº§æ¨™ã§æŒ‡å®šã•ã‚ŒãŸè¤‡ç´ æ•°ã®å®Ÿéƒ¨ã‚’ç‰¹å®šã§ãã‚‹ã€ã¨ã„ã†ã“ã¨ãŒæœ‰ç›Šãªå ´åˆãŒã€ã‚ˆãã‚ã‚‹ã€‚
</p>

<a name="%_fig_2.20"></a>
<figure>
<img src="ch2-Z-G-59.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 2.20:</b>  Complex numbers as points in the plane.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³2.20:</b> å¹³é¢å†…ã®ç‚¹ã¨ã—ã¦ã®è¤‡ç´ æ•°</figcaption>
</figure>

<p class="orig" lang="en">
To design such a system, we can follow the same <a name="%_idx_2310"></a>data-abstraction
strategy we followed in designing the rational-number package in
section <a href="14_sec2_1.html#%_sec_2.1.1">2.1.1</a>.  Assume that the operations on complex numbers are
implemented in terms of four selectors: <tt>real-part</tt>,
<tt>imag-part</tt>, <tt>magnitude</tt>, and <tt>angle</tt>.  Also assume that
we have two procedures for constructing complex numbers: <tt>make-from-real-imag</tt> returns a complex number with specified real and
imaginary parts, and <tt>make-from-mag-ang</tt> returns a complex number with
specified magnitude and angle.  These procedures have the property that,
for any complex number <tt>z</tt>, both</p>

<p class="trans" lang="ja">
ãã†ã„ã†ã‚·ã‚¹ãƒ†ãƒ ã‚’è¨­è¨ˆã™ã‚‹ãŸã‚ã«ã€ç§ãŸã¡ã¯ã€<a href="14_sec2_1.html#%_sec_2.1.1">2.1.1</a>ç¯€ã§æœ‰ç†æ•°ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’è¨­è¨ˆã™ã‚‹éš›ã«ã—ãŸãŒã£ãŸã®ã¨åŒã˜ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–æˆ¦ç•¥ã«ã€ã—ãŸãŒã†ã“ã¨ãŒã§ãã‚‹ã€‚
è¤‡ç´ æ•°ä¸Šã®æ¼”ç®—ãŒã€å››ã¤ã®ã‚»ãƒ¬ã‚¯ã‚¿â€”â€”<tt>real-part</tt> ã¨ <tt>imag-part</tt> ã¨ <tt>magnitude</tt> ã¨ <tt>angle</tt>â€”â€”ã‚’ç”¨ã„ã¦å®Ÿè£…ã•ã‚Œã‚‹ã€ã¨ä»®å®šã›ã‚ˆã€‚
ã¾ãŸã€è¤‡ç´ æ•°ã‚’æ§‹ç¯‰ã™ã‚‹ãŸã‚ã®äºŒã¤ã®æ‰‹ç¶šããŒã‚ã‚‹â€”â€”ã™ãªã‚ã¡ã€<tt>make-from-real-imag</tt> ã¯ã€æŒ‡å®šã•ã‚ŒãŸå®Ÿéƒ¨ã¨è™šéƒ¨ã‚’æœ‰ã™ã‚‹è¤‡ç´ æ•°ã‚’è¿”ã—ã€<tt>make-from-mag-ang</tt> ã¯ã€æŒ‡å®šã•ã‚ŒãŸå¤§ãã•ã¨è§’åº¦ã‚’æœ‰ã™ã‚‹è¤‡ç´ æ•°ã‚’è¿”ã™â€”â€”ã¨ã€ä»®å®šã›ã‚ˆã€‚
ã“ã‚Œã‚‰ã®æ‰‹ç¶šãã«ã¯ã€ä»»æ„ã®è¤‡ç´ æ•° <tt>z</tt> ã«å¯¾ã—ã¦ã€ä»¥ä¸‹ã®æ€§è³ªãŒã‚ã‚‹ã€‚ã™ãªã‚ã¡ã€
</p>


<p class="lisp">(make-from-real-imag (real-part z) (imag-part z))</p>

<p class="orig" lang="en">and</p>

<p class="trans" lang="ja">
ãŠã‚ˆã³
</p>

<p class="lisp">(make-from-mag-ang (magnitude z) (angle z))</p>

<p class="orig" lang="en">
produce complex numbers that are equal to <tt>z</tt>.
</p>

<p class="trans" lang="ja">
ã®åŒæ–¹ã¨ã‚‚ã€<tt>z</tt> ã«ç­‰ã—ã„è¤‡ç´ æ•°ã‚’ä½œã‚Šå‡ºã™ã€‚
</p>

<p class="orig" lang="en">
Using these constructors and selectors, we can implement
arithmetic on complex numbers using the ``abstract data'' specified by
the constructors and selectors, just as we did for rational numbers in
section <a href="14_sec2_1.html#%_sec_2.1.1">2.1.1</a>.  As shown in the formulas above, we can add and
subtract complex numbers in terms of real and imaginary parts while
multiplying and dividing complex numbers in terms of magnitudes and
angles:</p>

<p class="trans" lang="ja">
ã“ã‚Œã‚‰ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¨ã‚»ãƒ¬ã‚¯ã‚¿ã‚’ä½¿ã£ã¦ã€ç§ãŸã¡ã¯ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¨ã‚»ãƒ¬ã‚¯ã‚¿ã«ã‚ˆã‚ŠæŒ‡å®šã•ã‚Œã‚‹ã€ŒæŠ½è±¡çš„ãƒ‡ãƒ¼ã‚¿ã€ã‚’ç”¨ã„ãŸè¤‡ç´ æ•°ä¸Šã®ç®—è¡“æ¼”ç®—ã‚’ã€<a href="14_sec2_1.html#%_sec_2.1.1">2.1.1</a>ç¯€ã§æœ‰ç†æ•°ã«å¯¾ã—ã¦è¡Œã£ãŸã®ã¨ã¡ã‚‡ã†ã©åŒã˜ã‚ˆã†ã«ã—ã¦ã€å®Ÿè£…ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
ä¸Šè¨˜ã®å¼ã«ç¤ºã—ãŸã‚ˆã†ã«ã€å®Ÿéƒ¨ã¨è™šéƒ¨ã‚’ä½¿ã£ã¦è¤‡ç´ æ•°ã‚’è¶³ã—ãŸã‚Šå¼•ã„ãŸã‚Šã™ã‚‹ä¸€æ–¹ã§ã€å¤§ãã•ã¨è§’åº¦ã‚’ä½¿ã£ã¦è¤‡ç´ æ•°ã‚’æ›ã‘ãŸã‚Šå‰²ã£ãŸã‚Šã™ã‚‹ã“ã¨ãŒã€å¯èƒ½ã§ã‚ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_2312"></a>(define (add-complex z1 z2)
  (make-from-real-imag (+ (real-part z1) (real-part z2))
                       (+ (imag-part z1) (imag-part z2))))
<a name="%_idx_2314"></a>(define (sub-complex z1 z2)
  (make-from-real-imag (- (real-part z1) (real-part z2))
                       (- (imag-part z1) (imag-part z2))))
<a name="%_idx_2316"></a>(define (mul-complex z1 z2)
  (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                     (+ (angle z1) (angle z2))))
<a name="%_idx_2318"></a>(define (div-complex z1 z2)
  (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                     (- (angle z1) (angle z2))))
</p>

<p class="orig" lang="en">
To complete the complex-number package, we must choose a
representation and we must implement the constructors and selectors in
terms of primitive numbers and primitive list structure.
There are two obvious ways to do this: We can represent a complex
number in ``rectangular form'' as a pair (real part, imaginary part)
or in ``polar form'' as a pair (magnitude, angle).  Which shall we
choose?</p>

<p class="trans" lang="ja">
è¤‡ç´ æ•°ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’å®Œæˆã•ã›ã‚‹ã«ã¯ã€è¡¨ç¾ã‚’é¸ã°ã­ã°ãªã‚‰ãªã„ã—ã€åŸå§‹çš„ãªæ•°ã¨åŸå§‹çš„ãªãƒªã‚¹ãƒˆæ§‹é€ ã‚’ä½¿ã£ã¦ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¨ã‚»ãƒ¬ã‚¯ã‚¿ã‚’å®Ÿè£…ã›ã­ã°ãªã‚‰ãªã„ã€‚
ã“ã‚Œã‚’è¡Œã†ã«ã¯ã€äºŒã¤ã®è‡ªæ˜ãªæ–¹æ³•ãŒã‚ã‚‹â€”â€”è¤‡ç´ æ•°ã‚’ã€ã€Œç›´äº¤å½¢å¼ã€ã§å¯¾ (å®Ÿéƒ¨ã¨è™šéƒ¨) ã¨ã—ã¦è¡¨ç¾ã™ã‚‹ã“ã¨ã€ã‚ã‚‹ã„ã¯ã€ã€Œæ¥µå½¢å¼ã€ã§å¯¾ (å¤§ãã•ã¨è§’åº¦) ã¨ã—ã¦è¡¨ç¾ã™ã‚‹ã“ã¨ãŒã€å¯èƒ½ã§ã‚ã‚‹ã€‚
ã©ã¡ã‚‰ã‚’é¸ã¶ã¹ãã ã‚ã†?
</p>

<p class="orig" lang="en">
In order to make the different choices concrete, imagine that there
are two programmers, Ben Bitdiddle and Alyssa P. Hacker, who are
independently designing representations for the complex-number system.
<a name="%_idx_2320"></a>Ben chooses to represent complex numbers in rectangular form.  With
this choice, selecting the real and imaginary parts of a complex
number is straightforward, as is constructing a complex number with
given real and imaginary parts.  To find the magnitude and the angle,
or to construct a complex number with a given magnitude and angle, he
uses the trigonometric relations</p>

<p class="trans" lang="ja">
ç•°ãªã‚‹é¸æŠè‚¢ã‚’å…·ä½“çš„ã«ã™ã‚‹ãŸã‚ã«ã€ãƒ™ãƒ³ãƒ»ãƒ“ãƒƒãƒˆãƒ‡ã‚£ãƒ‰ãƒ«ã¨ã‚¢ãƒªãƒƒã‚µãƒ»Pãƒ»ãƒãƒƒã‚«ã¨ã„ã†ã€äºŒäººã®ãƒ—ãƒ­ã‚°ãƒ©ãƒãŒã„ã¦ã€äºŒäººã¯è¤‡ç´ æ•°ã‚·ã‚¹ãƒ†ãƒ ã®ãŸã‚ã®è¡¨ç¾ã‚’äº’ã„ã«ç„¡é–¢ä¿‚ã«è¨­è¨ˆã—ã¦ã„ã‚‹ã€ã¨æƒ³åƒã—ã‚ˆã†ã€‚
ãƒ™ãƒ³ã¯ã€è¤‡ç´ æ•°ã‚’ç›´äº¤å½¢å¼ã§è¡¨ç¾ã™ã‚‹ã“ã¨ã«ã™ã‚‹ã€‚
ã“ã®é¸æŠã§ã¯ã€è¤‡ç´ æ•°ã®å®Ÿéƒ¨ã¨è™šéƒ¨ã‚’é¸ã¶ã“ã¨ã¯å˜ç´”ã â€”â€”ä¸ãˆã‚‰ã‚ŒãŸå®Ÿéƒ¨ã¨è™šéƒ¨ã‚’æœ‰ã™ã‚‹è¤‡ç´ æ•°ã‚’æ§‹ç¯‰ã™ã‚‹ã“ã¨ãŒå˜ç´”ãªã®ã¨åŒæ§˜ã«ã€‚
å¤§ãã•ã¨è§’åº¦ã‚’çŸ¥ã‚‹ã«ã¯ã€ã‚ã‚‹ã„ã¯ã€ä¸ãˆã‚‰ã‚ŒãŸå¤§ãã•ã¨è§’åº¦ã‚’æœ‰ã™ã‚‹è¤‡ç´ æ•°ã‚’æ§‹ç¯‰ã™ã‚‹ã«ã¯ã€å½¼ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ãªä¸‰è§’é–¢æ•°ã«ã‚ˆã‚‹é–¢ä¿‚ã‚’ç”¨ã„ã‚‹ã€‚
</p>

<figure>
<img src="ch2-Z-G-60.gif" border="0"><br>
<img src="ch2-Z-G-61.gif" border="0">
</figure>

<p class="orig" lang="en">
which relate the real and imaginary parts (<em>x</em>, <em>y</em>) to the magnitude
and the angle (<em>r</em>, <em>A</em>).<a name="call_footnote_Temp_269" href="#footnote_Temp_269"><sup><small>44</small></sup></a>  Ben's representation is
therefore given by the following selectors and constructors:
</p>

<p class="trans" lang="ja">
â€”â€”ã“ã‚Œã‚‰ã¯ã€å®Ÿéƒ¨ã¨è™šéƒ¨ (<em class="en">x</em>, <em class="en">y</em>) ã‚’ã€å¤§ãã•ã¨è§’åº¦ (<em class="en">r</em>, <em class="en">A</em>) ã«é–¢é€£ã¥ã‘ã‚‹<a href="#footnote_Temp_269"><sup><small>44</small></sup></a>ã€‚
ã—ãŸãŒã£ã¦ã€ãƒ™ãƒ³ã®è¡¨ç¾ã¯ã€ä»¥ä¸‹ã®ã‚»ãƒ¬ã‚¯ã‚¿ã¨ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«ã‚ˆã‚Šä¸ãˆã‚‰ã‚Œã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_2328"></a>(define (real-part z) (car z))
<a name="%_idx_2330"></a>(define (imag-part z) (cdr z))
<a name="%_idx_2332"></a>(define (magnitude z)
  (sqrt (+ (square (real-part z)) (square (imag-part z)))))
<a name="%_idx_2334"></a>(define (angle z)
  (atan (imag-part z) (real-part z)))
<a name="%_idx_2336"></a>(define (make-from-real-imag x y) (cons x y))
<a name="%_idx_2338"></a>(define (make-from-mag-ang r a) 
  (cons (* r (cos a)) (* r (sin a))))
</p>

<p class="orig" lang="en">
<a name="%_idx_2340"></a>Alyssa, in contrast, chooses to represent complex numbers in polar
form.  For her, selecting the magnitude and angle is straightforward,
but she has to use the <a name="%_idx_2342"></a>trigonometric relations to obtain the real and
imaginary parts.  Alyssa's representation is:
</p>


<p class="trans" lang="ja">
ãã‚Œã«å¯¾ã—ã¦ã‚¢ãƒªãƒƒã‚µã¯ã€æ¥µå½¢å¼ã§è¤‡ç´ æ•°ã‚’è¡¨ç¾ã™ã‚‹ã“ã¨ã«ã™ã‚‹ã€‚
å½¼å¥³ã«ã¨ã£ã¦ã€å¤§ãã•ã¨è§’åº¦ã‚’é¸ã¶ã“ã¨ã¯å˜ç´”ã ãŒã€å®Ÿéƒ¨ã¨è™šéƒ¨ã‚’å¾—ã‚‹ã«ã¯ä¸‰è§’é–¢æ•°ã®é–¢ä¿‚ã‚’ä½¿ã‚ãªãã¦ã¯ãªã‚‰ãªã„ã€‚
ã‚¢ãƒªãƒƒã‚µã®è¡¨ç¾ã¯ä»¥ä¸‹ã®ã¨ãŠã‚Šã ã€‚
</p>

<p class="lisp"><a name="%_idx_2344"></a>(define (real-part z)
  (* (magnitude z) (cos (angle z))))
<a name="%_idx_2346"></a>(define (imag-part z)
  (* (magnitude z) (sin (angle z))))
<a name="%_idx_2348"></a>(define (magnitude z) (car z))
<a name="%_idx_2350"></a>(define (angle z) (cdr z))
<a name="%_idx_2352"></a>(define (make-from-real-imag x y) 
  (cons (sqrt (+ (square x) (square y)))
        (atan y x)))
<a name="%_idx_2354"></a>(define (make-from-mag-ang r a) (cons r a))
</p>

<p class="orig" lang="en">
The discipline of data abstraction ensures that the same implementation of
<tt>add-complex</tt>, <tt>sub-complex</tt>, <tt>mul-complex</tt>, and <tt>div-complex</tt> will work with either Ben's representation or Alyssa's
representation. </p>

<p class="trans" lang="ja">
<tt>add-complex</tt> ã¨ <tt>sub-complex</tt> ã¨ <tt>mul-complex</tt> ã¨ <tt>div-complex</tt> ã«ã¤ã„ã¦ã®åŒã˜å®Ÿè£…ãŒã€ãƒ™ãƒ³ã®è¡¨ç¾ã¨ã‚¢ãƒªãƒƒã‚µã®è¡¨ç¾ã®ã„ãšã‚Œã‚’ä½¿ã£ãŸå ´åˆã«ã‚‚ã¡ã‚ƒã‚“ã¨å‹•ãã€ã¨ã„ã†ã“ã¨ã‚’ã€ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ã®è¦å¾‹ã¯ä¿è¨¼ã™ã‚‹ã€‚
</p>

<a name="%_sec_2.4.2"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_2.4.2">2.4.2  Tagged data</a></h3>
<h3 class="trans" lang="ja">2.4.2 ã‚¿ã‚°ä»˜ã‘ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿</h3>

<p class="orig" lang="en">
<a name="%_idx_2356"></a><a name="%_idx_2358"></a><a name="%_idx_2360"></a>
One way to view data abstraction is as an application of the
<a name="%_idx_2362"></a><a name="%_idx_2364"></a>``principle of least commitment.''  In implementing the complex-number
system in section <a href="#%_sec_2.4.1">2.4.1</a>, we can
use either Ben's rectangular representation or Alyssa's polar
representation.  The abstraction barrier formed by the selectors and
constructors permits us to defer to the last possible moment the
choice of a concrete representation for our data objects and thus
retain maximum flexibility in our system design.</p>

<p class="trans" lang="ja">
ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ã®ä¸€ã¤ã®çœºã‚æ–¹ã¯ã€ã€Œæœ€å°ã®é–¢ã‚ã‚Šã®åŸå‰‡ã€ã®é©ç”¨ã¨ã—ã¦ã€ã¨ã„ã†ã‚‚ã®ã§ã‚ã‚‹ã€‚
<a href="#%_sec_2.4.1">2.4.1</a>ç¯€ã§è¤‡ç´ æ•°ã‚·ã‚¹ãƒ†ãƒ ã‚’å®Ÿè£…ã™ã‚‹éš›ã«ã¯ã€ãƒ™ãƒ³ã®ç›´äº¤è¡¨ç¾ã¾ãŸã¯ã‚¢ãƒªãƒƒã‚µã®æ¥µè¡¨ç¾ã‚’ä½¿ã†ã“ã¨ãŒã§ãã‚‹ã€‚
ã‚»ãƒ¬ã‚¯ã‚¿ã¨ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«ã‚ˆã‚Šå½¢æˆã•ã‚Œã‚‹æŠ½è±¡åŒ–ã®é˜²å£ã®ãŠã‹ã’ã§ã€è‡ªåˆ†ã®ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç”¨ã®å…·ä½“çš„ãªè¡¨ç¾ã®é¸æŠã‚’ã€å¯èƒ½ãªé™ã‚Šæœ€å¾Œã®æ™‚ç‚¹ã¾ã§å»¶æœŸã™ã‚‹ã“ã¨ãŒã§ãã€ã‚†ãˆã«ã€è‡ªåˆ†ã®ã‚·ã‚¹ãƒ†ãƒ è¨­è¨ˆã«ãŠã„ã¦æœ€å¤§é™ã®æŸ”è»Ÿæ€§ã‚’ä¿ã¡ç¶šã‘ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
</p>

<p class="orig" lang="en">
The principle of least commitment can be carried to even further
extremes.  If we desire, we can maintain the ambiguity of
representation even <em>after</em> we have designed the selectors and
constructors, and elect to use both Ben's representation <em>and</em>
Alyssa's representation.  If both representations are included in a
single system, however, we will need some way to distinguish data in
polar form from data in rectangular form.  Otherwise, if we were
asked, for instance, to find the <tt>magnitude</tt> of the pair (3,4),
we wouldn't know whether to answer 5 (interpreting the number in
rectangular form) or 3 (interpreting the number in polar form).  A
straightforward way to accomplish this distinction is to include a
<a name="%_idx_2366"></a><em>type tag</em> -- the symbol <tt>rectangular</tt> or <tt>polar</tt> -- as
part of each complex number.  Then when we need to manipulate a
complex number we can use the tag to decide which selector to apply.</p>

<p class="trans" lang="ja">
æœ€å°ã®é–¢ã‚ã‚Šã®åŸå‰‡ã‚’ã€ã‚‚ã£ã¨æ¥µç«¯ãªã¨ã“ã‚ã¾ã§æ¨ã—é€²ã‚ã‚‹ã“ã¨ã•ãˆå¯èƒ½ã ã€‚
ç§ãŸã¡ã¯ã€ã‚‚ã—æœ›ã‚€ãªã‚‰ã°ã€ã‚»ãƒ¬ã‚¯ã‚¿ã¨ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’è¨­è¨ˆã—ãŸ<em>å¾Œ</em>ã§ã•ãˆã‚‚ã€è¡¨ç¾ã®æ›–æ˜§æ€§ã‚’ä¿ã¦ã‚‹ã—ã€ãƒ™ãƒ³ã®è¡¨ç¾<em>ãŠã‚ˆã³</em>ã‚¢ãƒªãƒƒã‚µã®è¡¨ç¾ã®åŒæ–¹ã‚’ã€ä½¿ã†ã“ã¨ã«æ±ºã‚ã‚‹ã“ã¨ã‚‚ã§ãã‚‹ã€‚
ã—ã‹ã—ã€ã‚‚ã—å˜ä¸€ã®ã‚·ã‚¹ãƒ†ãƒ å†…ã«åŒæ–¹ã®è¡¨ç¾ãŒå«ã¾ã‚Œã¦ã„ãŸã‚‰ã€æ¥µå½¢å¼ã®ãƒ‡ãƒ¼ã‚¿ã‚’ç›´äº¤å½¢å¼ã®ãƒ‡ãƒ¼ã‚¿ã¨åŒºåˆ¥ã™ã‚‹ãŸã‚ã®ã€ä½•ã‚‰ã‹ã®æ–¹æ³•ãŒå¿…è¦ã«ãªã‚‹ã ã‚ã†ã€‚
ã•ã‚‚ãªã‘ã‚Œã°ã€ã‚‚ã—ã€ãŸã¨ãˆã° (3, 4) ã¨ã„ã†å¯¾ã® <tt>magnitude</tt> ã‚’æ±‚ã‚ã¦ã»ã—ã„ã¨è¨€ã‚ã‚ŒãŸã‚‰ã€ç§ãŸã¡ã¯ã€5 ã¨ç­”ãˆã‚‹ (æ•°ã‚’ç›´äº¤å½¢å¼ã§è§£é‡ˆã™ã‚‹) ã¹ãã‹ã€ãã‚Œã¨ã‚‚ 3 ã¨ç­”ãˆã‚‹ (æ•°ã‚’æ¥µå½¢å¼ã§è§£é‡ˆã™ã‚‹) ã¹ãã‹ãŒã€åˆ†ã‹ã‚‰ãªã„ã ã‚ã†ã€‚
ã“ã®åŒºåˆ¥ã‚’æˆã—é‚ã’ã‚‹ãŸã‚ã®å˜ç´”ãªæ–¹æ³•ã¯ã€<em>å‹ã‚¿ã‚°</em>â€”â€”<tt>rectangular</tt> ã¾ãŸã¯ <tt>polar</tt> ã¨ã„ã†è¨˜å·â€”â€”ã‚’ã€å„è¤‡ç´ æ•°ã®ä¸€éƒ¨ã¨ã—ã¦å«ã‚ã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚
ã™ã‚‹ã¨ã€è¤‡ç´ æ•°ã‚’æ“ä½œã—ãªãã¦ã¯ãªã‚‰ãªã„ã¨ãã«ã¯ã€ç§ãŸã¡ã¯ã€ã©ã¡ã‚‰ã®ã‚»ãƒ¬ã‚¯ã‚¿ã‚’é©ç”¨ã™ã¹ãã‹ã‚’æ±ºã‚ã‚‹ãŸã‚ã«ã‚¿ã‚°ã‚’ä½¿ãˆã‚‹ã€‚
</p>

<p class="orig" lang="en">
In order to manipulate tagged data,
we will assume that we have procedures <tt>type-tag</tt> and <tt>contents</tt> that extract from a data object the tag and the actual
contents (the polar or rectangular coordinates, in the case of a
complex number).  We will also postulate a procedure <tt>attach-tag</tt> that takes a tag and contents and produces a tagged data
object.  A straightforward way to implement this is to use ordinary
list structure:
</p>


<p class="trans" lang="ja">
ã‚¿ã‚°ä»˜ã‘ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‚’æ“ä½œã™ã‚‹ãŸã‚ã«ã€ã‚¿ã‚°ã¨å®Ÿéš›ã®ä¸­èº« (è¤‡ç´ æ•°ã®å ´åˆã¯ã€æ¥µåº§æ¨™ã¾ãŸã¯ç›´äº¤åº§æ¨™) ã‚’ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰æŠ½å‡ºã™ã‚‹ã€<tt>type-tag</tt> ãŠã‚ˆã³ <tt>contents</tt> ã¨ã„ã†æ‰‹ç¶šããŒã‚ã‚‹ã‚‚ã®ã¨ã—ã‚ˆã†ã€‚
ã¾ãŸã€ã‚¿ã‚°ã¨ä¸­èº«ã‚’ã‚‚ã‚‰ã£ã¦ã€ã‚¿ã‚°ä»˜ã‘ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œã‚Šå‡ºã™ã€<tt>attach-tag</tt> ã¨ã„ã†æ‰‹ç¶šãã‚‚ã€ä»®å®šã—ã¦ãŠã“ã†ã€‚
ã“ã‚Œã‚’å®Ÿè£…ã™ã‚‹å˜ç´”ãªæ–¹æ³•ã¯ã€æ™®é€šã®ãƒªã‚¹ãƒˆæ§‹é€ ã‚’ä½¿ã†ã“ã¨ã§ã‚ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_2368"></a>(define (attach-tag type-tag contents)
  (cons type-tag contents))
<a name="%_idx_2370"></a>(define (type-tag datum)
  (if (pair? datum)
      (car datum)
      (error &quot;Bad tagged datum -- TYPE-TAG&quot; datum)))
<a name="%_idx_2372"></a>(define (contents datum)
  (if (pair? datum)
      (cdr datum)
      (error &quot;Bad tagged datum -- CONTENTS&quot; datum)))
</p>

<p class="orig" lang="en">
Using these procedures, we can define predicates <tt>rectangular?</tt>
and <tt>polar?</tt>, which recognize polar and rectangular numbers,
respectively:</p>

<p class="trans" lang="ja">
ã“ã‚Œã‚‰ã®æ‰‹ç¶šãã‚’ä½¿ã†ã¨ã€<tt>rectangular?</tt> ãŠã‚ˆã³ <tt>polar?</tt> ã¨ã„ã†è¿°èªâ€”â€”ãã‚Œãã‚Œã€ç›´äº¤å½¢å¼ã®æ•°ã¨æ¥µå½¢å¼ã®æ•°ã‚’èªè­˜ã™ã‚‹â€”â€”ã‚’å®šç¾©ã§ãã‚‹ã€‚
<span class="note">(respectively ã¨ã‚ã‚‹ã®ã§ã€è¿°ã¹ã‚‹é †ãŒæƒã£ã¦ã„ãªã„ã¨å¤‰ãªã®ã ãŒã€é€†é †ã«ãªã£ã¦ã„ã‚‹ã€‚ãŠãã‚‰ãåŸæ–‡ã®æ›¸ãé–“é•ã„ã€‚)</span>
</p>

<p class="lisp"><a name="%_idx_2374"></a>(define (rectangular? z)
  (eq? (type-tag z) 'rectangular))
<a name="%_idx_2376"></a>(define (polar? z)
  (eq? (type-tag z) 'polar))
</p>

<p class="orig" lang="en">
With type tags, Ben and Alyssa can now modify their code so that
their two different representations can coexist in the same system.
Whenever Ben constructs a complex number, he tags it as rectangular.
Whenever Alyssa constructs a complex number, she tags it as polar.
In addition, Ben and Alyssa must make sure that the names of their
procedures do not conflict.  One way to do this is for Ben to append
the suffix <tt>rectangular</tt> to the name of each of his representation
procedures and for Alyssa to append <tt>polar</tt> to the names of hers.
Here is Ben's revised rectangular representation from
section <a href="#%_sec_2.4.1">2.4.1</a>:</p>

<p class="trans" lang="ja">
ã•ã¦ã€å‹ã‚¿ã‚°ã‚’ä½¿ã£ã¦ã€ãƒ™ãƒ³ã¨ã‚¢ãƒªãƒƒã‚µã¯ã€åŒã˜ã‚·ã‚¹ãƒ†ãƒ å†…ã«è‡ªåˆ†ãŸã¡ã®äºŒã¤ã®ç•°ãªã‚‹ã‚³ãƒ¼ãƒ‰ãŒå…±å­˜ã§ãã‚‹ã‚ˆã†ã«ã€è‡ªåˆ†ãŸã¡ã®ã‚³ãƒ¼ãƒ‰ã‚’ä¿®æ­£ã§ãã‚‹ã€‚
ãƒ™ãƒ³ã¯ã€è¤‡ç´ æ•°ã‚’æ§‹ç¯‰ã™ã‚‹ã¨ãã¯ã„ã¤ã§ã‚‚ã€ãã®è¤‡ç´ æ•°ã‚’ã€ç›´äº¤å½¢å¼ã ã¨ã‚¿ã‚°ä»˜ã‘ã™ã‚‹ã€‚
ã‚¢ãƒªãƒƒã‚µã¯ã€è¤‡ç´ æ•°ã‚’æ§‹ç¯‰ã™ã‚‹ã¨ãã¯ã„ã¤ã§ã‚‚ã€ãã®è¤‡ç´ æ•°ã‚’ã€æ¥µå½¢å¼ã ã¨ã‚¿ã‚°ä»˜ã‘ã™ã‚‹ã€‚
ã•ã‚‰ã«ã€ãƒ™ãƒ³ã¨ã‚¢ãƒªãƒƒã‚µã¯ã€è‡ªåˆ†ãŸã¡ã®æ‰‹ç¶šãã®åå‰ãŒé‡ãªã‚‰ãªã„ã“ã¨ã‚’ä¿è¨¼ã›ã­ã°ãªã‚‰ãªã„ã€‚
ã“ã†ã™ã‚‹ãŸã‚ã®ä¸€ã¤ã®æ–¹æ³•ã¯ã€ãƒ™ãƒ³ãŒã€è‡ªåˆ†ã®è¡¨ç¾æ‰‹ç¶šãã®å„ã€…ã®åå‰ã« <tt>rectangular</tt> ã¨ã„ã†æ¥å°¾è¾ã‚’ä»˜åŠ ã—ã€ã‚¢ãƒªãƒƒã‚µãŒã€è‡ªåˆ†ã®è¡¨ç¾æ‰‹ç¶šãã®åå‰ã« <tt>polar</tt> ã¨ä»˜åŠ ã™ã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚
ã“ã“ã«ã€<a href="#%_sec_2.4.1">2.4.1</a>ç¯€ã‹ã‚‰æ”¹å¤‰ã—ãŸå¾Œã®ã€ãƒ™ãƒ³ã®ç›´äº¤è¡¨ç¾ã‚’ç¤ºã™ã€‚
</p>

<p class="lisp"><a name="%_idx_2378"></a>(define (real-part-rectangular z) (car z))
<a name="%_idx_2380"></a>(define (imag-part-rectangular z) (cdr z))
<a name="%_idx_2382"></a>(define (magnitude-rectangular z)
  (sqrt (+ (square (real-part-rectangular z))
           (square (imag-part-rectangular z)))))
<a name="%_idx_2384"></a>(define (angle-rectangular z)
  (atan (imag-part-rectangular z)
        (real-part-rectangular z)))
<a name="%_idx_2386"></a>(define (make-from-real-imag-rectangular x y)
  (attach-tag 'rectangular (cons x y)))
<a name="%_idx_2388"></a>(define (make-from-mag-ang-rectangular r a) 
  (attach-tag 'rectangular
              (cons (* r (cos a)) (* r (sin a)))))
</p>

<p class="orig" lang="en">
and here is Alyssa's revised polar representation:
</p>

<p class="trans" lang="ja">
ãã—ã¦ã€ã“ã“ã«ã€ã‚¢ãƒªãƒƒã‚µã®æ”¹å¤‰å¾Œã®æ¥µè¡¨ç¾ã‚’ç¤ºã™ã€‚
</p>

<p class="lisp"><a name="%_idx_2390"></a>(define (real-part-polar z)
  (* (magnitude-polar z) (cos (angle-polar z))))
<a name="%_idx_2392"></a>(define (imag-part-polar z)
  (* (magnitude-polar z) (sin (angle-polar z))))
<a name="%_idx_2394"></a>(define (magnitude-polar z) (car z))
<a name="%_idx_2396"></a>(define (angle-polar z) (cdr z))
<a name="%_idx_2398"></a>(define (make-from-real-imag-polar x y) 
  (attach-tag 'polar
               (cons (sqrt (+ (square x) (square y)))
                     (atan y x))))
<a name="%_idx_2400"></a>(define (make-from-mag-ang-polar r a)
  (attach-tag 'polar (cons r a)))
</p>

<p class="orig" lang="en">
<a name="%_idx_2402"></a><a name="%_idx_2404"></a>Each generic selector is implemented as a procedure that checks the
tag of its argument and calls the appropriate procedure for handling
data of that type.  For example, to obtain the real part of a complex
number, <tt>real-part</tt> examines the tag to determine whether to use
Ben's <tt>real-part-rectangular</tt> or Alyssa's <tt>real-part-polar</tt>.
In either case, we use <tt>contents</tt> to extract the bare, untagged
datum and send this to the rectangular or polar procedure as required:
</p>

<p class="trans" lang="ja">
ç·ç§°çš„ãªã‚»ãƒ¬ã‚¯ã‚¿ã®å„ã€…ã¯ã€ãã®ã‚»ãƒ¬ã‚¯ã‚¿ã¸ã®å¼•æ•°ã®ã‚¿ã‚°ã‚’æ¤œæŸ»ã—ã¦ã€ãã®å‹ã®ãƒ‡ãƒ¼ã‚¿ã‚’æ‰±ã†ãŸã‚ã®é©å®œã®æ‰‹ç¶šãã‚’å‘¼ã³å‡ºã™ã‚ˆã†ãªæ‰‹ç¶šãã¨ã—ã¦ã€å®Ÿè£…ã•ã‚Œã‚‹ã€‚
ãŸã¨ãˆã°ã€è¤‡ç´ æ•°ã®å®Ÿéƒ¨ã‚’å¾—ã‚‹ãŸã‚ã«ã€<tt>real-part</tt> ã¯ã€ã‚¿ã‚°ã‚’èª¿ã¹ã¦ã€ãƒ™ãƒ³ã® <tt>real-part-rectangular</tt> ã‚’ä½¿ã†ã¹ãã‹ã€ãã‚Œã¨ã‚‚ã‚¢ãƒªãƒƒã‚µã® <tt>real-part-polar</tt> ã‚’ä½¿ã†ã¹ãã‹ã‚’æ±ºå®šã™ã‚‹ã€‚
ã„ãšã‚Œã®å ´åˆã§ã‚‚ã€ç§ãŸã¡ã¯ã€è£¸ã®ã€ã‚¿ã‚°ä»˜ã‘ã•ã‚Œã¦ã„ãªã„ãƒ‡ãƒ¼ã‚¿ã‚’æŠœãå‡ºã™ãŸã‚ã« <tt>contents</tt> ã‚’ä½¿ã„ã€ã“ã®ãƒ‡ãƒ¼ã‚¿ã‚’ã€æ±‚ã‚ã‚‰ã‚Œã‚‹ã¨ãŠã‚Šã«ã€ç›´äº¤å½¢å¼ç”¨ã®æ‰‹ç¶šãã‹ã€ã¾ãŸã¯æ¥µå½¢å¼ç”¨ã®æ‰‹ç¶šãã¸ã¨ã€é€ã‚Šå‡ºã™ã€‚
</p>

<p class="lisp"><a name="%_idx_2406"></a>(define (real-part z)
  (cond ((rectangular? z) 
         (real-part-rectangular (contents z)))
        ((polar? z)
         (real-part-polar (contents z)))
        (else (error &quot;Unknown type -- REAL-PART&quot; z))))
<a name="%_idx_2408"></a>(define (imag-part z)
  (cond ((rectangular? z)
         (imag-part-rectangular (contents z)))
        ((polar? z)
         (imag-part-polar (contents z)))
        (else (error &quot;Unknown type -- IMAG-PART&quot; z))))
<a name="%_idx_2410"></a>(define (magnitude z)
  (cond ((rectangular? z)
         (magnitude-rectangular (contents z)))
        ((polar? z)
         (magnitude-polar (contents z)))
        (else (error &quot;Unknown type -- MAGNITUDE&quot; z))))
<a name="%_idx_2412"></a>(define (angle z)
  (cond ((rectangular? z)
         (angle-rectangular (contents z)))
        ((polar? z)
         (angle-polar (contents z)))
        (else (error &quot;Unknown type -- ANGLE&quot; z))))
</p>

<p class="orig" lang="en">
To implement the complex-number arithmetic operations, we can use the
same procedures <tt>add-complex</tt>, <tt>sub-complex</tt>, <tt>mul-complex</tt>, and <tt>div-complex</tt> from
section <a href="#%_sec_2.4.1">2.4.1</a>, because the
selectors they call are generic, and so will work with either
representation.  For example, the procedure <tt>add-complex</tt> is still
</p>

<p class="trans" lang="ja">
è¤‡ç´ æ•°ã®ç®—è¡“æ¼”ç®—ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã«ã€ç§ãŸã¡ã¯ã€<a href="#%_sec_2.4.1">2.4.1</a>ã®ã¨åŒã˜ã€<tt>add-complex</tt> ã¨ <tt>sub-complex</tt> ã¨ <tt>mul-complex</tt> ã¨ <tt>div-complex</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’ã€ä½¿ã†ã“ã¨ãŒã§ãã‚‹ã€‚ã¨ã„ã†ã®ã‚‚ã€ã“ã‚Œã‚‰ã®æ‰‹ç¶šããŒå‘¼ã³å‡ºã™ã‚»ãƒ¬ã‚¯ã‚¿ã¯ã€ç·ç§°çš„ã§ã‚ã‚Šã€ãã®ãŸã‚ã€ã©ã¡ã‚‰ã®è¡¨ç¾ã«å¯¾ã—ã¦ã‚‚ã¡ã‚ƒã‚“ã¨å‹•ãã‹ã‚‰ã§ã‚ã‚‹ã€‚
ãŸã¨ãˆã°ã€<tt>add-complex</tt> ã¨ã„ã†æ‰‹ç¶šãã¯ã€ä¾ç„¶ã¨ã—ã¦ã€ä»¥ä¸‹ã®ã¨ãŠã‚Šã®ã¾ã¾ã§ã‚ã‚‹ã€‚
</p>

<p class="lisp">(define (add-complex z1 z2)
  (make-from-real-imag (+ (real-part z1) (real-part z2))
                       (+ (imag-part z1) (imag-part z2))))
</p>

<p class="orig" lang="en">
Finally, we must choose whether to construct complex numbers using
Ben's representation or Alyssa's representation.  One reasonable
choice is to construct rectangular numbers whenever we have real and
imaginary parts and to construct polar numbers whenever we have
magnitudes and angles:
</p>

<p class="trans" lang="ja">
æœ€å¾Œã«ã€ç§ãŸã¡ã¯ã€ãƒ™ãƒ³ã®è¡¨ç¾ã‚’ä½¿ã£ã¦è¤‡ç´ æ•°ã‚’æ§‹ç¯‰ã™ã‚‹ã®ã‹ã€ãã‚Œã¨ã‚‚ã€ã‚¢ãƒªãƒƒã‚µã®è¡¨ç¾ã‚’ä½¿ã£ã¦è¤‡ç´ æ•°ã‚’æ§‹ç¯‰ã™ã‚‹ã®ã‹ã‚’ã€é¸ã°ãªãã¦ã¯ãªã‚‰ãªã„ã€‚
ç†ã«ã‹ãªã£ãŸä¸€ã¤ã®é¸æŠã¯ã€å®Ÿéƒ¨ã¨è™šéƒ¨ãŒåˆ†ã‹ã£ã¦ã„ã‚‹ã¨ãã¯ã„ã¤ã§ã‚‚ç›´äº¤å½¢å¼ã®æ•°ã‚’æ§‹ç¯‰ã—ã€ã‹ã¤ã€å¤§ãã•ã¨è§’åº¦ãŒåˆ†ã‹ã£ã¦ã„ã‚‹ã¨ãã¯ã„ã¤ã§ã‚‚æ¥µå½¢å¼ã®æ•°ã‚’æ§‹ç¯‰ã™ã‚‹ã€ã¨ã„ã†æ–¹æ³•ã ã€‚
</p>

<p class="lisp"><a name="%_idx_2414"></a>(define (make-from-real-imag x y)
  (make-from-real-imag-rectangular x y))
<a name="%_idx_2416"></a>(define (make-from-mag-ang r a)
  (make-from-mag-ang-polar r a))
</p>

<figure>
<a name="%_fig_2.21"></a>
<img src="ch2-Z-G-62.gif" border="0">
<figcaption class="orig" lang="en"><div align=left><b>Figure 2.21:</b>  Structure of the generic complex-arithmetic system.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³2.21:</b> ç·ç§°çš„ãªè¤‡ç´ æ•°ç®—è¡“ã‚·ã‚¹ãƒ†ãƒ ã®æ§‹é€ </figcaption>
</figure>

<p class="orig" lang="en">
The resulting complex-number system has the structure shown in
figure <a href="#%_fig_2.21">2.21</a>.  The system has been
decomposed into three relatively independent parts: the
complex-number-arithmetic operations, Alyssa's polar
implementation, and Ben's rectangular implementation.  The polar and
rectangular implementations could have been written by Ben and Alyssa
working separately, and both of these can be used as underlying
representations by a third programmer implementing the
complex-arithmetic procedures in terms of the abstract
constructor/selector interface.</p>

<p class="trans" lang="ja">
ã§ãã‚ãŒã£ãŸè¤‡ç´ æ•°ã‚·ã‚¹ãƒ†ãƒ ã«ã¯ã€å›³<a href="#%_fig_2.21">2.21</a>ã«ç¤ºã™ã‚ˆã†ãªæ§‹é€ ãŒã‚ã‚‹ã€‚
ã‚·ã‚¹ãƒ†ãƒ ã¯ã€æ¯”è¼ƒçš„ç‹¬ç«‹ã—ãŸä¸‰ã¤ã®éƒ¨åˆ†ã¸ã¨åˆ†è§£ã•ã‚ŒãŸâ€”â€”ã™ãªã‚ã¡ã€è¤‡ç´ æ•°ç®—è¡“æ¼”ç®—ã¨ã€ã‚¢ãƒªãƒƒã‚µã®æ¥µå½¢å¼ã®å®Ÿè£…ã¨ã€ãƒ™ãƒ³ã®ç›´äº¤å½¢å¼ã®å®Ÿè£…ã§ã‚ã‚‹ã€‚
æ¥µå½¢å¼ã¨ç›´äº¤å½¢å¼ã®å®Ÿè£…ã¯ã€åˆ¥ã€…ã«åƒã„ã¦ã„ã‚‹ãƒ™ãƒ³ã¨ã‚¢ãƒªãƒƒã‚µã«ã‚ˆã£ã¦æ›¸ã‹ã‚Œå¾—ãŸã ã‚ã†ã—ã€ã“ã‚Œã‚‰ã®å®Ÿè£…ã®åŒæ–¹ã¯ã€æŠ½è±¡çš„ãªã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿/ã‚»ãƒ¬ã‚¯ã‚¿ã¨ã„ã†ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ã‚¤ã‚¹ã‚’ä½¿ã£ã¦è¤‡ç´ æ•°ç®—è¡“æ‰‹ç¶šãã‚’å®Ÿè£…ã™ã‚‹ç¬¬ä¸‰è€…ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒã«ã‚ˆã£ã¦ã€æ ¹åº•ã«ã‚ã‚‹è¡¨ç¾ã¨ã—ã¦ä½¿ã‚ã‚Œå¾—ã‚‹ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_2420"></a><a name="%_idx_2422"></a>Since each data object is tagged with its type, the selectors operate
on the data in a generic manner.  That is, each selector is defined to
have a behavior that depends upon the particular type of data it is
applied to.  Notice the general mechanism for interfacing the separate
representations: Within a given representation implementation (say,
Alyssa's polar package) a complex number is an untyped pair
(magnitude, angle).  When a generic selector operates on a number of
<tt>polar</tt> type, it strips off the tag and passes the contents on to
Alyssa's code.  Conversely, when Alyssa constructs a number for general
use, she tags it with a type so that it can be appropriately
recognized by the higher-level procedures.  This discipline of
stripping off and attaching tags as data objects are passed from level
to level can be an important organizational strategy, as we shall see
in section <a href="18_sec2_5.html#%_sec_2.5">2.5</a>.

</p>

<p class="trans" lang="ja">
å„ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå‹ã§ã‚¿ã‚°ä»˜ã‘ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€ã‚»ãƒ¬ã‚¯ã‚¿ã¯ã€ãã®ãƒ‡ãƒ¼ã‚¿ä¸Šã§ç·ç§°çš„ãªã‚„ã‚Šæ–¹ã§å‹•ä½œã™ã‚‹ã€‚
ã¤ã¾ã‚Šã€å„ã‚»ãƒ¬ã‚¯ã‚¿ã¯ã€ãã®ã‚»ãƒ¬ã‚¯ã‚¿ãŒé©ç”¨ã•ã‚Œã‚‹ãƒ‡ãƒ¼ã‚¿ã®ã€ç‰¹å®šã®å‹ã«ä¾å­˜ã™ã‚‹æŒ¯ã‚‹èˆã„ã‚’ã™ã‚‹ã‚ˆã†ã«ã€å®šç¾©ã•ã‚Œã‚‹ã€‚
åˆ¥ã€…ã®è¡¨ç¾åŒå£«ã®é–“ã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ã‚¤ã‚¹ã‚’ã¨ã‚‹ãŸã‚ã®ã€ä¸€èˆ¬çš„ãªä»•çµ„ã¿ã«æ³¨æ„ã›ã‚ˆâ€”â€”ä¸ãˆã‚‰ã‚ŒãŸè¡¨ç¾å®Ÿè£… (ãŸã¨ãˆã°ã€ã‚¢ãƒªãƒƒã‚µã®æ¥µå½¢å¼ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸) ã®å†…éƒ¨ã§ã¯ã€è¤‡ç´ æ•°ã¯ã€å‹ã®ãªã„å¯¾ (å¤§ãã•ã¨è§’åº¦) ãªã®ã ã€‚
ç·ç§°çš„ãªã‚»ãƒ¬ã‚¯ã‚¿ã¯ã€<tt>polar</tt> å‹ã®æ•°ã®ä¸Šã§å‹•ä½œã™ã‚‹ã¨ãã€ã‚¿ã‚°ã‚’å‰¥ãå–ã£ã¦ã€ä¸­èº«ã‚’ã‚¢ãƒªãƒƒã‚µã®ã‚³ãƒ¼ãƒ‰ã«æ¸¡ã™ã€‚
é€†ã«ã€ä¸€èˆ¬çš„ç”¨é€”ã®ãŸã‚ã«ã‚¢ãƒªãƒƒã‚µãŒæ•°ã‚’æ§‹ç¯‰ã™ã‚‹ã¨ãã«ã¯ã€ã‚¢ãƒªãƒƒã‚µã¯ã€ã‚ˆã‚Šé«˜ã„ãƒ¬ãƒ™ãƒ«ã®æ‰‹ç¶šãã«ã‚ˆã‚Šãã®æ•°ãŒé©åˆ‡ã«èªè­˜ã•ã‚Œã‚‹ã‚ˆã†ã«ã€ãã®æ•°ã‚’å‹ã§ã‚¿ã‚°ä»˜ã‘ã™ã‚‹ã€‚
ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒãƒ¬ãƒ™ãƒ«ã‹ã‚‰ãƒ¬ãƒ™ãƒ«ã¸ã¨å—ã‘æ¸¡ã•ã‚Œã‚‹ã®ã«ã¤ã‚Œã¦ã€ã‚¿ã‚°ã‚’å‰¥ãå–ã£ãŸã‚Šå–ã‚Šã¤ã‘ãŸã‚Šã™ã‚‹ã€ã¨ã„ã†ã“ã®è¦å¾‹ã¯ã€é‡è¦ãªçµ„ç¹”ç«‹ã¦ã®æˆ¦ç•¥ã«ãªã‚Šå¾—ã‚‹â€”â€”<a href="18_sec2_5.html#%_sec_2.5">2.5</a>ç¯€ã§è¦‹ã‚‹ã“ã¨ã«ãªã‚‹ã¨ãŠã‚Šã€‚
</p>

<a name="%_sec_2.4.3"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_2.4.3">2.4.3  Data-Directed Programming and Additivity</a></h3>
<h3 class="trans" lang="ja">2.4.3 ãƒ‡ãƒ¼ã‚¿æŒ‡å‘ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã¨åŠ æ³•æ€§</h3>

<p class="orig" lang="en">
<a name="%_idx_2424"></a><a name="%_idx_2426"></a>
<a name="%_idx_2428"></a>The general strategy of checking the type of a datum and calling an
appropriate procedure is called <a name="%_idx_2430"></a><a name="%_idx_2432"></a><em>dispatching on type</em>.  This is a
powerful strategy for obtaining modularity in system design.  On
the other hand, implementing the dispatch as in
section <a href="#%_sec_2.4.2">2.4.2</a> has two significant weaknesses.  One
weakness is that the generic interface procedures (<tt>real-part</tt>,
<tt>imag-part</tt>, <tt>magnitude</tt>, and <tt>angle</tt>) must know about all
the different representations.  For instance, suppose we wanted to
incorporate a new representation for complex numbers into our
complex-number system.  We would need to identify this new
representation with a type, and then add a clause to each of the
generic interface procedures to check for the new type and apply the
appropriate selector for that representation.</p>

<p class="trans" lang="ja">
ãƒ‡ãƒ¼ã‚¿ã®å‹ã‚’èª¿ã¹ã¦é©åˆ‡ãªæ‰‹ç¶šãã‚’å‘¼ã³å‡ºã™ã€ã¨ã„ã†ä¸€èˆ¬çš„ãªæˆ¦ç•¥ã¯ã€<em>å‹ã«ã‚ˆã‚‹<!--é€ã‚Šå‡ºã—-->æŒ¯ã‚Šåˆ†ã‘</em>ã¨å‘¼ã°ã‚Œã‚‹ã€‚
ã“ã‚Œã¯ã€ã‚·ã‚¹ãƒ†ãƒ è¨­è¨ˆã«ãŠã„ã¦ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ€§ã‚’ç²å¾—ã™ã‚‹ãŸã‚ã®ã€å¼·åŠ›ãªæˆ¦ç•¥ã§ã‚ã‚‹ã€‚
ä¸€æ–¹ã€<a href="#%_sec_2.4.2">2.4.2</a>ç¯€ã®ã‚ˆã†ã«<!--é€ã‚Šå‡ºã—-->æŒ¯ã‚Šåˆ†ã‘ã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ã«ã¯ã€äºŒã¤ã®é‡å¤§ãªå¼±ç‚¹ãŒã‚ã‚‹ã€‚
ä¸€ã¤ã®å¼±ç‚¹ã¯ã€ç·ç§°çš„ãªã‚¤ãƒ³ã‚¿ãƒ•ã‚§ã‚¤ã‚¹æ‰‹ç¶šã  (<tt>real-part</tt> ã¨ <tt>imag-part</tt> ã¨ <tt>magnitude</tt> ã¨ <tt>angle</tt>) ãŒã€ã™ã¹ã¦ã®ç•°ãªã‚‹è¡¨ç¾ã«ã¤ã„ã¦çŸ¥ã£ã¦ã„ãªãã¦ã¯ãªã‚‰ãªã„ã€ã¨ã„ã†ç‚¹ã ã€‚
ãŸã¨ãˆã°ã€ç§ãŸã¡ã®è¤‡ç´ æ•°ã‚·ã‚¹ãƒ†ãƒ ã«ã€è¤‡ç´ æ•°ç”¨ã®æ–°ãŸãªè¡¨ç¾ã‚’çµ„ã¿è¾¼ã¿ãŸã„ã®ã ã€ã¨ä»®å®šã—ã‚ˆã†ã€‚
ã“ã®æ–°ãŸãªè¡¨ç¾ã‚’ã€ã‚ã‚‹å‹ã ã¨åŒå®šã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã ã‚ã†ã—ã€ã•ã‚‰ã«ã€ãã®æ–°ãŸãªå‹ãªã®ã‹ã‚’èª¿ã¹ã¦ãã®è¡¨ç¾ã«é©ã—ãŸã‚»ãƒ¬ã‚¯ã‚¿ã‚’é©ç”¨ã™ã‚‹ãŸã‚ã«ã€ç·ç§°çš„ãªã‚¤ãƒ³ã‚¿ãƒ•ã‚§ã‚¤ã‚¹æ‰‹ç¶šãã®å„ã€…ã«ç¯€ã‚’è¿½åŠ ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã ã‚ã†ã€‚
</p>

<p class="orig" lang="en">
Another weakness of the technique is that even though the individual
representations can be designed separately, we must guarantee that
no two procedures in the entire system have the same name.  This is
why Ben and Alyssa had to change the names of their original
procedures from section <a href="#%_sec_2.4.1">2.4.1</a>.</p>

<p class="trans" lang="ja">
å½“æŠ€æ³•ã®ã‚‚ã†ä¸€ã¤ã®å¼±ç‚¹ã¯ã€ãŸã¨ãˆå€‹ã€…ã®è¡¨ç¾ã‚’åˆ¥ã€…ã«è¨­è¨ˆã§ãã‚‹ã®ã§ã‚ã£ã¦ã•ãˆã‚‚ã€å…¨ã‚·ã‚¹ãƒ†ãƒ å†…ã®ã©ã®äºŒã¤ã®æ‰‹ç¶šãã‚‚åŒã˜åå‰ã§ã¯ãªã„ã¨ã„ã†ã“ã¨ã‚’ä¿è¨¼ã—ãªãã¦ã¯ãªã‚‰ãªã„ã€ã¨ã„ã†ç‚¹ã ã€‚
ã“ã®ã“ã¨ã¯ã€ãªãœãƒ™ãƒ³ã¨ã‚¢ãƒªãƒƒã‚µãŒã€<a href="#%_sec_2.4.1">2.4.1</a>ç¯€ä»¥æ¥ã®è‡ªåˆ†ãŸã¡ã®å…ƒã®æ‰‹ç¶šãã®åå‰ã‚’å¤‰ãˆãªãã¦ã¯ãªã‚‰ãªã‹ã£ãŸã®ã‹ã€ã¨ã„ã†ã“ã¨ã®ç†ç”±ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
The issue underlying both of these weaknesses is that the technique
for implementing generic interfaces is not <em>additive</em>.  The person
implementing the generic selector procedures must modify those
procedures each time a new representation is installed, and the people
interfacing the individual representations must modify their
code to avoid name conflicts.  In each of these cases, the changes
that must be made to the code are straightforward, but they must be
made nonetheless, and this is a source of inconvenience and error.
This is not much of a problem for the complex-number system as it
stands, but suppose there were not two but hundreds of different
representations for complex numbers.  And suppose that there were many
generic selectors to be maintained in the abstract-data interface.
Suppose, in fact, that no one programmer knew all the interface
procedures or all the representations.  The problem is real and must
be addressed in such programs as large-scale data-base-management
systems.</p>

<p class="trans" lang="ja">
ã“ã‚Œã‚‰ã®å¼±ç‚¹åŒæ–¹ã®èƒŒå¾Œã«ã‚ã‚‹å•é¡Œã¯ã€ç·ç§°çš„ãªã‚¤ãƒ³ã‚¿ãƒ•ã‚§ã‚¤ã‚¹ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã®æŠ€æ³•ãŒ<em>åŠ æ³•çš„</em>ã§ã¯ãªã„ã“ã¨ã§ã‚ã‚‹ã€‚
ç·ç§°çš„ãªã‚»ãƒ¬ã‚¯ã‚¿æ‰‹ç¶šãã‚’å®Ÿè£…ã™ã‚‹äººã¯ã€æ–°ã—ã„è¡¨ç¾ãŒå–ã‚Šå…¥ã‚Œã‚‰ã‚Œã‚‹ãŸã³ã«ã€ãã‚Œã‚‰ã®æ‰‹ç¶šãã‚’ä¿®æ­£ã›ã­ã°ãªã‚‰ãªã„ã—ã€å€‹ã€…ã®è¡¨ç¾ã‚’ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ã‚¤ã‚¹ã§ã¤ãªãäººãŸã¡ã¯ã€åå‰ã®è¡çªã‚’é¿ã‘ã‚‹ãŸã‚ã«ã€è‡ªåˆ†ãŸã¡ã®ã‚³ãƒ¼ãƒ‰ã‚’ä¿®æ­£ã›ã­ã°ãªã‚‰ãªã„ã€‚
ã“ã‚Œã‚‰ã®çŠ¶æ³ã®ãã‚Œãã‚Œã«ãŠã„ã¦ã€ã‚³ãƒ¼ãƒ‰ã«å¯¾ã—ã¦ã—ãªãã¦ã¯ãªã‚‰ãªã„å¤‰æ›´ã¯ã€å˜ç´”ã§ã¯ã‚ã‚‹ãŒã€ãã‚Œã§ã‚‚ã‚„ã¯ã‚Šã€ã—ãªãã¦ã¯ãªã‚‰ãªã„ã®ã§ã‚ã‚Šã€ãã—ã¦ã€ã“ã®ã“ã¨ãŒã€ä¸ä¾¿ã¨ã‚¨ãƒ©ãƒ¼ã®æºãªã®ã ã€‚
ã“ã‚Œã¯ã€ç¾çŠ¶ã®è¤‡ç´ æ•°ã‚·ã‚¹ãƒ†ãƒ ã«ã¨ã£ã¦ã¯å¤§ã—ãŸå•é¡Œã§ã¯ãªã„ãŒã€è¤‡ç´ æ•°ã«å¯¾ã—ã¦äºŒã¤ã©ã“ã‚ã‹ä½•ç™¾ã‚‚ã®ç•°ãªã‚‹è¡¨ç¾ãŒã‚ã£ãŸã€ã¨ä»®å®šã—ã¦ã¿ãŸã¾ãˆã€‚
ãã—ã¦ã€æŠ½è±¡ãƒ‡ãƒ¼ã‚¿ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ã‚¤ã‚¹ã®ã†ã¡ã«ã¯ã€<!--ã‚’ä½¿ã£ã¦-->ä¿å®ˆã™ã¹ãç·ç§°çš„ã‚»ãƒ¬ã‚¯ã‚¿ãŒãŸãã•ã‚“ã‚ã£ãŸã€ã¨ä»®å®šã—ã¦ã¿ãŸã¾ãˆã€‚<!--span class="note">(inã‚’æ‰‹æ®µã¨è¦‹ã¦è¨³ã—ãŸãŒã€ã€Œã®ä¸­ã§ã€ã§ãªãã¦ã‚ˆã„ã‹ã€æ–‡ç« ã®æ„å‘³å†…å®¹ã‚’ã‚‚ã†ä¸€åº¦è¦‹ç›´ã™ã“ã¨ã€‚)</span-->
ã“ã®å•é¡Œã¯ã€ç¾å®Ÿçš„ã ã—ã€å¤§è¦æ¨¡ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã®ã‚ˆã†ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã¯ã€å¯¾å‡¦ã—ãªãã¦ã¯ãªã‚‰ãªã„ã‚‚ã®ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
What we need is a means for modularizing the system design even
further.  This is provided by the programming technique known as <em>data-directed programming</em>.  To understand how data-directed
programming works, begin with the observation that whenever we deal
with a set of generic operations that are common to a set of
different types we are, in effect, dealing with a two-dimensional
table that contains the possible operations on one axis and the
possible types on the other axis.  The entries in the table are the
procedures that implement each operation for each type of argument
presented.  In the complex-number system developed in the previous
section, the correspondence between operation name, data type, and
actual procedure was spread out among the various conditional clauses
in the generic interface procedures.  But the same information could
have been organized in a table, as shown in
figure <a href="#%_fig_2.22">2.22</a>.</p>

<p class="trans" lang="ja">
å¿…è¦ãªã®ã¯ã€ã‚·ã‚¹ãƒ†ãƒ è¨­è¨ˆã‚’ã•ã‚‰ã«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åŒ–ã™ã‚‹ãŸã‚ã®æ‰‹æ®µã§ã‚ã‚‹ã€‚
ã“ã‚Œã¯ã€<em>ãƒ‡ãƒ¼ã‚¿æŒ‡å‘ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°</em>ã¨ã—ã¦çŸ¥ã‚‰ã‚Œã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°æŠ€æ³•ã«ã‚ˆã‚Šã€ä¸ãˆã‚‰ã‚Œã‚‹ã€‚
ãƒ‡ãƒ¼ã‚¿æŒ‡å‘ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ãŒã©ã®ã‚ˆã†ã«ã—ã¦ã†ã¾ãå‹•ãã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’ç†è§£ã™ã‚‹ãŸã‚ã«ã€ã“ã®ã‚ˆã†ãªè¦³å¯Ÿã‹ã‚‰å§‹ã‚ã‚ˆã†â€”â€”ã™ãªã‚ã¡ã€ç§ãŸã¡ã¯ã€ç•°ãªã‚‹å‹ã®ä¸€æƒã„ã«å¯¾ã—ã¦å…±é€šãªç·ç§°çš„æ¼”ç®—ã®ä¸€æƒã„ã‚’æ‰±ã†ã¨ãã«ã¯ã„ã¤ã§ã‚‚ã€å®Ÿéš›ã®ã¨ã“ã‚ã€ä¸€æ–¹ã®è»¸ã«æ²¿ã£ã¦å¯èƒ½ãªæ¼”ç®—ã‚’å«ã¿ã€ã‹ã¤ã€ä»–æ–¹ã®è»¸ã«æ²¿ã£ã¦å¯èƒ½ãªå‹ã‚’å«ã‚€ã‚ˆã†ãªã€äºŒæ¬¡å…ƒã®è¡¨ã‚’æ‰±ã£ã¦ã„ã‚‹ã®ã§ã‚ã‚‹ã€‚
ã“ã®è¡¨ã®ã‚¨ãƒ³ãƒˆãƒªã¯ã€ãã‚Œãã‚Œã®å‹ã®ã€æç¤ºã•ã‚Œã¦ã„ã‚‹å¼•æ•°ã®ãŸã‚ã®å„æ¼”ç®—ã‚’ã€å®Ÿè£…ã™ã‚‹æ‰‹ç¶šãã§ã‚ã‚‹ã€‚
å‰ç¯€ã§é–‹ç™ºã—ãŸè¤‡ç´ æ•°ã‚·ã‚¹ãƒ†ãƒ ã§ã¯ã€æ¼”ç®—åã¨ã€ãƒ‡ãƒ¼ã‚¿å‹ã¨ã€å®Ÿéš›ã®æ‰‹ç¶šãã¨ã®é–“ã®å¯¾å¿œé–¢ä¿‚ã¯ã€ç·ç§°çš„ãªã‚¤ãƒ³ã‚¿ãƒ•ã‚§ã‚¤ã‚¹æ‰‹ç¶šãã®ä¸­ã®æ§˜ã€…ãªæ¡ä»¶ç¯€ã®é–“ã«è”“å»¶ã—ã¦ã„ãŸã€‚
ã—ã‹ã—ã€åŒã˜æƒ…å ±ã¯ã€è¡¨ã«ã¾ã¨ã‚ã‚‰ã‚Œå¾—ãŸã®ã â€”â€”å›³<a href="#%_fig_2.22">2.22</a>ã«ç¤ºã™ã¨ãŠã‚Šã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_2434"></a>Data-directed programming is the technique of designing programs to
work with such a table directly.  Previously, we implemented the
mechanism that interfaces the complex-arithmetic code with the two
representation packages as a set of procedures that each perform an
explicit dispatch on type.  Here we will implement the interface as a single
procedure that looks up the combination of the operation name and
argument type in
the table to find the correct procedure to apply, and then applies it
to the contents of the argument.  If we do this, then to add a new
representation package to the system we need not change any existing
procedures; we need only add new entries to the table.</p>

<p class="trans" lang="ja">
ãƒ‡ãƒ¼ã‚¿æŒ‡å‘ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã¯ã€ã“ã†ã„ã†è¡¨ã‚’ç›´æ¥ä½¿ã£ã¦å‹•ãã‚ˆã†ã«ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’è¨­è¨ˆã™ã‚‹æŠ€æ³•ã ã€‚
ä»¥å‰ã€ç§ãŸã¡ã¯ã€è¤‡ç´ æ•°ç®—è¡“ã®ã‚³ãƒ¼ãƒ‰ã‚’äºŒã¤ã®è¡¨ç¾ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã«ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ã‚¤ã‚¹ã§ã¤ãªãä»•çµ„ã¿ã‚’ã€å‹ã«ã‚ˆã‚‹<!--é€ã‚Šå‡ºã—-->æŒ¯ã‚Šåˆ†ã‘ã‚’ãã‚Œãã‚ŒãŒæ˜ç¤ºçš„ã«è¡Œã†ã‚ˆã†ãªä¸€ç¾¤ã®æ‰‹ç¶šãã¨ã—ã¦ã€å®Ÿè£…ã—ãŸã€‚
ã“ã“ã§ã¯ã€é©ç”¨ã™ã¹ãæ­£ã—ã„æ‰‹ç¶šãã‚’è¦‹ã¤ã‘ã‚‹ãŸã‚ã«ã€æ¼”ç®—åã¨å¼•æ•°ã®å‹ã®çµ„ã¿åˆã‚ã›ã‚’è¡¨ã§èª¿ã¹ã¦ã€ãã‚Œã‹ã‚‰ãã®æ‰‹ç¶šãã‚’å¼•æ•°ã®ä¸­èº«ã«é©ç”¨ã™ã‚‹ã‚ˆã†ãªã€å˜ä¸€ã®æ‰‹ç¶šãã¨ã—ã¦ã€ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ã‚¤ã‚¹ã‚’å®Ÿè£…ã—ã‚ˆã†ã€‚
ã‚‚ã—ã“ã†ã™ã‚Œã°ã€ã‚·ã‚¹ãƒ†ãƒ ã«æ–°ãŸãªè¡¨ç¾ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’è¿½åŠ ã™ã‚‹ãŸã‚ã«ã€æ—¢å­˜ã®ã©ã®æ‰‹ç¶šãã‚‚å¤‰æ›´ã—ãªãã¦ã‚ˆã„â€”â€”ãŸã ã€è¡¨ã«æ–°ãŸãªã‚¨ãƒ³ãƒˆãƒªã‚’åŠ ãˆã‚‹ã ã‘ã§ã‚ˆã„ã®ã ã€‚
</p>

<figure>
<a name="%_fig_2.22"></a>
<img src="ch2-Z-G-63.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 2.22:</b>  Table of operations for the complex-number system.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³2.22:</b> è¤‡ç´ æ•°ã‚·ã‚¹ãƒ†ãƒ ç”¨ã®æ¼”ç®—ã®è¡¨</figcaption>
</figure>

<p class="orig" lang="en">
To implement this plan, assume that we have two procedures,
<tt>put</tt> and <tt>get</tt>, for manipulating the
operation-and-type table:
<a name="%_idx_2436"></a>

<p class="trans" lang="ja">
ã“ã®è¨ˆç”»ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã«ã€<tt>put</tt> ã¨ <tt>get</tt> ã¨ã„ã†äºŒã¤ã®æ‰‹ç¶šãâ€”â€”æ¼”ç®—ãƒ»å‹ã®è¡¨ã‚’æ“ä½œã™ã‚‹ãŸã‚ã®ã‚‚ã®â€”â€”ãŒã‚ã‚‹ã€ã¨ä»®å®šã—ã‚ˆã†ã€‚
</p>

<ul class="orig" lang="en">
<a name="%_idx_2438"></a>
<li><tt>(put &lt;<em>op</em>&gt; &lt;<em>type</em>&gt; &lt;<em>item</em>&gt;)</tt><br>
installs the <tt>&lt;<em>item</em>&gt;</tt> in the table, indexed by the
<tt>&lt;<em>op</em>&gt;</tt> and the <tt>&lt;<em>type</em>&gt;</tt>.</li>

<a name="%_idx_2440"></a>
<li><tt>(get &lt;<em>op</em>&gt; &lt;<em>type</em>&gt;)</tt><br>
looks up the <tt>&lt;<em>op</em>&gt;</tt>, <tt>&lt;<em>type</em>&gt;</tt> entry in the table
and returns the item found there.  If no item is found, <tt>get</tt>
returns false.</li>
</ul>

<ul class="trans" lang="ja">
<li><tt>(put &lt;<em class="en">op</em>&gt; &lt;<em class="en">type</em>&gt; &lt;<em class="en">item</em>&gt;)</tt>
ã¯ã€è¡¨ã« <tt>&lt;<em class="en">item</em>&gt;</tt> ã‚’å–ã‚Šè¾¼ã¿ã€ã“ã‚Œã¯ã€<tt>&lt;<em class="en">op</em>&gt;</tt> ã¨ the <tt>&lt;<em class="en">type</em>&gt;</tt> ã§ç´¢å¼•ã¥ã‘ã‚‰ã‚Œã‚‹ã€‚
</li>
<li><tt>(get &lt;<em class="en">op</em>&gt; &lt;<em class="en">type</em>&gt;)</tt> ã¯ã€è¡¨å†…ã®ã€<tt>&lt;<em class="en">op</em>&gt;</tt>, <tt>&lt;<em class="en">type</em>&gt;</tt> ã®ã‚¨ãƒ³ãƒˆãƒªã‚’èª¿ã¹ã¦ã€ãã“ã§è¦‹ã¤ã‹ã£ãŸã‚‚ã®ã‚’è¿”ã™ã€‚ã‚‚ã—ä½•ã‚‚è¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸã‚‰ã€<tt>get</tt> ã¯å½ã‚’è¿”ã™ã€‚
</li>
</ul>

<p class="orig" lang="en">
For now, we can assume that <tt>put</tt> and <tt>get</tt> are
included in our language.  In chapter 3
(section <a href="22_sec3_3.html#%_sec_3.3.3">3.3.3</a>, exercise <a href="22_sec3_3.html#%_thm_3.24">3.24</a>)
we will see how to implement these and
other operations for manipulating tables.</p>

<p class="trans" lang="ja">
ã“ã‚Œã‹ã‚‰ã¯ã€ç§ãŸã¡ã®è¨€èªã« <tt>put</tt> ã¨ <tt>get</tt> ãŒå«ã¾ã‚Œã¦ã„ã‚‹ã€ã¨ä»®å®šã§ãã‚‹ã€‚
3ç«  (<a href="22_sec3_3.html#%_sec_3.3.3">3.3.3</a>ç¯€ã®ç·´ç¿’å•é¡Œ<a href="22_sec3_3.html#%_thm_3.24">3.24</a>) ã§ã¯ã€<tt>put</tt> ã¨ <tt>get</tt> ãŠã‚ˆã³è¡¨ã‚’æ“ä½œã™ã‚‹ãŸã‚ã®ä»–ã®æ¼”ç®—ã‚’ã©ã†å®Ÿè£…ã™ã‚‹ã®ã‹ã‚’è¦‹ã‚‹ã“ã¨ã«ã—ã‚ˆã†ã€‚
</p>

<p class="orig" lang="en">
Here is how data-directed programming can be used in the
complex-number system.  Ben, who developed the rectangular
representation, implements his code just as he did originally.  He
defines a collection of procedures, or a <a name="%_idx_2442"></a><em>package</em>, and interfaces
these to the rest of the system by adding entries to the table that
tell the system how to operate on rectangular numbers.
This is accomplished by calling the following procedure:
<a name="%_idx_2444"></a><a name="%_idx_2446"></a></p>

<p class="trans" lang="ja">
è¤‡ç´ æ•°ã‚·ã‚¹ãƒ†ãƒ ã«ãŠã„ã¦ãƒ‡ãƒ¼ã‚¿æŒ‡å‘ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚’ã©ã®ã‚ˆã†ã«ä½¿ãˆã‚‹ã‹ã€ã¨ã„ã†ã“ã¨ã‚’ã€ã“ã“ã«ç¤ºã™ã€‚
ãƒ™ãƒ³â€”â€”ç›´äº¤è¡¨ç¾ã‚’é–‹ç™ºã—ãŸâ€”â€”ã¯ã€è‡ªåˆ†ã®ã‚³ãƒ¼ãƒ‰ã‚’ã€æœ€åˆã«é–‹ç™ºã—ãŸã®ã¨ã¡ã‚‡ã†ã©åŒã˜ã‚ˆã†ã«ã€å®Ÿè£…ã™ã‚‹ã€‚
å½¼ã¯ã€æ‰‹ç¶šãã®é›†ã¾ã‚Šâ€”â€”ã¤ã¾ã‚Šã€<em>ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸</em>â€”â€”ã‚’å®šç¾©ã—ã¦ã€ãã—ã¦ã€ç›´äº¤å½¢å¼ã®æ•°ã®ä¸Šã§å‹•ä½œã™ã‚‹æ–¹æ³•ã‚’ã‚·ã‚¹ãƒ†ãƒ ã«ä¼ãˆã‚‹è¡¨ã«ã‚¨ãƒ³ãƒˆãƒªã‚’åŠ ãˆã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€ã“ã‚Œã‚‰ã®æ‰‹ç¶šãã‚’ã€ã‚·ã‚¹ãƒ†ãƒ ã®æ®‹ã‚Šã®éƒ¨åˆ†ã¸ã¨ã€ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ã‚¤ã‚¹ã§ã¤ãªãã€‚
ã“ã‚Œã¯ã€ä»¥ä¸‹ã®æ‰‹ç¶šãã‚’å‘¼ã³å‡ºã™ã“ã¨ã§ã€æˆã—é‚ã’ã‚‰ã‚Œã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_2448"></a>(define (install-rectangular-package)
  <em>;; internal procedures</em>
  (define (real-part z) (car z))
  (define (imag-part z) (cdr z))
  (define (make-from-real-imag x y) (cons x y))
  (define (magnitude z)
    (sqrt (+ (square (real-part z))
             (square (imag-part z)))))
  (define (angle z)
    (atan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a) 
    (cons (* r (cos a)) (* r (sin a))))
  <em>;; interface to the rest of the system</em>
  (define (tag x) (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular 
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular 
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)
</p>

<p class="orig" lang="en">
Notice that the internal procedures here are the same procedures from
section <a href="#%_sec_2.4.1">2.4.1</a> that Ben wrote when
he was working in isolation.  No changes are necessary in order to
interface them to the rest of the system.  Moreover, since these
procedure definitions are internal to the installation procedure, Ben
needn't worry about name conflicts with other procedures outside the
rectangular package.  To interface these to the rest of the system,
Ben installs his <tt>real-part</tt> procedure under the operation name
<tt>real-part</tt> and the type <tt>(rectangular)</tt>, and similarly
for the other selectors.<a name="call_footnote_Temp_270" href="#footnote_Temp_270"><sup><small>45</small></sup></a>  The interface also defines
the constructors to be used by the external system.<a name="call_footnote_Temp_271" href="#footnote_Temp_271"><sup><small>46</small></sup></a>
These are
identical to Ben's internally defined constructors, except that they
attach the tag.</p>

<p class="trans" lang="ja">
ã“ã“ã§ã®å†…éƒ¨æ‰‹ç¶šããŒã€<a href="#%_sec_2.4.1">2.4.1</a>ç¯€ã§ãƒ™ãƒ³ãŒéš”é›¢ã•ã‚Œã¦åƒã„ã¦ã„ãŸã¨ãã«æ›¸ã„ãŸã‚‚ã®ã¨åŒã˜æ‰‹ç¶šãã§ã‚ã‚‹ã“ã¨ã«ã€æ³¨æ„ã›ã‚ˆã€‚
ã“ã‚Œã‚‰ã®æ‰‹ç¶šãã‚’ã‚·ã‚¹ãƒ†ãƒ ã®æ®‹ã‚Šã®éƒ¨åˆ†ã¸ã¨ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ã‚¤ã‚¹ã§ã¤ãªããŸã‚ã«ã¯ã€ä½•ã®å¤‰æ›´ã‚‚å¿…è¦ãªã„ã€‚
ã•ã‚‰ã«ã€ã“ã‚Œã‚‰ã®æ‰‹ç¶šãå®šç¾©ã¯ã€ã‚¤ãƒ³ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ‰‹ç¶šãã®å†…éƒ¨ã®ã‚‚ã®ã ã‹ã‚‰ã€ãƒ™ãƒ³ã¯ã€ç›´äº¤è¡¨ç¾ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®å¤–éƒ¨ã®ä»–ã®æ‰‹ç¶šãã¨ã®é–“ã§ã®åå‰ã®è¡çªã«ã¤ã„ã¦ã€å¿ƒé…ã™ã‚‹å¿…è¦ãŒãªã„ã€‚
ã“ã‚Œã‚‰ã®æ‰‹ç¶šãã‚’ã‚·ã‚¹ãƒ†ãƒ ã®æ®‹ã‚Šã®éƒ¨åˆ†ã¸ã¨ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ã‚¤ã‚¹ã§ã¤ãªããŸã‚ã«ã€ãƒ™ãƒ³ã¯ã€è‡ªåˆ†ã® <tt>real-part</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’ã€<tt>real-part</tt> ã¨ã„ã†æ¼”ç®—åã¨ <tt>(rectangular)</tt> ã¨ã„ã†å‹ã®ã‚‚ã¨ã«ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã€ä»–ã®ã‚»ãƒ¬ã‚¯ã‚¿ã«ã¤ã„ã¦ã‚‚åŒæ§˜ã®ã“ã¨ã‚’ã™ã‚‹<a href="#footnote_Temp_270"><sup><small>45</small></sup></a>ã€‚
ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ã‚¤ã‚¹ã¯ã€å¤–éƒ¨ã®ã‚·ã‚¹ãƒ†ãƒ ã«ã‚ˆã‚Šä½¿ã‚ã‚Œã‚‹ã¹ãã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’ã‚‚ã€å®šç¾©ã—ã¦ã„ã‚‹<a href="#footnote_Temp_271"><sup><small>46</small></sup></a>ã€‚
ã“ã‚Œã‚‰ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ã€ã‚¿ã‚°ã‚’ãã£ã¤ã‘ã‚‹ã¨ã„ã†ç‚¹ã‚’é™¤ã‘ã°ã€ãƒ™ãƒ³ãŒå†…éƒ¨çš„ã«å®šç¾©ã—ãŸã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¨ãã£ãã‚ŠåŒã˜ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_2450"></a><a name="%_idx_2452"></a>Alyssa's polar package is analogous:</p>

<p class="trans" lang="ja">
ã‚¢ãƒªãƒƒã‚µã®æ¥µè¡¨ç¾ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚‚åŒæ§˜ã ã€‚
</p>

<p class="lisp"><a name="%_idx_2454"></a>(define (install-polar-package)
  <em>;; internal procedures</em>
  (define (magnitude z) (car z))
  (define (angle z) (cdr z))
  (define (make-from-mag-ang r a) (cons r a))
  (define (real-part z)
    (* (magnitude z) (cos (angle z))))
  (define (imag-part z)
    (* (magnitude z) (sin (angle z))))
  (define (make-from-real-imag x y) 
    (cons (sqrt (+ (square x) (square y)))
          (atan y x)))
  <em>;; interface to the rest of the system</em>
  (define (tag x) (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar 
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)
</p>

<p class="orig" lang="en">
Even though Ben and Alyssa both still use their original procedures
defined with the same names as each other's (e.g., <tt>real-part</tt>), these
definitions are now internal to different procedures (see
section <a href="10_sec1_1.html#%_sec_1.1.8">1.1.8</a>), so there is no name
conflict.</p>

<p class="trans" lang="ja">
ãƒ™ãƒ³ã¨ã‚¢ãƒªãƒƒã‚µã¯ã€äºŒäººã¨ã‚‚ä¾ç„¶ã¨ã—ã¦ã€ãŠäº’ã„ã®ã‚‚ã®ã¨åŒã˜åå‰ã§å®šç¾©ã—ãŸã€è‡ªåˆ†ã®å…ƒã®æ‰‹ç¶šã (ãŸã¨ãˆã° <tt>real-part</tt>) ã‚’ä½¿ã£ã¦ã„ã‚‹ã®ã ãŒã€ãã‚Œã§ã‚‚ã€ã“ã‚Œã‚‰ã®å®šç¾©ã¯ä»Šã‚„ã€ç•°ãªã‚‹æ‰‹ç¶šãã®å†…éƒ¨ã«ã‚ã‚Š (<a href="10_sec1_1.html#%_sec_1.1.8">1.1.8</a>ç¯€ã‚’å‚ç…§)ã€ã‚ˆã£ã¦ã€åå‰ã®è¡çªã¯ãªã„ã€‚
</p>

<p class="orig" lang="en">
The complex-arithmetic selectors access the table by means of a
general ``operation'' procedure called <tt>apply-generic</tt>, which
applies a generic operation to some arguments.  <tt>Apply-generic</tt>
looks in the table under the name of the operation and the types of the
arguments and applies the resulting procedure if one is present:<a name="call_footnote_Temp_272" href="#footnote_Temp_272"><sup><small>47</small></sup></a>
</p>

<p class="trans" lang="ja">
è¤‡ç´ æ•°ç®—è¡“ã®ã‚»ãƒ¬ã‚¯ã‚¿ã¯ã€<tt>apply-generic</tt> ã¨å‘¼ã°ã‚Œã‚‹æ±ç”¨ã®ã€Œæ¼”ç®—ã€æ‰‹ç¶šãâ€”â€”ç·ç§°çš„æ¼”ç®—ã‚’ä½•ã‚‰ã‹ã®å¼•æ•°ã«é©ç”¨ã™ã‚‹â€”â€”ã‚’ä»‹ã—ã¦ã€è¡¨ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã€‚
<tt>apply-generic</tt> ã¯ã€ãã®æ¼”ç®—ã®åå‰ã¨å¼•æ•°ã®å‹ã§è¡¨ã‚’èª¿ã¹ã¦ã€ã‚‚ã—æ‰‹ç¶šããŒã‚ã‚Œã°ã€çµæœã¨ã—ã¦å¾—ã‚‰ã‚ŒãŸæ‰‹ç¶šãã‚’é©ç”¨ã™ã‚‹<a href="#footnote_Temp_272"><sup><small>47</small></sup></a>ã€‚
***
</p>

<p class="lisp"><a name="%_idx_2462"></a>(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args))
          (error
            &quot;No method for these types -- APPLY-GENERIC&quot;
            (list op type-tags))))))
</p>

<p class="orig" lang="en">
Using <tt>apply-generic</tt>, we can define our generic selectors as follows:
</p>

<p class="trans" lang="ja">
<tt>apply-generic</tt> ã‚’ä½¿ã†ã¨ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ç·ç§°çš„ãªã‚»ãƒ¬ã‚¯ã‚¿ã‚’å®šç¾©ã§ãã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_2464"></a>(define (real-part z) (apply-generic 'real-part z))
<a name="%_idx_2466"></a>(define (imag-part z) (apply-generic 'imag-part z))
<a name="%_idx_2468"></a>(define (magnitude z) (apply-generic 'magnitude z))
<a name="%_idx_2470"></a>(define (angle z) (apply-generic 'angle z))
</p>

<p class="orig" lang="en">
Observe that these do not change at all if a new representation is
added to the system.</p>

<p class="trans" lang="ja">
æ–°ãŸãªè¡¨ç¾ãŒã‚·ã‚¹ãƒ†ãƒ ã«è¿½åŠ ã•ã‚ŒãŸã¨ã—ã¦ã‚‚ã€ã“ã‚Œã‚‰ãŒã¾ã£ãŸãå¤‰ã‚ã‚‰ãªã„ã€ã¨ã„ã†ã“ã¨ã«æ°—ã¥ã„ã¦ã»ã—ã„ã€‚
</p>

<p class="orig" lang="en">
We can also extract from the table the
constructors to be used by the programs external to the packages in
making complex numbers from real and imaginary parts and from
magnitudes and angles.
As in section <a href="#%_sec_2.4.2">2.4.2</a>, we
construct rectangular numbers whenever we have real and
imaginary parts, and polar numbers whenever we have magnitudes and angles:
</p>

<p class="trans" lang="ja">
è¤‡ç´ æ•°ã‚’å®Ÿéƒ¨ã¨è™šéƒ¨ã‹ã‚‰ä½œã£ãŸã‚Šã€å¤§ãã•ã¨è§’åº¦ã‹ã‚‰ä½œã£ãŸã‚Šã™ã‚‹éš›ã«ã€ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®å¤–éƒ¨ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ã‚ˆã£ã¦ä½¿ã‚ã‚Œã‚‹ã¹ãã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’ã€è¡¨ã‹ã‚‰å–ã‚Šå‡ºã™ã“ã¨ã‚‚ã§ãã‚‹ã€‚
<a href="#%_sec_2.4.2">2.4.2</a>ç¯€ã®ã¨ãŠã‚Šã€ç§ãŸã¡ã¯ã€å®Ÿéƒ¨ã¨è™šéƒ¨ã‚’çŸ¥ã£ã¦ã„ã‚‹ã¨ãã¯ã„ã¤ã§ã‚‚ç›´äº¤å½¢å¼ã®æ•°ã‚’æ§‹ç¯‰ã—ã€å¤§ãã•ã¨è§’åº¦ã‚’çŸ¥ã£ã¦ã„ã‚‹ã¨ãã¯ã„ã¤ã§ã‚‚æ¥µå½¢å¼ã®æ•°ã‚’æ§‹ç¯‰ã™ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_2472"></a>(define (make-from-real-imag x y)
  ((get 'make-from-real-imag 'rectangular) x y))
<a name="%_idx_2474"></a>(define (make-from-mag-ang r a)
  ((get 'make-from-mag-ang 'polar) r a))
</p>

<p class="orig" lang="en">
<a name="%_thm_2.73"></a>
<b>Exercise 2.73.</b>  Section <a href="16_sec2_3.html#%_sec_2.3.2">2.3.2</a> described a program that
performs symbolic differentiation:</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ 2.73</b> <a href="16_sec2_3.html#%_sec_2.3.2">2.3.2</a>ç¯€ã§ã¯ã€è¨˜å·å¾®åˆ†ã‚’è¡Œã†ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ã¤ã„ã¦èª¬æ˜ã—ãŸã€‚
</p>

<a name="%_idx_2476"></a><a name="%_idx_2478"></a>
<p class="lisp">(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp) (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
           (make-product (multiplier exp)
                         (deriv (multiplicand exp) var))
           (make-product (deriv (multiplier exp) var)
                         (multiplicand exp))))
        &lt;<em>more rules can be added here</em>&gt;
        (else (error &quot;unknown expression type -- DERIV&quot; exp))))
</p>

<p class="orig" lang="en">
We can regard this program as performing a dispatch on the type of the
expression to be differentiated.  In this situation the ``type tag'' of the
datum is the algebraic operator symbol (such as <tt>+</tt>) and the
operation being performed is <tt>deriv</tt>.  We can transform this
program into data-directed style by rewriting the basic derivative
procedure as</p>

<p class="trans" lang="ja">
ã“ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ã€å¾®åˆ†ã™ã¹ãå¼ã®å‹ã«ã‚ˆã‚‹<!--é€ã‚Šå‡ºã—-->æŒ¯ã‚Šåˆ†ã‘ã‚’è¡Œã£ã¦ã„ã‚‹ã‚‚ã®ã¨è¦‹ãªã›ã‚‹ã€‚
ã“ã®ç«‹å ´ã§ã¯ã€ãƒ‡ãƒ¼ã‚¿ã®ã€Œå‹ã‚¿ã‚°ã€ã¯ã€(<tt>+</tt> ãªã©ã®) ä»£æ•°çš„æ¼”ç®—å­è¨˜å·ã§ã‚ã‚Šã€å®Ÿè¡Œã•ã‚Œã‚‹æ¼”ç®—ã¨ã¯ã€<tt>deriv</tt> ã§ã‚ã‚‹ã€‚
åŸºæœ¬çš„ãªå¾®åˆ†æ‰‹ç¶šãã‚’æ¬¡ã®ã‚ˆã†ã«æ›¸ãæ›ãˆã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€ã“ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ã€ãƒ‡ãƒ¼ã‚¿æŒ‡å‘ã‚¹ã‚¿ã‚¤ãƒ«ã«å¤‰å½¢ã§ãã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_2480"></a>(define (deriv exp var)
   (cond ((number? exp) 0)
         ((variable? exp) (if (same-variable? exp var) 1 0))
         (else ((get 'deriv (operator exp)) (operands exp)
                                            var))))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
</p>

<ol class="orig" lang="en" style="list-style-type: lower-alpha;" start="1">
<li>Explain what was done above.
Why can't we assimilate the predicates <tt>number?</tt> and <tt>same-variable?</tt> into the data-directed dispatch?</li>
</ol>

<ol class="trans" lang="ja" style="list-style-type: lower-alpha;" start="1">
<li>ä¸Šè¨˜ã§è¡Œã‚ã‚ŒãŸã“ã¨ã‚’èª¬æ˜ã›ã‚ˆã€‚
ãªãœã€<tt>number?</tt> ã¨ <tt>same-variable?</tt> ã¨ã„ã†è¿°èªã‚’ã€ãƒ‡ãƒ¼ã‚¿æŒ‡å‘ã®<!--é€ã‚Šå‡ºã—-->æŒ¯ã‚Šåˆ†ã‘ã«èåˆã™ã‚‹ã“ã¨ãŒã§ããªã„ã®ã‹?
</li>
</ol>

<p class="exercise"><span class="ex_comment"></span>
</p>

<ol class="orig" lang="en" style="list-style-type: lower-alpha;" start="2">
<li>Write the procedures for derivatives of sums and products, and the
auxiliary code required to install them in the table used by the
program above.</li>
</ol>

<ol class="trans" lang="ja"  style="list-style-type: lower-alpha;" start="2">
<li>
å’Œã¨ç©ã®å¾®åˆ†ã«ã¤ã„ã¦ã®æ‰‹ç¶šãã‚’æ›¸ã‘ã€‚ãã—ã¦ã€ä¸Šè¨˜ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ã‚ˆã‚Šä½¿ã‚ã‚Œã‚‹è¡¨ã«ãã‚Œã‚‰ã®æ‰‹ç¶šãã‚’å–ã‚Šè¾¼ã‚€ãŸã‚ã«å¿…è¦ãªã€è£œåŠ©ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã‘ã€‚
</li>
</ol>

<p class="exercise"><span class="ex_comment"></span>
</p>

<ol class="orig" lang="en" style="list-style-type: lower-alpha;" start="3">
<li>Choose any additional differentiation rule that you like, such as
the one for exponents (exercise <a href="16_sec2_3.html#%_thm_2.56">2.56</a>),
and install it in this data-directed system.</li>
</ol>

<ol class="trans" lang="ja" style="list-style-type: lower-alpha;" start="3">
<li>ä½•ã§ã‚‚ã‚ˆã„ã‹ã‚‰å›ã®å¥½ããªè¿½åŠ ã®å¾®åˆ†è¦å‰‡â€”â€”ãŸã¨ãˆã°ã€æŒ‡æ•°ã«ã¤ã„ã¦ã®å¾®åˆ†è¦å‰‡ (ç·´ç¿’å•é¡Œ<a href="16_sec2_3.html#%_thm_2.56">2.56</a>)â€”â€”ã‚’é¸ã‚“ã§ã€ãã‚Œã‚’ã€ã“ã®ãƒ‡ãƒ¼ã‚¿æŒ‡å‘ã‚·ã‚¹ãƒ†ãƒ ã«å–ã‚Šå…¥ã‚Œã‚ˆã€‚</li>
</ol>

<p class="exercise"><span class="ex_comment"></span>
</p>

<ol class="orig" lang="en" style="list-style-type: lower-alpha;" start="4">
<li>In this simple algebraic manipulator the type of an expression is
the algebraic operator that binds it together.  Suppose, however, we
indexed the procedures in the opposite way, so that the dispatch line
in <tt>deriv</tt> looked like</li>
</ol>

<ol class="trans" lang="ja" style="list-style-type: lower-alpha;" start="4">
<li>ã“ã®ç°¡å˜ãªä»£æ•°çš„æ“ä½œå™¨ã§ã¯ã€å¼ã®å‹ã¨ã¯ã€ãã®å¼ã‚’æŸã­ã‚ã’ã¦ã„ã‚‹ä»£æ•°çš„æ¼”ç®—å­ã ã€‚
ã—ã‹ã—ã€é€†ã®ã‚„ã‚Šæ–¹ã§æ‰‹ç¶šãã‚’ç´¢å¼•åŒ–ã—ã¦ã€ãã®çµæœã€<tt>deriv</tt> å†…ã®<!--é€ã‚Šå‡ºã—-->æŒ¯ã‚Šåˆ†ã‘ã®è¡ŒãŒã€ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã£ãŸã®ã ã€ã¨ä»®å®šã›ã‚ˆã€‚
</li>
</ol>

<p class="lisp">((get (operator exp) 'deriv) (operands exp) var)</p>

<p class="orig" lang="en">
What corresponding changes to the derivative system are required?
</p>

<p class="trans" lang="ja">
å¯¾å¿œã™ã‚‹ã©ã®ã‚ˆã†ãªå¤‰æ›´ãŒã€å¾®åˆ†ã‚·ã‚¹ãƒ†ãƒ ã«å¯¾ã—ã¦å¿…è¦ã ã‚ã†ã‹?
</p>


<p class="exercise"><span class="ex_comment"></span>
</p>

<p class="orig" lang="en">
<a name="%_thm_2.74"></a>
<b>Exercise 2.74.</b>  <a name="%_idx_2482"></a><a name="%_idx_2484"></a>Insatiable Enterprises, Inc., is a highly decentralized conglomerate
company consisting of a large number of independent divisions located
all over the world.  The company's computer facilities have just been
interconnected by means of a clever network-interfacing scheme that
makes the entire network appear to any user to be a single computer.
Insatiable's president, in her first attempt to exploit the ability of
the network to extract administrative information from division files,
is dismayed to discover that, although all the division files have
been implemented as data structures in Scheme, the particular data
structure used varies from division to division.  A meeting of
division managers is hastily called to search for a strategy to
integrate the files that will satisfy headquarters' needs while
preserving the existing autonomy of the divisions.</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.74.</b> è²ªæ¬²äº‹æ¥­ç¤¾ã¯ã€ä¸–ç•Œä¸­ã«ã‚ã‚‹å¤šæ•°ã®ç‹¬ç«‹ã—ãŸéƒ¨é–€ã‹ã‚‰ãªã‚‹ã€ã¨ã¦ã‚‚åˆ†æ¨©åŒ–ã•ã‚ŒãŸè¤‡åˆä¼æ¥­ä½“ã®ä¼šç¤¾ã ã€‚
ã“ã®ä¼šç¤¾ã®ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿æ–½è¨­ã¯ã€ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å…¨ä½“ã‚’ã©ã®ãƒ¦ãƒ¼ã‚¶ã«å¯¾ã—ã¦ã‚‚å˜ä¸€ã®ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã®ã‚ˆã†ã«è¦‹ã›ã‹ã‘ã‚‹ã€è³¢ã„ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒ»ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ã‚¤ã‚¹æ¥ç¶šã®ä½“ç³»ã‚’ç”¨ã„ã¦ã€ã¡ã‚‡ã†ã©ç›¸äº’æ¥ç¶šã•ã‚ŒãŸã¨ã“ã‚ã ã€‚
è²ªæ¬²ç¤¾ã®ç¤¾é•·ã¯ã€ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã®èƒ½åŠ›ã‚’æ´»ç”¨ã—ã¦éƒ¨é–€ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰çµŒå–¶ã«é–¢ã™ã‚‹æƒ…å ±ã‚’æŠ½å‡ºã—ã‚ˆã†ã¨ã„ã†æœ€åˆã®è©¦ã¿ã§ã¯ã€ä»¥ä¸‹ã®ã“ã¨ã«æ°—ã¥ã„ã¦å¤±æœ›ã™ã‚‹ã€‚ã™ãªã‚ã¡ã€éƒ¨é–€ãƒ•ã‚¡ã‚¤ãƒ«ã®ã™ã¹ã¦ãŒã€Schemeã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã¨ã—ã¦æ—¢ã«å®Ÿè£…ã•ã‚Œã¦ã„ãŸã«ã‚‚ã‹ã‹ã‚ã‚‰ãšã€ä½¿ã‚ã‚Œã¦ã„ã‚‹ç‰¹å®šã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã¯ã€éƒ¨é–€ã”ã¨ã«é•ã†ã®ã ã€‚
è«¸éƒ¨é–€ã®æ—¢å­˜ã®è‡ªç«‹æ€§ã‚’ä¿ã¡ã¤ã¤ã‚‚ã€æœ¬éƒ¨ã®è¦æ±‚ã‚’æº€ãŸã™ã‚ˆã†ãªã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚’çµ±åˆã™ã‚‹ãŸã‚ã®æˆ¦ç•¥ã‚’æ¢ã™ãŸã‚ã«ã€éƒ¨é–€é•·ãŸã¡ã®ä¼šè­°ãŒå¤§æ€¥ãã§å¬é›†ã•ã‚Œã‚‹ã€‚
</p>

<p class="orig" lang="en">
Show how such a strategy can be implemented with data-directed
programming.  As an example, suppose that each division's personnel
records consist of a single file, which contains a set of records
keyed on employees' names.  The structure of the set varies from
division to division.  Furthermore, each employee's record is itself a
set (structured differently from division to division) that contains
information keyed under identifiers such as <tt>address</tt> and <tt>salary</tt>.  In particular:</p>

<p class="trans" lang="ja">
ã„ã‹ã«ã—ã¦ãã†ã„ã†æˆ¦ç•¥ã‚’ã€ãƒ‡ãƒ¼ã‚¿æŒ‡å‘ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚’ä½¿ã£ã¦å®Ÿè£…ã§ãã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’ç¤ºã›ã€‚
ä¾‹ã¨ã—ã¦ã€å„éƒ¨é–€ã®äººäº‹è¨˜éŒ²ãŒã€å˜ä¸€ã®ãƒ•ã‚¡ã‚¤ãƒ«â€”â€”å¾“æ¥­å“¡ã®åå‰ã«ã‚ˆã‚‹ã‚­ãƒ¼ãŒã¤ã‘ã‚‰ã‚ŒãŸãƒ¬ã‚³ãƒ¼ãƒ‰ã®é›†åˆã‚’å«ã‚“ã§ã„ã‚‹â€”â€”ã‹ã‚‰ãªã‚‹ã€ã¨ä»®å®šã—ã‚ˆã†ã€‚
ãã®é›†åˆã®æ§‹é€ ã¯ã€éƒ¨é–€ã”ã¨ã«é•ã†ã€‚
ã•ã‚‰ã«ã€å„å¾“æ¥­å“¡ã®è¨˜éŒ²ã¯ã€ãã‚Œè‡ªä½“ãŒã€<tt>address</tt> ã‚„ <tt>salary</tt> ãªã©ã®è­˜åˆ¥å­ã®ã‚‚ã¨ã«ã‚­ãƒ¼ãŒã¤ã‘ã‚‰ã‚ŒãŸæƒ…å ±ã‚’å«ã‚€ã‚ˆã†ãªé›†åˆ (éƒ¨é–€ã”ã¨ã«ç•°ãªã‚‹æ–¹æ³•ã§æ§‹é€ åŒ–ã•ã‚Œã¦ã„ã‚‹) ãªã®ã ã€‚
ç‰¹ã«ã€
</p>

<ol class="orig" lang="en" style="list-style-type: lower-alpha;" start="1">
<li> Implement for headquarters a <tt>get-record</tt> procedure that
retrieves a specified employee's record from a specified personnel
file.  The procedure should be applicable to any division's file.
Explain how the individual divisions' files should be structured.  In
particular, what type information must be supplied?</li>
</ol>

<ol class="trans" lang="ja" style="list-style-type: lower-alpha;" start="1">
<li>æŒ‡å®šã•ã‚ŒãŸå¾“æ¥­å“¡ã®è¨˜éŒ²ã‚’ã€æŒ‡å®šã•ã‚ŒãŸäººäº‹ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å–ã‚Šå‡ºã™ã‚ˆã†ãªã€<tt>get-record</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’ã€æœ¬éƒ¨ã®ãŸã‚ã«å®Ÿè£…ã›ã‚ˆã€‚
ãã®æ‰‹ç¶šãã¯ã€ã©ã®éƒ¨é–€ã®ãƒ•ã‚¡ã‚¤ãƒ«ã«ã‚‚é©ç”¨å¯èƒ½ã§ã‚ã‚‹ã¹ãã ã€‚
å€‹ã€…ã®éƒ¨é–€ã®ãƒ•ã‚¡ã‚¤ãƒ«ãŒã€ã©ã®ã‚ˆã†ã«æ§‹é€ åŒ–ã•ã‚Œã¦ã„ã‚‹ã¹ããªã®ã‹ã€èª¬æ˜ã›ã‚ˆã€‚
ç‰¹ã«ã€ã©ã®ã‚ˆã†ãªå‹æƒ…å ±ãŒæä¾›ã•ã‚Œã­ã°ãªã‚‰ãªã„ã®ã‹?
</li>
</ol>

<p class="exercise"><span class="ex_comment"></span>
</p>

<ol class="orig" lang="en" style="list-style-type: lower-alpha;" start="2">
<li>Implement for headquarters a <tt>get-salary</tt> procedure that
returns the salary information from a given employee's record from any
division's personnel file.  How should the record be structured in
order to make this operation work?</li>
</ol>

<ol class="trans" lang="ja" style="list-style-type: lower-alpha;" start="2">
<li>ä»»æ„ã®éƒ¨é–€ã®äººäº‹ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ä¸ãˆã‚‰ã‚ŒãŸå¾“æ¥­å“¡ã®ãƒ¬ã‚³ãƒ¼ãƒ‰ã‹ã‚‰ã€çµ¦æ–™æƒ…å ±ã‚’è¿”ã™ã‚ˆã†ãªã€<tt>get-salary</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’ã€æœ¬éƒ¨ã®ãŸã‚ã«å®Ÿè£…ã›ã‚ˆã€‚
ã“ã®æ¼”ç®—ãŒã†ã¾ãã„ãã‚ˆã†ã«ã™ã‚‹ãŸã‚ã«ã¯ã€ãã®ãƒ¬ã‚³ãƒ¼ãƒ‰ã¯ã€ã©ã®ã‚ˆã†ã«æ§‹é€ åŒ–ã•ã‚Œã¦ã„ã‚‹ã¹ãã ã‚ã†ã‹?
</li>
</ol>

<p class="exercise"><span class="ex_comment"></span>
</p>

<ol class="orig" lang="en" style="list-style-type: lower-alpha;" start="3">
<li>Implement for headquarters a <tt>find-employee-record</tt> procedure.
This should search all the divisions' files for the record of a given
employee and return the record.  Assume that this procedure takes as
arguments an employee's name and a list of all the divisions' files.</li>
</ol>

<ol class="trans" lang="ja" style="list-style-type: lower-alpha;" start="3">
<li><tt>find-employee-record</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’æœ¬éƒ¨ã®ãŸã‚ã«å®Ÿè£…ã›ã‚ˆã€‚
ã“ã‚Œã¯ã€ä¸ãˆã‚‰ã‚ŒãŸå¾“æ¥­å“¡ã®ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’æ±‚ã‚ã¦å…¨éƒ¨é–€ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¢ç´¢ã—ã€ãã®ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’è¿”ã™ã¹ãã§ã‚ã‚‹ã€‚
ã“ã®æ‰‹ç¶šããŒã€å¾“æ¥­å“¡ã®åå‰ã¨ã€è«¸éƒ¨é–€ã®ãƒ•ã‚¡ã‚¤ãƒ«ã™ã¹ã¦ã®ãƒªã‚¹ãƒˆã‚’ã€å¼•æ•°ã¨ã—ã¦ã¨ã‚‹ã‚‚ã®ã¨ä»®å®šã›ã‚ˆã€‚
</li>
</ol>

<p class="exercise"><span class="ex_comment"></span>
</p>

<ol class="orig" lang="en" style="list-style-type: lower-alpha;" start="4">
<li>When Insatiable takes over a new company, what changes must
be made in order to incorporate the new personnel information into the
central system?</li>
</ol>

<ol class="trans" lang="ja" style="list-style-type: lower-alpha;" start="4">
<li>è²ªæ¬²ç¤¾ãŒæ–°ã—ã„ä¼šç¤¾ã‚’è²·åã™ã‚‹å ´åˆã€ä¸­å¤®ã‚·ã‚¹ãƒ†ãƒ ã«æ–°ã—ã„äººäº‹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å–ã‚Šè¾¼ã‚€ãŸã‚ã«ã¯ã€ã©ã®ã‚ˆã†ãªå¤‰æ›´ãŒãªã•ã‚Œãªãã¦ã¯ãªã‚‰ãªã„ã‹?
</li>
</ol>

<p class="exercise"><span class="ex_comment"></span>
</p>

<a name="%_sec_Temp_275"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_275">Message passing</a></h4>
<h4 class="trans" lang="ja">ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ»ãƒ‘ãƒƒã‚·ãƒ³ã‚°</h4>

<p class="orig" lang="en">
<a name="%_idx_2486"></a>
The key idea of data-directed programming is to handle generic
operations in programs by dealing explicitly with operation-and-type
tables, such as the table in figure <a href="#%_fig_2.22">2.22</a>.  The
style of programming we used in section <a href="#%_sec_2.4.2">2.4.2</a>
organized the required dispatching on type by having each operation
take care of its own dispatching.  In effect, this decomposes the
operation-and-type table into rows, with each generic operation
procedure representing a row of the table.</p>

<p class="trans" lang="ja">
ãƒ‡ãƒ¼ã‚¿æŒ‡å‘ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®éµã¨ãªã‚‹è€ƒãˆæ–¹ã¯ã€å›³<a href="#%_fig_2.22">2.22</a>ã®ã‚ˆã†ãªã€æ¼”ç®—ã¨å‹ã®è¡¨ã‚’ã€æ˜ç¤ºçš„ã«æ‰±ã†ã“ã¨ã«ã‚ˆã‚Šã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ å†…ã®ç·ç§°çš„ãªæ¼”ç®—ã‚’å‡¦ç†ã™ã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚
<a href="#%_sec_2.4.2">2.4.2</a>ç¯€ã§ä½¿ã£ãŸãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®æµå„€ã§ã¯ã€å„æ¼”ç®—ã«å½“è©²æ¼”ç®—è‡ªä½“ã®<!--é€ã‚Šå‡ºã—ã‚’å‡¦ç†ã•ã›ã‚‹-->æŒ¯ã‚Šåˆ†ã‘ã®é¢å€’ã‚’è¦‹ã•ã›ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€å¿…è¦ã¨ã•ã‚Œã‚‹ã€å‹ã«ã‚ˆã‚‹<!--é€ã‚Šå‡ºã—-->æŒ¯ã‚Šåˆ†ã‘ã‚’ã€çµ„ç¹”åŒ–ã—ãŸã€‚
å®Ÿéš›ã®ã¨ã“ã‚ã€ã“ã‚Œã¯ã€æ¼”ç®—ã¨å‹ã®è¡¨ã‚’è¡Œã¸ã¨åˆ†è§£ã™ã‚‹ã‚‚ã®ã§ã‚ã‚Šã€ã“ã“ã§ã€ç·ç§°çš„æ¼”ç®—æ‰‹ç¶šãã®å„ã€…ã¯ã€è¡¨ã®ä¸€ã¤ã®è¡Œã‚’ä»£è¡¨ã—ã¦ã„ã‚‹ã€‚
</p>

<p class="orig" lang="en">
An alternative implementation strategy is to decompose the table into
columns and, instead of using ``intelligent operations'' that dispatch
on data types, to work with ``intelligent data objects'' that dispatch
on operation names.  We can do this by arranging things so that a data
object, such as a rectangular number, is represented as a procedure
that takes as input the required operation name and performs the
operation indicated.  In such a discipline, <tt>make-from-real-imag</tt>
could be written as
</p>


<p class="trans" lang="ja">
åˆ¥ã®å®Ÿè£…æˆ¦ç•¥ã¯ã€è¡¨ã‚’åˆ—ã¸ã¨åˆ†è§£ã™ã‚‹ã“ã¨ã€ãã—ã¦ã€ãƒ‡ãƒ¼ã‚¿å‹ã«ã‚ˆã‚‹<!--é€ã‚Šå‡ºã—-->æŒ¯ã‚Šåˆ†ã‘ã‚’è¡Œã†ã€Œè³¢ã„æ¼”ç®—ã€ã‚’ä½¿ã†ä»£ã‚ã‚Šã«ã€æ¼”ç®—åã«ã‚ˆã‚‹<!--é€ã‚Šå‡ºã—-->æŒ¯ã‚Šåˆ†ã‘ã‚’è¡Œã†ã€Œè³¢ã„ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ã‚’ç”¨ã„ã¦ä½œæ¥­ã™ã‚‹ã“ã¨ã€ã§ã‚ã‚‹ã€‚
æ±‚ã‚ã‚‰ã‚Œã‚‹æ¼”ç®—åã‚’å…¥åŠ›ã¨ã—ã¦å–ã£ã¦ã€ãã®ç¤ºã•ã‚ŒãŸæ¼”ç®—ã‚’å®Ÿè¡Œã™ã‚‹ã‚ˆã†ãªæ‰‹ç¶šãã¨ã—ã¦ã€ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆâ€”â€”ãŸã¨ãˆã°ã€ç›´äº¤å½¢å¼ã®æ•°ãªã©â€”â€”ãŒè¡¨ç¾ã•ã‚Œã‚‹ã‚ˆã†ã«ã€ã‚‚ã®ã”ã¨ã‚’æ‰‹é…ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€ã“ã®å®Ÿè£…æˆ¦ç•¥ã‚’é‚è¡Œã§ãã‚‹ã€‚
ãã†ã„ã†è¦å¾‹ã«ã‚ˆã‚Œã°ã€<tt>make-from-real-imag</tt> ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«æ›¸ã‘ãŸã ã‚ã†ã€‚
</p>

<p class="lisp"><a name="%_idx_2488"></a>(define (make-from-real-imag x y)
  (define (dispatch op)
    (cond ((eq? op 'real-part) x)
          ((eq? op 'imag-part) y)
          ((eq? op 'magnitude)
           (sqrt (+ (square x) (square y))))
          ((eq? op 'angle) (atan y x))
          (else
           (error &quot;Unknown op -- MAKE-FROM-REAL-IMAG&quot; op))))
  dispatch)
</p>

<p class="orig" lang="en">
The corresponding <tt>apply-generic</tt> procedure, which applies a
generic operation to an argument, now simply feeds the operation's
name to the data object and lets the object do the work:<a name="call_footnote_Temp_276" href="#footnote_Temp_276"><sup><small>48</small></sup></a>
</p>

<p class="trans" lang="ja">
å¯¾å¿œã™ã‚‹ <tt>apply-generic</tt> ã®æ‰‹ç¶šãâ€”â€”ã“ã‚Œã¯ã€ç·ç§°çš„ãªæ¼”ç®—ã‚’å¼•æ•°ã«é©ç”¨ã™ã‚‹â€”â€”ã¯ã€ã“ã“ã§ã¯å˜ç´”ã«ã€æ¼”ç®—ã®åå‰ã‚’ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ä¸ãˆã¦ã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒåƒãã®ã«ã¾ã‹ã›ã‚‹<a href="#footnote_Temp_276"><sup><small>48</small></sup></a>ã€‚
</p>

<p class="lisp"><a name="%_idx_2490"></a>(define (apply-generic op arg) (arg op))
</p>

<p class="orig" lang="en">
Note that the value returned by <tt>make-from-real-imag</tt> is a
procedure -- the internal <tt>dispatch</tt> procedure.  This is the
procedure that is invoked when <tt>apply-generic</tt> requests an operation to
be performed.</p>

<p class="trans" lang="ja">
<tt>make-from-real-imag</tt> ã«ã‚ˆã‚Šè¿”ã•ã‚Œã‚‹å€¤ãŒã€æ‰‹ç¶šãâ€”â€”ã¤ã¾ã‚Šã€å†…éƒ¨ã® <tt>dispatch</tt> ã¨ã„ã†æ‰‹ç¶šãâ€”â€”ã§ã‚ã‚‹ã“ã¨ã«ã€æ°—ã‚’ã¤ã‘ã‚ˆã€‚
ã“ã‚Œã¯ã€æ¼”ç®—ã‚’å®Ÿè¡Œã™ã‚‹ã‚ˆã† <tt>apply-generic</tt> ãŒæ±‚ã‚ã‚‹ã¨ãã«å‘¼ã³å‡ºã•ã‚Œã‚‹æ‰‹ç¶šãã ã€‚</p>

<p class="orig" lang="en">
This style of programming is called <em>message passing</em>.  The name
comes from the image that a data object is an entity that receives the
requested operation name as a ``message.''  We have already seen an
example of message passing in section <a href="14_sec2_1.html#%_sec_2.1.3">2.1.3</a>, where we saw
how <tt>cons</tt>, <tt>car</tt>, and <tt>cdr</tt> could be defined with no data
objects but only procedures.  Here we see that message passing is not
a mathematical trick but a useful technique for organizing systems
with generic operations.  In the remainder of this chapter we will
continue to use data-directed programming, rather than message
passing, to discuss generic arithmetic operations.  In chapter 3 we
will return to message passing, and we will see that it can be a
powerful tool for structuring simulation programs.</p>

<p class="trans" lang="ja">
ã“ã®ã‚ˆã†ãªãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®æµå„€ã¯ã€<em>ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ»ãƒ‘ãƒƒã‚·ãƒ³ã‚°</em>ã¨å‘¼ã°ã‚Œã‚‹ã€‚
ã“ã®åå‰ã¯ã€ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã¯è¦æ±‚ã•ã‚ŒãŸæ¼”ç®—åã‚’ã€Œãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã€ã¨ã—ã¦å—ã‘å–ã‚‹å®Ÿä½“ã§ã‚ã‚‹ã€ã¨ã„ã†å°è±¡ã«ç”±æ¥ã™ã‚‹ã€‚
ç§ãŸã¡ã¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ»ãƒ‘ãƒƒã‚·ãƒ³ã‚°ã®ä¾‹ã‚’æ—¢ã«<a href="14_sec2_1.html#%_sec_2.1.3">2.1.3</a>ç¯€ã§è¦‹ãŸâ€”â€”ãã“ã§ã¯ã€ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãªã—ã«ã€ãŸã æ‰‹ç¶šãã®ã¿ã§ã€ã©ã†ã‚„ã£ãŸã‚‰ <tt>cons</tt> ã¨ <tt>car</tt> ã¨ <tt>cdr</tt> ã‚’å®šç¾©ã§ãã‚‹ã®ã‹ã‚’è¦‹ãŸã€‚
ã“ã“ã§ã¯ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ»ãƒ‘ãƒƒã‚·ãƒ³ã‚°ã¯æ•°å­¦çš„ãªèŠ¸å½“ã§ã¯ãªãã€ç·ç§°çš„æ¼”ç®—ã‚’ä½¿ã£ãŸã‚·ã‚¹ãƒ†ãƒ ã‚’çµ„ç¹”åŒ–ã™ã‚‹ãŸã‚ã®æœ‰ç”¨ãªæŠ€æ³•ã ã€ã¨ã„ã†ã“ã¨ã‚’è¦‹ã¦ã„ã‚‹ã€‚
æœ¬ç« ã®æ®‹ã‚Šã§ã¯ã€ç·ç§°çš„ãªç®—è¡“æ¼”ç®—ã«ã¤ã„ã¦è­°è«–ã™ã‚‹ãŸã‚ã«ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ»ãƒ‘ãƒƒã‚·ãƒ³ã‚°ã§ã¯ãªãã€ã‚€ã—ã‚ãƒ‡ãƒ¼ã‚¿æŒ‡å‘ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚’ä½¿ã„ç¶šã‘ã‚ˆã†ã€‚
3ç« ã§ã¯ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ»ãƒ‘ãƒƒã‚·ãƒ³ã‚°ã«æˆ»ã‚‹ã“ã¨ã«ã—ã€ã¾ãŸã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ»ãƒ‘ãƒƒã‚·ãƒ³ã‚°ãŒã€ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ»ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ§‹é€ åŒ–ã™ã‚‹ãŸã‚ã®å¼·åŠ›ãªæ‰‹æ®µãŸã‚Šå¾—ã‚‹ã€ã¨ã„ã†ã“ã¨ã‚’è¦‹ã¦ã„ã“ã†ã€‚
</p>

<p class="orig" lang="en">
<a name="%_thm_2.75"></a>
<b>Exercise 2.75.</b>  <a name="%_idx_2492"></a>Implement the constructor <tt>make-from-mag-ang</tt> in message-passing style.
This procedure should be analogous to the <tt>make-from-real-imag</tt>
procedure given above.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.75.</b> ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ»ãƒ‘ãƒƒã‚·ãƒ³ã‚°ã®æµå„€ã§ã€<tt>make-from-mag-ang</tt> ã¨ã„ã†ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’å®Ÿè£…ã›ã‚ˆã€‚
ã“ã®æ‰‹ç¶šãã¯ã€ä¸Šè¿°ã® <tt>make-from-real-imag</tt> ã¨ã„ã†æ‰‹ç¶šãã¨é¡ä¼¼ã§ã‚ã‚‹ã€‚
</p>

<p class="exercise"><span class="ex_comment"></span>
</p>

<p class="orig" lang="en">
<a name="%_thm_2.76"></a>
<b>Exercise 2.76.</b>  <a name="%_idx_2494"></a>As a large system with generic operations evolves, new types of data
objects or new operations may be needed.  For each of the three
strategies -- generic operations with explicit dispatch, data-directed
style, and message-passing-style -- describe the changes that must be
made to a system in order to add new types or new operations.  Which
organization would be most appropriate for a system in which new types
must often be added?  Which would be most appropriate for a system in
which new operations must often be added?
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ2.76.</b> ç·ç§°çš„æ¼”ç®—ã‚’ä½¿ã£ãŸå¤§è¦æ¨¡ã‚·ã‚¹ãƒ†ãƒ ãŒé€²åŒ–ã™ã‚‹ã«ã¤ã‚Œã¦ã€ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ–°ãŸãªå‹ã‹ã€æ–°ãŸãªæ¼”ç®—ãŒå¿…è¦ã«ãªã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚
ä¸‰ã¤ã®æˆ¦ç•¥â€”â€”æ˜ç¤ºçš„ãªæŒ¯ã‚Šåˆ†ã‘ã‚’ä¼´ã†ç·ç§°çš„æ¼”ç®—ã€ãƒ‡ãƒ¼ã‚¿æŒ‡å‘ã®æµå„€ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ»ãƒ‘ãƒƒã‚·ãƒ³ã‚°â€”â€”ã®å„ã€…ã«ã¤ã„ã¦ã€æ–°ãŸãªå‹ã¾ãŸã¯æ–°ãŸãªæ¼”ç®—ã‚’è¿½åŠ ã™ã‚‹ãŸã‚ã«ã€ã‚·ã‚¹ãƒ†ãƒ ã«å¯¾ã—ã¦ãªã•ã‚Œãªãã¦ã¯ãªã‚‰ãªã„å¤‰æ›´ã‚’ã€èª¬æ˜ã›ã‚ˆã€‚
æ–°ãŸãªå‹ãŒã—ã°ã—ã°è¿½åŠ ã•ã‚Œã­ã°ãªã‚‰ãªã„ã‚ˆã†ãªã‚·ã‚¹ãƒ†ãƒ ã«å¯¾ã—ã¦ã€ã‚‚ã£ã¨ã‚‚é©åˆ‡ãªã®ã¯ã€ã©ã®çµ„ç¹”åŒ–ã®ä»•æ–¹ã ã‚ã†?
æ–°ãŸãªæ¼”ç®—ãŒã—ã°ã—ã°è¿½åŠ ã•ã‚Œã­ã°ãªã‚‰ãªã„ã‚ˆã†ãªã‚·ã‚¹ãƒ†ãƒ ã«å¯¾ã—ã¦ã€ã‚‚ã£ã¨ã‚‚é©åˆ‡ãªã®ã¯ã€ã©ã‚Œã ã‚ã†?
</p>

<p class="exercise"><span class="ex_comment"></span>
</p>


<a name="footnotes"></a>
<hr>
<p class="orig" lang="en">
<a name="footnote_Temp_268" href="#call_footnote_Temp_268"><sup><small>43</small></sup></a> In actual computational systems, rectangular form is
preferable to polar form most of the time because of <a name="%_idx_2308"></a>roundoff errors
in conversion between rectangular and polar form.  This is why the
complex-number example is unrealistic.  Nevertheless, it provides a
clear illustration of the design of a system using generic operations
and a good introduction to the more substantial systems to be
developed later in this chapter.</p>

<p class="trans" lang="ja">
å®Ÿéš›ã®è¨ˆç®—ã‚·ã‚¹ãƒ†ãƒ ã§ã¯ã€ç›´äº¤å½¢å¼ã¨æ¥µå½¢å¼ã®é–“ã§ã®å¤‰æ›ã«ãŠã‘ã‚‹ä¸¸ã‚èª¤å·®ãŒåŸå› ã§ã€å¤§ä½“ã„ã¤ã‚‚ã¯ã€æ¥µå½¢å¼ã‚ˆã‚Šã‚‚ç›´äº¤å½¢å¼ã®æ–¹ãŒå¥½ã¾ã—ã„ã€‚
ã“ã‚ŒãŒã€è¤‡ç´ æ•°ã®ä¾‹ãŒãªãœéç¾å®Ÿçš„ãªã®ã‹ã€ã¨ã„ã†ç†ç”±ã ã€‚
ãã‚Œã«ã‚‚ã‹ã‹ã‚ã‚‰ãšã€è¤‡ç´ æ•°ã®ä¾‹ã¯ã€ç·ç§°çš„æ¼”ç®—ã‚’ä½¿ã†ã‚·ã‚¹ãƒ†ãƒ ã®è¨­è¨ˆã«ã¤ã„ã¦ã®æ˜å¿«ãªè§£èª¬ã‚’ç¤ºã—ã¦ã„ã‚‹ã—ã€æœ¬ç« ã§å¾Œã«é–‹ç™ºã™ã¹ãã€ã‚ˆã‚Šé‡è¦ãªè«¸ã‚·ã‚¹ãƒ†ãƒ ã¸ã®ã€è‰¯ã„å°å…¥éƒ¨ã¨ãªã£ã¦ã„ã‚‹ã€‚
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_269" href="#call_footnote_Temp_269"><sup><small>44</small></sup></a> The arctangent function referred to
<a name="%_idx_2322"></a><a name="%_idx_2324"></a><a name="%_idx_2326"></a>here, computed by Scheme's <tt>atan</tt> procedure,
is defined so as to take two arguments <em>y</em> and <em>x</em> and to return
the angle whose tangent is <em>y</em>/<em>x</em>.  The signs of the arguments
determine the quadrant of the angle.</p>

<p class="trans" lang="ja">
ã“ã“ã§å‚ç…§ã•ã‚Œã¦ã„ã‚‹ã‚¢ãƒ¼ã‚¯ã‚¿ãƒ³ã‚¸ã‚§ãƒ³ãƒˆé–¢æ•°â€”â€”Schemeã® <tt>atan</tt> ã¨ã„ã†æ‰‹ç¶šãã«ã‚ˆã‚Šè¨ˆç®—ã•ã‚Œã‚‹â€”â€”ã¯ã€<em class="en">y</em> ã¨ <em class="en">x</em> ã¨ã„ã†äºŒã¤ã®å¼•æ•°ã‚’ã¨ã£ã¦ã€ã‚¿ãƒ³ã‚¸ã‚§ãƒ³ãƒˆãŒ <em class="en">y</em>/<em class="en">x</em> ã§ã‚ã‚‹ã‚ˆã†ãªè§’åº¦ã‚’è¿”ã™ã‚ˆã†ã«ã€å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã€‚
ã“ã‚Œã‚‰å¼•æ•°ã®ç¬¦å·ã«ã‚ˆã‚Šã€å½“è©²è§’åº¦ã®è±¡é™ãŒæ±ºã¾ã‚‹ã€‚
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_270" href="#call_footnote_Temp_270"><sup><small>45</small></sup></a> We use the list <tt>(rectangular)</tt>
rather than the symbol <tt>rectangular</tt> to allow for the possibility
of operations with multiple arguments, not all of the same
type.</p>

<p class="trans" lang="ja">
ã™ã¹ã¦ãŒåŒã˜å‹ã ã¨ã¯é™ã‚‰ãªã„è¤‡æ•°ã®å¼•æ•°ã‚’ã¨ã‚‹æ¼”ç®—ã®å¯èƒ½æ€§ã‚’è¦‹è¶Šã—ã¦ã€ç§ãŸã¡ã¯ã€<tt>rectangular</tt> ã¨ã„ã†è¨˜å·ã‚ˆã‚Šã‚€ã—ã‚ã€<tt>(rectangular)</tt> ã¨ã„ã†ãƒªã‚¹ãƒˆã‚’ä½¿ã†ã€‚
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_271" href="#call_footnote_Temp_271"><sup><small>46</small></sup></a> The
type the constructors are installed under needn't be a list because
a constructor is always used to make an object of one particular
type.</p>

<p class="trans" lang="ja">
ãã®å‹ã®ã‚‚ã¨ã«ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãŒçµ„ã¿å…¥ã‚Œã‚‰ã‚Œã‚‹ã€ã¨ã„ã†å‹ã¯ã€ãƒªã‚¹ãƒˆã§ãªãã¦ã‚‚ã‚ˆã„ã€‚ã¨ã„ã†ã®ã‚‚ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯å¸¸ã«ã€ç‰¹å®šã®ä¸€ã¤ã®å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œã‚‹ãŸã‚ã«ã€ä½¿ã‚ã‚Œã‚‹ã‹ã‚‰ã ã€‚
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_272" href="#call_footnote_Temp_272"><sup><small>47</small></sup></a> <tt>Apply-generic</tt> uses the <a name="%_idx_2456"></a>dotted-tail notation described in
exercise <a href="15_sec2_2.html#%_thm_2.20">2.20</a>, because different generic operations
may take different numbers of arguments.  In <tt>apply-generic</tt>, <tt>op</tt> has as its value the first argument to <tt>apply-generic</tt> and
<tt>args</tt> has as its value a list of the remaining arguments.</p>

<p class="trans" lang="ja">
<tt>apply-generic</tt> ã¯ã€ç·´ç¿’å•é¡Œ<a href="15_sec2_2.html#%_thm_2.20">2.20</a>ã§èª¬æ˜ã—ãŸã€ãƒ‰ãƒƒãƒˆä»˜ãæœ«å°¾ã®è¨˜æ³•ã‚’ä½¿ã£ã¦ã„ã‚‹ã€‚ã¨ã„ã†ã®ã‚‚ã€ç•°ãªã‚‹ç·ç§°çš„æ¼”ç®—ã¯ã€ç•°ãªã‚‹æ•°ã®å¼•æ•°ã‚’ã¨ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã‹ã‚‰ã ã€‚
<tt>apply-generic</tt> ã®ä¸­ã§ã¯ã€<tt>op</tt> ã¯ã€ãã®å€¤ã¨ã—ã¦ã€<tt>apply-generic</tt> ã®ç¬¬ä¸€å¼•æ•°ã‚’æœ‰ã—ã€<tt>args</tt> ã¯ã€ãã®å€¤ã¨ã—ã¦ã€æ®‹ã‚Šã®å¼•æ•°ã®ãƒªã‚¹ãƒˆã‚’æœ‰ã™ã‚‹ã€‚
</p>

<p class="orig" lang="en">
<tt>Apply-generic</tt> also uses the primitive procedure <a name="%_idx_2458"></a><a name="%_idx_2460"></a><tt>apply</tt>,
which takes two arguments, a procedure and a list.  <tt>Apply</tt>
applies the procedure, using the elements in the list as arguments.
For example,</p>

<p class="trans" lang="ja">
<tt>apply-generic</tt> ã¯ã€<tt>apply</tt> ã¨ã„ã†åŸå§‹çš„æ‰‹ç¶šãâ€”â€”æ‰‹ç¶šãã¨ãƒªã‚¹ãƒˆã¨ã„ã†ã€äºŒã¤ã®å¼•æ•°ã‚’ã¨ã‚‹â€”â€”ã‚‚ä½¿ã†ã€‚
<tt>apply</tt> ã¯ã€ãã®ãƒªã‚¹ãƒˆå†…ã®è¦ç´ ã‚’å¼•æ•°ã¨ã—ã¦ç”¨ã„ã¦ã€ãã®æ‰‹ç¶šãã‚’é©ç”¨ã™ã‚‹ã€‚ä¾‹ãˆã°ã€
</p>

<p class="lisp">(apply + (list 1 2 3 4))</p>

<p class="orig" lang="en">returns 10.</p>

<p class="trans" lang="ja">
ã¯ã€10ã‚’è¿”ã™ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_276" href="#call_footnote_Temp_276"><sup><small>48</small></sup></a> One
limitation of this organization is it permits only generic procedures
of one argument.</p>

<p class="trans" lang="ja">
ã“ã®çµ„ç¹”åŒ–ã®ä»•æ–¹ä¸€ã¤ã®é™ç•Œã¯ã€ã“ã®çµ„ç¹”åŒ–ã®ä»•æ–¹ã§ã¯ã€ä¸€å¼•æ•°ã®ç·ç§°çš„æ¼”ç®—ã—ã‹è¨±ã•ã‚Œãªã„ç‚¹ã ã€‚
</p>

</div>

</body>
</html>
