<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="sicp.css" type="text/css">
<base target="_top">
<title>SICP私訳: 3.2 評価についての環境モデル</title>
<link rel="canonical" href="https://piyo-ko.github.io/SICP/21_sec3_2.html" />
</head>
<body>

<div class="idx-bar">
<nav>
<a href="https://twitter.com/share" class="twitter-share-button" data-lang="ja">ツイート</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
<span class="status">推敲待ち</span>
[
<a href="00_cover.html">先頭へ</a> |
<a href="20_sec3_1.html">前へ</a> |
<a href="22_sec3_3.html">次へ</a> |
<a href="04_toc.html#%_toc_start">目次</a> |
<a href="38_index.html#%_index_start">索引</a>
] [<a href="99_about.html">この対訳版について</a> | <a href="../index.html">ホーム</a>]
[
§<a href="#%_sec_3.2">3.2</a>
🎨<a href="#%_fig_3.1">3.1</a>
§<a href="#%_sec_3.2.1">3.2.1</a>
🎨<a href="#%_fig_3.2">3.2</a>
🎨<a href="#%_fig_3.3">3.3</a>
§<a href="#%_sec_3.2.2">3.2.2</a>
🎨<a href="#%_fig_3.4">3.4</a>
🎨<a href="#%_fig_3.5">3.5</a>
📝<a href="#%_thm_3.9">3.9</a>
§<a href="#%_sec_3.2.3">3.2.3</a>
🎨<a href="#%_fig_3.6">3.6</a>
🎨<a href="#%_fig_3.7">3.7</a>
🎨<a href="#%_fig_3.8">3.8</a>
🎨<a href="#%_fig_3.9">3.9</a>
🎨<a href="#%_fig_3.10">3.10</a>
📝<a href="#%_thm_3.10">3.10</a>
§<a href="#%_sec_3.2.4">3.2.4</a>
🎨<a href="#%_fig_3.11">3.11</a>
📝<a href="#%_thm_3.11">3.11</a>
<a href="#footnotes">脚注</a>
]</nav>
</div>

<div class="main-txt">


<a name="%_sec_3.2"></a>
<h2 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_3.2">3.2  The Environment Model of Evaluation</a></h2>
<h2 class="trans" lang="ja">3.2 評価についての環境モデル</h2>

<p class="orig" lang="en">
<a name="%_idx_3034"></a>
When we introduced compound procedures in chapter 1, we used the
<a name="%_idx_3036"></a>substitution model of evaluation
(section <a href="10_sec1_1.html#%_sec_1.1.5">1.1.5</a>) to define what is meant by
applying a procedure to arguments:
</p>

<p class="trans" lang="ja">
1章で複合的手続きを導入したとき、私たちは、引数に手続きを適用することが意味することとは何か、を定義するために、評価についての<ruby><rb>代入</rb><rp> (</rp><rt>おきかえ</rt><rp>) </rp></ruby>モデルを使った (<a href="10_sec1_1.html#%_sec_1.1.5">1.1.5</a>節)。
</p>

<ul class="orig" lang="en">
<li>To apply a compound procedure to arguments, evaluate the body of the
procedure with each formal parameter replaced by the corresponding
argument.</li>
</ul>

<ul class="trans" lang="ja">
<li>引数に複合的手続きを適用するには、各仮引数をそれに対応する実引数で置き換えた状態の、手続きの本体を、評価せよ。</li>
</ul>

<p class="orig" lang="en">
Once we admit assignment into our programming language, such a
definition is no longer adequate.  In particular,
section <a href="20_sec3_1.html#%_sec_3.1.3">3.1.3</a> argued that, in the presence of
assignment, a variable can no longer be considered to be merely a name
for a value.  Rather, a variable must somehow designate a ``place'' in
which values can be stored.  In our new model of evaluation, these
places will be maintained in structures called <a name="%_idx_3038"></a><em>environments</em>.
</p>

<p class="trans" lang="ja">
一旦、プログラミング言語に<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>を受け入れることを認めるや、このような定義は、もはや適切ではなくなってしまう。
特に、<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>があると、変数はもはや値のための単なる名前だとは考えられなくなる、ということを、<a href="20_sec3_1.html#%_sec_3.1.3">3.1.3</a>節で主張した。
むしろ、変数は、値を格納できる「場所」を何らかの方法で指定しているに違いない。
評価についての私たちの新たなモデルでは、これらの場所は、<em>環境</em>と呼ばれる構造の中に維持されるだろう。
</p>

<p class="orig" lang="en">
An environment is a sequence of <a name="%_idx_3040"></a><em>frames</em>.  Each frame is a table
(possibly empty) of <a name="%_idx_3042"></a><em>bindings</em>, which associate variable names with
their corresponding values.  (A single frame may contain at most one
binding for any variable.)  Each frame also has a pointer to its <a name="%_idx_3044"></a><a name="%_idx_3046"></a><em>enclosing environment</em>, unless, for the purposes of discussion, the
frame is considered to be <a name="%_idx_3048"></a><a name="%_idx_3050"></a><em>global</em>.  The <a name="%_idx_3052"></a><em>value of a variable</em>
with respect to an environment is the value given by the binding of
the variable in the first frame in the environment that contains a
binding for that variable.  If no frame in the sequence specifies a
binding for the variable, then the variable is said to be <a name="%_idx_3054"></a><a name="%_idx_3056"></a><em>unbound</em> in the environment.
</p>

<p class="trans" lang="ja">
環境とは、<em>フレーム</em>の連なりである。
各フレームは、<em>束縛</em>の表 (空のこともある) であり、この表は、変数名をそれに対応する値に関連づける。
(一つのフレームは、どの変数に対しても、最大で一つの束縛だけを含むことができる。)
各フレームには、自分の<em>外側を囲っている環境</em>へのポインタもある——議論のために、そのフレームが<em>大域的</em>だと見なされない限りは。
ある環境に関しての<em>変数の値</em>は、その変数に対する束縛を含むような、その環境内で最初のフレームにおける、その変数の束縛によって、与えられる値である。
もし、連なりの中のどのフレームも、その変数に対する束縛を指定していなければ、その変数は、その環境内では<em>束縛されていない</em>と言われる。
</p>

<a name="%_fig_3.1"></a>
<figure>
<img src="ch3-Z-G-2.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.1:</b>  A simple environment structure.</figcaption>
<figcaption class="trans" lang="ja"><b>図3.1:</b> 簡単な環境の構造</figcaption>
</figure>
<a name="%_idx_3058"></a>

<p class="orig" lang="en">
Figure <a href="#%_fig_3.1">3.1</a> shows a simple environment
structure consisting of three frames, labeled I, II, and III.  In the
diagram, A, B, C, and D are pointers to environments.  C and D point
to the same environment.  The variables <tt>z</tt> and <tt>x</tt> are bound
in frame II, while <tt>y</tt> and <tt>x</tt> are bound in frame I.  The
value of <tt>x</tt> in environment D is 3.  The value of <tt>x</tt> with
respect to environment B is also 3.  This is determined as follows: We
examine the first frame in the sequence (frame III) and do not find a
binding for <tt>x</tt>, so we proceed to the enclosing environment D and
find the binding in frame I.  On the other hand, the value of <tt>x</tt>
in environment A is 7, because the first frame in the sequence (frame
II) contains a binding of <tt>x</tt> to 7.  With respect to environment
A, the binding of <tt>x</tt> to 7 in frame II is said to <a name="%_idx_3060"></a><em>shadow</em> the
binding of <tt>x</tt> to 3 in frame I.
</p>

<p class="trans" lang="ja">
図<a href="#%_fig_3.1">3.1</a>は、I、II、IIIとラベルづけされた三つのフレームからなる、簡単な環境の構造を示している。
この図において、A、B、C、Dは、環境へのポインタである。
CとDは、同じ環境を指している。
<tt>z</tt> と <tt>x</tt> という変数がフレームIIで束縛されており、その一方で、<tt>y</tt> と <tt>x</tt> がフレームIで束縛されている。
環境Dにおける <tt>x</tt> の値は3である。
環境Bについての <tt>x</tt> の値も3である。
これは以下のようにして決定される。
連なりのうちの最初のフレーム (フレームIII) を吟味し、<tt>x</tt> に対する束縛が見つからないので、外側を囲っている環境Dに進んで、フレームIにおいて束縛を見つける。
他方、環境Aにおける<tt>x</tt> の値は7である。というのも、連なりのうちの最初のフレーム (フレームII) が、<tt>x</tt> の7への束縛を含んでいるからである。
環境Aに関しては、フレームIIにおける <tt>x</tt> の7への束縛が、フレームIにおける <tt>x</tt> の3への束縛を<em>影で覆い隠す</em>、というふうに言われる
</p>

<p class="orig" lang="en">
The environment is crucial to the evaluation process,
because it determines the context in which an expression should be
evaluated.  Indeed, one could say that expressions in a programming
language do not, in themselves, have any meaning.  Rather, an
expression acquires a meaning only with respect to some environment in
which it is evaluated.  Even the interpretation of an expression as
straightforward as <tt>(+ 1 1)</tt> depends on an understanding that one
is operating in a context in which <tt>+</tt> is the symbol for addition.
Thus, in our model of evaluation we will always speak of evaluating an
expression with respect to some environment.  To describe interactions
with the interpreter, we will suppose that there is a <a name="%_idx_3062"></a>global
environment, consisting of a single frame (with no enclosing
environment) that includes values for the symbols associated with the
primitive procedures.  For example, the idea that <tt>+</tt> is the
symbol for addition is captured by saying that the symbol <tt>+</tt> is
bound in the global environment to the primitive addition procedure.
</p>

<p class="trans" lang="ja">
環境は、評価プロセスにとって決定的に重要である。というのも、環境は、式が評価されるべき文脈を決定するからだ。
実際、プログラミング言語における式とは、それ自体では何の意味も持たないのだ、と言うことだってできるだろう。
むしろ、式は、その式が評価される何らかの環境に関してのみ、意味を獲得する。
<tt>(+ 1 1)</tt> のような簡単な式の解釈ですら、<tt>+</tt> が加算のための記号であるような文脈において作業しているところなのだ、という理解に依存する。
よって、評価についての私たちのモデルにおいて、私たちは常に、何らかの環境に関して式を評価する、ということに言及するだろう。
インタプリタとの間のやりとりを説明するために、大域環境——原始的手続きと関連づけられた記号に対する値を含むような、単一のフレーム (外側を囲っている環境がないもの) のみからなる——がある、と想定しよう。
たとえば、<tt>+</tt> とは加算のための記号である、という概念は、<tt>+</tt> という記号が大域環境においては原始的加算手続きに束縛されている、と言うことによって、うまく捉えられる。
</p>

<a name="%_sec_3.2.1"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_3.2.1">3.2.1  The Rules for Evaluation</a></h3>
<h3 class="trans" lang="ja">3.2.1 評価用規則</h3>

<p class="orig" lang="en">
<a name="%_idx_3064"></a>
The overall specification of how the interpreter evaluates a
combination remains the same as when we first introduced it in
section <a href="10_sec1_1.html#%_sec_1.1.3">1.1.3</a>:
</p>

<p class="trans" lang="ja">
インタプリタがどのようにコンビネーションを評価するのかについての全般的な明細は、<a href="10_sec1_1.html#%_sec_1.1.3">1.1.3</a>節でそのことを最初に持ち込んだときと同じままである。すなわち、
</p>

<ul class="orig" lang="en">
<li>To evaluate a combination:
<ol>
<li>Evaluate the subexpressions of the
combination.<a name="call_footnote_Temp_342" href="#footnote_Temp_342"><sup><small>12</small></sup></a></li>
<li>Apply the value of the operator subexpression to the values of the
operand subexpressions.</li>
</ol>
</li>
</ul>

<ul class="trans" lang="ja">
<li>コンビネーションを評価するためには、
<ol>
<li>そのコンビネーションの部分式を評価せよ<a href="#footnote_Temp_342"><sup><small>12</small></sup></a>。</li>
<li>オペレータ部分式の値を、オペランド部分式の値に適用せよ。</li>
</ol>
</li>
</ul>

<p class="orig" lang="en">
The environment model of evaluation replaces the substitution model in
specifying what it means to apply a compound procedure to arguments.
</p>

<p class="trans" lang="ja">
引数に複合的手続きを適用することの意味を規定するところで、評価についての環境モデルが、<ruby><rb>代入</rb><rp> (</rp><rt>おきかえ</rt><rp>) </rp></ruby>モデルに取って代わる。
</p>

<p class="orig" lang="en">
In the environment model of evaluation, a procedure is always a pair
consisting of some code and a pointer to an environment.  Procedures
are created in one way only: by evaluating a <tt>lambda</tt> expression.
<a name="%_idx_3070"></a>This produces a procedure whose code is obtained from the text of the
<tt>lambda</tt> expression and whose environment is the environment in
which the <tt>lambda</tt> expression was evaluated to produce the
procedure.  For example, consider the procedure definition</p>

<p class="trans" lang="ja">
評価についての環境モデルにおいては、手続きは常に、何らかのコードと、環境へのポインタとの対である。
手続きは一つのやり方でのみ、作成される——つまり、<tt>lambda</tt> 式を評価することによって。
これは、次のような手続きを作り出す——その手続きのコードは、<tt>lambda</tt> 式のテキストから得られ、かつ、その手続きの環境とは、その手続きを作り出すために <tt>lambda</tt> 式が評価された環境である、というような手続きである。
例えば、次の手続き定義
</p>

<p class="lisp"><a name="%_idx_3072"></a>(define (square x)
  (* x x))
</p>

<p class="orig" lang="en">
evaluated in the global environment.  The procedure definition syntax
is just syntactic sugar for an underlying implicit <tt>lambda</tt>
expression.  It would have been equivalent to have used</p>

<p class="trans" lang="ja">
——大域環境で評価される——を考えよう。
手続き定義構文は、根底にある暗黙裡の <tt>lambda</tt> 式のための単なる糖衣構文だ。
これは、以下のものを使ったことと、等価になったであろう。
</p>


<p class="lisp">(define square
  (lambda (x) (* x x)))
</p>

<p class="orig" lang="en">
which evaluates <tt>(lambda (x) (* x x))</tt> and binds <tt>square</tt> to the resulting value, all in the global environment.</p>

<p class="trans" lang="ja">
これは、<tt>(lambda (x) (* x x))</tt> を評価して、結果として生じる値に <tt>square</tt> を束縛し、そのすべてを大域環境で行うものである。
</p>

<p class="orig" lang="en">
Figure <a href="#%_fig_3.2">3.2</a> shows the result of evaluating this
<tt>define</tt> expression.  The procedure object is a pair whose code
specifies that the procedure has one formal parameter, namely <tt>x</tt>,
and a procedure body <tt>(* x x)</tt>.  The environment part of the
procedure is a pointer to the global environment, since that is the
environment in which the <tt>lambda</tt> expression was evaluated to
produce the procedure. A new binding, which associates the procedure
object with the symbol <tt>square</tt>, has been added to the global
frame.  In general, <tt>define</tt> creates definitions by adding
bindings to frames.</p>

<p class="trans" lang="ja">
図<a href="#%_fig_3.2">3.2</a> は、この <tt>define</tt> 式を評価した結果を示す。
手続きオブジェクトは、この手続きには一つの仮引数——つまり <tt>x</tt> ——と <tt>(* x x)</tt> という手続き本体があるのだ、とコードが明細を述べているような、対である。
手続きの環境部は、大域環境へのポインタである。というのは、その大域環境こそが、この手続きを作り出すために <tt>lambda</tt> 式が評価された環境だからである。
新たな束縛——この手続きオブジェクトを、<tt>square</tt> という記号に関連づける——が、大域フレームに追加された。
一般に、<tt>definde</tt> は、フレームに束縛を追加することによって、定義を作成する。
</p>


<a name="%_fig_3.2"></a>
<figure>
<img src="ch3-Z-G-3.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.2:</b>  Environment structure produced by
evaluating <tt>(define (square x) (* x x))</tt> in the global environment.</figcaption>
<figcaption class="trans" lang="ja"><b>図3.2:</b> 大域環境で <tt>(define (square x) (* x x))</tt> を評価することで作り出される環境構造</figcaption>
</figure>

<p class="orig" lang="en">
Now that we have seen how procedures are created, we can describe how
procedures are applied.  The environment model specifies: To apply a
procedure to arguments, create a new environment containing a frame
that binds the parameters to the values of the arguments.  The
enclosing environment of this frame is the environment specified by
the procedure.  Now, within this new environment, evaluate the
procedure body.</p>

<p class="trans" lang="ja">
手続きがどのように作成されるのかを見たからには、私たちはもう、手続きがどのように適用されるのかを記述できる。
環境モデルは、こう規定する。すなわち、引数に手続きを適用するには、仮引数を実引数の値に束縛するフレームを含む、新たな環境を作成せよ、と。
このフレームにとっての、外側を囲っている環境とは、手続きによって指定される環境である。
そしてここで、新たな環境の中で、手続き本体を評価せよ。
</p>

<p class="orig" lang="en">
To show how this rule is followed, figure <a href="#%_fig_3.3">3.3</a>
illustrates the environment structure created by evaluating the
expression <tt>(square 5)</tt> in the global environment, where <tt>square</tt> is the procedure generated in
figure <a href="#%_fig_3.2">3.2</a>.  Applying the procedure results in
the creation of a new environment, labeled E1 in the figure, that
begins with a frame in which <tt>x</tt>, the formal parameter for the
procedure, is bound to the argument 5.  The pointer leading upward
from this frame shows that the frame's enclosing environment is the
global environment.  The global environment is chosen here, because
this is the environment that is indicated as part of the <tt>square</tt>
procedure object.  Within E1, we evaluate the body of the procedure,
<tt>(* x x)</tt>.  Since the value of <tt>x</tt> in E1 is 5, the result is
<tt>(* 5 5)</tt>, or 25.</p>

<p class="trans" lang="ja">
この規則がどのようにして守られるのか、を示すために、図<a href="#%_fig_3.3">3.3</a>は、大域環境において <tt>(square 5)</tt> という式を評価することによって作成される環境構造を示している——ただしここで、<tt>square</tt> は、図<a href="#%_fig_3.2">3.2</a>で生成された手続きである。手続きの適用は、<tt>x</tt> ——この手続きの仮引数——が実引数の5に束縛されるフレームで始まる、新たな環境——図では E1 とラベルづけされている——の作成、という結果をもたらす。
このフレームから上向きに出ているポインタは、このフレームの外側を囲っている環境が大域環境であることを示す。
大域環境は、これこそが、<tt>square</tt> の手続きオブジェクトの一部として示される環境であるので、ここで選ばれているわけだ。
E1の中で、手続きの本体——すなわち <tt>(* x x)</tt> ——を、評価する。
E1内での <tt>x</tt> の値は5なので、結果は <tt>(* 5 5)</tt> 、つまり25である。
</p>

<a name="%_fig_3.3"></a>
<figure>
<img src="ch3-Z-G-4.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.3:</b>  Environment created by evaluating <tt>(square 5)</tt> in the global environment.</figcaption>
<figcaption class="trans" lang="ja"><b>図3.3:</b>大域環境で <tt>(square 5)</tt> を評価することで作成される環境</figcaption>
</figure>


<p class="orig" lang="en">
The environment model of procedure application can be summarized by
two rules:</p>

<p class="trans" lang="ja">
手続き適用についての環境モデルは、二つの規則で要約できる。
</p>

<ul class="orig" lang="en">
<li>A procedure object is applied to a set of arguments by
constructing a frame, binding the formal parameters of the procedure
to the arguments of the call, and then evaluating the body of
the procedure in the context of the new environment constructed.  The
new frame has as its enclosing environment the environment part of the
procedure object being applied.</li>

<a name="%_idx_3074"></a><a name="%_idx_3076"></a>
<li>A procedure is created by evaluating a <tt>lambda</tt>
expression relative to a given environment.  The resulting procedure
object is a pair consisting of the text of the <tt>lambda</tt> expression
and a pointer to the environment in which the procedure was created.</li>
</ul>

<ul class="trans" lang="ja">
<li>フレームを構築し、手続きの仮引数をその呼び出しの実引数に束縛し、それから、構築された新たな環境の文脈において手続きの本体を評価することによって、手続きオブジェクトが実引数の集合に適用される。
新たなフレームは、自分の外側を囲っている環境として、いま適用されている手続きオブジェクトの環境部を有する。</li>
<li>手続きは、与えられた環境に関連した <tt>lambda</tt> 式を評価することで、作成される。
結果として生じる手続きオブジェクトは、<tt>lambda</tt> 式のテキストと、その手続きが作成された環境へのポインタと、からなる対である。</li>
</ul>

<p class="orig" lang="en">
<a name="%_idx_3078"></a>We also specify that defining a symbol using <tt>define</tt> creates a
binding in the current environment frame and assigns to the symbol the
indicated value.<a name="call_footnote_Temp_343" href="#footnote_Temp_343"><sup><small>13</small></sup></a>  Finally, we specify the behavior of
<tt>set!</tt>, the operation that forced us to introduce the environment
model in the first place.  Evaluating the expression <tt>(set!
&lt;<em>variable</em>&gt; &lt;<em>value</em>&gt;)</tt> in some environment locates the binding of
the variable in the environment and changes that binding to indicate
the new value.  That is, one finds the first frame in the environment
that contains a binding for the variable and modifies that frame.  If
the variable is unbound in the environment, then <tt>set!</tt> signals
an error.</p>

<p class="trans" lang="ja">
<tt>define</tt> を用いて記号を定義することは、現在の環境フレームでの束縛を作り出し、かつ、示された値をその記号に割り当てるのだ、ということも、私たちは規定する<a href="#footnote_Temp_343"><sup><small>13</small></sup></a>。
最後に、<tt>set!</tt> ——つまり、そもそも私たちが環境モデルを導入せざるを得ないようにした演算——の振る舞いを規定する。
<tt>(set! &lt;<em class="en">variable</em>&gt; &lt;<em class="en">value</em>&gt;)</tt> 
という式をある環境で評価することで、その環境での変数の束縛が探し出され、その束縛は、新たな値を指し示すように変更される。
つまり、その変数に対する束縛を含むような、その環境内での最初のフレームを見つけて、そのフレームを修正するのだ。
もし、その変数がその環境において束縛されていなければ、<tt>set!</tt> はエラーの合図を送る。
</p>

<p class="orig" lang="en">
These evaluation rules, though considerably more complex than the
substitution model, are still reasonably straightforward.  Moreover,
the evaluation model, though abstract, provides a correct description
of how the interpreter evaluates expressions.  In chapter 4 we shall
see how this model can serve as a blueprint for implementing a working
interpreter.  The following sections elaborate the details of the
model by analyzing some illustrative programs.</p>

<p class="trans" lang="ja">
これらの評価規則は、<ruby><rb>代入</rb><rp> (</rp><rt>おきかえ</rt><rp>) </rp></ruby>モデルよりもかなり複雑ではあるが、それでもまだ、まずまず分りやすい。
さらに、評価モデルは、抽象的ではあるが、インタプリタがどのようにして式を評価するのかについての、正しい説明を与える。
4章では、どのようにしてこのモデルが、実用に足るインタプリタを実装するための青写真として役立つことができるのか、ということを見ることにしよう。
以下の節は、いくつかの例示的プログラムを分析することによって、このモデルの詳細を詳しく述べるものである。
</p>


<a name="%_sec_3.2.2"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_3.2.2">3.2.2  Applying Simple Procedures</a></h3>
<h3 class="trans" lang="ja">3.2.2 簡単な手続きを適用する</h3>

<p class="orig" lang="en">
<a name="%_idx_3082"></a><a name="%_idx_3084"></a>
<a name="%_idx_3086"></a>When we introduced the substitution model in
section <a href="10_sec1_1.html#%_sec_1.1.5">1.1.5</a> we showed how the combination
<tt>(f 5)</tt> evaluates to 136, given the following procedure
definitions:</p>

<p class="trans" lang="ja">
<a href="10_sec1_1.html#%_sec_1.1.5">1.1.5</a>節で<ruby><rb>代入</rb><rp> (</rp><rt>おきかえ</rt><rp>) </rp></ruby>モデルを導入したとき、私たちは、以下の手続き定義が与えられた場合にどのようにして <tt>(f 5)</tt> というコンビネーションが136と求まるのか、を示した。
</p>

<p class="lisp">(define (square x)
  (* x x))
(define (sum-of-squares x y)
  (+ (square x) (square y)))
(define (f a)
  (sum-of-squares (+ a 1) (* a 2)))
</p>

<p class="orig" lang="en">
We can analyze the same example using the environment model.
Figure <a href="#%_fig_3.4">3.4</a> shows the three procedure objects
created by evaluating the definitions of <tt>f</tt>, <tt>square</tt>, and
<tt>sum-of-squares</tt> in the global environment.  Each procedure object
consists of some code, together with a pointer to the global
environment.</p>

<p class="trans" lang="ja">
私たちは、環境モデルを使って、同じ事例を分析できる。
図<a href="#%_fig_3.4">3.4</a>は、大域環境において <tt>f</tt> と <tt>square</tt> と <tt>sum-of-squares</tt> の定義を評価することによって作成される三つの手続きオブジェクトを示す。
各手続きオブジェクトは、大域環境へのポインタをともなった、何らかのコードからなる。
</p>

<a name="%_fig_3.4"></a>
<figure>
<img src="ch3-Z-G-5.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.4:</b>  Procedure objects in the global frame.</figcaption>
<figcaption class="trans" lang="ja"><b>図3.4:</b> 大域フレーム内の手続きオブジェクト</figcaption>
</figure>


<p class="orig" lang="en">
In figure <a href="#%_fig_3.5">3.5</a> we see the environment structure created
by evaluating the expression <tt>(f 5)</tt>.  The call to <tt>f</tt> creates
a new environment E1 beginning with a frame in which <tt>a</tt>, the
formal parameter of <tt>f</tt>, is bound to the argument 5.  In E1, we
evaluate the body of <tt>f</tt>:</p>

<p class="trans" lang="ja">
図<a href="#%_fig_3.5">3.5</a>では、<tt>(f 5)</tt> という式を評価することで作成される環境構造を見ている。
<tt>f</tt> に対する呼び出しは、<tt>a</tt> ——すなわち、<tt>f</tt> の仮引数——が5という実引数に束縛されるフレームから始まる、E1という新たな環境を、作成する。
E1で、以下のとおりの <tt>f</tt> の本体を評価する。
</p>

<p class="lisp">(sum-of-squares (+ a 1) (* a 2))
</p>

<a name="%_fig_3.5"></a>
<figure>
<img src="ch3-Z-G-6.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.5:</b>  Environments created by evaluating <tt>(f 5)</tt>
using the procedures in figure <a href="#%_fig_3.4">3.4</a>.</figcaption>
<figcaption class="trans" lang="ja"><b>図3.5:</b> 図<a href="#%_fig_3.4">3.4</a>の手続きを使って <tt>(f 5)</tt> を評価することで作成される環境</figcaption>
</figure>


<p class="orig" lang="en">
To evaluate this combination, we first evaluate the subexpressions.
The first subexpression, <tt>sum-of-squares</tt>, has a value that is a
procedure object.  (Notice how this value is found: We first look in
the first frame of E1, which contains no binding for <tt>sum-of-squares</tt>.  Then we proceed to the enclosing environment,
i.e. the global environment, and find the binding shown in
figure <a href="#%_fig_3.4">3.4</a>.)  The other two subexpressions are
evaluated by applying the primitive operations <tt>+</tt> and <tt>*</tt> to
evaluate the two combinations <tt>(+ a 1)</tt> and <tt>(* a 2)</tt> to
obtain 6 and 10, respectively.</p>

<p class="trans" lang="ja">
このコンビネーションを評価するために、まず、部分式を評価する。
最初の部分式、つまり <tt>sum-of-squares</tt> は、手続きオブジェクトであるような値を持っている。
(この値がどのようにして見つかるのかに注意せよ。E1の最初のフレームの中をまず見ると、そこには <tt>sum-of-squares</tt> に対する束縛が含まれない。そこで、外側を囲っている環境——つまり大域環境——へと進み、図<a href="#%_fig_3.4">3.4</a>に示されている束縛を見つけるのだ。)
残りの二つの部分式は、<tt>+</tt> および <tt>*</tt> という原始的演算を適用して、<tt>(+ a 1)</tt> および <tt>(* a 2)</tt> という二つのコンビネーションを評価し、6および10を得ることによって、それぞれ評価される。
</p>

<p class="orig" lang="en">
Now we apply the procedure object <tt>sum-of-squares</tt> to the
arguments 6 and 10.  This results in a new environment E2 in which the
formal parameters <tt>x</tt> and <tt>y</tt> are bound to the arguments.
Within E2 we evaluate the combination <tt>(+ (square x) (square y))</tt>.
This leads us to evaluate <tt>(square x)</tt>, where <tt>square</tt> is
found in the global frame and <tt>x</tt> is 6.  Once again, we set up a
new environment, E3, in which <tt>x</tt> is bound to 6, and within this
we evaluate the body of <tt>square</tt>, which is <tt>(* x x)</tt>.  Also as
part of applying <tt>sum-of-squares</tt>, we must evaluate the
subexpression <tt>(square y)</tt>, where <tt>y</tt> is 10.  This second call
to <tt>square</tt> creates another environment, E4, in which <tt>x</tt>, the
formal parameter of <tt>square</tt>, is bound to 10.  And within E4 we
must evaluate <tt>(* x x)</tt>.</p>

<p class="trans" lang="ja">
ここで、<tt>sum-of-squares</tt> という手続きオブジェクトを、6と10という実引数に適用する。
これは、<tt>x</tt> および <tt>y</tt> という仮引数がこれらの実引数に束縛された、E2という新たな環境、という結果をもたらす。
E2の中で、<tt>(+ (square x) (square y))</tt> というコンビネーションを評価する。
これにより、<tt>(square x)</tt> を評価することになるのだが、ここで <tt>square</tt> は大域フレームの中で見つかり、<tt>x</tt> は6である。
<tt>x</tt> が6に束縛されているような新たな環境——すなわちE3——を再び設定し、この新たな環境の中で、<tt>square</tt> の本体—— <tt>(* x x)</tt> である——を評価する。
また、<tt>sum-of-squares</tt> を適用することの一部として、<tt>(square y)</tt> という部分式も評価せねばならず、ここで <tt>y</tt> は10である。
<tt>square</tt> に対する、この2番目の呼び出しは、<tt>x</tt> ——つまり <tt>square</tt> の仮引数——が10に束縛されているような、もう一つ別の環境——すなわちE4——を作り出す。
そして、E4の中で、<tt>(* x x)</tt> を評価せねばならない。
</p>

<p class="orig" lang="en">
The important point to observe is that each call to <tt>square</tt>
creates a new environment containing a binding for <tt>x</tt>.  We can
see here how the different frames serve to keep separate the different
local variables all named <tt>x</tt>.  Notice that each frame created by
<tt>square</tt> points to the global environment, since this is the
environment indicated by the <tt>square</tt> procedure object.</p>

<p class="trans" lang="ja">
観察すべき重要な点は、<tt>square</tt> に対するそれぞれの呼び出しが、<tt>x</tt> についての束縛を含む新たな環境を作成する、ということである。
どれも皆 <tt>x</tt> と名付けられた異なる局所変数同士を区別したままでいるために、異なるフレームがどのように役立っているのか、ということを、ここで見ることができる。
<tt>square</tt> によって作成される各フレームが、大域環境を指す——なぜなら、この大域環境が、<tt>square</tt> の手続きオブジェクトにより示される環境なので——ということに注意せよ。
</p>

<p class="orig" lang="en">
After the subexpressions are evaluated, the results are
returned.  The values generated by the two calls to <tt>square</tt> are
added by <tt>sum-of-squares</tt>, and this result is returned by <tt>f</tt>.
Since our focus here is on the environment structures, we will not
dwell on how these returned values are passed from call to call;
however, this is also an important aspect of the evaluation process,
and we will return to it in detail in chapter 5.</p>

<p class="trans" lang="ja">
部分式が評価された後、結果が返される。
<tt>square</tt> に対する2回の呼び出しによって生成された値は、<tt>sum-of-squares</tt> によって足され、この結果が <tt>f</tt> により返される。
ここでの私たちの焦点は環境構造にあるので、これらの返された値がどのようにして呼び出しから呼び出しへと受け渡されるのか、ということを長々と述べるのはよそう。
しかし、これも評価過程の重要な側面なのであり、これについて詳しくは5章で立ち戻ることにしよう。
</p>

<p class="orig" lang="en">
<a name="%_thm_3.9"></a>
<b>Exercise 3.9.</b>  <a name="%_idx_3088"></a><a name="%_idx_3090"></a><a name="%_idx_3092"></a>In section <a href="11_sec1_2.html#%_sec_1.2.1">1.2.1</a>
we used the substitution model to analyze two
procedures for computing factorials, a recursive version</p>

<p class="trans" lang="ja">
<b>練習問題3.9.</b> <a href="11_sec1_2.html#%_sec_1.2.1">1.2.1</a>節では、<ruby><rb>代入</rb><rp> (</rp><rt>おきかえ</rt><rp>) </rp></ruby>モデルを使って、階乗を計算するための二つの手続きを分析した——つまり、以下のような再帰バージョンと、
</p>

<p class="lisp">(define (factorial n)
  (if (= n 1)
      1
      (* n (factorial (- n 1)))))
</p>

<p class="orig" lang="en">
and an iterative version</p>

<p class="trans" lang="ja">
以下のような反復バージョンを分析した。
</p>

<p class="lisp">(define (factorial n)
  (fact-iter 1 1 n))
(define (fact-iter product counter max-count)
  (if (&gt; counter max-count)
      product
      (fact-iter (* counter product)
                 (+ counter 1)
                 max-count)))
</p>

<p class="orig" lang="en">
Show the environment structures created by evaluating <tt>(factorial 6)</tt>
using each version of the <tt>factorial</tt> procedure.<a name="call_footnote_Temp_345" href="#footnote_Temp_345"><sup><small>14</small></sup></a></p>

<p class="trans" lang="ja">
<tt>(factorial 6)</tt> を評価することにより作成される環境構造を、<tt>factorial</tt> の手続きのそれぞれのバージョンを使って、示せ<a href="#footnote_Temp_345"><sup><small>14</small></sup></a>。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>


<a name="%_sec_3.2.3"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_3.2.3">3.2.3  Frames as the Repository of Local State</a></h3>
<h3 class="trans" lang="ja">3.2.3 局所状態の置き場としてのフレーム</h3>

<p class="orig" lang="en">
<a name="%_idx_3098"></a><a name="%_idx_3100"></a><a name="%_idx_3102"></a>
<a name="%_idx_3104"></a>We can turn to the environment model to see how procedures and
assignment can be used to represent objects with local state.  As an
example, consider the ``withdrawal processor'' from
section <a href="20_sec3_1.html#%_sec_3.1.1">3.1.1</a> created by calling the
procedure</p>

<p class="trans" lang="ja">
局所状態を有するオブジェクトを表現するために、どのようにして手続きと<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>を使うことができるのか、ということを見るために、環境モデルに目を向けることができる。
例として、以下の手続きを呼び出すことで作成される、<a href="20_sec3_1.html#%_sec_3.1.1">3.1.1</a>節での「引き出し処理器」を考えよう。
</p>

<p class="lisp">(define (make-withdraw balance)
  (lambda (amount)
    (if (&gt;= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        &quot;Insufficient funds&quot;)))
</p>

<p class="orig" lang="en">
Let us describe the evaluation of</p>

<p class="trans" lang="ja">
以下のものの評価について、説明しよう。
</p>

<p class="lisp">(define W1 (make-withdraw 100))
</p>

<p class="orig" lang="en">
followed by</p>

<p class="trans" lang="ja">
ただしこれは、以下のように続くものとする。
</p>

<p class="lisp">(W1 50)
<i>50</i>
</p>

<p class="orig" lang="en">
Figure <a href="#%_fig_3.6">3.6</a> shows the result of defining the <tt>make-withdraw</tt> procedure in the global environment.  This produces a
procedure object that contains a pointer to the global environment.
So far, this is no different from the examples we have already seen,
except that the body of the procedure is itself a <tt>lambda</tt>
expression.</p>

<p class="trans" lang="ja">
図<a href="#%_fig_3.6">3.6</a>は、大域環境で <tt>make-withdraw</tt> の手続きを定義した結果を示す。
この手続きは、大域環境へのポインタを含む手続きオブジェクトである。
ここまでのところでは、これは、既に見てきた例と何の違いもない——手続きの本体が、それ自体、<tt>lambda</tt> 式である、という点を除いて、であるが。
</p>

<a name="%_fig_3.6"></a>
<figure>
<img src="ch3-Z-G-7.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.6:</b>  Result of defining <tt>make-withdraw</tt>
in the global environment.</figcaption>
<figcaption class="trans" lang="ja"><b>図3.6:</b>大域環境で <tt>make-withdraw</tt> を定義した結果</figcaption>
</figure>

<p class="orig" lang="en">
The interesting part of the computation happens when we apply the
procedure <tt>make-withdraw</tt> to an argument:</p>

<p class="trans" lang="ja">
計算の興味深い部分は、<tt>make-withdraw</tt> という手続きを、以下のように実引数に適用するときに起こる。
</p>

<p class="lisp">(define W1 (make-withdraw 100))
</p>

<p class="orig" lang="en">
We begin, as usual, by setting up an environment E1 in which the
formal parameter <tt>balance</tt> is bound to the argument 100.  Within
this environment, we evaluate the body of <tt>make-withdraw</tt>, namely
the <tt>lambda</tt> expression.  This constructs a new procedure object,
whose code is as specified by the <tt>lambda</tt> and whose environment
is E1, the environment in which the <tt>lambda</tt> was evaluated to
produce the procedure.  The resulting procedure object is the value
returned by the call to <tt>make-withdraw</tt>.  This is bound to <tt>W1</tt> in the global environment, since the <tt>define</tt> itself is being
evaluated in the global environment.  Figure <a href="#%_fig_3.7">3.7</a> shows the
resulting environment structure.</p>

<p class="trans" lang="ja">
いつもどおり、<tt>balance</tt> という仮引数が100という実引数に束縛されているような環境E1を設定することから、始める。
この環境の中で、<tt>make-withdraw</tt> の本体——つまり <tt>lambda</tt> 式——を評価する。
これにより新たな手続きオブジェクトが構築されるわけだが、その新たな手続きオブジェクトのコードは、<tt>lambda</tt> により指定されるとおりであり、その新たな手続きオブジェクトの環境はE1——すなわち、その中で <tt>lambda</tt> が評価されて、この手続きを生み出すことになった環境——である。
結果として生じる手続きオブジェクトは、<tt>make-withdraw</tt> に対する呼び出しによって返される値である。
これは、大域環境において <tt>W1</tt> に束縛される——なぜなら、<tt>define</tt> 自体が大域環境の中で評価されているからである。
図<a href="#%_fig_3.7">3.7</a>は、結果として生じる環境構造を示している。
</p>


<a name="%_fig_3.7"></a>
<figure>
<img src="ch3-Z-G-8.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.7:</b>  Result of evaluating <tt>(define W1 (make-withdraw 100))</tt>.</figcaption>
<figcaption class="trans" lang="ja"><b>図3.7:</b><tt>(define W1 (make-withdraw 100))</tt> を評価した結果</figcaption>
</figure>


<p class="orig" lang="en">
Now we can analyze what happens when <tt>W1</tt> is applied to a
argument:</p>

<p class="trans" lang="ja">
これで、<tt>W1</tt> が実引数に適用されるときに起きることを分析できる。
</p>

<p class="lisp">(W1 50)
<i>50</i>
</p>


<p class="orig" lang="en">
We begin by constructing a frame in which <tt>amount</tt>, the formal
parameter of <tt>W1</tt>, is bound to the argument 50.  The crucial point
to observe is that this frame has as its enclosing environment not the
global environment, but rather the environment E1, because this is the
environment that is specified by the <tt>W1</tt> procedure object.
Within this new environment, we evaluate the body of the procedure:</p>

<p class="trans" lang="ja">
<tt>amount</tt> ——つまり <tt>W1</tt> の仮引数——が、50という実引数に束縛されているフレームを構築することから始める。
観察すべき、決定的に重要な点は、このフレームが、大域環境ではなくむしろ環境E1を、自身の外側を囲っている環境として有している——なぜなら、この環境E1が、<tt>W1</tt> の手続きオブジェクトにより指定されている環境だから——という点だ。
この新たな環境の中で、以下のような手続き本体を評価する。
</p>

<p class="lisp">(if (&gt;= balance amount)
    (begin (set! balance (- balance amount))
           balance)
    &quot;Insufficient funds&quot;)
</p>

<p class="orig" lang="en">
The resulting environment structure is shown in
figure <a href="#%_fig_3.8">3.8</a>.  The expression being evaluated references
both <tt>amount</tt> and <tt>balance</tt>.  <tt>Amount</tt> will be found in
the first frame in the environment, while <tt>balance</tt> will be found
by following the enclosing-environment pointer to E1.</p>

<p class="trans" lang="ja">
結果として生じる環境構造を図<a href="#%_fig_3.8">3.8</a>に示す。
いま評価されている式は、<tt>amount</tt> と <tt>balance</tt> の双方を参照する。
<tt>amount</tt> は、環境内の最初のフレームで見つかるだろうが、<tt>balance</tt> は、外側を囲っている環境に関する、E1を指しているポインタをたどることによって、見つかるだろう。
</p>


<a name="%_fig_3.8"></a>
<figure>
<img src="ch3-Z-G-9.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.8:</b>  Environments created by applying the procedure
object <tt>W1</tt>.</figcaption>
<figcaption class="trans" lang="ja"><b>図3.8:</b> <tt>W1</tt> という手続きオブジェクトを適用することで作成された環境</figcaption>
</figure>

<p class="orig" lang="en">
When the <tt>set!</tt> is executed, the binding of <tt>balance</tt> in E1 is changed.  At the completion of the call to <tt>W1</tt>,
<tt>balance</tt> is 50, and the frame that contains <tt>balance</tt>
is still pointed to by the procedure object <tt>W1</tt>.  The frame
that binds <tt>amount</tt>
(in which we executed the code that changed <tt>balance</tt>) is no longer
relevant, since the procedure call that constructed it has terminated,
and there are no pointers to that frame from other parts of the
environment.  The next time <tt>W1</tt> is called, this will build a new
frame that binds <tt>amount</tt> and whose enclosing environment is E1.
We see that E1 serves as the ``place'' that holds the local state
variable for the procedure object <tt>W1</tt>.  Figure <a href="#%_fig_3.9">3.9</a>
shows the situation after the call to <tt>W1</tt>.</p>

<p class="trans" lang="ja">
<tt>set!</tt> が実行されるとき、E1における <tt>balance</tt> の束縛が変更される。
<tt>W1</tt> に対する呼び出しの完了時において、<tt>balance</tt> は50であり、<tt>balance</tt> を含むフレームは、<tt>W1</tt> という手続きオブジェクトにより、依然として指されたままである。
<tt>amount</tt> を束縛するフレーム (そこにおいて、私たちは、<tt>balance</tt> を変更したコードを実行したのであった) は、もはや無関係である——というのも、そのフレームを構築した手続き呼び出しはもう終了したからであり、環境内の他の部分からそのフレームへのポインタは存在しないからである。
<tt>W1</tt> が次に呼ばれるとき、この呼び出しは、<tt>amount</tt>を束縛し、かつ、外側を囲っている環境がE1であるような、新たなフレームを築くだろう。
<tt>W1</tt> という手続きオブジェクトの局所状態を保持する「場所」として、E1が機能している、ということが分かる。
図<a href="#%_fig_3.9">3.9</a>は、<tt>W1</tt> に対する呼び出しの後の状況を示す。
</p>


<a name="%_fig_3.9"></a>
<figure>
<img src="ch3-Z-G-10.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.9:</b>  Environments after the call to <tt>W1</tt>.</figcaption>
<figcaption class="trans" lang="ja"><b>図3.9:</b> <tt>W1</tt> に対する呼び出しの後の環境</figcaption>
</figure>

<p class="orig" lang="en">
Observe what happens when we create a second ``withdraw'' object by
making another call to <tt>make-withdraw</tt>:
</p>

<p class="trans" lang="ja">
<tt>make-withdraw</tt> に対する別の呼び出しを行うことによって、第二の「引き出し」オブジェクトを作成するときに、何が起こるのか、観察せよ。
</p>

<p class="lisp">(define W2 (make-withdraw 100))
</p>

<p class="orig" lang="en">
This produces the environment structure of figure <a href="#%_fig_3.10">3.10</a>, which shows
that <tt>W2</tt> is a procedure object, that is, a pair with some code
and an environment.  The environment E2 for <tt>W2</tt> was created by
the call to <tt>make-withdraw</tt>.  It contains a frame with its own
local binding for <tt>balance</tt>.  On the other hand, <tt>W1</tt> and <tt>W2</tt> have the same code: the code specified by the <tt>lambda</tt>
expression in the body of <tt>make-withdraw</tt>.<a name="call_footnote_Temp_346" href="#footnote_Temp_346"><sup><small>15</small></sup></a> We see here why <tt>W1</tt> and <tt>W2</tt>
behave as independent objects.  Calls to <tt>W1</tt> reference the state
variable <tt>balance</tt> stored in E1, whereas calls to <tt>W2</tt>
reference the <tt>balance</tt> stored in E2. Thus, changes to the local
state of one object do not affect the other object.</p>

<p class="trans" lang="ja">
これは、図<a href="#%_fig_3.10">3.10</a>の環境構造を作り出し、その環境構造は、<tt>W2</tt> が手続きオブジェクト——すなわち、何らかのコードと、環境との対——であることを示す。
<tt>W2</tt> 用の環境E2は、<tt>make-withdraw</tt> に対する呼び出しにより作成された。
これは、<tt>balance</tt> に対する自分自身の局所的束縛を持ったフレームを含む。
他方、<tt>W1</tt> と <tt>W2</tt> は同じコードを有する——つまり、<tt>make-withdraw</tt> の本体の中の <tt>lambda</tt> 式により規定されるコードである<a href="#footnote_Temp_346"><sup><small>15</small></sup></a>。
<tt>W1</tt> と <tt>W2</tt> が、なぜ独立したオブジェクトとして振る舞うのか、ということが、ここで分かる。
<tt>W1</tt> に対する呼び出しは、E1に格納された <tt>balance</tt> という状態変数を参照するが、<tt>W2</tt> に対する呼び出しは、E2に格納された <tt>balance</tt> を参照するのだ。
よって、一方のオブジェクトの局所状態に対する変更は、他方のオブジェクトには影響しない。
</p>


<a name="%_fig_3.10"></a>
<figure>
<img src="ch3-Z-G-11.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.10:</b>  Using <tt>(define W2 (make-withdraw 100))</tt>
to create a second object.</figcaption>
<figcaption class="trans" lang="ja"><b>図3.10:</b> 第二のオブジェクトを作成するために <tt>(define W2 (make-withdraw 100))</tt> を使う</figcaption>
</figure>

<p class="orig" lang="en"><a name="%_thm_3.10"></a>
<b>Exercise 3.10.</b>  In the <tt>make-withdraw</tt> procedure, the local variable <tt>balance</tt>
is created as a parameter of <tt>make-withdraw</tt>.  We could also
create the local state variable explicitly, using <tt>let</tt>, as
follows:
</p>

<p class="trans" lang="ja">
<b>練習問題3.10.</b> <tt>make-withdraw</tt> の手続きの中で、<tt>balance</tt> という局所変数は、<tt>make-withdraw</tt> の仮引数として作成される。
以下のように <tt>let</tt> を用いて、局所状態変数を明示的に作成することもできただろう。
</p>

<p class="lisp"><a name="%_idx_3106"></a>(define (make-withdraw initial-amount)
  (let ((balance initial-amount))
    (lambda (amount)
      (if (&gt;= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          &quot;Insufficient funds&quot;))))
</p>

<p class="orig" lang="en">
<a name="%_idx_3108"></a><a name="%_idx_3110"></a>Recall from section <a href="12_sec1_3.html#%_sec_1.3.2">1.3.2</a> that <tt>let</tt> is simply
syntactic sugar for a procedure call:</p>

<p class="trans" lang="ja">
<tt>let</tt> は以下のように、手続き呼び出しに対する糖衣構文に過ぎないのだ、ということを、<a href="12_sec1_3.html#%_sec_1.3.2">1.3.2</a>節から思い出そう。
すなわち、
</p>

<p class="lisp">(let ((&lt;<em>var</em>&gt; &lt;<em>exp</em>&gt;)) &lt;<em>body</em>&gt;)
</p>

<p class="orig" lang="en">
is interpreted as an alternate syntax for</p>

<p class="trans" lang="ja">
は、以下のものに対する代替的構文として解釈される。
</p>

<p class="lisp">((lambda (&lt;<em>var</em>&gt;) &lt;<em>body</em>&gt;) &lt;<em>exp</em>&gt;)
</p>

<p class="orig" lang="en">
Use the environment model to analyze this alternate
version of <tt>make-withdraw</tt>, drawing figures like the ones above to
illustrate the interactions</p>

<p class="trans" lang="ja">
環境モデルを使って、<tt>make-withdraw</tt> についてのこの代替バージョンを分析せよ——その際、相互作用を示すために、上記のような図を描くこと。
</p>

<p class="lisp">(define W1 (make-withdraw 100))

(W1 50)

(define W2 (make-withdraw 100))
</p>

<p class="orig" lang="en">
Show that the two versions of <tt>make-withdraw</tt> create objects with
the same behavior.  How do the environment structures differ for the two
versions?</p>

<p class="trans" lang="ja">
<tt>make-withdraw</tt> の二つのバージョンが、同じ振る舞いのオブジェクトを作成する、ということを示せ。
二つのバージョンに対して、環境構造はどのように異なっているだろうか?
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_3.2.4"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_3.2.4">3.2.4  Internal Definitions</a></h3>
<h3 class="trans" lang="ja">3.2.4 内部定義</h3>

<p class="orig" lang="en">
<a name="%_idx_3112"></a><a name="%_idx_3114"></a><a name="%_idx_3116"></a>
Section <a href="10_sec1_1.html#%_sec_1.1.8">1.1.8</a> introduced the idea that procedures can have internal
definitions, thus leading to a block structure as in the
following procedure to compute square roots:</p>

<p class="trans" lang="ja">
<a href="10_sec1_1.html#%_sec_1.1.8">1.1.8</a> 節では、手続きが内部定義を持てる、という考えを導入したので、二乗根を計算するための以下の手続きに見られるようなブロック構造につながった。
</p>

<p class="lisp"><a name="%_idx_3118"></a>(define (sqrt x)
  (define (good-enough? guess)
    (&lt; (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))
</p>


<p class="orig" lang="en">
Now we can use the environment model to see why these internal
definitions behave as desired.  Figure <a href="#%_fig_3.11">3.11</a> shows the point in the
evaluation of the expression <tt>(sqrt 2)</tt> where the internal
procedure <tt>good-enough?</tt> has been called for the first time with
<tt>guess</tt> equal to 1.</p>

<p class="trans" lang="ja">
さてここで、私たちは、なぜこれらの内部定義が望みどおりに振る舞うのか、ということを見るために、環境モデルを使うことができる。
図<a href="#%_fig_3.11">3.11</a>は、<tt>(sqrt 2)</tt> という式の評価において、<tt>good-enough?</tt> という内部手続きが、<tt>guess</tt> が1に等しい状態で、一度目に呼び出された時点を示す。</p>


<a name="%_fig_3.11"></a>
<figure>
<img src="ch3-Z-G-12.gif" border="0">
<figcaption class="orig" lang="en"> <b>Figure 3.11:</b>  <tt>Sqrt</tt> procedure with internal definitions.</figcaption>
<figcaption class="trans" lang="ja"><b>図3.11:</b> 内部定義のある <tt>sqrt</tt> の手続き</figcaption>
</figure>


<p class="orig" lang="en">
Observe the structure of the environment.  <tt>Sqrt</tt> is a symbol in
the global environment that is bound to a procedure object whose
associated environment is the global environment.  When <tt>sqrt</tt> was
called, a new environment E1 was formed, subordinate to the global
environment, in which the parameter <tt>x</tt> is bound to 2.  The body
of <tt>sqrt</tt> was then evaluated in E1.  Since the first expression in
the body of <tt>sqrt</tt> is</p>

<p class="trans" lang="ja">
環境の構造を観察せよ。
<tt>sqrt</tt> は、自分に対応づけられた環境が大域環境であるような手続きオブジェクトに束縛されている、大域環境内の記号である。
<tt>sqrt</tt> が呼ばれたとき、E1という新たな環境——大域環境の下位にあり、そこでは <tt>x</tt> という仮引数が2に束縛されている——が形成された。
<tt>sqrt</tt> の本体は、そこで、E1において評価された。
<tt>sqrt</tt> の本体における最初の式は、
</p>


<p class="lisp">(define (good-enough? guess)
  (&lt; (abs (- (square guess) x)) 0.001))
</p>

<p class="orig" lang="en">
evaluating this expression defined the procedure <tt>good-enough?</tt>
in the environment E1.  To be more precise, the symbol <tt>good-enough?</tt> was added to the first frame of E1, bound to a
procedure object whose associated environment is E1.  Similarly, <tt>improve</tt> and <tt>sqrt-iter</tt> were defined as procedures in E1.  For
conciseness, figure <a href="#%_fig_3.11">3.11</a> shows only the procedure
object for <tt>good-enough?</tt>.</p>

<p class="trans" lang="ja">
であるため、この式を評価することで、E1という環境内における <tt>good-enough?</tt> という手続きが定義された。
より正確には、<tt>good-enough?</tt> という記号が、E1の最初のフレームに追加され、自分に対応づけられた環境がE1であるような手続きオブジェクトに、束縛された。
同様に、<tt>improve</tt> と <tt>sqrt-iter</tt> が、E1の中の手続きとして定義された。
簡潔さのために、図<a href="#%_fig_3.11">3.11</a>では、<tt>good-enough?</tt> についての手続きオブジェクトのみを示している。
</p>

<p class="orig" lang="en">
After the local procedures were defined, the
expression <tt>(sqrt-iter 1.0)</tt> was evaluated,
still in environment E1.  So the
procedure object bound to <tt>sqrt-iter</tt> in E1 was called with 1 as
an argument.  This created an environment E2 in which <tt>guess</tt>,
the parameter of <tt>sqrt-iter</tt>, is bound to 1.  <tt>Sqrt-iter</tt> in
turn called <tt>good-enough?</tt> with the value of <tt>guess</tt> (from
E2) as the argument for <tt>good-enough?</tt>.  This set up another
environment, E3, in which <tt>guess</tt> (the parameter of <tt>good-enough?</tt>) is bound to 1.  Although <tt>sqrt-iter</tt> and <tt>good-enough?</tt> both have a parameter named <tt>guess</tt>, these are two
distinct local variables located in different frames.  Also, E2 and E3
both have E1 as their enclosing environment, because the <tt>sqrt-iter</tt> and <tt>good-enough?</tt> procedures both have E1 as their
environment part.  One consequence of this is that the symbol <tt>x</tt>
that appears in the body of <tt>good-enough?</tt> will reference the
binding of <tt>x</tt> that appears in E1, namely the value of <tt>x</tt>
with which the original <tt>sqrt</tt> procedure was called.</p>

<p class="trans" lang="ja">
局所的手続きが定義された後、依然としてE1という環境の中で、<tt>(sqrt-iter 1.0)</tt> という式が評価された。
そういうわけで、E1において <tt>sqrt-iter</tt> に束縛されている手続きオブジェクトが、実引数としての1とともに、呼ばれたのだ。
これは、***
</p>

<p class="orig" lang="en">
The environment model thus explains the two key properties that make
local procedure definitions a useful technique for modularizing
programs:</p>

<p class="trans" lang="ja">
このようにして環境モデルが説明するのは、局所的手続き定義を、プログラムをモジュール化するための有用な技法にする、二つの重要な性質である。
</p>

<ul class="orig" lang="en">
<li>The names of the local procedures do not interfere with
names external to the enclosing procedure, because the local procedure
names will be bound in the frame that the procedure creates when it is
run, rather than being bound in the global environment.</li>

<li>The local procedures can access the arguments of the enclosing
procedure, simply by using parameter names as free variables.
This is because the body of the local procedure is evaluated in an
environment that is subordinate to the evaluation environment for the
enclosing procedure.</li>
</ul>

<ul class="trans" lang="ja">
<li>局所手続きの名前は、外側を囲っている手続きより外側の名前に干渉することはない——なぜなら、局所手続きの名前は、大域環境で束縛されるというよりもむしろ、手続きが実行されるときに手続きが作成するフレームの中で束縛されるだろうから。</li>
<li>局所手続きは、外側を囲っている手続きの実引数にアクセスできる——単に仮引数名を自由変数として使うことによって。その理由は、局所手続きの本体は、外側を囲っている手続き用の評価の環境に従属している環境の中で評価されるからである。</li>
</ul>

<p class="orig" lang="en"><a name="%_thm_3.11"></a>
<b>Exercise 3.11.</b>  <a name="%_idx_3120"></a><a name="%_idx_3122"></a><a name="%_idx_3124"></a>In section <a href="#%_sec_3.2.3">3.2.3</a>
we saw how the environment model described the
behavior of procedures with local state.  Now we have seen how
internal definitions work.  A typical message-passing procedure
contains both of these aspects.  Consider the bank account procedure
of section <a href="20_sec3_1.html#%_sec_3.1.1">3.1.1</a>:</p>

<p class="trans" lang="ja">
<b>練習問題3.11.</b> <a href="#%_sec_3.2.3">3.2.3</a>節では、局所状態のある手続きの振る舞いを環境モデルがどのように説明するのか、を見た。
今や私たちは、どのように内部定義が動くのか、を見てきた。
メッセージを渡す典型的な手続きは、これら双方の側面を含んでいる。
<a href="20_sec3_1.html#%_sec_3.1.1">3.1.1</a>節の銀行口座手続きについて考えよう。
</p>

<p class="lisp"><a name="%_idx_3126"></a>(define (make-account balance)
  (define (withdraw amount)
    (if (&gt;= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        &quot;Insufficient funds&quot;))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch m)
    (cond ((eq? m 'withdraw) withdraw)
          ((eq? m 'deposit) deposit)
          (else (error &quot;Unknown request -- MAKE-ACCOUNT&quot;
                       m))))
  dispatch)
</p>

<p class="orig" lang="en">
Show the environment structure generated by the sequence of
interactions</p>

<p class="trans" lang="ja">
以下の一連のやりとりにより生成される環境構造を示せ。
</p>

<p class="lisp">(define acc (make-account 50))

((acc 'deposit) 40)
<i>90</i>

((acc 'withdraw) 60)
<i>30</i>
</p>


<p class="orig" lang="en">
Where is the local state for <tt>acc</tt> kept?  Suppose we define
another account</p>

<p class="trans" lang="ja">
<tt>acc</tt> 用の局所状態はどこに保たれているだろうか?
以下のように、もう一つの口座を定義するものとしよう。
</p>


<p class="lisp">(define acc2 (make-account 100))
</p>

<p class="orig" lang="en">
How are the local states for the two accounts kept distinct?  Which
parts of the environment structure are shared between <tt>acc</tt> and
<tt>acc2</tt>?</p>

<p class="trans" lang="ja">
二つの口座用の局所状態は、どのようにして別々に保たれるのだろうか?
環境構造のうちどの部分が、<tt>acc</tt> と <tt>acc2</tt> の間で共有されているか?
</p>

<p class="exercise"><span class="ex_comment">
</span></p>


<hr>


<p class="orig" lang="en">
<a name="footnote_Temp_342" href="#call_footnote_Temp_342"><sup><small>12</small></sup></a> Assignment introduces a subtlety into step 1 of
the evaluation rule.  As shown in
exercise <a href="20_sec3_1.html#%_thm_3.8">3.8</a>, the presence of assignment
allows us to write expressions that will produce different values
depending on the order in which the subexpressions in a combination
<a name="%_idx_3066"></a><a name="%_idx_3068"></a>are evaluated.  Thus, to be precise, we should specify an evaluation
order in step 1 (e.g., left to right or right to left).  However, this
order should always be considered to be an implementation detail, and
one should never write programs that depend on some particular order.
For instance, a sophisticated compiler might optimize a program by
varying the order in which subexpressions are evaluated.</p>

<p class="trans" lang="ja">
<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>は、評価規則のステップ1に、微妙な点を持ち込む。
練習問題<a href="20_sec3_1.html#%_thm_3.8">3.8</a>に示されるように、<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>の存在によって私たちは、コンビネーション内の部分式が評価される順序に依存して異なる値を作り出すであろうような式を、書くことができるようになる。
よって、正確に言えば、ステップ1での評価順を指定すべきなのだ (例えば、左から右へ、あるいは、右から左へ、など)。
しかし、この順序は、常に実装の細部として考えられるべきであり、何らかの特定の順序に依存しているプログラムは書くべきではない。
たとえば、精巧なコンパイラは、部分式が評価される順序を変化させることで、プログラムを最適化するかもしれない。
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_343" href="#call_footnote_Temp_343"><sup><small>13</small></sup></a> If there is already a binding for the
variable in the current frame, then the binding is changed.  This is
convenient because it allows redefinition of symbols; however, it also
means that <tt>define</tt> can be used to change values, and this brings
up the issues of assignment without explicitly using <a name="%_idx_3080"></a><tt>set!</tt>.
Because of this, some people prefer redefinitions of existing symbols
to signal errors or warnings.</p>

<p class="trans" lang="ja">
もし現在のフレームの中に、既にその変数についての何らかの束縛があれば、その束縛は変更される。
これは、記号の再定義を可能とするので、便利である。が、これは、値を変更するために <tt>define</tt> を使える、ということをも意味し、明示的に <tt>set!</tt> を使わない<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>の問題を提起するのだ。
これが原因で、既存の記号の再定義にはエラーまたは警告の合図を出してほしい、と考える人たちもいる。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_345" href="#call_footnote_Temp_345"><sup><small>14</small></sup></a> The
environment model will not clarify our claim in
section <a href="11_sec1_2.html#%_sec_1.2.1">1.2.1</a> that the interpreter can
execute a procedure such as <tt>fact-iter</tt> in a constant amount of
space using tail recursion.  We will discuss tail recursion when we
<a name="%_idx_3094"></a><a name="%_idx_3096"></a>deal with the control structure of the interpreter in
section <a href="34_sec5_4.html#%_sec_5.4">5.4</a>.</p>

<p class="trans" lang="ja">
インタプリタは、末尾再帰を用いて、<tt>fact-iter</tt> のような手続きを定数量の空間で実行できる、という<a href="11_sec1_2.html#%_sec_1.2.1">1.2.1</a>節での主張を、環境モデルは明らかにしないだろう。
<a href="34_sec5_4.html#%_sec_5.4">5.4</a>節でインタプリタの制御構造を取り扱うときに、末尾再帰について議論しよう。
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_346" href="#call_footnote_Temp_346"><sup><small>15</small></sup></a> Whether
<tt>W1</tt> and <tt>W2</tt> share the same physical code stored in the
computer, or whether they each keep a copy of the code, is a detail of
the implementation.  For the interpreter we implement in chapter 4,
the code is in fact shared.</p>

<p class="trans" lang="ja">
<tt>W1</tt> と <tt>W2</tt> が、コンピュータ内に格納された同じ物理的コードを共有するのか、それとも、そのコードの写しをそれぞれ保持するのか、ということは、実装の細目である。
私たちが4章で実装するインタプリタにとっては、コードは、実際、共有される。
</p>


</div>
</body>
</html>
