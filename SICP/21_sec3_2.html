<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="sicp.css" type="text/css">
<base target="_top">
<title>SICPç§è¨³: 3.2 è©•ä¾¡ã«ã¤ã„ã¦ã®ç’°å¢ƒãƒ¢ãƒ‡ãƒ«</title>
<link rel="canonical" href="https://piyo-ko.github.io/SICP/21_sec3_2.html" />
</head>
<body>

<div class="idx-bar">
<nav>
<a href="https://twitter.com/share" class="twitter-share-button" data-lang="ja">ãƒ„ã‚¤ãƒ¼ãƒˆ</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
<span class="status">æ¨æ•²å¾…ã¡</span>
[
<a href="00_cover.html">å…ˆé ­ã¸</a> |
<a href="20_sec3_1.html">å‰ã¸</a> |
<a href="22_sec3_3.html">æ¬¡ã¸</a> |
<a href="04_toc.html#%_toc_start">ç›®æ¬¡</a> |
<a href="38_index.html#%_index_start">ç´¢å¼•</a>
] [<a href="99_about.html">ã“ã®å¯¾è¨³ç‰ˆã«ã¤ã„ã¦</a> | <a href="../index.html">ãƒ›ãƒ¼ãƒ </a>]
[
Â§<a href="#%_sec_3.2">3.2</a>
ğŸ¨<a href="#%_fig_3.1">3.1</a>
Â§<a href="#%_sec_3.2.1">3.2.1</a>
ğŸ¨<a href="#%_fig_3.2">3.2</a>
ğŸ¨<a href="#%_fig_3.3">3.3</a>
Â§<a href="#%_sec_3.2.2">3.2.2</a>
ğŸ¨<a href="#%_fig_3.4">3.4</a>
ğŸ¨<a href="#%_fig_3.5">3.5</a>
ğŸ“<a href="#%_thm_3.9">3.9</a>
Â§<a href="#%_sec_3.2.3">3.2.3</a>
ğŸ¨<a href="#%_fig_3.6">3.6</a>
ğŸ¨<a href="#%_fig_3.7">3.7</a>
ğŸ¨<a href="#%_fig_3.8">3.8</a>
ğŸ¨<a href="#%_fig_3.9">3.9</a>
ğŸ¨<a href="#%_fig_3.10">3.10</a>
ğŸ“<a href="#%_thm_3.10">3.10</a>
Â§<a href="#%_sec_3.2.4">3.2.4</a>
ğŸ¨<a href="#%_fig_3.11">3.11</a>
ğŸ“<a href="#%_thm_3.11">3.11</a>
<a href="#footnotes">è„šæ³¨</a>
]</nav>
</div>

<div class="main-txt">


<a name="%_sec_3.2"></a>
<h2 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_3.2">3.2  The Environment Model of Evaluation</a></h2>
<h2 class="trans" lang="ja">3.2 è©•ä¾¡ã«ã¤ã„ã¦ã®ç’°å¢ƒãƒ¢ãƒ‡ãƒ«</h2>

<p class="orig" lang="en">
<a name="%_idx_3034"></a>
When we introduced compound procedures in chapter 1, we used the
<a name="%_idx_3036"></a>substitution model of evaluation
(section <a href="10_sec1_1.html#%_sec_1.1.5">1.1.5</a>) to define what is meant by
applying a procedure to arguments:
</p>

<p class="trans" lang="ja">
1ç« ã§è¤‡åˆçš„æ‰‹ç¶šãã‚’å°å…¥ã—ãŸã¨ãã€ç§ãŸã¡ã¯ã€å¼•æ•°ã«æ‰‹ç¶šãã‚’é©ç”¨ã™ã‚‹ã“ã¨ãŒæ„å‘³ã™ã‚‹ã“ã¨ã¨ã¯ä½•ã‹ã€ã‚’å®šç¾©ã™ã‚‹ãŸã‚ã«ã€è©•ä¾¡ã«ã¤ã„ã¦ã®<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ãŠãã‹ãˆ</rt><rp>) </rp></ruby>ãƒ¢ãƒ‡ãƒ«ã‚’ä½¿ã£ãŸ (<a href="10_sec1_1.html#%_sec_1.1.5">1.1.5</a>ç¯€)ã€‚
</p>

<ul class="orig" lang="en">
<li>To apply a compound procedure to arguments, evaluate the body of the
procedure with each formal parameter replaced by the corresponding
argument.</li>
</ul>

<ul class="trans" lang="ja">
<li>å¼•æ•°ã«è¤‡åˆçš„æ‰‹ç¶šãã‚’é©ç”¨ã™ã‚‹ã«ã¯ã€å„ä»®å¼•æ•°ã‚’ãã‚Œã«å¯¾å¿œã™ã‚‹å®Ÿå¼•æ•°ã§ç½®ãæ›ãˆãŸçŠ¶æ…‹ã®ã€æ‰‹ç¶šãã®æœ¬ä½“ã‚’ã€è©•ä¾¡ã›ã‚ˆã€‚</li>
</ul>

<p class="orig" lang="en">
Once we admit assignment into our programming language, such a
definition is no longer adequate.  In particular,
section <a href="20_sec3_1.html#%_sec_3.1.3">3.1.3</a> argued that, in the presence of
assignment, a variable can no longer be considered to be merely a name
for a value.  Rather, a variable must somehow designate a ``place'' in
which values can be stored.  In our new model of evaluation, these
places will be maintained in structures called <a name="%_idx_3038"></a><em>environments</em>.
</p>

<p class="trans" lang="ja">
ä¸€æ—¦ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã«<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã‚’å—ã‘å…¥ã‚Œã‚‹ã“ã¨ã‚’èªã‚ã‚‹ã‚„ã€ã“ã®ã‚ˆã†ãªå®šç¾©ã¯ã€ã‚‚ã¯ã‚„é©åˆ‡ã§ã¯ãªããªã£ã¦ã—ã¾ã†ã€‚
ç‰¹ã«ã€<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ãŒã‚ã‚‹ã¨ã€å¤‰æ•°ã¯ã‚‚ã¯ã‚„å€¤ã®ãŸã‚ã®å˜ãªã‚‹åå‰ã ã¨ã¯è€ƒãˆã‚‰ã‚Œãªããªã‚‹ã€ã¨ã„ã†ã“ã¨ã‚’ã€<a href="20_sec3_1.html#%_sec_3.1.3">3.1.3</a>ç¯€ã§ä¸»å¼µã—ãŸã€‚
ã‚€ã—ã‚ã€å¤‰æ•°ã¯ã€å€¤ã‚’æ ¼ç´ã§ãã‚‹ã€Œå ´æ‰€ã€ã‚’ä½•ã‚‰ã‹ã®æ–¹æ³•ã§æŒ‡å®šã—ã¦ã„ã‚‹ã«é•ã„ãªã„ã€‚
è©•ä¾¡ã«ã¤ã„ã¦ã®ç§ãŸã¡ã®æ–°ãŸãªãƒ¢ãƒ‡ãƒ«ã§ã¯ã€ã“ã‚Œã‚‰ã®å ´æ‰€ã¯ã€<em>ç’°å¢ƒ</em>ã¨å‘¼ã°ã‚Œã‚‹æ§‹é€ ã®ä¸­ã«ç¶­æŒã•ã‚Œã‚‹ã ã‚ã†ã€‚
</p>

<p class="orig" lang="en">
An environment is a sequence of <a name="%_idx_3040"></a><em>frames</em>.  Each frame is a table
(possibly empty) of <a name="%_idx_3042"></a><em>bindings</em>, which associate variable names with
their corresponding values.  (A single frame may contain at most one
binding for any variable.)  Each frame also has a pointer to its <a name="%_idx_3044"></a><a name="%_idx_3046"></a><em>enclosing environment</em>, unless, for the purposes of discussion, the
frame is considered to be <a name="%_idx_3048"></a><a name="%_idx_3050"></a><em>global</em>.  The <a name="%_idx_3052"></a><em>value of a variable</em>
with respect to an environment is the value given by the binding of
the variable in the first frame in the environment that contains a
binding for that variable.  If no frame in the sequence specifies a
binding for the variable, then the variable is said to be <a name="%_idx_3054"></a><a name="%_idx_3056"></a><em>unbound</em> in the environment.
</p>

<p class="trans" lang="ja">
ç’°å¢ƒã¨ã¯ã€<em>ãƒ•ãƒ¬ãƒ¼ãƒ </em>ã®é€£ãªã‚Šã§ã‚ã‚‹ã€‚
å„ãƒ•ãƒ¬ãƒ¼ãƒ ã¯ã€<em>æŸç¸›</em>ã®è¡¨ (ç©ºã®ã“ã¨ã‚‚ã‚ã‚‹) ã§ã‚ã‚Šã€ã“ã®è¡¨ã¯ã€å¤‰æ•°åã‚’ãã‚Œã«å¯¾å¿œã™ã‚‹å€¤ã«é–¢é€£ã¥ã‘ã‚‹ã€‚
(ä¸€ã¤ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã¯ã€ã©ã®å¤‰æ•°ã«å¯¾ã—ã¦ã‚‚ã€æœ€å¤§ã§ä¸€ã¤ã®æŸç¸›ã ã‘ã‚’å«ã‚€ã“ã¨ãŒã§ãã‚‹ã€‚)
å„ãƒ•ãƒ¬ãƒ¼ãƒ ã«ã¯ã€è‡ªåˆ†ã®<em>å¤–å´ã‚’å›²ã£ã¦ã„ã‚‹ç’°å¢ƒ</em>ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã‚‚ã‚ã‚‹â€”â€”è­°è«–ã®ãŸã‚ã«ã€ãã®ãƒ•ãƒ¬ãƒ¼ãƒ ãŒ<em>å¤§åŸŸçš„</em>ã ã¨è¦‹ãªã•ã‚Œãªã„é™ã‚Šã¯ã€‚
ã‚ã‚‹ç’°å¢ƒã«é–¢ã—ã¦ã®<em>å¤‰æ•°ã®å€¤</em>ã¯ã€ãã®å¤‰æ•°ã«å¯¾ã™ã‚‹æŸç¸›ã‚’å«ã‚€ã‚ˆã†ãªã€ãã®ç’°å¢ƒå†…ã§æœ€åˆã®ãƒ•ãƒ¬ãƒ¼ãƒ ã«ãŠã‘ã‚‹ã€ãã®å¤‰æ•°ã®æŸç¸›ã«ã‚ˆã£ã¦ã€ä¸ãˆã‚‰ã‚Œã‚‹å€¤ã§ã‚ã‚‹ã€‚
ã‚‚ã—ã€é€£ãªã‚Šã®ä¸­ã®ã©ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚‚ã€ãã®å¤‰æ•°ã«å¯¾ã™ã‚‹æŸç¸›ã‚’æŒ‡å®šã—ã¦ã„ãªã‘ã‚Œã°ã€ãã®å¤‰æ•°ã¯ã€ãã®ç’°å¢ƒå†…ã§ã¯<em>æŸç¸›ã•ã‚Œã¦ã„ãªã„</em>ã¨è¨€ã‚ã‚Œã‚‹ã€‚
</p>

<a name="%_fig_3.1"></a>
<figure>
<img src="ch3-Z-G-2.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.1:</b>  A simple environment structure.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³3.1:</b> ç°¡å˜ãªç’°å¢ƒã®æ§‹é€ </figcaption>
</figure>
<a name="%_idx_3058"></a>

<p class="orig" lang="en">
Figure <a href="#%_fig_3.1">3.1</a> shows a simple environment
structure consisting of three frames, labeled I, II, and III.  In the
diagram, A, B, C, and D are pointers to environments.  C and D point
to the same environment.  The variables <tt>z</tt> and <tt>x</tt> are bound
in frame II, while <tt>y</tt> and <tt>x</tt> are bound in frame I.  The
value of <tt>x</tt> in environment D is 3.  The value of <tt>x</tt> with
respect to environment B is also 3.  This is determined as follows: We
examine the first frame in the sequence (frame III) and do not find a
binding for <tt>x</tt>, so we proceed to the enclosing environment D and
find the binding in frame I.  On the other hand, the value of <tt>x</tt>
in environment A is 7, because the first frame in the sequence (frame
II) contains a binding of <tt>x</tt> to 7.  With respect to environment
A, the binding of <tt>x</tt> to 7 in frame II is said to <a name="%_idx_3060"></a><em>shadow</em> the
binding of <tt>x</tt> to 3 in frame I.
</p>

<p class="trans" lang="ja">
å›³<a href="#%_fig_3.1">3.1</a>ã¯ã€Iã€IIã€IIIã¨ãƒ©ãƒ™ãƒ«ã¥ã‘ã•ã‚ŒãŸä¸‰ã¤ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰ãªã‚‹ã€ç°¡å˜ãªç’°å¢ƒã®æ§‹é€ ã‚’ç¤ºã—ã¦ã„ã‚‹ã€‚
ã“ã®å›³ã«ãŠã„ã¦ã€Aã€Bã€Cã€Dã¯ã€ç’°å¢ƒã¸ã®ãƒã‚¤ãƒ³ã‚¿ã§ã‚ã‚‹ã€‚
Cã¨Dã¯ã€åŒã˜ç’°å¢ƒã‚’æŒ‡ã—ã¦ã„ã‚‹ã€‚
<tt>z</tt> ã¨ <tt>x</tt> ã¨ã„ã†å¤‰æ•°ãŒãƒ•ãƒ¬ãƒ¼ãƒ IIã§æŸç¸›ã•ã‚Œã¦ãŠã‚Šã€ãã®ä¸€æ–¹ã§ã€<tt>y</tt> ã¨ <tt>x</tt> ãŒãƒ•ãƒ¬ãƒ¼ãƒ Iã§æŸç¸›ã•ã‚Œã¦ã„ã‚‹ã€‚
ç’°å¢ƒDã«ãŠã‘ã‚‹ <tt>x</tt> ã®å€¤ã¯3ã§ã‚ã‚‹ã€‚
ç’°å¢ƒBã«ã¤ã„ã¦ã® <tt>x</tt> ã®å€¤ã‚‚3ã§ã‚ã‚‹ã€‚
ã“ã‚Œã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¦æ±ºå®šã•ã‚Œã‚‹ã€‚
é€£ãªã‚Šã®ã†ã¡ã®æœ€åˆã®ãƒ•ãƒ¬ãƒ¼ãƒ  (ãƒ•ãƒ¬ãƒ¼ãƒ III) ã‚’åŸå‘³ã—ã€<tt>x</tt> ã«å¯¾ã™ã‚‹æŸç¸›ãŒè¦‹ã¤ã‹ã‚‰ãªã„ã®ã§ã€å¤–å´ã‚’å›²ã£ã¦ã„ã‚‹ç’°å¢ƒDã«é€²ã‚“ã§ã€ãƒ•ãƒ¬ãƒ¼ãƒ Iã«ãŠã„ã¦æŸç¸›ã‚’è¦‹ã¤ã‘ã‚‹ã€‚
ä»–æ–¹ã€ç’°å¢ƒAã«ãŠã‘ã‚‹<tt>x</tt> ã®å€¤ã¯7ã§ã‚ã‚‹ã€‚ã¨ã„ã†ã®ã‚‚ã€é€£ãªã‚Šã®ã†ã¡ã®æœ€åˆã®ãƒ•ãƒ¬ãƒ¼ãƒ  (ãƒ•ãƒ¬ãƒ¼ãƒ II) ãŒã€<tt>x</tt> ã®7ã¸ã®æŸç¸›ã‚’å«ã‚“ã§ã„ã‚‹ã‹ã‚‰ã§ã‚ã‚‹ã€‚
ç’°å¢ƒAã«é–¢ã—ã¦ã¯ã€ãƒ•ãƒ¬ãƒ¼ãƒ IIã«ãŠã‘ã‚‹ <tt>x</tt> ã®7ã¸ã®æŸç¸›ãŒã€ãƒ•ãƒ¬ãƒ¼ãƒ Iã«ãŠã‘ã‚‹ <tt>x</tt> ã®3ã¸ã®æŸç¸›ã‚’<em>å½±ã§è¦†ã„éš ã™</em>ã€ã¨ã„ã†ãµã†ã«è¨€ã‚ã‚Œã‚‹
</p>

<p class="orig" lang="en">
The environment is crucial to the evaluation process,
because it determines the context in which an expression should be
evaluated.  Indeed, one could say that expressions in a programming
language do not, in themselves, have any meaning.  Rather, an
expression acquires a meaning only with respect to some environment in
which it is evaluated.  Even the interpretation of an expression as
straightforward as <tt>(+ 1 1)</tt> depends on an understanding that one
is operating in a context in which <tt>+</tt> is the symbol for addition.
Thus, in our model of evaluation we will always speak of evaluating an
expression with respect to some environment.  To describe interactions
with the interpreter, we will suppose that there is a <a name="%_idx_3062"></a>global
environment, consisting of a single frame (with no enclosing
environment) that includes values for the symbols associated with the
primitive procedures.  For example, the idea that <tt>+</tt> is the
symbol for addition is captured by saying that the symbol <tt>+</tt> is
bound in the global environment to the primitive addition procedure.
</p>

<p class="trans" lang="ja">
ç’°å¢ƒã¯ã€è©•ä¾¡ãƒ—ãƒ­ã‚»ã‚¹ã«ã¨ã£ã¦æ±ºå®šçš„ã«é‡è¦ã§ã‚ã‚‹ã€‚ã¨ã„ã†ã®ã‚‚ã€ç’°å¢ƒã¯ã€å¼ãŒè©•ä¾¡ã•ã‚Œã‚‹ã¹ãæ–‡è„ˆã‚’æ±ºå®šã™ã‚‹ã‹ã‚‰ã ã€‚
å®Ÿéš›ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã«ãŠã‘ã‚‹å¼ã¨ã¯ã€ãã‚Œè‡ªä½“ã§ã¯ä½•ã®æ„å‘³ã‚‚æŒãŸãªã„ã®ã ã€ã¨è¨€ã†ã“ã¨ã ã£ã¦ã§ãã‚‹ã ã‚ã†ã€‚
ã‚€ã—ã‚ã€å¼ã¯ã€ãã®å¼ãŒè©•ä¾¡ã•ã‚Œã‚‹ä½•ã‚‰ã‹ã®ç’°å¢ƒã«é–¢ã—ã¦ã®ã¿ã€æ„å‘³ã‚’ç²å¾—ã™ã‚‹ã€‚
<tt>(+ 1 1)</tt> ã®ã‚ˆã†ãªç°¡å˜ãªå¼ã®è§£é‡ˆã§ã™ã‚‰ã€<tt>+</tt> ãŒåŠ ç®—ã®ãŸã‚ã®è¨˜å·ã§ã‚ã‚‹ã‚ˆã†ãªæ–‡è„ˆã«ãŠã„ã¦ä½œæ¥­ã—ã¦ã„ã‚‹ã¨ã“ã‚ãªã®ã ã€ã¨ã„ã†ç†è§£ã«ä¾å­˜ã™ã‚‹ã€‚
ã‚ˆã£ã¦ã€è©•ä¾¡ã«ã¤ã„ã¦ã®ç§ãŸã¡ã®ãƒ¢ãƒ‡ãƒ«ã«ãŠã„ã¦ã€ç§ãŸã¡ã¯å¸¸ã«ã€ä½•ã‚‰ã‹ã®ç’°å¢ƒã«é–¢ã—ã¦å¼ã‚’è©•ä¾¡ã™ã‚‹ã€ã¨ã„ã†ã“ã¨ã«è¨€åŠã™ã‚‹ã ã‚ã†ã€‚
ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã¨ã®é–“ã®ã‚„ã‚Šã¨ã‚Šã‚’èª¬æ˜ã™ã‚‹ãŸã‚ã«ã€å¤§åŸŸç’°å¢ƒâ€”â€”åŸå§‹çš„æ‰‹ç¶šãã¨é–¢é€£ã¥ã‘ã‚‰ã‚ŒãŸè¨˜å·ã«å¯¾ã™ã‚‹å€¤ã‚’å«ã‚€ã‚ˆã†ãªã€å˜ä¸€ã®ãƒ•ãƒ¬ãƒ¼ãƒ  (å¤–å´ã‚’å›²ã£ã¦ã„ã‚‹ç’°å¢ƒãŒãªã„ã‚‚ã®) ã®ã¿ã‹ã‚‰ãªã‚‹â€”â€”ãŒã‚ã‚‹ã€ã¨æƒ³å®šã—ã‚ˆã†ã€‚
ãŸã¨ãˆã°ã€<tt>+</tt> ã¨ã¯åŠ ç®—ã®ãŸã‚ã®è¨˜å·ã§ã‚ã‚‹ã€ã¨ã„ã†æ¦‚å¿µã¯ã€<tt>+</tt> ã¨ã„ã†è¨˜å·ãŒå¤§åŸŸç’°å¢ƒã«ãŠã„ã¦ã¯åŸå§‹çš„åŠ ç®—æ‰‹ç¶šãã«æŸç¸›ã•ã‚Œã¦ã„ã‚‹ã€ã¨è¨€ã†ã“ã¨ã«ã‚ˆã£ã¦ã€ã†ã¾ãæ‰ãˆã‚‰ã‚Œã‚‹ã€‚
</p>

<a name="%_sec_3.2.1"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_3.2.1">3.2.1  The Rules for Evaluation</a></h3>
<h3 class="trans" lang="ja">3.2.1 è©•ä¾¡ç”¨è¦å‰‡</h3>

<p class="orig" lang="en">
<a name="%_idx_3064"></a>
The overall specification of how the interpreter evaluates a
combination remains the same as when we first introduced it in
section <a href="10_sec1_1.html#%_sec_1.1.3">1.1.3</a>:
</p>

<p class="trans" lang="ja">
ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒã©ã®ã‚ˆã†ã«ã‚³ãƒ³ãƒ“ãƒãƒ¼ã‚·ãƒ§ãƒ³ã‚’è©•ä¾¡ã™ã‚‹ã®ã‹ã«ã¤ã„ã¦ã®å…¨èˆ¬çš„ãªæ˜ç´°ã¯ã€<a href="10_sec1_1.html#%_sec_1.1.3">1.1.3</a>ç¯€ã§ãã®ã“ã¨ã‚’æœ€åˆã«æŒã¡è¾¼ã‚“ã ã¨ãã¨åŒã˜ã¾ã¾ã§ã‚ã‚‹ã€‚ã™ãªã‚ã¡ã€
</p>

<ul class="orig" lang="en">
<li>To evaluate a combination:
<ol>
<li>Evaluate the subexpressions of the
combination.<a name="call_footnote_Temp_342" href="#footnote_Temp_342"><sup><small>12</small></sup></a></li>
<li>Apply the value of the operator subexpression to the values of the
operand subexpressions.</li>
</ol>
</li>
</ul>

<ul class="trans" lang="ja">
<li>ã‚³ãƒ³ãƒ“ãƒãƒ¼ã‚·ãƒ§ãƒ³ã‚’è©•ä¾¡ã™ã‚‹ãŸã‚ã«ã¯ã€
<ol>
<li>ãã®ã‚³ãƒ³ãƒ“ãƒãƒ¼ã‚·ãƒ§ãƒ³ã®éƒ¨åˆ†å¼ã‚’è©•ä¾¡ã›ã‚ˆ<a href="#footnote_Temp_342"><sup><small>12</small></sup></a>ã€‚</li>
<li>ã‚ªãƒšãƒ¬ãƒ¼ã‚¿éƒ¨åˆ†å¼ã®å€¤ã‚’ã€ã‚ªãƒšãƒ©ãƒ³ãƒ‰éƒ¨åˆ†å¼ã®å€¤ã«é©ç”¨ã›ã‚ˆã€‚</li>
</ol>
</li>
</ul>

<p class="orig" lang="en">
The environment model of evaluation replaces the substitution model in
specifying what it means to apply a compound procedure to arguments.
</p>

<p class="trans" lang="ja">
å¼•æ•°ã«è¤‡åˆçš„æ‰‹ç¶šãã‚’é©ç”¨ã™ã‚‹ã“ã¨ã®æ„å‘³ã‚’è¦å®šã™ã‚‹ã¨ã“ã‚ã§ã€è©•ä¾¡ã«ã¤ã„ã¦ã®ç’°å¢ƒãƒ¢ãƒ‡ãƒ«ãŒã€<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ãŠãã‹ãˆ</rt><rp>) </rp></ruby>ãƒ¢ãƒ‡ãƒ«ã«å–ã£ã¦ä»£ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
In the environment model of evaluation, a procedure is always a pair
consisting of some code and a pointer to an environment.  Procedures
are created in one way only: by evaluating a <tt>lambda</tt> expression.
<a name="%_idx_3070"></a>This produces a procedure whose code is obtained from the text of the
<tt>lambda</tt> expression and whose environment is the environment in
which the <tt>lambda</tt> expression was evaluated to produce the
procedure.  For example, consider the procedure definition</p>

<p class="trans" lang="ja">
è©•ä¾¡ã«ã¤ã„ã¦ã®ç’°å¢ƒãƒ¢ãƒ‡ãƒ«ã«ãŠã„ã¦ã¯ã€æ‰‹ç¶šãã¯å¸¸ã«ã€ä½•ã‚‰ã‹ã®ã‚³ãƒ¼ãƒ‰ã¨ã€ç’°å¢ƒã¸ã®ãƒã‚¤ãƒ³ã‚¿ã¨ã®å¯¾ã§ã‚ã‚‹ã€‚
æ‰‹ç¶šãã¯ä¸€ã¤ã®ã‚„ã‚Šæ–¹ã§ã®ã¿ã€ä½œæˆã•ã‚Œã‚‹â€”â€”ã¤ã¾ã‚Šã€<tt>lambda</tt> å¼ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€‚
ã“ã‚Œã¯ã€æ¬¡ã®ã‚ˆã†ãªæ‰‹ç¶šãã‚’ä½œã‚Šå‡ºã™â€”â€”ãã®æ‰‹ç¶šãã®ã‚³ãƒ¼ãƒ‰ã¯ã€<tt>lambda</tt> å¼ã®ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰å¾—ã‚‰ã‚Œã€ã‹ã¤ã€ãã®æ‰‹ç¶šãã®ç’°å¢ƒã¨ã¯ã€ãã®æ‰‹ç¶šãã‚’ä½œã‚Šå‡ºã™ãŸã‚ã« <tt>lambda</tt> å¼ãŒè©•ä¾¡ã•ã‚ŒãŸç’°å¢ƒã§ã‚ã‚‹ã€ã¨ã„ã†ã‚ˆã†ãªæ‰‹ç¶šãã§ã‚ã‚‹ã€‚
ä¾‹ãˆã°ã€æ¬¡ã®æ‰‹ç¶šãå®šç¾©
</p>

<p class="lisp"><a name="%_idx_3072"></a>(define (square x)
  (* x x))
</p>

<p class="orig" lang="en">
evaluated in the global environment.  The procedure definition syntax
is just syntactic sugar for an underlying implicit <tt>lambda</tt>
expression.  It would have been equivalent to have used</p>

<p class="trans" lang="ja">
â€”â€”å¤§åŸŸç’°å¢ƒã§è©•ä¾¡ã•ã‚Œã‚‹â€”â€”ã‚’è€ƒãˆã‚ˆã†ã€‚
æ‰‹ç¶šãå®šç¾©æ§‹æ–‡ã¯ã€æ ¹åº•ã«ã‚ã‚‹æš—é»™è£¡ã® <tt>lambda</tt> å¼ã®ãŸã‚ã®å˜ãªã‚‹ç³–è¡£æ§‹æ–‡ã ã€‚
ã“ã‚Œã¯ã€ä»¥ä¸‹ã®ã‚‚ã®ã‚’ä½¿ã£ãŸã“ã¨ã¨ã€ç­‰ä¾¡ã«ãªã£ãŸã§ã‚ã‚ã†ã€‚
</p>


<p class="lisp">(define square
  (lambda (x) (* x x)))
</p>

<p class="orig" lang="en">
which evaluates <tt>(lambda (x) (* x x))</tt> and binds <tt>square</tt> to the resulting value, all in the global environment.</p>

<p class="trans" lang="ja">
ã“ã‚Œã¯ã€<tt>(lambda (x) (* x x))</tt> ã‚’è©•ä¾¡ã—ã¦ã€çµæœã¨ã—ã¦ç”Ÿã˜ã‚‹å€¤ã« <tt>square</tt> ã‚’æŸç¸›ã—ã€ãã®ã™ã¹ã¦ã‚’å¤§åŸŸç’°å¢ƒã§è¡Œã†ã‚‚ã®ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
Figure <a href="#%_fig_3.2">3.2</a> shows the result of evaluating this
<tt>define</tt> expression.  The procedure object is a pair whose code
specifies that the procedure has one formal parameter, namely <tt>x</tt>,
and a procedure body <tt>(* x x)</tt>.  The environment part of the
procedure is a pointer to the global environment, since that is the
environment in which the <tt>lambda</tt> expression was evaluated to
produce the procedure. A new binding, which associates the procedure
object with the symbol <tt>square</tt>, has been added to the global
frame.  In general, <tt>define</tt> creates definitions by adding
bindings to frames.</p>

<p class="trans" lang="ja">
å›³<a href="#%_fig_3.2">3.2</a> ã¯ã€ã“ã® <tt>define</tt> å¼ã‚’è©•ä¾¡ã—ãŸçµæœã‚’ç¤ºã™ã€‚
æ‰‹ç¶šãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ã“ã®æ‰‹ç¶šãã«ã¯ä¸€ã¤ã®ä»®å¼•æ•°â€”â€”ã¤ã¾ã‚Š <tt>x</tt> â€”â€”ã¨ <tt>(* x x)</tt> ã¨ã„ã†æ‰‹ç¶šãæœ¬ä½“ãŒã‚ã‚‹ã®ã ã€ã¨ã‚³ãƒ¼ãƒ‰ãŒæ˜ç´°ã‚’è¿°ã¹ã¦ã„ã‚‹ã‚ˆã†ãªã€å¯¾ã§ã‚ã‚‹ã€‚
æ‰‹ç¶šãã®ç’°å¢ƒéƒ¨ã¯ã€å¤§åŸŸç’°å¢ƒã¸ã®ãƒã‚¤ãƒ³ã‚¿ã§ã‚ã‚‹ã€‚ã¨ã„ã†ã®ã¯ã€ãã®å¤§åŸŸç’°å¢ƒã“ããŒã€ã“ã®æ‰‹ç¶šãã‚’ä½œã‚Šå‡ºã™ãŸã‚ã« <tt>lambda</tt> å¼ãŒè©•ä¾¡ã•ã‚ŒãŸç’°å¢ƒã ã‹ã‚‰ã§ã‚ã‚‹ã€‚
æ–°ãŸãªæŸç¸›â€”â€”ã“ã®æ‰‹ç¶šãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã€<tt>square</tt> ã¨ã„ã†è¨˜å·ã«é–¢é€£ã¥ã‘ã‚‹â€”â€”ãŒã€å¤§åŸŸãƒ•ãƒ¬ãƒ¼ãƒ ã«è¿½åŠ ã•ã‚ŒãŸã€‚
ä¸€èˆ¬ã«ã€<tt>definde</tt> ã¯ã€ãƒ•ãƒ¬ãƒ¼ãƒ ã«æŸç¸›ã‚’è¿½åŠ ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€å®šç¾©ã‚’ä½œæˆã™ã‚‹ã€‚
</p>


<a name="%_fig_3.2"></a>
<figure>
<img src="ch3-Z-G-3.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.2:</b>  Environment structure produced by
evaluating <tt>(define (square x) (* x x))</tt> in the global environment.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³3.2:</b> å¤§åŸŸç’°å¢ƒã§ <tt>(define (square x) (* x x))</tt> ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ã§ä½œã‚Šå‡ºã•ã‚Œã‚‹ç’°å¢ƒæ§‹é€ </figcaption>
</figure>

<p class="orig" lang="en">
Now that we have seen how procedures are created, we can describe how
procedures are applied.  The environment model specifies: To apply a
procedure to arguments, create a new environment containing a frame
that binds the parameters to the values of the arguments.  The
enclosing environment of this frame is the environment specified by
the procedure.  Now, within this new environment, evaluate the
procedure body.</p>

<p class="trans" lang="ja">
æ‰‹ç¶šããŒã©ã®ã‚ˆã†ã«ä½œæˆã•ã‚Œã‚‹ã®ã‹ã‚’è¦‹ãŸã‹ã‚‰ã«ã¯ã€ç§ãŸã¡ã¯ã‚‚ã†ã€æ‰‹ç¶šããŒã©ã®ã‚ˆã†ã«é©ç”¨ã•ã‚Œã‚‹ã®ã‹ã‚’è¨˜è¿°ã§ãã‚‹ã€‚
ç’°å¢ƒãƒ¢ãƒ‡ãƒ«ã¯ã€ã“ã†è¦å®šã™ã‚‹ã€‚ã™ãªã‚ã¡ã€å¼•æ•°ã«æ‰‹ç¶šãã‚’é©ç”¨ã™ã‚‹ã«ã¯ã€ä»®å¼•æ•°ã‚’å®Ÿå¼•æ•°ã®å€¤ã«æŸç¸›ã™ã‚‹ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’å«ã‚€ã€æ–°ãŸãªç’°å¢ƒã‚’ä½œæˆã›ã‚ˆã€ã¨ã€‚
ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã«ã¨ã£ã¦ã®ã€å¤–å´ã‚’å›²ã£ã¦ã„ã‚‹ç’°å¢ƒã¨ã¯ã€æ‰‹ç¶šãã«ã‚ˆã£ã¦æŒ‡å®šã•ã‚Œã‚‹ç’°å¢ƒã§ã‚ã‚‹ã€‚
ãã—ã¦ã“ã“ã§ã€æ–°ãŸãªç’°å¢ƒã®ä¸­ã§ã€æ‰‹ç¶šãæœ¬ä½“ã‚’è©•ä¾¡ã›ã‚ˆã€‚
</p>

<p class="orig" lang="en">
To show how this rule is followed, figure <a href="#%_fig_3.3">3.3</a>
illustrates the environment structure created by evaluating the
expression <tt>(square 5)</tt> in the global environment, where <tt>square</tt> is the procedure generated in
figure <a href="#%_fig_3.2">3.2</a>.  Applying the procedure results in
the creation of a new environment, labeled E1 in the figure, that
begins with a frame in which <tt>x</tt>, the formal parameter for the
procedure, is bound to the argument 5.  The pointer leading upward
from this frame shows that the frame's enclosing environment is the
global environment.  The global environment is chosen here, because
this is the environment that is indicated as part of the <tt>square</tt>
procedure object.  Within E1, we evaluate the body of the procedure,
<tt>(* x x)</tt>.  Since the value of <tt>x</tt> in E1 is 5, the result is
<tt>(* 5 5)</tt>, or 25.</p>

<p class="trans" lang="ja">
ã“ã®è¦å‰‡ãŒã©ã®ã‚ˆã†ã«ã—ã¦å®ˆã‚‰ã‚Œã‚‹ã®ã‹ã€ã‚’ç¤ºã™ãŸã‚ã«ã€å›³<a href="#%_fig_3.3">3.3</a>ã¯ã€å¤§åŸŸç’°å¢ƒã«ãŠã„ã¦ <tt>(square 5)</tt> ã¨ã„ã†å¼ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ä½œæˆã•ã‚Œã‚‹ç’°å¢ƒæ§‹é€ ã‚’ç¤ºã—ã¦ã„ã‚‹â€”â€”ãŸã ã—ã“ã“ã§ã€<tt>square</tt> ã¯ã€å›³<a href="#%_fig_3.2">3.2</a>ã§ç”Ÿæˆã•ã‚ŒãŸæ‰‹ç¶šãã§ã‚ã‚‹ã€‚æ‰‹ç¶šãã®é©ç”¨ã¯ã€<tt>x</tt> â€”â€”ã“ã®æ‰‹ç¶šãã®ä»®å¼•æ•°â€”â€”ãŒå®Ÿå¼•æ•°ã®5ã«æŸç¸›ã•ã‚Œã‚‹ãƒ•ãƒ¬ãƒ¼ãƒ ã§å§‹ã¾ã‚‹ã€æ–°ãŸãªç’°å¢ƒâ€”â€”å›³ã§ã¯ E1 ã¨ãƒ©ãƒ™ãƒ«ã¥ã‘ã•ã‚Œã¦ã„ã‚‹â€”â€”ã®ä½œæˆã€ã¨ã„ã†çµæœã‚’ã‚‚ãŸã‚‰ã™ã€‚
ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰ä¸Šå‘ãã«å‡ºã¦ã„ã‚‹ãƒã‚¤ãƒ³ã‚¿ã¯ã€ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã®å¤–å´ã‚’å›²ã£ã¦ã„ã‚‹ç’°å¢ƒãŒå¤§åŸŸç’°å¢ƒã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã™ã€‚
å¤§åŸŸç’°å¢ƒã¯ã€ã“ã‚Œã“ããŒã€<tt>square</tt> ã®æ‰‹ç¶šãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä¸€éƒ¨ã¨ã—ã¦ç¤ºã•ã‚Œã‚‹ç’°å¢ƒã§ã‚ã‚‹ã®ã§ã€ã“ã“ã§é¸ã°ã‚Œã¦ã„ã‚‹ã‚ã‘ã ã€‚
E1ã®ä¸­ã§ã€æ‰‹ç¶šãã®æœ¬ä½“â€”â€”ã™ãªã‚ã¡ <tt>(* x x)</tt> â€”â€”ã‚’ã€è©•ä¾¡ã™ã‚‹ã€‚
E1å†…ã§ã® <tt>x</tt> ã®å€¤ã¯5ãªã®ã§ã€çµæœã¯ <tt>(* 5 5)</tt> ã€ã¤ã¾ã‚Š25ã§ã‚ã‚‹ã€‚
</p>

<a name="%_fig_3.3"></a>
<figure>
<img src="ch3-Z-G-4.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.3:</b>  Environment created by evaluating <tt>(square 5)</tt> in the global environment.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³3.3:</b>å¤§åŸŸç’°å¢ƒã§ <tt>(square 5)</tt> ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ã§ä½œæˆã•ã‚Œã‚‹ç’°å¢ƒ</figcaption>
</figure>


<p class="orig" lang="en">
The environment model of procedure application can be summarized by
two rules:</p>

<p class="trans" lang="ja">
æ‰‹ç¶šãé©ç”¨ã«ã¤ã„ã¦ã®ç’°å¢ƒãƒ¢ãƒ‡ãƒ«ã¯ã€äºŒã¤ã®è¦å‰‡ã§è¦ç´„ã§ãã‚‹ã€‚
</p>

<ul class="orig" lang="en">
<li>A procedure object is applied to a set of arguments by
constructing a frame, binding the formal parameters of the procedure
to the arguments of the call, and then evaluating the body of
the procedure in the context of the new environment constructed.  The
new frame has as its enclosing environment the environment part of the
procedure object being applied.</li>

<a name="%_idx_3074"></a><a name="%_idx_3076"></a>
<li>A procedure is created by evaluating a <tt>lambda</tt>
expression relative to a given environment.  The resulting procedure
object is a pair consisting of the text of the <tt>lambda</tt> expression
and a pointer to the environment in which the procedure was created.</li>
</ul>

<ul class="trans" lang="ja">
<li>ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’æ§‹ç¯‰ã—ã€æ‰‹ç¶šãã®ä»®å¼•æ•°ã‚’ãã®å‘¼ã³å‡ºã—ã®å®Ÿå¼•æ•°ã«æŸç¸›ã—ã€ãã‚Œã‹ã‚‰ã€æ§‹ç¯‰ã•ã‚ŒãŸæ–°ãŸãªç’°å¢ƒã®æ–‡è„ˆã«ãŠã„ã¦æ‰‹ç¶šãã®æœ¬ä½“ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€æ‰‹ç¶šãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå®Ÿå¼•æ•°ã®é›†åˆã«é©ç”¨ã•ã‚Œã‚‹ã€‚
æ–°ãŸãªãƒ•ãƒ¬ãƒ¼ãƒ ã¯ã€è‡ªåˆ†ã®å¤–å´ã‚’å›²ã£ã¦ã„ã‚‹ç’°å¢ƒã¨ã—ã¦ã€ã„ã¾é©ç”¨ã•ã‚Œã¦ã„ã‚‹æ‰‹ç¶šãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç’°å¢ƒéƒ¨ã‚’æœ‰ã™ã‚‹ã€‚</li>
<li>æ‰‹ç¶šãã¯ã€ä¸ãˆã‚‰ã‚ŒãŸç’°å¢ƒã«é–¢é€£ã—ãŸ <tt>lambda</tt> å¼ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ã§ã€ä½œæˆã•ã‚Œã‚‹ã€‚
çµæœã¨ã—ã¦ç”Ÿã˜ã‚‹æ‰‹ç¶šãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€<tt>lambda</tt> å¼ã®ãƒ†ã‚­ã‚¹ãƒˆã¨ã€ãã®æ‰‹ç¶šããŒä½œæˆã•ã‚ŒãŸç’°å¢ƒã¸ã®ãƒã‚¤ãƒ³ã‚¿ã¨ã€ã‹ã‚‰ãªã‚‹å¯¾ã§ã‚ã‚‹ã€‚</li>
</ul>

<p class="orig" lang="en">
<a name="%_idx_3078"></a>We also specify that defining a symbol using <tt>define</tt> creates a
binding in the current environment frame and assigns to the symbol the
indicated value.<a name="call_footnote_Temp_343" href="#footnote_Temp_343"><sup><small>13</small></sup></a>  Finally, we specify the behavior of
<tt>set!</tt>, the operation that forced us to introduce the environment
model in the first place.  Evaluating the expression <tt>(set!
&lt;<em>variable</em>&gt; &lt;<em>value</em>&gt;)</tt> in some environment locates the binding of
the variable in the environment and changes that binding to indicate
the new value.  That is, one finds the first frame in the environment
that contains a binding for the variable and modifies that frame.  If
the variable is unbound in the environment, then <tt>set!</tt> signals
an error.</p>

<p class="trans" lang="ja">
<tt>define</tt> ã‚’ç”¨ã„ã¦è¨˜å·ã‚’å®šç¾©ã™ã‚‹ã“ã¨ã¯ã€ç¾åœ¨ã®ç’°å¢ƒãƒ•ãƒ¬ãƒ¼ãƒ ã§ã®æŸç¸›ã‚’ä½œã‚Šå‡ºã—ã€ã‹ã¤ã€ç¤ºã•ã‚ŒãŸå€¤ã‚’ãã®è¨˜å·ã«å‰²ã‚Šå½“ã¦ã‚‹ã®ã ã€ã¨ã„ã†ã“ã¨ã‚‚ã€ç§ãŸã¡ã¯è¦å®šã™ã‚‹<a href="#footnote_Temp_343"><sup><small>13</small></sup></a>ã€‚
æœ€å¾Œã«ã€<tt>set!</tt> â€”â€”ã¤ã¾ã‚Šã€ãã‚‚ãã‚‚ç§ãŸã¡ãŒç’°å¢ƒãƒ¢ãƒ‡ãƒ«ã‚’å°å…¥ã›ã–ã‚‹ã‚’å¾—ãªã„ã‚ˆã†ã«ã—ãŸæ¼”ç®—â€”â€”ã®æŒ¯ã‚‹èˆã„ã‚’è¦å®šã™ã‚‹ã€‚
<tt>(set! &lt;<em class="en">variable</em>&gt; &lt;<em class="en">value</em>&gt;)</tt> 
ã¨ã„ã†å¼ã‚’ã‚ã‚‹ç’°å¢ƒã§è©•ä¾¡ã™ã‚‹ã“ã¨ã§ã€ãã®ç’°å¢ƒã§ã®å¤‰æ•°ã®æŸç¸›ãŒæ¢ã—å‡ºã•ã‚Œã€ãã®æŸç¸›ã¯ã€æ–°ãŸãªå€¤ã‚’æŒ‡ã—ç¤ºã™ã‚ˆã†ã«å¤‰æ›´ã•ã‚Œã‚‹ã€‚
ã¤ã¾ã‚Šã€ãã®å¤‰æ•°ã«å¯¾ã™ã‚‹æŸç¸›ã‚’å«ã‚€ã‚ˆã†ãªã€ãã®ç’°å¢ƒå†…ã§ã®æœ€åˆã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’è¦‹ã¤ã‘ã¦ã€ãã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ä¿®æ­£ã™ã‚‹ã®ã ã€‚
ã‚‚ã—ã€ãã®å¤‰æ•°ãŒãã®ç’°å¢ƒã«ãŠã„ã¦æŸç¸›ã•ã‚Œã¦ã„ãªã‘ã‚Œã°ã€<tt>set!</tt> ã¯ã‚¨ãƒ©ãƒ¼ã®åˆå›³ã‚’é€ã‚‹ã€‚
</p>

<p class="orig" lang="en">
These evaluation rules, though considerably more complex than the
substitution model, are still reasonably straightforward.  Moreover,
the evaluation model, though abstract, provides a correct description
of how the interpreter evaluates expressions.  In chapter 4 we shall
see how this model can serve as a blueprint for implementing a working
interpreter.  The following sections elaborate the details of the
model by analyzing some illustrative programs.</p>

<p class="trans" lang="ja">
ã“ã‚Œã‚‰ã®è©•ä¾¡è¦å‰‡ã¯ã€<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ãŠãã‹ãˆ</rt><rp>) </rp></ruby>ãƒ¢ãƒ‡ãƒ«ã‚ˆã‚Šã‚‚ã‹ãªã‚Šè¤‡é›‘ã§ã¯ã‚ã‚‹ãŒã€ãã‚Œã§ã‚‚ã¾ã ã€ã¾ãšã¾ãšåˆ†ã‚Šã‚„ã™ã„ã€‚
ã•ã‚‰ã«ã€è©•ä¾¡ãƒ¢ãƒ‡ãƒ«ã¯ã€æŠ½è±¡çš„ã§ã¯ã‚ã‚‹ãŒã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒã©ã®ã‚ˆã†ã«ã—ã¦å¼ã‚’è©•ä¾¡ã™ã‚‹ã®ã‹ã«ã¤ã„ã¦ã®ã€æ­£ã—ã„èª¬æ˜ã‚’ä¸ãˆã‚‹ã€‚
4ç« ã§ã¯ã€ã©ã®ã‚ˆã†ã«ã—ã¦ã“ã®ãƒ¢ãƒ‡ãƒ«ãŒã€å®Ÿç”¨ã«è¶³ã‚‹ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã®é’å†™çœŸã¨ã—ã¦å½¹ç«‹ã¤ã“ã¨ãŒã§ãã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’è¦‹ã‚‹ã“ã¨ã«ã—ã‚ˆã†ã€‚
ä»¥ä¸‹ã®ç¯€ã¯ã€ã„ãã¤ã‹ã®ä¾‹ç¤ºçš„ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’åˆ†æã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€ã“ã®ãƒ¢ãƒ‡ãƒ«ã®è©³ç´°ã‚’è©³ã—ãè¿°ã¹ã‚‹ã‚‚ã®ã§ã‚ã‚‹ã€‚
</p>


<a name="%_sec_3.2.2"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_3.2.2">3.2.2  Applying Simple Procedures</a></h3>
<h3 class="trans" lang="ja">3.2.2 ç°¡å˜ãªæ‰‹ç¶šãã‚’é©ç”¨ã™ã‚‹</h3>

<p class="orig" lang="en">
<a name="%_idx_3082"></a><a name="%_idx_3084"></a>
<a name="%_idx_3086"></a>When we introduced the substitution model in
section <a href="10_sec1_1.html#%_sec_1.1.5">1.1.5</a> we showed how the combination
<tt>(f 5)</tt> evaluates to 136, given the following procedure
definitions:</p>

<p class="trans" lang="ja">
<a href="10_sec1_1.html#%_sec_1.1.5">1.1.5</a>ç¯€ã§<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ãŠãã‹ãˆ</rt><rp>) </rp></ruby>ãƒ¢ãƒ‡ãƒ«ã‚’å°å…¥ã—ãŸã¨ãã€ç§ãŸã¡ã¯ã€ä»¥ä¸‹ã®æ‰‹ç¶šãå®šç¾©ãŒä¸ãˆã‚‰ã‚ŒãŸå ´åˆã«ã©ã®ã‚ˆã†ã«ã—ã¦ <tt>(f 5)</tt> ã¨ã„ã†ã‚³ãƒ³ãƒ“ãƒãƒ¼ã‚·ãƒ§ãƒ³ãŒ136ã¨æ±‚ã¾ã‚‹ã®ã‹ã€ã‚’ç¤ºã—ãŸã€‚
</p>

<p class="lisp">(define (square x)
  (* x x))
(define (sum-of-squares x y)
  (+ (square x) (square y)))
(define (f a)
  (sum-of-squares (+ a 1) (* a 2)))
</p>

<p class="orig" lang="en">
We can analyze the same example using the environment model.
Figure <a href="#%_fig_3.4">3.4</a> shows the three procedure objects
created by evaluating the definitions of <tt>f</tt>, <tt>square</tt>, and
<tt>sum-of-squares</tt> in the global environment.  Each procedure object
consists of some code, together with a pointer to the global
environment.</p>

<p class="trans" lang="ja">
ç§ãŸã¡ã¯ã€ç’°å¢ƒãƒ¢ãƒ‡ãƒ«ã‚’ä½¿ã£ã¦ã€åŒã˜äº‹ä¾‹ã‚’åˆ†æã§ãã‚‹ã€‚
å›³<a href="#%_fig_3.4">3.4</a>ã¯ã€å¤§åŸŸç’°å¢ƒã«ãŠã„ã¦ <tt>f</tt> ã¨ <tt>square</tt> ã¨ <tt>sum-of-squares</tt> ã®å®šç¾©ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ä½œæˆã•ã‚Œã‚‹ä¸‰ã¤ã®æ‰‹ç¶šãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç¤ºã™ã€‚
å„æ‰‹ç¶šãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€å¤§åŸŸç’°å¢ƒã¸ã®ãƒã‚¤ãƒ³ã‚¿ã‚’ã¨ã‚‚ãªã£ãŸã€ä½•ã‚‰ã‹ã®ã‚³ãƒ¼ãƒ‰ã‹ã‚‰ãªã‚‹ã€‚
</p>

<a name="%_fig_3.4"></a>
<figure>
<img src="ch3-Z-G-5.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.4:</b>  Procedure objects in the global frame.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³3.4:</b> å¤§åŸŸãƒ•ãƒ¬ãƒ¼ãƒ å†…ã®æ‰‹ç¶šãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ</figcaption>
</figure>


<p class="orig" lang="en">
In figure <a href="#%_fig_3.5">3.5</a> we see the environment structure created
by evaluating the expression <tt>(f 5)</tt>.  The call to <tt>f</tt> creates
a new environment E1 beginning with a frame in which <tt>a</tt>, the
formal parameter of <tt>f</tt>, is bound to the argument 5.  In E1, we
evaluate the body of <tt>f</tt>:</p>

<p class="trans" lang="ja">
å›³<a href="#%_fig_3.5">3.5</a>ã§ã¯ã€<tt>(f 5)</tt> ã¨ã„ã†å¼ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ã§ä½œæˆã•ã‚Œã‚‹ç’°å¢ƒæ§‹é€ ã‚’è¦‹ã¦ã„ã‚‹ã€‚
<tt>f</tt> ã«å¯¾ã™ã‚‹å‘¼ã³å‡ºã—ã¯ã€<tt>a</tt> â€”â€”ã™ãªã‚ã¡ã€<tt>f</tt> ã®ä»®å¼•æ•°â€”â€”ãŒ5ã¨ã„ã†å®Ÿå¼•æ•°ã«æŸç¸›ã•ã‚Œã‚‹ãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰å§‹ã¾ã‚‹ã€E1ã¨ã„ã†æ–°ãŸãªç’°å¢ƒã‚’ã€ä½œæˆã™ã‚‹ã€‚
E1ã§ã€ä»¥ä¸‹ã®ã¨ãŠã‚Šã® <tt>f</tt> ã®æœ¬ä½“ã‚’è©•ä¾¡ã™ã‚‹ã€‚
</p>

<p class="lisp">(sum-of-squares (+ a 1) (* a 2))
</p>

<a name="%_fig_3.5"></a>
<figure>
<img src="ch3-Z-G-6.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.5:</b>  Environments created by evaluating <tt>(f 5)</tt>
using the procedures in figure <a href="#%_fig_3.4">3.4</a>.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³3.5:</b> å›³<a href="#%_fig_3.4">3.4</a>ã®æ‰‹ç¶šãã‚’ä½¿ã£ã¦ <tt>(f 5)</tt> ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ã§ä½œæˆã•ã‚Œã‚‹ç’°å¢ƒ</figcaption>
</figure>


<p class="orig" lang="en">
To evaluate this combination, we first evaluate the subexpressions.
The first subexpression, <tt>sum-of-squares</tt>, has a value that is a
procedure object.  (Notice how this value is found: We first look in
the first frame of E1, which contains no binding for <tt>sum-of-squares</tt>.  Then we proceed to the enclosing environment,
i.e. the global environment, and find the binding shown in
figure <a href="#%_fig_3.4">3.4</a>.)  The other two subexpressions are
evaluated by applying the primitive operations <tt>+</tt> and <tt>*</tt> to
evaluate the two combinations <tt>(+ a 1)</tt> and <tt>(* a 2)</tt> to
obtain 6 and 10, respectively.</p>

<p class="trans" lang="ja">
ã“ã®ã‚³ãƒ³ãƒ“ãƒãƒ¼ã‚·ãƒ§ãƒ³ã‚’è©•ä¾¡ã™ã‚‹ãŸã‚ã«ã€ã¾ãšã€éƒ¨åˆ†å¼ã‚’è©•ä¾¡ã™ã‚‹ã€‚
æœ€åˆã®éƒ¨åˆ†å¼ã€ã¤ã¾ã‚Š <tt>sum-of-squares</tt> ã¯ã€æ‰‹ç¶šãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚‹ã‚ˆã†ãªå€¤ã‚’æŒã£ã¦ã„ã‚‹ã€‚
(ã“ã®å€¤ãŒã©ã®ã‚ˆã†ã«ã—ã¦è¦‹ã¤ã‹ã‚‹ã®ã‹ã«æ³¨æ„ã›ã‚ˆã€‚E1ã®æœ€åˆã®ãƒ•ãƒ¬ãƒ¼ãƒ ã®ä¸­ã‚’ã¾ãšè¦‹ã‚‹ã¨ã€ãã“ã«ã¯ <tt>sum-of-squares</tt> ã«å¯¾ã™ã‚‹æŸç¸›ãŒå«ã¾ã‚Œãªã„ã€‚ãã“ã§ã€å¤–å´ã‚’å›²ã£ã¦ã„ã‚‹ç’°å¢ƒâ€”â€”ã¤ã¾ã‚Šå¤§åŸŸç’°å¢ƒâ€”â€”ã¸ã¨é€²ã¿ã€å›³<a href="#%_fig_3.4">3.4</a>ã«ç¤ºã•ã‚Œã¦ã„ã‚‹æŸç¸›ã‚’è¦‹ã¤ã‘ã‚‹ã®ã ã€‚)
æ®‹ã‚Šã®äºŒã¤ã®éƒ¨åˆ†å¼ã¯ã€<tt>+</tt> ãŠã‚ˆã³ <tt>*</tt> ã¨ã„ã†åŸå§‹çš„æ¼”ç®—ã‚’é©ç”¨ã—ã¦ã€<tt>(+ a 1)</tt> ãŠã‚ˆã³ <tt>(* a 2)</tt> ã¨ã„ã†äºŒã¤ã®ã‚³ãƒ³ãƒ“ãƒãƒ¼ã‚·ãƒ§ãƒ³ã‚’è©•ä¾¡ã—ã€6ãŠã‚ˆã³10ã‚’å¾—ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€ãã‚Œãã‚Œè©•ä¾¡ã•ã‚Œã‚‹ã€‚
</p>

<p class="orig" lang="en">
Now we apply the procedure object <tt>sum-of-squares</tt> to the
arguments 6 and 10.  This results in a new environment E2 in which the
formal parameters <tt>x</tt> and <tt>y</tt> are bound to the arguments.
Within E2 we evaluate the combination <tt>(+ (square x) (square y))</tt>.
This leads us to evaluate <tt>(square x)</tt>, where <tt>square</tt> is
found in the global frame and <tt>x</tt> is 6.  Once again, we set up a
new environment, E3, in which <tt>x</tt> is bound to 6, and within this
we evaluate the body of <tt>square</tt>, which is <tt>(* x x)</tt>.  Also as
part of applying <tt>sum-of-squares</tt>, we must evaluate the
subexpression <tt>(square y)</tt>, where <tt>y</tt> is 10.  This second call
to <tt>square</tt> creates another environment, E4, in which <tt>x</tt>, the
formal parameter of <tt>square</tt>, is bound to 10.  And within E4 we
must evaluate <tt>(* x x)</tt>.</p>

<p class="trans" lang="ja">
ã“ã“ã§ã€<tt>sum-of-squares</tt> ã¨ã„ã†æ‰‹ç¶šãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã€6ã¨10ã¨ã„ã†å®Ÿå¼•æ•°ã«é©ç”¨ã™ã‚‹ã€‚
ã“ã‚Œã¯ã€<tt>x</tt> ãŠã‚ˆã³ <tt>y</tt> ã¨ã„ã†ä»®å¼•æ•°ãŒã“ã‚Œã‚‰ã®å®Ÿå¼•æ•°ã«æŸç¸›ã•ã‚ŒãŸã€E2ã¨ã„ã†æ–°ãŸãªç’°å¢ƒã€ã¨ã„ã†çµæœã‚’ã‚‚ãŸã‚‰ã™ã€‚
E2ã®ä¸­ã§ã€<tt>(+ (square x) (square y))</tt> ã¨ã„ã†ã‚³ãƒ³ãƒ“ãƒãƒ¼ã‚·ãƒ§ãƒ³ã‚’è©•ä¾¡ã™ã‚‹ã€‚
ã“ã‚Œã«ã‚ˆã‚Šã€<tt>(square x)</tt> ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ã«ãªã‚‹ã®ã ãŒã€ã“ã“ã§ <tt>square</tt> ã¯å¤§åŸŸãƒ•ãƒ¬ãƒ¼ãƒ ã®ä¸­ã§è¦‹ã¤ã‹ã‚Šã€<tt>x</tt> ã¯6ã§ã‚ã‚‹ã€‚
<tt>x</tt> ãŒ6ã«æŸç¸›ã•ã‚Œã¦ã„ã‚‹ã‚ˆã†ãªæ–°ãŸãªç’°å¢ƒâ€”â€”ã™ãªã‚ã¡E3â€”â€”ã‚’å†ã³è¨­å®šã—ã€ã“ã®æ–°ãŸãªç’°å¢ƒã®ä¸­ã§ã€<tt>square</tt> ã®æœ¬ä½“â€”â€” <tt>(* x x)</tt> ã§ã‚ã‚‹â€”â€”ã‚’è©•ä¾¡ã™ã‚‹ã€‚
ã¾ãŸã€<tt>sum-of-squares</tt> ã‚’é©ç”¨ã™ã‚‹ã“ã¨ã®ä¸€éƒ¨ã¨ã—ã¦ã€<tt>(square y)</tt> ã¨ã„ã†éƒ¨åˆ†å¼ã‚‚è©•ä¾¡ã›ã­ã°ãªã‚‰ãšã€ã“ã“ã§ <tt>y</tt> ã¯10ã§ã‚ã‚‹ã€‚
<tt>square</tt> ã«å¯¾ã™ã‚‹ã€ã“ã®2ç•ªç›®ã®å‘¼ã³å‡ºã—ã¯ã€<tt>x</tt> â€”â€”ã¤ã¾ã‚Š <tt>square</tt> ã®ä»®å¼•æ•°â€”â€”ãŒ10ã«æŸç¸›ã•ã‚Œã¦ã„ã‚‹ã‚ˆã†ãªã€ã‚‚ã†ä¸€ã¤åˆ¥ã®ç’°å¢ƒâ€”â€”ã™ãªã‚ã¡E4â€”â€”ã‚’ä½œã‚Šå‡ºã™ã€‚
ãã—ã¦ã€E4ã®ä¸­ã§ã€<tt>(* x x)</tt> ã‚’è©•ä¾¡ã›ã­ã°ãªã‚‰ãªã„ã€‚
</p>

<p class="orig" lang="en">
The important point to observe is that each call to <tt>square</tt>
creates a new environment containing a binding for <tt>x</tt>.  We can
see here how the different frames serve to keep separate the different
local variables all named <tt>x</tt>.  Notice that each frame created by
<tt>square</tt> points to the global environment, since this is the
environment indicated by the <tt>square</tt> procedure object.</p>

<p class="trans" lang="ja">
è¦³å¯Ÿã™ã¹ãé‡è¦ãªç‚¹ã¯ã€<tt>square</tt> ã«å¯¾ã™ã‚‹ãã‚Œãã‚Œã®å‘¼ã³å‡ºã—ãŒã€<tt>x</tt> ã«ã¤ã„ã¦ã®æŸç¸›ã‚’å«ã‚€æ–°ãŸãªç’°å¢ƒã‚’ä½œæˆã™ã‚‹ã€ã¨ã„ã†ã“ã¨ã§ã‚ã‚‹ã€‚
ã©ã‚Œã‚‚çš† <tt>x</tt> ã¨åä»˜ã‘ã‚‰ã‚ŒãŸç•°ãªã‚‹å±€æ‰€å¤‰æ•°åŒå£«ã‚’åŒºåˆ¥ã—ãŸã¾ã¾ã§ã„ã‚‹ãŸã‚ã«ã€ç•°ãªã‚‹ãƒ•ãƒ¬ãƒ¼ãƒ ãŒã©ã®ã‚ˆã†ã«å½¹ç«‹ã£ã¦ã„ã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’ã€ã“ã“ã§è¦‹ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
<tt>square</tt> ã«ã‚ˆã£ã¦ä½œæˆã•ã‚Œã‚‹å„ãƒ•ãƒ¬ãƒ¼ãƒ ãŒã€å¤§åŸŸç’°å¢ƒã‚’æŒ‡ã™â€”â€”ãªãœãªã‚‰ã€ã“ã®å¤§åŸŸç’°å¢ƒãŒã€<tt>square</tt> ã®æ‰‹ç¶šãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚ˆã‚Šç¤ºã•ã‚Œã‚‹ç’°å¢ƒãªã®ã§â€”â€”ã¨ã„ã†ã“ã¨ã«æ³¨æ„ã›ã‚ˆã€‚
</p>

<p class="orig" lang="en">
After the subexpressions are evaluated, the results are
returned.  The values generated by the two calls to <tt>square</tt> are
added by <tt>sum-of-squares</tt>, and this result is returned by <tt>f</tt>.
Since our focus here is on the environment structures, we will not
dwell on how these returned values are passed from call to call;
however, this is also an important aspect of the evaluation process,
and we will return to it in detail in chapter 5.</p>

<p class="trans" lang="ja">
éƒ¨åˆ†å¼ãŒè©•ä¾¡ã•ã‚ŒãŸå¾Œã€çµæœãŒè¿”ã•ã‚Œã‚‹ã€‚
<tt>square</tt> ã«å¯¾ã™ã‚‹2å›ã®å‘¼ã³å‡ºã—ã«ã‚ˆã£ã¦ç”Ÿæˆã•ã‚ŒãŸå€¤ã¯ã€<tt>sum-of-squares</tt> ã«ã‚ˆã£ã¦è¶³ã•ã‚Œã€ã“ã®çµæœãŒ <tt>f</tt> ã«ã‚ˆã‚Šè¿”ã•ã‚Œã‚‹ã€‚
ã“ã“ã§ã®ç§ãŸã¡ã®ç„¦ç‚¹ã¯ç’°å¢ƒæ§‹é€ ã«ã‚ã‚‹ã®ã§ã€ã“ã‚Œã‚‰ã®è¿”ã•ã‚ŒãŸå€¤ãŒã©ã®ã‚ˆã†ã«ã—ã¦å‘¼ã³å‡ºã—ã‹ã‚‰å‘¼ã³å‡ºã—ã¸ã¨å—ã‘æ¸¡ã•ã‚Œã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’é•·ã€…ã¨è¿°ã¹ã‚‹ã®ã¯ã‚ˆãã†ã€‚
ã—ã‹ã—ã€ã“ã‚Œã‚‚è©•ä¾¡éç¨‹ã®é‡è¦ãªå´é¢ãªã®ã§ã‚ã‚Šã€ã“ã‚Œã«ã¤ã„ã¦è©³ã—ãã¯5ç« ã§ç«‹ã¡æˆ»ã‚‹ã“ã¨ã«ã—ã‚ˆã†ã€‚
</p>

<p class="orig" lang="en">
<a name="%_thm_3.9"></a>
<b>Exercise 3.9.</b>  <a name="%_idx_3088"></a><a name="%_idx_3090"></a><a name="%_idx_3092"></a>In section <a href="11_sec1_2.html#%_sec_1.2.1">1.2.1</a>
we used the substitution model to analyze two
procedures for computing factorials, a recursive version</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.9.</b> <a href="11_sec1_2.html#%_sec_1.2.1">1.2.1</a>ç¯€ã§ã¯ã€<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ãŠãã‹ãˆ</rt><rp>) </rp></ruby>ãƒ¢ãƒ‡ãƒ«ã‚’ä½¿ã£ã¦ã€éšä¹—ã‚’è¨ˆç®—ã™ã‚‹ãŸã‚ã®äºŒã¤ã®æ‰‹ç¶šãã‚’åˆ†æã—ãŸâ€”â€”ã¤ã¾ã‚Šã€ä»¥ä¸‹ã®ã‚ˆã†ãªå†å¸°ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¨ã€
</p>

<p class="lisp">(define (factorial n)
  (if (= n 1)
      1
      (* n (factorial (- n 1)))))
</p>

<p class="orig" lang="en">
and an iterative version</p>

<p class="trans" lang="ja">
ä»¥ä¸‹ã®ã‚ˆã†ãªåå¾©ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’åˆ†æã—ãŸã€‚
</p>

<p class="lisp">(define (factorial n)
  (fact-iter 1 1 n))
(define (fact-iter product counter max-count)
  (if (&gt; counter max-count)
      product
      (fact-iter (* counter product)
                 (+ counter 1)
                 max-count)))
</p>

<p class="orig" lang="en">
Show the environment structures created by evaluating <tt>(factorial 6)</tt>
using each version of the <tt>factorial</tt> procedure.<a name="call_footnote_Temp_345" href="#footnote_Temp_345"><sup><small>14</small></sup></a></p>

<p class="trans" lang="ja">
<tt>(factorial 6)</tt> ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šä½œæˆã•ã‚Œã‚‹ç’°å¢ƒæ§‹é€ ã‚’ã€<tt>factorial</tt> ã®æ‰‹ç¶šãã®ãã‚Œãã‚Œã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ä½¿ã£ã¦ã€ç¤ºã›<a href="#footnote_Temp_345"><sup><small>14</small></sup></a>ã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>


<a name="%_sec_3.2.3"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_3.2.3">3.2.3  Frames as the Repository of Local State</a></h3>
<h3 class="trans" lang="ja">3.2.3 å±€æ‰€çŠ¶æ…‹ã®ç½®ãå ´ã¨ã—ã¦ã®ãƒ•ãƒ¬ãƒ¼ãƒ </h3>

<p class="orig" lang="en">
<a name="%_idx_3098"></a><a name="%_idx_3100"></a><a name="%_idx_3102"></a>
<a name="%_idx_3104"></a>We can turn to the environment model to see how procedures and
assignment can be used to represent objects with local state.  As an
example, consider the ``withdrawal processor'' from
section <a href="20_sec3_1.html#%_sec_3.1.1">3.1.1</a> created by calling the
procedure</p>

<p class="trans" lang="ja">
å±€æ‰€çŠ¶æ…‹ã‚’æœ‰ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¡¨ç¾ã™ã‚‹ãŸã‚ã«ã€ã©ã®ã‚ˆã†ã«ã—ã¦æ‰‹ç¶šãã¨<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã‚’ä½¿ã†ã“ã¨ãŒã§ãã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’è¦‹ã‚‹ãŸã‚ã«ã€ç’°å¢ƒãƒ¢ãƒ‡ãƒ«ã«ç›®ã‚’å‘ã‘ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
ä¾‹ã¨ã—ã¦ã€ä»¥ä¸‹ã®æ‰‹ç¶šãã‚’å‘¼ã³å‡ºã™ã“ã¨ã§ä½œæˆã•ã‚Œã‚‹ã€<a href="20_sec3_1.html#%_sec_3.1.1">3.1.1</a>ç¯€ã§ã®ã€Œå¼•ãå‡ºã—å‡¦ç†å™¨ã€ã‚’è€ƒãˆã‚ˆã†ã€‚
</p>

<p class="lisp">(define (make-withdraw balance)
  (lambda (amount)
    (if (&gt;= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        &quot;Insufficient funds&quot;)))
</p>

<p class="orig" lang="en">
Let us describe the evaluation of</p>

<p class="trans" lang="ja">
ä»¥ä¸‹ã®ã‚‚ã®ã®è©•ä¾¡ã«ã¤ã„ã¦ã€èª¬æ˜ã—ã‚ˆã†ã€‚
</p>

<p class="lisp">(define W1 (make-withdraw 100))
</p>

<p class="orig" lang="en">
followed by</p>

<p class="trans" lang="ja">
ãŸã ã—ã“ã‚Œã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ç¶šãã‚‚ã®ã¨ã™ã‚‹ã€‚
</p>

<p class="lisp">(W1 50)
<i>50</i>
</p>

<p class="orig" lang="en">
Figure <a href="#%_fig_3.6">3.6</a> shows the result of defining the <tt>make-withdraw</tt> procedure in the global environment.  This produces a
procedure object that contains a pointer to the global environment.
So far, this is no different from the examples we have already seen,
except that the body of the procedure is itself a <tt>lambda</tt>
expression.</p>

<p class="trans" lang="ja">
å›³<a href="#%_fig_3.6">3.6</a>ã¯ã€å¤§åŸŸç’°å¢ƒã§ <tt>make-withdraw</tt> ã®æ‰‹ç¶šãã‚’å®šç¾©ã—ãŸçµæœã‚’ç¤ºã™ã€‚
ã“ã®æ‰‹ç¶šãã¯ã€å¤§åŸŸç’°å¢ƒã¸ã®ãƒã‚¤ãƒ³ã‚¿ã‚’å«ã‚€æ‰‹ç¶šãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚‹ã€‚
ã“ã“ã¾ã§ã®ã¨ã“ã‚ã§ã¯ã€ã“ã‚Œã¯ã€æ—¢ã«è¦‹ã¦ããŸä¾‹ã¨ä½•ã®é•ã„ã‚‚ãªã„â€”â€”æ‰‹ç¶šãã®æœ¬ä½“ãŒã€ãã‚Œè‡ªä½“ã€<tt>lambda</tt> å¼ã§ã‚ã‚‹ã€ã¨ã„ã†ç‚¹ã‚’é™¤ã„ã¦ã€ã§ã‚ã‚‹ãŒã€‚
</p>

<a name="%_fig_3.6"></a>
<figure>
<img src="ch3-Z-G-7.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.6:</b>  Result of defining <tt>make-withdraw</tt>
in the global environment.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³3.6:</b>å¤§åŸŸç’°å¢ƒã§ <tt>make-withdraw</tt> ã‚’å®šç¾©ã—ãŸçµæœ</figcaption>
</figure>

<p class="orig" lang="en">
The interesting part of the computation happens when we apply the
procedure <tt>make-withdraw</tt> to an argument:</p>

<p class="trans" lang="ja">
è¨ˆç®—ã®èˆˆå‘³æ·±ã„éƒ¨åˆ†ã¯ã€<tt>make-withdraw</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’ã€ä»¥ä¸‹ã®ã‚ˆã†ã«å®Ÿå¼•æ•°ã«é©ç”¨ã™ã‚‹ã¨ãã«èµ·ã“ã‚‹ã€‚
</p>

<p class="lisp">(define W1 (make-withdraw 100))
</p>

<p class="orig" lang="en">
We begin, as usual, by setting up an environment E1 in which the
formal parameter <tt>balance</tt> is bound to the argument 100.  Within
this environment, we evaluate the body of <tt>make-withdraw</tt>, namely
the <tt>lambda</tt> expression.  This constructs a new procedure object,
whose code is as specified by the <tt>lambda</tt> and whose environment
is E1, the environment in which the <tt>lambda</tt> was evaluated to
produce the procedure.  The resulting procedure object is the value
returned by the call to <tt>make-withdraw</tt>.  This is bound to <tt>W1</tt> in the global environment, since the <tt>define</tt> itself is being
evaluated in the global environment.  Figure <a href="#%_fig_3.7">3.7</a> shows the
resulting environment structure.</p>

<p class="trans" lang="ja">
ã„ã¤ã‚‚ã©ãŠã‚Šã€<tt>balance</tt> ã¨ã„ã†ä»®å¼•æ•°ãŒ100ã¨ã„ã†å®Ÿå¼•æ•°ã«æŸç¸›ã•ã‚Œã¦ã„ã‚‹ã‚ˆã†ãªç’°å¢ƒE1ã‚’è¨­å®šã™ã‚‹ã“ã¨ã‹ã‚‰ã€å§‹ã‚ã‚‹ã€‚
ã“ã®ç’°å¢ƒã®ä¸­ã§ã€<tt>make-withdraw</tt> ã®æœ¬ä½“â€”â€”ã¤ã¾ã‚Š <tt>lambda</tt> å¼â€”â€”ã‚’è©•ä¾¡ã™ã‚‹ã€‚
ã“ã‚Œã«ã‚ˆã‚Šæ–°ãŸãªæ‰‹ç¶šãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒæ§‹ç¯‰ã•ã‚Œã‚‹ã‚ã‘ã ãŒã€ãã®æ–°ãŸãªæ‰‹ç¶šãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚³ãƒ¼ãƒ‰ã¯ã€<tt>lambda</tt> ã«ã‚ˆã‚ŠæŒ‡å®šã•ã‚Œã‚‹ã¨ãŠã‚Šã§ã‚ã‚Šã€ãã®æ–°ãŸãªæ‰‹ç¶šãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç’°å¢ƒã¯E1â€”â€”ã™ãªã‚ã¡ã€ãã®ä¸­ã§ <tt>lambda</tt> ãŒè©•ä¾¡ã•ã‚Œã¦ã€ã“ã®æ‰‹ç¶šãã‚’ç”Ÿã¿å‡ºã™ã“ã¨ã«ãªã£ãŸç’°å¢ƒâ€”â€”ã§ã‚ã‚‹ã€‚
çµæœã¨ã—ã¦ç”Ÿã˜ã‚‹æ‰‹ç¶šãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€<tt>make-withdraw</tt> ã«å¯¾ã™ã‚‹å‘¼ã³å‡ºã—ã«ã‚ˆã£ã¦è¿”ã•ã‚Œã‚‹å€¤ã§ã‚ã‚‹ã€‚
ã“ã‚Œã¯ã€å¤§åŸŸç’°å¢ƒã«ãŠã„ã¦ <tt>W1</tt> ã«æŸç¸›ã•ã‚Œã‚‹â€”â€”ãªãœãªã‚‰ã€<tt>define</tt> è‡ªä½“ãŒå¤§åŸŸç’°å¢ƒã®ä¸­ã§è©•ä¾¡ã•ã‚Œã¦ã„ã‚‹ã‹ã‚‰ã§ã‚ã‚‹ã€‚
å›³<a href="#%_fig_3.7">3.7</a>ã¯ã€çµæœã¨ã—ã¦ç”Ÿã˜ã‚‹ç’°å¢ƒæ§‹é€ ã‚’ç¤ºã—ã¦ã„ã‚‹ã€‚
</p>


<a name="%_fig_3.7"></a>
<figure>
<img src="ch3-Z-G-8.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.7:</b>  Result of evaluating <tt>(define W1 (make-withdraw 100))</tt>.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³3.7:</b><tt>(define W1 (make-withdraw 100))</tt> ã‚’è©•ä¾¡ã—ãŸçµæœ</figcaption>
</figure>


<p class="orig" lang="en">
Now we can analyze what happens when <tt>W1</tt> is applied to a
argument:</p>

<p class="trans" lang="ja">
ã“ã‚Œã§ã€<tt>W1</tt> ãŒå®Ÿå¼•æ•°ã«é©ç”¨ã•ã‚Œã‚‹ã¨ãã«èµ·ãã‚‹ã“ã¨ã‚’åˆ†æã§ãã‚‹ã€‚
</p>

<p class="lisp">(W1 50)
<i>50</i>
</p>


<p class="orig" lang="en">
We begin by constructing a frame in which <tt>amount</tt>, the formal
parameter of <tt>W1</tt>, is bound to the argument 50.  The crucial point
to observe is that this frame has as its enclosing environment not the
global environment, but rather the environment E1, because this is the
environment that is specified by the <tt>W1</tt> procedure object.
Within this new environment, we evaluate the body of the procedure:</p>

<p class="trans" lang="ja">
<tt>amount</tt> â€”â€”ã¤ã¾ã‚Š <tt>W1</tt> ã®ä»®å¼•æ•°â€”â€”ãŒã€50ã¨ã„ã†å®Ÿå¼•æ•°ã«æŸç¸›ã•ã‚Œã¦ã„ã‚‹ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’æ§‹ç¯‰ã™ã‚‹ã“ã¨ã‹ã‚‰å§‹ã‚ã‚‹ã€‚
è¦³å¯Ÿã™ã¹ãã€æ±ºå®šçš„ã«é‡è¦ãªç‚¹ã¯ã€ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãŒã€å¤§åŸŸç’°å¢ƒã§ã¯ãªãã‚€ã—ã‚ç’°å¢ƒE1ã‚’ã€è‡ªèº«ã®å¤–å´ã‚’å›²ã£ã¦ã„ã‚‹ç’°å¢ƒã¨ã—ã¦æœ‰ã—ã¦ã„ã‚‹â€”â€”ãªãœãªã‚‰ã€ã“ã®ç’°å¢ƒE1ãŒã€<tt>W1</tt> ã®æ‰‹ç¶šãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚ˆã‚ŠæŒ‡å®šã•ã‚Œã¦ã„ã‚‹ç’°å¢ƒã ã‹ã‚‰â€”â€”ã¨ã„ã†ç‚¹ã ã€‚
ã“ã®æ–°ãŸãªç’°å¢ƒã®ä¸­ã§ã€ä»¥ä¸‹ã®ã‚ˆã†ãªæ‰‹ç¶šãæœ¬ä½“ã‚’è©•ä¾¡ã™ã‚‹ã€‚
</p>

<p class="lisp">(if (&gt;= balance amount)
    (begin (set! balance (- balance amount))
           balance)
    &quot;Insufficient funds&quot;)
</p>

<p class="orig" lang="en">
The resulting environment structure is shown in
figure <a href="#%_fig_3.8">3.8</a>.  The expression being evaluated references
both <tt>amount</tt> and <tt>balance</tt>.  <tt>Amount</tt> will be found in
the first frame in the environment, while <tt>balance</tt> will be found
by following the enclosing-environment pointer to E1.</p>

<p class="trans" lang="ja">
çµæœã¨ã—ã¦ç”Ÿã˜ã‚‹ç’°å¢ƒæ§‹é€ ã‚’å›³<a href="#%_fig_3.8">3.8</a>ã«ç¤ºã™ã€‚
ã„ã¾è©•ä¾¡ã•ã‚Œã¦ã„ã‚‹å¼ã¯ã€<tt>amount</tt> ã¨ <tt>balance</tt> ã®åŒæ–¹ã‚’å‚ç…§ã™ã‚‹ã€‚
<tt>amount</tt> ã¯ã€ç’°å¢ƒå†…ã®æœ€åˆã®ãƒ•ãƒ¬ãƒ¼ãƒ ã§è¦‹ã¤ã‹ã‚‹ã ã‚ã†ãŒã€<tt>balance</tt> ã¯ã€å¤–å´ã‚’å›²ã£ã¦ã„ã‚‹ç’°å¢ƒã«é–¢ã™ã‚‹ã€E1ã‚’æŒ‡ã—ã¦ã„ã‚‹ãƒã‚¤ãƒ³ã‚¿ã‚’ãŸã©ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€è¦‹ã¤ã‹ã‚‹ã ã‚ã†ã€‚
</p>


<a name="%_fig_3.8"></a>
<figure>
<img src="ch3-Z-G-9.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.8:</b>  Environments created by applying the procedure
object <tt>W1</tt>.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³3.8:</b> <tt>W1</tt> ã¨ã„ã†æ‰‹ç¶šãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’é©ç”¨ã™ã‚‹ã“ã¨ã§ä½œæˆã•ã‚ŒãŸç’°å¢ƒ</figcaption>
</figure>

<p class="orig" lang="en">
When the <tt>set!</tt> is executed, the binding of <tt>balance</tt> in E1 is changed.  At the completion of the call to <tt>W1</tt>,
<tt>balance</tt> is 50, and the frame that contains <tt>balance</tt>
is still pointed to by the procedure object <tt>W1</tt>.  The frame
that binds <tt>amount</tt>
(in which we executed the code that changed <tt>balance</tt>) is no longer
relevant, since the procedure call that constructed it has terminated,
and there are no pointers to that frame from other parts of the
environment.  The next time <tt>W1</tt> is called, this will build a new
frame that binds <tt>amount</tt> and whose enclosing environment is E1.
We see that E1 serves as the ``place'' that holds the local state
variable for the procedure object <tt>W1</tt>.  Figure <a href="#%_fig_3.9">3.9</a>
shows the situation after the call to <tt>W1</tt>.</p>

<p class="trans" lang="ja">
<tt>set!</tt> ãŒå®Ÿè¡Œã•ã‚Œã‚‹ã¨ãã€E1ã«ãŠã‘ã‚‹ <tt>balance</tt> ã®æŸç¸›ãŒå¤‰æ›´ã•ã‚Œã‚‹ã€‚
<tt>W1</tt> ã«å¯¾ã™ã‚‹å‘¼ã³å‡ºã—ã®å®Œäº†æ™‚ã«ãŠã„ã¦ã€<tt>balance</tt> ã¯50ã§ã‚ã‚Šã€<tt>balance</tt> ã‚’å«ã‚€ãƒ•ãƒ¬ãƒ¼ãƒ ã¯ã€<tt>W1</tt> ã¨ã„ã†æ‰‹ç¶šãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚ˆã‚Šã€ä¾ç„¶ã¨ã—ã¦æŒ‡ã•ã‚ŒãŸã¾ã¾ã§ã‚ã‚‹ã€‚
<tt>amount</tt> ã‚’æŸç¸›ã™ã‚‹ãƒ•ãƒ¬ãƒ¼ãƒ  (ãã“ã«ãŠã„ã¦ã€ç§ãŸã¡ã¯ã€<tt>balance</tt> ã‚’å¤‰æ›´ã—ãŸã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã—ãŸã®ã§ã‚ã£ãŸ) ã¯ã€ã‚‚ã¯ã‚„ç„¡é–¢ä¿‚ã§ã‚ã‚‹â€”â€”ã¨ã„ã†ã®ã‚‚ã€ãã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’æ§‹ç¯‰ã—ãŸæ‰‹ç¶šãå‘¼ã³å‡ºã—ã¯ã‚‚ã†çµ‚äº†ã—ãŸã‹ã‚‰ã§ã‚ã‚Šã€ç’°å¢ƒå†…ã®ä»–ã®éƒ¨åˆ†ã‹ã‚‰ãã®ãƒ•ãƒ¬ãƒ¼ãƒ ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã¯å­˜åœ¨ã—ãªã„ã‹ã‚‰ã§ã‚ã‚‹ã€‚
<tt>W1</tt> ãŒæ¬¡ã«å‘¼ã°ã‚Œã‚‹ã¨ãã€ã“ã®å‘¼ã³å‡ºã—ã¯ã€<tt>amount</tt>ã‚’æŸç¸›ã—ã€ã‹ã¤ã€å¤–å´ã‚’å›²ã£ã¦ã„ã‚‹ç’°å¢ƒãŒE1ã§ã‚ã‚‹ã‚ˆã†ãªã€æ–°ãŸãªãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ç¯‰ãã ã‚ã†ã€‚
<tt>W1</tt> ã¨ã„ã†æ‰‹ç¶šãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å±€æ‰€çŠ¶æ…‹ã‚’ä¿æŒã™ã‚‹ã€Œå ´æ‰€ã€ã¨ã—ã¦ã€E1ãŒæ©Ÿèƒ½ã—ã¦ã„ã‚‹ã€ã¨ã„ã†ã“ã¨ãŒåˆ†ã‹ã‚‹ã€‚
å›³<a href="#%_fig_3.9">3.9</a>ã¯ã€<tt>W1</tt> ã«å¯¾ã™ã‚‹å‘¼ã³å‡ºã—ã®å¾Œã®çŠ¶æ³ã‚’ç¤ºã™ã€‚
</p>


<a name="%_fig_3.9"></a>
<figure>
<img src="ch3-Z-G-10.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.9:</b>  Environments after the call to <tt>W1</tt>.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³3.9:</b> <tt>W1</tt> ã«å¯¾ã™ã‚‹å‘¼ã³å‡ºã—ã®å¾Œã®ç’°å¢ƒ</figcaption>
</figure>

<p class="orig" lang="en">
Observe what happens when we create a second ``withdraw'' object by
making another call to <tt>make-withdraw</tt>:
</p>

<p class="trans" lang="ja">
<tt>make-withdraw</tt> ã«å¯¾ã™ã‚‹åˆ¥ã®å‘¼ã³å‡ºã—ã‚’è¡Œã†ã“ã¨ã«ã‚ˆã£ã¦ã€ç¬¬äºŒã®ã€Œå¼•ãå‡ºã—ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã™ã‚‹ã¨ãã«ã€ä½•ãŒèµ·ã“ã‚‹ã®ã‹ã€è¦³å¯Ÿã›ã‚ˆã€‚
</p>

<p class="lisp">(define W2 (make-withdraw 100))
</p>

<p class="orig" lang="en">
This produces the environment structure of figure <a href="#%_fig_3.10">3.10</a>, which shows
that <tt>W2</tt> is a procedure object, that is, a pair with some code
and an environment.  The environment E2 for <tt>W2</tt> was created by
the call to <tt>make-withdraw</tt>.  It contains a frame with its own
local binding for <tt>balance</tt>.  On the other hand, <tt>W1</tt> and <tt>W2</tt> have the same code: the code specified by the <tt>lambda</tt>
expression in the body of <tt>make-withdraw</tt>.<a name="call_footnote_Temp_346" href="#footnote_Temp_346"><sup><small>15</small></sup></a> We see here why <tt>W1</tt> and <tt>W2</tt>
behave as independent objects.  Calls to <tt>W1</tt> reference the state
variable <tt>balance</tt> stored in E1, whereas calls to <tt>W2</tt>
reference the <tt>balance</tt> stored in E2. Thus, changes to the local
state of one object do not affect the other object.</p>

<p class="trans" lang="ja">
ã“ã‚Œã¯ã€å›³<a href="#%_fig_3.10">3.10</a>ã®ç’°å¢ƒæ§‹é€ ã‚’ä½œã‚Šå‡ºã—ã€ãã®ç’°å¢ƒæ§‹é€ ã¯ã€<tt>W2</tt> ãŒæ‰‹ç¶šãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆâ€”â€”ã™ãªã‚ã¡ã€ä½•ã‚‰ã‹ã®ã‚³ãƒ¼ãƒ‰ã¨ã€ç’°å¢ƒã¨ã®å¯¾â€”â€”ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã™ã€‚
<tt>W2</tt> ç”¨ã®ç’°å¢ƒE2ã¯ã€<tt>make-withdraw</tt> ã«å¯¾ã™ã‚‹å‘¼ã³å‡ºã—ã«ã‚ˆã‚Šä½œæˆã•ã‚ŒãŸã€‚
ã“ã‚Œã¯ã€<tt>balance</tt> ã«å¯¾ã™ã‚‹è‡ªåˆ†è‡ªèº«ã®å±€æ‰€çš„æŸç¸›ã‚’æŒã£ãŸãƒ•ãƒ¬ãƒ¼ãƒ ã‚’å«ã‚€ã€‚
ä»–æ–¹ã€<tt>W1</tt> ã¨ <tt>W2</tt> ã¯åŒã˜ã‚³ãƒ¼ãƒ‰ã‚’æœ‰ã™ã‚‹â€”â€”ã¤ã¾ã‚Šã€<tt>make-withdraw</tt> ã®æœ¬ä½“ã®ä¸­ã® <tt>lambda</tt> å¼ã«ã‚ˆã‚Šè¦å®šã•ã‚Œã‚‹ã‚³ãƒ¼ãƒ‰ã§ã‚ã‚‹<a href="#footnote_Temp_346"><sup><small>15</small></sup></a>ã€‚
<tt>W1</tt> ã¨ <tt>W2</tt> ãŒã€ãªãœç‹¬ç«‹ã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦æŒ¯ã‚‹èˆã†ã®ã‹ã€ã¨ã„ã†ã“ã¨ãŒã€ã“ã“ã§åˆ†ã‹ã‚‹ã€‚
<tt>W1</tt> ã«å¯¾ã™ã‚‹å‘¼ã³å‡ºã—ã¯ã€E1ã«æ ¼ç´ã•ã‚ŒãŸ <tt>balance</tt> ã¨ã„ã†çŠ¶æ…‹å¤‰æ•°ã‚’å‚ç…§ã™ã‚‹ãŒã€<tt>W2</tt> ã«å¯¾ã™ã‚‹å‘¼ã³å‡ºã—ã¯ã€E2ã«æ ¼ç´ã•ã‚ŒãŸ <tt>balance</tt> ã‚’å‚ç…§ã™ã‚‹ã®ã ã€‚
ã‚ˆã£ã¦ã€ä¸€æ–¹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å±€æ‰€çŠ¶æ…‹ã«å¯¾ã™ã‚‹å¤‰æ›´ã¯ã€ä»–æ–¹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯å½±éŸ¿ã—ãªã„ã€‚
</p>


<a name="%_fig_3.10"></a>
<figure>
<img src="ch3-Z-G-11.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.10:</b>  Using <tt>(define W2 (make-withdraw 100))</tt>
to create a second object.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³3.10:</b> ç¬¬äºŒã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã™ã‚‹ãŸã‚ã« <tt>(define W2 (make-withdraw 100))</tt> ã‚’ä½¿ã†</figcaption>
</figure>

<p class="orig" lang="en"><a name="%_thm_3.10"></a>
<b>Exercise 3.10.</b>  In the <tt>make-withdraw</tt> procedure, the local variable <tt>balance</tt>
is created as a parameter of <tt>make-withdraw</tt>.  We could also
create the local state variable explicitly, using <tt>let</tt>, as
follows:
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.10.</b> <tt>make-withdraw</tt> ã®æ‰‹ç¶šãã®ä¸­ã§ã€<tt>balance</tt> ã¨ã„ã†å±€æ‰€å¤‰æ•°ã¯ã€<tt>make-withdraw</tt> ã®ä»®å¼•æ•°ã¨ã—ã¦ä½œæˆã•ã‚Œã‚‹ã€‚
ä»¥ä¸‹ã®ã‚ˆã†ã« <tt>let</tt> ã‚’ç”¨ã„ã¦ã€å±€æ‰€çŠ¶æ…‹å¤‰æ•°ã‚’æ˜ç¤ºçš„ã«ä½œæˆã™ã‚‹ã“ã¨ã‚‚ã§ããŸã ã‚ã†ã€‚
</p>

<p class="lisp"><a name="%_idx_3106"></a>(define (make-withdraw initial-amount)
  (let ((balance initial-amount))
    (lambda (amount)
      (if (&gt;= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          &quot;Insufficient funds&quot;))))
</p>

<p class="orig" lang="en">
<a name="%_idx_3108"></a><a name="%_idx_3110"></a>Recall from section <a href="12_sec1_3.html#%_sec_1.3.2">1.3.2</a> that <tt>let</tt> is simply
syntactic sugar for a procedure call:</p>

<p class="trans" lang="ja">
<tt>let</tt> ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ã€æ‰‹ç¶šãå‘¼ã³å‡ºã—ã«å¯¾ã™ã‚‹ç³–è¡£æ§‹æ–‡ã«éããªã„ã®ã ã€ã¨ã„ã†ã“ã¨ã‚’ã€<a href="12_sec1_3.html#%_sec_1.3.2">1.3.2</a>ç¯€ã‹ã‚‰æ€ã„å‡ºãã†ã€‚
ã™ãªã‚ã¡ã€
</p>

<p class="lisp">(let ((&lt;<em>var</em>&gt; &lt;<em>exp</em>&gt;)) &lt;<em>body</em>&gt;)
</p>

<p class="orig" lang="en">
is interpreted as an alternate syntax for</p>

<p class="trans" lang="ja">
ã¯ã€ä»¥ä¸‹ã®ã‚‚ã®ã«å¯¾ã™ã‚‹ä»£æ›¿çš„æ§‹æ–‡ã¨ã—ã¦è§£é‡ˆã•ã‚Œã‚‹ã€‚
</p>

<p class="lisp">((lambda (&lt;<em>var</em>&gt;) &lt;<em>body</em>&gt;) &lt;<em>exp</em>&gt;)
</p>

<p class="orig" lang="en">
Use the environment model to analyze this alternate
version of <tt>make-withdraw</tt>, drawing figures like the ones above to
illustrate the interactions</p>

<p class="trans" lang="ja">
ç’°å¢ƒãƒ¢ãƒ‡ãƒ«ã‚’ä½¿ã£ã¦ã€<tt>make-withdraw</tt> ã«ã¤ã„ã¦ã®ã“ã®ä»£æ›¿ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’åˆ†æã›ã‚ˆâ€”â€”ãã®éš›ã€ç›¸äº’ä½œç”¨ã‚’ç¤ºã™ãŸã‚ã«ã€ä¸Šè¨˜ã®ã‚ˆã†ãªå›³ã‚’æãã“ã¨ã€‚
</p>

<p class="lisp">(define W1 (make-withdraw 100))

(W1 50)

(define W2 (make-withdraw 100))
</p>

<p class="orig" lang="en">
Show that the two versions of <tt>make-withdraw</tt> create objects with
the same behavior.  How do the environment structures differ for the two
versions?</p>

<p class="trans" lang="ja">
<tt>make-withdraw</tt> ã®äºŒã¤ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒã€åŒã˜æŒ¯ã‚‹èˆã„ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã™ã‚‹ã€ã¨ã„ã†ã“ã¨ã‚’ç¤ºã›ã€‚
äºŒã¤ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«å¯¾ã—ã¦ã€ç’°å¢ƒæ§‹é€ ã¯ã©ã®ã‚ˆã†ã«ç•°ãªã£ã¦ã„ã‚‹ã ã‚ã†ã‹?
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_3.2.4"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_3.2.4">3.2.4  Internal Definitions</a></h3>
<h3 class="trans" lang="ja">3.2.4 å†…éƒ¨å®šç¾©</h3>

<p class="orig" lang="en">
<a name="%_idx_3112"></a><a name="%_idx_3114"></a><a name="%_idx_3116"></a>
Section <a href="10_sec1_1.html#%_sec_1.1.8">1.1.8</a> introduced the idea that procedures can have internal
definitions, thus leading to a block structure as in the
following procedure to compute square roots:</p>

<p class="trans" lang="ja">
<a href="10_sec1_1.html#%_sec_1.1.8">1.1.8</a> ç¯€ã§ã¯ã€æ‰‹ç¶šããŒå†…éƒ¨å®šç¾©ã‚’æŒã¦ã‚‹ã€ã¨ã„ã†è€ƒãˆã‚’å°å…¥ã—ãŸã®ã§ã€äºŒä¹—æ ¹ã‚’è¨ˆç®—ã™ã‚‹ãŸã‚ã®ä»¥ä¸‹ã®æ‰‹ç¶šãã«è¦‹ã‚‰ã‚Œã‚‹ã‚ˆã†ãªãƒ–ãƒ­ãƒƒã‚¯æ§‹é€ ã«ã¤ãªãŒã£ãŸã€‚
</p>

<p class="lisp"><a name="%_idx_3118"></a>(define (sqrt x)
  (define (good-enough? guess)
    (&lt; (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))
</p>


<p class="orig" lang="en">
Now we can use the environment model to see why these internal
definitions behave as desired.  Figure <a href="#%_fig_3.11">3.11</a> shows the point in the
evaluation of the expression <tt>(sqrt 2)</tt> where the internal
procedure <tt>good-enough?</tt> has been called for the first time with
<tt>guess</tt> equal to 1.</p>

<p class="trans" lang="ja">
ã•ã¦ã“ã“ã§ã€ç§ãŸã¡ã¯ã€ãªãœã“ã‚Œã‚‰ã®å†…éƒ¨å®šç¾©ãŒæœ›ã¿ã©ãŠã‚Šã«æŒ¯ã‚‹èˆã†ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’è¦‹ã‚‹ãŸã‚ã«ã€ç’°å¢ƒãƒ¢ãƒ‡ãƒ«ã‚’ä½¿ã†ã“ã¨ãŒã§ãã‚‹ã€‚
å›³<a href="#%_fig_3.11">3.11</a>ã¯ã€<tt>(sqrt 2)</tt> ã¨ã„ã†å¼ã®è©•ä¾¡ã«ãŠã„ã¦ã€<tt>good-enough?</tt> ã¨ã„ã†å†…éƒ¨æ‰‹ç¶šããŒã€<tt>guess</tt> ãŒ1ã«ç­‰ã—ã„çŠ¶æ…‹ã§ã€ä¸€åº¦ç›®ã«å‘¼ã³å‡ºã•ã‚ŒãŸæ™‚ç‚¹ã‚’ç¤ºã™ã€‚</p>


<a name="%_fig_3.11"></a>
<figure>
<img src="ch3-Z-G-12.gif" border="0">
<figcaption class="orig" lang="en"> <b>Figure 3.11:</b>  <tt>Sqrt</tt> procedure with internal definitions.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³3.11:</b> å†…éƒ¨å®šç¾©ã®ã‚ã‚‹ <tt>sqrt</tt> ã®æ‰‹ç¶šã</figcaption>
</figure>


<p class="orig" lang="en">
Observe the structure of the environment.  <tt>Sqrt</tt> is a symbol in
the global environment that is bound to a procedure object whose
associated environment is the global environment.  When <tt>sqrt</tt> was
called, a new environment E1 was formed, subordinate to the global
environment, in which the parameter <tt>x</tt> is bound to 2.  The body
of <tt>sqrt</tt> was then evaluated in E1.  Since the first expression in
the body of <tt>sqrt</tt> is</p>

<p class="trans" lang="ja">
ç’°å¢ƒã®æ§‹é€ ã‚’è¦³å¯Ÿã›ã‚ˆã€‚
<tt>sqrt</tt> ã¯ã€è‡ªåˆ†ã«å¯¾å¿œã¥ã‘ã‚‰ã‚ŒãŸç’°å¢ƒãŒå¤§åŸŸç’°å¢ƒã§ã‚ã‚‹ã‚ˆã†ãªæ‰‹ç¶šãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«æŸç¸›ã•ã‚Œã¦ã„ã‚‹ã€å¤§åŸŸç’°å¢ƒå†…ã®è¨˜å·ã§ã‚ã‚‹ã€‚
<tt>sqrt</tt> ãŒå‘¼ã°ã‚ŒãŸã¨ãã€E1ã¨ã„ã†æ–°ãŸãªç’°å¢ƒâ€”â€”å¤§åŸŸç’°å¢ƒã®ä¸‹ä½ã«ã‚ã‚Šã€ãã“ã§ã¯ <tt>x</tt> ã¨ã„ã†ä»®å¼•æ•°ãŒ2ã«æŸç¸›ã•ã‚Œã¦ã„ã‚‹â€”â€”ãŒå½¢æˆã•ã‚ŒãŸã€‚
<tt>sqrt</tt> ã®æœ¬ä½“ã¯ã€ãã“ã§ã€E1ã«ãŠã„ã¦è©•ä¾¡ã•ã‚ŒãŸã€‚
<tt>sqrt</tt> ã®æœ¬ä½“ã«ãŠã‘ã‚‹æœ€åˆã®å¼ã¯ã€
</p>


<p class="lisp">(define (good-enough? guess)
  (&lt; (abs (- (square guess) x)) 0.001))
</p>

<p class="orig" lang="en">
evaluating this expression defined the procedure <tt>good-enough?</tt>
in the environment E1.  To be more precise, the symbol <tt>good-enough?</tt> was added to the first frame of E1, bound to a
procedure object whose associated environment is E1.  Similarly, <tt>improve</tt> and <tt>sqrt-iter</tt> were defined as procedures in E1.  For
conciseness, figure <a href="#%_fig_3.11">3.11</a> shows only the procedure
object for <tt>good-enough?</tt>.</p>

<p class="trans" lang="ja">
ã§ã‚ã‚‹ãŸã‚ã€ã“ã®å¼ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ã§ã€E1ã¨ã„ã†ç’°å¢ƒå†…ã«ãŠã‘ã‚‹ <tt>good-enough?</tt> ã¨ã„ã†æ‰‹ç¶šããŒå®šç¾©ã•ã‚ŒãŸã€‚
ã‚ˆã‚Šæ­£ç¢ºã«ã¯ã€<tt>good-enough?</tt> ã¨ã„ã†è¨˜å·ãŒã€E1ã®æœ€åˆã®ãƒ•ãƒ¬ãƒ¼ãƒ ã«è¿½åŠ ã•ã‚Œã€è‡ªåˆ†ã«å¯¾å¿œã¥ã‘ã‚‰ã‚ŒãŸç’°å¢ƒãŒE1ã§ã‚ã‚‹ã‚ˆã†ãªæ‰‹ç¶šãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã€æŸç¸›ã•ã‚ŒãŸã€‚
åŒæ§˜ã«ã€<tt>improve</tt> ã¨ <tt>sqrt-iter</tt> ãŒã€E1ã®ä¸­ã®æ‰‹ç¶šãã¨ã—ã¦å®šç¾©ã•ã‚ŒãŸã€‚
ç°¡æ½”ã•ã®ãŸã‚ã«ã€å›³<a href="#%_fig_3.11">3.11</a>ã§ã¯ã€<tt>good-enough?</tt> ã«ã¤ã„ã¦ã®æ‰‹ç¶šãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã¿ã‚’ç¤ºã—ã¦ã„ã‚‹ã€‚
</p>

<p class="orig" lang="en">
After the local procedures were defined, the
expression <tt>(sqrt-iter 1.0)</tt> was evaluated,
still in environment E1.  So the
procedure object bound to <tt>sqrt-iter</tt> in E1 was called with 1 as
an argument.  This created an environment E2 in which <tt>guess</tt>,
the parameter of <tt>sqrt-iter</tt>, is bound to 1.  <tt>Sqrt-iter</tt> in
turn called <tt>good-enough?</tt> with the value of <tt>guess</tt> (from
E2) as the argument for <tt>good-enough?</tt>.  This set up another
environment, E3, in which <tt>guess</tt> (the parameter of <tt>good-enough?</tt>) is bound to 1.  Although <tt>sqrt-iter</tt> and <tt>good-enough?</tt> both have a parameter named <tt>guess</tt>, these are two
distinct local variables located in different frames.  Also, E2 and E3
both have E1 as their enclosing environment, because the <tt>sqrt-iter</tt> and <tt>good-enough?</tt> procedures both have E1 as their
environment part.  One consequence of this is that the symbol <tt>x</tt>
that appears in the body of <tt>good-enough?</tt> will reference the
binding of <tt>x</tt> that appears in E1, namely the value of <tt>x</tt>
with which the original <tt>sqrt</tt> procedure was called.</p>

<p class="trans" lang="ja">
å±€æ‰€çš„æ‰‹ç¶šããŒå®šç¾©ã•ã‚ŒãŸå¾Œã€ä¾ç„¶ã¨ã—ã¦E1ã¨ã„ã†ç’°å¢ƒã®ä¸­ã§ã€<tt>(sqrt-iter 1.0)</tt> ã¨ã„ã†å¼ãŒè©•ä¾¡ã•ã‚ŒãŸã€‚
ãã†ã„ã†ã‚ã‘ã§ã€E1ã«ãŠã„ã¦ <tt>sqrt-iter</tt> ã«æŸç¸›ã•ã‚Œã¦ã„ã‚‹æ‰‹ç¶šãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã€å®Ÿå¼•æ•°ã¨ã—ã¦ã®1ã¨ã¨ã‚‚ã«ã€å‘¼ã°ã‚ŒãŸã®ã ã€‚
ã“ã‚Œã¯ã€***
</p>

<p class="orig" lang="en">
The environment model thus explains the two key properties that make
local procedure definitions a useful technique for modularizing
programs:</p>

<p class="trans" lang="ja">
ã“ã®ã‚ˆã†ã«ã—ã¦ç’°å¢ƒãƒ¢ãƒ‡ãƒ«ãŒèª¬æ˜ã™ã‚‹ã®ã¯ã€å±€æ‰€çš„æ‰‹ç¶šãå®šç¾©ã‚’ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åŒ–ã™ã‚‹ãŸã‚ã®æœ‰ç”¨ãªæŠ€æ³•ã«ã™ã‚‹ã€äºŒã¤ã®é‡è¦ãªæ€§è³ªã§ã‚ã‚‹ã€‚
</p>

<ul class="orig" lang="en">
<li>The names of the local procedures do not interfere with
names external to the enclosing procedure, because the local procedure
names will be bound in the frame that the procedure creates when it is
run, rather than being bound in the global environment.</li>

<li>The local procedures can access the arguments of the enclosing
procedure, simply by using parameter names as free variables.
This is because the body of the local procedure is evaluated in an
environment that is subordinate to the evaluation environment for the
enclosing procedure.</li>
</ul>

<ul class="trans" lang="ja">
<li>å±€æ‰€æ‰‹ç¶šãã®åå‰ã¯ã€å¤–å´ã‚’å›²ã£ã¦ã„ã‚‹æ‰‹ç¶šãã‚ˆã‚Šå¤–å´ã®åå‰ã«å¹²æ¸‰ã™ã‚‹ã“ã¨ã¯ãªã„â€”â€”ãªãœãªã‚‰ã€å±€æ‰€æ‰‹ç¶šãã®åå‰ã¯ã€å¤§åŸŸç’°å¢ƒã§æŸç¸›ã•ã‚Œã‚‹ã¨ã„ã†ã‚ˆã‚Šã‚‚ã‚€ã—ã‚ã€æ‰‹ç¶šããŒå®Ÿè¡Œã•ã‚Œã‚‹ã¨ãã«æ‰‹ç¶šããŒä½œæˆã™ã‚‹ãƒ•ãƒ¬ãƒ¼ãƒ ã®ä¸­ã§æŸç¸›ã•ã‚Œã‚‹ã ã‚ã†ã‹ã‚‰ã€‚</li>
<li>å±€æ‰€æ‰‹ç¶šãã¯ã€å¤–å´ã‚’å›²ã£ã¦ã„ã‚‹æ‰‹ç¶šãã®å®Ÿå¼•æ•°ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹â€”â€”å˜ã«ä»®å¼•æ•°åã‚’è‡ªç”±å¤‰æ•°ã¨ã—ã¦ä½¿ã†ã“ã¨ã«ã‚ˆã£ã¦ã€‚ãã®ç†ç”±ã¯ã€å±€æ‰€æ‰‹ç¶šãã®æœ¬ä½“ã¯ã€å¤–å´ã‚’å›²ã£ã¦ã„ã‚‹æ‰‹ç¶šãç”¨ã®è©•ä¾¡ã®ç’°å¢ƒã«å¾“å±ã—ã¦ã„ã‚‹ç’°å¢ƒã®ä¸­ã§è©•ä¾¡ã•ã‚Œã‚‹ã‹ã‚‰ã§ã‚ã‚‹ã€‚</li>
</ul>

<p class="orig" lang="en"><a name="%_thm_3.11"></a>
<b>Exercise 3.11.</b>  <a name="%_idx_3120"></a><a name="%_idx_3122"></a><a name="%_idx_3124"></a>In section <a href="#%_sec_3.2.3">3.2.3</a>
we saw how the environment model described the
behavior of procedures with local state.  Now we have seen how
internal definitions work.  A typical message-passing procedure
contains both of these aspects.  Consider the bank account procedure
of section <a href="20_sec3_1.html#%_sec_3.1.1">3.1.1</a>:</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.11.</b> <a href="#%_sec_3.2.3">3.2.3</a>ç¯€ã§ã¯ã€å±€æ‰€çŠ¶æ…‹ã®ã‚ã‚‹æ‰‹ç¶šãã®æŒ¯ã‚‹èˆã„ã‚’ç’°å¢ƒãƒ¢ãƒ‡ãƒ«ãŒã©ã®ã‚ˆã†ã«èª¬æ˜ã™ã‚‹ã®ã‹ã€ã‚’è¦‹ãŸã€‚
ä»Šã‚„ç§ãŸã¡ã¯ã€ã©ã®ã‚ˆã†ã«å†…éƒ¨å®šç¾©ãŒå‹•ãã®ã‹ã€ã‚’è¦‹ã¦ããŸã€‚
ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ¸¡ã™å…¸å‹çš„ãªæ‰‹ç¶šãã¯ã€ã“ã‚Œã‚‰åŒæ–¹ã®å´é¢ã‚’å«ã‚“ã§ã„ã‚‹ã€‚
<a href="20_sec3_1.html#%_sec_3.1.1">3.1.1</a>ç¯€ã®éŠ€è¡Œå£åº§æ‰‹ç¶šãã«ã¤ã„ã¦è€ƒãˆã‚ˆã†ã€‚
</p>

<p class="lisp"><a name="%_idx_3126"></a>(define (make-account balance)
  (define (withdraw amount)
    (if (&gt;= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        &quot;Insufficient funds&quot;))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch m)
    (cond ((eq? m 'withdraw) withdraw)
          ((eq? m 'deposit) deposit)
          (else (error &quot;Unknown request -- MAKE-ACCOUNT&quot;
                       m))))
  dispatch)
</p>

<p class="orig" lang="en">
Show the environment structure generated by the sequence of
interactions</p>

<p class="trans" lang="ja">
ä»¥ä¸‹ã®ä¸€é€£ã®ã‚„ã‚Šã¨ã‚Šã«ã‚ˆã‚Šç”Ÿæˆã•ã‚Œã‚‹ç’°å¢ƒæ§‹é€ ã‚’ç¤ºã›ã€‚
</p>

<p class="lisp">(define acc (make-account 50))

((acc 'deposit) 40)
<i>90</i>

((acc 'withdraw) 60)
<i>30</i>
</p>


<p class="orig" lang="en">
Where is the local state for <tt>acc</tt> kept?  Suppose we define
another account</p>

<p class="trans" lang="ja">
<tt>acc</tt> ç”¨ã®å±€æ‰€çŠ¶æ…‹ã¯ã©ã“ã«ä¿ãŸã‚Œã¦ã„ã‚‹ã ã‚ã†ã‹?
ä»¥ä¸‹ã®ã‚ˆã†ã«ã€ã‚‚ã†ä¸€ã¤ã®å£åº§ã‚’å®šç¾©ã™ã‚‹ã‚‚ã®ã¨ã—ã‚ˆã†ã€‚
</p>


<p class="lisp">(define acc2 (make-account 100))
</p>

<p class="orig" lang="en">
How are the local states for the two accounts kept distinct?  Which
parts of the environment structure are shared between <tt>acc</tt> and
<tt>acc2</tt>?</p>

<p class="trans" lang="ja">
äºŒã¤ã®å£åº§ç”¨ã®å±€æ‰€çŠ¶æ…‹ã¯ã€ã©ã®ã‚ˆã†ã«ã—ã¦åˆ¥ã€…ã«ä¿ãŸã‚Œã‚‹ã®ã ã‚ã†ã‹?
ç’°å¢ƒæ§‹é€ ã®ã†ã¡ã©ã®éƒ¨åˆ†ãŒã€<tt>acc</tt> ã¨ <tt>acc2</tt> ã®é–“ã§å…±æœ‰ã•ã‚Œã¦ã„ã‚‹ã‹?
</p>

<p class="exercise"><span class="ex_comment">
</span></p>


<hr>


<p class="orig" lang="en">
<a name="footnote_Temp_342" href="#call_footnote_Temp_342"><sup><small>12</small></sup></a> Assignment introduces a subtlety into step 1 of
the evaluation rule.  As shown in
exercise <a href="20_sec3_1.html#%_thm_3.8">3.8</a>, the presence of assignment
allows us to write expressions that will produce different values
depending on the order in which the subexpressions in a combination
<a name="%_idx_3066"></a><a name="%_idx_3068"></a>are evaluated.  Thus, to be precise, we should specify an evaluation
order in step 1 (e.g., left to right or right to left).  However, this
order should always be considered to be an implementation detail, and
one should never write programs that depend on some particular order.
For instance, a sophisticated compiler might optimize a program by
varying the order in which subexpressions are evaluated.</p>

<p class="trans" lang="ja">
<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã¯ã€è©•ä¾¡è¦å‰‡ã®ã‚¹ãƒ†ãƒƒãƒ—1ã«ã€å¾®å¦™ãªç‚¹ã‚’æŒã¡è¾¼ã‚€ã€‚
ç·´ç¿’å•é¡Œ<a href="20_sec3_1.html#%_thm_3.8">3.8</a>ã«ç¤ºã•ã‚Œã‚‹ã‚ˆã†ã«ã€<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã®å­˜åœ¨ã«ã‚ˆã£ã¦ç§ãŸã¡ã¯ã€ã‚³ãƒ³ãƒ“ãƒãƒ¼ã‚·ãƒ§ãƒ³å†…ã®éƒ¨åˆ†å¼ãŒè©•ä¾¡ã•ã‚Œã‚‹é †åºã«ä¾å­˜ã—ã¦ç•°ãªã‚‹å€¤ã‚’ä½œã‚Šå‡ºã™ã§ã‚ã‚ã†ã‚ˆã†ãªå¼ã‚’ã€æ›¸ãã“ã¨ãŒã§ãã‚‹ã‚ˆã†ã«ãªã‚‹ã€‚
ã‚ˆã£ã¦ã€æ­£ç¢ºã«è¨€ãˆã°ã€ã‚¹ãƒ†ãƒƒãƒ—1ã§ã®è©•ä¾¡é †ã‚’æŒ‡å®šã™ã¹ããªã®ã  (ä¾‹ãˆã°ã€å·¦ã‹ã‚‰å³ã¸ã€ã‚ã‚‹ã„ã¯ã€å³ã‹ã‚‰å·¦ã¸ã€ãªã©)ã€‚
ã—ã‹ã—ã€ã“ã®é †åºã¯ã€å¸¸ã«å®Ÿè£…ã®ç´°éƒ¨ã¨ã—ã¦è€ƒãˆã‚‰ã‚Œã‚‹ã¹ãã§ã‚ã‚Šã€ä½•ã‚‰ã‹ã®ç‰¹å®šã®é †åºã«ä¾å­˜ã—ã¦ã„ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯æ›¸ãã¹ãã§ã¯ãªã„ã€‚
ãŸã¨ãˆã°ã€ç²¾å·§ãªã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯ã€éƒ¨åˆ†å¼ãŒè©•ä¾¡ã•ã‚Œã‚‹é †åºã‚’å¤‰åŒ–ã•ã›ã‚‹ã“ã¨ã§ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æœ€é©åŒ–ã™ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_343" href="#call_footnote_Temp_343"><sup><small>13</small></sup></a> If there is already a binding for the
variable in the current frame, then the binding is changed.  This is
convenient because it allows redefinition of symbols; however, it also
means that <tt>define</tt> can be used to change values, and this brings
up the issues of assignment without explicitly using <a name="%_idx_3080"></a><tt>set!</tt>.
Because of this, some people prefer redefinitions of existing symbols
to signal errors or warnings.</p>

<p class="trans" lang="ja">
ã‚‚ã—ç¾åœ¨ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã®ä¸­ã«ã€æ—¢ã«ãã®å¤‰æ•°ã«ã¤ã„ã¦ã®ä½•ã‚‰ã‹ã®æŸç¸›ãŒã‚ã‚Œã°ã€ãã®æŸç¸›ã¯å¤‰æ›´ã•ã‚Œã‚‹ã€‚
ã“ã‚Œã¯ã€è¨˜å·ã®å†å®šç¾©ã‚’å¯èƒ½ã¨ã™ã‚‹ã®ã§ã€ä¾¿åˆ©ã§ã‚ã‚‹ã€‚ãŒã€ã“ã‚Œã¯ã€å€¤ã‚’å¤‰æ›´ã™ã‚‹ãŸã‚ã« <tt>define</tt> ã‚’ä½¿ãˆã‚‹ã€ã¨ã„ã†ã“ã¨ã‚’ã‚‚æ„å‘³ã—ã€æ˜ç¤ºçš„ã« <tt>set!</tt> ã‚’ä½¿ã‚ãªã„<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã®å•é¡Œã‚’æèµ·ã™ã‚‹ã®ã ã€‚
ã“ã‚ŒãŒåŸå› ã§ã€æ—¢å­˜ã®è¨˜å·ã®å†å®šç¾©ã«ã¯ã‚¨ãƒ©ãƒ¼ã¾ãŸã¯è­¦å‘Šã®åˆå›³ã‚’å‡ºã—ã¦ã»ã—ã„ã€ã¨è€ƒãˆã‚‹äººãŸã¡ã‚‚ã„ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_345" href="#call_footnote_Temp_345"><sup><small>14</small></sup></a> The
environment model will not clarify our claim in
section <a href="11_sec1_2.html#%_sec_1.2.1">1.2.1</a> that the interpreter can
execute a procedure such as <tt>fact-iter</tt> in a constant amount of
space using tail recursion.  We will discuss tail recursion when we
<a name="%_idx_3094"></a><a name="%_idx_3096"></a>deal with the control structure of the interpreter in
section <a href="34_sec5_4.html#%_sec_5.4">5.4</a>.</p>

<p class="trans" lang="ja">
ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã¯ã€æœ«å°¾å†å¸°ã‚’ç”¨ã„ã¦ã€<tt>fact-iter</tt> ã®ã‚ˆã†ãªæ‰‹ç¶šãã‚’å®šæ•°é‡ã®ç©ºé–“ã§å®Ÿè¡Œã§ãã‚‹ã€ã¨ã„ã†<a href="11_sec1_2.html#%_sec_1.2.1">1.2.1</a>ç¯€ã§ã®ä¸»å¼µã‚’ã€ç’°å¢ƒãƒ¢ãƒ‡ãƒ«ã¯æ˜ã‚‰ã‹ã«ã—ãªã„ã ã‚ã†ã€‚
<a href="34_sec5_4.html#%_sec_5.4">5.4</a>ç¯€ã§ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã®åˆ¶å¾¡æ§‹é€ ã‚’å–ã‚Šæ‰±ã†ã¨ãã«ã€æœ«å°¾å†å¸°ã«ã¤ã„ã¦è­°è«–ã—ã‚ˆã†ã€‚
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_346" href="#call_footnote_Temp_346"><sup><small>15</small></sup></a> Whether
<tt>W1</tt> and <tt>W2</tt> share the same physical code stored in the
computer, or whether they each keep a copy of the code, is a detail of
the implementation.  For the interpreter we implement in chapter 4,
the code is in fact shared.</p>

<p class="trans" lang="ja">
<tt>W1</tt> ã¨ <tt>W2</tt> ãŒã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿å†…ã«æ ¼ç´ã•ã‚ŒãŸåŒã˜ç‰©ç†çš„ã‚³ãƒ¼ãƒ‰ã‚’å…±æœ‰ã™ã‚‹ã®ã‹ã€ãã‚Œã¨ã‚‚ã€ãã®ã‚³ãƒ¼ãƒ‰ã®å†™ã—ã‚’ãã‚Œãã‚Œä¿æŒã™ã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã¯ã€å®Ÿè£…ã®ç´°ç›®ã§ã‚ã‚‹ã€‚
ç§ãŸã¡ãŒ4ç« ã§å®Ÿè£…ã™ã‚‹ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«ã¨ã£ã¦ã¯ã€ã‚³ãƒ¼ãƒ‰ã¯ã€å®Ÿéš›ã€å…±æœ‰ã•ã‚Œã‚‹ã€‚
</p>


</div>
</body>
</html>
