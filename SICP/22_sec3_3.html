<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="sicp.css" type="text/css">
<base target="_top">
<title>Structure and Interpretation of Computer Programs: SICP私訳</title>
</head>
<body>

<div class="idx-bar">
<nav>
<a href="https://twitter.com/share" class="twitter-share-button" data-lang="ja">ツイート</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
<span class="status">推敲待ち</span>
[
<a href="00_cover.html">先頭へ</a> |
<a href="21_sec3_2.html">前へ</a> |
<a href="23_sec3_4.html">次へ</a> |
<a href="04_toc.html#%_toc_start">目次</a> |
<a href="38_index.html#%_index_start">索引</a>
] [<a href="99_about.html">この対訳版について</a> | <a href="../index.html">ホーム</a>]

<!--
$ curl -o ch3-Z-G-#1.gif https://mitpress.mit.edu/sicp/full-text/book/ch3-Z-G-[13-30].gif
-->
[
§<a href="#%_sec_3.3">3.3</a>
§<a href="#%_sec_3.3.1">3.3.1</a>
🎨<a href="#%_fig_3.12">3.12</a>
🎨<a href="#%_fig_3.13">3.13</a>
🎨<a href="#%_fig_3.14">3.14</a>
🎨<a href="#%_fig_3.15">3.15</a>
📝<a href="#%_thm_3.12">3.12</a>
📝<a href="#%_thm_3.13">3.13</a>
📝<a href="#%_thm_3.14">3.14</a>
📚<a href="#%_sec_Temp_355">&hellip;</a>
🎨<a href="#%_fig_3.16">3.16</a>
🎨<a href="#%_fig_3.17">3.17</a>
📝<a href="#%_thm_3.15">3.15</a>
📝<a href="#%_thm_3.16">3.16</a>
📝<a href="#%_thm_3.17">3.17</a>
📝<a href="#%_thm_3.18">3.18</a>
📝<a href="#%_thm_3.19">3.19</a>
📚<a href="#%_sec_Temp_363">&hellip;</a>
📝<a href="#%_thm_3.20">3.20</a>
§<a href="#%_sec_3.3.2">3.3.2</a>
🎨<a href="#%_fig_3.18">3.18</a>
🎨<a href="#%_fig_3.19">3.19</a>
🎨<a href="#%_fig_3.20">3.20</a>
🎨<a href="#%_fig_3.21">3.21</a>
📝<a href="#%_thm_3.21">3.21</a>
📝<a href="#%_thm_3.22">3.22</a>
📝<a href="#%_thm_3.23">3.23</a>
§<a href="#%_sec_3.3.3">3.3.3</a>
🎨<a href="#%_fig_3.22">3.22</a>
📚<a href="#%_sec_Temp_373">&hellip;</a>
🎨<a href="#%_fig_3.23">3.23</a>
📚<a href="#%_sec_Temp_374">&hellip;</a>
📝<a href="#%_thm_3.24">3.24</a>
📝<a href="#%_thm_3.25">3.25</a>
📝<a href="#%_thm_3.26">3.26</a>
📝<a href="#%_thm_3.27">3.27</a>
§<a href="#%_sec_3.3.4">3.3.4</a>
🎨<a href="#%_fig_3.24">3.24</a>
🎨<a href="#%_fig_3.25">3.25</a>
🎨<a href="#%_fig_3.26">3.26</a>
📚<a href="#%_sec_Temp_380">&hellip;</a>
📝<a href="#%_thm_3.28">3.28</a>
📝<a href="#%_thm_3.29">3.29</a>
📝<a href="#%_thm_3.30">3.30</a>
🎨<a href="#%_fig_3.27">3.27</a>
📚<a href="#%_sec_Temp_384">&hellip;</a>
📚<a href="#%_sec_Temp_386">&hellip;</a>
📚<a href="#%_sec_Temp_387">&hellip;</a>
📝<a href="#%_thm_3.31">3.31</a>
📚<a href="#%_sec_Temp_389">&hellip;</a>
📝<a href="#%_thm_3.32">3.32</a>
§<a href="#%_sec_3.3.5">3.3.5</a>
🎨<a href="#%_fig_3.28">3.28</a>
📚<a href="#%_sec_Temp_395">&hellip;</a>
📚<a href="#%_sec_Temp_396">&hellip;</a>
📚<a href="#%_sec_Temp_397">&hellip;</a>
📝<a href="#%_thm_3.33">3.33</a>
📝<a href="#%_thm_3.34">3.34</a>
📝<a href="#%_thm_3.35">3.35</a>
📝<a href="#%_thm_3.36">3.36</a>
📝<a href="#%_thm_3.37">3.37</a>
<a href="#footnotes">脚注</a>
]
</nav>

</div>

<div class="main-txt">
<a name="%_sec_3.3"></a>
<h2 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_3.3">3.3  Modeling with Mutable Data</a></h2>
<h2 class="trans" lang="ja">3.3 変更可能なデータをともなうモデル化</h2>

<p class="orig" lang="en">
<a name="%_idx_3128"></a>
Chapter 2 dealt with compound data as a means for constructing
computational objects that have several parts, in order to model
real-world objects that have several aspects.  In that chapter we
introduced the discipline of data abstraction, according to which data
structures are specified in terms of constructors, which create data
objects, and selectors, which access the parts of compound data
objects.  But we now know that there is another aspect of data that
chapter 2 did not address.  The desire to model systems composed of
objects that have changing state leads us to the need to modify
compound data objects, as well as to construct and select from them.
In order to model compound objects with changing state, we will design
data abstractions to include, in addition to selectors and
constructors, operations called <a name="%_idx_3130"></a><em>mutators</em>, which modify data
objects.  For instance, modeling a banking system requires us to
change account balances.  Thus, a data structure for representing bank
accounts might admit an operation
</p>

<p class="trans" lang="ja">
2章では、いくつかの側面を持った実世界の<ruby><rb>物</rb><rp> (</rp><rt>オブジェクト</rt><rp>) </rp></ruby>をモデル化するためにいくつかの部品を持っているような計算オブジェクトを構築するための手段として、複合的データを取り扱った。
2章では、データ抽象化の規律を導入したわけだが、これによれば、データ構造は、コンストラクタ——データオブジェクトを作成する——と、セレクタ——複合データオブジェクトの部品にアクセスする——の観点から、規定される。
しかし今や私たちは、2章では対処しなかった、データの別の側面が存在することを、知っているのだ。
変化する状態を有する<ruby><rb>物</rb><rp> (</rp><rt>オブジェクト</rt><rp>) </rp></ruby>からなる<ruby><rb>系</rb><rp> (</rp><rt>システム</rt><rp>) </rp></ruby>をモデル化するという願望は、複合データオブジェクトを構築したり、複合データオブジェクトから選択したりする必要性だけでなく、複合データオブジェクトを修正する必要性につながる。
変化する状態を有する複合的な<ruby><rb>物</rb><rp> (</rp><rt>オブジェクト</rt><rp>) </rp></ruby>をモデル化するために、私たちは、セレクタとコンストラクタに加えて、<em><ruby><rb>変更演算子</rb><rp> (</rp><rt>ミューテータ</rt><rp>) </rp></ruby></em>と呼ばれる演算——データオブジェクトを修正する——を含むように、データ抽象化を設計しよう。
たとえば、銀行システムをモデル化することは、口座残高を変更することを要する。
よって、銀行口座を表現するためのデータ構造は、次のような演算を許すかもしれない。
</p>

<p class="lisp">(set-balance! &lt;<em>account</em>&gt; &lt;<em>new-value</em>&gt;)
</p>

<p class="orig" lang="en">
that changes the balance of the designated account to the designated
new value.  Data objects for which mutators are defined are known as
<em>mutable data objects</em>.</p>

<p class="trans" lang="ja">
これは、指定された口座の残高を、指定された新たな値に変更する。
ミューテータが定義される対象となっているデータオブジェクトは、<em><ruby><rb>変変更可能な</rb><rp> (</rp><rt>ミュータブル</rt><rp>) </rp></ruby>データオブジェクト</em>として知られる。
</p>

<p class="orig" lang="en">
Chapter 2 introduced pairs as a general-purpose ``glue'' for
synthesizing compound data.  We begin this section by defining basic
mutators for pairs, so that pairs can serve as building blocks for
constructing mutable data objects.  These mutators greatly enhance the
representational power of pairs, enabling us to build data structures
other than the sequences and trees that we worked with in
section <a href="15_sec2_2.html#%_sec_2.2">2.2</a>.  We also present some examples of
simulations in which complex systems are modeled as collections of
objects with local state.</p>

<p class="trans" lang="ja">
2章では、複合データを合成するための汎用の「接着糊」として、対を導入した。
対に対する基本的なミューテータを定義することから本節を始めるが、その結果として、対は、変更可能なデータオブジェクトを構築するための基本構成要素として、機能できるようになるだろう。
こうしたミューテータは、対の表現力を非常に高める——<a href="15_sec2_2.html#%_sec_2.2">2.2</a>節で作業した列や木以外のデータ構造も構築できるようにしてくれるのだ。
局所状態を有するオブジェクトの集まりとして複雑な系がモデル化されているようなシミュレーションの例も、いくつか提示する。
</p>

<a name="%_sec_3.3.1"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_3.3.1">3.3.1  Mutable List Structure</a></h3>
<h3 class="trans" lang="ja">3.3.1 変更可能なリスト構造</h3>

<p class="orig" lang="en">
<a name="%_idx_3132"></a><a name="%_idx_3134"></a>
<a name="%_idx_3136"></a><a name="%_idx_3138"></a>
The basic operations on pairs -- <tt>cons</tt>, <tt>car</tt>, and <tt>cdr</tt> -- can be used to construct list structure and to select parts
from list structure, but they are incapable of modifying list
structure.  The same is true of the list operations we have used so
far, such as <tt>append</tt> and <tt>list</tt>, since these can be defined
in terms of <tt>cons</tt>, <tt>car</tt>, and <tt>cdr</tt>.  To modify list
structures we need new operations.</p>

<p class="trans" lang="ja">
対に対する基本的な演算—— <tt>cons</tt> と <tt>car</tt> と <tt>cdr</tt> ——は、リスト構造を構築するのに使えるし、リスト構造から一部を選択するのにも使えるが、これらの演算は、リスト構造を修正することはできない。
同じことは、ここまで使ってきたリスト演算—— <tt>append</tt> や <tt>list</tt> など——についても言える。というのも、これらの演算は、<tt>cons</tt> と <tt>car</tt> と <tt>cdr</tt> を使って定義され得るものだからである。
リスト構造を修正するには、新しい演算が必要だ。
</p>

<a name="%_fig_3.12"></a>
<figure>
<img src="ch3-Z-G-13.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.12:</b>  Lists <tt>x</tt>: <tt>((a b) c d)</tt> and <tt>y</tt>: <tt>(e f)</tt>.</figcaption>
<figcaption class="trans" lang="ja"><b>図3.12:</b> <tt>x</tt>: <tt>((a b) c d)</tt> および <tt>y</tt>: <tt>(e f)</tt> なるリスト</figcaption>
</figure>

<a name="%_fig_3.13"></a>
<figure>
<img src="ch3-Z-G-14.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.13:</b>  Effect of <tt>(set-car! x y)</tt> on the lists in figure <a href="#%_fig_3.12">3.12</a>.</figcaption>
<figcaption class="trans" lang="ja"><b>図3.13:</b> 図<a href="#%_fig_3.12">3.12</a>のリストに対する、<tt>(set-car! x y)</tt> の影響</figcaption>
</figure>

<a name="%_fig_3.14"></a>
<figure>
<img src="ch3-Z-G-15.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.14:</b>  Effect of <tt>(define z (cons y (cdr x)))</tt> on the lists in figure <a href="#%_fig_3.12">3.12</a>.</figcaption>
<figcaption class="trans" lang="ja"><b>図3.14:</b> 図<a href="#%_fig_3.12">3.12</a>のリストに対する、<tt>(define z (cons y (cdr x)))</tt> の影響</figcaption>
</figure>

<a name="%_fig_3.15"></a>
<figure>
<img src="ch3-Z-G-16.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.15:</b>  Effect of <tt>(set-cdr! x y)</tt> on the lists in figure <a href="#%_fig_3.12">3.12</a>.</figcaption>
<figcaption class="trans" lang="ja"><b>図3.15:</b> 図<a href="#%_fig_3.12">3.12</a>のリストに対する、<tt>(set-cdr! x y)</tt> の影響</figcaption>
</figure>

<p class="orig" lang="en">
<a name="%_idx_3140"></a><a name="%_idx_3142"></a><a name="%_idx_3144"></a><a name="%_idx_3146"></a>The primitive mutators for pairs are <tt>set-car!</tt> and <tt>set-cdr!</tt>. <tt>Set-car!</tt> takes two arguments, the first of which
must be a pair.  It modifies this pair, replacing the <tt>car</tt>
pointer by a pointer to the second argument of <tt>set-car!</tt>.<a name="call_footnote_Temp_349" href="#footnote_Temp_349"><sup><small>16</small></sup></a>
</p>

<p class="trans" lang="ja">
対に対する原始的ミューテータは、<tt>set-car!</tt> と <tt>set-cdr!</tt> だ。
<tt>set-car!</tt> は二つの引数をとり、それらのうちの最初のものは、対でなくてはならない。
<tt>set-car!</tt> はこの対を修正する——つまり、<tt>car</tt> ポインタを、<tt>set-car!</tt> の第二引数を指すポインタで置き換える<a href="#footnote_Temp_349"><sup><small>16</small></sup></a>。
</p>

<p class="orig" lang="en">
As an example, suppose that <tt>x</tt> is bound to the list <tt>((a b) c
d)</tt> and <tt>y</tt> to the list <tt>(e f)</tt> as illustrated in
figure <a href="#%_fig_3.12">3.12</a>.  Evaluating the expression <tt>(set-car!
x y)</tt> modifies the pair to which <tt>x</tt> is bound, replacing its <tt>car</tt> by the value of <tt>y</tt>.  The result of the operation is shown in
figure <a href="#%_fig_3.13">3.13</a>.  The structure <tt>x</tt> has been modified and
would now be printed
as <tt>((e f) c d)</tt>.  The
pairs representing the list <tt>(a b)</tt>, identified by the pointer
that was replaced, are now detached from the original
structure.<a name="call_footnote_Temp_350" href="#footnote_Temp_350"><sup><small>17</small></sup></a>
</p>

<p class="trans" lang="ja">
例として、図<a href="#%_fig_3.12">3.12</a>に示すように、<tt>x</tt> が 
<tt>((a b) c d)</tt> というリストに束縛されており、かつ、<tt>y</tt> が
<tt>(e f)</tt> というリストに束縛されているものとする。
<tt>(set-car! x y)</tt> という式を評価することで、<tt>x</tt> が束縛されている対が、修正される——つまり、この対の <tt>car</tt> を <tt>y</tt> の値で置き換えるわけである。
この演算の結果は、図<a href="#%_fig_3.13">3.13</a>に示されている。
<tt>x</tt> の構造は、修正されたのであり、そして今や、<tt>((e f) c d)</tt> と印刷されることだろう。
<tt>(a b)</tt> というリストを表現する対——置き換えられたポインタにより識別されるもの——は、今や、元の構造からは切り離されている<a href="#footnote_Temp_350"><sup><small>17</small></sup></a>。
</p>

<p class="orig" lang="en">
Compare figure <a href="#%_fig_3.13">3.13</a> with figure <a href="#%_fig_3.14">3.14</a>,
which illustrates the result of executing <tt>(define z (cons y (cdr
x)))</tt> with <tt>x</tt> and <tt>y</tt> bound to the original lists of
figure <a href="#%_fig_3.12">3.12</a>.  The variable <tt>z</tt> is now bound to a
new pair created by the <tt>cons</tt> operation; the list to which <tt>x</tt> is bound is unchanged.
</p>

<p class="trans" lang="ja">
図<a href="#%_fig_3.13">3.13</a>を、図<a href="#%_fig_3.14">3.14</a>——図<a href="#%_fig_3.12">3.12</a>の元のリストに束縛されている <tt>x</tt> と <tt>y</tt> を使って、<tt>(define z (cons y (cdr x)))</tt> を実行した結果——と比べよ。
<tt>z</tt> という変数は、ここで、<tt>cons</tt> 演算により作成された新たな対に、束縛されている。そして、<tt>x</tt> が束縛されているリストは、そのままである。
</p>

<p class="orig" lang="en">
The <tt>set-cdr!</tt> operation is similar to <tt>set-car!</tt>.  The
only difference is that the <tt>cdr</tt> pointer of the pair, rather than
the <tt>car</tt> pointer, is replaced.  The effect of executing <tt>(set-cdr! x y)</tt> on the lists of figure <a href="#%_fig_3.12">3.12</a> is shown
in figure <a href="#%_fig_3.15">3.15</a>.
Here the <tt>cdr</tt> pointer of <tt>x</tt> has been replaced by the pointer
to <tt>(e f)</tt>.  Also, the list <tt>(c d)</tt>, which used to be the <tt>cdr</tt> of <tt>x</tt>, is now detached from the structure.
</p>

<p class="trans" lang="ja">
<tt>set-cdr!</tt> 演算は、 <tt>set-car!</tt> 演算に似ている。
唯一の違いは、対の、<tt>car</tt> ポインタではなくむしろ <tt>cdr</tt> ポインタが、置換されるという点である。
図<a href="#%_fig_3.12">3.12</a>のリストに対して <tt>(set-cdr! x y)</tt> を実行した効果が、図<a href="#%_fig_3.15">3.15</a>に示されている。
ここで、<tt>x</tt> の <tt>cdr</tt> ポインタは、<tt>(e f)</tt> を指すポインタに置き換えられた。
また、<tt>(c d)</tt> というリスト——かつては <tt>x</tt> の <tt>cdr</tt> だった——は、今や当該構造から切り離されている。
</p>

<p class="orig" lang="en">
<a name="%_idx_3158"></a><tt>Cons</tt> builds new list structure by creating new pairs, while
<tt>set-car!</tt> and <tt>set-cdr!</tt> modify existing pairs.  Indeed, we
could implement <tt>cons</tt> in terms of the two mutators, together with
a procedure <tt>get-new-pair</tt>, which returns a new pair that is not
part of any existing list structure.  We obtain the new pair, set its
<tt>car</tt> and <tt>cdr</tt> pointers to the designated objects, and return
the new pair as the result of the <tt>cons</tt>.<a name="call_footnote_Temp_351" href="#footnote_Temp_351"><sup><small>18</small></sup></a>
</p>

<p class="trans" lang="ja">
<tt>cons</tt> が新たな対を作成することで新たなリスト構造を構築するのに対して、<tt>set-car!</tt> と <tt>set-cdr!</tt> は既存の対を修正する。
実際、これら二つのミューテータを、<tt>get-new-pair</tt> という手続き——いかなる既存のリスト構造の部分でもない、新たな対を返す——と一緒に使って、<tt>cons</tt> を実装することができただろう。
新しい対を得て、それの <tt>car</tt> と <tt>cdr</tt> のポインタを、指定されたオブジェクトに設定し、その新しい対を、<tt>cons</tt> の結果として返すのである<a href="#footnote_Temp_351"><sup><small>18</small></sup></a>。
</p>

<p class="lisp"><a name="%_idx_3160"></a>(define (cons x y)
  (let ((new (get-new-pair)))
    (set-car! new x)
    (set-cdr! new y)
    new))
</p>

<p class="orig" lang="en">
<a name="%_thm_3.12"></a>
<b>Exercise 3.12.</b>  <a name="%_idx_3162"></a>The following procedure for appending lists was introduced in
section <a href="15_sec2_2.html#%_sec_2.2.1">2.2.1</a>:
</p>

<p class="trans" lang="ja">
<b>練習問題3.12.</b> リスト同士をつなげるための以下の手続きを、<a href="15_sec2_2.html#%_sec_2.2.1">2.2.1</a>節で導入した。
</p>

<p class="lisp"><a name="%_idx_3164"></a>(define (append x y)
  (if (null? x)
      y
      (cons (car x) (append (cdr x) y))))
</p>

<p class="orig" lang="en">
<tt>Append</tt> forms a new list by successively <tt>cons</tt>ing the
elements of <tt>x</tt> onto <tt>y</tt>.  The procedure <tt>append!</tt> is
similar to <tt>append</tt>, but it is a mutator rather than a constructor.
It appends the lists by splicing them together, modifying the final
pair of <tt>x</tt> so that its <tt>cdr</tt> is now <tt>y</tt>.
(It is an error to call <tt>append!</tt> with an empty <tt>x</tt>.)
</p>

<p class="trans" lang="ja">
<tt>append</tt> は、<tt>y</tt> の上に <tt>x</tt> の要素を次々と <tt>cons</tt> して行くことによって、新たなリストを形成する。
<tt>append!</tt> という手続きは、<tt>append</tt> に似ているが、コンストラクタというよりむしろミューテータである。
これは、リスト同士を継ぎ合わせて一つにすることで、リスト同士をつなげる—— <tt>x</tt>の最後の対の <tt>cdr</tt> が、今や <tt>y</tt> となるように、<tt>x</tt>の最後の対を修正してゆくのである。
(空の <tt>x</tt> に対して <tt>append!</tt> を呼び出すのは、エラーである。)
</p>

<p class="lisp"><a name="%_idx_3166"></a>(define (append! x y)
  (set-cdr! (last-pair x) y)
  x)
</p>

<p class="orig" lang="en">
Here <tt>last-pair</tt> is a procedure that returns the last pair in its
argument:
</p>

<p class="trans" lang="ja">
ここで、<tt>last-pair</tt> は、引数の中の最後の対を返す手続きである。
</p>

<p class="lisp"><a name="%_idx_3168"></a>(define (last-pair x)
  (if (null? (cdr x))
      x
      (last-pair (cdr x))))
</p>

<p class="orig" lang="en">
Consider the interaction
</p>

<p class="trans" lang="ja">
以下のやりとりを考えよう。
</p>

<p class="lisp">(define x (list 'a 'b))
(define y (list 'c 'd))
(define z (append x y))
z
<i>(a b c d)</i>
(cdr x)
&lt;<em>response</em>&gt;
(define w (append! x y))
w
<i>(a b c d)</i>
(cdr x)
&lt;<em>response</em>&gt;
</p>

<p class="orig" lang="en">
What are the missing &lt;<em>response</em>&gt;s?
Draw box-and-pointer diagrams to explain your answer.
</p>

<p class="trans" lang="ja">
欠けている応答 (&lt;<em class="en">response</em>&gt;) は、どのようなものであろうか?
箱とポインタの図を描いて、答えを説明したまえ。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_3.13"></a>
<b>Exercise 3.13.</b>  <a name="%_idx_3170"></a>Consider the following <tt>make-cycle</tt> procedure, which uses the <tt>last-pair</tt> procedure defined in exercise <a href="#%_thm_3.12">3.12</a>:
</p>

<p class="trans" lang="ja">
<b>練習問題3.13.</b> 以下の <tt>make-cycle</tt> という手続き——練習問題<a href="#%_thm_3.12">3.12</a> で定義した <tt>last-pair</tt> の手続きを使っている——を考えよ。
</p>

<p class="lisp"><a name="%_idx_3172"></a>(define (make-cycle x)
  (set-cdr! (last-pair x) x)
  x)
</p>

<p class="orig" lang="en">
Draw a box-and-pointer diagram that shows the structure <tt>z</tt>
created by
</p>

<p class="trans" lang="ja">
以下のようにすることで作られる <tt>z</tt> という構造を示すような、箱とポインタの図を描け。
</p>

<p class="lisp">(define z (make-cycle (list 'a 'b 'c)))
</p>

<p class="orig" lang="en">
What happens if we try to compute <tt>(last-pair z)</tt>?
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="trans" lang="ja">
もし、<tt>(last-pair z)</tt> を計算しようとしたら、何が起きるだろう?
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_3.14"></a>
<b>Exercise 3.14.</b>  The following procedure is quite useful, although obscure:
</p>

<p class="trans" lang="ja">
<b>練習問題3.14.</b> 以下の手続きは、晦渋ではあるものの、非常に有用である。
</p>

<p class="lisp"><a name="%_idx_3174"></a>(define (mystery x)
  (define (loop x y)
    (if (null? x)
        y
        (let ((temp (cdr x)))
          (set-cdr! x y)
          (loop temp x))))
  (loop x '()))
</p>

<p class="orig" lang="en">
<tt>Loop</tt> uses the ``temporary'' variable <tt>temp</tt> to hold
the old value of the <tt>cdr</tt> of <tt>x</tt>, since the <tt>set-cdr!</tt>
on the next line destroys the <tt>cdr</tt>.  Explain what <tt>mystery</tt>
does in general.  Suppose <tt>v</tt> is defined by <tt>(define v (list 'a
'b 'c 'd))</tt>. Draw the box-and-pointer diagram that represents the list
to which <tt>v</tt> is bound.  Suppose that we now evaluate <tt>(define
w (mystery v))</tt>. Draw box-and-pointer diagrams that show the
structures <tt>v</tt> and <tt>w</tt> after evaluating this expression.  What
would be printed as the values of <tt>v</tt> and <tt>w</tt> ?</p>

<p class="trans" lang="ja">
<tt>loop</tt> は、<tt>x</tt> の <tt>cdr</tt> の元の値を保持するために、<tt>temp</tt> という「臨時的な」変数を使う。というのも、次の行の <tt>set-cdr!</tt> が、当該 <tt>cdr</tt> を破壊するからである。
一般に <tt>mystery</tt> が何をするのかを説明せよ。
<tt>(define v (list 'a 'b 'c 'd))</tt> により <tt>v</tt> が定義されているものとせよ。
<tt>v</tt> が束縛されているリストを表現するような、箱とポインタの図を描け。
今、<tt>(define w (mystery v))</tt> を評価するものとしよう。
この式を評価した後の <tt>v</tt> と <tt>w</tt> の構造を示すような、箱とポインタの図を描け。
<tt>v</tt> と <tt>w</tt> の値として、何が印刷されるだろうか?
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_Temp_355"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_355">Sharing and identity</a></h4>
<h4 class="trans" lang="ja">共有と自己同一性と</h4>

<p class="orig" lang="en">
<a name="%_idx_3176"></a><a name="%_idx_3178"></a>
<a name="%_idx_3180"></a><a name="%_idx_3182"></a>We mentioned in section <a href="20_sec3_1.html#%_sec_3.1.3">3.1.3</a> the theoretical
issues of ``sameness'' and ``change'' raised by the introduction of
assignment.  These issues arise in practice when individual pairs are
<em>shared</em> among different data objects.  For example, consider the
structure formed by
</p>

<p class="trans" lang="ja">
<a href="20_sec3_1.html#%_sec_3.1.3">3.1.3</a>節では、<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>の導入によって引き起こされた、「同一性」と「変化」についての理論上の問題について述べた。
これらの問題は、個々の対が異なるデータオブジェクトの間で<em>共有される</em>場合に、実際に生じる。
たとえば、以下により作られる構造を考えよう。
</p>

<p class="lisp">(define x (list 'a 'b))
(define z1 (cons x x))
</p>

<p class="orig" lang="en">
As shown in figure <a href="#%_fig_3.16">3.16</a>, <tt>z1</tt> is a pair whose <tt>car</tt> and <tt>cdr</tt> both point to the same pair <tt>x</tt>.  This sharing
of <tt>x</tt> by the <tt>car</tt> and <tt>cdr</tt> of <tt>z1</tt> is a consequence
of the straightforward way in which <tt>cons</tt> is implemented.  In
general, using <tt>cons</tt> to construct lists will result in an
interlinked structure of pairs in which many individual pairs are
shared by many different structures.</p>

<p class="trans" lang="ja">
図<a href="#%_fig_3.16">3.16</a>に示すように、<tt>z1</tt> は、<tt>car</tt> と <tt>cdr</tt> の双方が、<tt>x</tt> という同じ対を指しているような、対である。
<tt>z1</tt> の<tt>car</tt> と <tt>cdr</tt> による、このような <tt>x</tt> の共有は、<tt>cons</tt> が実装されている単純な方法の帰結である。
一般に、リストを構成するのに <tt>cons</tt> を使うことは、その中では多くの個々の対が多くの異なる構造によって共有されているような、対の連結された構造、という結果になるだろう。
</p>


<a name="%_fig_3.16"></a>
<figure>
<img src="ch3-Z-G-17.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.16:</b>  The list <tt>z1</tt> formed by <tt>(cons x x)</tt>.</figcaption>
<figcaption class="trans" lang="ja"><b>図3.16:</b> <tt>(cons x x)</tt> により作られる <tt>z1</tt> というリスト</figcaption>
</figure>

<a name="%_fig_3.17"></a>
<figure>
<img src="ch3-Z-G-18.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.17:</b>  The list <tt>z2</tt> formed by <tt>(cons (list 'a 'b) (list 'a 'b))</tt>.</figcaption>
<figcaption class="trans" lang="ja"><b>図3.17:</b> <tt>(cons (list 'a 'b) (list 'a 'b))</tt> により作られる <tt>z2</tt> というリスト</figcaption>
</figure>

<p class="orig" lang="en">
In contrast to figure <a href="#%_fig_3.16">3.16</a>, figure <a href="#%_fig_3.17">3.17</a> shows
the structure created by
</p>

<p class="trans" lang="ja">
図<a href="#%_fig_3.16">3.16</a>とは対照的に、図<a href="#%_fig_3.17">3.17</a>は、以下により作成された構造を示している。
</p>

<p class="lisp">(define z2 (cons (list 'a 'b) (list 'a 'b)))
</p>

<p class="orig" lang="en">
In this structure, the pairs in the two <tt>(a b)</tt> lists are
distinct, although the actual symbols are shared.<a name="call_footnote_Temp_356" href="#footnote_Temp_356"><sup><small>19</small></sup></a>
</p>

<p class="trans" lang="ja">
この構造では、二つの <tt>(a b)</tt> というリストの中の対は、別個のものである——もっとも、実際の記号は共有されているが<a href="#footnote_Temp_356"><sup><small>19</small></sup></a>。
</p>

<p class="orig" lang="en">
When thought of as a list, <tt>z1</tt> and <tt>z2</tt> both represent ``the
same'' list, <tt>((a b) a b)</tt>.  In general, sharing is completely
undetectable if we operate on lists using only <tt>cons</tt>, <tt>car</tt>,
and <tt>cdr</tt>.  However, if we allow mutators on list structure,
sharing becomes significant.  As an example of the difference that
sharing can make, consider the following procedure, which modifies the
<tt>car</tt> of the structure to which it is applied:
</p>

<p class="trans" lang="ja">
リストとして考えた場合には、<tt>z1</tt> と <tt>z2</tt> の双方は、「同じ」リスト——すなわち、<tt>((a b) a b)</tt> ——を表現する。
一般に、もし <tt>cons</tt> と <tt>car</tt> と <tt>cdr</tt> のみを使ってリスト上で演算を行うならば、共有は、完全に検知不能である。
しかし、もしリスト構造上でのミューテータを許容するなら、共有は目立つようになる。
共有により作り出されることのある差異の一例として、以下の手続き——適用先の構造の <tt>car</tt> を修正する——を考えよう。
</p>

<p class="lisp">(define (set-to-wow! x)
  (set-car! (car x) 'wow)
  x)
</p>

<p class="orig" lang="en">
Even though <tt>z1</tt> and <tt>z2</tt> are ``the same'' structure,
applying <tt>set-to-wow!</tt> to them yields different results.  With
<tt>z1</tt>, altering the <tt>car</tt> also changes the <tt>cdr</tt>, because
in <tt>z1</tt> the <tt>car</tt> and the <tt>cdr</tt> are the same pair.  With
<tt>z2</tt>, the <tt>car</tt> and <tt>cdr</tt> are distinct, so <tt>set-to-wow!</tt> modifies only the <tt>car</tt>:
</p>

<p class="trans" lang="ja">
たとえ <tt>z1</tt> と <tt>z2</tt> が「同じ」構造であるとはいっても、<tt>z1</tt> と <tt>z2</tt> に <tt>set-to-wow!</tt> を適用すると、異なる結果を生み出す。
<tt>z1</tt> については、<tt>car</tt> を変えることで、<tt>cdr</tt> も変更される——なぜなら、<tt>z1</tt> の中では、<tt>car</tt> と <tt>cdr</tt> は同じ対だからである。
<tt>z2</tt> については、<tt>car</tt> と <tt>cdr</tt> が別個のものであるから、<tt>set-to-wow!</tt> は <tt>car</tt> のみを修正する。
</p>

<p class="lisp">z1
<i>((a b) a b)</i>

(set-to-wow! z1)
<i>((wow b) wow b)</i>

z2
<i>((a b) a b)</i>

(set-to-wow! z2)
<i>((wow b) a b)</i>
</p>

<p class="orig" lang="en">
One way to detect sharing in list structures is to use the predicate
<a name="%_idx_3186"></a><a name="%_idx_3188"></a><tt>eq?</tt>, which we introduced in section <a href="16_sec2_3.html#%_sec_2.3.1">2.3.1</a> as a
way to test whether two symbols are equal.  More generally, <tt>(eq?
x y)</tt> tests whether <tt>x</tt> and <tt>y</tt> are the same object (that is,
whether <tt>x</tt> and <tt>y</tt> are equal as pointers).  Thus, with <tt>z1</tt> and <tt>z2</tt> as defined in figures <a href="#%_fig_3.16">3.16</a>
and <a href="#%_fig_3.17">3.17</a>, <tt>(eq? (car z1) (cdr z1))</tt> is true and
<tt>(eq? (car z2) (cdr z2))</tt> is false.
</p>

<p class="trans" lang="ja">
リスト構造における共有を検出するための一つの方法は、<tt>eq?</tt> という述語——二つの記号が等しいかどうかを検査するための手段として、<a href="16_sec2_3.html#%_sec_2.3.1">2.3.1</a>節で導入したもの——を使うことである。
より一般的に言うと、<tt>(eq? x y)</tt> は、<tt>x</tt> と <tt>y</tt> が同じオブジェクトかどうか (つまり、<tt>x</tt> と <tt>y</tt> がポインタとして等しいかどうか) を検査する。
よって、図<a href="#%_fig_3.16">3.16</a>と図<a href="#%_fig_3.17">3.17</a>のように定義された <tt>z1</tt> と <tt>z2</tt> については、
<tt>(eq? (car z1) (cdr z1))</tt> は真で、
<tt>(eq? (car z2) (cdr z2))</tt> は偽である。
</p>

<p class="orig" lang="en">
<a name="%_idx_3190"></a>As will be seen in the following sections, we can exploit sharing to
greatly extend the repertoire of data structures that can be
represented by pairs.  On the other hand, sharing can also be
dangerous, since modifications made to structures will also affect
other structures that happen to share the modified parts.  The
mutation operations <tt>set-car!</tt> and <tt>set-cdr!</tt> should be used
with care; unless we have a good understanding of how our data objects
are shared, mutation can have unanticipated results.<a name="call_footnote_Temp_357" href="#footnote_Temp_357"><sup><small>20</small></sup></a>
</p>

<p class="trans" lang="ja">
以下の節で見ることになるように、対によって表現できるデータ構造のレパートリーを大いに広げるために、共有を活用することができる。
一方で、共有は危険にもなり得る——というのも、構造に対してなされた改変は、その修正された部分をたまたま共有している他の構造にも、影響してしまうであろうから。
<ruby><rb>変更</rb><rp> (</rp><rt>ミューテーション</rt><rp>) </rp></ruby>の演算である <tt>set-car!</tt> と <tt>set-cdr!</tt> は、注意深く使うべきである。自分のデータオブジェクトがどのように共有されているのかについて、ちゃんと理解しているのでない限り、<ruby><rb>変更</rb><rp> (</rp><rt>ミューテーション</rt><rp>) </rp></ruby>は、予期せぬ結果を招き得る<a href="#footnote_Temp_357"><sup><small>20</small></sup></a>。
</p>

<p class="orig" lang="en">
<a name="%_thm_3.15"></a>
<b>Exercise 3.15.</b>  Draw box-and-pointer diagrams to explain the effect of <tt>set-to-wow!</tt> on the structures <tt>z1</tt> and <tt>z2</tt> above.
</p>

<p class="trans" lang="ja">
<b>練習問題3.15.</b> 上記の <tt>z1</tt> と <tt>z2</tt> という構造に対する <tt>set-to-wow!</tt> の作用を説明するための、箱とポインタの図を描け。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_3.16"></a>
<b>Exercise 3.16.</b>  Ben Bitdiddle decides to write a procedure to count the number of
pairs in any list structure.  ``It's easy,'' he reasons.  ``The number
of pairs in any structure is the number in the <tt>car</tt> plus the
number in the <tt>cdr</tt> plus one more to count the current pair.''
So Ben writes the following procedure:
</p>

<p class="trans" lang="ja">
<b>練習問題3.16.</b> ベン・ビットディドルは、任意のリスト構造の中の対の個数を数える手続きを書くことを決意する。
「簡単だよね」と彼は推測する。
「任意の構造の中の対の個数とは、<tt>car</tt> の中の個数、足す、<tt>cdr</tt> の中の個数、足す、あとは今見ているこの対を数えるための1、だよ」
よって、ベンは、以下の手続きを書く。
</p>

<p class="lisp"><a name="%_idx_3192"></a>(define (count-pairs x)
  (if (not (pair? x))
      0
      (+ (count-pairs (car x))
         (count-pairs (cdr x))
         1)))
</p>

<p class="orig" lang="en">
Show that this procedure is not correct.  In particular, draw
box-and-pointer diagrams representing list structures made up of
exactly three pairs for which Ben's procedure would return 3; return
4; return 7; never return at all.
</p>

<p class="trans" lang="ja">
この手続きが正しくないことを示せ。
特に、きっかり三つの対から作られているリスト構造で、ベンの手続きが3を返すだろう、というものと、4を返すだろう、というものと、7を返すだろう、というものと、決して何も返さないだろう、というものを表現する、箱とポインタの図を描け。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_3.17"></a>
<b>Exercise 3.17.</b>  Devise a correct version of the <tt>count-pairs</tt> procedure of
exercise <a href="#%_thm_3.16">3.16</a> that returns the number of distinct
pairs in any structure.  (Hint: Traverse the structure, maintaining an
auxiliary data structure that is used to keep track of which pairs
have already been counted.)
</p>

<p class="trans" lang="ja">
<b>練習問題3.17.</b> 任意の構造における別個の対の数を返すような、練習問題<a href="#%_thm_3.16">3.16</a>の <tt>count-pairs</tt> という手続きの正しいバージョンを考案せよ。
(ヒント: その構造の全体を、どの対を既に数えたかという経過を把握しておくために使われる補助的なデータ構造を維持しながら、見て回れ。)
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_3.18"></a>
<b>Exercise 3.18.</b>  <a name="%_idx_3194"></a>Write a procedure that examines a list and determines whether it
contains a cycle, that is, whether a program that tried to find the
end of the list by taking successive <tt>cdr</tt>s would go into an
infinite loop.  Exercise <a href="#%_thm_3.13">3.13</a> constructed such lists.
</p>

<p class="trans" lang="ja">
<b>練習問題3.18.</b> リストを調べて、そのリストが循環を含んでいるかどうか——つまり、連続的に <tt>cdr</tt> を取っていくことでリストの終わりを見つけようとするプログラムが、無限ループに陥ることになるかどうか——を判断するような手続きを書け。
練習問題<a href="#%_thm_3.13">3.13</a>は、そういうリストを構築した。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_3.19"></a>
<b>Exercise 3.19.</b>  Redo exercise <a href="#%_thm_3.18">3.18</a> using an algorithm that takes only a
constant amount of space.  (This requires a very clever idea.)
</p>

<p class="trans" lang="ja">
<b>練習問題3.19.</b> 定数量の空間しか必要としないようなアルゴリズムを使って、練習問題<a href="#%_thm_3.18">3.18</a>をやり直せ。
(これには非常に巧みな考えが必要である。)
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_Temp_363"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_363">Mutation is just assignment</a></h4>
<h4 class="trans" lang="ja"><ruby><rb>変更</rb><rp> (</rp><rt>ミューテーション</rt><rp>) </rp></ruby>とはまさに<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>である</h4>

<p class="orig" lang="en">
<a name="%_idx_3196"></a><a name="%_idx_3198"></a><a name="%_idx_3200"></a><a name="%_idx_3202"></a>
When we introduced compound data, we observed in
section <a href="14_sec2_1.html#%_sec_2.1.3">2.1.3</a> that pairs can be represented purely in terms
of procedures:
</p>

<p class="trans" lang="ja">
複合的データを導入したとき、<a href="14_sec2_1.html#%_sec_2.1.3">2.1.3</a>節で私たちは、純粋に手続きだけを使って対を表現できることを観察した。
</p>

<p class="lisp"><a name="%_idx_3204"></a>(define (cons x y)
  (define (dispatch m)
    (cond ((eq? m 'car) x)
          ((eq? m 'cdr) y)
          (else (error &quot;Undefined operation -- CONS&quot; m))))
  dispatch)
<a name="%_idx_3206"></a>(define (car z) (z 'car))
<a name="%_idx_3208"></a>(define (cdr z) (z 'cdr))
</p>

<p class="orig" lang="en">
The same observation is true for mutable data.  We can implement
mutable data objects as procedures using assignment and local state.
For instance, we can extend the above pair implementation to handle
<tt>set-car!</tt> and <tt>set-cdr!</tt> in a manner analogous to the way
we implemented bank accounts using <tt>make-account</tt> in
section <a href="20_sec3_1.html#%_sec_3.1.1">3.1.1</a>:
</p>

<p class="trans" lang="ja">
この同じ観察結果は、<ruby><rb>変更可能</rb><rp> (</rp><rt>ミュータブル</rt><rp>) </rp></ruby>なデータに対しても真である。
<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>と局所状態とを用いて、変更可能なデータオブジェクトを、手続きとして実装することができるのだ。
たとえば、<a href="20_sec3_1.html#%_sec_3.1.1">3.1.1</a>節で <tt>make-account</tt> を用いて銀行口座を実装した方法と類似のやり方で <tt>set-car!</tt> と <tt>set-cdr!</tt> を扱うように、上記の対の実装を拡張できる。
</p>

<p class="lisp"><a name="%_idx_3210"></a>(define (cons x y)
  (define (set-x! v) (set! x v))
  (define (set-y! v) (set! y v))
  (define (dispatch m)
    (cond ((eq? m 'car) x)
          ((eq? m 'cdr) y)
          ((eq? m 'set-car!) set-x!)
          ((eq? m 'set-cdr!) set-y!)
          (else (error &quot;Undefined operation -- CONS&quot; m))))
  dispatch)
<a name="%_idx_3212"></a>(define (car z) (z 'car))
<a name="%_idx_3214"></a>(define (cdr z) (z 'cdr))
<a name="%_idx_3216"></a>(define (set-car! z new-value)
  ((z 'set-car!) new-value)
  z)
<a name="%_idx_3218"></a>(define (set-cdr! z new-value)
  ((z 'set-cdr!) new-value)
  z)
</p>

<p class="orig" lang="en">
Assignment is all that is needed, theoretically, to account for the
behavior of mutable data.  As soon as we admit <tt>set!</tt> to our
language, we raise all the issues, not only of assignment, but of
mutable data in general.<a name="call_footnote_Temp_364" href="#footnote_Temp_364"><sup><small>21</small></sup></a>
</p>

<p class="trans" lang="ja">
<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>が、変更可能なデータの振る舞いを説明するのに理論上必要なすべて、なのである。
私たちの言語に <tt>set!</tt> を受け入れることを認めるや否や、私たちは、すべての問題点を——<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>についての問題点だけでなく、変更可能なデータ一般についての問題点をも——提起するのだ<a href="#footnote_Temp_364"><sup><small>21</small></sup></a>
。
</p>

<p class="orig" lang="en">
<a name="%_thm_3.20"></a>
<b>Exercise 3.20.</b>  Draw environment diagrams to illustrate the evaluation of the sequence
of expressions
</p>

<p class="trans" lang="ja">
<b>練習問題3.20.</b> 以下の一連の式の評価を図示するための環境図を描け。
</p>

<p class="lisp">(define x (cons 1 2))
(define z (cons x x))
(set-car! (cdr z) 17)
(car x)
<i>17</i>
</p>

<p class="orig" lang="en">
using the procedural implementation of pairs given above.  (Compare
exercise <a href="21_sec3_2.html#%_thm_3.11">3.11</a>.)
</p>

<p class="trans" lang="ja">
ただし、上記の手続きによる対の実装を用いるように。
(練習問題<a href="21_sec3_2.html#%_thm_3.11">3.11</a>と比べてごらん。)
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_3.3.2"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_3.3.2">3.3.2  Representing Queues</a></h3>
<h3 class="trans" lang="ja">3.3.2 キューを表現する</h3>

<p class="orig" lang="en">
<a name="%_idx_3220"></a>
The mutators <tt>set-car!</tt> and <tt>set-cdr!</tt> enable us to use
pairs to construct data structures that cannot be built with <tt>cons</tt>, <tt>car</tt>, and <tt>cdr</tt> alone.  This section shows how to use
pairs to represent a data structure called a queue.  Section <a href="#%_sec_3.3.3">3.3.3</a>
will show how to represent data structures called tables.</p>

<p class="trans" lang="ja">
<tt>set-car!</tt> および <tt>set-cdr!</tt> というミューテータによって、私たちは、<tt>cons</tt> と <tt>car</tt> と <tt>cdr</tt> だけでは築くことのできないようなデータ構造を、対を使って構築できるようになるのだ。
本節では、キューと呼ばれるデータ構造を、どのように対を使って表現するのか、ということを示す。
<a href="#%_sec_3.3.3">3.3.3</a>節では、テーブルと呼ばれるデータ構造をどのように表現するのか、ということを示そう。
</p>

<p class="orig" lang="en">
A <em>queue</em> is a sequence in which items are inserted at one end
(called the <a name="%_idx_3222"></a><em>rear</em> of the queue) and deleted from the other end
(the <a name="%_idx_3224"></a><em>front</em>).  Figure <a href="#%_fig_3.18">3.18</a> shows an initially empty
queue in which the items <tt>a</tt> and <tt>b</tt> are inserted.  Then <tt>a</tt> is removed, <tt>c</tt> and <tt>d</tt> are inserted, and <tt>b</tt> is
removed.  Because items are always removed in the order in which they
are inserted, a queue is sometimes called a <a name="%_idx_3226"></a><em>FIFO</em> (first in,
first out) buffer.</p>

<p class="trans" lang="ja">
<em><ruby><rb>待ち行列</rb><rp> (</rp><rt>キュー</rt><rp>) </rp></ruby></em>とは、<ruby><rb>項目</rb><rp> (</rp><rt>アイテム</rt><rp>) </rp></ruby>が一方の端 (キューの<em>末尾</em>と呼ばれる) に挿入されて他方の端 (<em>先頭</em>)から削除されるような、列である。
図<a href="#%_fig_3.18">3.18</a>は、最初は空で、<tt>a</tt> と <tt>b</tt> という項目が挿入されるような、キューを示している。
その後、<tt>a</tt> は取り去られ、<tt>c</tt> と <tt>d</tt> が挿入され、<tt>b</tt> が取り去られる。
項目は常に、それらの項目が挿入された順で取り去られるので、時としてキューは、<em>FIFO</em> (first in, first out: 先入れ先出し) バッファと呼ばれる。
</p>

<a name="%_fig_3.18"></a>
<figure>
<table class="common"><tr><td valign=top >Operation </td><td valign=top >Resulting Queue  </td></tr>
<tr><td valign=top ><tt>(define q (make-queue))</tt> </td><td valign=top ></td></tr>
<tr><td valign=top ><tt>(insert-queue! q 'a)</tt> </td><td valign=top ><tt>a</tt></td></tr>
<tr><td valign=top ><tt>(insert-queue! q 'b)</tt> </td><td valign=top ><tt>a b</tt></td></tr>
<tr><td valign=top ><tt>(delete-queue! q)</tt> </td><td valign=top ><tt>b</tt></td></tr>
<tr><td valign=top ><tt>(insert-queue! q 'c)</tt> </td><td valign=top ><tt>b c</tt></td></tr>
<tr><td valign=top ><tt>(insert-queue! q 'd)</tt> </td><td valign=top ><tt>b c d</tt></td></tr>
<tr><td valign=top ><tt>(delete-queue! q)</tt> </td><td valign=top ><tt>c d</tt>
</td></tr></table>
<figcaption class="orig" lang="en"><b>Figure 3.18:</b>  Queue operations.</figcaption>
<figcaption class="trans" lang="ja"><b>図3.18:</b> キューの演算</figcaption>
</figure>


<p class="orig" lang="en">
<a name="%_idx_3228"></a><a name="%_idx_3230"></a>In terms of data abstraction, we can regard a queue as defined by the
following set of operations:</p>

<p class="trans" lang="ja">
データ抽象化の観点からは、キューを、以下の演算の集まりによって定義されたものと見なせる。
</p>

<ul class="orig" lang="en">
<li>a constructor:
<a name="%_idx_3232"></a><tt>(make-queue)</tt>
returns an empty queue (a queue containing no items).</li>

<li>two selectors:
<a name="%_idx_3234"></a><tt>(empty-queue? &lt;<em>queue</em>&gt;)</tt>
tests if the queue is empty.

<a name="%_idx_3236"></a><tt>(front-queue &lt;<em>queue</em>&gt;)</tt>
returns the object at the front of
the queue, signaling an error if the queue is empty; it does not
modify the queue.</li>

<li>two mutators:
<a name="%_idx_3238"></a><tt>(insert-queue! &lt;<em>queue</em>&gt; &lt;<em>item</em>&gt;)</tt>
inserts the item at the rear of the queue and returns the modified
queue as its value.

<a name="%_idx_3240"></a><tt>(delete-queue! &lt;<em>queue</em>&gt;)</tt>
removes the item at the
front of the queue and returns the modified queue as its value,
signaling an error if the queue is empty before the deletion.</li>
</ul>

<ul class="trans" lang="ja">
<li>コンストラクタ: 
<tt>(make-queue)</tt> は、空のキュー (何も項目を含まないキュー
) を返す。</li>
<li>二つのセレクタ: 
<tt>(empty-queue? &lt;<em class="en">queue</em>&gt;)</tt> は、キューが空かどうかを検査する。
<tt>(front-queue &lt;<em class="en">queue</em>&gt;)</tt> は、キューの先頭にあるオブジェクトを返し、もしキューが空ならエラーを知らせる。これは、キューを修正しない。</li>
<li>二つのミューテータ:
<tt>(insert-queue! &lt;<em class="en">queue</em>&gt; &lt;<em class="en">item</em>&gt;)</tt> は、キューの末尾に項目を挿入し、修正後のキューを、値として返す。
<tt>(delete-queue! &lt;<em class="en">queue</em>&gt;)</tt> は、キューの先頭の項目を取り去り、修正後のキューを、値として返す。ただし、もし削除前のキューが空ならば、エラーを知らせる。</li>
</ul>

<p class="orig" lang="en">
Because a queue is a sequence of items, we could certainly represent
it as an ordinary list; the front of the queue would be the <tt>car</tt>
of the list, inserting an item in the queue would amount to appending
a new element at the end of the list, and deleting an item from the
queue would just be taking the <tt>cdr</tt> of the list.  However, this
representation is inefficient, because in order to insert an item we
must scan the list until we reach the end.  Since the only method we
have for scanning a list is by successive <tt>cdr</tt> operations, this
scanning requires <img src="book-Z-G-D-3.gif" border="0">(<em>n</em>) steps for a list of <em>n</em> items.  A simple
modification to the list representation overcomes this disadvantage by
allowing the queue operations to be implemented so that they require
<img src="book-Z-G-D-3.gif" border="0">(1) steps; that is, so that the number of steps
needed is independent of the length of the queue.
</p>

<p class="trans" lang="ja">
キューは項目の列なので、確かに私たちは、キューを普通のリストとして表現することだってできるだろう。つまり、キューの先頭はリストの <tt>car</tt> だろうし、キューに項目を挿入することは、リストの最後に新たな要素を付け加えることに他ならないだろうし、キューから要素を削除することは、まさにリストの <tt>cdr</tt> をとることであろう。
しかし、こんな表現は非効率的だ。なぜなら、項目を挿入するためには、リストを、その最後に到達するまで走査せねばならないのだから。
リストを走査するための手持ちの唯一の方法は、連続的な <tt>cdr</tt> 操作によるものであり、こうした走査は、<em class="en">n</em> 個の項目からなるリストに対して、
<span class="math">&Theta;(<em class="en">n</em>)</span>
ステップを要する。
リスト表現に対する単純な修正で、この欠点を克服できる——キュー操作が、
<span class="math">&Theta;(1)</span>
ステップを要するように、つまり、必要なステップ数がキューの長さに依存しないように、キュー操作を実装することを可能とすることによって。
</p>

<p class="orig" lang="en">
The difficulty with the list representation arises from the need to
scan to find the end of the list.  The reason we need to scan is that,
although the standard way of representing a list as a chain of pairs
readily provides us with a pointer to the beginning of the list, it
gives us no easily accessible pointer to the end.  The modification
that avoids the drawback is to represent the queue as a list, together
with an additional pointer that indicates the final pair in the list.
That way, when we go to insert an item, we can consult the rear
pointer and so avoid scanning the list.</p>

<p class="trans" lang="ja">
リスト表現にともなう困難は、リストの最後を見つけるための走査の必要性に起因する。
走査する必要がある理由とは、こうである。すなわち、リストを対の連なりとして表現するという標準的な方法は、リストの開始点に対するポインタをあっさり提供してくれるとはいえ、末尾への簡単にアクセス可能なポインタを、全然与えてくれないからである。
以上の欠点を回避する修正が、リスト中の最後の対を示す追加的なポインタも一緒に備えた形で、キューをリストとして表現することなのである。
そうすると、項目を挿入しに行くときに、末尾ポインタを調べることができて、よって、リストを走査することを避けられるのだ。
</p>

<p class="orig" lang="en">
A queue is represented, then, as a pair of pointers, <tt>front-ptr</tt>
and <tt>rear-ptr</tt>, which indicate, respectively, the first and last
pairs in an ordinary list.  Since we would like the queue to be an
identifiable object, we can use <tt>cons</tt> to combine the two
pointers.  Thus, the queue itself will be the <tt>cons</tt> of the two
pointers.  Figure <a href="#%_fig_3.19">3.19</a> illustrates this
representation.</p>

<p class="trans" lang="ja">
すると、キューは、一対のポインタ——つまり <tt>front-ptr</tt> と <tt>rear-ptr</tt> ——として表されて、これらのポインタは、それぞれ、普通のリストの中の最初と最後の対を示す。
キューは識別可能なオブジェクトであってほしいので、これら二つのポインタを結びつけるのに <tt>cons</tt> を使うことができる。
よって、キュー自体は、これら二つのポインタの <tt>cons</tt> になるだろう。
図<a href="#%_fig_3.19">3.19</a>は、この表現を示している。
</p>


<a name="%_fig_3.19"></a>
<figure>
<img src="ch3-Z-G-19.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.19:</b>  Implementation of a queue as a list with front and rear
pointers.</figcaption>
<figcaption class="trans" lang="ja"><b>図3.19:</b> 先頭と末尾のポインタを備えたリストとしてのキューの実装</figcaption>
</figure>


<p class="orig" lang="en">
To define the queue operations we use the following procedures, which
enable us to select and to modify the front and rear pointers of a
queue:
</p>

<p class="trans" lang="ja">
キュー操作を定義するために、以下の手続き——これらにより、キューの先頭ポインタと末尾ポインタを選択したり変更したりできるようになる——を使う。
</p>

<p class="lisp"><a name="%_idx_3242"></a>(define (front-ptr queue) (car queue))
<a name="%_idx_3244"></a>(define (rear-ptr queue) (cdr queue))
<a name="%_idx_3246"></a>(define (set-front-ptr! queue item) (set-car! queue item))
<a name="%_idx_3248"></a>(define (set-rear-ptr! queue item) (set-cdr! queue item))
</p>

<p class="orig" lang="en">
Now we can implement the actual queue operations.  We will consider a
queue to be empty if its front pointer is the empty list:
</p>

<p class="trans" lang="ja">
さて今や、実際のキュー操作を実装できる。
もし先頭ポインタが空リストなら、キューが空である、と見なすことにしよう。
</p>

<p class="lisp"><a name="%_idx_3250"></a>(define (empty-queue? queue) (null? (front-ptr queue)))
</p>

<p class="orig" lang="en">
The <tt>make-queue</tt> constructor returns, as an initially empty queue,
a pair whose <tt>car</tt> and <tt>cdr</tt> are both the empty list:
</p>

<p class="trans" lang="ja">
<tt>make-queue</tt> というコンストラクタは、最初の空のキューとして、<tt>car</tt> と <tt>cdr</tt> の双方が空リストの対を、返す。
</p>

<p class="lisp"><a name="%_idx_3252"></a>(define (make-queue) (cons '() '()))
</p>

<p class="orig" lang="en">
To select the item at the front of the queue, we return the <tt>car</tt>
of the pair indicated by the front pointer:
</p>

<p class="trans" lang="ja">
キューの先頭の項目を選択するために、先頭ポインタにより示される対の <tt>car</tt> を返す。
</p>

<p class="lisp"><a name="%_idx_3254"></a>(define (front-queue queue)
  (if (empty-queue? queue)
      (error &quot;FRONT called with an empty queue&quot; queue)
      (car (front-ptr queue))))
</p>

<p class="orig" lang="en">
To insert an item in a queue, we follow the method whose result is
indicated in figure <a href="#%_fig_3.20">3.20</a>.  We first create a new
pair whose <tt>car</tt> is the item to be inserted and whose <tt>cdr</tt> is
the empty list.  If the queue was initially empty, we set the front and
rear pointers of the queue to this new pair.  Otherwise, we modify the
final pair in the queue to point to the new pair, and also set the
rear pointer to the new pair.</p>

<p class="trans" lang="ja">
キューに項目を挿入するためには、図<a href="#%_fig_3.20">3.20</a>に結果が示されている方法にしたがう。
まず、<tt>car</tt> が、その挿入すべき項目であり、かつ、<tt>cdr</tt> が空リストであるような、新たな対を、作成する。
もしキューが元から空だったら、キューの先頭ポインタと末尾ポインタを、この新たな対に設定する。
そうでない場合は、キューの最後の対を、この新たな対を指すように修正し、また、末尾ポインタを、この新たな対に設定する。
</p>

<a name="%_fig_3.20"></a>
<figure>
<img src="ch3-Z-G-20.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.20:</b>  Result of using <tt>(insert-queue! q 'd)</tt> on the queue of figure <a href="#%_fig_3.19">3.19</a>.</figcaption>
<figcaption class="trans" lang="ja"><b>図3.20:</b> </figcaption>
</figure>

<p class="lisp"><a name="%_idx_3256"></a>(define (insert-queue! queue item)
  (let ((new-pair (cons item '())))
    (cond ((empty-queue? queue)
           (set-front-ptr! queue new-pair)
           (set-rear-ptr! queue new-pair)
           queue)
          (else
           (set-cdr! (rear-ptr queue) new-pair)
           (set-rear-ptr! queue new-pair)
           queue)))) 
</p>

<p class="orig" lang="en">
To delete the item at the front of the queue, we merely modify the
front pointer so that it now points at the second item in the queue,
which can be found by following the <tt>cdr</tt> pointer of the first
item (see figure <a href="#%_fig_3.21">3.21</a>):<a name="call_footnote_Temp_366" href="#footnote_Temp_366"><sup><small>22</small></sup></a>
</p>

<p class="trans" lang="ja">
キューの先頭の項目を削除するには、キューの2番目の項目——1番目の項目の <tt>cdr</tt> を追いかけることで見つかる——を今からは指すように、先頭ポインタを修正するだけである (図<a href="#%_fig_3.21">3.21</a>を参照)<a href="#footnote_Temp_366"><sup><small>22</small></sup></a>。
</p>


<a name="%_fig_3.21"></a>
<figure>
<img src="ch3-Z-G-21.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.21:</b>  Result of using <tt>(delete-queue! q)</tt> on the queue of figure <a href="#%_fig_3.20">3.20</a>.</figcaption>
<figcaption class="trans" lang="ja"><b>図3.21:</b> 図<a href="#%_fig_3.20">3.20</a>のキューに対して <tt>(delete-queue! q)</tt> を使った結果</figcaption>
</figure>

<p class="lisp"><a name="%_idx_3258"></a>(define (delete-queue! queue)
  (cond ((empty-queue? queue)
         (error &quot;DELETE! called with an empty queue&quot; queue))
        (else
         (set-front-ptr! queue (cdr (front-ptr queue)))
         queue))) 
</p>

<p class="orig" lang="en">
<a name="%_thm_3.21"></a>
<b>Exercise 3.21.</b>  Ben Bitdiddle decides to test the queue implementation described
above.  He types in the procedures to the Lisp interpreter and
proceeds to try them out:
</p>

<p class="trans" lang="ja">
<b>練習問題3.21.</b> ベン・ビットディドルは、上記のキューの実装をテストすることを決意する。
彼は上記の手続きをLispインタプリタに打ち込んで、これらの手続きがちゃんと動くかどうか試そうとし始める。
</p>

<p class="lisp">(define q1 (make-queue))
(insert-queue! q1 'a)
<i>((a) a)</i>
(insert-queue! q1 'b)
<i>((a b) b)</i>
(delete-queue! q1)
<i>((b) b)</i>
(delete-queue! q1)
<i>(() b)</i>
</p>

<p class="orig" lang="en">
``It's all wrong!'' he complains.  ``The interpreter's response shows
that the last item is inserted into the queue twice.  And when I
delete both items, the second <tt>b</tt> is still there, so the queue
isn't empty, even though it's supposed to be.''  Eva Lu Ator suggests
that Ben has misunderstood what is happening.  ``It's not that the
items are going into the queue twice,'' she explains.  ``It's just
that the standard Lisp printer doesn't know how to make sense of the
queue representation.  If you want to see the queue printed correctly,
you'll have to define your own print procedure for queues.'' Explain
what Eva Lu is talking about.  In particular, show why Ben's examples
produce the printed results that they do.  Define a procedure <a name="%_idx_3260"></a><tt>print-queue</tt> that takes a queue as input and prints the sequence of
items in the queue.
</p>

<p class="trans" lang="ja">
「まったく間違っているじゃないか!」と、彼は文句をたれる。
「インタプリタの応答は、最後の項目がキューに二度挿入されている、っていうことを示しているよね。
それに、僕が両方の項目を消したとき、2番目の方の <tt>b</tt> がまだあって、そのせいでキューは空じゃないんだ。想定されることではあるけれど」
エヴァ・リュ・エイタは、何が起きているかについて、ベンが誤解している、と示唆する。
「項目が二度、キューに入っていっている訳じゃないんだよ」と、彼女は説明する。
「標準的なLispインタプリタが、キュー表現を理解する方法を知らない、ってだけ。
もし正しく印字されたキューを見たいなら、キューのための自分の印字手続きを定義しなくちゃ。」
エヴァ・リュが何について語っているのか、説明せよ。
特に、なぜベンの事例が、これらの事例が作り出すような印字結果を作り出すのかを、示せ。
キューを入力として取り、キューの中の一連の項目を印字するような、<tt>print-queue</tt> という手続きを、定義せよ。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_3.22"></a>
<b>Exercise 3.22.</b>  <a name="%_idx_3262"></a>Instead of representing a queue as a pair of pointers, we can build a
queue as a procedure with local state.  The local state will consist
of pointers to the beginning and the end of an ordinary list.  Thus,
the <tt>make-queue</tt> procedure will have the form
</p>

<p class="trans" lang="ja">
<b>練習問題3.22.</b> 一対のポインタとしてキューを表現する代わりに、局所状態を持つ手続きとしてキューを構築できる。
その局所状態は、通常のリストの開始点へのポインタと末尾へのポインタからなることだろう。
よって、 <tt>make-queue</tt> の手続きは、以下のような形になるだろう。
</p>

<p class="lisp">(define (make-queue)
  (let ((front-ptr <tt>...</tt>)
        (rear-ptr <tt>...</tt>))
    &lt;<em>definitions of internal procedures</em>&gt;
    (define (dispatch m) <tt>...</tt>)
    dispatch))
</p>

<p class="orig" lang="en">
Complete the definition of <tt>make-queue</tt> and provide
implementations of the queue operations using this representation.
</p>

<p class="trans" lang="ja">
<tt>make-queue</tt> の定義を完成させ、そして、この表現を使ってキュー操作の実装を提供せよ。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_3.23"></a>
<b>Exercise 3.23.</b>  <a name="%_idx_3264"></a><a name="%_idx_3266"></a>A <em>deque</em> (``double-ended queue'') is a sequence in which items
can be inserted and deleted at either the front or the rear.
Operations on deques are the constructor <tt>make-deque</tt>, the predicate <tt>empty-deque?</tt>, selectors <tt>front-deque</tt> and <tt>rear-deque</tt>, and mutators <tt>front-insert-deque!</tt>, <tt>rear-insert-deque!</tt>, <tt>front-delete-deque!</tt>, and <tt>rear-delete-deque!</tt>.  Show how to represent deques using pairs, and
give implementations of the operations.<a name="call_footnote_Temp_370" href="#footnote_Temp_370"><sup><small>23</small></sup></a>
All operations should be accomplished in <img src="book-Z-G-D-3.gif" border="0">(1) steps.
</p>

<p class="trans" lang="ja">
<b>練習問題3.23.</b> <em><ruby><rb>デック</rb><rp> (</rp><rt>deque</rt><rp>) </rp></ruby></em> (「両端キュー」)
<span class="note"> (dequeue ではない。念のため)</span>
とは、先頭と末尾のいずれにおいても、項目を挿入したり削除したりできるような、列のことである。
デックに対する演算は、<tt>make-deque</tt> というコンストラクタと、<tt>empty-deque?</tt> という述語と、<tt>front-deque</tt> と <tt>rear-deque</tt> というセレクタと、<tt>front-insert-deque!</tt> と <tt>rear-insert-deque!</tt> と <tt>front-delete-deque!</tt> と <tt>rear-delete-deque!</tt> というミューテータである。
対を使ってどのようにデックを表現するのかを示し、これらの演算の実装を与えよ<a href="#footnote_Temp_370"><sup><small>23</small></sup></a>。
すべての演算は、&Theta;(1) の個数のステップで達成されるべきである。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_3.3.3"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_3.3.3">3.3.3  Representing Tables</a></h3>
<h3 class="trans" lang="ja">3.3.3 テーブルを表現する</h3>

<p class="orig" lang="en">
<a name="%_idx_3268"></a>
<a name="%_idx_3270"></a>When we studied various ways of representing sets in chapter 2, we
mentioned in section <a href="16_sec2_3.html#%_sec_2.3.3">2.3.3</a> the task of
maintaining a table of records indexed by identifying keys.  In the
implementation of data-directed programming in
section <a href="17_sec2_4.html#%_sec_2.4.3">2.4.3</a>, we made extensive use of
two-dimensional tables, in which information is stored and retrieved
using two keys.  Here we see how to build tables as mutable list
structures.</p>

<p class="trans" lang="ja">
2章で集合を表現する様々な方法について検討したときに、<a href="16_sec2_3.html#%_sec_2.3.3">2.3.3</a>節において私たちは、識別キーにより索引付けされたレコード群からなるテーブルを維持するという課題について述べた。
<a href="17_sec2_4.html#%_sec_2.4.3">2.4.3</a>節でのデータ指向プログラミングの実装では、二次元テーブル——二つのキーを使って、情報が格納されたり取り出されたりする——を広範囲にわたって使った。
ここでは、どのようにしてテーブルを変更可能なリスト構造として構築するのか、ということを見よう。
</p>

<p class="orig" lang="en">
<a name="%_idx_3272"></a>We first consider a one-dimensional table, in which each value is
stored under a single key.  We implement the table as a list of
records, each of which is implemented as a pair consisting of a key
and the associated value. The records are glued together to form a
list by pairs whose <tt>car</tt>s point to successive records.  These
gluing pairs are called the <a name="%_idx_3274"></a><em>backbone</em> of the table.  In order to
have a place that we can change when we add a new record to the table,
we build the table as a <a name="%_idx_3276"></a><a name="%_idx_3278"></a><em>headed list</em>.  A headed list has a
special backbone pair at the beginning, which holds a dummy
``record'' -- in this case the arbitrarily chosen symbol <tt>*table*</tt>.
Figure <a href="#%_fig_3.22">3.22</a> shows the box-and-pointer diagram for the table</p>

<p class="trans" lang="ja">
まず、一次元テーブル——それぞれの値が単一のキーの元に格納される——を考える。
レコードのリストとしてテーブルを実装する。なお、それらレコードの各々は、キーと、関連づけられた値とからなる対として、実装される。
連続するレコードをそれぞれの<tt>car</tt>が指し示しているような幾つかの対によるリストを形成するように、レコード群は糊づけされてまとめられる。
これらの糊づけをしている対は、テーブルの<em><ruby><rb>背骨</rb><rp> (</rp><rt>バックボーン</rt><rp>) </rp></ruby></em>と呼ばれる。
テーブルに新たなレコードを追加するときに変更できる場所があるようにしておくために、<em>頭つきのリスト</em>としてテーブルを構築する。
頭つきのリストには、始めに特別な背骨の対があり、これは、ダミーの「レコード」——この場合は、任意に選ばれた <tt>*table*</tt> という記号——を保持している。
図<a href="#%_fig_3.22">3.22</a>は、以下のテーブルについての、箱とポインタの図を示している。
</p>

<p class="lisp">a:  1
b:  2
c:  3
</p>

<a name="%_fig_3.22"></a>
<figure>
<img src="ch3-Z-G-22.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.22:</b>  A table represented as a headed list.</figcaption>
<figcaption class="trans" lang="ja"><b>図3.22:</b> 頭つきのリストとして表現されたテーブル</figcaption>
</figure>

<p class="orig" lang="en">
To extract information from a table we use the <tt>lookup</tt>
procedure, which takes a key as argument and returns the associated
value (or false if there is no value stored under that key).
<tt>Lookup</tt> is defined in terms of the <tt>assoc</tt> operation, which
expects a key and a list of records as arguments.  Note that <tt>assoc</tt> never sees the dummy record.  <tt>Assoc</tt> returns the record
that has the given key as its <tt>car</tt>.<a name="call_footnote_Temp_371" href="#footnote_Temp_371"><sup><small>24</small></sup></a>
<tt>Lookup</tt> then
checks to see that the resulting record returned by <tt>assoc</tt> is not
false, and returns the value (the <tt>cdr</tt>) of the record.</p>

<p class="trans" lang="ja">
テーブルから情報を抽出するためには、<tt>lookup</tt> という手続き——キーを引数としてとり、関連づけられた値 (または、そのキーのもとに格納されている値がない場合は、偽) を返す——を使う。
<tt>lookup</tt> は、<tt>assoc</tt> 演算——キーと、レコードのリストとを、引数として期待する——を使って、定義される。
<tt>assoc</tt> が決してダミーレコードを見ないことに注意せよ。
<tt>assoc</tt> は、与えられたキーを <tt>car</tt> として有するレコードを、返す<a href="#footnote_Temp_371"><sup><small>24</small></sup></a>。
すると、<tt>lookup</tt> は、<tt>assoc</tt> によって返された、結果として得られたレコードが、偽ではないことを確かめて、そのレコードの値 (そのレコードの <tt>cdr</tt>) を返す。
</p>

<p class="lisp"><a name="%_idx_3280"></a>(define (lookup key table)
  (let ((record (assoc key (cdr table))))
    (if record
        (cdr record)
        false)))
<a name="%_idx_3282"></a>(define (assoc key records)
  (cond ((null? records) false)
        ((equal? key (caar records)) (car records))
        (else (assoc key (cdr records)))))
</p>

<p class="orig" lang="en">
To insert a value in a table under a specified key, we first use <tt>assoc</tt> to see if there is already a record in the table with this key.
If not, we form a new record by <tt>cons</tt>ing the key with the value,
and insert this at the head of the table's list of records, after the
dummy record.  If there already is a record with this key, we set the
<tt>cdr</tt> of this record to the designated new value.  The header of
the table provides us with a fixed location to modify in order to
insert the new record.<a name="call_footnote_Temp_372" href="#footnote_Temp_372"><sup><small>25</small></sup></a></p>

<p class="trans" lang="ja">
指定されたキーのもとに値をテーブルに挿入するには、まず <tt>assoc</tt>を使って、このキーを持ったレコードが既にテーブルの中にあるかどうかを見る。
もしなければ、キーと値を <tt>cons</tt> することで新たなレコードを形成し、これを、このテーブルのレコードのリストの先頭——ただしダミーレコードの後——に挿入する。
もし、このキーを持ったレコードが既にあれば、このレコードの <tt>cdr</tt> を、指定された新たな値に設定する。
テーブルのヘッダは、新たなレコードを挿入するために修正すべき定位置を、与えてくれるのだ<a href="#footnote_Temp_372"><sup><small>25</small></sup></a>。
</p>

<p class="lisp"><a name="%_idx_3284"></a>(define (insert! key value table)
  (let ((record (assoc key (cdr table))))
    (if record
        (set-cdr! record value)
        (set-cdr! table
                  (cons (cons key value) (cdr table)))))
  'ok)
</p>

<p class="orig" lang="en">
To construct a new table, we simply create a list containing the
symbol <tt>*table*</tt>:</p>

<p class="trans" lang="ja">
新たなテーブルを構築するためには、単純に、<tt>*table*</tt> という記号を含むリストを作成する。
</p>

<p class="lisp"><a name="%_idx_3286"></a>(define (make-table)
  (list '*table*))
</p>


<a name="%_sec_Temp_373"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_373">Two-dimensional tables</a></h4>
<h4 class="trans" lang="ja">2次元のテーブル</h4>

<p class="orig" lang="en">
<a name="%_idx_3288"></a>
In a two-dimensional table, each value is indexed by two keys.  We can
construct such a table as a one-dimensional table in which each key
identifies a subtable.
Figure <a href="#%_fig_3.23">3.23</a> shows the box-and-pointer diagram for the table
</p>

<p class="trans" lang="ja">
二次元テーブルでは、それぞれの値が二つのキーにより索引づけされている。
そういうテーブルを、それぞれのキーが下位テーブルを識別しているような一次元テーブルとして、構築することができる。
図<a href="#%_fig_3.23">3.23</a>は、以下のテーブルに対する、箱とポインタの図を示している。
</p>

<p class="lisp">math:
    +:  43
    -:  45
    *:  42
letters:
    a:  97
    b:  98
</p>

<p class="orig" lang="en">
which has two subtables.  (The subtables don't need a
special header symbol, since the key that identifies the subtable
serves this purpose.)
</p>

<p class="trans" lang="ja">
なおこれは二つの下位テーブルを含む。
(これらの下位テーブルは、特別なヘッダ記号を必要としない。というのも、下位テーブルを識別するキーが、この目的を果たしているからである。)
</p>

<a name="%_fig_3.23"></a>
<figure>
<img src="ch3-Z-G-23.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.23:</b>  A two-dimensional table.</figcaption>
<figcaption class="trans" lang="ja"><b>図3.23:</b> 二次元テーブル</figcaption>
</figure>

<p class="orig" lang="en">
When we look up an item, we use the first key
to identify the correct subtable.  Then we use the second key to
identify the record within the subtable.</p>

<p class="trans" lang="ja">
ある項目を引く場合、正しい下位テーブルを識別するために、第一のキーを使う。
それから、その下位テーブルの内部でレコードを識別するために、第二のキーを使う。
</p>

<p class="lisp"><a name="%_idx_3290"></a>(define (lookup key-1 key-2 table)
  (let ((subtable (assoc key-1 (cdr table))))
    (if subtable
        (let ((record (assoc key-2 (cdr subtable))))
          (if record
              (cdr record)
              false))
        false)))
</p>

<p class="orig" lang="en">
To insert a new item under a pair of keys, we use <tt>assoc</tt> to see if
there is a subtable stored under the first key.  If not, we build a
new subtable containing the single record (<tt>key-2</tt>, <tt>value</tt>)
and insert it into the table under the first key.  If a subtable
already exists for the first key, we insert the new record into this
subtable, using the insertion method for one-dimensional tables
described above:</p>

<p class="trans" lang="ja">
一組のキーのもとに新たな項目を挿入するには、<tt>assoc</tt> を使って、第一のキーのもとに格納された下位テーブルがあるかどうかを調べる。
もしなければ、(<tt>key-2</tt>, <tt>value</tt>) というただ一つのレコードを含む新たな下位テーブルを構築し、それを第一のキーのもとに表に挿入する。
もし既に第一のキーに対して下位テーブルが存在していれば、上記の一次元テーブル用の挿入手法を使って、この下位テーブルに新たなレコードを挿入する。
</p>

<p class="lisp"><a name="%_idx_3292"></a>(define (insert! key-1 key-2 value table)
  (let ((subtable (assoc key-1 (cdr table))))
    (if subtable
        (let ((record (assoc key-2 (cdr subtable))))
          (if record
              (set-cdr! record value)
              (set-cdr! subtable
                        (cons (cons key-2 value)
                              (cdr subtable)))))
        (set-cdr! table
                  (cons (list key-1
                              (cons key-2 value))
                        (cdr table)))))
  'ok)
</p>

<a name="%_sec_Temp_374"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_374">Creating local tables</a></h4>
<h4 class="trans" lang="ja">局所的なテーブルを作成する</h4>

<p class="orig" lang="en">
<a name="%_idx_3294"></a>
The <tt>lookup</tt> and <tt>insert!</tt> operations defined above take the
table as an argument.  This enables us to use programs that access
more than one table.  Another way to deal with multiple tables is to
have separate <tt>lookup</tt> and <tt>insert!</tt> procedures for each
table.  We can do this by representing a table procedurally, as an
object that maintains an internal table as part of its local state.
When sent an appropriate message, this ``table object'' supplies the
procedure with which to operate on the internal table.  Here is a
generator for two-dimensional tables represented in this fashion:</p>

<p class="trans" lang="ja">
上記で定義した <tt>lookup</tt> と <tt>insert!</tt> の操作は、テーブルを引数としてとる。
これによって、一つよりも多いテーブルにアクセスするプログラムを使うことが可能になる。
複数のテーブルを扱うための別の方法は、各テーブルに対して <tt>lookup</tt> と <tt>insert!</tt> の手続きを持っておくことだ。
局所状態の一部として内部テーブルを維持するようなオブジェクトとして、テーブルを手続き的に表現することにより、これを行うことが可能である。
適切なメッセージが送られたとき、この「テーブル・オブジェクト」は、内部テーブルに対して操作を行うときに使う手続きを与える。
こうした流儀で表現された二次元のテーブル用の生成器を、ここに示す。
</p>

<p class="lisp"><a name="%_idx_3296"></a>(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup key-1 key-2)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (cdr record)
                  false))
            false)))
    (define (insert! key-1 key-2 value)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1
                                  (cons key-2 value))
                            (cdr local-table)))))
      'ok)    
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error &quot;Unknown operation -- TABLE&quot; m))))
    dispatch))
</p>

<p class="orig" lang="en">
Using <tt>make-table</tt>, we could implement the <tt>get</tt> and <tt>put</tt>
operations used in section <a href="17_sec2_4.html#%_sec_2.4.3">2.4.3</a> for data-directed
programming, as follows:</p>

<p class="trans" lang="ja">
<tt>make-table</tt> を使えば、データ指向プログラミング用に<a href="17_sec2_4.html#%_sec_2.4.3">2.4.3</a>節で使った <tt>get</tt> と <tt>put</tt>
の操作を以下のようにして実装することができよう。</p>

<p class="lisp"><a name="%_idx_3298"></a>(define operation-table (make-table))
<a name="%_idx_3300"></a>(define get (operation-table 'lookup-proc))
<a name="%_idx_3302"></a>(define put (operation-table 'insert-proc!))
</p>

<p class="orig" lang="en">
<tt>Get</tt> takes as arguments two keys, and <tt>put</tt> takes
as arguments two keys and a value.  Both operations access the same
local table, which is encapsulated within the object created by the
call to <tt>make-table</tt>.</p>

<p class="trans" lang="ja">
<tt>get</tt> は引数として二つのキーをとり、<tt>put</tt> は引数として二つのキーと一つの値とをとる。
双方の操作は、同じ局所テーブル——<tt>make-table</tt> に対する呼び出しによって作成されたオブジェクト内にカプセル化されている——に、アクセスする。
</p>

<p class="orig" lang="en"><a name="%_thm_3.24"></a>
<b>Exercise 3.24.</b>  <a name="%_idx_3304"></a><a name="%_idx_3306"></a>In the table implementations above, the keys are tested for equality
using <tt>equal?</tt> (called by <tt>assoc</tt>).  This is not always the appropriate test.  For
instance, we might have a table with numeric keys in which we don't
need an exact match to the number we're looking up,
but only a number within some tolerance of it.
Design a table constructor <tt>make-table</tt> that takes as an argument a <tt>same-key?</tt> procedure
that will be used to test ``equality'' of keys.  <tt>Make-table</tt> should
return a <tt>dispatch</tt> procedure that can be used to access
appropriate <tt>lookup</tt> and <tt>insert!</tt> procedures for a local
table.

<p class="trans" lang="ja">
<b>練習問題3.24.</b> 上記のテーブルの実装において、キーは、同一性について、<tt>equal?</tt> (<tt>assoc</tt> により呼び出されている) を用いて検査されている。
これは、常に適切な検査というわけではない。
たとえば、いま調べている数との厳密な一致は必要なくて、その数の何らかの許容範囲内の数だけが必要だ、というような、数値キーを持ったテーブルが、あるかもしれない。
キー同士の「同一性」を検査するのに使われるであろう、<tt>same-key?</tt> という手続きを引数としてとる、<tt>make-table</tt> というテーブル・コンストラクタを、設計せよ。
<tt>make-table</tt> は、局所テーブルにとって適切な <tt>lookup</tt> と <tt>insert!</tt> にアクセスするのに使えるような、<tt>dispatch</tt> という手続きを返すべきである。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.25"></a>
<b>Exercise 3.25.</b>  <a name="%_idx_3308"></a>Generalizing one- and two-dimensional tables, show how to implement a
table in which values are stored under an arbitrary number of keys and
different values may be stored under different numbers of keys.  The
<tt>lookup</tt> and <tt>insert!</tt> procedures should take as input a list
of keys used to access the table.
</p>

<p class="trans" lang="ja">
<b>練習問題3.25.</b> 任意の個数のキーのもとに値が格納され、かつ、異なる値は異なる複数個のキーのもとに格納され得るようなテーブルを実装する方法を、一次元と二次元のテーブルを一般化することで、示せ。
<tt>lookup</tt> と <tt>insert!</tt> の手続きは、テーブルにアクセスするのに使われるキーのリストを、入力として取るべきである。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.26"></a>
<b>Exercise 3.26.</b>  <a name="%_idx_3310"></a><a name="%_idx_3312"></a>To search a table as implemented above, one needs to scan through the
list of records.  This is basically the unordered list representation of
section <a href="16_sec2_3.html#%_sec_2.3.3">2.3.3</a>.  For large tables, it may be more
efficient to structure the table in a different manner.  Describe a
table implementation where the (key, value) records are organized
using a binary tree, assuming that keys can be ordered in some way
(e.g., numerically or alphabetically).  (Compare
exercise <a href="16_sec2_3.html#%_thm_2.66">2.66</a> of chapter 2.)
</p>

<p class="trans" lang="ja">
<b>練習問題3.26.</b> 上記のように実装されたテーブルを検索するためには、レコードのリスト全体を走査する必要がある。
これは基本的には、<a href="16_sec2_3.html#%_sec_2.3.3">2.3.3</a>節の順序なしリスト表現である。
大きなテーブルに対しては、テーブルを別のやり方で構造化する方が、より効率的かもしれない。
<span class="math">(キー, 値)</span> のレコードが、二分木を使って組織化されているようなテーブル実装について、説明せよ——ただし、何らかの方法によって (たとえば、数値的に、または、アルファベット順に) キーを順序づけることができるものと想定する。
(2章の練習問題<a href="16_sec2_3.html#%_thm_2.66">2.66</a>と比較せよ。)
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.27"></a>
<b>Exercise 3.27.</b>  <a name="%_idx_3314"></a><a name="%_idx_3316"></a><a name="%_idx_3318"></a><a name="%_idx_3320"></a><em>Memoization</em> (also called <em>tabulation</em>) is a technique that
enables a procedure to record, in a local table, values that have
previously been computed.  This technique can make a vast difference
in the performance of a program.  A memoized procedure maintains a
table in which values of previous calls are stored
using as keys the arguments that produced the values.  When the
memoized procedure is asked to compute a value, it first checks the
table to see if the value is already there and, if so, just returns
that value.  Otherwise, it computes the new value in the ordinary way
and stores this in the table.  As an example of memoization, recall
from section <a href="11_sec1_2.html#%_sec_1.2.2">1.2.2</a> the exponential process for
computing Fibonacci numbers:
</p>


<p class="trans" lang="ja">
<b>練習問題3.27.</b> <em>メモ化</em> (<em>表作成</em>とも呼ばれる) は、以前すでに計算されたことのある値を、手続きが局所テーブルに記録することを、可能とする技法である。
この技法は、プログラムの性能に非常な相違をもたらす可能性がある。
以前の呼び出しの値が、その値を生み出した引数をキーとして使って、格納されているようなテーブルを、メモ化された手続きは維持する。
メモ化された手続きは、値を計算するように求められたときには、まずテーブルを検査して、その値が既にそこにあるかどうかを調べ、もしあれば、ただその値を返す。
そうでない場合は、普通のやり方で新たな値を計算して、この値をテーブルに格納する。
メモ化の例として、<a href="11_sec1_2.html#%_sec_1.2.2">1.2.2</a>節から、フィボナッチ数を計算するための指数的なプロセスを思い出そう。
</p>

<p class="lisp"><a name="%_idx_3322"></a>(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))
</p>

<p class="orig" lang="en">
The memoized version of the same procedure is
</p>

<p class="trans" lang="ja">
同じ手続きのメモ化されたバージョンは、
</p>

<p class="lisp"><a name="%_idx_3324"></a>(define memo-fib
  (memoize (lambda (n)
             (cond ((= n 0) 0)
                   ((= n 1) 1)
                   (else (+ (memo-fib (- n 1))
                            (memo-fib (- n 2))))))))
</p>

<p class="orig" lang="en">
where the memoizer is defined as
</p>

<p class="trans" lang="ja">
であり、ここで、<ruby><rb>メモ化するもの</rb><rp> (</rp><rt>メモワイザ</rt><rp>) </rp></ruby>は、以下のように定義される。
</p>

<p class="lisp"><a name="%_idx_3326"></a>(define (memoize f)
  (let ((table (make-table)))
    (lambda (x)
      (let ((previously-computed-result (lookup x table)))
        (or previously-computed-result
            (let ((result (f x)))
              (insert! x result table)
              result))))))
</p>

<p class="orig" lang="en">
Draw an environment diagram to analyze the computation of <tt>(memo-fib 3)</tt>.  Explain why <tt>memo-fib</tt> computes the <em>n</em>th
Fibonacci number in a number of steps proportional to <em>n</em>.
Would the scheme still
work if we had simply defined <tt>memo-fib</tt> to be <tt>(memoize
fib)</tt>?

<p class="trans" lang="ja">
<tt>(memo-fib 3)</tt> の計算を分析する環境図を描け。
なぜ <tt>memo-fib</tt> は <em class="en">n</em> 番目のフィボナッチ数を <em class="en">n</em> に比例するステップ数で計算するのか、について説明せよ。
もし単純に <tt>memo-fib</tt> を <tt>(memoize fib)</tt> と定義していたとしても、この方法は依然としてうまくいっただろうか?
</p>

<p class="exercise"><span class="ex_comment">
</span></p>


<a name="%_sec_3.3.4"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_3.3.4">3.3.4  A Simulator for Digital Circuits</a></h3>
<h3 class="trans" lang="ja">3.3.4 ディジタル回路のシミュレータ</h3>

<p class="orig" lang="en">
<a name="%_idx_3328"></a>
Designing complex digital systems, such as computers, is an important
engineering activity.  Digital systems are constructed by
interconnecting simple elements.  Although the behavior of these
individual elements is simple, networks of them can have very complex
behavior.  Computer simulation of proposed circuit designs is an
important tool used by digital systems engineers.  In this section we
design a system for performing digital logic simulations.  This system
typifies a kind of program called an <a name="%_idx_3330"></a><a name="%_idx_3332"></a><em>event-driven simulation</em>, in
which actions (``events'') trigger further events that happen at a
later time, which in turn trigger more events, and so so.</p>

<p class="trans" lang="ja">
複雑なディジタルシステム——たとえばコンピュータのようなもの——を設計することは、重要な工学的活動である。
ディジタルシステムは、単純な要素同士を相互接続することによって、構築される。
これらの個々の要素の振る舞いは単純なのだが、それらでできた網状組織は、非常に複雑な振る舞いをすることが可能だ。
提案された回路設計のコンピュータ・シミュレーションは、ディジタルシステム技術者によって使われる、重要な道具である。
本節では、ディジタル論理シミュレーションを実行するためのシステムを設計する。
このシステムは、<em>イベント駆動シミュレーション</em>——活動 (「イベント」) が、後に起こる更なるイベントの引き金となり、その更なるイベントが今度はまた別のイベントの引き金となり、以下同様である——と呼ばれる、ある種のプログラムを代表するものである。
</p>

<p class="orig" lang="en">
Our computational model of a circuit will be composed of objects that
correspond to the elementary components from which the circuit is
constructed.  There are <a name="%_idx_3334"></a><em>wires</em>, which carry <a name="%_idx_3336"></a><a name="%_idx_3338"></a><em>digital signals</em>.  A
digital signal may at any moment have only one of two possible values,
0 and 1.  There are also various types of digital <a name="%_idx_3340"></a><em>function
boxes</em>, which connect wires carrying input signals to other output
wires.  Such boxes produce output signals computed from their input
signals.  The output signal is <a name="%_idx_3342"></a>delayed by a time that depends on the
type of the function box.  For example, an <a name="%_idx_3344"></a><em>inverter</em> is a
primitive function box that inverts its input.  If the
input signal to an inverter changes to 0, then one inverter-delay
later the inverter will change its output signal to 1.  If the input
signal to an inverter changes to 1, then one inverter-delay later the
inverter will change its output signal to 0.  We draw an inverter
symbolically as in figure <a href="#%_fig_3.24">3.24</a>.  An <a name="%_idx_3346"></a><em>and-gate</em>,
also shown in figure <a href="#%_fig_3.24">3.24</a>, is a primitive function
box with two inputs and one output.  It drives its output signal to a
value that is the <a name="%_idx_3348"></a><em>logical and</em> of the inputs.  That is, if both
of its input signals become 1, then one and-gate-delay time later the
and-gate will force its output signal to be 1; otherwise the output
will be 0.  An <a name="%_idx_3350"></a><em>or-gate</em> is a similar two-input primitive function
box that drives its output signal to a value that is the <a name="%_idx_3352"></a><em>logical
or</em> of the inputs.  That is, the output will become 1 if at least one
of the input signals is 1; otherwise the output will become 0.</p>

<p class="trans" lang="ja">
回路についての私たちの計算モデルは、その回路を構築する元となっている基本的構成要素に対応するようなオブジェクトから、構成されるであろう。
<em>配線</em>——<em>ディジタル信号</em>を伝える——がある。
ディジタル信号は、任意の時点において、二つの可能な値——すなわち0と1——のうちの、ただ一つの値をとるだろう。
また、多くの種類のディジタル<em>機能ボックス</em>——入力信号を伝える配線を、他の出力配線につなげる——がある。
そういったボックスは、自分への入力信号から計算される出力信号を作り出す。
出力信号は、その機能ボックスの種類に応じた時間だけ、遅延される。
たとえば、<em>インバータ</em>は、入力を反転させるような、原始的機能ボックスである。
インバータへの入力信号が0へと変化すると、インバータ遅延の1単位分だけ後に、インバータは、その出力信号を1へと変化させるだろう。
インバータへの入力信号が1へと変化すると、インバータ遅延の1単位分だけ後に、インバータは、その出力信号を0へと変化させるだろう。
私たちは、図<a href="#%_fig_3.24">3.24</a>のように、インバータを記号的に描く。
<em>ANDゲート</em>——これも図<a href="#%_fig_3.24">3.24</a>に示されている——は、二つの入力と一つの出力を持った、原始的機能ボックスである。
これは、入力の<em>論理積</em>であるような値へと、その出力信号を駆動する。
つまり、入力信号の双方が1になったら、ANDゲート遅延時間の1単位分だけ後に、ANDゲートは、その出力信号を1にするだろう。それ以外の場合、出力は0になるだろう。
<em>ORゲート</em>は、類似の2入力の原始的機能ボックスで、入力の<em>論理和</em>であるような値へと、その出力信号を駆動するものである。
つまり、入力信号のうち少なくとも一つが1のときに、出力が1となるだろうし、それ以外の場合は、出力が0となるだろう。
</p>

<a name="%_fig_3.24"></a>
<figure>
<img src="ch3-Z-G-24.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.24:</b>  Primitive functions in the digital logic simulator.</figcaption>
<figcaption class="trans" lang="ja"><b>図3.24:</b> ディジタル論理シミュレータにおける原始的機能</figcaption>
</figure>


<p class="orig" lang="en">
We can connect primitive functions together to construct more complex
functions.  To accomplish this we wire the outputs of some
function boxes to the inputs of other function boxes.  For example,
the <a name="%_idx_3354"></a><a name="%_idx_3356"></a><em>half-adder</em> circuit shown in figure <a href="#%_fig_3.25">3.25</a> consists of an
or-gate, two and-gates, and an inverter.  It takes two input signals,
A and B, and has two output signals, S and C.  S will become 1
whenever precisely one of A and B is 1, and C will become 1 whenever A
and B are both 1.  We can see from the figure that, because of the
delays involved, the outputs may be generated at different times.
Many of the difficulties in the design of digital circuits arise from
this fact.</p>

<p class="trans" lang="ja">
原始的な機能同士を接続して、より複雑な機能を構築することができる。
これを達成するために、私たちは、いくつかの機能ボックスの出力を、他の機能ボックスの入力へと配線でつなぐ。
たとえば、図<a href="#%_fig_3.25">3.25</a>に示した<em>ハーフ・アダー</em> (半加算器) 回路は、一つのORゲートと、二つのANDゲートと、一つのインバータと、からなる。
これは二つの入力信号——つまり、AとB——をとり、二つの出力信号——つまり、SとC——を持つ。
AとBのうちのちょうどまさに一つが1のときにはいつでも、Sが1になるだろうし、AとBがともに1のときにはいつでも、Cが1になるだろう。
そこに伴う遅延のせいで、異なる時点において出力が生成されるかもしれない、ということが、図から分かる。
ディジタル回路の設計における困難の多くは、この事実から生じる。
</p>

<a name="%_fig_3.25"></a>
<figure>
<img src="ch3-Z-G-25.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.25:</b>  A half-adder circuit.</figcaption>
<figcaption class="trans" lang="ja"><b>図3.25:</b> ハーフ・アダー回路</figcaption>
</figure>

<div class="exercise"><table class="expl">
<tr><th>A</th><th>B</th><th>C <br>(= A AND B)</th><th>D <br>(= A OR B)</th><th>E <br>(= NOT C)</th><th>S <br>(= D AND E)</th></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr>
<tr><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td></tr>
</table></div>

<p class="orig" lang="en">
We will now build a program for modeling the digital logic circuits we
wish to study.  The program will construct computational objects
modeling the wires, which will ``hold'' the signals.  Function boxes
will be modeled by procedures that enforce the correct relationships
among the signals.</p>

<p class="trans" lang="ja">
さてこれから、研究したいディジタル論理回路をモデル化するためのプログラムを構築しよう。
プログラムは、配線——信号を「保持」することだろう——をモデル化する計算オブジェクトを構築するだろう。
機能ボックスは、信号同士の間の正しい関係を強制するような手続きによって、モデル化されるだろう。
</p>

<p class="orig" lang="en">
<a name="%_idx_3358"></a>One basic element of our simulation will be a procedure <tt>make-wire</tt>, which constructs wires.  For example, we can construct six
wires as follows:</p>

<p class="trans" lang="ja">
私たちのシミュレーションにおける一つの基本的要素は、<tt>make-wire</tt> という手続き——配線を構築する——であろう。
たとえば、6本の配線を以下のように構築できる。
</p>

<p class="lisp">(define a (make-wire))
(define b (make-wire))
(define c (make-wire))

(define d (make-wire))
(define e (make-wire))
(define s (make-wire))
</p>

<p class="orig" lang="en">
We attach a function box to a set of wires by calling a procedure that
constructs that kind of box.  The arguments to the constructor
procedure are the wires to be attached to the box.  For example, given
that we can construct and-gates, or-gates, and inverters, we can wire
together the half-adder shown in figure <a href="#%_fig_3.25">3.25</a>:</p>

<p class="trans" lang="ja">
私たちは、機能ボックスを、その種類のボックスを構築する手続きを呼び出すことによって、配線の集合につなげる。
コンストラクタ手続きに対する実引数は、そのボックスにつながれるべき配線である。
たとえば、ANDゲートとORゲートとインバータを構築できるものとすると、図<a href="#%_fig_3.25">3.25</a>に示したハーフ・アダーを配線でつないでまとめあげることができる。
</p>

<p class="lisp">(or-gate a b d)
<i>ok</i>

(and-gate a b c)
<i>ok</i>

(inverter c e)
<i>ok</i>

(and-gate d e s)
<i>ok</i>
</p>

<p class="orig" lang="en">
Better yet, we can explicitly name this operation by defining a procedure <tt>half-adder</tt> that constructs this circuit, given the four
external wires to be attached to the half-adder:</p>

<p class="trans" lang="ja">
ハーフ・アダーにつながれるべき、外部の4本の配線を与えられると、この回路を構築するような、<tt>half-adder</tt> という手続きを定義することによって、私たちは、もっと良いことには、この演算に明示的に名前をつけられるのである。
</p>

<p class="lisp"><a name="%_idx_3360"></a>(define (half-adder a b s c)
  (let ((d (make-wire)) (e (make-wire)))
    (or-gate a b d)
    (and-gate a b c)
    (inverter c e)
    (and-gate d e s)
    'ok))
</p>

<p class="orig" lang="en">
The advantage of making this definition is that we can use
<tt>half-adder</tt> itself as a building block in creating more complex
circuits.  Figure <a href="#%_fig_3.26">3.26</a>, for example, shows a <a name="%_idx_3362"></a><a name="%_idx_3364"></a><em>full-adder</em> composed of two half-adders and an or-gate.<a name="call_footnote_Temp_379" href="#footnote_Temp_379"><sup><small>26</small></sup></a> We can construct a full-adder
as follows:</p>

<p class="trans" lang="ja">
こういう定義を行うことの利点は、より複雑な回路を作成する際の基本構成要素として、<tt>half-adder</tt> 自体を使える点である。
たとえば、図<a href="#%_fig_3.26">3.26</a>は、二つのハーフ・アダーと一つのORゲートから構成される、<em>フル・アダー</em> (全加算器) を示している<a href="#footnote_Temp_379"><sup><small>26</small></sup></a> 。
フル・アダーは以下のようにして構築できる。
</p>

<p class="lisp"><a name="%_idx_3366"></a>(define (full-adder a b c-in sum c-out)
  (let ((s (make-wire))
        (c1 (make-wire))
        (c2 (make-wire)))
    (half-adder b c-in s c1)
    (half-adder a s sum c2)
    (or-gate c1 c2 c-out)
    'ok))
</p>

<p class="orig" lang="en">
Having defined <tt>full-adder</tt> as a procedure, we can now use it as a
building block for creating still more complex circuits.  (For
example, see exercise <a href="#%_thm_3.30">3.30</a>.)</p>

<p class="trans" lang="ja">
<tt>full-adder</tt> を手続きとして定義したので、私たちは今やそれを、まだまださらに複雑な回路を作成するための基本構成要素として、用いることができる。
(たとえば、練習問題<a href="#%_thm_3.30">3.30</a>を参照)。
</p>

<a name="%_fig_3.26"></a>
<figure>
<img src="ch3-Z-G-26.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.26:</b>  A full-adder circuit.</figcaption>
<figcaption class="trans" lang="ja"><b>図3.26:</b> フル・アダー回路</figcaption>
</figure>

<div class="exercise"><table class="expl">
<tr><th colspan="3">入力</th><th colspan="2">下のHAの出力</th><th colspan="2">上のHAの出力</th><th>ORゲートの出力</th></tr>
<tr><th>A</th><th>B</th><th>Cin</th><th>S</th><th>C1</th><th>SUM</th><th>C2</th><th>Cout (=C1 OR C2)</th></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td></tr>
</table></div>

<p class="orig" lang="en">
In essence, our simulator provides us with the tools to construct a
language of circuits.  If we adopt the general perspective on
languages with which we approached the study of Lisp in
section <a href="10_sec1_1.html#%_sec_1.1">1.1</a>,
we can say that the primitive function boxes form the primitive
elements of the language, that wiring boxes together provides a means
of combination, and that specifying wiring patterns as procedures
serves as a means of abstraction.</p>

<p class="trans" lang="ja">
本質的には、私たちのシミュレータは、回路の言語を構築するための手段を提供してくれるのである。
もし、<a href="10_sec1_1.html#%_sec_1.1">1.1</a>節でLispの勉強にとりかかったときに使った、言語についての一般的な視点を採用するなら、次のように言えるだろう。つまり、原始的な機能ボックスは言語の原始的要素を形成し、それと同時に配線のボックスは結合手段を提供し、配線パタンを手続きとして指定することは抽象化手段として役立つのである、と。
</p>


<a name="%_sec_Temp_380"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_380">Primitive function boxes</a></h4>
<h4 class="trans" lang="ja">原始的な機能ボックス</h4>


<p class="orig" lang="en">
<a name="%_idx_3368"></a>
The primitive function boxes implement the ``forces'' by which a
change in the signal on one wire influences the signals on other
wires.  To build function boxes, we use the following operations on
wires:</p>

<p class="trans" lang="ja">
原始的な機能ボックスは、1本の配線上の信号の変化が他の配線上の信号に影響を及ぼす際にその手段となる「力」を実装する。
機能ボックスを構築するには、配線に対する以下の演算を使う。
</p>


<ul class="orig" lang="en">
<li><tt>(get-signal &lt;<em>wire</em>&gt;)</tt>
<a name="%_idx_3370"></a>returns the current value of the signal on the wire.</li>

<li><tt>(set-signal! &lt;<em>wire</em>&gt; &lt;<em>new value</em>&gt;)</tt>
<a name="%_idx_3372"></a>changes the value of the signal on the wire to the new value.</li>

<li><tt>(add-action! &lt;<em>wire</em>&gt; &lt;<em>procedure of no arguments</em>&gt;)</tt>
<a name="%_idx_3374"></a>asserts that the designated procedure should be run whenever the
signal on the wire changes value.  Such procedures are the vehicles by
which changes in the signal value on the wire are communicated to
other wires.</li>
</ul>

<ul class="trans" lang="ja">
<li><tt>(get-signal &lt;<em class="en">wire</em>&gt;)</tt> は、その配線上の信号の現在の値を返す。</li>
<li><tt>(set-signal! &lt;<em class="en">wire</em>&gt; &lt;<em class="en">new value</em>&gt;)</tt> は、その配線上の信号の値を新たな値に変更する。</li>
<li><tt>(add-action! &lt;<em class="en">wire</em>&gt; &lt;<em class="en">procedure of no arguments</em>&gt;)</tt>  は、その配線上の信号の値が値を変化させるときにはいつでも、指定された手続きを実行すべきであることを主張する。
このような手続きは、配線上の信号値の変化を他の配線へと伝える伝達媒体なのである。</li>
</ul>

<p class="orig" lang="en">
<a name="%_idx_3376"></a>In addition, we will make use of a procedure <tt>after-delay</tt> that
takes a time delay and a procedure to be run and executes the
given procedure after the given delay.</p>

<p class="trans" lang="ja">
さらに、時間の遅延と、実行すべき手続きとを取り、与えられた遅延の後に与えられた手続きを実行するような、<tt>after-delay</tt> という手続きを利用することにしよう。
</p>

<p class="orig" lang="en">
Using these procedures, we can define the primitive digital logic
functions.  To connect an input to an output through an inverter, we
use <tt>add-action!</tt> to associate with the input wire a procedure
that will be run whenever the signal on the input wire changes value.
The procedure computes the <tt>logical-not</tt> of the input signal, and
then, after one <tt>inverter-delay</tt>, sets the output signal to be
this new value:</p>

<p class="trans" lang="ja">
これらの手続きを使うと、原始的なディジタル論理関数を定義できる。
インバータを介して入力を出力へつなぐには、<tt>add-action!</tt> を使って、入力配線に、その入力配線上の信号が値を変更するときにはいつでも実行されることになるだろう手続きを、関連づける。
その手続きは、入力信号の <tt>logical-not</tt> (論理否定) を計算し、それから、<tt>inverter-delay</tt> (インバータ遅延) の1回分だけ後に、出力信号をこの新たな値へと設定する。
</p>


<p class="lisp"><a name="%_idx_3378"></a>(define (inverter input output)
  (define (invert-input)
    (let ((new-value (logical-not (get-signal input))))
      (after-delay inverter-delay
                   (lambda ()
                     (set-signal! output new-value)))))
  (add-action! input invert-input)
  'ok)
<a name="%_idx_3380"></a>(define (logical-not s)
  (cond ((= s 0) 1)
        ((= s 1) 0)
        (else (error &quot;Invalid signal&quot; s))))
</p>

<p class="orig" lang="en">
An and-gate is a little more complex.  The action procedure must be run if
either of the inputs to the gate changes.  It computes the <tt>logical-and</tt> (using a procedure analogous to <tt>logical-not</tt>) of the
values of the signals on the input wires and sets up a change to the
new value to occur on the output wire after one <tt>and-gate-delay</tt>.</p>

<p class="trans" lang="ja">
ANDゲートは、もう少し複雑である。
動作の手続きは、ゲートへの入力のうちの一方が変化したら、実行されねばならないのである。
この手続きは、入力配線上の信号の値同士の <tt>logical-and</tt> (論理積) を、(<tt>logical-not</tt> と似た手続きを使って) 計算し、新たな値への変更を、<tt>and-gate-delay</tt> (ANDゲート遅延) の1回分だけ後に出力配線上に生じるように、設定するのだ。
</p>

<p class="lisp"><a name="%_idx_3382"></a>(define (and-gate a1 a2 output)
  (define (and-action-procedure)
    (let ((new-value
           (logical-and (get-signal a1) (get-signal a2))))
      (after-delay and-gate-delay
                   (lambda ()
                     (set-signal! output new-value)))))
  (add-action! a1 and-action-procedure)
  (add-action! a2 and-action-procedure)
  'ok)
</p>

<p class="orig" lang="en">
<a name="%_thm_3.28"></a>
<b>Exercise 3.28.</b>  <a name="%_idx_3384"></a>Define an or-gate as a primitive function box.  Your <tt>or-gate</tt>
constructor should be similar to <tt>and-gate</tt>.
</p>

<p class="trans" lang="ja">
<b>練習問題3.28.</b> ORゲートを、原始的な機能ボックスとして定義せよ。
君の <tt>or-gate</tt> というコンストラクタは、<tt>and-gate</tt> に似ているはずだ。
</p>

<p class="exercise">(define (or-gate o1 o2 output)
  (define (or-action-procedure)
    (let ((new-value (logical-or (get-signal o1) (get-signal o2))))
      (after-delay or-gate-delay (lambda () (set-signal! output new-value)))))
  (add-action! o1 or-action-procedure)
  (add-action! o2 or-action-procedure)
  'ok)
<span class="ex_comment">; ついでにこれも定義しておく。</span>
(define (logical-or a b)
  (cond ((and (= a 0) (= b 0)) 0)
        ((and (= a 0) (= b 1)) 1)
        ((and (= a 1) (= b 0)) 1)
        ((and (= a 0) (= b 0)) 0)
        (else (error &quot;Invalid signal&quot; a b))))
</p>

<p class="orig" lang="en"><a name="%_thm_3.29"></a>
<b>Exercise 3.29.</b>  <a name="%_idx_3386"></a>Another way to construct an or-gate is as a compound digital logic
device, built from and-gates and inverters.  Define a procedure <tt>or-gate</tt> that accomplishes this.  What is the delay time of the
or-gate in terms of <tt>and-gate-delay</tt> and <tt>inverter-delay</tt>?
</p>


<p class="trans" lang="ja">
<b>練習問題3.29.</b> ORゲートを構築するための別の方法は、複合的なディジタル論理デバイス——ANDゲートとインバータから構築されたもの——としてのものである。
これを達成するような、<tt>or-gate</tt> という手続きを定義せよ。
<tt>and-gate-delay</tt> と <tt>inverter-delay</tt> で表した、ORゲートの遅延時間は、どのようなものか?
</p>

<div class="exercise"><table class="expl">
<tr><th>A</th><th>B</th><th>NOT A</th><th>NOT B</th><th>NOT A AND NOT B</th><th>A OR B</th></tr>
<tr><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td></tr>
<tr><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td></tr>
<tr><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>
</table></div>

<p class="exercise"><span class="ex_comment">上の表からもわかるように、
A OR B = NOT (NOT A AND NOT B)
なので、このことを利用して定義する。なお、NOT AとNOT Bは並列に実行できるから、
遅延時間は、<tt>inverter-delay * 2 + and-gate-delay</tt> になるはず。</span>

(define (or-gate o1 o2 output)
  (let ((a (make-wire)) (b (make-wire)) (c (make-wire)))
      (inverter o1 a) (inverter o2 b) (and-gate a b c) (inverter c output)))</p>
<!--うっかりすると、単純に
(define (or-gate a b output)
  (inverter (and-gate (inverter a not-a) (inverter b not-b) not-a-and-not-b) output))
と書きたくなってしまうところだが、そうはいかんのよね。
-->
<p class="orig" lang="en">
<a name="%_thm_3.30"></a>
<b>Exercise 3.30.</b>  Figure <a href="#%_fig_3.27">3.27</a> shows a <a name="%_idx_3388"></a><a name="%_idx_3390"></a><em>ripple-carry adder</em> formed by stringing
together <em>n</em> full-adders.  This is the simplest form of parallel adder
for adding two <em>n</em>-bit binary numbers.  The inputs A<sub>1</sub>, A<sub>2</sub>,
A<sub>3</sub>, <tt>...</tt>, A<sub><em>n</em></sub> and B<sub>1</sub>, B<sub>2</sub>, B<sub>3</sub>, <tt>...</tt>,
B<sub><em>n</em></sub> are the two binary numbers to be added (each A<sub><em>k</em></sub> and B<sub><em>k</em></sub>
is a 0 or a 1).  The circuit generates S<sub>1</sub>, S<sub>2</sub>, S<sub>3</sub>,
<tt>...</tt>, S<sub><em>n</em></sub>, the <em>n</em> bits of the sum, and C, the carry from
the addition.  Write a procedure <tt>ripple-carry-adder</tt> that
generates this circuit.  The procedure should take as arguments three
lists of <em>n</em> wires each -- the A<sub><em>k</em></sub>, the B<sub><em>k</em></sub>, and the S<sub><em>k</em></sub> -- and
also another wire C.  The major drawback of the ripple-carry adder is
the need to wait for the carry signals to propagate.  What is the
delay needed to obtain the complete output from an <em>n</em>-bit
ripple-carry adder, expressed in terms of the delays for and-gates,
or-gates, and inverters?
</p>

<p class="trans" lang="ja">
<b>練習問題3.30.</b> 図<a href="#%_fig_3.27">3.27</a>は、<em class="en">n</em>個のフル・アダーをひとつなぎにすることで形成された<em>リップル・キャリー・アダー</em>を示している。
これは、二つの<em class="en">n</em>ビットの2進数を足すための、最も単純な並列加算器である。
A<sub>1</sub>, A<sub>2</sub>, A<sub>3</sub>, <tt>...</tt>, A<sub><em class="en">n</em></sub> 
および 
B<sub>1</sub>, B<sub>2</sub>, B<sub>3</sub>, <tt>...</tt>, B<sub><em class="en">n</em></sub> 
は、足すべき二つの2進数である (各 A<sub><em class="en">k</em></sub> および B<sub><em class="en">k</em></sub> は、0または1である)。
この回路は、
 S<sub>1</sub>, S<sub>2</sub>, S<sub>3</sub>, <tt>...</tt>, S<sub><em class="en">n</em></sub> 
——すなわち、<em class="en">n</em>ビットの和——と、C ——すなわち加算による繰り上がり——とを、生成する。
この回路を生成するような、 <tt>ripple-carry-adder</tt> という手続きを書け。
その手続きは、引数として、それぞれが<em class="en">n</em>本の配線のリストであるような三つのリスト——つまり、A<sub><em class="en">k</em></sub> と B<sub><em class="en">k</em></sub> と S<sub><em class="en">k</em></sub> のリスト——をとり、また、もう1本の C という配線をとる。
リップル・キャリー・アダーの主な欠点は、<ruby><rb>繰り上がり</rb><rp> (</rp><rt>キャリー</rt><rp>) </rp></ruby>信号が伝播するのを待つ必要があることである。
<em class="en">n</em>ビットのリップル・キャリー・アダーからの完全な出力を得るのに必要な遅延は、ANDゲートとORゲートとインバータの遅延を用いて表現すると、どのようなものになるだろうか?
</p>

<a name="%_fig_3.27"></a>
<figure>
<img src="ch3-Z-G-27.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.27:</b>  A ripple-carry adder for <em>n</em>-bit numbers.</figcaption>
<figcaption class="trans" lang="ja"><b>図3.27:</b> <em class="en">n</em>ビットの数のためのリップル・キャリー・アダー</figcaption>
</figure>

<p class="exercise"><span class="ex_comment">; 多分こんな感じ?</span>
(define (ripple-carry-adder A B S C)
  <span class="ex_comment">; cdr をとりたいので一応チェックしておく。</span>
  (if (and (pair? A) (pair? B) (pair? S))
    <span class="ex_comment">; 1要素のリストかどうか?</span>
    (if (and (null? (cdr A)) (null? (cdr B)) (null? (cdr S)))
        <span class="ex_comment">; 1要素のリストなので、最下位1ビット (LSB) での加算をして、おしまい。</span>
        (let ((Cn-in (make-wire)))
             (set-signal! Cn-in 0)
             (full-adder (car A) (car B) Cn-in (car S) C))
        <span class="ex_comment">; 2要素以上あるとき。下位桁 (LSBs) のリップル・キャリー・アダーに、最上位桁 (MSB) のフル・アダーをつなぐ。</span>
        (let ((c-prev-out (make-wire)))
             (ripple-carry-adder (cdr A) (cdr B) (cdr S) c-prev-out)
             (full-adder (car A) (car B) c-prev-out (car S) C)))
    <span class="ex_comment">; エラー処理</span>
    (error "入力リストA, B, Sは同じ長さのリストにしてくださいよ")))
</p>

<p class="exercise"><span class="ex_comment">ハーフ・アダーは、<img src="ch3-Z-G-25.gif">なので、
Cまでの遅延は and-gate-delay
Dまでの遅延は or-gate-delay
Eまでの遅延は and-gate-delay + inverter-delay
Sまでの遅延は
  max(or-gate-delay, and-gate-delay + inverter-delay) + and-gate-delay
= max(or-gate-delay + and-gate-delay, 2 * and-gate-delay + inverter-delay)
である。常に、Sまでの遅延の方が、Cまでの遅延より大きい。
よって、Sまでの遅延が、ハーフ・アダー全体の遅延である。これを HA-delay とする。

フル・アダーは、<img src="ch3-Z-G-26.gif">なので、
SUMまでの遅延は、2 * HA-delay である。
Coutまでの遅延は、素朴に考えると、
  max(2 * HA-delay, HA-delay) + or-gate-delay = 2 * HA-delay + or-gate-delay
なのだが、ハーフ・アダー全体の遅延よりも、ハーフ・アダーでのCの出力の遅延の方が
短いことを考慮すると、
  max(HA-delay + and-gate-delay, and-gate-delay) + or-gate-delay
= HA-delay + and-gate-delay + or-gate-delay &le; 2 * HA-delay
である。
というわけで、フル・アダー全体の遅延は、2 * HA-delay だと考えてよい。
これを FA-delay とする。

ここまでが準備。以下本題。nビットのリップル・キャリー・アダーは、
<img src="ch3-Z-G-27.gif"> である。
なお、右がキャリーの入力側で、A、B、Sの最下位ビット。
左がキャリーの出力側で、A、B、Sの最上位ビット。
これの遅延は n * FA-delay である。
というわけで、
  n * FA-delay
= 2n * HA-delay
= 2n * max(or-gate-delay + and-gate-delay, 2 * and-gate-delay + inverter-delay)
が、nビットのリップル・キャリー・アダーの遅延である。
</span></p>


<a name="%_sec_Temp_384"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_384">Representing wires</a></h4>
<h4 class="trans" lang="ja">配線を表現する</h4>

<p class="orig" lang="en">
<a name="%_idx_3392"></a>
A wire in our simulation will be a computational object with two local
state variables: a <tt>signal-value</tt> (initially taken to be 0) and a
collection of <tt>action-procedures</tt> to be run when the signal
changes value.  We implement the wire, using message-passing style, as
<a name="%_idx_3394"></a>a collection of local procedures together with a <tt>dispatch</tt>
procedure that selects the appropriate local operation, just as we did
with the simple bank-account object in section
 <a href="20_sec3_1.html#%_sec_3.1.1">3.1.1</a>:</p>

<p class="trans" lang="ja">
私たちのシミュレーションにおける配線は、二つの局所状態変数——つまり、<tt>signal-value</tt> (最初は0だと見なされる) と、信号が値を変えるときに実行されるべき <tt>action-procedures</tt> の集まり——をもった、計算オブジェクトとなることだろう。
私たちは、メッセージ・パッシングの様式を使って、配線を、局所手続きの集まりとして、適切な局所的演算を選択する <tt>dispatch</tt> という手続きとともに、実装する——<a href="20_sec3_1.html#%_sec_3.1.1">3.1.1</a>節で簡単な銀行口座オブジェクトについてそうしたのと、ちょうど同じように。
</p>

<p class="lisp"><a name="%_idx_3396"></a>(define (make-wire)
  (let ((signal-value 0) (action-procedures '()))
    (define (set-my-signal! new-value)
      (if (not (= signal-value new-value))
          (begin (set! signal-value new-value)
                 (call-each action-procedures))
          'done))
    (define (accept-action-procedure! proc)
      (set! action-procedures (cons proc action-procedures))
      (proc))
    (define (dispatch m)
      (cond ((eq? m 'get-signal) signal-value)
            ((eq? m 'set-signal!) set-my-signal!)
            ((eq? m 'add-action!) accept-action-procedure!)
            (else (error &quot;Unknown operation -- WIRE&quot; m))))
    dispatch))
</p>

<p class="orig" lang="en">
The local procedure <tt>set-my-signal!</tt> tests whether the new signal
value changes the signal on the wire.  If so, it runs each of the
action procedures, using the following procedure <tt>call-each</tt>,
which calls each of the items in a list of no-argument procedures:</p>

<p class="trans" lang="ja">
<tt>set-my-signal!</tt> という局所手続きは、新たな信号値がその配線上の信号を変更するかどうかを調べる。
もし変更するなら、この局所手続きは、動作手続きのそれぞれを、以下の <tt>call-each</tt> という手続き——引数のない手続きのリスト内の項目のそれぞれを呼び出す——を使って、実行する。
</p>

<p class="lisp"><a name="%_idx_3398"></a>(define (call-each procedures)
  (if (null? procedures)
      'done
      (begin
        ((car procedures))
        (call-each (cdr procedures)))))
</p>

<p class="orig" lang="en">
The local procedure <tt>accept-action-procedure!</tt> adds the given
procedure to the list of procedures to be run, and then runs the new
procedure once.  (See exercise <a href="#%_thm_3.31">3.31</a>.)</p>

<p class="trans" lang="ja">
<tt>accept-action-procedure!</tt> という局所手続きは、与えられた手続きを、実行すべき手続きのリストへと、付け加える。そして、その新たな手続きを、一度、実行する。
(練習問題<a href="#%_thm_3.31">3.31</a>を参照)。
</p>

<p class="orig" lang="en">
With the local <tt>dispatch</tt> procedure set up as specified, we can
provide the following procedures to access the local operations on
wires:<a name="call_footnote_Temp_385" href="#footnote_Temp_385"><sup><small>27</small></sup></a></p>

<p class="trans" lang="ja">
上に規定したように設定された、局所的な <tt>dispatch</tt> の手続きがあると、配線に対する局所的演算にアクセスするための以下のような手続きを提供することができる。
</p>

<p class="lisp"><a name="%_idx_3404"></a>(define (get-signal wire)
  (wire 'get-signal))
<a name="%_idx_3406"></a>(define (set-signal! wire new-value)
  ((wire 'set-signal!) new-value))
<a name="%_idx_3408"></a>(define (add-action! wire action-procedure)
  ((wire 'add-action!) action-procedure))
</p>

<p class="orig" lang="en">
Wires, which have time-varying signals and may be incrementally
attached to devices, are typical of mutable objects.  We have modeled
them as procedures with local state variables that are modified by
assignment.  When a new wire is created, a new set of state variables
is allocated (by the <tt>let</tt> expression in <tt>make-wire</tt>) and a
new <tt>dispatch</tt> procedure is constructed and returned, capturing
the environment with the new state variables.</p>

<p class="trans" lang="ja">
配線——経時変化する信号を有していて、デバイスに対して少しずつ、つなげられていくかもしれない——は、変更可能なオブジェクトの典型である。
私たちは、配線を、<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>により修正される局所状態変数を持った手続きとして、モデル化してきた。
新たな配線が作成されると、状態変数の新たな一式が、(<tt>make-wire</tt> 内の <tt>let</tt>式によって) 割り当てられて、新たな <tt>dispatch</tt> の手続き————上記の新たな状態変数を有する環境をつかまえている——が、構築されて返される。
</p>

<p class="orig" lang="en">
The wires are shared among the various devices that have been
connected to them.  Thus, a change made by an interaction with one
device will affect all the other devices attached to the wire.  The
wire communicates the change to its neighbors by calling the action
procedures provided to it when the connections were established.</p>

<p class="trans" lang="ja">
配線は、それらの配線に接続された様々なデバイスの間で共有される。
よって、一つのデバイスとの相互作用により起きた変化は、その配線につながっている残りのすべてのデバイスに影響するだろう。
配線は、接続が確立されたときにその配線に対して与えられた動作手続きを呼び出すことにより、その変化を、自身に隣接するものへと伝達する。
</p>


<a name="%_sec_Temp_386"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_386">The agenda</a></h4>
<h4 class="trans" lang="ja">アジェンダ</h4>

<p class="orig" lang="en">
<a name="%_idx_3410"></a>
The only thing needed to complete the simulator is <tt>after-delay</tt>.
The idea here is that we maintain a data structure, called an <em>agenda</em>, that contains a schedule of things to do.  The following
operations are defined for agendas:</p>

<p class="trans" lang="ja">
シミュレータを完成させるのに必要な唯一のものは、<tt>after-delay</tt> である。
ここでの考え方は、やるべきことの計画表を含むデータ構造——<em>アジェンダ</em>と呼ばれる——を維持する、というものである。
アジェンダに対して、以下の演算が定義される。
</p>


<ul class="orig" lang="en">
<li><a name="%_idx_3412"></a><tt>(make-agenda)</tt>
returns a new empty agenda.</li>

<li><a name="%_idx_3414"></a><tt>(empty-agenda? &lt;<em>agenda</em>&gt;)</tt>
is true if the specified agenda is empty.</li>

<li><a name="%_idx_3416"></a><tt>(first-agenda-item &lt;<em>agenda</em>&gt;)</tt>
returns the first item on the agenda.</li>

<li><a name="%_idx_3418"></a><tt>(remove-first-agenda-item! &lt;<em>agenda</em>&gt;)</tt>
modifies the agenda by removing the first item.</li>

<li><a name="%_idx_3420"></a><tt>(add-to-agenda! &lt;<em>time</em>&gt; &lt;<em>action</em>&gt; &lt;<em>agenda</em>&gt;)</tt>
modifies the agenda by adding the given action procedure to be run at
the specified time.</li>

<li><a name="%_idx_3422"></a><tt>(current-time &lt;<em>agenda</em>&gt;)</tt>
returns the current simulation time.</li>
</ul>

<ul class="trans" lang="ja">
<li><tt>(make-agenda)</tt> は、新たな空のアジェンダを返す。</li>
<li><tt>(empty-agenda? &lt;<em class="en">agenda</em>&gt;)</tt> は、指定されたアジェンダが空のとき、真である。</li>
<li><tt>(first-agenda-item &lt;<em class="en">agenda</em>&gt;)</tt> は、そのアジェンダ上の最初の項目を返す。</li>
<li><tt>(remove-first-agenda-item! &lt;<em class="en">agenda</em>&gt;)</tt> は、最初の項目を取り除くことにより、アジェンダを変更する。</li>
<li><tt>(add-to-agenda! &lt;<em class="en">time</em>&gt; &lt;<em class="en">action</em>&gt; &lt;<em class="en">agenda</em>&gt;)</tt> は、指定された時刻に実行すべき、与えられた動作手続きを、追加することによって、アジェンダを変更する。</li>
<li><tt>(current-time &lt;<em class="en">agenda</em>&gt;)</tt> は、現在のシミュレーション時刻を返す。</li>
</ul>

<p class="orig" lang="en">
The particular agenda that we use is denoted by
<tt>the-agenda</tt>.  The procedure <tt>after-delay</tt> adds new
elements to <tt>the-agenda</tt>:</p>

<p class="trans" lang="ja">
私たちが使う特定のアジェンダは、<tt>the-agenda</tt> で示される。
<tt>after-delay</tt> の手続きは、<tt>the-agenda</tt> に新たな要素を追加する。
</p>

<p class="lisp"><a name="%_idx_3424"></a>(define (after-delay delay action)
  (add-to-agenda! (+ delay (current-time the-agenda))
                  action
                  the-agenda))
</p>

<p class="orig" lang="en">
The simulation is driven by the procedure <tt>propagate</tt>, which
operates on <tt>the-agenda</tt>, executing each procedure on the agenda
in sequence.  In general, as the simulation runs, new items will be
added to the agenda, and <tt>propagate</tt> will continue the simulation
as long as there are items on the agenda:</p>

<p class="trans" lang="ja">
シミュレーションは、<tt>propagate</tt> という手続き—— <tt>the-agenda</tt> に対して動作するもので、アジェンダ上の各手続きを順に実行する——によって駆動される。
一般に、シミュレーションが進行するにつれて、新たな項目がアジェンダに追加されるだろうし、アジェンダ上に項目がある限り、<tt>propagate</tt> は継続するだろう。
</p>

<p class="lisp"><a name="%_idx_3426"></a>(define (propagate)
  (if (empty-agenda? the-agenda)
      'done
      (let ((first-item (first-agenda-item the-agenda)))
        (first-item)
        (remove-first-agenda-item! the-agenda)
        (propagate))))
</p>


<a name="%_sec_Temp_387"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_387">A sample simulation</a></h4>
<h4 class="trans" lang="ja">例示のシミュレーション</h4>

<p class="orig" lang="en">
<a name="%_idx_3428"></a><a name="%_idx_3430"></a>
The following procedure, which places a ``probe'' on a wire, shows the
simulator in action.  The probe tells the wire that, whenever its
signal changes value, it should print the new signal value, together
with the current time and a name that identifies the wire:</p>

<p class="trans" lang="ja">
以下の手続き——「プローブ」を配線上に置く——は、作動中のシミュレータを見せてくれる。
プローブは、配線に対してこう命令するのだ。すなわち、その配線が値を変えるときはいつでも、その配線は、現在時刻および当該配線を識別する名前とともに、新たな信号値を印字すべきである、と。
</p>

<p class="lisp"><a name="%_idx_3432"></a>(define (probe name wire)
  (add-action! wire
               (lambda ()        
                 (newline)
                 (display name)
                 (display &quot; &quot;)
                 (display (current-time the-agenda))
                 (display &quot;  New-value = &quot;)
                 (display (get-signal wire)))))
</p>

<p class="orig" lang="en">
We begin by initializing the agenda and specifying delays for the
primitive function boxes:</p>

<p class="trans" lang="ja">
アジェンダを初期化して、原始的な機能ボックスについての遅延を指定することから、始めよう。
</p>

<p class="lisp">(define the-agenda (make-agenda))
(define inverter-delay 2)
(define and-gate-delay 3)
(define or-gate-delay 5)
</p>

<p class="orig" lang="en">
Now we define four wires, placing probes on two of them:
</p>

<p class="trans" lang="ja">
ここで、4本の配線を定義し、それらのうちの2本の上プローブを設置する。
</p>

<p class="lisp">(define input-1 (make-wire))
(define input-2 (make-wire))
(define sum (make-wire))
(define carry (make-wire))
(probe 'sum sum)
<i>sum 0  New-value = 0</i>
(probe 'carry carry)
<i>carry 0  New-value = 0</i>
</p>

<p class="orig" lang="en">
Next we connect the wires in a half-adder circuit (as in
figure <a href="#%_fig_3.25">3.25</a>), set the signal on <tt>input-1</tt> to 1,
and run the simulation:
</p>

<p class="trans" lang="ja">
次に、これらの配線を (図<a href="#%_fig_3.25">3.25</a>のように) ハーフ・アダー回路に接続し、<tt>input-1</tt> 上の信号を1に設定し、シミュレーションを実行する。
</p>

<p class="lisp">(half-adder input-1 input-2 sum carry)
<i>ok</i>
(set-signal! input-1 1)
<i>done</i>
(propagate)
<i>sum 8  New-value = 1</i>
<i>done</i>
</p>

<p class="orig" lang="en">
The <tt>sum</tt> signal changes to 1 at time 8.  We are now eight time
units from the beginning of the simulation.  At this point, we can set
the signal on <tt>input-2</tt> to 1 and allow the values to propagate:
</p>

<p class="trans" lang="ja">
<tt>sum</tt> という信号は、時刻8において、1に変化する。
私たちは今、シミュレーションの開始から、時間単位の8個ぶんだけ後に居るのだ。
この時点で、私たちは、<tt>input-2</tt> 上の信号を1に設定することができ、その値を伝播させることができる。
</p>

<p class="lisp">(set-signal! input-2 1)
<i>done</i>
(propagate)
<i>carry 11  New-value = 1</i>
<i>sum 16  New-value = 0</i>
<i>done</i>
</p>

<p class="orig" lang="en">
The <tt>carry</tt> changes to 1 at time 11 and the <tt>sum</tt> changes to 0
at time 16.</p>

<p class="trans" lang="ja">
<tt>carry</tt> は、時刻11において、1に変化する。そして、<tt>sum</tt> は、時刻16において、0に変化する。
</p>

<p class="orig" lang="en">
<a name="%_thm_3.31"></a>
<b>Exercise 3.31.</b>  
<a name="%_idx_3434"></a>The internal procedure <tt>accept-action-procedure!</tt> defined in <tt>make-wire</tt> specifies that when a new action procedure is added to
a wire, the procedure is immediately run.  Explain why this initialization
is necessary.  In particular, trace through the half-adder example in
the paragraphs above and say how the system's response would differ if
we had defined <tt>accept-action-procedure!</tt> as
</p>

<p class="trans" lang="ja">
<b>練習問題3.31.</b> <tt>make-wire</tt> の中で定義されている <tt>accept-action-procedure!</tt> という内部手続きは、配線に対して新たな動作が追加されたら、その手続きをすぐさま実行する、と規定している。
なぜこのような初期化が必要なのかを、説明せよ。
特に、上記段落におけるハーフ・アダーの例を通じてトレースせよ。そして、もし以下のように <tt>accept-action-procedure!</tt> を定義していたとしたら、システムの応答がどのように異なっていただろうか、ということを述べよ。
</p>

<p class="lisp">(define (accept-action-procedure! proc)
  (set! action-procedures (cons proc action-procedures)))
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_Temp_389"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_389">Implementing the agenda</a></h4>
<h4 class="trans" lang="ja">アジェンダを実装する</h4>


<p class="orig" lang="en">
<a name="%_idx_3436"></a>
Finally, we give details of the agenda data structure, which holds the
procedures that are scheduled for future execution.</p>

<p class="trans" lang="ja">
最後に、アジェンダのデータ構造——将来の実行のために予定されている諸手続きを保持する——の詳細を述べる。
</p>

<p class="orig" lang="en">
The agenda is made up of <a name="%_idx_3438"></a><em>time segments</em>.  Each time segment is a
pair consisting of a number (the time) and a <a name="%_idx_3440"></a>queue (see
exercise <a href="#%_thm_3.32">3.32</a>) that holds the procedures that are
scheduled to be run during that time segment.</p>

<p class="trans" lang="ja">
アジェンダは、いくつかの<em>時間区分</em>からなっている。
それぞれの時間区分は、数 (時刻) と、その時間区分の間に実行すべく予定されている手続きを保持するキュー (練習問題<a href="#%_thm_3.32">3.32</a>を参照) とから構成される、対である。
</p>

<p class="lisp"><a name="%_idx_3442"></a>(define (make-time-segment time queue)
  (cons time queue))
<a name="%_idx_3444"></a>(define (segment-time s) (car s))
<a name="%_idx_3446"></a>(define (segment-queue s) (cdr s))
</p>

<p class="orig" lang="en">
We will operate on the time-segment queues using the queue operations
described in section <a href="#%_sec_3.3.2">3.3.2</a>.</p>

<p class="trans" lang="ja">
<a href="#%_sec_3.3.2">3.3.2</a>節で説明したキュー演算を使って、時間区分のキューに対して操作を行おう。
</p>

<p class="orig" lang="en">
<a name="%_idx_3448"></a>The agenda itself is a one-dimensional table of time segments.  It
differs from the tables described in section <a href="#%_sec_3.3.3">3.3.3</a> in that
the segments will be sorted in order of increasing time.  In addition,
we store the <a name="%_idx_3450"></a><em>current time</em> (i.e., the time of the last action
that was processed) at the head of the agenda.  A newly constructed
agenda has no time segments and has a current time of 0:<a name="call_footnote_Temp_390" href="#footnote_Temp_390"><sup><small>28</small></sup></a></p>

<p class="trans" lang="ja">
アジェンダ自体は、時間区分の一次元テーブルである。
これは、増加してゆく時間の順序にしたがって区分が格納されるだろう、という点において、<a href="#%_sec_3.3.3">3.3.3</a>節で説明したテーブルとは異なる。
さらに、<em>現在時刻</em> (すなわち、処理済みの最後の動作の時刻) を、アジェンダの先頭に格納する。
新たに構築されたアジェンダは、時間区分を有しておらず、0 という現在時刻を有する<a  href="#footnote_Temp_390"><sup><small>28</small></sup></a>。
</p>

<p class="lisp"><a name="%_idx_3456"></a>(define (make-agenda) (list 0))
<a name="%_idx_3458"></a>(define (current-time agenda) (car agenda))
<a name="%_idx_3460"></a>(define (set-current-time! agenda time)
  (set-car! agenda time))
<a name="%_idx_3462"></a>(define (segments agenda) (cdr agenda))
<a name="%_idx_3464"></a>(define (set-segments! agenda segments)
  (set-cdr! agenda segments))
<a name="%_idx_3466"></a>(define (first-segment agenda) (car (segments agenda)))
<a name="%_idx_3468"></a>(define (rest-segments agenda) (cdr (segments agenda)))
</p>

<p class="orig" lang="en">
An agenda is empty if it has no time segments:
</p>

<p class="trans" lang="ja">
時間区分がないとき、アジェンダは空である。
</p>

<p class="lisp"><a name="%_idx_3470"></a>(define (empty-agenda? agenda)
  (null? (segments agenda)))
</p>

<p class="orig" lang="en">
To add an action to an agenda, we first check if the agenda is empty.
If so, we create a time segment for the action and install this in
the agenda.  Otherwise, we scan the agenda, examining the time of each
segment.  If we find a segment for our appointed time, we add the
action to the associated queue.  If we reach a time later than the one
to which we are appointed, we insert a new time segment into the
agenda just before it.  If we reach the end of the agenda, we must
create a new time segment at the end.
</p>

<p class="trans" lang="ja">
アジェンダに動作を追加するには、まず、アジェンダが空かどうかを調べる。
もしそうなら、その動作用の新たな時間区分を作成し、これをアジェンダに組み込む。
そうでない場合は、各区分の時刻を検査しながら、アジェンダを走査する。
もし、指定された時刻の区分を見つけたら、それに関連づけられたキューに当該動作を追加する。
もし、指定された時刻よりも遅い時刻に到達したら、その時刻の直前において、新たな時間区分をアジェンダに挿入する。
もし、アジェンダの末尾に到達したら、末尾に、新たな時間区分を作成せねばならない。
</p>

<p class="lisp"><a name="%_idx_3472"></a>(define (add-to-agenda! time action agenda)
  (define (belongs-before? segments)
    (or (null? segments)
        (&lt; time (segment-time (car segments)))))
  (define (make-new-time-segment time action)
    (let ((q (make-queue)))
      (insert-queue! q action)
      (make-time-segment time q)))
  (define (add-to-segments! segments)
    (if (= (segment-time (car segments)) time)
        (insert-queue! (segment-queue (car segments))
                       action)
        (let ((rest (cdr segments)))
          (if (belongs-before? rest)
              (set-cdr!
               segments
               (cons (make-new-time-segment time action)
                     (cdr segments)))
              (add-to-segments! rest)))))
  (let ((segments (segments agenda)))
    (if (belongs-before? segments)
        (set-segments!
         agenda
         (cons (make-new-time-segment time action)
               segments))
        (add-to-segments! segments))))
</p>

<p class="orig" lang="en">
The procedure that removes the first item from the agenda deletes the
item at the front of the queue in the first time segment.  If this
deletion makes the time segment empty, we remove it from the list of
segments:<a name="call_footnote_Temp_391" href="#footnote_Temp_391"><sup><small>29</small></sup></a></p>

<p class="trans" lang="ja">
アジェンダから最初の項目を取り除く手続きは、最初の時間区分においてキューの先頭にある項目を、削除する。
もし、この削除によって時間区分が空になるなら、その時間区分を、区分のリストから取り除く<a href="#footnote_Temp_391"><sup><small>29</small></sup></a>。
</p>

<p class="lisp"><a name="%_idx_3478"></a>(define (remove-first-agenda-item! agenda)
  (let ((q (segment-queue (first-segment agenda))))
    (delete-queue! q)
    (if (empty-queue? q)
        (set-segments! agenda (rest-segments agenda)))))
</p>

<p class="orig" lang="en">
The first agenda item is found at the head of the queue in the first
time segment.  Whenever we extract an item, we also update the current
time:<a name="call_footnote_Temp_392" href="#footnote_Temp_392"><sup><small>30</small></sup></a></p>

<p class="trans" lang="ja">
最初のアジェンダ項目は、最初の時間区分のキューの先頭で見つかる。
項目を抜き出すときはいつでも、現在時刻も更新する<a href="#footnote_Temp_392"><sup><small>30</small></sup></a>。
</p>

<p class="lisp"><a name="%_idx_3480"></a>(define (first-agenda-item agenda)
  (if (empty-agenda? agenda)
      (error &quot;Agenda is empty -- FIRST-AGENDA-ITEM&quot;)
      (let ((first-seg (first-segment agenda)))
        (set-current-time! agenda (segment-time first-seg))
        (front-queue (segment-queue first-seg)))))
</p>

<p class="orig" lang="en">
<a name="%_thm_3.32"></a>
<b>Exercise 3.32.</b>  The procedures to be run during each time segment of the agenda are
kept in a queue.  Thus, the procedures for each segment are called in
the order in which they were added to the agenda (first in, first
out).  Explain why this order must be used.  In particular, trace the
behavior of an and-gate whose inputs change from 0,1 to 1,0 in the
same segment and say how the behavior would differ if we stored a
segment's procedures in an ordinary list, adding and removing
procedures only at the front (last in, first out).
</p>

<p class="trans" lang="ja">
<b>練習問題3.32.</b> アジェンダのそれぞれの時間区分の間に実行すべき手続きは、キューの中に保持されている。
よって、各区分についての手続きは、それらの手続きがアジェンダに追加された順序で、呼び出される (最初に入ったものが最初に出ていく)。
なぜこの順序が使われなくてはならないのか、説明せよ。
特に、同じ区分内において入力が0と1から1と0へ変化するようなANDゲートの振る舞いをトレースせよ。そして、もし区分の手続きを通常のリストで記憶していたとしたら——つまり、先頭においてだけ、手続きを追加したり取り除いたりしていたなら (最後に入ったものが最初に出ていく)——その振る舞いがどう異なっていたか、述べよ。
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_3.3.5"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_3.3.5">3.3.5  Propagation of Constraints</a></h3>
<h3 class="trans" lang="ja">3.3.5 制約の伝播</h3>


<p class="orig" lang="en">
<a name="%_idx_3482"></a><a name="%_idx_3484"></a>
Computer programs are traditionally organized as
one-directional computations, which perform operations on prespecified
arguments to produce desired outputs.  On the other hand, we often
model systems in terms of relations among quantities.  For example, a
mathematical model of a mechanical structure might include the
information that the deflection <em>d</em> of a metal rod is related to the
force <em>F</em> on the rod, the length <em>L</em> of the rod, the cross-sectional
area <em>A</em>, and the elastic modulus <em>E</em> via the equation
</p>

<p class="trans" lang="ja">
伝統的にコンピュータプログラムは、一方向の計算——予め指定された引数に対する演算を行い、所望の出力を生み出す——として、組織化される。
他方、私たちはよく、量と量の間の関係の観点から、<ruby><rb>系</rb><rp> (</rp><rt>システム</rt><rp>) </rp></ruby>をモデル化する。
たとえば、金属棒の変位 <em class="en">d</em> は、棒にかかる力 <em class="en">F</em> と棒の長さ <em class="en">L</em> と断面積 <em class="en">A</em> と弾性係数 <em class="en">E</em>に関係している、という情報を、機械的構造の数学的モデルが、以下の式を通じて、含んでいるかもしれない。
</p>

<figure><img src="ch3-Z-G-28.gif" border="0"></figure>

<p class="orig" lang="en">
Such an equation is not one-directional.  Given any four of the
quantities, we can use it to compute the fifth.  Yet translating the
equation into a traditional computer language would force us to choose
one of the quantities to be computed in terms of the other four.
Thus, a procedure for computing the area <em>A</em> could not be used to
compute the deflection <em>d</em>, even though the computations of <em>A</em> and
<em>d</em> arise from the same equation.<a name="call_footnote_Temp_394" href="#footnote_Temp_394"><sup><small>31</small></sup></a></p>

<p class="trans" lang="ja">
こういう式は、一方向的ではない。
これらの数量のうちの任意の四つが与えられると、それを使って五番目の数量を計算できる。
式を伝統的なコンピュータ言語に移し変えることもやはり、残りの四つの数量を使って計算すべき数量のうちの一つを選ぶことを、私たちに強いるのである。
よって、<em class="en">A</em> と <em class="en">d</em> の計算が同じ式から生じていてさえ、面積 <em class="en">A</em> を計算するための手続きは、変位 <em class="en">d</em> を計算するのには使えないだろう<a href="#footnote_Temp_394"><sup><small>31</small></sup></a>。</p>

<p class="orig" lang="en">
<a name="%_idx_3508"></a>In this section, we sketch the design of a language that enables us to
work in terms of relations themselves.  The primitive elements of the
language are <a name="%_idx_3510"></a><a name="%_idx_3512"></a><em>primitive constraints</em>, which state that certain
relations hold between quantities.  For example, <tt>(adder a b c)</tt>
specifies that the quantities <em>a</em>, <em>b</em>, and <em>c</em> must be related by the
equation <em>a</em> + <em>b</em> = <em>c</em>, <tt>(multiplier x y z)</tt> expresses the constraint
<em>x</em><em>y</em>  =  <em>z</em>, and <tt>(constant 3.14 x)</tt> says that the value of <em>x</em> must
be 3.14.</p>

<p class="trans" lang="ja">
関係そのものを使って作業できるようにしてくれる言語の設計について、本節で概略を述べる。
その言語の原始的な要素は、<em>原始的制約</em>であり、それは、量と量の間に、ある関係が成り立つ、と述べるものである。
たとえば、<tt>(adder a b c)</tt> は、
<em class="en">a</em> と <em class="en">b</em> と <em class="en">c</em> という数量同士が 
<span class="math"><em class="en">a</em> + <em class="en">b</em> = <em class="en">c</em></span>
という式により関連づけられねばならない、と規定しており、
<tt>(multiplier x y z)</tt> は、
<span class="math"><em class="en">xy</em>  =  <em class="en">z</em></span>
という制約を表しており、
<tt>(constant 3.14 x)</tt> は、
<em class="en">x</em> の値が3.14でなくてはならない、と述べている。
</p>

<p class="orig" lang="en">
Our language provides a means of combining primitive constraints in
order to express more complex relations.  We combine constraints by
constructing <a name="%_idx_3514"></a><em>constraint networks</em>, in which constraints are
joined by <a name="%_idx_3516"></a><em>connectors</em>.  A connector is an object that ``holds'' a
value that may participate in one or more constraints.  For example,
we know that the relationship between Fahrenheit and Celsius
temperatures is</p>

<p class="trans" lang="ja">
私たちの言語は、より複雑な関係を表現するために原始的な制約同士を結合する手段を、提供している。
私たちは、<em>制約ネットワーク</em>——その中で制約同士は<em>コネクタ</em>によりつながれる——を構築することにより、制約同士を結合する。
コネクタは、一つ以上の制約に関与する可能性のある値を「保持」するオブジェクトである。
たとえば、華氏温度と摂氏温度の関係が以下のとおりであることを、私たちは知っている。
</p>

<figure><img src="ch3-Z-G-29.gif" border="0"></figure>

<p class="orig" lang="en">
Such a constraint can be thought of as a network consisting of
primitive adder, multiplier, and constant constraints
(figure <a href="#%_fig_3.28">3.28</a>).  In the figure, we see on the left a
multiplier box with three terminals, labeled <em>m</em>1, <em>m</em>2, and <em>p</em>.
These connect the multiplier to the rest of the network as follows:
The <em>m</em>1 terminal is linked to a connector <em>C</em>, which will hold the
Celsius temperature.  The <em>m</em>2 terminal is linked to a connector
<em>w</em>, which is also linked to a constant box that holds 9.  The <em>p</em>
terminal, which the multiplier box constrains to be the product of
<em>m</em>1 and <em>m</em>2, is linked to the <em>p</em> terminal
of another multiplier box, whose <em>m</em>2 is connected to a constant 5 and
whose <em>m</em>1 is connected to one of the terms in a sum.</p>

<p class="trans" lang="ja">
こういう制約は、原始的な加算器と乗算器と定数制約とから構成されるネットワークだと見なせる (図<a href="#%_fig_3.28">3.28</a>)。
この図で、私たちは、三つの端子——<em class="en">m</em>1、<em class="en">m</em>2、<em class="en">p</em> とラベル付けされている——のある乗算器ボックスを左側に見ている。
これらの端子は、以下のようにして、乗算器を、ネットワークの残りの部分へと接続する。
<em class="en">m</em>1 の端子は、<em class="en">C</em> というコネクタ——摂氏温度を保持することになるだろう——につながれる。
<em class="en">m</em>2 の端子は、<em class="en">w</em> というコネクタにつながれ、このコネクタも、9を保持する定数ボックスへとつながれる。
<em class="en">p</em> という端子—— <em class="en">m</em>1 と <em class="en">m</em>2 の積である、と乗算器ボックスが制約している——は、もう一つの乗算器ボックス——その <em class="en">m</em>2 は5という定数に接続され、その <em class="en">m</em>1 は、とある和に含まれる項のうちの一つに接続される——の <em class="en">p</em> の端子につながれる。
</p>

<a name="%_fig_3.28"></a>
<figure>
<img src="ch3-Z-G-30.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.28:</b>  The relation 9<em>C</em>  =  5(<em>F</em>  -  32)
expressed as a constraint network.</figcaption>
<figcaption class="trans" lang="ja"><b>図3.28:</b> 制約ネットワークとして表された、
<span class="math">9<em class="en">C</em>  =  5(<em class="en">F</em>  &minus;  32)</span>
という関係</figcaption>
</figure>


<p class="orig" lang="en">
Computation by such a network proceeds as follows: When a connector is
given a value (by the user or by a constraint box to which it is
linked), it awakens all of its associated constraints (except for the
constraint that just awakened it) to inform them that it has a value.
Each awakened constraint box then polls its connectors to see if there
is enough information to determine a value for a connector.  If so,
the box sets that connector, which then awakens all of its associated
constraints, and so on.  For instance, in conversion between
Celsius and Fahrenheit, <em>w</em>, <em>x</em>, and <em>y</em> are immediately set by
the constant boxes to 9, 5, and 32, respectively.  The connectors
awaken the multipliers and the adder, which determine that there is
not enough information to proceed.  If the user (or some other part of
the network) sets <em>C</em> to a value (say 25), the leftmost multiplier
will be awakened, and it will set <em>u</em> to 25 &middot;  9 = 225.  Then <em>u</em>
awakens the second multiplier, which sets <em>v</em> to 45, and <em>v</em> awakens
the adder, which sets <em>F</em> to 77.</p>

<p class="trans" lang="ja">
こうしたネットワークによる計算は、次のようにして進む。
コネクタに、(ユーザによって、または、そのコネクタがつながれている制約ボックスによって) 値が与えられると、コネクタは、自分に関連づけられた制約のすべて (ただし、そのコネクタをまさに目覚めさせた当該制約を除く) を目覚めさせて、それらの制約に対して、そのコネクタが値を持っていることを知らせる。
すると、起こされたそれぞれの制約ボックスは、自分のコネクタに対して問い合わせを行って、そのコネクタの値を決定するのに十分な情報があるかどうかを調べる。
もしあれば、そのボックスはそのコネクタを設定し、するとそのコネクタは、自分に対応づけられた制約のすべてを目覚めさせ、といった具合になる。
たとえば、摂氏と華氏の変換において、<em class="en">w</em> と <em class="en">x</em> と <em class="en">y</em> は、制約ボックスによって直接的に、それぞれ9と5と32に設定される。
これらのコネクタは、乗算器と加算器を目覚めさせるが、乗算器と加算器は、先に進むための十分な情報がない、と判定する。
もしユーザ (またはネットワークの中の何らかの他の部分) が <em class="en">C</em> をある値 (たとえば25) に設定すると、一番左の乗算器が起こされるだろう。そして、一番左の乗算器は、<em class="en">u</em> を <span class="math">25 &middot;  9 = 225</span>
に設定するだろう。
すると、<em class="en">u</em> が二番目の乗算器を目覚めさせ、これが <em class="en">v</em> を45に設定し、そして、 <em class="en">v</em> が加算器を目覚めさせ、加算器が <em class="en">F</em> を77に設定する。
</p>

<a name="%_sec_Temp_395"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_395">Using the constraint system</a></h4>
<h4 class="trans" lang="ja">制約システムを使う</h4>

<p class="orig" lang="en">
To use the constraint system to carry out the temperature computation
outlined above, we first create two connectors, <tt>C</tt> and <tt>F</tt>,
by calling the constructor <tt>make-connector</tt>, and link <tt>C</tt> and
<tt>F</tt> in an appropriate network:</p>

<p class="trans" lang="ja">
制約システムを使って、上記に概説した温度計算を実行するためには、私たちはまず、<tt>make-connector</tt> というコンストラクタを呼び出すことによって、二つのコネクタ——つまり <tt>C</tt> と <tt>F</tt> ——を作成し、そして、<tt>C</tt> と <tt>F</tt> を適切なネットワークの中につなぐ。
</p>

<p class="lisp">(define C (make-connector))
(define F (make-connector))
(celsius-fahrenheit-converter C F)
<i>ok</i>
</p>

<p class="orig" lang="en">
The procedure that creates the network is defined as follows:</p>

<p class="trans" lang="ja">
ネットワークを作成する手続きは、以下のように定義される。
</p>

<p class="lisp"><a name="%_idx_3518"></a>(define (celsius-fahrenheit-converter c f)
  (let ((u (make-connector))
        (v (make-connector))
        (w (make-connector))
        (x (make-connector))
        (y (make-connector)))
    (multiplier c w u)
    (multiplier v x u)
    (adder v y f)
    (constant 9 w)
    (constant 5 x)
    (constant 32 y)
    'ok))
</p>

<p class="orig" lang="en">
This procedure creates the internal connectors <tt>u</tt>, <tt>v</tt>, <tt>w</tt>, <tt>x</tt>, and <tt>y</tt>, and links them as shown in
figure <a href="#%_fig_3.28">3.28</a> using the primitive constraint
constructors <tt>adder</tt>, <tt>multiplier</tt>, and <tt>constant</tt>.  Just
as with the digital-circuit simulator of
section <a href="#%_sec_3.3.4">3.3.4</a>, expressing these combinations of
primitive elements in terms of procedures automatically provides our
language with a means of abstraction for compound objects.
</p>

<p class="trans" lang="ja">
この手続きは、<tt>u</tt> と <tt>v</tt> と <tt>w</tt> と <tt>x</tt> と <tt>y</tt>という内部コネクタを作成し、<tt>adder</tt> と <tt>multiplier</tt> と <tt>constant</tt> という原始的制約のコンストラクタを用いて、これらの内部コネクタを図<a href="#%_fig_3.28">3.28</a>に示すとおりにつなぐ。
<a href="#%_sec_3.3.4">3.3.4</a>節でのディジタル回路シミュレータにおけるのとちょうど同じように、手続きを用いて原始的な要素同士のこれらの組み合わせを表現すると、自動的に、私たちの言語には、複合オブジェクトのための抽象化の手段が提供されるのだ。
</p>

<p class="orig" lang="en">
To watch the network in action, we can place probes on the connectors
<tt>C</tt> and <tt>F</tt>, using a <tt>probe</tt> procedure similar to the one
we used to monitor wires in section <a href="#%_sec_3.3.4">3.3.4</a>.
Placing a probe on a connector will cause a message to be printed
whenever the connector is given a value:</p>

<p class="trans" lang="ja">
動作中のネットワークを見張るために、<tt>C</tt> と <tt>F</tt> というコネクタにプローブを設置することができる——<a href="#%_sec_3.3.4">3.3.4</a>節で配線を監視するのに用いたものに似ている、<tt>probe</tt> という手続きを使って。
コネクタにプローブを設置することは、コネクタに値が与えられるたびに印字すべきメッセージをもたらすだろう。
</p>

<p class="lisp">(probe &quot;Celsius temp&quot; C)
(probe &quot;Fahrenheit temp&quot; F)
</p>

<p class="orig" lang="en">
Next we set the value of <tt>C</tt> to 25.  (The third argument to <tt>set-value!</tt> tells <tt>C</tt> that this directive comes from the <tt>user</tt>.)</p>

<p class="trans" lang="ja">
次に、<tt>C</tt> の値を25に設定する。
(<tt>set-value!</tt> の三番目の引数は、<tt>C</tt> に対して、この<ruby><rb>指令</rb><rp> (</rp><rt>ディレクティブ</rt><rp>) </rp></ruby>が <tt>user</tt> から来ていることを知らせている。)
</p>

<p class="lisp">(set-value! C 25 'user)
<i>Probe: Celsius temp = 25</i>
<i>Probe: Fahrenheit temp = 77</i>
<i>done</i>
</p>

<p class="orig" lang="en">
The probe on <tt>C</tt> awakens and reports the value.  <tt>C</tt> also
propagates its value through the network as described above.  This
sets <tt>F</tt> to 77, which is reported by the probe on <tt>F</tt>.
</p>

<p class="trans" lang="ja">
<tt>C</tt> 上のプローブは、目覚めて、値を報告する。
<tt>C</tt> は、自分の値を、ネットワークを通じて、上述のように伝播させる。
これにより、<tt>F</tt> が77に設定され、それが <tt>F</tt> 上のプローブにより報告される。
</p>

<p class="orig" lang="en">
Now we can try to set <tt>F</tt> to a new value, say 212:
</p>

<p class="trans" lang="ja">
ここで、<tt>F</tt> を、新たな値——たとえば、212——に、設定しようと試みることができる。
</p>

<p class="lisp">(set-value! F 212 'user)
<i>Error! Contradiction (77 212)</i>
</p>

<p class="orig" lang="en">
The connector complains that it has sensed a contradiction: Its value
is 77, and someone is trying to set it to 212.  If we really want to
reuse the network with new values, we can tell <tt>C</tt> to forget its
old value:</p>

<p class="trans" lang="ja">
コネクタは、矛盾を感知した、と訴える。つまり、そのコネクタの値は77であり、かつ、誰かがそれを212に設定しようとしているところだ、と。
もし本当にこの新たな値を使ってネットワークを再利用したいならば、<tt>C</tt> に対して、古い値を忘れるように命令できる。
</p>

<p class="lisp">(forget-value! C 'user)
<i>Probe: Celsius temp = ?</i>
<i>Probe: Fahrenheit temp = ?</i>
<i>done</i>
</p>

<p class="orig" lang="en">
<tt>C</tt> finds that the <tt>user</tt>, who set its value originally, is
now retracting that value, so <tt>C</tt> agrees to lose its value, as
shown by the probe, and informs the rest of the network of this fact.
This information eventually propagates to <tt>F</tt>, which now finds
that it has no reason for continuing to believe that its own value is
77.  Thus, <tt>F</tt> also gives up its value, as shown by the probe.
</p>

<p class="trans" lang="ja">
<tt>C</tt> は、<tt>user</tt> ——最初に <tt>C</tt> の値を設定した人——が、今、その値を撤回しているところだ、と気づき、そのため<tt>C</tt> は、自分の値——プローブによって示されているとおりのもの——を失うことに同意し、ネットワークの残りの部分に対して、この事実を知らせる。
この知らせは、ついには <tt>F</tt> まで伝播し、すると<tt>F</tt> は、自分自身の値が77だと信じ続ける理由がないことに気づく。
よって、<tt>F</tt> もまた自分の値——プローブによって示されているとおりのもの——を捨て去る。
</p>

<p class="orig" lang="en">
Now that <tt>F</tt> has no value, we are free to set it to 212:</p>

<p class="trans" lang="ja">
さて今や <tt>F</tt> は値を持っていないから、私たちは自由に値を212に設定できる。
</p>

<p class="lisp">(set-value! F 212 'user)
<i>Probe: Fahrenheit temp = 212</i>
<i>Probe: Celsius temp = 100</i>
<i>done</i>
</p>

<p class="orig" lang="en">
This new value, when propagated through the network, forces <tt>C</tt> to
have a value of 100, and this is registered by the probe on <tt>C</tt>.
Notice that the very same network is being used to compute <tt>C</tt>
given <tt>F</tt> and to compute <tt>F</tt> given <tt>C</tt>.  This
nondirectionality of computation is the distinguishing feature of
constraint-based systems.</p>

<p class="trans" lang="ja">
この新たな値は、ネットワークを通じて伝播してきたときに、100という値を持つように <tt>C</tt> に強いるので、これが <tt>C</tt> 上のプローブにより登録される。
<tt>F</tt> を与えられて <tt>C</tt> を計算するのにも、<tt>C</tt> を与えられて <tt>F</tt> を計算するのにも、まさしく同じネットワークが使われているのだ、ということに気づいてほしい。
このような計算の無方向性は、制約に基づくシステムの際立った特徴である。
<span class="note">(なんかPrologで書けそうな気もするんだが、約20年も書いていないと、すっかりもう分からなくなっているな……。今度よく考えよう。)</span>
</p>

<a name="%_sec_Temp_396"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_396">Implementing the constraint system</a></h4>
<h4 class="trans" lang="ja">制約システムを実装する</h4>

<p class="orig" lang="en">
The constraint system is implemented via procedural objects with local
state, in a manner very similar to the digital-circuit simulator of
section <a href="#%_sec_3.3.4">3.3.4</a>.  Although the primitive objects
of the constraint system are somewhat more complex, the overall system
is simpler, since there is no concern about agendas and logic delays.</p>

<p class="trans" lang="ja">
制約システムは、<a href="#%_sec_3.3.4">3.3.4</a>節のディジタル回路シミュレータととてもよく似た方法で、局所状態を持った手続きオブジェクトによって、実装される。
制約システムの原始的オブジェクトは、多少は、より複雑ではあるのだが、全体のシステムは、より単純である。というのも、アジェンダとロジックの遅延についての懸念がないからである。
</p>

<p class="orig" lang="en">
<a name="%_idx_3520"></a>The basic operations on connectors are the following:
</p>

<p class="trans" lang="ja">
コネクタについての基本演算は、以下のとおりである。
</p>

<ul class="orig" lang="en">
<li><a name="%_idx_3522"></a><tt>(has-value? &lt;<em>connector</em>&gt;)</tt>
tells whether the connector has a value.</li>

<li><a name="%_idx_3524"></a><tt>(get-value &lt;<em>connector</em>&gt;)</tt>
returns the connector's current value.</li>

<li><a name="%_idx_3526"></a><tt>(set-value! &lt;<em>connector</em>&gt; &lt;<em>new-value</em>&gt; &lt;<em>informant</em>&gt;)</tt>
indicates that the informant is requesting the connector to set its
value to the new value.</li>

<li><a name="%_idx_3528"></a><tt>(forget-value! &lt;<em>connector</em>&gt; &lt;<em>retractor</em>&gt;)</tt>
tells the connector that the retractor is requesting it to forget its value.</li>

<li><a name="%_idx_3530"></a><tt>(connect &lt;<em>connector</em>&gt; &lt;<em>new-constraint</em>&gt;)</tt>
tells the connector to participate in the new constraint.</li>
</ul>

<ul class="trans" lang="ja">
<li><tt>(has-value? &lt;<em class="en">connector</em>&gt;)</tt> は、コネクタが値を持っているかどうかを知らせる。</li>

<li><tt>(get-value &lt;<em class="en">connector</em>&gt;)</tt> は、コネクタの現在の値を返す。</li>

<li><tt>(set-value! &lt;<em class="en">connector</em>&gt; &lt;<em class="en">new-value</em>&gt; &lt;<em class="en">informant</em>&gt;)</tt> は、<ruby><rb>情報提供者</rb><rp> (</rp><rt>informant</rt><rp>) </rp></ruby>がコネクタに対して、その値を新たな値に設定することを要求している、ということを示す。</li>

<li><tt>(forget-value! &lt;<em class="en">connector</em>&gt; &lt;<em class="en">retractor</em>&gt;)</tt> は、<ruby><rb>撤回者</rb><rp> (</rp><rt>retractor</rt><rp>) </rp></ruby>がコネクタに対して値を忘れるよう求めている、ということをコネクタに伝える。</li>

<li><tt>(connect &lt;<em class="en">connector</em>&gt; &lt;<em class="en">new-constraint</em>&gt;)</tt> は、コネクタに対して、新たな制約に参加するよう命令する。</li>
</ul>

<p class="orig" lang="en">
The connectors communicate with the constraints by means of the
procedures <tt>inform-about-value</tt>, which tells the given
constraint that the connector has a value, and <tt>inform-about-no-value</tt>, which tells the constraint that the connector
has lost its value.
</p>

<p class="trans" lang="ja">
コネクタは、<tt>inform-about-value</tt> ——与えられた制約に対して、コネクタが値を持っていることを伝える——および <tt>inform-about-no-value</tt> ——制約に対して、コネクタがその値を失ったことを伝える——という手続きを用いて、制約と情報を交換しあう。
</p>

<p class="orig" lang="en">
<tt>Adder</tt> constructs an adder constraint among summand connectors
<tt>a1</tt> and <tt>a2</tt> and a <tt>sum</tt> connector.  An adder is
implemented as a procedure with local state (the procedure <tt>me</tt>
below):</p>

<p class="trans" lang="ja">
<tt>adder</tt> は、<tt>a1</tt> と <tt>a2</tt> という被加数コネクタと、<tt>sum</tt> というコネクタとの間での、加算器制約を構築する。
加算器は、局所状態を有する手続き (下記の <tt>me</tt> という手続き) として実装される。
</p>

<p class="lisp"><a name="%_idx_3532"></a>(define (adder a1 a2 sum)
  (define (process-new-value)
    (cond ((and (has-value? a1) (has-value? a2))
           (set-value! sum
                       (+ (get-value a1) (get-value a2))
                       me))
          ((and (has-value? a1) (has-value? sum))
           (set-value! a2
                       (- (get-value sum) (get-value a1))
                       me))
          ((and (has-value? a2) (has-value? sum))
           (set-value! a1
                       (- (get-value sum) (get-value a2))
                       me))))
  (define (process-forget-value)
    (forget-value! sum me)
    (forget-value! a1 me)
    (forget-value! a2 me)
    (process-new-value))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)  
           (process-new-value))
          ((eq? request 'I-lost-my-value) 
           (process-forget-value))
          (else 
           (error &quot;Unknown request -- ADDER&quot; request))))
  (connect a1 me)
  (connect a2 me)
  (connect sum me)
  me)
</p>

<p class="orig" lang="en">
<tt>Adder</tt> connects the new adder to the designated connectors and
returns it as its value.  The procedure <tt>me</tt>, which represents the
adder, acts as a dispatch to the local procedures.  The following
``syntax interfaces'' (see footnote <a href="#footnote_Temp_385">27</a> in
section <a href="#%_sec_3.3.4">3.3.4</a>) are used in conjunction with the
dispatch:</p>

<p class="trans" lang="ja">
<tt>adder</tt> は新たな加算器を指定されたコネクタに接続し、その加算器を、値として返す。
<tt>me</tt> という手続き——加算器を表現している——は、局所手続きへの<ruby><rb>割り振り</rb><rp> (</rp><rt>ディスパッチ</rt><rp>) </rp></ruby>として振る舞う。
以下の「構文上のインタフェイス」(<a href="#%_sec_3.3.4">3.3.4</a>節の脚註<a href="#footnote_Temp_385">27</a>を参照) が、割り振りとともに使われる。
</p>

<p class="lisp"><a name="%_idx_3534"></a>(define (inform-about-value constraint)
  (constraint 'I-have-a-value))
<a name="%_idx_3536"></a>(define (inform-about-no-value constraint)
  (constraint 'I-lost-my-value))
</p>

<p class="orig" lang="en">
The adder's local procedure <tt>process-new-value</tt> is called when the
adder is informed that one of its connectors has a value. The adder
first checks to see if both <tt>a1</tt> and <tt>a2</tt> have values. If so,
it tells <tt>sum</tt> to set its value to the sum of the two addends.
The <tt>informant</tt> argument to <tt>set-value!</tt> is <tt>me</tt>, which is
the adder object itself.  If <tt>a1</tt> and <tt>a2</tt> do not both have
values, then the adder checks to see if perhaps <tt>a1</tt> and <tt>sum</tt>
have values.  If so, it sets <tt>a2</tt> to the difference of these two.
Finally, if <tt>a2</tt> and <tt>sum</tt> have values, this gives the adder
enough information to set <tt>a1</tt>.  If the adder is told that one of
its connectors has lost a value, it requests that all of its
connectors now lose their values.  (Only those values that were set by
this adder are actually lost.)  Then it runs <tt>process-new-value</tt>.
The reason for this last step is that one or more connectors may still
have a value (that is, a connector may have had a value that was not
originally set by the adder), and these values may need to be
propagated back through the adder.
</p>

<p class="trans" lang="ja">
加算器の <tt>process-new-value</tt> という局所手続きは、加算器のコネクタのうちの一つが値を持っている、と加算器が知らされたときに、呼び出される。
加算器はまず、<tt>a1</tt> と <tt>a2</tt> の双方が値を持っているかどうかを調べる。
もしそうなら、加算器は <tt>sum</tt> に対して、その値を、二つの被加数の和に設定するよう、命令する。
<tt>set-value!</tt> に対する <tt>informant</tt> の引数は、<tt>me</tt> ——つまり、加算器オブジェクト自体——である。
もし、<tt>a1</tt> と <tt>a2</tt> の双方ともが値を持っている、というわけではないならば、加算器は、もしかして <tt>a1</tt> と <tt>sum</tt> が値を持っているかもしれないが、どうなのかな、と調べる。
もしそうなら、加算器は、これら二つの値の差分を、<tt>a2</tt> に設定する。
最後に、もし <tt>a2</tt> と <tt>sum</tt> が値を持っていたら、このことは、加算器に対して、<tt>a1</tt> を設定するのに十分な情報を与えている。
もし加算器が、自分のコネクタのうちの一つが値を失ったことを伝えられたら、加算器は、自分のコネクタのすべてが今からは値を失う、ということを要求する。
(この加算器によって設定された値のみが、実際に失われる。)
その後、加算器は、<tt>process-new-value</tt> を実行する。
この最後のステップを行う理由は、一つまたはそれ以上のコネクタが依然として値を持っているかもしれない (つまり、あるコネクタが、この加算器によってもともと設定されたのではない値を持っていたかもしれない) からであり、加算器を通じてこれらの値を逆向きに伝播する必要があるかもしれないからである。
</p>

<p class="orig" lang="en">
A multiplier is very similar to an adder. It will set its <tt>product</tt> to 0 if either of the factors is 0, even if the other factor
is not known.</p>

<p class="trans" lang="ja">
乗算器は加算器ととてもよく似ている。
乗算器は、因子のいずれかが0であるとき、たとえ他方の因子が不明であろうとも、自分の <tt>product</tt> を0に設定する。
</p>

<p class="lisp"><a name="%_idx_3538"></a>(define (multiplier m1 m2 product)
  (define (process-new-value)
    (cond ((or (and (has-value? m1) (= (get-value m1) 0))
               (and (has-value? m2) (= (get-value m2) 0)))
           (set-value! product 0 me))
          ((and (has-value? m1) (has-value? m2))
           (set-value! product
                       (* (get-value m1) (get-value m2))
                       me))
          ((and (has-value? product) (has-value? m1))
           (set-value! m2
                       (/ (get-value product) (get-value m1))
                       me))
          ((and (has-value? product) (has-value? m2))
           (set-value! m1
                       (/ (get-value product) (get-value m2))
                       me))))
  (define (process-forget-value)
    (forget-value! product me)
    (forget-value! m1 me)
    (forget-value! m2 me)
    (process-new-value))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)
           (process-new-value))
          ((eq? request 'I-lost-my-value)
           (process-forget-value))
          (else
           (error &quot;Unknown request -- MULTIPLIER&quot; request))))
  (connect m1 me)
  (connect m2 me)
  (connect product me)
  me)
</p>

<p class="orig" lang="en">
A <tt>constant</tt> constructor simply sets the value of the designated
connector.  Any <tt>I-have-a-value</tt> or <tt>I-lost-my-value</tt> message
sent to the constant box will produce an error.</p>

<p class="trans" lang="ja">
<tt>constant</tt> というコンストラクタは、単純に、指定されたコネクタの値を設定する。
定数ボックスに送られた、<tt>I-have-a-value</tt> または <tt>I-lost-my-value</tt> というメッセージはどれも、エラーを引き起こすだろう。
</p>

<p class="lisp"><a name="%_idx_3540"></a>(define (constant value connector)
  (define (me request)
    (error &quot;Unknown request -- CONSTANT&quot; request))
  (connect connector me)
  (set-value! connector value me)
  me)
</p>

<p class="orig" lang="en">
Finally, a probe prints a message about the setting or unsetting of
the designated connector:</p>

<p class="trans" lang="ja">
最後に、プローブは、指定されたコネクタの設定または非設定についてのメッセージを印字する。
</p>

<p class="lisp"><a name="%_idx_3542"></a>(define (probe name connector)
  (define (print-probe value)
    (newline)
    (display &quot;Probe: &quot;)
    (display name)
    (display &quot; = &quot;)
    (display value))
  (define (process-new-value)
    (print-probe (get-value connector)))
  (define (process-forget-value)
    (print-probe &quot;?&quot;))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)
           (process-new-value))
          ((eq? request 'I-lost-my-value)
           (process-forget-value))
          (else
           (error &quot;Unknown request -- PROBE&quot; request))))
  (connect connector me)
  me)
</p>



<a name="%_sec_Temp_397"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_397">Representing connectors</a></h4>
<h4 class="trans" lang="ja">コネクタを表現する</h4>

<p class="orig" lang="en">
<a name="%_idx_3544"></a>
A connector is represented as a procedural object with local state
variables <tt>value</tt>, the current value of the connector; <tt>informant</tt>, the object that set the connector's value; and <tt>constraints</tt>, a list of the constraints in which the connector
participates.</p>

<p class="trans" lang="ja">
コネクタは、<tt>value</tt> ——コネクタの現在の値——と <tt>infromation</tt> ——コネクタの値を設定したオブジェクト——と <tt>constraints</tt> ——コネクタが参加している制約のリスト——という局所状態変数をもった、手続き的オブジェクトとして表現される。
</p>

<p class="lisp"><a name="%_idx_3546"></a>(define (make-connector)
  (let ((value false) (informant false) (constraints '()))
    (define (set-my-value newval setter)
      (cond ((not (has-value? me))
             (set! value newval)
             (set! informant setter)
             (for-each-except setter
                              inform-about-value
                              constraints))
            ((not (= value newval))
             (error &quot;Contradiction&quot; (list value newval)))
            (else 'ignored)))
    (define (forget-my-value retractor)
      (if (eq? retractor informant)
          (begin (set! informant false)
                 (for-each-except retractor
                                  inform-about-no-value
                                  constraints))
          'ignored))
    (define (connect new-constraint)
      (if (not (memq new-constraint constraints))
          (set! constraints 
                (cons new-constraint constraints)))
      (if (has-value? me)
          (inform-about-value new-constraint))
      'done)
    (define (me request)
      (cond ((eq? request 'has-value?)
             (if informant true false))
            ((eq? request 'value) value)
            ((eq? request 'set-value!) set-my-value)
            ((eq? request 'forget) forget-my-value)
            ((eq? request 'connect) connect)
            (else (error &quot;Unknown operation -- CONNECTOR&quot;
                         request))))
    me))
</p>

<p class="orig" lang="en">
The connector's local procedure <tt>set-my-value</tt> is called when
there is a request to set the connector's value.  If the connector
does not currently have a value, it will set its value and remember as
<tt>informant</tt> the constraint that requested the value to be
set.<a name="call_footnote_Temp_398" href="#footnote_Temp_398"><sup><small>32</small></sup></a>
Then the connector will notify all of its participating
constraints except the constraint that requested the value to be set.
This is accomplished using the following iterator, which applies a
designated procedure to all items in a list except a given one:</p>

<p class="trans" lang="ja">
コネクタの <tt>set-my-value</tt> という局所手続きは、コネクタの値を設定するように、という要求があると、呼び出される。
もし、コネクタが今のところ値を持っていなければ、コネクタは自分の値を設定して、その値を設定するように要求した制約を <tt>informant</tt> として記憶しておく<a href="#footnote_Temp_398"><sup><small>32</small></sup></a>。
それから、コネクタは、その値を設定するように要求した制約を除いて、自分が参加している制約すべてに対して、通知するだろう。
これは、以下のイテレータ——与えられた項目を除く、リスト内のすべての項目に対して、指定された手続きを適用する——を使って、達成される。
</p>

<p class="lisp"><a name="%_idx_3548"></a>(define (for-each-except exception procedure list)
  (define (loop items)
    (cond ((null? items) 'done)
          ((eq? (car items) exception) (loop (cdr items)))
          (else (procedure (car items))
                (loop (cdr items)))))
  (loop list))
</p>

<p class="orig" lang="en">
If a connector is asked to forget its value, it runs the local
procedure <tt>forget-my-value</tt>, which first checks to make sure that
the request is coming from the same object that set the value
originally.  If so, the connector informs its associated constraints
about the loss of the value.
</p>

<p class="trans" lang="ja">
もしコネクタが、値を忘れるように求められたら、コネクタは、<tt>forget-my-value</tt> という局所手続き——その求めが、その値を最初に設定したのと同じオブジェクトから来ているのだ、ということを、まず確かめる——を実行する。
もしそうなら、コネクタは、自分に関連づけられている制約に対して、値の喪失を知らせる。
</p>

<p class="orig" lang="en">
The local procedure <tt>connect</tt> adds the designated new constraint
to the list of constraints if it is not already in that list.  Then,
if the connector has a value, it informs the new constraint of this
fact.
</p>

<p class="trans" lang="ja">
<tt>connect</tt> という局所手続きは、指定された新たな制約を、制約のリストに付け加える——もしそのリスト内にその新たな制約が既に存在していなければ。
そして、もしコネクタが値を持っていれば、<tt>connect</tt> は、この事実をその新たな制約に知らせる。
</p>

<p class="orig" lang="en">
The connector's procedure <tt>me</tt> serves as a dispatch to the other
internal procedures and also represents the connector as an object.
The following procedures provide a syntax interface for the dispatch:</p>

<p class="trans" lang="ja">
コネクタの <tt>me</tt> という手続きは、他の内部手続きへの<ruby><rb>割り振り</rb><rp> (</rp><rt>ディスパッチ</rt><rp>) </rp></ruby>としてはたらき、また、コネクタをオブジェクトとして表現する。
以下の手続きは、ディスパッチに対する構文上のインタフェイスを提供する。
</p>

<p class="lisp"><a name="%_idx_3550"></a>(define (has-value? connector)
  (connector 'has-value?))
<a name="%_idx_3552"></a>(define (get-value connector)
  (connector 'value))
<a name="%_idx_3554"></a>(define (set-value! connector new-value informant)
  ((connector 'set-value!) new-value informant))
<a name="%_idx_3556"></a>(define (forget-value! connector retractor)
  ((connector 'forget) retractor))
<a name="%_idx_3558"></a>(define (connect connector new-constraint)
  ((connector 'connect) new-constraint))
</p>


<p class="orig" lang="en"><a name="%_thm_3.33"></a>
<b>Exercise 3.33.</b>  Using primitive multiplier, adder, and constant constraints, define a
procedure <a name="%_idx_3560"></a><tt>averager</tt> that takes three connectors <tt>a</tt>, <tt>b</tt>,
and <tt>c</tt> as inputs and establishes the constraint that the value of
<tt>c</tt> is the average of the values of <tt>a</tt> and <tt>b</tt>.
</p>


<p class="trans" lang="ja">
<b>練習問題3.33.</b> <tt>a</tt> と <tt>b</tt> と <tt>c</tt> という三つのコネクタを入力としてとり、<tt>c</tt> の値が <tt>a</tt> と <tt>b</tt> の値の平均であるという制約を確立する、<tt>averager</tt> という手続きを、原始的な乗算器制約と加算器制約と定数制約とを用いて、定義せよ。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.34"></a>
<b>Exercise 3.34.</b>  <a name="%_idx_3562"></a>Louis Reasoner wants to build a squarer, a constraint device with two
terminals such that the value of connector <tt>b</tt> on the second
terminal will always be the square of the value <tt>a</tt> on the first
terminal.  He proposes the following simple device made from a
multiplier:
</p>

<p class="trans" lang="ja">
<b>練習問題3.34.</b> ルイス・リーズナは、二乗器——つまり、第二端子上の <tt>b</tt> というコネクタの値が、常に、第一端子上の <tt>a</tt> という値の二乗となるような、二端子の制約装置——を構築したがっている。
彼は、乗算器から作られた、以下のような簡単な装置を提案する。
</p>

<p class="lisp">(define (squarer a b)
  (multiplier a a b))
</p>

<p class="orig" lang="en">
There is a serious flaw in this idea.  Explain.
</p>

<p class="trans" lang="ja">
この考えには深刻な瑕疵がある。説明せよ。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>


<p class="orig" lang="en"><a name="%_thm_3.35"></a>
<b>Exercise 3.35.</b>  <a name="%_idx_3564"></a>Ben Bitdiddle tells Louis that one way to avoid the trouble in
exercise <a href="#%_thm_3.34">3.34</a> is to define a squarer as a new
primitive constraint.  Fill in the missing portions in Ben's outline
for a procedure to implement such a constraint:
</p>

<p class="trans" lang="ja">
<b>練習問題3.35.</b> 練習問題<a href="#%_thm_3.34">3.34</a>での厄介事を避けるための一つの方法は、二乗器を新たな原始的制約として定義することである、と、ベン・ビットディドルはルイスに教える。
そういう制約を実装するための手続きについてのベンによる概略の中の、欠けている部分を埋めよ。
</p>


<p class="lisp">(define (squarer a b)
  (define (process-new-value)
    (if (has-value? b)
        (if (&lt; (get-value b) 0)
            (error &quot;square less than 0 -- SQUARER&quot; (get-value b))
            &lt;<em>alternative1</em>&gt;)
        &lt;<em>alternative2</em>&gt;))
  (define (process-forget-value) &lt;<em>body1</em>&gt;)
  (define (me request) &lt;<em>body2</em>&gt;)
  &lt;<em>rest of definition</em>&gt;
  me)
</p>


<p class="exercise"><span class="ex_comment">
</span></p>


<p class="orig" lang="en"><a name="%_thm_3.36"></a>
<b>Exercise 3.36.</b>  Suppose we evaluate the following sequence of expressions in the
global environment:
</p>


<p class="trans" lang="ja">
<b>練習問題3.36.</b> 大域環境内で以下の一連の式を評価するものと想定しよう。
</p>

<p class="lisp">(define a (make-connector))
(define b (make-connector))
(set-value! a 10 'user)
</p>

<p class="orig" lang="en">
At some time during evaluation of the <tt>set-value!</tt>, the following
expression from the connector's local procedure is evaluated:
</p>

<p class="trans" lang="ja">
<tt>set-value!</tt> の評価の最中のある時点において、コネクタの局所手続きからの以下の式が、評価される。
</p>

<p class="lisp">(for-each-except setter inform-about-value constraints)
</p>

<p class="orig" lang="en">
Draw an environment diagram showing the environment in which the above
expression is evaluated.
</p>

<p class="trans" lang="ja">
上記の式が評価される環境を示す環境図を描け。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>


<p class="orig" lang="en"><a name="%_thm_3.37"></a>
<b>Exercise 3.37.</b>  The <tt>celsius-fahrenheit-converter</tt> procedure is cumbersome when
compared with a more expression-oriented style of definition, such as
</p>


<p class="trans" lang="ja">
<b>練習問題3.37.</b> <tt>celsius-fahrenheit-converter</tt> の手続きは、以下のような、より式指向の様式の定義と比べると、ややこしくて非効率である。
</p>

<p class="lisp"><a name="%_idx_3566"></a>(define (celsius-fahrenheit-converter x)
  (c+ (c* (c/ (cv 9) (cv 5))
          x)
      (cv 32)))
(define C (make-connector))
(define F (celsius-fahrenheit-converter C))
</p>

<p class="orig" lang="en">
Here <tt>c+</tt>, <tt>c*</tt>, etc. are the ``constraint'' versions of the
arithmetic operations.  For example, <tt>c+</tt> takes two connectors as
arguments and returns a connector that is related to these by an adder
constraint:
</p>

<p class="trans" lang="ja">
ここで、<tt>c+</tt> や <tt>c*</tt> などは、算術演算の「制約」版である。
たとえば、<tt>c+</tt> は、二つのコネクタを引数としてとり、そして、加算器制約によってこれらのコネクタに関連づけられているコネクタを返す。
</p>

<p class="lisp">(define (c+ x y)
  (let ((z (make-connector)))
    (adder x y z)
    z))
</p>

<p class="orig" lang="en">
Define analogous procedures <tt>c-</tt>, <tt>c*</tt>, <tt>c/</tt>, and <tt>cv</tt>
(constant value) that enable us to define compound constraints as in
the converter example above.<a name="call_footnote_Temp_404" href="#footnote_Temp_404"><sup><small>33</small></sup></a>
</p>

<p class="trans" lang="ja">
上記の変換器の事例におけるような複合的制約を定義できるようにしてくれる、<tt>c-</tt> と <tt>c*</tt> と <tt>c/</tt> と <tt>cv</tt> (定数値) という、同様の手続きを定義せよ<a href="#footnote_Temp_404"><sup><small>33</small></sup></a>。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="footnotes"></a>
<hr>

<p class="orig" lang="en"><a name="footnote_Temp_349" href="#call_footnote_Temp_349"><sup><small>16</small></sup></a> <tt>Set-car!</tt> and <tt>set-cdr!</tt> return implementation-dependent
<a name="%_idx_3148"></a><a name="%_idx_3150"></a><a name="%_idx_3152"></a><a name="%_idx_3154"></a>values.  Like <tt>set!</tt>, they should be used only for their effect.
</p>

<p class="trans" lang="ja">
<tt>set-car!</tt> と <tt>set-cdr!</tt> は、実装依存の値を返す。
これらは、<tt>set!</tt> と同様、その作用のためにだけ使われるべきである。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_350" href="#call_footnote_Temp_350"><sup><small>17</small></sup></a> We see from this that mutation operations on lists
can create ``garbage'' that is not part of any accessible structure.
We will see in section <a href="33_sec5_3.html#%_sec_5.3.2">5.3.2</a> that Lisp memory-management
systems include a <a name="%_idx_3156"></a><em>garbage collector</em>, which identifies and
recycles the memory space used by unneeded pairs.
</p>

<p class="trans" lang="ja">
リストに対する変更操作が、アクセス可能ないかなる構造の一部でもないような「ごみ」を作り出すことがあり得る、ということが、このことから分かる。
<a href="33_sec5_3.html#%_sec_5.3.2">5.3.2</a>節では、Lispのメモリ管理システムが<em><ruby><rb>ガーベジ・コレクタ</rb><rp> (</rp><rt>ごみあつめをするもの</rt><rp>) </rp></ruby></em>——不必要な対により使われているメモリ空間を特定して再利用する——を含む、ということを見ることにしよう。
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_351" href="#call_footnote_Temp_351"><sup><small>18</small></sup></a> <tt>Get-new-pair</tt> is one of the operations that must be implemented as
part of the memory management required by a Lisp implementation.  We
will discuss this in section <a href="33_sec5_3.html#%_sec_5.3.1">5.3.1</a>.
</p>

<p class="trans" lang="ja">
<tt>get-new-pair</tt> は、Lispの実装によって必要とされるメモリ管理の一部として実装されねばならない演算のうちの一つである。
これについては、<a href="33_sec5_3.html#%_sec_5.3.1">5.3.1</a>節で議論しよう。
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_356" href="#call_footnote_Temp_356"><sup><small>19</small></sup></a> The two pairs
are distinct because each call to <tt>cons</tt> returns a new pair.  The
symbols are shared; in Scheme there is a unique symbol with any given
<a name="%_idx_3184"></a>name.  Since Scheme provides no way to mutate a symbol, this sharing is
undetectable.  Note also that the sharing is what enables us to
compare symbols using <tt>eq?</tt>, which simply checks equality of
pointers.
</p>

<p class="trans" lang="ja">
<tt>cons</tt> に対するそれぞれの呼び出しが新たな対を返しているので、これらの二つの対は別個のものである。
記号は共有されている。Schemeでは、与えられた任意の名前について、一意な記号が存在するのだ。
記号を変更する方法をSchemeは何も提供しないので、こうした共有は検出不能である。
また、共有こそが、<tt>eq?</tt> ——単にポインタ同士の等価性を調べる——を使って記号同士を比較できるようにしてくれるのだ、ということにも注意せよ。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_357" href="#call_footnote_Temp_357"><sup><small>20</small></sup></a> The
subtleties of dealing with sharing of mutable data objects reflect the
underlying issues of ``sameness'' and ``change'' that were raised in
section <a href="20_sec3_1.html#%_sec_3.1.3">3.1.3</a>.  We mentioned there that
admitting change to our language requires that a compound object must
have an ``identity'' that is something different from the pieces from
which it is composed.  In Lisp, we consider this ``identity'' to be
the quality that is tested by <tt>eq?</tt>, i.e., by equality of
pointers.  Since in most Lisp implementations a pointer is
essentially a memory address, we are ``solving the problem'' of
defining the identity of objects by stipulating that a data object
``itself'' is the information stored in some particular set of memory
locations in the computer.  This suffices for simple Lisp programs,
but is hardly a general way to resolve the issue of ``sameness'' in
computational models.
</p>

<p class="trans" lang="ja">
変更可能なデータオブジェクトの共有を取り扱うことの機微は、<a href="20_sec3_1.html#%_sec_3.1.3">3.1.3</a>節で提起された、「同一性」と「変化」についての、裏に潜んでいる論点を反映している。
そこでは、こう述べた。すなわち、私たちの言語に対して変化を持ち込むことを容認することは、複合オブジェクトが、その複合オブジェクトを構成する元となっている諸部分とは異なる何かであるような「自己同一性」を持たなくてはならない、ということを必要とするのだ、と。
Lispでは、この「自己同一性」のことを、<tt>eq?</tt> によって——つまり、ポインタ同士の同一性によって——検査される特質である、と考える。
ほとんどのLisp処理系において、ポインタは、本質的にはメモリアドレスであるため、私たちは、データオブジェクト「それ自体」とは、コンピュータ内の、ある特定の一群のメモリ位置に格納されている情報である、と規定することによって、オブジェクトの自己同一性を定義するという「問題を解決」している。
これは、単純なLispプログラムにとっては十分であるが、計算モデルにおける「同一性」の論点を解消するための一般的な方法などでは到底ない。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_364" href="#call_footnote_Temp_364"><sup><small>21</small></sup></a> On the other hand, from the
viewpoint of implementation, assignment requires us to modify the
environment, which is itself a mutable data structure.  Thus,
assignment and mutation are equipotent: Each can be implemented in
terms of the other.
</p>

<p class="trans" lang="ja">
一方で、実装の観点からは、<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>は私たちに対して、環境——それ自体が変更かのうなデータ構造である——を修正するように求めてくる。よって、<ruby><rb>代入</rb><rp> (</rp><rt>わりあて</rt><rp>) </rp></ruby>と<ruby><rb>変更</rb><rp> (</rp><rt>ミューテーション</rt><rp>) </rp></ruby>は、同じ効力がある。
つまり、各々が、他方を用いて実装することが可能なのである。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_366" href="#call_footnote_Temp_366"><sup><small>22</small></sup></a> If the first item is
the final item in the queue, the front pointer will be the empty list after
the deletion, which will mark the queue as empty; we needn't worry
about updating the rear pointer, which will still point to the deleted
item, because <tt>empty-queue?</tt> looks only at the front pointer.
</p>

<p class="trans" lang="ja">
もし、キューにおいて最初の項目が最後の項目であったなら、その削除の後には、先頭ポインタは空リストとなるだろうし、それによってキューは、空である、と示されるだろう。
末尾ポインタ——削除された項目を依然として指す——を更新することについては、心配する必要がない。なぜなら、<tt>empty-queue?</tt> は先頭ポインタのみを見るからである。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_370" href="#call_footnote_Temp_370"><sup><small>23</small></sup></a> Be careful not to
make the interpreter try to print a structure that contains cycles.
(See exercise <a href="#%_thm_3.13">3.13</a>.)
</p>

<p class="trans" lang="ja">
循環を含む構造を印字しよう、とインタプリタに試みさせないように、気をつけたまえ (練習問題<a href="#%_thm_3.13">3.13</a>を参照)。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_371" href="#call_footnote_Temp_371"><sup><small>24</small></sup></a> Because <tt>assoc</tt>
uses <tt>equal?</tt>, it can recognize keys that are symbols, numbers,
or list structure.
</p>

<p class="trans" lang="ja">
<tt>assoc</tt> は、<tt>equal?</tt> を使うので、記号、数、またはリスト構造であるようなキーを、認識できるのだ。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_372" href="#call_footnote_Temp_372"><sup><small>25</small></sup></a> Thus, the first backbone pair is the
object that represents the table ``itself''; that is, a pointer to the
table is a pointer to this pair.  This same backbone pair always
starts the table.  If we did not arrange things in this way, <tt>insert!</tt> would have to return a new value for the start of the table
when it added a new record.
</p>

<p class="trans" lang="ja">
よって、最初の背骨の対は、テーブル「それ自体」を表すオブジェクトである。つまり、テーブルへのポインタは、この対へのポインタである。
この同じ背骨対が、常にテーブルを開始させるのである。
もし、このようなやり方でものごとの手筈を整えたのでなかったら、<tt>insert!</tt> は、新たなレコードを追加したときに、テーブルの開始点のための新たな値を返さなくてはならなかったことだろう。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_379" href="#call_footnote_Temp_379"><sup><small>26</small></sup></a> A
full-adder is a basic circuit element used in adding two binary
numbers.  Here A and B are the bits at corresponding positions in the
two numbers to be added, and C<sub><em>i</em><em>n</em></sub> is the carry bit from the
addition one place to the right.  The circuit generates SUM, which is
the sum bit in the corresponding position, and C<sub><em>o</em><em>u</em><em>t</em></sub>, which is the
carry bit to be propagated to the left.
</p>

<p class="trans" lang="ja">
フル・アダーは、二つの2進数を足す際に使われる、基本的回路要素である。
ここで、A と B は、足されるべき二つの数における、対応する位置にあるビットであり、 C<sub><em class="en">in</em></sub> は、一つぶん右側の位置での加算からの<ruby><rb>繰り上がり</rb><rp> (</rp><rt>キャリー</rt><rp>) </rp></ruby>である。
この回路は、SUM ——対応する位置における和のビット——と、C<sub><em class="en">out</em></sub> ——左に伝播すべきキャリー・ビット——とを生成する。
</p>


<p class="orig" lang="en"><a name="footnote_Temp_385" href="#call_footnote_Temp_385"><sup><small>27</small></sup></a> These procedures are simply syntactic sugar that allow
<a name="%_idx_3400"></a><a name="%_idx_3402"></a>us to use ordinary procedural syntax to access the local procedures of
objects.  It is striking that we can interchange the role of
``procedures'' and ``data'' in such a simple way.  For example, if we
write <tt>(wire 'get-signal)</tt> we think of <tt>wire</tt> as a procedure
that is called with the message <tt>get-signal</tt> as input.
Alternatively, writing <tt>(get-signal wire)</tt> encourages us to think
of <tt>wire</tt> as a data object that is the input to a procedure <tt>get-signal</tt>.  The truth of the matter is that, in a language in which
we can deal with procedures as objects, there is no fundamental
difference between ``procedures'' and ``data,'' and we can choose our
syntactic sugar to allow us to program in whatever style we choose.
</p>

<p class="trans" lang="ja">
これらの手続きは、普通の手続き的な構文を使ってオブジェクトの局所手続きにアクセスできるようにしてくれる、単なる糖衣構文である。
こうした単純な方法で「手続き」と「データ」の役割を交換できることは、魅力的である。
たとえば、<tt>(wire 'get-signal)</tt> と書くとき、私たちは、<tt>wire</tt> を、入力としての <tt>get-signal</tt> というメッセージとともに呼ばれる手続きだ、と見なしている。
その代わり、<tt>(get-signal wire)</tt> と書くことで、私たちは、<tt>wire</tt> を、<tt>get-signal</tt> という手続きへの入力であるデータオブジェクトだ、と見なすように仕向けられるのである。
実を言うと、手続きをオブジェクトとして扱える言語においては、「手続き」と「データ」の間に根本的な違いなどないし、私たちは、自分が選ぶどのような流儀でもプログラムを組めるようにしてくれる、自分の糖衣構文を選べるのだ。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_390" href="#call_footnote_Temp_390"><sup><small>28</small></sup></a> The
agenda is a <a name="%_idx_3452"></a><a name="%_idx_3454"></a>headed list, like the tables in section <a href="#%_sec_3.3.3">3.3.3</a>,
but since the list is headed by the time, we do not need an additional
dummy header (such as the <tt>*table*</tt> symbol used with tables).
</p>

<p class="trans" lang="ja">
アジェンダは、<a href="#%_sec_3.3.3">3.3.3</a>節のテーブルと同様に頭つきのリストだが、リストの頭に時刻が付いているため、追加的なダミーのヘッダ (テーブルとともに使った、<tt>*table*</tt> という記号など) は不要である。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_391" href="#call_footnote_Temp_391"><sup><small>29</small></sup></a> Observe that the <tt>if</tt> expression in
this procedure has no
&lt;<em>alternative</em>&gt; expression.  Such a ``one-armed <tt>if</tt> statement''
<a name="%_idx_3474"></a><a name="%_idx_3476"></a>is used to decide whether to do something, rather than to select
between two expressions.  An <tt>if</tt> expression returns an
unspecified value if the predicate is false and there is no
&lt;<em>alternative</em>&gt;.
</p>

<p class="trans" lang="ja">
この手続きでの <tt>if</tt> 式には &lt;<em class="en">alternative</em>&gt; 式がないことに気づいてほしい。
このような「片腕の <tt>if</tt> 文」は、二つの式の間で選択を行うため、というよりもむしろ、何かをすべきかどうかを決めるために、使われる。
<tt>if</tt> 式は、もし述語が偽で、かつ、&lt;<em class="en">alternative</em>&gt; がなければ、不特定の値を返す。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_392" href="#call_footnote_Temp_392"><sup><small>30</small></sup></a> In this way, the current time will always be the time
of the action most recently processed.  Storing this time at the head
of the agenda ensures that it will still be available even if the
associated time segment has been deleted.
</p>

<p class="trans" lang="ja">
このやり方で、現在時刻は常に、一番最近に処理された動作の時刻になるだろう。
この時刻をアジェンダの先頭に記憶することで、関連づけられた時間区分が削除されてさえ、その時刻が依然として利用可能であるだろう、ということが確実になる。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_394" href="#call_footnote_Temp_394"><sup><small>31</small></sup></a> Constraint propagation
first appeared in the incredibly forward-looking <a name="%_idx_3486"></a>SKETCHPAD system of
<a name="%_idx_3488"></a>Ivan Sutherland (1963).  A beautiful constraint-propagation system
based on the <a name="%_idx_3490"></a>Smalltalk language was developed by <a name="%_idx_3492"></a>Alan Borning (1977)
at <a name="%_idx_3494"></a>Xerox Palo Alto Research Center.  Sussman, Stallman, and Steele
<a name="%_idx_3496"></a><a name="%_idx_3498"></a><a name="%_idx_3500"></a><a name="%_idx_3502"></a><a name="%_idx_3504"></a><a name="%_idx_3506"></a>applied constraint propagation to electrical circuit analysis (Sussman
and Stallman 1975; Sussman and Steele 1980). TK!Solver (Konopasek and
Jayaraman 1984) is an extensive modeling environment based on
constraints.
</p>

<p class="trans" lang="ja">制約伝播は、信じがたいくらい先進的な、Ivan Sutherland (1963) の SKETCHPAD システムに、最初に登場した。
Smalltalk 言語に基づく、すばらしい制約伝播システムは、Alan Borning (1977) により、Xerox Palo Alto Research Center において開発された。
Sussman と Stallman と Steele は、制約伝播を電子回路分析に適用した (Sussman and Stallman 1975; Sussman and Steele 1980)。
TK!Solver (Konopasek and Jayaraman 1984) は、制約に基づく大規模モデル化環境である。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_398" href="#call_footnote_Temp_398"><sup><small>32</small></sup></a> The <tt>setter</tt> might not be a constraint.  In our
temperature example, we used <tt>user</tt> as the <tt>setter</tt>.
</p>

<p class="trans" lang="ja">
<tt>setter</tt> は制約ではないかもしれない。
私たちの温度の事例では、<tt>user</tt> を <tt>setter</tt> として使った。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_404" href="#call_footnote_Temp_404"><sup><small>33</small></sup></a> The expression-oriented format
is convenient because it avoids the need to name the intermediate
expressions in a computation.  Our original formulation of the
<a name="%_idx_3568"></a><a name="%_idx_3570"></a><a name="%_idx_3572"></a><a name="%_idx_3574"></a><a name="%_idx_3576"></a>constraint language is cumbersome in the same way that many languages
are cumbersome when dealing with operations on compound data.  For
example, if we wanted to compute the product (<em>a</em> + <em>b</em>) &middot; (<em>c</em> + <em>d</em>), where the
variables represent vectors, we could work in ``imperative style,''
using procedures that set the values of designated vector arguments
but do not themselves return vectors as values:
</p>

<p class="trans" lang="ja">
式指向の形式は、この形式により、計算中の中間の式に名前をつける必要性を回避できるため、便利である。
制約言語についての私たちの当初の定式化は、複合的データ上の演算を扱うときに多くの言語が複雑で扱いづらいのと同じように、複雑で扱いづらい。
たとえば、変数はベクトルを表すものとして、
<span class="math">(<em class="en">a</em> + <em class="en">b</em>) &middot; (<em class="en">c</em> + <em class="en">d</em>)</span>
という積を計算したいとすると、指定されたベクトル引数の値を設定するものの自分自身はベクトルを値として返さないような手続きを用いて、「命令型の流儀」で作業できるだろう。
 </p>

<p class="lisp">(v-sum a b temp1)
(v-sum c d temp2)
(v-prod temp1 temp2 answer)
</p>

<p class="orig" lang="en">Alternatively, we could deal with expressions, using
procedures that return vectors as values, and thus avoid
explicitly mentioning <tt>temp1</tt> and <tt>temp2</tt>:
</p>

<p class="trans" lang="ja">
代わりに、ベクトルを値として返す手続きを用いて式を扱うことも可能だろうし、よって、明示的に  <tt>temp1</tt> や <tt>temp2</tt> に言及することを避けることが可能だろう。
</p>

<p class="lisp">(define answer (v-prod (v-sum a b) (v-sum c d)))
</p>

<p class="orig" lang="en">
Since Lisp allows us to return compound objects as values of
procedures, we can transform our imperative-style constraint language
into an expression-oriented style as shown in this exercise.  In
languages that are impoverished in handling compound objects, such as
Algol, Basic, and Pascal (unless one explicitly uses Pascal pointer
variables), one is usually stuck with the imperative style when
manipulating compound objects.  Given the advantage of the
expression-oriented format, one might ask if there is any reason to
have implemented the system in imperative style, as we did in this
section.  One reason is that the non-expression-oriented constraint
language provides a handle on constraint objects (e.g., the value of
the <tt>adder</tt> procedure) as well as on connector objects.  This is
useful if we wish to extend the system with new operations that
communicate with constraints directly rather than only indirectly via
operations on connectors.  Although it is easy to implement the
expression-oriented style in terms of the imperative implementation,
it is very difficult to do the converse.
</p>

<p class="trans" lang="ja">
Lispは、手続きの値として複合的オブジェクトを返すことを許しているので、本問に示したように、私たちの命令的な流儀の制約言語を、式指向の流儀へと、変換することができる。
複合的オブジェクトを扱うことにおいて貧弱な言語——たとえば、Algol や Basic や Pascal (明示的に Pascal のポインタ変数を使わない限りは) など——では、人は普通、複合的オブジェクトを操作するときに命令的な流儀から抜け出せない。
式指向の形式の利点を与えられると、人は、私たちが本節でそうしたように、命令的な流儀でシステムを実装した理由が何かあるのかどうかを尋ねるかもしれない。
一つの理由は、式指向でない制約言語が、コネクタオブジェクト上と同様に、制約オブジェクト上でも<ruby><rb>手がかり</rb><rp> (</rp><rt>ハンドル</rt><rp>) </rp></ruby> (たとえば、<tt>adder</tt> 手続きの値) を提供することである。
これは、コネクタ上の演算を介して間接的にのみ、というよりもむしろ、直接的に、制約と情報をやり取りするような、新たな演算を使って、システムを拡張したいときに、有用である。
</p>


</div>

</body>
</html>
