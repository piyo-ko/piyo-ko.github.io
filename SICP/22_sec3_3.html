<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="sicp.css" type="text/css">
<base target="_top">
<title>Structure and Interpretation of Computer Programs: SICPç§è¨³</title>
</head>
<body>

<div class="idx-bar">
<nav>
<a href="https://twitter.com/share" class="twitter-share-button" data-lang="ja">ãƒ„ã‚¤ãƒ¼ãƒˆ</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
<span class="status">æ¨æ•²å¾…ã¡</span>
[
<a href="00_cover.html">å…ˆé ­ã¸</a> |
<a href="21_sec3_2.html">å‰ã¸</a> |
<a href="23_sec3_4.html">æ¬¡ã¸</a> |
<a href="04_toc.html#%_toc_start">ç›®æ¬¡</a> |
<a href="38_index.html#%_index_start">ç´¢å¼•</a>
] [<a href="99_about.html">ã“ã®å¯¾è¨³ç‰ˆã«ã¤ã„ã¦</a> | <a href="../index.html">ãƒ›ãƒ¼ãƒ </a>]

<!--
$ curl -o ch3-Z-G-#1.gif https://mitpress.mit.edu/sicp/full-text/book/ch3-Z-G-[13-30].gif
-->
[
Â§<a href="#%_sec_3.3">3.3</a>
Â§<a href="#%_sec_3.3.1">3.3.1</a>
ğŸ¨<a href="#%_fig_3.12">3.12</a>
ğŸ¨<a href="#%_fig_3.13">3.13</a>
ğŸ¨<a href="#%_fig_3.14">3.14</a>
ğŸ¨<a href="#%_fig_3.15">3.15</a>
ğŸ“<a href="#%_thm_3.12">3.12</a>
ğŸ“<a href="#%_thm_3.13">3.13</a>
ğŸ“<a href="#%_thm_3.14">3.14</a>
ğŸ“š<a href="#%_sec_Temp_355">&hellip;</a>
ğŸ¨<a href="#%_fig_3.16">3.16</a>
ğŸ¨<a href="#%_fig_3.17">3.17</a>
ğŸ“<a href="#%_thm_3.15">3.15</a>
ğŸ“<a href="#%_thm_3.16">3.16</a>
ğŸ“<a href="#%_thm_3.17">3.17</a>
ğŸ“<a href="#%_thm_3.18">3.18</a>
ğŸ“<a href="#%_thm_3.19">3.19</a>
ğŸ“š<a href="#%_sec_Temp_363">&hellip;</a>
ğŸ“<a href="#%_thm_3.20">3.20</a>
Â§<a href="#%_sec_3.3.2">3.3.2</a>
ğŸ¨<a href="#%_fig_3.18">3.18</a>
ğŸ¨<a href="#%_fig_3.19">3.19</a>
ğŸ¨<a href="#%_fig_3.20">3.20</a>
ğŸ¨<a href="#%_fig_3.21">3.21</a>
ğŸ“<a href="#%_thm_3.21">3.21</a>
ğŸ“<a href="#%_thm_3.22">3.22</a>
ğŸ“<a href="#%_thm_3.23">3.23</a>
Â§<a href="#%_sec_3.3.3">3.3.3</a>
ğŸ¨<a href="#%_fig_3.22">3.22</a>
ğŸ“š<a href="#%_sec_Temp_373">&hellip;</a>
ğŸ¨<a href="#%_fig_3.23">3.23</a>
ğŸ“š<a href="#%_sec_Temp_374">&hellip;</a>
ğŸ“<a href="#%_thm_3.24">3.24</a>
ğŸ“<a href="#%_thm_3.25">3.25</a>
ğŸ“<a href="#%_thm_3.26">3.26</a>
ğŸ“<a href="#%_thm_3.27">3.27</a>
Â§<a href="#%_sec_3.3.4">3.3.4</a>
ğŸ¨<a href="#%_fig_3.24">3.24</a>
ğŸ¨<a href="#%_fig_3.25">3.25</a>
ğŸ¨<a href="#%_fig_3.26">3.26</a>
ğŸ“š<a href="#%_sec_Temp_380">&hellip;</a>
ğŸ“<a href="#%_thm_3.28">3.28</a>
ğŸ“<a href="#%_thm_3.29">3.29</a>
ğŸ“<a href="#%_thm_3.30">3.30</a>
ğŸ¨<a href="#%_fig_3.27">3.27</a>
ğŸ“š<a href="#%_sec_Temp_384">&hellip;</a>
ğŸ“š<a href="#%_sec_Temp_386">&hellip;</a>
ğŸ“š<a href="#%_sec_Temp_387">&hellip;</a>
ğŸ“<a href="#%_thm_3.31">3.31</a>
ğŸ“š<a href="#%_sec_Temp_389">&hellip;</a>
ğŸ“<a href="#%_thm_3.32">3.32</a>
Â§<a href="#%_sec_3.3.5">3.3.5</a>
ğŸ¨<a href="#%_fig_3.28">3.28</a>
ğŸ“š<a href="#%_sec_Temp_395">&hellip;</a>
ğŸ“š<a href="#%_sec_Temp_396">&hellip;</a>
ğŸ“š<a href="#%_sec_Temp_397">&hellip;</a>
ğŸ“<a href="#%_thm_3.33">3.33</a>
ğŸ“<a href="#%_thm_3.34">3.34</a>
ğŸ“<a href="#%_thm_3.35">3.35</a>
ğŸ“<a href="#%_thm_3.36">3.36</a>
ğŸ“<a href="#%_thm_3.37">3.37</a>
<a href="#footnotes">è„šæ³¨</a>
]
</nav>

</div>

<div class="main-txt">
<a name="%_sec_3.3"></a>
<h2 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_3.3">3.3  Modeling with Mutable Data</a></h2>
<h2 class="trans" lang="ja">3.3 å¤‰æ›´å¯èƒ½ãªãƒ‡ãƒ¼ã‚¿ã‚’ã¨ã‚‚ãªã†ãƒ¢ãƒ‡ãƒ«åŒ–</h2>

<p class="orig" lang="en">
<a name="%_idx_3128"></a>
Chapter 2 dealt with compound data as a means for constructing
computational objects that have several parts, in order to model
real-world objects that have several aspects.  In that chapter we
introduced the discipline of data abstraction, according to which data
structures are specified in terms of constructors, which create data
objects, and selectors, which access the parts of compound data
objects.  But we now know that there is another aspect of data that
chapter 2 did not address.  The desire to model systems composed of
objects that have changing state leads us to the need to modify
compound data objects, as well as to construct and select from them.
In order to model compound objects with changing state, we will design
data abstractions to include, in addition to selectors and
constructors, operations called <a name="%_idx_3130"></a><em>mutators</em>, which modify data
objects.  For instance, modeling a banking system requires us to
change account balances.  Thus, a data structure for representing bank
accounts might admit an operation
</p>

<p class="trans" lang="ja">
2ç« ã§ã¯ã€ã„ãã¤ã‹ã®å´é¢ã‚’æŒã£ãŸå®Ÿä¸–ç•Œã®<ruby><rb>ç‰©</rb><rp> (</rp><rt>ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ</rt><rp>) </rp></ruby>ã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã™ã‚‹ãŸã‚ã«ã„ãã¤ã‹ã®éƒ¨å“ã‚’æŒã£ã¦ã„ã‚‹ã‚ˆã†ãªè¨ˆç®—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ§‹ç¯‰ã™ã‚‹ãŸã‚ã®æ‰‹æ®µã¨ã—ã¦ã€è¤‡åˆçš„ãƒ‡ãƒ¼ã‚¿ã‚’å–ã‚Šæ‰±ã£ãŸã€‚
2ç« ã§ã¯ã€ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ã®è¦å¾‹ã‚’å°å…¥ã—ãŸã‚ã‘ã ãŒã€ã“ã‚Œã«ã‚ˆã‚Œã°ã€ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã¯ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿â€”â€”ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã™ã‚‹â€”â€”ã¨ã€ã‚»ãƒ¬ã‚¯ã‚¿â€”â€”è¤‡åˆãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®éƒ¨å“ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹â€”â€”ã®è¦³ç‚¹ã‹ã‚‰ã€è¦å®šã•ã‚Œã‚‹ã€‚
ã—ã‹ã—ä»Šã‚„ç§ãŸã¡ã¯ã€2ç« ã§ã¯å¯¾å‡¦ã—ãªã‹ã£ãŸã€ãƒ‡ãƒ¼ã‚¿ã®åˆ¥ã®å´é¢ãŒå­˜åœ¨ã™ã‚‹ã“ã¨ã‚’ã€çŸ¥ã£ã¦ã„ã‚‹ã®ã ã€‚
å¤‰åŒ–ã™ã‚‹çŠ¶æ…‹ã‚’æœ‰ã™ã‚‹<ruby><rb>ç‰©</rb><rp> (</rp><rt>ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ</rt><rp>) </rp></ruby>ã‹ã‚‰ãªã‚‹<ruby><rb>ç³»</rb><rp> (</rp><rt>ã‚·ã‚¹ãƒ†ãƒ </rt><rp>) </rp></ruby>ã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã™ã‚‹ã¨ã„ã†é¡˜æœ›ã¯ã€è¤‡åˆãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ§‹ç¯‰ã—ãŸã‚Šã€è¤‡åˆãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰é¸æŠã—ãŸã‚Šã™ã‚‹å¿…è¦æ€§ã ã‘ã§ãªãã€è¤‡åˆãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä¿®æ­£ã™ã‚‹å¿…è¦æ€§ã«ã¤ãªãŒã‚‹ã€‚
å¤‰åŒ–ã™ã‚‹çŠ¶æ…‹ã‚’æœ‰ã™ã‚‹è¤‡åˆçš„ãª<ruby><rb>ç‰©</rb><rp> (</rp><rt>ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ</rt><rp>) </rp></ruby>ã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã™ã‚‹ãŸã‚ã«ã€ç§ãŸã¡ã¯ã€ã‚»ãƒ¬ã‚¯ã‚¿ã¨ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«åŠ ãˆã¦ã€<em><ruby><rb>å¤‰æ›´æ¼”ç®—å­</rb><rp> (</rp><rt>ãƒŸãƒ¥ãƒ¼ãƒ†ãƒ¼ã‚¿</rt><rp>) </rp></ruby></em>ã¨å‘¼ã°ã‚Œã‚‹æ¼”ç®—â€”â€”ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä¿®æ­£ã™ã‚‹â€”â€”ã‚’å«ã‚€ã‚ˆã†ã«ã€ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ã‚’è¨­è¨ˆã—ã‚ˆã†ã€‚
ãŸã¨ãˆã°ã€éŠ€è¡Œã‚·ã‚¹ãƒ†ãƒ ã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã™ã‚‹ã“ã¨ã¯ã€å£åº§æ®‹é«˜ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ã‚’è¦ã™ã‚‹ã€‚
ã‚ˆã£ã¦ã€éŠ€è¡Œå£åº§ã‚’è¡¨ç¾ã™ã‚‹ãŸã‚ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã¯ã€æ¬¡ã®ã‚ˆã†ãªæ¼”ç®—ã‚’è¨±ã™ã‹ã‚‚ã—ã‚Œãªã„ã€‚
</p>

<p class="lisp">(set-balance! &lt;<em>account</em>&gt; &lt;<em>new-value</em>&gt;)
</p>

<p class="orig" lang="en">
that changes the balance of the designated account to the designated
new value.  Data objects for which mutators are defined are known as
<em>mutable data objects</em>.</p>

<p class="trans" lang="ja">
ã“ã‚Œã¯ã€æŒ‡å®šã•ã‚ŒãŸå£åº§ã®æ®‹é«˜ã‚’ã€æŒ‡å®šã•ã‚ŒãŸæ–°ãŸãªå€¤ã«å¤‰æ›´ã™ã‚‹ã€‚
ãƒŸãƒ¥ãƒ¼ãƒ†ãƒ¼ã‚¿ãŒå®šç¾©ã•ã‚Œã‚‹å¯¾è±¡ã¨ãªã£ã¦ã„ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€<em><ruby><rb>å¤‰å¤‰æ›´å¯èƒ½ãª</rb><rp> (</rp><rt>ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«</rt><rp>) </rp></ruby>ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ</em>ã¨ã—ã¦çŸ¥ã‚‰ã‚Œã‚‹ã€‚
</p>

<p class="orig" lang="en">
Chapter 2 introduced pairs as a general-purpose ``glue'' for
synthesizing compound data.  We begin this section by defining basic
mutators for pairs, so that pairs can serve as building blocks for
constructing mutable data objects.  These mutators greatly enhance the
representational power of pairs, enabling us to build data structures
other than the sequences and trees that we worked with in
section <a href="15_sec2_2.html#%_sec_2.2">2.2</a>.  We also present some examples of
simulations in which complex systems are modeled as collections of
objects with local state.</p>

<p class="trans" lang="ja">
2ç« ã§ã¯ã€è¤‡åˆãƒ‡ãƒ¼ã‚¿ã‚’åˆæˆã™ã‚‹ãŸã‚ã®æ±ç”¨ã®ã€Œæ¥ç€ç³Šã€ã¨ã—ã¦ã€å¯¾ã‚’å°å…¥ã—ãŸã€‚
å¯¾ã«å¯¾ã™ã‚‹åŸºæœ¬çš„ãªãƒŸãƒ¥ãƒ¼ãƒ†ãƒ¼ã‚¿ã‚’å®šç¾©ã™ã‚‹ã“ã¨ã‹ã‚‰æœ¬ç¯€ã‚’å§‹ã‚ã‚‹ãŒã€ãã®çµæœã¨ã—ã¦ã€å¯¾ã¯ã€å¤‰æ›´å¯èƒ½ãªãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ§‹ç¯‰ã™ã‚‹ãŸã‚ã®åŸºæœ¬æ§‹æˆè¦ç´ ã¨ã—ã¦ã€æ©Ÿèƒ½ã§ãã‚‹ã‚ˆã†ã«ãªã‚‹ã ã‚ã†ã€‚
ã“ã†ã—ãŸãƒŸãƒ¥ãƒ¼ãƒ†ãƒ¼ã‚¿ã¯ã€å¯¾ã®è¡¨ç¾åŠ›ã‚’éå¸¸ã«é«˜ã‚ã‚‹â€”â€”<a href="15_sec2_2.html#%_sec_2.2">2.2</a>ç¯€ã§ä½œæ¥­ã—ãŸåˆ—ã‚„æœ¨ä»¥å¤–ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚‚æ§‹ç¯‰ã§ãã‚‹ã‚ˆã†ã«ã—ã¦ãã‚Œã‚‹ã®ã ã€‚
å±€æ‰€çŠ¶æ…‹ã‚’æœ‰ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é›†ã¾ã‚Šã¨ã—ã¦è¤‡é›‘ãªç³»ãŒãƒ¢ãƒ‡ãƒ«åŒ–ã•ã‚Œã¦ã„ã‚‹ã‚ˆã†ãªã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®ä¾‹ã‚‚ã€ã„ãã¤ã‹æç¤ºã™ã‚‹ã€‚
</p>

<a name="%_sec_3.3.1"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_3.3.1">3.3.1  Mutable List Structure</a></h3>
<h3 class="trans" lang="ja">3.3.1 å¤‰æ›´å¯èƒ½ãªãƒªã‚¹ãƒˆæ§‹é€ </h3>

<p class="orig" lang="en">
<a name="%_idx_3132"></a><a name="%_idx_3134"></a>
<a name="%_idx_3136"></a><a name="%_idx_3138"></a>
The basic operations on pairs -- <tt>cons</tt>, <tt>car</tt>, and <tt>cdr</tt> -- can be used to construct list structure and to select parts
from list structure, but they are incapable of modifying list
structure.  The same is true of the list operations we have used so
far, such as <tt>append</tt> and <tt>list</tt>, since these can be defined
in terms of <tt>cons</tt>, <tt>car</tt>, and <tt>cdr</tt>.  To modify list
structures we need new operations.</p>

<p class="trans" lang="ja">
å¯¾ã«å¯¾ã™ã‚‹åŸºæœ¬çš„ãªæ¼”ç®—â€”â€” <tt>cons</tt> ã¨ <tt>car</tt> ã¨ <tt>cdr</tt> â€”â€”ã¯ã€ãƒªã‚¹ãƒˆæ§‹é€ ã‚’æ§‹ç¯‰ã™ã‚‹ã®ã«ä½¿ãˆã‚‹ã—ã€ãƒªã‚¹ãƒˆæ§‹é€ ã‹ã‚‰ä¸€éƒ¨ã‚’é¸æŠã™ã‚‹ã®ã«ã‚‚ä½¿ãˆã‚‹ãŒã€ã“ã‚Œã‚‰ã®æ¼”ç®—ã¯ã€ãƒªã‚¹ãƒˆæ§‹é€ ã‚’ä¿®æ­£ã™ã‚‹ã“ã¨ã¯ã§ããªã„ã€‚
åŒã˜ã“ã¨ã¯ã€ã“ã“ã¾ã§ä½¿ã£ã¦ããŸãƒªã‚¹ãƒˆæ¼”ç®—â€”â€” <tt>append</tt> ã‚„ <tt>list</tt> ãªã©â€”â€”ã«ã¤ã„ã¦ã‚‚è¨€ãˆã‚‹ã€‚ã¨ã„ã†ã®ã‚‚ã€ã“ã‚Œã‚‰ã®æ¼”ç®—ã¯ã€<tt>cons</tt> ã¨ <tt>car</tt> ã¨ <tt>cdr</tt> ã‚’ä½¿ã£ã¦å®šç¾©ã•ã‚Œå¾—ã‚‹ã‚‚ã®ã ã‹ã‚‰ã§ã‚ã‚‹ã€‚
ãƒªã‚¹ãƒˆæ§‹é€ ã‚’ä¿®æ­£ã™ã‚‹ã«ã¯ã€æ–°ã—ã„æ¼”ç®—ãŒå¿…è¦ã ã€‚
</p>

<a name="%_fig_3.12"></a>
<figure>
<img src="ch3-Z-G-13.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.12:</b>  Lists <tt>x</tt>: <tt>((a b) c d)</tt> and <tt>y</tt>: <tt>(e f)</tt>.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³3.12:</b> <tt>x</tt>: <tt>((a b) c d)</tt> ãŠã‚ˆã³ <tt>y</tt>: <tt>(e f)</tt> ãªã‚‹ãƒªã‚¹ãƒˆ</figcaption>
</figure>

<a name="%_fig_3.13"></a>
<figure>
<img src="ch3-Z-G-14.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.13:</b>  Effect of <tt>(set-car! x y)</tt> on the lists in figure <a href="#%_fig_3.12">3.12</a>.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³3.13:</b> å›³<a href="#%_fig_3.12">3.12</a>ã®ãƒªã‚¹ãƒˆã«å¯¾ã™ã‚‹ã€<tt>(set-car! x y)</tt> ã®å½±éŸ¿</figcaption>
</figure>

<a name="%_fig_3.14"></a>
<figure>
<img src="ch3-Z-G-15.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.14:</b>  Effect of <tt>(define z (cons y (cdr x)))</tt> on the lists in figure <a href="#%_fig_3.12">3.12</a>.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³3.14:</b> å›³<a href="#%_fig_3.12">3.12</a>ã®ãƒªã‚¹ãƒˆã«å¯¾ã™ã‚‹ã€<tt>(define z (cons y (cdr x)))</tt> ã®å½±éŸ¿</figcaption>
</figure>

<a name="%_fig_3.15"></a>
<figure>
<img src="ch3-Z-G-16.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.15:</b>  Effect of <tt>(set-cdr! x y)</tt> on the lists in figure <a href="#%_fig_3.12">3.12</a>.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³3.15:</b> å›³<a href="#%_fig_3.12">3.12</a>ã®ãƒªã‚¹ãƒˆã«å¯¾ã™ã‚‹ã€<tt>(set-cdr! x y)</tt> ã®å½±éŸ¿</figcaption>
</figure>

<p class="orig" lang="en">
<a name="%_idx_3140"></a><a name="%_idx_3142"></a><a name="%_idx_3144"></a><a name="%_idx_3146"></a>The primitive mutators for pairs are <tt>set-car!</tt> and <tt>set-cdr!</tt>. <tt>Set-car!</tt> takes two arguments, the first of which
must be a pair.  It modifies this pair, replacing the <tt>car</tt>
pointer by a pointer to the second argument of <tt>set-car!</tt>.<a name="call_footnote_Temp_349" href="#footnote_Temp_349"><sup><small>16</small></sup></a>
</p>

<p class="trans" lang="ja">
å¯¾ã«å¯¾ã™ã‚‹åŸå§‹çš„ãƒŸãƒ¥ãƒ¼ãƒ†ãƒ¼ã‚¿ã¯ã€<tt>set-car!</tt> ã¨ <tt>set-cdr!</tt> ã ã€‚
<tt>set-car!</tt> ã¯äºŒã¤ã®å¼•æ•°ã‚’ã¨ã‚Šã€ãã‚Œã‚‰ã®ã†ã¡ã®æœ€åˆã®ã‚‚ã®ã¯ã€å¯¾ã§ãªãã¦ã¯ãªã‚‰ãªã„ã€‚
<tt>set-car!</tt> ã¯ã“ã®å¯¾ã‚’ä¿®æ­£ã™ã‚‹â€”â€”ã¤ã¾ã‚Šã€<tt>car</tt> ãƒã‚¤ãƒ³ã‚¿ã‚’ã€<tt>set-car!</tt> ã®ç¬¬äºŒå¼•æ•°ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿ã§ç½®ãæ›ãˆã‚‹<a href="#footnote_Temp_349"><sup><small>16</small></sup></a>ã€‚
</p>

<p class="orig" lang="en">
As an example, suppose that <tt>x</tt> is bound to the list <tt>((a b) c
d)</tt> and <tt>y</tt> to the list <tt>(e f)</tt> as illustrated in
figure <a href="#%_fig_3.12">3.12</a>.  Evaluating the expression <tt>(set-car!
x y)</tt> modifies the pair to which <tt>x</tt> is bound, replacing its <tt>car</tt> by the value of <tt>y</tt>.  The result of the operation is shown in
figure <a href="#%_fig_3.13">3.13</a>.  The structure <tt>x</tt> has been modified and
would now be printed
as <tt>((e f) c d)</tt>.  The
pairs representing the list <tt>(a b)</tt>, identified by the pointer
that was replaced, are now detached from the original
structure.<a name="call_footnote_Temp_350" href="#footnote_Temp_350"><sup><small>17</small></sup></a>
</p>

<p class="trans" lang="ja">
ä¾‹ã¨ã—ã¦ã€å›³<a href="#%_fig_3.12">3.12</a>ã«ç¤ºã™ã‚ˆã†ã«ã€<tt>x</tt> ãŒ 
<tt>((a b) c d)</tt> ã¨ã„ã†ãƒªã‚¹ãƒˆã«æŸç¸›ã•ã‚Œã¦ãŠã‚Šã€ã‹ã¤ã€<tt>y</tt> ãŒ
<tt>(e f)</tt> ã¨ã„ã†ãƒªã‚¹ãƒˆã«æŸç¸›ã•ã‚Œã¦ã„ã‚‹ã‚‚ã®ã¨ã™ã‚‹ã€‚
<tt>(set-car! x y)</tt> ã¨ã„ã†å¼ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ã§ã€<tt>x</tt> ãŒæŸç¸›ã•ã‚Œã¦ã„ã‚‹å¯¾ãŒã€ä¿®æ­£ã•ã‚Œã‚‹â€”â€”ã¤ã¾ã‚Šã€ã“ã®å¯¾ã® <tt>car</tt> ã‚’ <tt>y</tt> ã®å€¤ã§ç½®ãæ›ãˆã‚‹ã‚ã‘ã§ã‚ã‚‹ã€‚
ã“ã®æ¼”ç®—ã®çµæœã¯ã€å›³<a href="#%_fig_3.13">3.13</a>ã«ç¤ºã•ã‚Œã¦ã„ã‚‹ã€‚
<tt>x</tt> ã®æ§‹é€ ã¯ã€ä¿®æ­£ã•ã‚ŒãŸã®ã§ã‚ã‚Šã€ãã—ã¦ä»Šã‚„ã€<tt>((e f) c d)</tt> ã¨å°åˆ·ã•ã‚Œã‚‹ã“ã¨ã ã‚ã†ã€‚
<tt>(a b)</tt> ã¨ã„ã†ãƒªã‚¹ãƒˆã‚’è¡¨ç¾ã™ã‚‹å¯¾â€”â€”ç½®ãæ›ãˆã‚‰ã‚ŒãŸãƒã‚¤ãƒ³ã‚¿ã«ã‚ˆã‚Šè­˜åˆ¥ã•ã‚Œã‚‹ã‚‚ã®â€”â€”ã¯ã€ä»Šã‚„ã€å…ƒã®æ§‹é€ ã‹ã‚‰ã¯åˆ‡ã‚Šé›¢ã•ã‚Œã¦ã„ã‚‹<a href="#footnote_Temp_350"><sup><small>17</small></sup></a>ã€‚
</p>

<p class="orig" lang="en">
Compare figure <a href="#%_fig_3.13">3.13</a> with figure <a href="#%_fig_3.14">3.14</a>,
which illustrates the result of executing <tt>(define z (cons y (cdr
x)))</tt> with <tt>x</tt> and <tt>y</tt> bound to the original lists of
figure <a href="#%_fig_3.12">3.12</a>.  The variable <tt>z</tt> is now bound to a
new pair created by the <tt>cons</tt> operation; the list to which <tt>x</tt> is bound is unchanged.
</p>

<p class="trans" lang="ja">
å›³<a href="#%_fig_3.13">3.13</a>ã‚’ã€å›³<a href="#%_fig_3.14">3.14</a>â€”â€”å›³<a href="#%_fig_3.12">3.12</a>ã®å…ƒã®ãƒªã‚¹ãƒˆã«æŸç¸›ã•ã‚Œã¦ã„ã‚‹ <tt>x</tt> ã¨ <tt>y</tt> ã‚’ä½¿ã£ã¦ã€<tt>(define z (cons y (cdr x)))</tt> ã‚’å®Ÿè¡Œã—ãŸçµæœâ€”â€”ã¨æ¯”ã¹ã‚ˆã€‚
<tt>z</tt> ã¨ã„ã†å¤‰æ•°ã¯ã€ã“ã“ã§ã€<tt>cons</tt> æ¼”ç®—ã«ã‚ˆã‚Šä½œæˆã•ã‚ŒãŸæ–°ãŸãªå¯¾ã«ã€æŸç¸›ã•ã‚Œã¦ã„ã‚‹ã€‚ãã—ã¦ã€<tt>x</tt> ãŒæŸç¸›ã•ã‚Œã¦ã„ã‚‹ãƒªã‚¹ãƒˆã¯ã€ãã®ã¾ã¾ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
The <tt>set-cdr!</tt> operation is similar to <tt>set-car!</tt>.  The
only difference is that the <tt>cdr</tt> pointer of the pair, rather than
the <tt>car</tt> pointer, is replaced.  The effect of executing <tt>(set-cdr! x y)</tt> on the lists of figure <a href="#%_fig_3.12">3.12</a> is shown
in figure <a href="#%_fig_3.15">3.15</a>.
Here the <tt>cdr</tt> pointer of <tt>x</tt> has been replaced by the pointer
to <tt>(e f)</tt>.  Also, the list <tt>(c d)</tt>, which used to be the <tt>cdr</tt> of <tt>x</tt>, is now detached from the structure.
</p>

<p class="trans" lang="ja">
<tt>set-cdr!</tt> æ¼”ç®—ã¯ã€ <tt>set-car!</tt> æ¼”ç®—ã«ä¼¼ã¦ã„ã‚‹ã€‚
å”¯ä¸€ã®é•ã„ã¯ã€å¯¾ã®ã€<tt>car</tt> ãƒã‚¤ãƒ³ã‚¿ã§ã¯ãªãã‚€ã—ã‚ <tt>cdr</tt> ãƒã‚¤ãƒ³ã‚¿ãŒã€ç½®æ›ã•ã‚Œã‚‹ã¨ã„ã†ç‚¹ã§ã‚ã‚‹ã€‚
å›³<a href="#%_fig_3.12">3.12</a>ã®ãƒªã‚¹ãƒˆã«å¯¾ã—ã¦ <tt>(set-cdr! x y)</tt> ã‚’å®Ÿè¡Œã—ãŸåŠ¹æœãŒã€å›³<a href="#%_fig_3.15">3.15</a>ã«ç¤ºã•ã‚Œã¦ã„ã‚‹ã€‚
ã“ã“ã§ã€<tt>x</tt> ã® <tt>cdr</tt> ãƒã‚¤ãƒ³ã‚¿ã¯ã€<tt>(e f)</tt> ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿ã«ç½®ãæ›ãˆã‚‰ã‚ŒãŸã€‚
ã¾ãŸã€<tt>(c d)</tt> ã¨ã„ã†ãƒªã‚¹ãƒˆâ€”â€”ã‹ã¤ã¦ã¯ <tt>x</tt> ã® <tt>cdr</tt> ã ã£ãŸâ€”â€”ã¯ã€ä»Šã‚„å½“è©²æ§‹é€ ã‹ã‚‰åˆ‡ã‚Šé›¢ã•ã‚Œã¦ã„ã‚‹ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_3158"></a><tt>Cons</tt> builds new list structure by creating new pairs, while
<tt>set-car!</tt> and <tt>set-cdr!</tt> modify existing pairs.  Indeed, we
could implement <tt>cons</tt> in terms of the two mutators, together with
a procedure <tt>get-new-pair</tt>, which returns a new pair that is not
part of any existing list structure.  We obtain the new pair, set its
<tt>car</tt> and <tt>cdr</tt> pointers to the designated objects, and return
the new pair as the result of the <tt>cons</tt>.<a name="call_footnote_Temp_351" href="#footnote_Temp_351"><sup><small>18</small></sup></a>
</p>

<p class="trans" lang="ja">
<tt>cons</tt> ãŒæ–°ãŸãªå¯¾ã‚’ä½œæˆã™ã‚‹ã“ã¨ã§æ–°ãŸãªãƒªã‚¹ãƒˆæ§‹é€ ã‚’æ§‹ç¯‰ã™ã‚‹ã®ã«å¯¾ã—ã¦ã€<tt>set-car!</tt> ã¨ <tt>set-cdr!</tt> ã¯æ—¢å­˜ã®å¯¾ã‚’ä¿®æ­£ã™ã‚‹ã€‚
å®Ÿéš›ã€ã“ã‚Œã‚‰äºŒã¤ã®ãƒŸãƒ¥ãƒ¼ãƒ†ãƒ¼ã‚¿ã‚’ã€<tt>get-new-pair</tt> ã¨ã„ã†æ‰‹ç¶šãâ€”â€”ã„ã‹ãªã‚‹æ—¢å­˜ã®ãƒªã‚¹ãƒˆæ§‹é€ ã®éƒ¨åˆ†ã§ã‚‚ãªã„ã€æ–°ãŸãªå¯¾ã‚’è¿”ã™â€”â€”ã¨ä¸€ç·’ã«ä½¿ã£ã¦ã€<tt>cons</tt> ã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ãŒã§ããŸã ã‚ã†ã€‚
æ–°ã—ã„å¯¾ã‚’å¾—ã¦ã€ãã‚Œã® <tt>car</tt> ã¨ <tt>cdr</tt> ã®ãƒã‚¤ãƒ³ã‚¿ã‚’ã€æŒ‡å®šã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«è¨­å®šã—ã€ãã®æ–°ã—ã„å¯¾ã‚’ã€<tt>cons</tt> ã®çµæœã¨ã—ã¦è¿”ã™ã®ã§ã‚ã‚‹<a href="#footnote_Temp_351"><sup><small>18</small></sup></a>ã€‚
</p>

<p class="lisp"><a name="%_idx_3160"></a>(define (cons x y)
  (let ((new (get-new-pair)))
    (set-car! new x)
    (set-cdr! new y)
    new))
</p>

<p class="orig" lang="en">
<a name="%_thm_3.12"></a>
<b>Exercise 3.12.</b>  <a name="%_idx_3162"></a>The following procedure for appending lists was introduced in
section <a href="15_sec2_2.html#%_sec_2.2.1">2.2.1</a>:
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.12.</b> ãƒªã‚¹ãƒˆåŒå£«ã‚’ã¤ãªã’ã‚‹ãŸã‚ã®ä»¥ä¸‹ã®æ‰‹ç¶šãã‚’ã€<a href="15_sec2_2.html#%_sec_2.2.1">2.2.1</a>ç¯€ã§å°å…¥ã—ãŸã€‚
</p>

<p class="lisp"><a name="%_idx_3164"></a>(define (append x y)
  (if (null? x)
      y
      (cons (car x) (append (cdr x) y))))
</p>

<p class="orig" lang="en">
<tt>Append</tt> forms a new list by successively <tt>cons</tt>ing the
elements of <tt>x</tt> onto <tt>y</tt>.  The procedure <tt>append!</tt> is
similar to <tt>append</tt>, but it is a mutator rather than a constructor.
It appends the lists by splicing them together, modifying the final
pair of <tt>x</tt> so that its <tt>cdr</tt> is now <tt>y</tt>.
(It is an error to call <tt>append!</tt> with an empty <tt>x</tt>.)
</p>

<p class="trans" lang="ja">
<tt>append</tt> ã¯ã€<tt>y</tt> ã®ä¸Šã« <tt>x</tt> ã®è¦ç´ ã‚’æ¬¡ã€…ã¨ <tt>cons</tt> ã—ã¦è¡Œãã“ã¨ã«ã‚ˆã£ã¦ã€æ–°ãŸãªãƒªã‚¹ãƒˆã‚’å½¢æˆã™ã‚‹ã€‚
<tt>append!</tt> ã¨ã„ã†æ‰‹ç¶šãã¯ã€<tt>append</tt> ã«ä¼¼ã¦ã„ã‚‹ãŒã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¨ã„ã†ã‚ˆã‚Šã‚€ã—ã‚ãƒŸãƒ¥ãƒ¼ãƒ†ãƒ¼ã‚¿ã§ã‚ã‚‹ã€‚
ã“ã‚Œã¯ã€ãƒªã‚¹ãƒˆåŒå£«ã‚’ç¶™ãåˆã‚ã›ã¦ä¸€ã¤ã«ã™ã‚‹ã“ã¨ã§ã€ãƒªã‚¹ãƒˆåŒå£«ã‚’ã¤ãªã’ã‚‹â€”â€” <tt>x</tt>ã®æœ€å¾Œã®å¯¾ã® <tt>cdr</tt> ãŒã€ä»Šã‚„ <tt>y</tt> ã¨ãªã‚‹ã‚ˆã†ã«ã€<tt>x</tt>ã®æœ€å¾Œã®å¯¾ã‚’ä¿®æ­£ã—ã¦ã‚†ãã®ã§ã‚ã‚‹ã€‚
(ç©ºã® <tt>x</tt> ã«å¯¾ã—ã¦ <tt>append!</tt> ã‚’å‘¼ã³å‡ºã™ã®ã¯ã€ã‚¨ãƒ©ãƒ¼ã§ã‚ã‚‹ã€‚)
</p>

<p class="lisp"><a name="%_idx_3166"></a>(define (append! x y)
  (set-cdr! (last-pair x) y)
  x)
</p>

<p class="orig" lang="en">
Here <tt>last-pair</tt> is a procedure that returns the last pair in its
argument:
</p>

<p class="trans" lang="ja">
ã“ã“ã§ã€<tt>last-pair</tt> ã¯ã€å¼•æ•°ã®ä¸­ã®æœ€å¾Œã®å¯¾ã‚’è¿”ã™æ‰‹ç¶šãã§ã‚ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_3168"></a>(define (last-pair x)
  (if (null? (cdr x))
      x
      (last-pair (cdr x))))
</p>

<p class="orig" lang="en">
Consider the interaction
</p>

<p class="trans" lang="ja">
ä»¥ä¸‹ã®ã‚„ã‚Šã¨ã‚Šã‚’è€ƒãˆã‚ˆã†ã€‚
</p>

<p class="lisp">(define x (list 'a 'b))
(define y (list 'c 'd))
(define z (append x y))
z
<i>(a b c d)</i>
(cdr x)
&lt;<em>response</em>&gt;
(define w (append! x y))
w
<i>(a b c d)</i>
(cdr x)
&lt;<em>response</em>&gt;
</p>

<p class="orig" lang="en">
What are the missing &lt;<em>response</em>&gt;s?
Draw box-and-pointer diagrams to explain your answer.
</p>

<p class="trans" lang="ja">
æ¬ ã‘ã¦ã„ã‚‹å¿œç­” (&lt;<em class="en">response</em>&gt;) ã¯ã€ã©ã®ã‚ˆã†ãªã‚‚ã®ã§ã‚ã‚ã†ã‹?
ç®±ã¨ãƒã‚¤ãƒ³ã‚¿ã®å›³ã‚’æã„ã¦ã€ç­”ãˆã‚’èª¬æ˜ã—ãŸã¾ãˆã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_3.13"></a>
<b>Exercise 3.13.</b>  <a name="%_idx_3170"></a>Consider the following <tt>make-cycle</tt> procedure, which uses the <tt>last-pair</tt> procedure defined in exercise <a href="#%_thm_3.12">3.12</a>:
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.13.</b> ä»¥ä¸‹ã® <tt>make-cycle</tt> ã¨ã„ã†æ‰‹ç¶šãâ€”â€”ç·´ç¿’å•é¡Œ<a href="#%_thm_3.12">3.12</a> ã§å®šç¾©ã—ãŸ <tt>last-pair</tt> ã®æ‰‹ç¶šãã‚’ä½¿ã£ã¦ã„ã‚‹â€”â€”ã‚’è€ƒãˆã‚ˆã€‚
</p>

<p class="lisp"><a name="%_idx_3172"></a>(define (make-cycle x)
  (set-cdr! (last-pair x) x)
  x)
</p>

<p class="orig" lang="en">
Draw a box-and-pointer diagram that shows the structure <tt>z</tt>
created by
</p>

<p class="trans" lang="ja">
ä»¥ä¸‹ã®ã‚ˆã†ã«ã™ã‚‹ã“ã¨ã§ä½œã‚‰ã‚Œã‚‹ <tt>z</tt> ã¨ã„ã†æ§‹é€ ã‚’ç¤ºã™ã‚ˆã†ãªã€ç®±ã¨ãƒã‚¤ãƒ³ã‚¿ã®å›³ã‚’æã‘ã€‚
</p>

<p class="lisp">(define z (make-cycle (list 'a 'b 'c)))
</p>

<p class="orig" lang="en">
What happens if we try to compute <tt>(last-pair z)</tt>?
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="trans" lang="ja">
ã‚‚ã—ã€<tt>(last-pair z)</tt> ã‚’è¨ˆç®—ã—ã‚ˆã†ã¨ã—ãŸã‚‰ã€ä½•ãŒèµ·ãã‚‹ã ã‚ã†?
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_3.14"></a>
<b>Exercise 3.14.</b>  The following procedure is quite useful, although obscure:
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.14.</b> ä»¥ä¸‹ã®æ‰‹ç¶šãã¯ã€æ™¦æ¸‹ã§ã¯ã‚ã‚‹ã‚‚ã®ã®ã€éå¸¸ã«æœ‰ç”¨ã§ã‚ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_3174"></a>(define (mystery x)
  (define (loop x y)
    (if (null? x)
        y
        (let ((temp (cdr x)))
          (set-cdr! x y)
          (loop temp x))))
  (loop x '()))
</p>

<p class="orig" lang="en">
<tt>Loop</tt> uses the ``temporary'' variable <tt>temp</tt> to hold
the old value of the <tt>cdr</tt> of <tt>x</tt>, since the <tt>set-cdr!</tt>
on the next line destroys the <tt>cdr</tt>.  Explain what <tt>mystery</tt>
does in general.  Suppose <tt>v</tt> is defined by <tt>(define v (list 'a
'b 'c 'd))</tt>. Draw the box-and-pointer diagram that represents the list
to which <tt>v</tt> is bound.  Suppose that we now evaluate <tt>(define
w (mystery v))</tt>. Draw box-and-pointer diagrams that show the
structures <tt>v</tt> and <tt>w</tt> after evaluating this expression.  What
would be printed as the values of <tt>v</tt> and <tt>w</tt> ?</p>

<p class="trans" lang="ja">
<tt>loop</tt> ã¯ã€<tt>x</tt> ã® <tt>cdr</tt> ã®å…ƒã®å€¤ã‚’ä¿æŒã™ã‚‹ãŸã‚ã«ã€<tt>temp</tt> ã¨ã„ã†ã€Œè‡¨æ™‚çš„ãªã€å¤‰æ•°ã‚’ä½¿ã†ã€‚ã¨ã„ã†ã®ã‚‚ã€æ¬¡ã®è¡Œã® <tt>set-cdr!</tt> ãŒã€å½“è©² <tt>cdr</tt> ã‚’ç ´å£Šã™ã‚‹ã‹ã‚‰ã§ã‚ã‚‹ã€‚
ä¸€èˆ¬ã« <tt>mystery</tt> ãŒä½•ã‚’ã™ã‚‹ã®ã‹ã‚’èª¬æ˜ã›ã‚ˆã€‚
<tt>(define v (list 'a 'b 'c 'd))</tt> ã«ã‚ˆã‚Š <tt>v</tt> ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‚‚ã®ã¨ã›ã‚ˆã€‚
<tt>v</tt> ãŒæŸç¸›ã•ã‚Œã¦ã„ã‚‹ãƒªã‚¹ãƒˆã‚’è¡¨ç¾ã™ã‚‹ã‚ˆã†ãªã€ç®±ã¨ãƒã‚¤ãƒ³ã‚¿ã®å›³ã‚’æã‘ã€‚
ä»Šã€<tt>(define w (mystery v))</tt> ã‚’è©•ä¾¡ã™ã‚‹ã‚‚ã®ã¨ã—ã‚ˆã†ã€‚
ã“ã®å¼ã‚’è©•ä¾¡ã—ãŸå¾Œã® <tt>v</tt> ã¨ <tt>w</tt> ã®æ§‹é€ ã‚’ç¤ºã™ã‚ˆã†ãªã€ç®±ã¨ãƒã‚¤ãƒ³ã‚¿ã®å›³ã‚’æã‘ã€‚
<tt>v</tt> ã¨ <tt>w</tt> ã®å€¤ã¨ã—ã¦ã€ä½•ãŒå°åˆ·ã•ã‚Œã‚‹ã ã‚ã†ã‹?
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_Temp_355"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_355">Sharing and identity</a></h4>
<h4 class="trans" lang="ja">å…±æœ‰ã¨è‡ªå·±åŒä¸€æ€§ã¨</h4>

<p class="orig" lang="en">
<a name="%_idx_3176"></a><a name="%_idx_3178"></a>
<a name="%_idx_3180"></a><a name="%_idx_3182"></a>We mentioned in section <a href="20_sec3_1.html#%_sec_3.1.3">3.1.3</a> the theoretical
issues of ``sameness'' and ``change'' raised by the introduction of
assignment.  These issues arise in practice when individual pairs are
<em>shared</em> among different data objects.  For example, consider the
structure formed by
</p>

<p class="trans" lang="ja">
<a href="20_sec3_1.html#%_sec_3.1.3">3.1.3</a>ç¯€ã§ã¯ã€<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã®å°å…¥ã«ã‚ˆã£ã¦å¼•ãèµ·ã“ã•ã‚ŒãŸã€ã€ŒåŒä¸€æ€§ã€ã¨ã€Œå¤‰åŒ–ã€ã«ã¤ã„ã¦ã®ç†è«–ä¸Šã®å•é¡Œã«ã¤ã„ã¦è¿°ã¹ãŸã€‚
ã“ã‚Œã‚‰ã®å•é¡Œã¯ã€å€‹ã€…ã®å¯¾ãŒç•°ãªã‚‹ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é–“ã§<em>å…±æœ‰ã•ã‚Œã‚‹</em>å ´åˆã«ã€å®Ÿéš›ã«ç”Ÿã˜ã‚‹ã€‚
ãŸã¨ãˆã°ã€ä»¥ä¸‹ã«ã‚ˆã‚Šä½œã‚‰ã‚Œã‚‹æ§‹é€ ã‚’è€ƒãˆã‚ˆã†ã€‚
</p>

<p class="lisp">(define x (list 'a 'b))
(define z1 (cons x x))
</p>

<p class="orig" lang="en">
As shown in figure <a href="#%_fig_3.16">3.16</a>, <tt>z1</tt> is a pair whose <tt>car</tt> and <tt>cdr</tt> both point to the same pair <tt>x</tt>.  This sharing
of <tt>x</tt> by the <tt>car</tt> and <tt>cdr</tt> of <tt>z1</tt> is a consequence
of the straightforward way in which <tt>cons</tt> is implemented.  In
general, using <tt>cons</tt> to construct lists will result in an
interlinked structure of pairs in which many individual pairs are
shared by many different structures.</p>

<p class="trans" lang="ja">
å›³<a href="#%_fig_3.16">3.16</a>ã«ç¤ºã™ã‚ˆã†ã«ã€<tt>z1</tt> ã¯ã€<tt>car</tt> ã¨ <tt>cdr</tt> ã®åŒæ–¹ãŒã€<tt>x</tt> ã¨ã„ã†åŒã˜å¯¾ã‚’æŒ‡ã—ã¦ã„ã‚‹ã‚ˆã†ãªã€å¯¾ã§ã‚ã‚‹ã€‚
<tt>z1</tt> ã®<tt>car</tt> ã¨ <tt>cdr</tt> ã«ã‚ˆã‚‹ã€ã“ã®ã‚ˆã†ãª <tt>x</tt> ã®å…±æœ‰ã¯ã€<tt>cons</tt> ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹å˜ç´”ãªæ–¹æ³•ã®å¸°çµã§ã‚ã‚‹ã€‚
ä¸€èˆ¬ã«ã€ãƒªã‚¹ãƒˆã‚’æ§‹æˆã™ã‚‹ã®ã« <tt>cons</tt> ã‚’ä½¿ã†ã“ã¨ã¯ã€ãã®ä¸­ã§ã¯å¤šãã®å€‹ã€…ã®å¯¾ãŒå¤šãã®ç•°ãªã‚‹æ§‹é€ ã«ã‚ˆã£ã¦å…±æœ‰ã•ã‚Œã¦ã„ã‚‹ã‚ˆã†ãªã€å¯¾ã®é€£çµã•ã‚ŒãŸæ§‹é€ ã€ã¨ã„ã†çµæœã«ãªã‚‹ã ã‚ã†ã€‚
</p>


<a name="%_fig_3.16"></a>
<figure>
<img src="ch3-Z-G-17.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.16:</b>  The list <tt>z1</tt> formed by <tt>(cons x x)</tt>.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³3.16:</b> <tt>(cons x x)</tt> ã«ã‚ˆã‚Šä½œã‚‰ã‚Œã‚‹ <tt>z1</tt> ã¨ã„ã†ãƒªã‚¹ãƒˆ</figcaption>
</figure>

<a name="%_fig_3.17"></a>
<figure>
<img src="ch3-Z-G-18.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.17:</b>  The list <tt>z2</tt> formed by <tt>(cons (list 'a 'b) (list 'a 'b))</tt>.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³3.17:</b> <tt>(cons (list 'a 'b) (list 'a 'b))</tt> ã«ã‚ˆã‚Šä½œã‚‰ã‚Œã‚‹ <tt>z2</tt> ã¨ã„ã†ãƒªã‚¹ãƒˆ</figcaption>
</figure>

<p class="orig" lang="en">
In contrast to figure <a href="#%_fig_3.16">3.16</a>, figure <a href="#%_fig_3.17">3.17</a> shows
the structure created by
</p>

<p class="trans" lang="ja">
å›³<a href="#%_fig_3.16">3.16</a>ã¨ã¯å¯¾ç…§çš„ã«ã€å›³<a href="#%_fig_3.17">3.17</a>ã¯ã€ä»¥ä¸‹ã«ã‚ˆã‚Šä½œæˆã•ã‚ŒãŸæ§‹é€ ã‚’ç¤ºã—ã¦ã„ã‚‹ã€‚
</p>

<p class="lisp">(define z2 (cons (list 'a 'b) (list 'a 'b)))
</p>

<p class="orig" lang="en">
In this structure, the pairs in the two <tt>(a b)</tt> lists are
distinct, although the actual symbols are shared.<a name="call_footnote_Temp_356" href="#footnote_Temp_356"><sup><small>19</small></sup></a>
</p>

<p class="trans" lang="ja">
ã“ã®æ§‹é€ ã§ã¯ã€äºŒã¤ã® <tt>(a b)</tt> ã¨ã„ã†ãƒªã‚¹ãƒˆã®ä¸­ã®å¯¾ã¯ã€åˆ¥å€‹ã®ã‚‚ã®ã§ã‚ã‚‹â€”â€”ã‚‚ã£ã¨ã‚‚ã€å®Ÿéš›ã®è¨˜å·ã¯å…±æœ‰ã•ã‚Œã¦ã„ã‚‹ãŒ<a href="#footnote_Temp_356"><sup><small>19</small></sup></a>ã€‚
</p>

<p class="orig" lang="en">
When thought of as a list, <tt>z1</tt> and <tt>z2</tt> both represent ``the
same'' list, <tt>((a b) a b)</tt>.  In general, sharing is completely
undetectable if we operate on lists using only <tt>cons</tt>, <tt>car</tt>,
and <tt>cdr</tt>.  However, if we allow mutators on list structure,
sharing becomes significant.  As an example of the difference that
sharing can make, consider the following procedure, which modifies the
<tt>car</tt> of the structure to which it is applied:
</p>

<p class="trans" lang="ja">
ãƒªã‚¹ãƒˆã¨ã—ã¦è€ƒãˆãŸå ´åˆã«ã¯ã€<tt>z1</tt> ã¨ <tt>z2</tt> ã®åŒæ–¹ã¯ã€ã€ŒåŒã˜ã€ãƒªã‚¹ãƒˆâ€”â€”ã™ãªã‚ã¡ã€<tt>((a b) a b)</tt> â€”â€”ã‚’è¡¨ç¾ã™ã‚‹ã€‚
ä¸€èˆ¬ã«ã€ã‚‚ã— <tt>cons</tt> ã¨ <tt>car</tt> ã¨ <tt>cdr</tt> ã®ã¿ã‚’ä½¿ã£ã¦ãƒªã‚¹ãƒˆä¸Šã§æ¼”ç®—ã‚’è¡Œã†ãªã‚‰ã°ã€å…±æœ‰ã¯ã€å®Œå…¨ã«æ¤œçŸ¥ä¸èƒ½ã§ã‚ã‚‹ã€‚
ã—ã‹ã—ã€ã‚‚ã—ãƒªã‚¹ãƒˆæ§‹é€ ä¸Šã§ã®ãƒŸãƒ¥ãƒ¼ãƒ†ãƒ¼ã‚¿ã‚’è¨±å®¹ã™ã‚‹ãªã‚‰ã€å…±æœ‰ã¯ç›®ç«‹ã¤ã‚ˆã†ã«ãªã‚‹ã€‚
å…±æœ‰ã«ã‚ˆã‚Šä½œã‚Šå‡ºã•ã‚Œã‚‹ã“ã¨ã®ã‚ã‚‹å·®ç•°ã®ä¸€ä¾‹ã¨ã—ã¦ã€ä»¥ä¸‹ã®æ‰‹ç¶šãâ€”â€”é©ç”¨å…ˆã®æ§‹é€ ã® <tt>car</tt> ã‚’ä¿®æ­£ã™ã‚‹â€”â€”ã‚’è€ƒãˆã‚ˆã†ã€‚
</p>

<p class="lisp">(define (set-to-wow! x)
  (set-car! (car x) 'wow)
  x)
</p>

<p class="orig" lang="en">
Even though <tt>z1</tt> and <tt>z2</tt> are ``the same'' structure,
applying <tt>set-to-wow!</tt> to them yields different results.  With
<tt>z1</tt>, altering the <tt>car</tt> also changes the <tt>cdr</tt>, because
in <tt>z1</tt> the <tt>car</tt> and the <tt>cdr</tt> are the same pair.  With
<tt>z2</tt>, the <tt>car</tt> and <tt>cdr</tt> are distinct, so <tt>set-to-wow!</tt> modifies only the <tt>car</tt>:
</p>

<p class="trans" lang="ja">
ãŸã¨ãˆ <tt>z1</tt> ã¨ <tt>z2</tt> ãŒã€ŒåŒã˜ã€æ§‹é€ ã§ã‚ã‚‹ã¨ã¯ã„ã£ã¦ã‚‚ã€<tt>z1</tt> ã¨ <tt>z2</tt> ã« <tt>set-to-wow!</tt> ã‚’é©ç”¨ã™ã‚‹ã¨ã€ç•°ãªã‚‹çµæœã‚’ç”Ÿã¿å‡ºã™ã€‚
<tt>z1</tt> ã«ã¤ã„ã¦ã¯ã€<tt>car</tt> ã‚’å¤‰ãˆã‚‹ã“ã¨ã§ã€<tt>cdr</tt> ã‚‚å¤‰æ›´ã•ã‚Œã‚‹â€”â€”ãªãœãªã‚‰ã€<tt>z1</tt> ã®ä¸­ã§ã¯ã€<tt>car</tt> ã¨ <tt>cdr</tt> ã¯åŒã˜å¯¾ã ã‹ã‚‰ã§ã‚ã‚‹ã€‚
<tt>z2</tt> ã«ã¤ã„ã¦ã¯ã€<tt>car</tt> ã¨ <tt>cdr</tt> ãŒåˆ¥å€‹ã®ã‚‚ã®ã§ã‚ã‚‹ã‹ã‚‰ã€<tt>set-to-wow!</tt> ã¯ <tt>car</tt> ã®ã¿ã‚’ä¿®æ­£ã™ã‚‹ã€‚
</p>

<p class="lisp">z1
<i>((a b) a b)</i>

(set-to-wow! z1)
<i>((wow b) wow b)</i>

z2
<i>((a b) a b)</i>

(set-to-wow! z2)
<i>((wow b) a b)</i>
</p>

<p class="orig" lang="en">
One way to detect sharing in list structures is to use the predicate
<a name="%_idx_3186"></a><a name="%_idx_3188"></a><tt>eq?</tt>, which we introduced in section <a href="16_sec2_3.html#%_sec_2.3.1">2.3.1</a> as a
way to test whether two symbols are equal.  More generally, <tt>(eq?
x y)</tt> tests whether <tt>x</tt> and <tt>y</tt> are the same object (that is,
whether <tt>x</tt> and <tt>y</tt> are equal as pointers).  Thus, with <tt>z1</tt> and <tt>z2</tt> as defined in figures <a href="#%_fig_3.16">3.16</a>
and <a href="#%_fig_3.17">3.17</a>, <tt>(eq? (car z1) (cdr z1))</tt> is true and
<tt>(eq? (car z2) (cdr z2))</tt> is false.
</p>

<p class="trans" lang="ja">
ãƒªã‚¹ãƒˆæ§‹é€ ã«ãŠã‘ã‚‹å…±æœ‰ã‚’æ¤œå‡ºã™ã‚‹ãŸã‚ã®ä¸€ã¤ã®æ–¹æ³•ã¯ã€<tt>eq?</tt> ã¨ã„ã†è¿°èªâ€”â€”äºŒã¤ã®è¨˜å·ãŒç­‰ã—ã„ã‹ã©ã†ã‹ã‚’æ¤œæŸ»ã™ã‚‹ãŸã‚ã®æ‰‹æ®µã¨ã—ã¦ã€<a href="16_sec2_3.html#%_sec_2.3.1">2.3.1</a>ç¯€ã§å°å…¥ã—ãŸã‚‚ã®â€”â€”ã‚’ä½¿ã†ã“ã¨ã§ã‚ã‚‹ã€‚
ã‚ˆã‚Šä¸€èˆ¬çš„ã«è¨€ã†ã¨ã€<tt>(eq? x y)</tt> ã¯ã€<tt>x</tt> ã¨ <tt>y</tt> ãŒåŒã˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã©ã†ã‹ (ã¤ã¾ã‚Šã€<tt>x</tt> ã¨ <tt>y</tt> ãŒãƒã‚¤ãƒ³ã‚¿ã¨ã—ã¦ç­‰ã—ã„ã‹ã©ã†ã‹) ã‚’æ¤œæŸ»ã™ã‚‹ã€‚
ã‚ˆã£ã¦ã€å›³<a href="#%_fig_3.16">3.16</a>ã¨å›³<a href="#%_fig_3.17">3.17</a>ã®ã‚ˆã†ã«å®šç¾©ã•ã‚ŒãŸ <tt>z1</tt> ã¨ <tt>z2</tt> ã«ã¤ã„ã¦ã¯ã€
<tt>(eq? (car z1) (cdr z1))</tt> ã¯çœŸã§ã€
<tt>(eq? (car z2) (cdr z2))</tt> ã¯å½ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_3190"></a>As will be seen in the following sections, we can exploit sharing to
greatly extend the repertoire of data structures that can be
represented by pairs.  On the other hand, sharing can also be
dangerous, since modifications made to structures will also affect
other structures that happen to share the modified parts.  The
mutation operations <tt>set-car!</tt> and <tt>set-cdr!</tt> should be used
with care; unless we have a good understanding of how our data objects
are shared, mutation can have unanticipated results.<a name="call_footnote_Temp_357" href="#footnote_Temp_357"><sup><small>20</small></sup></a>
</p>

<p class="trans" lang="ja">
ä»¥ä¸‹ã®ç¯€ã§è¦‹ã‚‹ã“ã¨ã«ãªã‚‹ã‚ˆã†ã«ã€å¯¾ã«ã‚ˆã£ã¦è¡¨ç¾ã§ãã‚‹ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã®ãƒ¬ãƒ‘ãƒ¼ãƒˆãƒªãƒ¼ã‚’å¤§ã„ã«åºƒã’ã‚‹ãŸã‚ã«ã€å…±æœ‰ã‚’æ´»ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
ä¸€æ–¹ã§ã€å…±æœ‰ã¯å±é™ºã«ã‚‚ãªã‚Šå¾—ã‚‹â€”â€”ã¨ã„ã†ã®ã‚‚ã€æ§‹é€ ã«å¯¾ã—ã¦ãªã•ã‚ŒãŸæ”¹å¤‰ã¯ã€ãã®ä¿®æ­£ã•ã‚ŒãŸéƒ¨åˆ†ã‚’ãŸã¾ãŸã¾å…±æœ‰ã—ã¦ã„ã‚‹ä»–ã®æ§‹é€ ã«ã‚‚ã€å½±éŸ¿ã—ã¦ã—ã¾ã†ã§ã‚ã‚ã†ã‹ã‚‰ã€‚
<ruby><rb>å¤‰æ›´</rb><rp> (</rp><rt>ãƒŸãƒ¥ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³</rt><rp>) </rp></ruby>ã®æ¼”ç®—ã§ã‚ã‚‹ <tt>set-car!</tt> ã¨ <tt>set-cdr!</tt> ã¯ã€æ³¨æ„æ·±ãä½¿ã†ã¹ãã§ã‚ã‚‹ã€‚è‡ªåˆ†ã®ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã©ã®ã‚ˆã†ã«å…±æœ‰ã•ã‚Œã¦ã„ã‚‹ã®ã‹ã«ã¤ã„ã¦ã€ã¡ã‚ƒã‚“ã¨ç†è§£ã—ã¦ã„ã‚‹ã®ã§ãªã„é™ã‚Šã€<ruby><rb>å¤‰æ›´</rb><rp> (</rp><rt>ãƒŸãƒ¥ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³</rt><rp>) </rp></ruby>ã¯ã€äºˆæœŸã›ã¬çµæœã‚’æ‹›ãå¾—ã‚‹<a href="#footnote_Temp_357"><sup><small>20</small></sup></a>ã€‚
</p>

<p class="orig" lang="en">
<a name="%_thm_3.15"></a>
<b>Exercise 3.15.</b>  Draw box-and-pointer diagrams to explain the effect of <tt>set-to-wow!</tt> on the structures <tt>z1</tt> and <tt>z2</tt> above.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.15.</b> ä¸Šè¨˜ã® <tt>z1</tt> ã¨ <tt>z2</tt> ã¨ã„ã†æ§‹é€ ã«å¯¾ã™ã‚‹ <tt>set-to-wow!</tt> ã®ä½œç”¨ã‚’èª¬æ˜ã™ã‚‹ãŸã‚ã®ã€ç®±ã¨ãƒã‚¤ãƒ³ã‚¿ã®å›³ã‚’æã‘ã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_3.16"></a>
<b>Exercise 3.16.</b>  Ben Bitdiddle decides to write a procedure to count the number of
pairs in any list structure.  ``It's easy,'' he reasons.  ``The number
of pairs in any structure is the number in the <tt>car</tt> plus the
number in the <tt>cdr</tt> plus one more to count the current pair.''
So Ben writes the following procedure:
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.16.</b> ãƒ™ãƒ³ãƒ»ãƒ“ãƒƒãƒˆãƒ‡ã‚£ãƒ‰ãƒ«ã¯ã€ä»»æ„ã®ãƒªã‚¹ãƒˆæ§‹é€ ã®ä¸­ã®å¯¾ã®å€‹æ•°ã‚’æ•°ãˆã‚‹æ‰‹ç¶šãã‚’æ›¸ãã“ã¨ã‚’æ±ºæ„ã™ã‚‹ã€‚
ã€Œç°¡å˜ã ã‚ˆã­ã€ã¨å½¼ã¯æ¨æ¸¬ã™ã‚‹ã€‚
ã€Œä»»æ„ã®æ§‹é€ ã®ä¸­ã®å¯¾ã®å€‹æ•°ã¨ã¯ã€<tt>car</tt> ã®ä¸­ã®å€‹æ•°ã€è¶³ã™ã€<tt>cdr</tt> ã®ä¸­ã®å€‹æ•°ã€è¶³ã™ã€ã‚ã¨ã¯ä»Šè¦‹ã¦ã„ã‚‹ã“ã®å¯¾ã‚’æ•°ãˆã‚‹ãŸã‚ã®1ã€ã ã‚ˆã€
ã‚ˆã£ã¦ã€ãƒ™ãƒ³ã¯ã€ä»¥ä¸‹ã®æ‰‹ç¶šãã‚’æ›¸ãã€‚
</p>

<p class="lisp"><a name="%_idx_3192"></a>(define (count-pairs x)
  (if (not (pair? x))
      0
      (+ (count-pairs (car x))
         (count-pairs (cdr x))
         1)))
</p>

<p class="orig" lang="en">
Show that this procedure is not correct.  In particular, draw
box-and-pointer diagrams representing list structures made up of
exactly three pairs for which Ben's procedure would return 3; return
4; return 7; never return at all.
</p>

<p class="trans" lang="ja">
ã“ã®æ‰‹ç¶šããŒæ­£ã—ããªã„ã“ã¨ã‚’ç¤ºã›ã€‚
ç‰¹ã«ã€ãã£ã‹ã‚Šä¸‰ã¤ã®å¯¾ã‹ã‚‰ä½œã‚‰ã‚Œã¦ã„ã‚‹ãƒªã‚¹ãƒˆæ§‹é€ ã§ã€ãƒ™ãƒ³ã®æ‰‹ç¶šããŒ3ã‚’è¿”ã™ã ã‚ã†ã€ã¨ã„ã†ã‚‚ã®ã¨ã€4ã‚’è¿”ã™ã ã‚ã†ã€ã¨ã„ã†ã‚‚ã®ã¨ã€7ã‚’è¿”ã™ã ã‚ã†ã€ã¨ã„ã†ã‚‚ã®ã¨ã€æ±ºã—ã¦ä½•ã‚‚è¿”ã•ãªã„ã ã‚ã†ã€ã¨ã„ã†ã‚‚ã®ã‚’è¡¨ç¾ã™ã‚‹ã€ç®±ã¨ãƒã‚¤ãƒ³ã‚¿ã®å›³ã‚’æã‘ã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_3.17"></a>
<b>Exercise 3.17.</b>  Devise a correct version of the <tt>count-pairs</tt> procedure of
exercise <a href="#%_thm_3.16">3.16</a> that returns the number of distinct
pairs in any structure.  (Hint: Traverse the structure, maintaining an
auxiliary data structure that is used to keep track of which pairs
have already been counted.)
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.17.</b> ä»»æ„ã®æ§‹é€ ã«ãŠã‘ã‚‹åˆ¥å€‹ã®å¯¾ã®æ•°ã‚’è¿”ã™ã‚ˆã†ãªã€ç·´ç¿’å•é¡Œ<a href="#%_thm_3.16">3.16</a>ã® <tt>count-pairs</tt> ã¨ã„ã†æ‰‹ç¶šãã®æ­£ã—ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’è€ƒæ¡ˆã›ã‚ˆã€‚
(ãƒ’ãƒ³ãƒˆ: ãã®æ§‹é€ ã®å…¨ä½“ã‚’ã€ã©ã®å¯¾ã‚’æ—¢ã«æ•°ãˆãŸã‹ã¨ã„ã†çµŒéã‚’æŠŠæ¡ã—ã¦ãŠããŸã‚ã«ä½¿ã‚ã‚Œã‚‹è£œåŠ©çš„ãªãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’ç¶­æŒã—ãªãŒã‚‰ã€è¦‹ã¦å›ã‚Œã€‚)
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_3.18"></a>
<b>Exercise 3.18.</b>  <a name="%_idx_3194"></a>Write a procedure that examines a list and determines whether it
contains a cycle, that is, whether a program that tried to find the
end of the list by taking successive <tt>cdr</tt>s would go into an
infinite loop.  Exercise <a href="#%_thm_3.13">3.13</a> constructed such lists.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.18.</b> ãƒªã‚¹ãƒˆã‚’èª¿ã¹ã¦ã€ãã®ãƒªã‚¹ãƒˆãŒå¾ªç’°ã‚’å«ã‚“ã§ã„ã‚‹ã‹ã©ã†ã‹â€”â€”ã¤ã¾ã‚Šã€é€£ç¶šçš„ã« <tt>cdr</tt> ã‚’å–ã£ã¦ã„ãã“ã¨ã§ãƒªã‚¹ãƒˆã®çµ‚ã‚ã‚Šã‚’è¦‹ã¤ã‘ã‚ˆã†ã¨ã™ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒã€ç„¡é™ãƒ«ãƒ¼ãƒ—ã«é™¥ã‚‹ã“ã¨ã«ãªã‚‹ã‹ã©ã†ã‹â€”â€”ã‚’åˆ¤æ–­ã™ã‚‹ã‚ˆã†ãªæ‰‹ç¶šãã‚’æ›¸ã‘ã€‚
ç·´ç¿’å•é¡Œ<a href="#%_thm_3.13">3.13</a>ã¯ã€ãã†ã„ã†ãƒªã‚¹ãƒˆã‚’æ§‹ç¯‰ã—ãŸã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_3.19"></a>
<b>Exercise 3.19.</b>  Redo exercise <a href="#%_thm_3.18">3.18</a> using an algorithm that takes only a
constant amount of space.  (This requires a very clever idea.)
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.19.</b> å®šæ•°é‡ã®ç©ºé–“ã—ã‹å¿…è¦ã¨ã—ãªã„ã‚ˆã†ãªã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’ä½¿ã£ã¦ã€ç·´ç¿’å•é¡Œ<a href="#%_thm_3.18">3.18</a>ã‚’ã‚„ã‚Šç›´ã›ã€‚
(ã“ã‚Œã«ã¯éå¸¸ã«å·§ã¿ãªè€ƒãˆãŒå¿…è¦ã§ã‚ã‚‹ã€‚)
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_Temp_363"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_363">Mutation is just assignment</a></h4>
<h4 class="trans" lang="ja"><ruby><rb>å¤‰æ›´</rb><rp> (</rp><rt>ãƒŸãƒ¥ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³</rt><rp>) </rp></ruby>ã¨ã¯ã¾ã•ã«<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã§ã‚ã‚‹</h4>

<p class="orig" lang="en">
<a name="%_idx_3196"></a><a name="%_idx_3198"></a><a name="%_idx_3200"></a><a name="%_idx_3202"></a>
When we introduced compound data, we observed in
section <a href="14_sec2_1.html#%_sec_2.1.3">2.1.3</a> that pairs can be represented purely in terms
of procedures:
</p>

<p class="trans" lang="ja">
è¤‡åˆçš„ãƒ‡ãƒ¼ã‚¿ã‚’å°å…¥ã—ãŸã¨ãã€<a href="14_sec2_1.html#%_sec_2.1.3">2.1.3</a>ç¯€ã§ç§ãŸã¡ã¯ã€ç´”ç²‹ã«æ‰‹ç¶šãã ã‘ã‚’ä½¿ã£ã¦å¯¾ã‚’è¡¨ç¾ã§ãã‚‹ã“ã¨ã‚’è¦³å¯Ÿã—ãŸã€‚
</p>

<p class="lisp"><a name="%_idx_3204"></a>(define (cons x y)
  (define (dispatch m)
    (cond ((eq? m 'car) x)
          ((eq? m 'cdr) y)
          (else (error &quot;Undefined operation -- CONS&quot; m))))
  dispatch)
<a name="%_idx_3206"></a>(define (car z) (z 'car))
<a name="%_idx_3208"></a>(define (cdr z) (z 'cdr))
</p>

<p class="orig" lang="en">
The same observation is true for mutable data.  We can implement
mutable data objects as procedures using assignment and local state.
For instance, we can extend the above pair implementation to handle
<tt>set-car!</tt> and <tt>set-cdr!</tt> in a manner analogous to the way
we implemented bank accounts using <tt>make-account</tt> in
section <a href="20_sec3_1.html#%_sec_3.1.1">3.1.1</a>:
</p>

<p class="trans" lang="ja">
ã“ã®åŒã˜è¦³å¯Ÿçµæœã¯ã€<ruby><rb>å¤‰æ›´å¯èƒ½</rb><rp> (</rp><rt>ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«</rt><rp>) </rp></ruby>ãªãƒ‡ãƒ¼ã‚¿ã«å¯¾ã—ã¦ã‚‚çœŸã§ã‚ã‚‹ã€‚
<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã¨å±€æ‰€çŠ¶æ…‹ã¨ã‚’ç”¨ã„ã¦ã€å¤‰æ›´å¯èƒ½ãªãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã€æ‰‹ç¶šãã¨ã—ã¦å®Ÿè£…ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã®ã ã€‚
ãŸã¨ãˆã°ã€<a href="20_sec3_1.html#%_sec_3.1.1">3.1.1</a>ç¯€ã§ <tt>make-account</tt> ã‚’ç”¨ã„ã¦éŠ€è¡Œå£åº§ã‚’å®Ÿè£…ã—ãŸæ–¹æ³•ã¨é¡ä¼¼ã®ã‚„ã‚Šæ–¹ã§ <tt>set-car!</tt> ã¨ <tt>set-cdr!</tt> ã‚’æ‰±ã†ã‚ˆã†ã«ã€ä¸Šè¨˜ã®å¯¾ã®å®Ÿè£…ã‚’æ‹¡å¼µã§ãã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_3210"></a>(define (cons x y)
  (define (set-x! v) (set! x v))
  (define (set-y! v) (set! y v))
  (define (dispatch m)
    (cond ((eq? m 'car) x)
          ((eq? m 'cdr) y)
          ((eq? m 'set-car!) set-x!)
          ((eq? m 'set-cdr!) set-y!)
          (else (error &quot;Undefined operation -- CONS&quot; m))))
  dispatch)
<a name="%_idx_3212"></a>(define (car z) (z 'car))
<a name="%_idx_3214"></a>(define (cdr z) (z 'cdr))
<a name="%_idx_3216"></a>(define (set-car! z new-value)
  ((z 'set-car!) new-value)
  z)
<a name="%_idx_3218"></a>(define (set-cdr! z new-value)
  ((z 'set-cdr!) new-value)
  z)
</p>

<p class="orig" lang="en">
Assignment is all that is needed, theoretically, to account for the
behavior of mutable data.  As soon as we admit <tt>set!</tt> to our
language, we raise all the issues, not only of assignment, but of
mutable data in general.<a name="call_footnote_Temp_364" href="#footnote_Temp_364"><sup><small>21</small></sup></a>
</p>

<p class="trans" lang="ja">
<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ãŒã€å¤‰æ›´å¯èƒ½ãªãƒ‡ãƒ¼ã‚¿ã®æŒ¯ã‚‹èˆã„ã‚’èª¬æ˜ã™ã‚‹ã®ã«ç†è«–ä¸Šå¿…è¦ãªã™ã¹ã¦ã€ãªã®ã§ã‚ã‚‹ã€‚
ç§ãŸã¡ã®è¨€èªã« <tt>set!</tt> ã‚’å—ã‘å…¥ã‚Œã‚‹ã“ã¨ã‚’èªã‚ã‚‹ã‚„å¦ã‚„ã€ç§ãŸã¡ã¯ã€ã™ã¹ã¦ã®å•é¡Œç‚¹ã‚’â€”â€”<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã«ã¤ã„ã¦ã®å•é¡Œç‚¹ã ã‘ã§ãªãã€å¤‰æ›´å¯èƒ½ãªãƒ‡ãƒ¼ã‚¿ä¸€èˆ¬ã«ã¤ã„ã¦ã®å•é¡Œç‚¹ã‚’ã‚‚â€”â€”æèµ·ã™ã‚‹ã®ã <a href="#footnote_Temp_364"><sup><small>21</small></sup></a>
ã€‚
</p>

<p class="orig" lang="en">
<a name="%_thm_3.20"></a>
<b>Exercise 3.20.</b>  Draw environment diagrams to illustrate the evaluation of the sequence
of expressions
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.20.</b> ä»¥ä¸‹ã®ä¸€é€£ã®å¼ã®è©•ä¾¡ã‚’å›³ç¤ºã™ã‚‹ãŸã‚ã®ç’°å¢ƒå›³ã‚’æã‘ã€‚
</p>

<p class="lisp">(define x (cons 1 2))
(define z (cons x x))
(set-car! (cdr z) 17)
(car x)
<i>17</i>
</p>

<p class="orig" lang="en">
using the procedural implementation of pairs given above.  (Compare
exercise <a href="21_sec3_2.html#%_thm_3.11">3.11</a>.)
</p>

<p class="trans" lang="ja">
ãŸã ã—ã€ä¸Šè¨˜ã®æ‰‹ç¶šãã«ã‚ˆã‚‹å¯¾ã®å®Ÿè£…ã‚’ç”¨ã„ã‚‹ã‚ˆã†ã«ã€‚
(ç·´ç¿’å•é¡Œ<a href="21_sec3_2.html#%_thm_3.11">3.11</a>ã¨æ¯”ã¹ã¦ã”ã‚‰ã‚“ã€‚)
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_3.3.2"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_3.3.2">3.3.2  Representing Queues</a></h3>
<h3 class="trans" lang="ja">3.3.2 ã‚­ãƒ¥ãƒ¼ã‚’è¡¨ç¾ã™ã‚‹</h3>

<p class="orig" lang="en">
<a name="%_idx_3220"></a>
The mutators <tt>set-car!</tt> and <tt>set-cdr!</tt> enable us to use
pairs to construct data structures that cannot be built with <tt>cons</tt>, <tt>car</tt>, and <tt>cdr</tt> alone.  This section shows how to use
pairs to represent a data structure called a queue.  Section <a href="#%_sec_3.3.3">3.3.3</a>
will show how to represent data structures called tables.</p>

<p class="trans" lang="ja">
<tt>set-car!</tt> ãŠã‚ˆã³ <tt>set-cdr!</tt> ã¨ã„ã†ãƒŸãƒ¥ãƒ¼ãƒ†ãƒ¼ã‚¿ã«ã‚ˆã£ã¦ã€ç§ãŸã¡ã¯ã€<tt>cons</tt> ã¨ <tt>car</tt> ã¨ <tt>cdr</tt> ã ã‘ã§ã¯ç¯‰ãã“ã¨ã®ã§ããªã„ã‚ˆã†ãªãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’ã€å¯¾ã‚’ä½¿ã£ã¦æ§‹ç¯‰ã§ãã‚‹ã‚ˆã†ã«ãªã‚‹ã®ã ã€‚
æœ¬ç¯€ã§ã¯ã€ã‚­ãƒ¥ãƒ¼ã¨å‘¼ã°ã‚Œã‚‹ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’ã€ã©ã®ã‚ˆã†ã«å¯¾ã‚’ä½¿ã£ã¦è¡¨ç¾ã™ã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’ç¤ºã™ã€‚
<a href="#%_sec_3.3.3">3.3.3</a>ç¯€ã§ã¯ã€ãƒ†ãƒ¼ãƒ–ãƒ«ã¨å‘¼ã°ã‚Œã‚‹ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’ã©ã®ã‚ˆã†ã«è¡¨ç¾ã™ã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’ç¤ºãã†ã€‚
</p>

<p class="orig" lang="en">
A <em>queue</em> is a sequence in which items are inserted at one end
(called the <a name="%_idx_3222"></a><em>rear</em> of the queue) and deleted from the other end
(the <a name="%_idx_3224"></a><em>front</em>).  Figure <a href="#%_fig_3.18">3.18</a> shows an initially empty
queue in which the items <tt>a</tt> and <tt>b</tt> are inserted.  Then <tt>a</tt> is removed, <tt>c</tt> and <tt>d</tt> are inserted, and <tt>b</tt> is
removed.  Because items are always removed in the order in which they
are inserted, a queue is sometimes called a <a name="%_idx_3226"></a><em>FIFO</em> (first in,
first out) buffer.</p>

<p class="trans" lang="ja">
<em><ruby><rb>å¾…ã¡è¡Œåˆ—</rb><rp> (</rp><rt>ã‚­ãƒ¥ãƒ¼</rt><rp>) </rp></ruby></em>ã¨ã¯ã€<ruby><rb>é …ç›®</rb><rp> (</rp><rt>ã‚¢ã‚¤ãƒ†ãƒ </rt><rp>) </rp></ruby>ãŒä¸€æ–¹ã®ç«¯ (ã‚­ãƒ¥ãƒ¼ã®<em>æœ«å°¾</em>ã¨å‘¼ã°ã‚Œã‚‹) ã«æŒ¿å…¥ã•ã‚Œã¦ä»–æ–¹ã®ç«¯ (<em>å…ˆé ­</em>)ã‹ã‚‰å‰Šé™¤ã•ã‚Œã‚‹ã‚ˆã†ãªã€åˆ—ã§ã‚ã‚‹ã€‚
å›³<a href="#%_fig_3.18">3.18</a>ã¯ã€æœ€åˆã¯ç©ºã§ã€<tt>a</tt> ã¨ <tt>b</tt> ã¨ã„ã†é …ç›®ãŒæŒ¿å…¥ã•ã‚Œã‚‹ã‚ˆã†ãªã€ã‚­ãƒ¥ãƒ¼ã‚’ç¤ºã—ã¦ã„ã‚‹ã€‚
ãã®å¾Œã€<tt>a</tt> ã¯å–ã‚Šå»ã‚‰ã‚Œã€<tt>c</tt> ã¨ <tt>d</tt> ãŒæŒ¿å…¥ã•ã‚Œã€<tt>b</tt> ãŒå–ã‚Šå»ã‚‰ã‚Œã‚‹ã€‚
é …ç›®ã¯å¸¸ã«ã€ãã‚Œã‚‰ã®é …ç›®ãŒæŒ¿å…¥ã•ã‚ŒãŸé †ã§å–ã‚Šå»ã‚‰ã‚Œã‚‹ã®ã§ã€æ™‚ã¨ã—ã¦ã‚­ãƒ¥ãƒ¼ã¯ã€<em>FIFO</em> (first in, first out: å…ˆå…¥ã‚Œå…ˆå‡ºã—) ãƒãƒƒãƒ•ã‚¡ã¨å‘¼ã°ã‚Œã‚‹ã€‚
</p>

<a name="%_fig_3.18"></a>
<figure>
<table class="common"><tr><td valign=top >Operation </td><td valign=top >Resulting Queue  </td></tr>
<tr><td valign=top ><tt>(define q (make-queue))</tt> </td><td valign=top ></td></tr>
<tr><td valign=top ><tt>(insert-queue! q 'a)</tt> </td><td valign=top ><tt>a</tt></td></tr>
<tr><td valign=top ><tt>(insert-queue! q 'b)</tt> </td><td valign=top ><tt>a b</tt></td></tr>
<tr><td valign=top ><tt>(delete-queue! q)</tt> </td><td valign=top ><tt>b</tt></td></tr>
<tr><td valign=top ><tt>(insert-queue! q 'c)</tt> </td><td valign=top ><tt>b c</tt></td></tr>
<tr><td valign=top ><tt>(insert-queue! q 'd)</tt> </td><td valign=top ><tt>b c d</tt></td></tr>
<tr><td valign=top ><tt>(delete-queue! q)</tt> </td><td valign=top ><tt>c d</tt>
</td></tr></table>
<figcaption class="orig" lang="en"><b>Figure 3.18:</b>  Queue operations.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³3.18:</b> ã‚­ãƒ¥ãƒ¼ã®æ¼”ç®—</figcaption>
</figure>


<p class="orig" lang="en">
<a name="%_idx_3228"></a><a name="%_idx_3230"></a>In terms of data abstraction, we can regard a queue as defined by the
following set of operations:</p>

<p class="trans" lang="ja">
ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ã®è¦³ç‚¹ã‹ã‚‰ã¯ã€ã‚­ãƒ¥ãƒ¼ã‚’ã€ä»¥ä¸‹ã®æ¼”ç®—ã®é›†ã¾ã‚Šã«ã‚ˆã£ã¦å®šç¾©ã•ã‚ŒãŸã‚‚ã®ã¨è¦‹ãªã›ã‚‹ã€‚
</p>

<ul class="orig" lang="en">
<li>a constructor:
<a name="%_idx_3232"></a><tt>(make-queue)</tt>
returns an empty queue (a queue containing no items).</li>

<li>two selectors:
<a name="%_idx_3234"></a><tt>(empty-queue? &lt;<em>queue</em>&gt;)</tt>
tests if the queue is empty.

<a name="%_idx_3236"></a><tt>(front-queue &lt;<em>queue</em>&gt;)</tt>
returns the object at the front of
the queue, signaling an error if the queue is empty; it does not
modify the queue.</li>

<li>two mutators:
<a name="%_idx_3238"></a><tt>(insert-queue! &lt;<em>queue</em>&gt; &lt;<em>item</em>&gt;)</tt>
inserts the item at the rear of the queue and returns the modified
queue as its value.

<a name="%_idx_3240"></a><tt>(delete-queue! &lt;<em>queue</em>&gt;)</tt>
removes the item at the
front of the queue and returns the modified queue as its value,
signaling an error if the queue is empty before the deletion.</li>
</ul>

<ul class="trans" lang="ja">
<li>ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿: 
<tt>(make-queue)</tt> ã¯ã€ç©ºã®ã‚­ãƒ¥ãƒ¼ (ä½•ã‚‚é …ç›®ã‚’å«ã¾ãªã„ã‚­ãƒ¥ãƒ¼
) ã‚’è¿”ã™ã€‚</li>
<li>äºŒã¤ã®ã‚»ãƒ¬ã‚¯ã‚¿: 
<tt>(empty-queue? &lt;<em class="en">queue</em>&gt;)</tt> ã¯ã€ã‚­ãƒ¥ãƒ¼ãŒç©ºã‹ã©ã†ã‹ã‚’æ¤œæŸ»ã™ã‚‹ã€‚
<tt>(front-queue &lt;<em class="en">queue</em>&gt;)</tt> ã¯ã€ã‚­ãƒ¥ãƒ¼ã®å…ˆé ­ã«ã‚ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã€ã‚‚ã—ã‚­ãƒ¥ãƒ¼ãŒç©ºãªã‚‰ã‚¨ãƒ©ãƒ¼ã‚’çŸ¥ã‚‰ã›ã‚‹ã€‚ã“ã‚Œã¯ã€ã‚­ãƒ¥ãƒ¼ã‚’ä¿®æ­£ã—ãªã„ã€‚</li>
<li>äºŒã¤ã®ãƒŸãƒ¥ãƒ¼ãƒ†ãƒ¼ã‚¿:
<tt>(insert-queue! &lt;<em class="en">queue</em>&gt; &lt;<em class="en">item</em>&gt;)</tt> ã¯ã€ã‚­ãƒ¥ãƒ¼ã®æœ«å°¾ã«é …ç›®ã‚’æŒ¿å…¥ã—ã€ä¿®æ­£å¾Œã®ã‚­ãƒ¥ãƒ¼ã‚’ã€å€¤ã¨ã—ã¦è¿”ã™ã€‚
<tt>(delete-queue! &lt;<em class="en">queue</em>&gt;)</tt> ã¯ã€ã‚­ãƒ¥ãƒ¼ã®å…ˆé ­ã®é …ç›®ã‚’å–ã‚Šå»ã‚Šã€ä¿®æ­£å¾Œã®ã‚­ãƒ¥ãƒ¼ã‚’ã€å€¤ã¨ã—ã¦è¿”ã™ã€‚ãŸã ã—ã€ã‚‚ã—å‰Šé™¤å‰ã®ã‚­ãƒ¥ãƒ¼ãŒç©ºãªã‚‰ã°ã€ã‚¨ãƒ©ãƒ¼ã‚’çŸ¥ã‚‰ã›ã‚‹ã€‚</li>
</ul>

<p class="orig" lang="en">
Because a queue is a sequence of items, we could certainly represent
it as an ordinary list; the front of the queue would be the <tt>car</tt>
of the list, inserting an item in the queue would amount to appending
a new element at the end of the list, and deleting an item from the
queue would just be taking the <tt>cdr</tt> of the list.  However, this
representation is inefficient, because in order to insert an item we
must scan the list until we reach the end.  Since the only method we
have for scanning a list is by successive <tt>cdr</tt> operations, this
scanning requires <img src="book-Z-G-D-3.gif" border="0">(<em>n</em>) steps for a list of <em>n</em> items.  A simple
modification to the list representation overcomes this disadvantage by
allowing the queue operations to be implemented so that they require
<img src="book-Z-G-D-3.gif" border="0">(1) steps; that is, so that the number of steps
needed is independent of the length of the queue.
</p>

<p class="trans" lang="ja">
ã‚­ãƒ¥ãƒ¼ã¯é …ç›®ã®åˆ—ãªã®ã§ã€ç¢ºã‹ã«ç§ãŸã¡ã¯ã€ã‚­ãƒ¥ãƒ¼ã‚’æ™®é€šã®ãƒªã‚¹ãƒˆã¨ã—ã¦è¡¨ç¾ã™ã‚‹ã“ã¨ã ã£ã¦ã§ãã‚‹ã ã‚ã†ã€‚ã¤ã¾ã‚Šã€ã‚­ãƒ¥ãƒ¼ã®å…ˆé ­ã¯ãƒªã‚¹ãƒˆã® <tt>car</tt> ã ã‚ã†ã—ã€ã‚­ãƒ¥ãƒ¼ã«é …ç›®ã‚’æŒ¿å…¥ã™ã‚‹ã“ã¨ã¯ã€ãƒªã‚¹ãƒˆã®æœ€å¾Œã«æ–°ãŸãªè¦ç´ ã‚’ä»˜ã‘åŠ ãˆã‚‹ã“ã¨ã«ä»–ãªã‚‰ãªã„ã ã‚ã†ã—ã€ã‚­ãƒ¥ãƒ¼ã‹ã‚‰è¦ç´ ã‚’å‰Šé™¤ã™ã‚‹ã“ã¨ã¯ã€ã¾ã•ã«ãƒªã‚¹ãƒˆã® <tt>cdr</tt> ã‚’ã¨ã‚‹ã“ã¨ã§ã‚ã‚ã†ã€‚
ã—ã‹ã—ã€ã“ã‚“ãªè¡¨ç¾ã¯éåŠ¹ç‡çš„ã ã€‚ãªãœãªã‚‰ã€é …ç›®ã‚’æŒ¿å…¥ã™ã‚‹ãŸã‚ã«ã¯ã€ãƒªã‚¹ãƒˆã‚’ã€ãã®æœ€å¾Œã«åˆ°é”ã™ã‚‹ã¾ã§èµ°æŸ»ã›ã­ã°ãªã‚‰ãªã„ã®ã ã‹ã‚‰ã€‚
ãƒªã‚¹ãƒˆã‚’èµ°æŸ»ã™ã‚‹ãŸã‚ã®æ‰‹æŒã¡ã®å”¯ä¸€ã®æ–¹æ³•ã¯ã€é€£ç¶šçš„ãª <tt>cdr</tt> æ“ä½œã«ã‚ˆã‚‹ã‚‚ã®ã§ã‚ã‚Šã€ã“ã†ã—ãŸèµ°æŸ»ã¯ã€<em class="en">n</em> å€‹ã®é …ç›®ã‹ã‚‰ãªã‚‹ãƒªã‚¹ãƒˆã«å¯¾ã—ã¦ã€
<span class="math">&Theta;(<em class="en">n</em>)</span>
ã‚¹ãƒ†ãƒƒãƒ—ã‚’è¦ã™ã‚‹ã€‚
ãƒªã‚¹ãƒˆè¡¨ç¾ã«å¯¾ã™ã‚‹å˜ç´”ãªä¿®æ­£ã§ã€ã“ã®æ¬ ç‚¹ã‚’å…‹æœã§ãã‚‹â€”â€”ã‚­ãƒ¥ãƒ¼æ“ä½œãŒã€
<span class="math">&Theta;(1)</span>
ã‚¹ãƒ†ãƒƒãƒ—ã‚’è¦ã™ã‚‹ã‚ˆã†ã«ã€ã¤ã¾ã‚Šã€å¿…è¦ãªã‚¹ãƒ†ãƒƒãƒ—æ•°ãŒã‚­ãƒ¥ãƒ¼ã®é•·ã•ã«ä¾å­˜ã—ãªã„ã‚ˆã†ã«ã€ã‚­ãƒ¥ãƒ¼æ“ä½œã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ã‚’å¯èƒ½ã¨ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€‚
</p>

<p class="orig" lang="en">
The difficulty with the list representation arises from the need to
scan to find the end of the list.  The reason we need to scan is that,
although the standard way of representing a list as a chain of pairs
readily provides us with a pointer to the beginning of the list, it
gives us no easily accessible pointer to the end.  The modification
that avoids the drawback is to represent the queue as a list, together
with an additional pointer that indicates the final pair in the list.
That way, when we go to insert an item, we can consult the rear
pointer and so avoid scanning the list.</p>

<p class="trans" lang="ja">
ãƒªã‚¹ãƒˆè¡¨ç¾ã«ã¨ã‚‚ãªã†å›°é›£ã¯ã€ãƒªã‚¹ãƒˆã®æœ€å¾Œã‚’è¦‹ã¤ã‘ã‚‹ãŸã‚ã®èµ°æŸ»ã®å¿…è¦æ€§ã«èµ·å› ã™ã‚‹ã€‚
èµ°æŸ»ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ç†ç”±ã¨ã¯ã€ã“ã†ã§ã‚ã‚‹ã€‚ã™ãªã‚ã¡ã€ãƒªã‚¹ãƒˆã‚’å¯¾ã®é€£ãªã‚Šã¨ã—ã¦è¡¨ç¾ã™ã‚‹ã¨ã„ã†æ¨™æº–çš„ãªæ–¹æ³•ã¯ã€ãƒªã‚¹ãƒˆã®é–‹å§‹ç‚¹ã«å¯¾ã™ã‚‹ãƒã‚¤ãƒ³ã‚¿ã‚’ã‚ã£ã•ã‚Šæä¾›ã—ã¦ãã‚Œã‚‹ã¨ã¯ã„ãˆã€æœ«å°¾ã¸ã®ç°¡å˜ã«ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ãªãƒã‚¤ãƒ³ã‚¿ã‚’ã€å…¨ç„¶ä¸ãˆã¦ãã‚Œãªã„ã‹ã‚‰ã§ã‚ã‚‹ã€‚
ä»¥ä¸Šã®æ¬ ç‚¹ã‚’å›é¿ã™ã‚‹ä¿®æ­£ãŒã€ãƒªã‚¹ãƒˆä¸­ã®æœ€å¾Œã®å¯¾ã‚’ç¤ºã™è¿½åŠ çš„ãªãƒã‚¤ãƒ³ã‚¿ã‚‚ä¸€ç·’ã«å‚™ãˆãŸå½¢ã§ã€ã‚­ãƒ¥ãƒ¼ã‚’ãƒªã‚¹ãƒˆã¨ã—ã¦è¡¨ç¾ã™ã‚‹ã“ã¨ãªã®ã§ã‚ã‚‹ã€‚
ãã†ã™ã‚‹ã¨ã€é …ç›®ã‚’æŒ¿å…¥ã—ã«è¡Œãã¨ãã«ã€æœ«å°¾ãƒã‚¤ãƒ³ã‚¿ã‚’èª¿ã¹ã‚‹ã“ã¨ãŒã§ãã¦ã€ã‚ˆã£ã¦ã€ãƒªã‚¹ãƒˆã‚’èµ°æŸ»ã™ã‚‹ã“ã¨ã‚’é¿ã‘ã‚‰ã‚Œã‚‹ã®ã ã€‚
</p>

<p class="orig" lang="en">
A queue is represented, then, as a pair of pointers, <tt>front-ptr</tt>
and <tt>rear-ptr</tt>, which indicate, respectively, the first and last
pairs in an ordinary list.  Since we would like the queue to be an
identifiable object, we can use <tt>cons</tt> to combine the two
pointers.  Thus, the queue itself will be the <tt>cons</tt> of the two
pointers.  Figure <a href="#%_fig_3.19">3.19</a> illustrates this
representation.</p>

<p class="trans" lang="ja">
ã™ã‚‹ã¨ã€ã‚­ãƒ¥ãƒ¼ã¯ã€ä¸€å¯¾ã®ãƒã‚¤ãƒ³ã‚¿â€”â€”ã¤ã¾ã‚Š <tt>front-ptr</tt> ã¨ <tt>rear-ptr</tt> â€”â€”ã¨ã—ã¦è¡¨ã•ã‚Œã¦ã€ã“ã‚Œã‚‰ã®ãƒã‚¤ãƒ³ã‚¿ã¯ã€ãã‚Œãã‚Œã€æ™®é€šã®ãƒªã‚¹ãƒˆã®ä¸­ã®æœ€åˆã¨æœ€å¾Œã®å¯¾ã‚’ç¤ºã™ã€‚
ã‚­ãƒ¥ãƒ¼ã¯è­˜åˆ¥å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã£ã¦ã»ã—ã„ã®ã§ã€ã“ã‚Œã‚‰äºŒã¤ã®ãƒã‚¤ãƒ³ã‚¿ã‚’çµã³ã¤ã‘ã‚‹ã®ã« <tt>cons</tt> ã‚’ä½¿ã†ã“ã¨ãŒã§ãã‚‹ã€‚
ã‚ˆã£ã¦ã€ã‚­ãƒ¥ãƒ¼è‡ªä½“ã¯ã€ã“ã‚Œã‚‰äºŒã¤ã®ãƒã‚¤ãƒ³ã‚¿ã® <tt>cons</tt> ã«ãªã‚‹ã ã‚ã†ã€‚
å›³<a href="#%_fig_3.19">3.19</a>ã¯ã€ã“ã®è¡¨ç¾ã‚’ç¤ºã—ã¦ã„ã‚‹ã€‚
</p>


<a name="%_fig_3.19"></a>
<figure>
<img src="ch3-Z-G-19.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.19:</b>  Implementation of a queue as a list with front and rear
pointers.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³3.19:</b> å…ˆé ­ã¨æœ«å°¾ã®ãƒã‚¤ãƒ³ã‚¿ã‚’å‚™ãˆãŸãƒªã‚¹ãƒˆã¨ã—ã¦ã®ã‚­ãƒ¥ãƒ¼ã®å®Ÿè£…</figcaption>
</figure>


<p class="orig" lang="en">
To define the queue operations we use the following procedures, which
enable us to select and to modify the front and rear pointers of a
queue:
</p>

<p class="trans" lang="ja">
ã‚­ãƒ¥ãƒ¼æ“ä½œã‚’å®šç¾©ã™ã‚‹ãŸã‚ã«ã€ä»¥ä¸‹ã®æ‰‹ç¶šãâ€”â€”ã“ã‚Œã‚‰ã«ã‚ˆã‚Šã€ã‚­ãƒ¥ãƒ¼ã®å…ˆé ­ãƒã‚¤ãƒ³ã‚¿ã¨æœ«å°¾ãƒã‚¤ãƒ³ã‚¿ã‚’é¸æŠã—ãŸã‚Šå¤‰æ›´ã—ãŸã‚Šã§ãã‚‹ã‚ˆã†ã«ãªã‚‹â€”â€”ã‚’ä½¿ã†ã€‚
</p>

<p class="lisp"><a name="%_idx_3242"></a>(define (front-ptr queue) (car queue))
<a name="%_idx_3244"></a>(define (rear-ptr queue) (cdr queue))
<a name="%_idx_3246"></a>(define (set-front-ptr! queue item) (set-car! queue item))
<a name="%_idx_3248"></a>(define (set-rear-ptr! queue item) (set-cdr! queue item))
</p>

<p class="orig" lang="en">
Now we can implement the actual queue operations.  We will consider a
queue to be empty if its front pointer is the empty list:
</p>

<p class="trans" lang="ja">
ã•ã¦ä»Šã‚„ã€å®Ÿéš›ã®ã‚­ãƒ¥ãƒ¼æ“ä½œã‚’å®Ÿè£…ã§ãã‚‹ã€‚
ã‚‚ã—å…ˆé ­ãƒã‚¤ãƒ³ã‚¿ãŒç©ºãƒªã‚¹ãƒˆãªã‚‰ã€ã‚­ãƒ¥ãƒ¼ãŒç©ºã§ã‚ã‚‹ã€ã¨è¦‹ãªã™ã“ã¨ã«ã—ã‚ˆã†ã€‚
</p>

<p class="lisp"><a name="%_idx_3250"></a>(define (empty-queue? queue) (null? (front-ptr queue)))
</p>

<p class="orig" lang="en">
The <tt>make-queue</tt> constructor returns, as an initially empty queue,
a pair whose <tt>car</tt> and <tt>cdr</tt> are both the empty list:
</p>

<p class="trans" lang="ja">
<tt>make-queue</tt> ã¨ã„ã†ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ã€æœ€åˆã®ç©ºã®ã‚­ãƒ¥ãƒ¼ã¨ã—ã¦ã€<tt>car</tt> ã¨ <tt>cdr</tt> ã®åŒæ–¹ãŒç©ºãƒªã‚¹ãƒˆã®å¯¾ã‚’ã€è¿”ã™ã€‚
</p>

<p class="lisp"><a name="%_idx_3252"></a>(define (make-queue) (cons '() '()))
</p>

<p class="orig" lang="en">
To select the item at the front of the queue, we return the <tt>car</tt>
of the pair indicated by the front pointer:
</p>

<p class="trans" lang="ja">
ã‚­ãƒ¥ãƒ¼ã®å…ˆé ­ã®é …ç›®ã‚’é¸æŠã™ã‚‹ãŸã‚ã«ã€å…ˆé ­ãƒã‚¤ãƒ³ã‚¿ã«ã‚ˆã‚Šç¤ºã•ã‚Œã‚‹å¯¾ã® <tt>car</tt> ã‚’è¿”ã™ã€‚
</p>

<p class="lisp"><a name="%_idx_3254"></a>(define (front-queue queue)
  (if (empty-queue? queue)
      (error &quot;FRONT called with an empty queue&quot; queue)
      (car (front-ptr queue))))
</p>

<p class="orig" lang="en">
To insert an item in a queue, we follow the method whose result is
indicated in figure <a href="#%_fig_3.20">3.20</a>.  We first create a new
pair whose <tt>car</tt> is the item to be inserted and whose <tt>cdr</tt> is
the empty list.  If the queue was initially empty, we set the front and
rear pointers of the queue to this new pair.  Otherwise, we modify the
final pair in the queue to point to the new pair, and also set the
rear pointer to the new pair.</p>

<p class="trans" lang="ja">
ã‚­ãƒ¥ãƒ¼ã«é …ç›®ã‚’æŒ¿å…¥ã™ã‚‹ãŸã‚ã«ã¯ã€å›³<a href="#%_fig_3.20">3.20</a>ã«çµæœãŒç¤ºã•ã‚Œã¦ã„ã‚‹æ–¹æ³•ã«ã—ãŸãŒã†ã€‚
ã¾ãšã€<tt>car</tt> ãŒã€ãã®æŒ¿å…¥ã™ã¹ãé …ç›®ã§ã‚ã‚Šã€ã‹ã¤ã€<tt>cdr</tt> ãŒç©ºãƒªã‚¹ãƒˆã§ã‚ã‚‹ã‚ˆã†ãªã€æ–°ãŸãªå¯¾ã‚’ã€ä½œæˆã™ã‚‹ã€‚
ã‚‚ã—ã‚­ãƒ¥ãƒ¼ãŒå…ƒã‹ã‚‰ç©ºã ã£ãŸã‚‰ã€ã‚­ãƒ¥ãƒ¼ã®å…ˆé ­ãƒã‚¤ãƒ³ã‚¿ã¨æœ«å°¾ãƒã‚¤ãƒ³ã‚¿ã‚’ã€ã“ã®æ–°ãŸãªå¯¾ã«è¨­å®šã™ã‚‹ã€‚
ãã†ã§ãªã„å ´åˆã¯ã€ã‚­ãƒ¥ãƒ¼ã®æœ€å¾Œã®å¯¾ã‚’ã€ã“ã®æ–°ãŸãªå¯¾ã‚’æŒ‡ã™ã‚ˆã†ã«ä¿®æ­£ã—ã€ã¾ãŸã€æœ«å°¾ãƒã‚¤ãƒ³ã‚¿ã‚’ã€ã“ã®æ–°ãŸãªå¯¾ã«è¨­å®šã™ã‚‹ã€‚
</p>

<a name="%_fig_3.20"></a>
<figure>
<img src="ch3-Z-G-20.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.20:</b>  Result of using <tt>(insert-queue! q 'd)</tt> on the queue of figure <a href="#%_fig_3.19">3.19</a>.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³3.20:</b> </figcaption>
</figure>

<p class="lisp"><a name="%_idx_3256"></a>(define (insert-queue! queue item)
  (let ((new-pair (cons item '())))
    (cond ((empty-queue? queue)
           (set-front-ptr! queue new-pair)
           (set-rear-ptr! queue new-pair)
           queue)
          (else
           (set-cdr! (rear-ptr queue) new-pair)
           (set-rear-ptr! queue new-pair)
           queue)))) 
</p>

<p class="orig" lang="en">
To delete the item at the front of the queue, we merely modify the
front pointer so that it now points at the second item in the queue,
which can be found by following the <tt>cdr</tt> pointer of the first
item (see figure <a href="#%_fig_3.21">3.21</a>):<a name="call_footnote_Temp_366" href="#footnote_Temp_366"><sup><small>22</small></sup></a>
</p>

<p class="trans" lang="ja">
ã‚­ãƒ¥ãƒ¼ã®å…ˆé ­ã®é …ç›®ã‚’å‰Šé™¤ã™ã‚‹ã«ã¯ã€ã‚­ãƒ¥ãƒ¼ã®2ç•ªç›®ã®é …ç›®â€”â€”1ç•ªç›®ã®é …ç›®ã® <tt>cdr</tt> ã‚’è¿½ã„ã‹ã‘ã‚‹ã“ã¨ã§è¦‹ã¤ã‹ã‚‹â€”â€”ã‚’ä»Šã‹ã‚‰ã¯æŒ‡ã™ã‚ˆã†ã«ã€å…ˆé ­ãƒã‚¤ãƒ³ã‚¿ã‚’ä¿®æ­£ã™ã‚‹ã ã‘ã§ã‚ã‚‹ (å›³<a href="#%_fig_3.21">3.21</a>ã‚’å‚ç…§)<a href="#footnote_Temp_366"><sup><small>22</small></sup></a>ã€‚
</p>


<a name="%_fig_3.21"></a>
<figure>
<img src="ch3-Z-G-21.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.21:</b>  Result of using <tt>(delete-queue! q)</tt> on the queue of figure <a href="#%_fig_3.20">3.20</a>.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³3.21:</b> å›³<a href="#%_fig_3.20">3.20</a>ã®ã‚­ãƒ¥ãƒ¼ã«å¯¾ã—ã¦ <tt>(delete-queue! q)</tt> ã‚’ä½¿ã£ãŸçµæœ</figcaption>
</figure>

<p class="lisp"><a name="%_idx_3258"></a>(define (delete-queue! queue)
  (cond ((empty-queue? queue)
         (error &quot;DELETE! called with an empty queue&quot; queue))
        (else
         (set-front-ptr! queue (cdr (front-ptr queue)))
         queue))) 
</p>

<p class="orig" lang="en">
<a name="%_thm_3.21"></a>
<b>Exercise 3.21.</b>  Ben Bitdiddle decides to test the queue implementation described
above.  He types in the procedures to the Lisp interpreter and
proceeds to try them out:
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.21.</b> ãƒ™ãƒ³ãƒ»ãƒ“ãƒƒãƒˆãƒ‡ã‚£ãƒ‰ãƒ«ã¯ã€ä¸Šè¨˜ã®ã‚­ãƒ¥ãƒ¼ã®å®Ÿè£…ã‚’ãƒ†ã‚¹ãƒˆã™ã‚‹ã“ã¨ã‚’æ±ºæ„ã™ã‚‹ã€‚
å½¼ã¯ä¸Šè¨˜ã®æ‰‹ç¶šãã‚’Lispã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«æ‰“ã¡è¾¼ã‚“ã§ã€ã“ã‚Œã‚‰ã®æ‰‹ç¶šããŒã¡ã‚ƒã‚“ã¨å‹•ãã‹ã©ã†ã‹è©¦ãã†ã¨ã—å§‹ã‚ã‚‹ã€‚
</p>

<p class="lisp">(define q1 (make-queue))
(insert-queue! q1 'a)
<i>((a) a)</i>
(insert-queue! q1 'b)
<i>((a b) b)</i>
(delete-queue! q1)
<i>((b) b)</i>
(delete-queue! q1)
<i>(() b)</i>
</p>

<p class="orig" lang="en">
``It's all wrong!'' he complains.  ``The interpreter's response shows
that the last item is inserted into the queue twice.  And when I
delete both items, the second <tt>b</tt> is still there, so the queue
isn't empty, even though it's supposed to be.''  Eva Lu Ator suggests
that Ben has misunderstood what is happening.  ``It's not that the
items are going into the queue twice,'' she explains.  ``It's just
that the standard Lisp printer doesn't know how to make sense of the
queue representation.  If you want to see the queue printed correctly,
you'll have to define your own print procedure for queues.'' Explain
what Eva Lu is talking about.  In particular, show why Ben's examples
produce the printed results that they do.  Define a procedure <a name="%_idx_3260"></a><tt>print-queue</tt> that takes a queue as input and prints the sequence of
items in the queue.
</p>

<p class="trans" lang="ja">
ã€Œã¾ã£ãŸãé–“é•ã£ã¦ã„ã‚‹ã˜ã‚ƒãªã„ã‹!ã€ã¨ã€å½¼ã¯æ–‡å¥ã‚’ãŸã‚Œã‚‹ã€‚
ã€Œã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã®å¿œç­”ã¯ã€æœ€å¾Œã®é …ç›®ãŒã‚­ãƒ¥ãƒ¼ã«äºŒåº¦æŒ¿å…¥ã•ã‚Œã¦ã„ã‚‹ã€ã£ã¦ã„ã†ã“ã¨ã‚’ç¤ºã—ã¦ã„ã‚‹ã‚ˆã­ã€‚
ãã‚Œã«ã€åƒ•ãŒä¸¡æ–¹ã®é …ç›®ã‚’æ¶ˆã—ãŸã¨ãã€2ç•ªç›®ã®æ–¹ã® <tt>b</tt> ãŒã¾ã ã‚ã£ã¦ã€ãã®ã›ã„ã§ã‚­ãƒ¥ãƒ¼ã¯ç©ºã˜ã‚ƒãªã„ã‚“ã ã€‚æƒ³å®šã•ã‚Œã‚‹ã“ã¨ã§ã¯ã‚ã‚‹ã‘ã‚Œã©ã€
ã‚¨ãƒ´ã‚¡ãƒ»ãƒªãƒ¥ãƒ»ã‚¨ã‚¤ã‚¿ã¯ã€ä½•ãŒèµ·ãã¦ã„ã‚‹ã‹ã«ã¤ã„ã¦ã€ãƒ™ãƒ³ãŒèª¤è§£ã—ã¦ã„ã‚‹ã€ã¨ç¤ºå”†ã™ã‚‹ã€‚
ã€Œé …ç›®ãŒäºŒåº¦ã€ã‚­ãƒ¥ãƒ¼ã«å…¥ã£ã¦ã„ã£ã¦ã„ã‚‹è¨³ã˜ã‚ƒãªã„ã‚“ã ã‚ˆã€ã¨ã€å½¼å¥³ã¯èª¬æ˜ã™ã‚‹ã€‚
ã€Œæ¨™æº–çš„ãªLispã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒã€ã‚­ãƒ¥ãƒ¼è¡¨ç¾ã‚’ç†è§£ã™ã‚‹æ–¹æ³•ã‚’çŸ¥ã‚‰ãªã„ã€ã£ã¦ã ã‘ã€‚
ã‚‚ã—æ­£ã—ãå°å­—ã•ã‚ŒãŸã‚­ãƒ¥ãƒ¼ã‚’è¦‹ãŸã„ãªã‚‰ã€ã‚­ãƒ¥ãƒ¼ã®ãŸã‚ã®è‡ªåˆ†ã®å°å­—æ‰‹ç¶šãã‚’å®šç¾©ã—ãªãã¡ã‚ƒã€‚ã€
ã‚¨ãƒ´ã‚¡ãƒ»ãƒªãƒ¥ãŒä½•ã«ã¤ã„ã¦èªã£ã¦ã„ã‚‹ã®ã‹ã€èª¬æ˜ã›ã‚ˆã€‚
ç‰¹ã«ã€ãªãœãƒ™ãƒ³ã®äº‹ä¾‹ãŒã€ã“ã‚Œã‚‰ã®äº‹ä¾‹ãŒä½œã‚Šå‡ºã™ã‚ˆã†ãªå°å­—çµæœã‚’ä½œã‚Šå‡ºã™ã®ã‹ã‚’ã€ç¤ºã›ã€‚
ã‚­ãƒ¥ãƒ¼ã‚’å…¥åŠ›ã¨ã—ã¦å–ã‚Šã€ã‚­ãƒ¥ãƒ¼ã®ä¸­ã®ä¸€é€£ã®é …ç›®ã‚’å°å­—ã™ã‚‹ã‚ˆã†ãªã€<tt>print-queue</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’ã€å®šç¾©ã›ã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_3.22"></a>
<b>Exercise 3.22.</b>  <a name="%_idx_3262"></a>Instead of representing a queue as a pair of pointers, we can build a
queue as a procedure with local state.  The local state will consist
of pointers to the beginning and the end of an ordinary list.  Thus,
the <tt>make-queue</tt> procedure will have the form
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.22.</b> ä¸€å¯¾ã®ãƒã‚¤ãƒ³ã‚¿ã¨ã—ã¦ã‚­ãƒ¥ãƒ¼ã‚’è¡¨ç¾ã™ã‚‹ä»£ã‚ã‚Šã«ã€å±€æ‰€çŠ¶æ…‹ã‚’æŒã¤æ‰‹ç¶šãã¨ã—ã¦ã‚­ãƒ¥ãƒ¼ã‚’æ§‹ç¯‰ã§ãã‚‹ã€‚
ãã®å±€æ‰€çŠ¶æ…‹ã¯ã€é€šå¸¸ã®ãƒªã‚¹ãƒˆã®é–‹å§‹ç‚¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã¨æœ«å°¾ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã‹ã‚‰ãªã‚‹ã“ã¨ã ã‚ã†ã€‚
ã‚ˆã£ã¦ã€ <tt>make-queue</tt> ã®æ‰‹ç¶šãã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ãªå½¢ã«ãªã‚‹ã ã‚ã†ã€‚
</p>

<p class="lisp">(define (make-queue)
  (let ((front-ptr <tt>...</tt>)
        (rear-ptr <tt>...</tt>))
    &lt;<em>definitions of internal procedures</em>&gt;
    (define (dispatch m) <tt>...</tt>)
    dispatch))
</p>

<p class="orig" lang="en">
Complete the definition of <tt>make-queue</tt> and provide
implementations of the queue operations using this representation.
</p>

<p class="trans" lang="ja">
<tt>make-queue</tt> ã®å®šç¾©ã‚’å®Œæˆã•ã›ã€ãã—ã¦ã€ã“ã®è¡¨ç¾ã‚’ä½¿ã£ã¦ã‚­ãƒ¥ãƒ¼æ“ä½œã®å®Ÿè£…ã‚’æä¾›ã›ã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_3.23"></a>
<b>Exercise 3.23.</b>  <a name="%_idx_3264"></a><a name="%_idx_3266"></a>A <em>deque</em> (``double-ended queue'') is a sequence in which items
can be inserted and deleted at either the front or the rear.
Operations on deques are the constructor <tt>make-deque</tt>, the predicate <tt>empty-deque?</tt>, selectors <tt>front-deque</tt> and <tt>rear-deque</tt>, and mutators <tt>front-insert-deque!</tt>, <tt>rear-insert-deque!</tt>, <tt>front-delete-deque!</tt>, and <tt>rear-delete-deque!</tt>.  Show how to represent deques using pairs, and
give implementations of the operations.<a name="call_footnote_Temp_370" href="#footnote_Temp_370"><sup><small>23</small></sup></a>
All operations should be accomplished in <img src="book-Z-G-D-3.gif" border="0">(1) steps.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.23.</b> <em><ruby><rb>ãƒ‡ãƒƒã‚¯</rb><rp> (</rp><rt>deque</rt><rp>) </rp></ruby></em> (ã€Œä¸¡ç«¯ã‚­ãƒ¥ãƒ¼ã€)
<span class="note"> (dequeue ã§ã¯ãªã„ã€‚å¿µã®ãŸã‚)</span>
ã¨ã¯ã€å…ˆé ­ã¨æœ«å°¾ã®ã„ãšã‚Œã«ãŠã„ã¦ã‚‚ã€é …ç›®ã‚’æŒ¿å…¥ã—ãŸã‚Šå‰Šé™¤ã—ãŸã‚Šã§ãã‚‹ã‚ˆã†ãªã€åˆ—ã®ã“ã¨ã§ã‚ã‚‹ã€‚
ãƒ‡ãƒƒã‚¯ã«å¯¾ã™ã‚‹æ¼”ç®—ã¯ã€<tt>make-deque</tt> ã¨ã„ã†ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¨ã€<tt>empty-deque?</tt> ã¨ã„ã†è¿°èªã¨ã€<tt>front-deque</tt> ã¨ <tt>rear-deque</tt> ã¨ã„ã†ã‚»ãƒ¬ã‚¯ã‚¿ã¨ã€<tt>front-insert-deque!</tt> ã¨ <tt>rear-insert-deque!</tt> ã¨ <tt>front-delete-deque!</tt> ã¨ <tt>rear-delete-deque!</tt> ã¨ã„ã†ãƒŸãƒ¥ãƒ¼ãƒ†ãƒ¼ã‚¿ã§ã‚ã‚‹ã€‚
å¯¾ã‚’ä½¿ã£ã¦ã©ã®ã‚ˆã†ã«ãƒ‡ãƒƒã‚¯ã‚’è¡¨ç¾ã™ã‚‹ã®ã‹ã‚’ç¤ºã—ã€ã“ã‚Œã‚‰ã®æ¼”ç®—ã®å®Ÿè£…ã‚’ä¸ãˆã‚ˆ<a href="#footnote_Temp_370"><sup><small>23</small></sup></a>ã€‚
ã™ã¹ã¦ã®æ¼”ç®—ã¯ã€&Theta;(1) ã®å€‹æ•°ã®ã‚¹ãƒ†ãƒƒãƒ—ã§é”æˆã•ã‚Œã‚‹ã¹ãã§ã‚ã‚‹ã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_3.3.3"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_3.3.3">3.3.3  Representing Tables</a></h3>
<h3 class="trans" lang="ja">3.3.3 ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’è¡¨ç¾ã™ã‚‹</h3>

<p class="orig" lang="en">
<a name="%_idx_3268"></a>
<a name="%_idx_3270"></a>When we studied various ways of representing sets in chapter 2, we
mentioned in section <a href="16_sec2_3.html#%_sec_2.3.3">2.3.3</a> the task of
maintaining a table of records indexed by identifying keys.  In the
implementation of data-directed programming in
section <a href="17_sec2_4.html#%_sec_2.4.3">2.4.3</a>, we made extensive use of
two-dimensional tables, in which information is stored and retrieved
using two keys.  Here we see how to build tables as mutable list
structures.</p>

<p class="trans" lang="ja">
2ç« ã§é›†åˆã‚’è¡¨ç¾ã™ã‚‹æ§˜ã€…ãªæ–¹æ³•ã«ã¤ã„ã¦æ¤œè¨ã—ãŸã¨ãã«ã€<a href="16_sec2_3.html#%_sec_2.3.3">2.3.3</a>ç¯€ã«ãŠã„ã¦ç§ãŸã¡ã¯ã€è­˜åˆ¥ã‚­ãƒ¼ã«ã‚ˆã‚Šç´¢å¼•ä»˜ã‘ã•ã‚ŒãŸãƒ¬ã‚³ãƒ¼ãƒ‰ç¾¤ã‹ã‚‰ãªã‚‹ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’ç¶­æŒã™ã‚‹ã¨ã„ã†èª²é¡Œã«ã¤ã„ã¦è¿°ã¹ãŸã€‚
<a href="17_sec2_4.html#%_sec_2.4.3">2.4.3</a>ç¯€ã§ã®ãƒ‡ãƒ¼ã‚¿æŒ‡å‘ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®å®Ÿè£…ã§ã¯ã€äºŒæ¬¡å…ƒãƒ†ãƒ¼ãƒ–ãƒ«â€”â€”äºŒã¤ã®ã‚­ãƒ¼ã‚’ä½¿ã£ã¦ã€æƒ…å ±ãŒæ ¼ç´ã•ã‚ŒãŸã‚Šå–ã‚Šå‡ºã•ã‚ŒãŸã‚Šã™ã‚‹â€”â€”ã‚’åºƒç¯„å›²ã«ã‚ãŸã£ã¦ä½¿ã£ãŸã€‚
ã“ã“ã§ã¯ã€ã©ã®ã‚ˆã†ã«ã—ã¦ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’å¤‰æ›´å¯èƒ½ãªãƒªã‚¹ãƒˆæ§‹é€ ã¨ã—ã¦æ§‹ç¯‰ã™ã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’è¦‹ã‚ˆã†ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_3272"></a>We first consider a one-dimensional table, in which each value is
stored under a single key.  We implement the table as a list of
records, each of which is implemented as a pair consisting of a key
and the associated value. The records are glued together to form a
list by pairs whose <tt>car</tt>s point to successive records.  These
gluing pairs are called the <a name="%_idx_3274"></a><em>backbone</em> of the table.  In order to
have a place that we can change when we add a new record to the table,
we build the table as a <a name="%_idx_3276"></a><a name="%_idx_3278"></a><em>headed list</em>.  A headed list has a
special backbone pair at the beginning, which holds a dummy
``record'' -- in this case the arbitrarily chosen symbol <tt>*table*</tt>.
Figure <a href="#%_fig_3.22">3.22</a> shows the box-and-pointer diagram for the table</p>

<p class="trans" lang="ja">
ã¾ãšã€ä¸€æ¬¡å…ƒãƒ†ãƒ¼ãƒ–ãƒ«â€”â€”ãã‚Œãã‚Œã®å€¤ãŒå˜ä¸€ã®ã‚­ãƒ¼ã®å…ƒã«æ ¼ç´ã•ã‚Œã‚‹â€”â€”ã‚’è€ƒãˆã‚‹ã€‚
ãƒ¬ã‚³ãƒ¼ãƒ‰ã®ãƒªã‚¹ãƒˆã¨ã—ã¦ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’å®Ÿè£…ã™ã‚‹ã€‚ãªãŠã€ãã‚Œã‚‰ãƒ¬ã‚³ãƒ¼ãƒ‰ã®å„ã€…ã¯ã€ã‚­ãƒ¼ã¨ã€é–¢é€£ã¥ã‘ã‚‰ã‚ŒãŸå€¤ã¨ã‹ã‚‰ãªã‚‹å¯¾ã¨ã—ã¦ã€å®Ÿè£…ã•ã‚Œã‚‹ã€‚
é€£ç¶šã™ã‚‹ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’ãã‚Œãã‚Œã®<tt>car</tt>ãŒæŒ‡ã—ç¤ºã—ã¦ã„ã‚‹ã‚ˆã†ãªå¹¾ã¤ã‹ã®å¯¾ã«ã‚ˆã‚‹ãƒªã‚¹ãƒˆã‚’å½¢æˆã™ã‚‹ã‚ˆã†ã«ã€ãƒ¬ã‚³ãƒ¼ãƒ‰ç¾¤ã¯ç³Šã¥ã‘ã•ã‚Œã¦ã¾ã¨ã‚ã‚‰ã‚Œã‚‹ã€‚
ã“ã‚Œã‚‰ã®ç³Šã¥ã‘ã‚’ã—ã¦ã„ã‚‹å¯¾ã¯ã€ãƒ†ãƒ¼ãƒ–ãƒ«ã®<em><ruby><rb>èƒŒéª¨</rb><rp> (</rp><rt>ãƒãƒƒã‚¯ãƒœãƒ¼ãƒ³</rt><rp>) </rp></ruby></em>ã¨å‘¼ã°ã‚Œã‚‹ã€‚
ãƒ†ãƒ¼ãƒ–ãƒ«ã«æ–°ãŸãªãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’è¿½åŠ ã™ã‚‹ã¨ãã«å¤‰æ›´ã§ãã‚‹å ´æ‰€ãŒã‚ã‚‹ã‚ˆã†ã«ã—ã¦ãŠããŸã‚ã«ã€<em>é ­ã¤ãã®ãƒªã‚¹ãƒˆ</em>ã¨ã—ã¦ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’æ§‹ç¯‰ã™ã‚‹ã€‚
é ­ã¤ãã®ãƒªã‚¹ãƒˆã«ã¯ã€å§‹ã‚ã«ç‰¹åˆ¥ãªèƒŒéª¨ã®å¯¾ãŒã‚ã‚Šã€ã“ã‚Œã¯ã€ãƒ€ãƒŸãƒ¼ã®ã€Œãƒ¬ã‚³ãƒ¼ãƒ‰ã€â€”â€”ã“ã®å ´åˆã¯ã€ä»»æ„ã«é¸ã°ã‚ŒãŸ <tt>*table*</tt> ã¨ã„ã†è¨˜å·â€”â€”ã‚’ä¿æŒã—ã¦ã„ã‚‹ã€‚
å›³<a href="#%_fig_3.22">3.22</a>ã¯ã€ä»¥ä¸‹ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã«ã¤ã„ã¦ã®ã€ç®±ã¨ãƒã‚¤ãƒ³ã‚¿ã®å›³ã‚’ç¤ºã—ã¦ã„ã‚‹ã€‚
</p>

<p class="lisp">a:  1
b:  2
c:  3
</p>

<a name="%_fig_3.22"></a>
<figure>
<img src="ch3-Z-G-22.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.22:</b>  A table represented as a headed list.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³3.22:</b> é ­ã¤ãã®ãƒªã‚¹ãƒˆã¨ã—ã¦è¡¨ç¾ã•ã‚ŒãŸãƒ†ãƒ¼ãƒ–ãƒ«</figcaption>
</figure>

<p class="orig" lang="en">
To extract information from a table we use the <tt>lookup</tt>
procedure, which takes a key as argument and returns the associated
value (or false if there is no value stored under that key).
<tt>Lookup</tt> is defined in terms of the <tt>assoc</tt> operation, which
expects a key and a list of records as arguments.  Note that <tt>assoc</tt> never sees the dummy record.  <tt>Assoc</tt> returns the record
that has the given key as its <tt>car</tt>.<a name="call_footnote_Temp_371" href="#footnote_Temp_371"><sup><small>24</small></sup></a>
<tt>Lookup</tt> then
checks to see that the resulting record returned by <tt>assoc</tt> is not
false, and returns the value (the <tt>cdr</tt>) of the record.</p>

<p class="trans" lang="ja">
ãƒ†ãƒ¼ãƒ–ãƒ«ã‹ã‚‰æƒ…å ±ã‚’æŠ½å‡ºã™ã‚‹ãŸã‚ã«ã¯ã€<tt>lookup</tt> ã¨ã„ã†æ‰‹ç¶šãâ€”â€”ã‚­ãƒ¼ã‚’å¼•æ•°ã¨ã—ã¦ã¨ã‚Šã€é–¢é€£ã¥ã‘ã‚‰ã‚ŒãŸå€¤ (ã¾ãŸã¯ã€ãã®ã‚­ãƒ¼ã®ã‚‚ã¨ã«æ ¼ç´ã•ã‚Œã¦ã„ã‚‹å€¤ãŒãªã„å ´åˆã¯ã€å½) ã‚’è¿”ã™â€”â€”ã‚’ä½¿ã†ã€‚
<tt>lookup</tt> ã¯ã€<tt>assoc</tt> æ¼”ç®—â€”â€”ã‚­ãƒ¼ã¨ã€ãƒ¬ã‚³ãƒ¼ãƒ‰ã®ãƒªã‚¹ãƒˆã¨ã‚’ã€å¼•æ•°ã¨ã—ã¦æœŸå¾…ã™ã‚‹â€”â€”ã‚’ä½¿ã£ã¦ã€å®šç¾©ã•ã‚Œã‚‹ã€‚
<tt>assoc</tt> ãŒæ±ºã—ã¦ãƒ€ãƒŸãƒ¼ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’è¦‹ãªã„ã“ã¨ã«æ³¨æ„ã›ã‚ˆã€‚
<tt>assoc</tt> ã¯ã€ä¸ãˆã‚‰ã‚ŒãŸã‚­ãƒ¼ã‚’ <tt>car</tt> ã¨ã—ã¦æœ‰ã™ã‚‹ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’ã€è¿”ã™<a href="#footnote_Temp_371"><sup><small>24</small></sup></a>ã€‚
ã™ã‚‹ã¨ã€<tt>lookup</tt> ã¯ã€<tt>assoc</tt> ã«ã‚ˆã£ã¦è¿”ã•ã‚ŒãŸã€çµæœã¨ã—ã¦å¾—ã‚‰ã‚ŒãŸãƒ¬ã‚³ãƒ¼ãƒ‰ãŒã€å½ã§ã¯ãªã„ã“ã¨ã‚’ç¢ºã‹ã‚ã¦ã€ãã®ãƒ¬ã‚³ãƒ¼ãƒ‰ã®å€¤ (ãã®ãƒ¬ã‚³ãƒ¼ãƒ‰ã® <tt>cdr</tt>) ã‚’è¿”ã™ã€‚
</p>

<p class="lisp"><a name="%_idx_3280"></a>(define (lookup key table)
  (let ((record (assoc key (cdr table))))
    (if record
        (cdr record)
        false)))
<a name="%_idx_3282"></a>(define (assoc key records)
  (cond ((null? records) false)
        ((equal? key (caar records)) (car records))
        (else (assoc key (cdr records)))))
</p>

<p class="orig" lang="en">
To insert a value in a table under a specified key, we first use <tt>assoc</tt> to see if there is already a record in the table with this key.
If not, we form a new record by <tt>cons</tt>ing the key with the value,
and insert this at the head of the table's list of records, after the
dummy record.  If there already is a record with this key, we set the
<tt>cdr</tt> of this record to the designated new value.  The header of
the table provides us with a fixed location to modify in order to
insert the new record.<a name="call_footnote_Temp_372" href="#footnote_Temp_372"><sup><small>25</small></sup></a></p>

<p class="trans" lang="ja">
æŒ‡å®šã•ã‚ŒãŸã‚­ãƒ¼ã®ã‚‚ã¨ã«å€¤ã‚’ãƒ†ãƒ¼ãƒ–ãƒ«ã«æŒ¿å…¥ã™ã‚‹ã«ã¯ã€ã¾ãš <tt>assoc</tt>ã‚’ä½¿ã£ã¦ã€ã“ã®ã‚­ãƒ¼ã‚’æŒã£ãŸãƒ¬ã‚³ãƒ¼ãƒ‰ãŒæ—¢ã«ãƒ†ãƒ¼ãƒ–ãƒ«ã®ä¸­ã«ã‚ã‚‹ã‹ã©ã†ã‹ã‚’è¦‹ã‚‹ã€‚
ã‚‚ã—ãªã‘ã‚Œã°ã€ã‚­ãƒ¼ã¨å€¤ã‚’ <tt>cons</tt> ã™ã‚‹ã“ã¨ã§æ–°ãŸãªãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’å½¢æˆã—ã€ã“ã‚Œã‚’ã€ã“ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã®ãƒ¬ã‚³ãƒ¼ãƒ‰ã®ãƒªã‚¹ãƒˆã®å…ˆé ­â€”â€”ãŸã ã—ãƒ€ãƒŸãƒ¼ãƒ¬ã‚³ãƒ¼ãƒ‰ã®å¾Œâ€”â€”ã«æŒ¿å…¥ã™ã‚‹ã€‚
ã‚‚ã—ã€ã“ã®ã‚­ãƒ¼ã‚’æŒã£ãŸãƒ¬ã‚³ãƒ¼ãƒ‰ãŒæ—¢ã«ã‚ã‚Œã°ã€ã“ã®ãƒ¬ã‚³ãƒ¼ãƒ‰ã® <tt>cdr</tt> ã‚’ã€æŒ‡å®šã•ã‚ŒãŸæ–°ãŸãªå€¤ã«è¨­å®šã™ã‚‹ã€‚
ãƒ†ãƒ¼ãƒ–ãƒ«ã®ãƒ˜ãƒƒãƒ€ã¯ã€æ–°ãŸãªãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’æŒ¿å…¥ã™ã‚‹ãŸã‚ã«ä¿®æ­£ã™ã¹ãå®šä½ç½®ã‚’ã€ä¸ãˆã¦ãã‚Œã‚‹ã®ã <a href="#footnote_Temp_372"><sup><small>25</small></sup></a>ã€‚
</p>

<p class="lisp"><a name="%_idx_3284"></a>(define (insert! key value table)
  (let ((record (assoc key (cdr table))))
    (if record
        (set-cdr! record value)
        (set-cdr! table
                  (cons (cons key value) (cdr table)))))
  'ok)
</p>

<p class="orig" lang="en">
To construct a new table, we simply create a list containing the
symbol <tt>*table*</tt>:</p>

<p class="trans" lang="ja">
æ–°ãŸãªãƒ†ãƒ¼ãƒ–ãƒ«ã‚’æ§‹ç¯‰ã™ã‚‹ãŸã‚ã«ã¯ã€å˜ç´”ã«ã€<tt>*table*</tt> ã¨ã„ã†è¨˜å·ã‚’å«ã‚€ãƒªã‚¹ãƒˆã‚’ä½œæˆã™ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_3286"></a>(define (make-table)
  (list '*table*))
</p>


<a name="%_sec_Temp_373"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_373">Two-dimensional tables</a></h4>
<h4 class="trans" lang="ja">2æ¬¡å…ƒã®ãƒ†ãƒ¼ãƒ–ãƒ«</h4>

<p class="orig" lang="en">
<a name="%_idx_3288"></a>
In a two-dimensional table, each value is indexed by two keys.  We can
construct such a table as a one-dimensional table in which each key
identifies a subtable.
Figure <a href="#%_fig_3.23">3.23</a> shows the box-and-pointer diagram for the table
</p>

<p class="trans" lang="ja">
äºŒæ¬¡å…ƒãƒ†ãƒ¼ãƒ–ãƒ«ã§ã¯ã€ãã‚Œãã‚Œã®å€¤ãŒäºŒã¤ã®ã‚­ãƒ¼ã«ã‚ˆã‚Šç´¢å¼•ã¥ã‘ã•ã‚Œã¦ã„ã‚‹ã€‚
ãã†ã„ã†ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’ã€ãã‚Œãã‚Œã®ã‚­ãƒ¼ãŒä¸‹ä½ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’è­˜åˆ¥ã—ã¦ã„ã‚‹ã‚ˆã†ãªä¸€æ¬¡å…ƒãƒ†ãƒ¼ãƒ–ãƒ«ã¨ã—ã¦ã€æ§‹ç¯‰ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
å›³<a href="#%_fig_3.23">3.23</a>ã¯ã€ä»¥ä¸‹ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã«å¯¾ã™ã‚‹ã€ç®±ã¨ãƒã‚¤ãƒ³ã‚¿ã®å›³ã‚’ç¤ºã—ã¦ã„ã‚‹ã€‚
</p>

<p class="lisp">math:
    +:  43
    -:  45
    *:  42
letters:
    a:  97
    b:  98
</p>

<p class="orig" lang="en">
which has two subtables.  (The subtables don't need a
special header symbol, since the key that identifies the subtable
serves this purpose.)
</p>

<p class="trans" lang="ja">
ãªãŠã“ã‚Œã¯äºŒã¤ã®ä¸‹ä½ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’å«ã‚€ã€‚
(ã“ã‚Œã‚‰ã®ä¸‹ä½ãƒ†ãƒ¼ãƒ–ãƒ«ã¯ã€ç‰¹åˆ¥ãªãƒ˜ãƒƒãƒ€è¨˜å·ã‚’å¿…è¦ã¨ã—ãªã„ã€‚ã¨ã„ã†ã®ã‚‚ã€ä¸‹ä½ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’è­˜åˆ¥ã™ã‚‹ã‚­ãƒ¼ãŒã€ã“ã®ç›®çš„ã‚’æœãŸã—ã¦ã„ã‚‹ã‹ã‚‰ã§ã‚ã‚‹ã€‚)
</p>

<a name="%_fig_3.23"></a>
<figure>
<img src="ch3-Z-G-23.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.23:</b>  A two-dimensional table.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³3.23:</b> äºŒæ¬¡å…ƒãƒ†ãƒ¼ãƒ–ãƒ«</figcaption>
</figure>

<p class="orig" lang="en">
When we look up an item, we use the first key
to identify the correct subtable.  Then we use the second key to
identify the record within the subtable.</p>

<p class="trans" lang="ja">
ã‚ã‚‹é …ç›®ã‚’å¼•ãå ´åˆã€æ­£ã—ã„ä¸‹ä½ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’è­˜åˆ¥ã™ã‚‹ãŸã‚ã«ã€ç¬¬ä¸€ã®ã‚­ãƒ¼ã‚’ä½¿ã†ã€‚
ãã‚Œã‹ã‚‰ã€ãã®ä¸‹ä½ãƒ†ãƒ¼ãƒ–ãƒ«ã®å†…éƒ¨ã§ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’è­˜åˆ¥ã™ã‚‹ãŸã‚ã«ã€ç¬¬äºŒã®ã‚­ãƒ¼ã‚’ä½¿ã†ã€‚
</p>

<p class="lisp"><a name="%_idx_3290"></a>(define (lookup key-1 key-2 table)
  (let ((subtable (assoc key-1 (cdr table))))
    (if subtable
        (let ((record (assoc key-2 (cdr subtable))))
          (if record
              (cdr record)
              false))
        false)))
</p>

<p class="orig" lang="en">
To insert a new item under a pair of keys, we use <tt>assoc</tt> to see if
there is a subtable stored under the first key.  If not, we build a
new subtable containing the single record (<tt>key-2</tt>, <tt>value</tt>)
and insert it into the table under the first key.  If a subtable
already exists for the first key, we insert the new record into this
subtable, using the insertion method for one-dimensional tables
described above:</p>

<p class="trans" lang="ja">
ä¸€çµ„ã®ã‚­ãƒ¼ã®ã‚‚ã¨ã«æ–°ãŸãªé …ç›®ã‚’æŒ¿å…¥ã™ã‚‹ã«ã¯ã€<tt>assoc</tt> ã‚’ä½¿ã£ã¦ã€ç¬¬ä¸€ã®ã‚­ãƒ¼ã®ã‚‚ã¨ã«æ ¼ç´ã•ã‚ŒãŸä¸‹ä½ãƒ†ãƒ¼ãƒ–ãƒ«ãŒã‚ã‚‹ã‹ã©ã†ã‹ã‚’èª¿ã¹ã‚‹ã€‚
ã‚‚ã—ãªã‘ã‚Œã°ã€(<tt>key-2</tt>, <tt>value</tt>) ã¨ã„ã†ãŸã ä¸€ã¤ã®ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’å«ã‚€æ–°ãŸãªä¸‹ä½ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’æ§‹ç¯‰ã—ã€ãã‚Œã‚’ç¬¬ä¸€ã®ã‚­ãƒ¼ã®ã‚‚ã¨ã«è¡¨ã«æŒ¿å…¥ã™ã‚‹ã€‚
ã‚‚ã—æ—¢ã«ç¬¬ä¸€ã®ã‚­ãƒ¼ã«å¯¾ã—ã¦ä¸‹ä½ãƒ†ãƒ¼ãƒ–ãƒ«ãŒå­˜åœ¨ã—ã¦ã„ã‚Œã°ã€ä¸Šè¨˜ã®ä¸€æ¬¡å…ƒãƒ†ãƒ¼ãƒ–ãƒ«ç”¨ã®æŒ¿å…¥æ‰‹æ³•ã‚’ä½¿ã£ã¦ã€ã“ã®ä¸‹ä½ãƒ†ãƒ¼ãƒ–ãƒ«ã«æ–°ãŸãªãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’æŒ¿å…¥ã™ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_3292"></a>(define (insert! key-1 key-2 value table)
  (let ((subtable (assoc key-1 (cdr table))))
    (if subtable
        (let ((record (assoc key-2 (cdr subtable))))
          (if record
              (set-cdr! record value)
              (set-cdr! subtable
                        (cons (cons key-2 value)
                              (cdr subtable)))))
        (set-cdr! table
                  (cons (list key-1
                              (cons key-2 value))
                        (cdr table)))))
  'ok)
</p>

<a name="%_sec_Temp_374"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_374">Creating local tables</a></h4>
<h4 class="trans" lang="ja">å±€æ‰€çš„ãªãƒ†ãƒ¼ãƒ–ãƒ«ã‚’ä½œæˆã™ã‚‹</h4>

<p class="orig" lang="en">
<a name="%_idx_3294"></a>
The <tt>lookup</tt> and <tt>insert!</tt> operations defined above take the
table as an argument.  This enables us to use programs that access
more than one table.  Another way to deal with multiple tables is to
have separate <tt>lookup</tt> and <tt>insert!</tt> procedures for each
table.  We can do this by representing a table procedurally, as an
object that maintains an internal table as part of its local state.
When sent an appropriate message, this ``table object'' supplies the
procedure with which to operate on the internal table.  Here is a
generator for two-dimensional tables represented in this fashion:</p>

<p class="trans" lang="ja">
ä¸Šè¨˜ã§å®šç¾©ã—ãŸ <tt>lookup</tt> ã¨ <tt>insert!</tt> ã®æ“ä½œã¯ã€ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’å¼•æ•°ã¨ã—ã¦ã¨ã‚‹ã€‚
ã“ã‚Œã«ã‚ˆã£ã¦ã€ä¸€ã¤ã‚ˆã‚Šã‚‚å¤šã„ãƒ†ãƒ¼ãƒ–ãƒ«ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ä½¿ã†ã“ã¨ãŒå¯èƒ½ã«ãªã‚‹ã€‚
è¤‡æ•°ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’æ‰±ã†ãŸã‚ã®åˆ¥ã®æ–¹æ³•ã¯ã€å„ãƒ†ãƒ¼ãƒ–ãƒ«ã«å¯¾ã—ã¦ <tt>lookup</tt> ã¨ <tt>insert!</tt> ã®æ‰‹ç¶šãã‚’æŒã£ã¦ãŠãã“ã¨ã ã€‚
å±€æ‰€çŠ¶æ…‹ã®ä¸€éƒ¨ã¨ã—ã¦å†…éƒ¨ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’ç¶­æŒã™ã‚‹ã‚ˆã†ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦ã€ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’æ‰‹ç¶šãçš„ã«è¡¨ç¾ã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€ã“ã‚Œã‚’è¡Œã†ã“ã¨ãŒå¯èƒ½ã§ã‚ã‚‹ã€‚
é©åˆ‡ãªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒé€ã‚‰ã‚ŒãŸã¨ãã€ã“ã®ã€Œãƒ†ãƒ¼ãƒ–ãƒ«ãƒ»ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ã¯ã€å†…éƒ¨ãƒ†ãƒ¼ãƒ–ãƒ«ã«å¯¾ã—ã¦æ“ä½œã‚’è¡Œã†ã¨ãã«ä½¿ã†æ‰‹ç¶šãã‚’ä¸ãˆã‚‹ã€‚
ã“ã†ã—ãŸæµå„€ã§è¡¨ç¾ã•ã‚ŒãŸäºŒæ¬¡å…ƒã®ãƒ†ãƒ¼ãƒ–ãƒ«ç”¨ã®ç”Ÿæˆå™¨ã‚’ã€ã“ã“ã«ç¤ºã™ã€‚
</p>

<p class="lisp"><a name="%_idx_3296"></a>(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup key-1 key-2)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (cdr record)
                  false))
            false)))
    (define (insert! key-1 key-2 value)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1
                                  (cons key-2 value))
                            (cdr local-table)))))
      'ok)    
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error &quot;Unknown operation -- TABLE&quot; m))))
    dispatch))
</p>

<p class="orig" lang="en">
Using <tt>make-table</tt>, we could implement the <tt>get</tt> and <tt>put</tt>
operations used in section <a href="17_sec2_4.html#%_sec_2.4.3">2.4.3</a> for data-directed
programming, as follows:</p>

<p class="trans" lang="ja">
<tt>make-table</tt> ã‚’ä½¿ãˆã°ã€ãƒ‡ãƒ¼ã‚¿æŒ‡å‘ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ç”¨ã«<a href="17_sec2_4.html#%_sec_2.4.3">2.4.3</a>ç¯€ã§ä½¿ã£ãŸ <tt>get</tt> ã¨ <tt>put</tt>
ã®æ“ä½œã‚’ä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¦å®Ÿè£…ã™ã‚‹ã“ã¨ãŒã§ãã‚ˆã†ã€‚</p>

<p class="lisp"><a name="%_idx_3298"></a>(define operation-table (make-table))
<a name="%_idx_3300"></a>(define get (operation-table 'lookup-proc))
<a name="%_idx_3302"></a>(define put (operation-table 'insert-proc!))
</p>

<p class="orig" lang="en">
<tt>Get</tt> takes as arguments two keys, and <tt>put</tt> takes
as arguments two keys and a value.  Both operations access the same
local table, which is encapsulated within the object created by the
call to <tt>make-table</tt>.</p>

<p class="trans" lang="ja">
<tt>get</tt> ã¯å¼•æ•°ã¨ã—ã¦äºŒã¤ã®ã‚­ãƒ¼ã‚’ã¨ã‚Šã€<tt>put</tt> ã¯å¼•æ•°ã¨ã—ã¦äºŒã¤ã®ã‚­ãƒ¼ã¨ä¸€ã¤ã®å€¤ã¨ã‚’ã¨ã‚‹ã€‚
åŒæ–¹ã®æ“ä½œã¯ã€åŒã˜å±€æ‰€ãƒ†ãƒ¼ãƒ–ãƒ«â€”â€”<tt>make-table</tt> ã«å¯¾ã™ã‚‹å‘¼ã³å‡ºã—ã«ã‚ˆã£ã¦ä½œæˆã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå†…ã«ã‚«ãƒ—ã‚»ãƒ«åŒ–ã•ã‚Œã¦ã„ã‚‹â€”â€”ã«ã€ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="%_thm_3.24"></a>
<b>Exercise 3.24.</b>  <a name="%_idx_3304"></a><a name="%_idx_3306"></a>In the table implementations above, the keys are tested for equality
using <tt>equal?</tt> (called by <tt>assoc</tt>).  This is not always the appropriate test.  For
instance, we might have a table with numeric keys in which we don't
need an exact match to the number we're looking up,
but only a number within some tolerance of it.
Design a table constructor <tt>make-table</tt> that takes as an argument a <tt>same-key?</tt> procedure
that will be used to test ``equality'' of keys.  <tt>Make-table</tt> should
return a <tt>dispatch</tt> procedure that can be used to access
appropriate <tt>lookup</tt> and <tt>insert!</tt> procedures for a local
table.

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.24.</b> ä¸Šè¨˜ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã®å®Ÿè£…ã«ãŠã„ã¦ã€ã‚­ãƒ¼ã¯ã€åŒä¸€æ€§ã«ã¤ã„ã¦ã€<tt>equal?</tt> (<tt>assoc</tt> ã«ã‚ˆã‚Šå‘¼ã³å‡ºã•ã‚Œã¦ã„ã‚‹) ã‚’ç”¨ã„ã¦æ¤œæŸ»ã•ã‚Œã¦ã„ã‚‹ã€‚
ã“ã‚Œã¯ã€å¸¸ã«é©åˆ‡ãªæ¤œæŸ»ã¨ã„ã†ã‚ã‘ã§ã¯ãªã„ã€‚
ãŸã¨ãˆã°ã€ã„ã¾èª¿ã¹ã¦ã„ã‚‹æ•°ã¨ã®å³å¯†ãªä¸€è‡´ã¯å¿…è¦ãªãã¦ã€ãã®æ•°ã®ä½•ã‚‰ã‹ã®è¨±å®¹ç¯„å›²å†…ã®æ•°ã ã‘ãŒå¿…è¦ã ã€ã¨ã„ã†ã‚ˆã†ãªã€æ•°å€¤ã‚­ãƒ¼ã‚’æŒã£ãŸãƒ†ãƒ¼ãƒ–ãƒ«ãŒã€ã‚ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚
ã‚­ãƒ¼åŒå£«ã®ã€ŒåŒä¸€æ€§ã€ã‚’æ¤œæŸ»ã™ã‚‹ã®ã«ä½¿ã‚ã‚Œã‚‹ã§ã‚ã‚ã†ã€<tt>same-key?</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’å¼•æ•°ã¨ã—ã¦ã¨ã‚‹ã€<tt>make-table</tt> ã¨ã„ã†ãƒ†ãƒ¼ãƒ–ãƒ«ãƒ»ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’ã€è¨­è¨ˆã›ã‚ˆã€‚
<tt>make-table</tt> ã¯ã€å±€æ‰€ãƒ†ãƒ¼ãƒ–ãƒ«ã«ã¨ã£ã¦é©åˆ‡ãª <tt>lookup</tt> ã¨ <tt>insert!</tt> ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã®ã«ä½¿ãˆã‚‹ã‚ˆã†ãªã€<tt>dispatch</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’è¿”ã™ã¹ãã§ã‚ã‚‹ã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.25"></a>
<b>Exercise 3.25.</b>  <a name="%_idx_3308"></a>Generalizing one- and two-dimensional tables, show how to implement a
table in which values are stored under an arbitrary number of keys and
different values may be stored under different numbers of keys.  The
<tt>lookup</tt> and <tt>insert!</tt> procedures should take as input a list
of keys used to access the table.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.25.</b> ä»»æ„ã®å€‹æ•°ã®ã‚­ãƒ¼ã®ã‚‚ã¨ã«å€¤ãŒæ ¼ç´ã•ã‚Œã€ã‹ã¤ã€ç•°ãªã‚‹å€¤ã¯ç•°ãªã‚‹è¤‡æ•°å€‹ã®ã‚­ãƒ¼ã®ã‚‚ã¨ã«æ ¼ç´ã•ã‚Œå¾—ã‚‹ã‚ˆã†ãªãƒ†ãƒ¼ãƒ–ãƒ«ã‚’å®Ÿè£…ã™ã‚‹æ–¹æ³•ã‚’ã€ä¸€æ¬¡å…ƒã¨äºŒæ¬¡å…ƒã®ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’ä¸€èˆ¬åŒ–ã™ã‚‹ã“ã¨ã§ã€ç¤ºã›ã€‚
<tt>lookup</tt> ã¨ <tt>insert!</tt> ã®æ‰‹ç¶šãã¯ã€ãƒ†ãƒ¼ãƒ–ãƒ«ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã®ã«ä½¿ã‚ã‚Œã‚‹ã‚­ãƒ¼ã®ãƒªã‚¹ãƒˆã‚’ã€å…¥åŠ›ã¨ã—ã¦å–ã‚‹ã¹ãã§ã‚ã‚‹ã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.26"></a>
<b>Exercise 3.26.</b>  <a name="%_idx_3310"></a><a name="%_idx_3312"></a>To search a table as implemented above, one needs to scan through the
list of records.  This is basically the unordered list representation of
section <a href="16_sec2_3.html#%_sec_2.3.3">2.3.3</a>.  For large tables, it may be more
efficient to structure the table in a different manner.  Describe a
table implementation where the (key, value) records are organized
using a binary tree, assuming that keys can be ordered in some way
(e.g., numerically or alphabetically).  (Compare
exercise <a href="16_sec2_3.html#%_thm_2.66">2.66</a> of chapter 2.)
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.26.</b> ä¸Šè¨˜ã®ã‚ˆã†ã«å®Ÿè£…ã•ã‚ŒãŸãƒ†ãƒ¼ãƒ–ãƒ«ã‚’æ¤œç´¢ã™ã‚‹ãŸã‚ã«ã¯ã€ãƒ¬ã‚³ãƒ¼ãƒ‰ã®ãƒªã‚¹ãƒˆå…¨ä½“ã‚’èµ°æŸ»ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
ã“ã‚Œã¯åŸºæœ¬çš„ã«ã¯ã€<a href="16_sec2_3.html#%_sec_2.3.3">2.3.3</a>ç¯€ã®é †åºãªã—ãƒªã‚¹ãƒˆè¡¨ç¾ã§ã‚ã‚‹ã€‚
å¤§ããªãƒ†ãƒ¼ãƒ–ãƒ«ã«å¯¾ã—ã¦ã¯ã€ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’åˆ¥ã®ã‚„ã‚Šæ–¹ã§æ§‹é€ åŒ–ã™ã‚‹æ–¹ãŒã€ã‚ˆã‚ŠåŠ¹ç‡çš„ã‹ã‚‚ã—ã‚Œãªã„ã€‚
<span class="math">(ã‚­ãƒ¼, å€¤)</span> ã®ãƒ¬ã‚³ãƒ¼ãƒ‰ãŒã€äºŒåˆ†æœ¨ã‚’ä½¿ã£ã¦çµ„ç¹”åŒ–ã•ã‚Œã¦ã„ã‚‹ã‚ˆã†ãªãƒ†ãƒ¼ãƒ–ãƒ«å®Ÿè£…ã«ã¤ã„ã¦ã€èª¬æ˜ã›ã‚ˆâ€”â€”ãŸã ã—ã€ä½•ã‚‰ã‹ã®æ–¹æ³•ã«ã‚ˆã£ã¦ (ãŸã¨ãˆã°ã€æ•°å€¤çš„ã«ã€ã¾ãŸã¯ã€ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆé †ã«) ã‚­ãƒ¼ã‚’é †åºã¥ã‘ã‚‹ã“ã¨ãŒã§ãã‚‹ã‚‚ã®ã¨æƒ³å®šã™ã‚‹ã€‚
(2ç« ã®ç·´ç¿’å•é¡Œ<a href="16_sec2_3.html#%_thm_2.66">2.66</a>ã¨æ¯”è¼ƒã›ã‚ˆã€‚)
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.27"></a>
<b>Exercise 3.27.</b>  <a name="%_idx_3314"></a><a name="%_idx_3316"></a><a name="%_idx_3318"></a><a name="%_idx_3320"></a><em>Memoization</em> (also called <em>tabulation</em>) is a technique that
enables a procedure to record, in a local table, values that have
previously been computed.  This technique can make a vast difference
in the performance of a program.  A memoized procedure maintains a
table in which values of previous calls are stored
using as keys the arguments that produced the values.  When the
memoized procedure is asked to compute a value, it first checks the
table to see if the value is already there and, if so, just returns
that value.  Otherwise, it computes the new value in the ordinary way
and stores this in the table.  As an example of memoization, recall
from section <a href="11_sec1_2.html#%_sec_1.2.2">1.2.2</a> the exponential process for
computing Fibonacci numbers:
</p>


<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.27.</b> <em>ãƒ¡ãƒ¢åŒ–</em> (<em>è¡¨ä½œæˆ</em>ã¨ã‚‚å‘¼ã°ã‚Œã‚‹) ã¯ã€ä»¥å‰ã™ã§ã«è¨ˆç®—ã•ã‚ŒãŸã“ã¨ã®ã‚ã‚‹å€¤ã‚’ã€æ‰‹ç¶šããŒå±€æ‰€ãƒ†ãƒ¼ãƒ–ãƒ«ã«è¨˜éŒ²ã™ã‚‹ã“ã¨ã‚’ã€å¯èƒ½ã¨ã™ã‚‹æŠ€æ³•ã§ã‚ã‚‹ã€‚
ã“ã®æŠ€æ³•ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®æ€§èƒ½ã«éå¸¸ãªç›¸é•ã‚’ã‚‚ãŸã‚‰ã™å¯èƒ½æ€§ãŒã‚ã‚‹ã€‚
ä»¥å‰ã®å‘¼ã³å‡ºã—ã®å€¤ãŒã€ãã®å€¤ã‚’ç”Ÿã¿å‡ºã—ãŸå¼•æ•°ã‚’ã‚­ãƒ¼ã¨ã—ã¦ä½¿ã£ã¦ã€æ ¼ç´ã•ã‚Œã¦ã„ã‚‹ã‚ˆã†ãªãƒ†ãƒ¼ãƒ–ãƒ«ã‚’ã€ãƒ¡ãƒ¢åŒ–ã•ã‚ŒãŸæ‰‹ç¶šãã¯ç¶­æŒã™ã‚‹ã€‚
ãƒ¡ãƒ¢åŒ–ã•ã‚ŒãŸæ‰‹ç¶šãã¯ã€å€¤ã‚’è¨ˆç®—ã™ã‚‹ã‚ˆã†ã«æ±‚ã‚ã‚‰ã‚ŒãŸã¨ãã«ã¯ã€ã¾ãšãƒ†ãƒ¼ãƒ–ãƒ«ã‚’æ¤œæŸ»ã—ã¦ã€ãã®å€¤ãŒæ—¢ã«ãã“ã«ã‚ã‚‹ã‹ã©ã†ã‹ã‚’èª¿ã¹ã€ã‚‚ã—ã‚ã‚Œã°ã€ãŸã ãã®å€¤ã‚’è¿”ã™ã€‚
ãã†ã§ãªã„å ´åˆã¯ã€æ™®é€šã®ã‚„ã‚Šæ–¹ã§æ–°ãŸãªå€¤ã‚’è¨ˆç®—ã—ã¦ã€ã“ã®å€¤ã‚’ãƒ†ãƒ¼ãƒ–ãƒ«ã«æ ¼ç´ã™ã‚‹ã€‚
ãƒ¡ãƒ¢åŒ–ã®ä¾‹ã¨ã—ã¦ã€<a href="11_sec1_2.html#%_sec_1.2.2">1.2.2</a>ç¯€ã‹ã‚‰ã€ãƒ•ã‚£ãƒœãƒŠãƒƒãƒæ•°ã‚’è¨ˆç®—ã™ã‚‹ãŸã‚ã®æŒ‡æ•°çš„ãªãƒ—ãƒ­ã‚»ã‚¹ã‚’æ€ã„å‡ºãã†ã€‚
</p>

<p class="lisp"><a name="%_idx_3322"></a>(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))
</p>

<p class="orig" lang="en">
The memoized version of the same procedure is
</p>

<p class="trans" lang="ja">
åŒã˜æ‰‹ç¶šãã®ãƒ¡ãƒ¢åŒ–ã•ã‚ŒãŸãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯ã€
</p>

<p class="lisp"><a name="%_idx_3324"></a>(define memo-fib
  (memoize (lambda (n)
             (cond ((= n 0) 0)
                   ((= n 1) 1)
                   (else (+ (memo-fib (- n 1))
                            (memo-fib (- n 2))))))))
</p>

<p class="orig" lang="en">
where the memoizer is defined as
</p>

<p class="trans" lang="ja">
ã§ã‚ã‚Šã€ã“ã“ã§ã€<ruby><rb>ãƒ¡ãƒ¢åŒ–ã™ã‚‹ã‚‚ã®</rb><rp> (</rp><rt>ãƒ¡ãƒ¢ãƒ¯ã‚¤ã‚¶</rt><rp>) </rp></ruby>ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_3326"></a>(define (memoize f)
  (let ((table (make-table)))
    (lambda (x)
      (let ((previously-computed-result (lookup x table)))
        (or previously-computed-result
            (let ((result (f x)))
              (insert! x result table)
              result))))))
</p>

<p class="orig" lang="en">
Draw an environment diagram to analyze the computation of <tt>(memo-fib 3)</tt>.  Explain why <tt>memo-fib</tt> computes the <em>n</em>th
Fibonacci number in a number of steps proportional to <em>n</em>.
Would the scheme still
work if we had simply defined <tt>memo-fib</tt> to be <tt>(memoize
fib)</tt>?

<p class="trans" lang="ja">
<tt>(memo-fib 3)</tt> ã®è¨ˆç®—ã‚’åˆ†æã™ã‚‹ç’°å¢ƒå›³ã‚’æã‘ã€‚
ãªãœ <tt>memo-fib</tt> ã¯ <em class="en">n</em> ç•ªç›®ã®ãƒ•ã‚£ãƒœãƒŠãƒƒãƒæ•°ã‚’ <em class="en">n</em> ã«æ¯”ä¾‹ã™ã‚‹ã‚¹ãƒ†ãƒƒãƒ—æ•°ã§è¨ˆç®—ã™ã‚‹ã®ã‹ã€ã«ã¤ã„ã¦èª¬æ˜ã›ã‚ˆã€‚
ã‚‚ã—å˜ç´”ã« <tt>memo-fib</tt> ã‚’ <tt>(memoize fib)</tt> ã¨å®šç¾©ã—ã¦ã„ãŸã¨ã—ã¦ã‚‚ã€ã“ã®æ–¹æ³•ã¯ä¾ç„¶ã¨ã—ã¦ã†ã¾ãã„ã£ãŸã ã‚ã†ã‹?
</p>

<p class="exercise"><span class="ex_comment">
</span></p>


<a name="%_sec_3.3.4"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_3.3.4">3.3.4  A Simulator for Digital Circuits</a></h3>
<h3 class="trans" lang="ja">3.3.4 ãƒ‡ã‚£ã‚¸ã‚¿ãƒ«å›è·¯ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿</h3>

<p class="orig" lang="en">
<a name="%_idx_3328"></a>
Designing complex digital systems, such as computers, is an important
engineering activity.  Digital systems are constructed by
interconnecting simple elements.  Although the behavior of these
individual elements is simple, networks of them can have very complex
behavior.  Computer simulation of proposed circuit designs is an
important tool used by digital systems engineers.  In this section we
design a system for performing digital logic simulations.  This system
typifies a kind of program called an <a name="%_idx_3330"></a><a name="%_idx_3332"></a><em>event-driven simulation</em>, in
which actions (``events'') trigger further events that happen at a
later time, which in turn trigger more events, and so so.</p>

<p class="trans" lang="ja">
è¤‡é›‘ãªãƒ‡ã‚£ã‚¸ã‚¿ãƒ«ã‚·ã‚¹ãƒ†ãƒ â€”â€”ãŸã¨ãˆã°ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã®ã‚ˆã†ãªã‚‚ã®â€”â€”ã‚’è¨­è¨ˆã™ã‚‹ã“ã¨ã¯ã€é‡è¦ãªå·¥å­¦çš„æ´»å‹•ã§ã‚ã‚‹ã€‚
ãƒ‡ã‚£ã‚¸ã‚¿ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã¯ã€å˜ç´”ãªè¦ç´ åŒå£«ã‚’ç›¸äº’æ¥ç¶šã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€æ§‹ç¯‰ã•ã‚Œã‚‹ã€‚
ã“ã‚Œã‚‰ã®å€‹ã€…ã®è¦ç´ ã®æŒ¯ã‚‹èˆã„ã¯å˜ç´”ãªã®ã ãŒã€ãã‚Œã‚‰ã§ã§ããŸç¶²çŠ¶çµ„ç¹”ã¯ã€éå¸¸ã«è¤‡é›‘ãªæŒ¯ã‚‹èˆã„ã‚’ã™ã‚‹ã“ã¨ãŒå¯èƒ½ã ã€‚
ææ¡ˆã•ã‚ŒãŸå›è·¯è¨­è¨ˆã®ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ»ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã¯ã€ãƒ‡ã‚£ã‚¸ã‚¿ãƒ«ã‚·ã‚¹ãƒ†ãƒ æŠ€è¡“è€…ã«ã‚ˆã£ã¦ä½¿ã‚ã‚Œã‚‹ã€é‡è¦ãªé“å…·ã§ã‚ã‚‹ã€‚
æœ¬ç¯€ã§ã¯ã€ãƒ‡ã‚£ã‚¸ã‚¿ãƒ«è«–ç†ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œã™ã‚‹ãŸã‚ã®ã‚·ã‚¹ãƒ†ãƒ ã‚’è¨­è¨ˆã™ã‚‹ã€‚
ã“ã®ã‚·ã‚¹ãƒ†ãƒ ã¯ã€<em>ã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³</em>â€”â€”æ´»å‹• (ã€Œã‚¤ãƒ™ãƒ³ãƒˆã€) ãŒã€å¾Œã«èµ·ã“ã‚‹æ›´ãªã‚‹ã‚¤ãƒ™ãƒ³ãƒˆã®å¼•ãé‡‘ã¨ãªã‚Šã€ãã®æ›´ãªã‚‹ã‚¤ãƒ™ãƒ³ãƒˆãŒä»Šåº¦ã¯ã¾ãŸåˆ¥ã®ã‚¤ãƒ™ãƒ³ãƒˆã®å¼•ãé‡‘ã¨ãªã‚Šã€ä»¥ä¸‹åŒæ§˜ã§ã‚ã‚‹â€”â€”ã¨å‘¼ã°ã‚Œã‚‹ã€ã‚ã‚‹ç¨®ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ä»£è¡¨ã™ã‚‹ã‚‚ã®ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
Our computational model of a circuit will be composed of objects that
correspond to the elementary components from which the circuit is
constructed.  There are <a name="%_idx_3334"></a><em>wires</em>, which carry <a name="%_idx_3336"></a><a name="%_idx_3338"></a><em>digital signals</em>.  A
digital signal may at any moment have only one of two possible values,
0 and 1.  There are also various types of digital <a name="%_idx_3340"></a><em>function
boxes</em>, which connect wires carrying input signals to other output
wires.  Such boxes produce output signals computed from their input
signals.  The output signal is <a name="%_idx_3342"></a>delayed by a time that depends on the
type of the function box.  For example, an <a name="%_idx_3344"></a><em>inverter</em> is a
primitive function box that inverts its input.  If the
input signal to an inverter changes to 0, then one inverter-delay
later the inverter will change its output signal to 1.  If the input
signal to an inverter changes to 1, then one inverter-delay later the
inverter will change its output signal to 0.  We draw an inverter
symbolically as in figure <a href="#%_fig_3.24">3.24</a>.  An <a name="%_idx_3346"></a><em>and-gate</em>,
also shown in figure <a href="#%_fig_3.24">3.24</a>, is a primitive function
box with two inputs and one output.  It drives its output signal to a
value that is the <a name="%_idx_3348"></a><em>logical and</em> of the inputs.  That is, if both
of its input signals become 1, then one and-gate-delay time later the
and-gate will force its output signal to be 1; otherwise the output
will be 0.  An <a name="%_idx_3350"></a><em>or-gate</em> is a similar two-input primitive function
box that drives its output signal to a value that is the <a name="%_idx_3352"></a><em>logical
or</em> of the inputs.  That is, the output will become 1 if at least one
of the input signals is 1; otherwise the output will become 0.</p>

<p class="trans" lang="ja">
å›è·¯ã«ã¤ã„ã¦ã®ç§ãŸã¡ã®è¨ˆç®—ãƒ¢ãƒ‡ãƒ«ã¯ã€ãã®å›è·¯ã‚’æ§‹ç¯‰ã™ã‚‹å…ƒã¨ãªã£ã¦ã„ã‚‹åŸºæœ¬çš„æ§‹æˆè¦ç´ ã«å¯¾å¿œã™ã‚‹ã‚ˆã†ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ã€æ§‹æˆã•ã‚Œã‚‹ã§ã‚ã‚ã†ã€‚
<em>é…ç·š</em>â€”â€”<em>ãƒ‡ã‚£ã‚¸ã‚¿ãƒ«ä¿¡å·</em>ã‚’ä¼ãˆã‚‹â€”â€”ãŒã‚ã‚‹ã€‚
ãƒ‡ã‚£ã‚¸ã‚¿ãƒ«ä¿¡å·ã¯ã€ä»»æ„ã®æ™‚ç‚¹ã«ãŠã„ã¦ã€äºŒã¤ã®å¯èƒ½ãªå€¤â€”â€”ã™ãªã‚ã¡0ã¨1â€”â€”ã®ã†ã¡ã®ã€ãŸã ä¸€ã¤ã®å€¤ã‚’ã¨ã‚‹ã ã‚ã†ã€‚
ã¾ãŸã€å¤šãã®ç¨®é¡ã®ãƒ‡ã‚£ã‚¸ã‚¿ãƒ«<em>æ©Ÿèƒ½ãƒœãƒƒã‚¯ã‚¹</em>â€”â€”å…¥åŠ›ä¿¡å·ã‚’ä¼ãˆã‚‹é…ç·šã‚’ã€ä»–ã®å‡ºåŠ›é…ç·šã«ã¤ãªã’ã‚‹â€”â€”ãŒã‚ã‚‹ã€‚
ãã†ã„ã£ãŸãƒœãƒƒã‚¯ã‚¹ã¯ã€è‡ªåˆ†ã¸ã®å…¥åŠ›ä¿¡å·ã‹ã‚‰è¨ˆç®—ã•ã‚Œã‚‹å‡ºåŠ›ä¿¡å·ã‚’ä½œã‚Šå‡ºã™ã€‚
å‡ºåŠ›ä¿¡å·ã¯ã€ãã®æ©Ÿèƒ½ãƒœãƒƒã‚¯ã‚¹ã®ç¨®é¡ã«å¿œã˜ãŸæ™‚é–“ã ã‘ã€é…å»¶ã•ã‚Œã‚‹ã€‚
ãŸã¨ãˆã°ã€<em>ã‚¤ãƒ³ãƒãƒ¼ã‚¿</em>ã¯ã€å…¥åŠ›ã‚’åè»¢ã•ã›ã‚‹ã‚ˆã†ãªã€åŸå§‹çš„æ©Ÿèƒ½ãƒœãƒƒã‚¯ã‚¹ã§ã‚ã‚‹ã€‚
ã‚¤ãƒ³ãƒãƒ¼ã‚¿ã¸ã®å…¥åŠ›ä¿¡å·ãŒ0ã¸ã¨å¤‰åŒ–ã™ã‚‹ã¨ã€ã‚¤ãƒ³ãƒãƒ¼ã‚¿é…å»¶ã®1å˜ä½åˆ†ã ã‘å¾Œã«ã€ã‚¤ãƒ³ãƒãƒ¼ã‚¿ã¯ã€ãã®å‡ºåŠ›ä¿¡å·ã‚’1ã¸ã¨å¤‰åŒ–ã•ã›ã‚‹ã ã‚ã†ã€‚
ã‚¤ãƒ³ãƒãƒ¼ã‚¿ã¸ã®å…¥åŠ›ä¿¡å·ãŒ1ã¸ã¨å¤‰åŒ–ã™ã‚‹ã¨ã€ã‚¤ãƒ³ãƒãƒ¼ã‚¿é…å»¶ã®1å˜ä½åˆ†ã ã‘å¾Œã«ã€ã‚¤ãƒ³ãƒãƒ¼ã‚¿ã¯ã€ãã®å‡ºåŠ›ä¿¡å·ã‚’0ã¸ã¨å¤‰åŒ–ã•ã›ã‚‹ã ã‚ã†ã€‚
ç§ãŸã¡ã¯ã€å›³<a href="#%_fig_3.24">3.24</a>ã®ã‚ˆã†ã«ã€ã‚¤ãƒ³ãƒãƒ¼ã‚¿ã‚’è¨˜å·çš„ã«æãã€‚
<em>ANDã‚²ãƒ¼ãƒˆ</em>â€”â€”ã“ã‚Œã‚‚å›³<a href="#%_fig_3.24">3.24</a>ã«ç¤ºã•ã‚Œã¦ã„ã‚‹â€”â€”ã¯ã€äºŒã¤ã®å…¥åŠ›ã¨ä¸€ã¤ã®å‡ºåŠ›ã‚’æŒã£ãŸã€åŸå§‹çš„æ©Ÿèƒ½ãƒœãƒƒã‚¯ã‚¹ã§ã‚ã‚‹ã€‚
ã“ã‚Œã¯ã€å…¥åŠ›ã®<em>è«–ç†ç©</em>ã§ã‚ã‚‹ã‚ˆã†ãªå€¤ã¸ã¨ã€ãã®å‡ºåŠ›ä¿¡å·ã‚’é§†å‹•ã™ã‚‹ã€‚
ã¤ã¾ã‚Šã€å…¥åŠ›ä¿¡å·ã®åŒæ–¹ãŒ1ã«ãªã£ãŸã‚‰ã€ANDã‚²ãƒ¼ãƒˆé…å»¶æ™‚é–“ã®1å˜ä½åˆ†ã ã‘å¾Œã«ã€ANDã‚²ãƒ¼ãƒˆã¯ã€ãã®å‡ºåŠ›ä¿¡å·ã‚’1ã«ã™ã‚‹ã ã‚ã†ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã€å‡ºåŠ›ã¯0ã«ãªã‚‹ã ã‚ã†ã€‚
<em>ORã‚²ãƒ¼ãƒˆ</em>ã¯ã€é¡ä¼¼ã®2å…¥åŠ›ã®åŸå§‹çš„æ©Ÿèƒ½ãƒœãƒƒã‚¯ã‚¹ã§ã€å…¥åŠ›ã®<em>è«–ç†å’Œ</em>ã§ã‚ã‚‹ã‚ˆã†ãªå€¤ã¸ã¨ã€ãã®å‡ºåŠ›ä¿¡å·ã‚’é§†å‹•ã™ã‚‹ã‚‚ã®ã§ã‚ã‚‹ã€‚
ã¤ã¾ã‚Šã€å…¥åŠ›ä¿¡å·ã®ã†ã¡å°‘ãªãã¨ã‚‚ä¸€ã¤ãŒ1ã®ã¨ãã«ã€å‡ºåŠ›ãŒ1ã¨ãªã‚‹ã ã‚ã†ã—ã€ãã‚Œä»¥å¤–ã®å ´åˆã¯ã€å‡ºåŠ›ãŒ0ã¨ãªã‚‹ã ã‚ã†ã€‚
</p>

<a name="%_fig_3.24"></a>
<figure>
<img src="ch3-Z-G-24.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.24:</b>  Primitive functions in the digital logic simulator.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³3.24:</b> ãƒ‡ã‚£ã‚¸ã‚¿ãƒ«è«–ç†ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã«ãŠã‘ã‚‹åŸå§‹çš„æ©Ÿèƒ½</figcaption>
</figure>


<p class="orig" lang="en">
We can connect primitive functions together to construct more complex
functions.  To accomplish this we wire the outputs of some
function boxes to the inputs of other function boxes.  For example,
the <a name="%_idx_3354"></a><a name="%_idx_3356"></a><em>half-adder</em> circuit shown in figure <a href="#%_fig_3.25">3.25</a> consists of an
or-gate, two and-gates, and an inverter.  It takes two input signals,
A and B, and has two output signals, S and C.  S will become 1
whenever precisely one of A and B is 1, and C will become 1 whenever A
and B are both 1.  We can see from the figure that, because of the
delays involved, the outputs may be generated at different times.
Many of the difficulties in the design of digital circuits arise from
this fact.</p>

<p class="trans" lang="ja">
åŸå§‹çš„ãªæ©Ÿèƒ½åŒå£«ã‚’æ¥ç¶šã—ã¦ã€ã‚ˆã‚Šè¤‡é›‘ãªæ©Ÿèƒ½ã‚’æ§‹ç¯‰ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
ã“ã‚Œã‚’é”æˆã™ã‚‹ãŸã‚ã«ã€ç§ãŸã¡ã¯ã€ã„ãã¤ã‹ã®æ©Ÿèƒ½ãƒœãƒƒã‚¯ã‚¹ã®å‡ºåŠ›ã‚’ã€ä»–ã®æ©Ÿèƒ½ãƒœãƒƒã‚¯ã‚¹ã®å…¥åŠ›ã¸ã¨é…ç·šã§ã¤ãªãã€‚
ãŸã¨ãˆã°ã€å›³<a href="#%_fig_3.25">3.25</a>ã«ç¤ºã—ãŸ<em>ãƒãƒ¼ãƒ•ãƒ»ã‚¢ãƒ€ãƒ¼</em> (åŠåŠ ç®—å™¨) å›è·¯ã¯ã€ä¸€ã¤ã®ORã‚²ãƒ¼ãƒˆã¨ã€äºŒã¤ã®ANDã‚²ãƒ¼ãƒˆã¨ã€ä¸€ã¤ã®ã‚¤ãƒ³ãƒãƒ¼ã‚¿ã¨ã€ã‹ã‚‰ãªã‚‹ã€‚
ã“ã‚Œã¯äºŒã¤ã®å…¥åŠ›ä¿¡å·â€”â€”ã¤ã¾ã‚Šã€Aã¨Bâ€”â€”ã‚’ã¨ã‚Šã€äºŒã¤ã®å‡ºåŠ›ä¿¡å·â€”â€”ã¤ã¾ã‚Šã€Sã¨Câ€”â€”ã‚’æŒã¤ã€‚
Aã¨Bã®ã†ã¡ã®ã¡ã‚‡ã†ã©ã¾ã•ã«ä¸€ã¤ãŒ1ã®ã¨ãã«ã¯ã„ã¤ã§ã‚‚ã€SãŒ1ã«ãªã‚‹ã ã‚ã†ã—ã€Aã¨BãŒã¨ã‚‚ã«1ã®ã¨ãã«ã¯ã„ã¤ã§ã‚‚ã€CãŒ1ã«ãªã‚‹ã ã‚ã†ã€‚
ãã“ã«ä¼´ã†é…å»¶ã®ã›ã„ã§ã€ç•°ãªã‚‹æ™‚ç‚¹ã«ãŠã„ã¦å‡ºåŠ›ãŒç”Ÿæˆã•ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€ã¨ã„ã†ã“ã¨ãŒã€å›³ã‹ã‚‰åˆ†ã‹ã‚‹ã€‚
ãƒ‡ã‚£ã‚¸ã‚¿ãƒ«å›è·¯ã®è¨­è¨ˆã«ãŠã‘ã‚‹å›°é›£ã®å¤šãã¯ã€ã“ã®äº‹å®Ÿã‹ã‚‰ç”Ÿã˜ã‚‹ã€‚
</p>

<a name="%_fig_3.25"></a>
<figure>
<img src="ch3-Z-G-25.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.25:</b>  A half-adder circuit.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³3.25:</b> ãƒãƒ¼ãƒ•ãƒ»ã‚¢ãƒ€ãƒ¼å›è·¯</figcaption>
</figure>

<div class="exercise"><table class="expl">
<tr><th>A</th><th>B</th><th>C <br>(= A AND B)</th><th>D <br>(= A OR B)</th><th>E <br>(= NOT C)</th><th>S <br>(= D AND E)</th></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr>
<tr><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td></tr>
</table></div>

<p class="orig" lang="en">
We will now build a program for modeling the digital logic circuits we
wish to study.  The program will construct computational objects
modeling the wires, which will ``hold'' the signals.  Function boxes
will be modeled by procedures that enforce the correct relationships
among the signals.</p>

<p class="trans" lang="ja">
ã•ã¦ã“ã‚Œã‹ã‚‰ã€ç ”ç©¶ã—ãŸã„ãƒ‡ã‚£ã‚¸ã‚¿ãƒ«è«–ç†å›è·¯ã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã™ã‚‹ãŸã‚ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ§‹ç¯‰ã—ã‚ˆã†ã€‚
ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€é…ç·šâ€”â€”ä¿¡å·ã‚’ã€Œä¿æŒã€ã™ã‚‹ã“ã¨ã ã‚ã†â€”â€”ã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã™ã‚‹è¨ˆç®—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ§‹ç¯‰ã™ã‚‹ã ã‚ã†ã€‚
æ©Ÿèƒ½ãƒœãƒƒã‚¯ã‚¹ã¯ã€ä¿¡å·åŒå£«ã®é–“ã®æ­£ã—ã„é–¢ä¿‚ã‚’å¼·åˆ¶ã™ã‚‹ã‚ˆã†ãªæ‰‹ç¶šãã«ã‚ˆã£ã¦ã€ãƒ¢ãƒ‡ãƒ«åŒ–ã•ã‚Œã‚‹ã ã‚ã†ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_3358"></a>One basic element of our simulation will be a procedure <tt>make-wire</tt>, which constructs wires.  For example, we can construct six
wires as follows:</p>

<p class="trans" lang="ja">
ç§ãŸã¡ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã«ãŠã‘ã‚‹ä¸€ã¤ã®åŸºæœ¬çš„è¦ç´ ã¯ã€<tt>make-wire</tt> ã¨ã„ã†æ‰‹ç¶šãâ€”â€”é…ç·šã‚’æ§‹ç¯‰ã™ã‚‹â€”â€”ã§ã‚ã‚ã†ã€‚
ãŸã¨ãˆã°ã€6æœ¬ã®é…ç·šã‚’ä»¥ä¸‹ã®ã‚ˆã†ã«æ§‹ç¯‰ã§ãã‚‹ã€‚
</p>

<p class="lisp">(define a (make-wire))
(define b (make-wire))
(define c (make-wire))

(define d (make-wire))
(define e (make-wire))
(define s (make-wire))
</p>

<p class="orig" lang="en">
We attach a function box to a set of wires by calling a procedure that
constructs that kind of box.  The arguments to the constructor
procedure are the wires to be attached to the box.  For example, given
that we can construct and-gates, or-gates, and inverters, we can wire
together the half-adder shown in figure <a href="#%_fig_3.25">3.25</a>:</p>

<p class="trans" lang="ja">
ç§ãŸã¡ã¯ã€æ©Ÿèƒ½ãƒœãƒƒã‚¯ã‚¹ã‚’ã€ãã®ç¨®é¡ã®ãƒœãƒƒã‚¯ã‚¹ã‚’æ§‹ç¯‰ã™ã‚‹æ‰‹ç¶šãã‚’å‘¼ã³å‡ºã™ã“ã¨ã«ã‚ˆã£ã¦ã€é…ç·šã®é›†åˆã«ã¤ãªã’ã‚‹ã€‚
ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿æ‰‹ç¶šãã«å¯¾ã™ã‚‹å®Ÿå¼•æ•°ã¯ã€ãã®ãƒœãƒƒã‚¯ã‚¹ã«ã¤ãªãŒã‚Œã‚‹ã¹ãé…ç·šã§ã‚ã‚‹ã€‚
ãŸã¨ãˆã°ã€ANDã‚²ãƒ¼ãƒˆã¨ORã‚²ãƒ¼ãƒˆã¨ã‚¤ãƒ³ãƒãƒ¼ã‚¿ã‚’æ§‹ç¯‰ã§ãã‚‹ã‚‚ã®ã¨ã™ã‚‹ã¨ã€å›³<a href="#%_fig_3.25">3.25</a>ã«ç¤ºã—ãŸãƒãƒ¼ãƒ•ãƒ»ã‚¢ãƒ€ãƒ¼ã‚’é…ç·šã§ã¤ãªã„ã§ã¾ã¨ã‚ã‚ã’ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
</p>

<p class="lisp">(or-gate a b d)
<i>ok</i>

(and-gate a b c)
<i>ok</i>

(inverter c e)
<i>ok</i>

(and-gate d e s)
<i>ok</i>
</p>

<p class="orig" lang="en">
Better yet, we can explicitly name this operation by defining a procedure <tt>half-adder</tt> that constructs this circuit, given the four
external wires to be attached to the half-adder:</p>

<p class="trans" lang="ja">
ãƒãƒ¼ãƒ•ãƒ»ã‚¢ãƒ€ãƒ¼ã«ã¤ãªãŒã‚Œã‚‹ã¹ãã€å¤–éƒ¨ã®4æœ¬ã®é…ç·šã‚’ä¸ãˆã‚‰ã‚Œã‚‹ã¨ã€ã“ã®å›è·¯ã‚’æ§‹ç¯‰ã™ã‚‹ã‚ˆã†ãªã€<tt>half-adder</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’å®šç¾©ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€ç§ãŸã¡ã¯ã€ã‚‚ã£ã¨è‰¯ã„ã“ã¨ã«ã¯ã€ã“ã®æ¼”ç®—ã«æ˜ç¤ºçš„ã«åå‰ã‚’ã¤ã‘ã‚‰ã‚Œã‚‹ã®ã§ã‚ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_3360"></a>(define (half-adder a b s c)
  (let ((d (make-wire)) (e (make-wire)))
    (or-gate a b d)
    (and-gate a b c)
    (inverter c e)
    (and-gate d e s)
    'ok))
</p>

<p class="orig" lang="en">
The advantage of making this definition is that we can use
<tt>half-adder</tt> itself as a building block in creating more complex
circuits.  Figure <a href="#%_fig_3.26">3.26</a>, for example, shows a <a name="%_idx_3362"></a><a name="%_idx_3364"></a><em>full-adder</em> composed of two half-adders and an or-gate.<a name="call_footnote_Temp_379" href="#footnote_Temp_379"><sup><small>26</small></sup></a> We can construct a full-adder
as follows:</p>

<p class="trans" lang="ja">
ã“ã†ã„ã†å®šç¾©ã‚’è¡Œã†ã“ã¨ã®åˆ©ç‚¹ã¯ã€ã‚ˆã‚Šè¤‡é›‘ãªå›è·¯ã‚’ä½œæˆã™ã‚‹éš›ã®åŸºæœ¬æ§‹æˆè¦ç´ ã¨ã—ã¦ã€<tt>half-adder</tt> è‡ªä½“ã‚’ä½¿ãˆã‚‹ç‚¹ã§ã‚ã‚‹ã€‚
ãŸã¨ãˆã°ã€å›³<a href="#%_fig_3.26">3.26</a>ã¯ã€äºŒã¤ã®ãƒãƒ¼ãƒ•ãƒ»ã‚¢ãƒ€ãƒ¼ã¨ä¸€ã¤ã®ORã‚²ãƒ¼ãƒˆã‹ã‚‰æ§‹æˆã•ã‚Œã‚‹ã€<em>ãƒ•ãƒ«ãƒ»ã‚¢ãƒ€ãƒ¼</em> (å…¨åŠ ç®—å™¨) ã‚’ç¤ºã—ã¦ã„ã‚‹<a href="#footnote_Temp_379"><sup><small>26</small></sup></a> ã€‚
ãƒ•ãƒ«ãƒ»ã‚¢ãƒ€ãƒ¼ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¦æ§‹ç¯‰ã§ãã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_3366"></a>(define (full-adder a b c-in sum c-out)
  (let ((s (make-wire))
        (c1 (make-wire))
        (c2 (make-wire)))
    (half-adder b c-in s c1)
    (half-adder a s sum c2)
    (or-gate c1 c2 c-out)
    'ok))
</p>

<p class="orig" lang="en">
Having defined <tt>full-adder</tt> as a procedure, we can now use it as a
building block for creating still more complex circuits.  (For
example, see exercise <a href="#%_thm_3.30">3.30</a>.)</p>

<p class="trans" lang="ja">
<tt>full-adder</tt> ã‚’æ‰‹ç¶šãã¨ã—ã¦å®šç¾©ã—ãŸã®ã§ã€ç§ãŸã¡ã¯ä»Šã‚„ãã‚Œã‚’ã€ã¾ã ã¾ã ã•ã‚‰ã«è¤‡é›‘ãªå›è·¯ã‚’ä½œæˆã™ã‚‹ãŸã‚ã®åŸºæœ¬æ§‹æˆè¦ç´ ã¨ã—ã¦ã€ç”¨ã„ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
(ãŸã¨ãˆã°ã€ç·´ç¿’å•é¡Œ<a href="#%_thm_3.30">3.30</a>ã‚’å‚ç…§)ã€‚
</p>

<a name="%_fig_3.26"></a>
<figure>
<img src="ch3-Z-G-26.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.26:</b>  A full-adder circuit.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³3.26:</b> ãƒ•ãƒ«ãƒ»ã‚¢ãƒ€ãƒ¼å›è·¯</figcaption>
</figure>

<div class="exercise"><table class="expl">
<tr><th colspan="3">å…¥åŠ›</th><th colspan="2">ä¸‹ã®HAã®å‡ºåŠ›</th><th colspan="2">ä¸Šã®HAã®å‡ºåŠ›</th><th>ORã‚²ãƒ¼ãƒˆã®å‡ºåŠ›</th></tr>
<tr><th>A</th><th>B</th><th>Cin</th><th>S</th><th>C1</th><th>SUM</th><th>C2</th><th>Cout (=C1 OR C2)</th></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td></tr>
</table></div>

<p class="orig" lang="en">
In essence, our simulator provides us with the tools to construct a
language of circuits.  If we adopt the general perspective on
languages with which we approached the study of Lisp in
section <a href="10_sec1_1.html#%_sec_1.1">1.1</a>,
we can say that the primitive function boxes form the primitive
elements of the language, that wiring boxes together provides a means
of combination, and that specifying wiring patterns as procedures
serves as a means of abstraction.</p>

<p class="trans" lang="ja">
æœ¬è³ªçš„ã«ã¯ã€ç§ãŸã¡ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã¯ã€å›è·¯ã®è¨€èªã‚’æ§‹ç¯‰ã™ã‚‹ãŸã‚ã®æ‰‹æ®µã‚’æä¾›ã—ã¦ãã‚Œã‚‹ã®ã§ã‚ã‚‹ã€‚
ã‚‚ã—ã€<a href="10_sec1_1.html#%_sec_1.1">1.1</a>ç¯€ã§Lispã®å‹‰å¼·ã«ã¨ã‚Šã‹ã‹ã£ãŸã¨ãã«ä½¿ã£ãŸã€è¨€èªã«ã¤ã„ã¦ã®ä¸€èˆ¬çš„ãªè¦–ç‚¹ã‚’æ¡ç”¨ã™ã‚‹ãªã‚‰ã€æ¬¡ã®ã‚ˆã†ã«è¨€ãˆã‚‹ã ã‚ã†ã€‚ã¤ã¾ã‚Šã€åŸå§‹çš„ãªæ©Ÿèƒ½ãƒœãƒƒã‚¯ã‚¹ã¯è¨€èªã®åŸå§‹çš„è¦ç´ ã‚’å½¢æˆã—ã€ãã‚Œã¨åŒæ™‚ã«é…ç·šã®ãƒœãƒƒã‚¯ã‚¹ã¯çµåˆæ‰‹æ®µã‚’æä¾›ã—ã€é…ç·šãƒ‘ã‚¿ãƒ³ã‚’æ‰‹ç¶šãã¨ã—ã¦æŒ‡å®šã™ã‚‹ã“ã¨ã¯æŠ½è±¡åŒ–æ‰‹æ®µã¨ã—ã¦å½¹ç«‹ã¤ã®ã§ã‚ã‚‹ã€ã¨ã€‚
</p>


<a name="%_sec_Temp_380"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_380">Primitive function boxes</a></h4>
<h4 class="trans" lang="ja">åŸå§‹çš„ãªæ©Ÿèƒ½ãƒœãƒƒã‚¯ã‚¹</h4>


<p class="orig" lang="en">
<a name="%_idx_3368"></a>
The primitive function boxes implement the ``forces'' by which a
change in the signal on one wire influences the signals on other
wires.  To build function boxes, we use the following operations on
wires:</p>

<p class="trans" lang="ja">
åŸå§‹çš„ãªæ©Ÿèƒ½ãƒœãƒƒã‚¯ã‚¹ã¯ã€1æœ¬ã®é…ç·šä¸Šã®ä¿¡å·ã®å¤‰åŒ–ãŒä»–ã®é…ç·šä¸Šã®ä¿¡å·ã«å½±éŸ¿ã‚’åŠã¼ã™éš›ã«ãã®æ‰‹æ®µã¨ãªã‚‹ã€ŒåŠ›ã€ã‚’å®Ÿè£…ã™ã‚‹ã€‚
æ©Ÿèƒ½ãƒœãƒƒã‚¯ã‚¹ã‚’æ§‹ç¯‰ã™ã‚‹ã«ã¯ã€é…ç·šã«å¯¾ã™ã‚‹ä»¥ä¸‹ã®æ¼”ç®—ã‚’ä½¿ã†ã€‚
</p>


<ul class="orig" lang="en">
<li><tt>(get-signal &lt;<em>wire</em>&gt;)</tt>
<a name="%_idx_3370"></a>returns the current value of the signal on the wire.</li>

<li><tt>(set-signal! &lt;<em>wire</em>&gt; &lt;<em>new value</em>&gt;)</tt>
<a name="%_idx_3372"></a>changes the value of the signal on the wire to the new value.</li>

<li><tt>(add-action! &lt;<em>wire</em>&gt; &lt;<em>procedure of no arguments</em>&gt;)</tt>
<a name="%_idx_3374"></a>asserts that the designated procedure should be run whenever the
signal on the wire changes value.  Such procedures are the vehicles by
which changes in the signal value on the wire are communicated to
other wires.</li>
</ul>

<ul class="trans" lang="ja">
<li><tt>(get-signal &lt;<em class="en">wire</em>&gt;)</tt> ã¯ã€ãã®é…ç·šä¸Šã®ä¿¡å·ã®ç¾åœ¨ã®å€¤ã‚’è¿”ã™ã€‚</li>
<li><tt>(set-signal! &lt;<em class="en">wire</em>&gt; &lt;<em class="en">new value</em>&gt;)</tt> ã¯ã€ãã®é…ç·šä¸Šã®ä¿¡å·ã®å€¤ã‚’æ–°ãŸãªå€¤ã«å¤‰æ›´ã™ã‚‹ã€‚</li>
<li><tt>(add-action! &lt;<em class="en">wire</em>&gt; &lt;<em class="en">procedure of no arguments</em>&gt;)</tt>  ã¯ã€ãã®é…ç·šä¸Šã®ä¿¡å·ã®å€¤ãŒå€¤ã‚’å¤‰åŒ–ã•ã›ã‚‹ã¨ãã«ã¯ã„ã¤ã§ã‚‚ã€æŒ‡å®šã•ã‚ŒãŸæ‰‹ç¶šãã‚’å®Ÿè¡Œã™ã¹ãã§ã‚ã‚‹ã“ã¨ã‚’ä¸»å¼µã™ã‚‹ã€‚
ã“ã®ã‚ˆã†ãªæ‰‹ç¶šãã¯ã€é…ç·šä¸Šã®ä¿¡å·å€¤ã®å¤‰åŒ–ã‚’ä»–ã®é…ç·šã¸ã¨ä¼ãˆã‚‹ä¼é”åª’ä½“ãªã®ã§ã‚ã‚‹ã€‚</li>
</ul>

<p class="orig" lang="en">
<a name="%_idx_3376"></a>In addition, we will make use of a procedure <tt>after-delay</tt> that
takes a time delay and a procedure to be run and executes the
given procedure after the given delay.</p>

<p class="trans" lang="ja">
ã•ã‚‰ã«ã€æ™‚é–“ã®é…å»¶ã¨ã€å®Ÿè¡Œã™ã¹ãæ‰‹ç¶šãã¨ã‚’å–ã‚Šã€ä¸ãˆã‚‰ã‚ŒãŸé…å»¶ã®å¾Œã«ä¸ãˆã‚‰ã‚ŒãŸæ‰‹ç¶šãã‚’å®Ÿè¡Œã™ã‚‹ã‚ˆã†ãªã€<tt>after-delay</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ã«ã—ã‚ˆã†ã€‚
</p>

<p class="orig" lang="en">
Using these procedures, we can define the primitive digital logic
functions.  To connect an input to an output through an inverter, we
use <tt>add-action!</tt> to associate with the input wire a procedure
that will be run whenever the signal on the input wire changes value.
The procedure computes the <tt>logical-not</tt> of the input signal, and
then, after one <tt>inverter-delay</tt>, sets the output signal to be
this new value:</p>

<p class="trans" lang="ja">
ã“ã‚Œã‚‰ã®æ‰‹ç¶šãã‚’ä½¿ã†ã¨ã€åŸå§‹çš„ãªãƒ‡ã‚£ã‚¸ã‚¿ãƒ«è«–ç†é–¢æ•°ã‚’å®šç¾©ã§ãã‚‹ã€‚
ã‚¤ãƒ³ãƒãƒ¼ã‚¿ã‚’ä»‹ã—ã¦å…¥åŠ›ã‚’å‡ºåŠ›ã¸ã¤ãªãã«ã¯ã€<tt>add-action!</tt> ã‚’ä½¿ã£ã¦ã€å…¥åŠ›é…ç·šã«ã€ãã®å…¥åŠ›é…ç·šä¸Šã®ä¿¡å·ãŒå€¤ã‚’å¤‰æ›´ã™ã‚‹ã¨ãã«ã¯ã„ã¤ã§ã‚‚å®Ÿè¡Œã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã ã‚ã†æ‰‹ç¶šãã‚’ã€é–¢é€£ã¥ã‘ã‚‹ã€‚
ãã®æ‰‹ç¶šãã¯ã€å…¥åŠ›ä¿¡å·ã® <tt>logical-not</tt> (è«–ç†å¦å®š) ã‚’è¨ˆç®—ã—ã€ãã‚Œã‹ã‚‰ã€<tt>inverter-delay</tt> (ã‚¤ãƒ³ãƒãƒ¼ã‚¿é…å»¶) ã®1å›åˆ†ã ã‘å¾Œã«ã€å‡ºåŠ›ä¿¡å·ã‚’ã“ã®æ–°ãŸãªå€¤ã¸ã¨è¨­å®šã™ã‚‹ã€‚
</p>


<p class="lisp"><a name="%_idx_3378"></a>(define (inverter input output)
  (define (invert-input)
    (let ((new-value (logical-not (get-signal input))))
      (after-delay inverter-delay
                   (lambda ()
                     (set-signal! output new-value)))))
  (add-action! input invert-input)
  'ok)
<a name="%_idx_3380"></a>(define (logical-not s)
  (cond ((= s 0) 1)
        ((= s 1) 0)
        (else (error &quot;Invalid signal&quot; s))))
</p>

<p class="orig" lang="en">
An and-gate is a little more complex.  The action procedure must be run if
either of the inputs to the gate changes.  It computes the <tt>logical-and</tt> (using a procedure analogous to <tt>logical-not</tt>) of the
values of the signals on the input wires and sets up a change to the
new value to occur on the output wire after one <tt>and-gate-delay</tt>.</p>

<p class="trans" lang="ja">
ANDã‚²ãƒ¼ãƒˆã¯ã€ã‚‚ã†å°‘ã—è¤‡é›‘ã§ã‚ã‚‹ã€‚
å‹•ä½œã®æ‰‹ç¶šãã¯ã€ã‚²ãƒ¼ãƒˆã¸ã®å…¥åŠ›ã®ã†ã¡ã®ä¸€æ–¹ãŒå¤‰åŒ–ã—ãŸã‚‰ã€å®Ÿè¡Œã•ã‚Œã­ã°ãªã‚‰ãªã„ã®ã§ã‚ã‚‹ã€‚
ã“ã®æ‰‹ç¶šãã¯ã€å…¥åŠ›é…ç·šä¸Šã®ä¿¡å·ã®å€¤åŒå£«ã® <tt>logical-and</tt> (è«–ç†ç©) ã‚’ã€(<tt>logical-not</tt> ã¨ä¼¼ãŸæ‰‹ç¶šãã‚’ä½¿ã£ã¦) è¨ˆç®—ã—ã€æ–°ãŸãªå€¤ã¸ã®å¤‰æ›´ã‚’ã€<tt>and-gate-delay</tt> (ANDã‚²ãƒ¼ãƒˆé…å»¶) ã®1å›åˆ†ã ã‘å¾Œã«å‡ºåŠ›é…ç·šä¸Šã«ç”Ÿã˜ã‚‹ã‚ˆã†ã«ã€è¨­å®šã™ã‚‹ã®ã ã€‚
</p>

<p class="lisp"><a name="%_idx_3382"></a>(define (and-gate a1 a2 output)
  (define (and-action-procedure)
    (let ((new-value
           (logical-and (get-signal a1) (get-signal a2))))
      (after-delay and-gate-delay
                   (lambda ()
                     (set-signal! output new-value)))))
  (add-action! a1 and-action-procedure)
  (add-action! a2 and-action-procedure)
  'ok)
</p>

<p class="orig" lang="en">
<a name="%_thm_3.28"></a>
<b>Exercise 3.28.</b>  <a name="%_idx_3384"></a>Define an or-gate as a primitive function box.  Your <tt>or-gate</tt>
constructor should be similar to <tt>and-gate</tt>.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.28.</b> ORã‚²ãƒ¼ãƒˆã‚’ã€åŸå§‹çš„ãªæ©Ÿèƒ½ãƒœãƒƒã‚¯ã‚¹ã¨ã—ã¦å®šç¾©ã›ã‚ˆã€‚
å›ã® <tt>or-gate</tt> ã¨ã„ã†ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ã€<tt>and-gate</tt> ã«ä¼¼ã¦ã„ã‚‹ã¯ãšã ã€‚
</p>

<p class="exercise">(define (or-gate o1 o2 output)
  (define (or-action-procedure)
    (let ((new-value (logical-or (get-signal o1) (get-signal o2))))
      (after-delay or-gate-delay (lambda () (set-signal! output new-value)))))
  (add-action! o1 or-action-procedure)
  (add-action! o2 or-action-procedure)
  'ok)
<span class="ex_comment">; ã¤ã„ã§ã«ã“ã‚Œã‚‚å®šç¾©ã—ã¦ãŠãã€‚</span>
(define (logical-or a b)
  (cond ((and (= a 0) (= b 0)) 0)
        ((and (= a 0) (= b 1)) 1)
        ((and (= a 1) (= b 0)) 1)
        ((and (= a 0) (= b 0)) 0)
        (else (error &quot;Invalid signal&quot; a b))))
</p>

<p class="orig" lang="en"><a name="%_thm_3.29"></a>
<b>Exercise 3.29.</b>  <a name="%_idx_3386"></a>Another way to construct an or-gate is as a compound digital logic
device, built from and-gates and inverters.  Define a procedure <tt>or-gate</tt> that accomplishes this.  What is the delay time of the
or-gate in terms of <tt>and-gate-delay</tt> and <tt>inverter-delay</tt>?
</p>


<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.29.</b> ORã‚²ãƒ¼ãƒˆã‚’æ§‹ç¯‰ã™ã‚‹ãŸã‚ã®åˆ¥ã®æ–¹æ³•ã¯ã€è¤‡åˆçš„ãªãƒ‡ã‚£ã‚¸ã‚¿ãƒ«è«–ç†ãƒ‡ãƒã‚¤ã‚¹â€”â€”ANDã‚²ãƒ¼ãƒˆã¨ã‚¤ãƒ³ãƒãƒ¼ã‚¿ã‹ã‚‰æ§‹ç¯‰ã•ã‚ŒãŸã‚‚ã®â€”â€”ã¨ã—ã¦ã®ã‚‚ã®ã§ã‚ã‚‹ã€‚
ã“ã‚Œã‚’é”æˆã™ã‚‹ã‚ˆã†ãªã€<tt>or-gate</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’å®šç¾©ã›ã‚ˆã€‚
<tt>and-gate-delay</tt> ã¨ <tt>inverter-delay</tt> ã§è¡¨ã—ãŸã€ORã‚²ãƒ¼ãƒˆã®é…å»¶æ™‚é–“ã¯ã€ã©ã®ã‚ˆã†ãªã‚‚ã®ã‹?
</p>

<div class="exercise"><table class="expl">
<tr><th>A</th><th>B</th><th>NOT A</th><th>NOT B</th><th>NOT A AND NOT B</th><th>A OR B</th></tr>
<tr><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td></tr>
<tr><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td></tr>
<tr><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>
</table></div>

<p class="exercise"><span class="ex_comment">ä¸Šã®è¡¨ã‹ã‚‰ã‚‚ã‚ã‹ã‚‹ã‚ˆã†ã«ã€
A OR B = NOT (NOT A AND NOT B)
ãªã®ã§ã€ã“ã®ã“ã¨ã‚’åˆ©ç”¨ã—ã¦å®šç¾©ã™ã‚‹ã€‚ãªãŠã€NOT Aã¨NOT Bã¯ä¸¦åˆ—ã«å®Ÿè¡Œã§ãã‚‹ã‹ã‚‰ã€
é…å»¶æ™‚é–“ã¯ã€<tt>inverter-delay * 2 + and-gate-delay</tt> ã«ãªã‚‹ã¯ãšã€‚</span>

(define (or-gate o1 o2 output)
  (let ((a (make-wire)) (b (make-wire)) (c (make-wire)))
      (inverter o1 a) (inverter o2 b) (and-gate a b c) (inverter c output)))</p>
<!--ã†ã£ã‹ã‚Šã™ã‚‹ã¨ã€å˜ç´”ã«
(define (or-gate a b output)
  (inverter (and-gate (inverter a not-a) (inverter b not-b) not-a-and-not-b) output))
ã¨æ›¸ããŸããªã£ã¦ã—ã¾ã†ã¨ã“ã‚ã ãŒã€ãã†ã¯ã„ã‹ã‚“ã®ã‚ˆã­ã€‚
-->
<p class="orig" lang="en">
<a name="%_thm_3.30"></a>
<b>Exercise 3.30.</b>  Figure <a href="#%_fig_3.27">3.27</a> shows a <a name="%_idx_3388"></a><a name="%_idx_3390"></a><em>ripple-carry adder</em> formed by stringing
together <em>n</em> full-adders.  This is the simplest form of parallel adder
for adding two <em>n</em>-bit binary numbers.  The inputs A<sub>1</sub>, A<sub>2</sub>,
A<sub>3</sub>, <tt>...</tt>, A<sub><em>n</em></sub> and B<sub>1</sub>, B<sub>2</sub>, B<sub>3</sub>, <tt>...</tt>,
B<sub><em>n</em></sub> are the two binary numbers to be added (each A<sub><em>k</em></sub> and B<sub><em>k</em></sub>
is a 0 or a 1).  The circuit generates S<sub>1</sub>, S<sub>2</sub>, S<sub>3</sub>,
<tt>...</tt>, S<sub><em>n</em></sub>, the <em>n</em> bits of the sum, and C, the carry from
the addition.  Write a procedure <tt>ripple-carry-adder</tt> that
generates this circuit.  The procedure should take as arguments three
lists of <em>n</em> wires each -- the A<sub><em>k</em></sub>, the B<sub><em>k</em></sub>, and the S<sub><em>k</em></sub> -- and
also another wire C.  The major drawback of the ripple-carry adder is
the need to wait for the carry signals to propagate.  What is the
delay needed to obtain the complete output from an <em>n</em>-bit
ripple-carry adder, expressed in terms of the delays for and-gates,
or-gates, and inverters?
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.30.</b> å›³<a href="#%_fig_3.27">3.27</a>ã¯ã€<em class="en">n</em>å€‹ã®ãƒ•ãƒ«ãƒ»ã‚¢ãƒ€ãƒ¼ã‚’ã²ã¨ã¤ãªãã«ã™ã‚‹ã“ã¨ã§å½¢æˆã•ã‚ŒãŸ<em>ãƒªãƒƒãƒ—ãƒ«ãƒ»ã‚­ãƒ£ãƒªãƒ¼ãƒ»ã‚¢ãƒ€ãƒ¼</em>ã‚’ç¤ºã—ã¦ã„ã‚‹ã€‚
ã“ã‚Œã¯ã€äºŒã¤ã®<em class="en">n</em>ãƒ“ãƒƒãƒˆã®2é€²æ•°ã‚’è¶³ã™ãŸã‚ã®ã€æœ€ã‚‚å˜ç´”ãªä¸¦åˆ—åŠ ç®—å™¨ã§ã‚ã‚‹ã€‚
A<sub>1</sub>, A<sub>2</sub>, A<sub>3</sub>, <tt>...</tt>, A<sub><em class="en">n</em></sub> 
ãŠã‚ˆã³ 
B<sub>1</sub>, B<sub>2</sub>, B<sub>3</sub>, <tt>...</tt>, B<sub><em class="en">n</em></sub> 
ã¯ã€è¶³ã™ã¹ãäºŒã¤ã®2é€²æ•°ã§ã‚ã‚‹ (å„ A<sub><em class="en">k</em></sub> ãŠã‚ˆã³ B<sub><em class="en">k</em></sub> ã¯ã€0ã¾ãŸã¯1ã§ã‚ã‚‹)ã€‚
ã“ã®å›è·¯ã¯ã€
 S<sub>1</sub>, S<sub>2</sub>, S<sub>3</sub>, <tt>...</tt>, S<sub><em class="en">n</em></sub> 
â€”â€”ã™ãªã‚ã¡ã€<em class="en">n</em>ãƒ“ãƒƒãƒˆã®å’Œâ€”â€”ã¨ã€C â€”â€”ã™ãªã‚ã¡åŠ ç®—ã«ã‚ˆã‚‹ç¹°ã‚Šä¸ŠãŒã‚Šâ€”â€”ã¨ã‚’ã€ç”Ÿæˆã™ã‚‹ã€‚
ã“ã®å›è·¯ã‚’ç”Ÿæˆã™ã‚‹ã‚ˆã†ãªã€ <tt>ripple-carry-adder</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’æ›¸ã‘ã€‚
ãã®æ‰‹ç¶šãã¯ã€å¼•æ•°ã¨ã—ã¦ã€ãã‚Œãã‚ŒãŒ<em class="en">n</em>æœ¬ã®é…ç·šã®ãƒªã‚¹ãƒˆã§ã‚ã‚‹ã‚ˆã†ãªä¸‰ã¤ã®ãƒªã‚¹ãƒˆâ€”â€”ã¤ã¾ã‚Šã€A<sub><em class="en">k</em></sub> ã¨ B<sub><em class="en">k</em></sub> ã¨ S<sub><em class="en">k</em></sub> ã®ãƒªã‚¹ãƒˆâ€”â€”ã‚’ã¨ã‚Šã€ã¾ãŸã€ã‚‚ã†1æœ¬ã® C ã¨ã„ã†é…ç·šã‚’ã¨ã‚‹ã€‚
ãƒªãƒƒãƒ—ãƒ«ãƒ»ã‚­ãƒ£ãƒªãƒ¼ãƒ»ã‚¢ãƒ€ãƒ¼ã®ä¸»ãªæ¬ ç‚¹ã¯ã€<ruby><rb>ç¹°ã‚Šä¸ŠãŒã‚Š</rb><rp> (</rp><rt>ã‚­ãƒ£ãƒªãƒ¼</rt><rp>) </rp></ruby>ä¿¡å·ãŒä¼æ’­ã™ã‚‹ã®ã‚’å¾…ã¤å¿…è¦ãŒã‚ã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚
<em class="en">n</em>ãƒ“ãƒƒãƒˆã®ãƒªãƒƒãƒ—ãƒ«ãƒ»ã‚­ãƒ£ãƒªãƒ¼ãƒ»ã‚¢ãƒ€ãƒ¼ã‹ã‚‰ã®å®Œå…¨ãªå‡ºåŠ›ã‚’å¾—ã‚‹ã®ã«å¿…è¦ãªé…å»¶ã¯ã€ANDã‚²ãƒ¼ãƒˆã¨ORã‚²ãƒ¼ãƒˆã¨ã‚¤ãƒ³ãƒãƒ¼ã‚¿ã®é…å»¶ã‚’ç”¨ã„ã¦è¡¨ç¾ã™ã‚‹ã¨ã€ã©ã®ã‚ˆã†ãªã‚‚ã®ã«ãªã‚‹ã ã‚ã†ã‹?
</p>

<a name="%_fig_3.27"></a>
<figure>
<img src="ch3-Z-G-27.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.27:</b>  A ripple-carry adder for <em>n</em>-bit numbers.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³3.27:</b> <em class="en">n</em>ãƒ“ãƒƒãƒˆã®æ•°ã®ãŸã‚ã®ãƒªãƒƒãƒ—ãƒ«ãƒ»ã‚­ãƒ£ãƒªãƒ¼ãƒ»ã‚¢ãƒ€ãƒ¼</figcaption>
</figure>

<p class="exercise"><span class="ex_comment">; å¤šåˆ†ã“ã‚“ãªæ„Ÿã˜?</span>
(define (ripple-carry-adder A B S C)
  <span class="ex_comment">; cdr ã‚’ã¨ã‚ŠãŸã„ã®ã§ä¸€å¿œãƒã‚§ãƒƒã‚¯ã—ã¦ãŠãã€‚</span>
  (if (and (pair? A) (pair? B) (pair? S))
    <span class="ex_comment">; 1è¦ç´ ã®ãƒªã‚¹ãƒˆã‹ã©ã†ã‹?</span>
    (if (and (null? (cdr A)) (null? (cdr B)) (null? (cdr S)))
        <span class="ex_comment">; 1è¦ç´ ã®ãƒªã‚¹ãƒˆãªã®ã§ã€æœ€ä¸‹ä½1ãƒ“ãƒƒãƒˆ (LSB) ã§ã®åŠ ç®—ã‚’ã—ã¦ã€ãŠã—ã¾ã„ã€‚</span>
        (let ((Cn-in (make-wire)))
             (set-signal! Cn-in 0)
             (full-adder (car A) (car B) Cn-in (car S) C))
        <span class="ex_comment">; 2è¦ç´ ä»¥ä¸Šã‚ã‚‹ã¨ãã€‚ä¸‹ä½æ¡ (LSBs) ã®ãƒªãƒƒãƒ—ãƒ«ãƒ»ã‚­ãƒ£ãƒªãƒ¼ãƒ»ã‚¢ãƒ€ãƒ¼ã«ã€æœ€ä¸Šä½æ¡ (MSB) ã®ãƒ•ãƒ«ãƒ»ã‚¢ãƒ€ãƒ¼ã‚’ã¤ãªãã€‚</span>
        (let ((c-prev-out (make-wire)))
             (ripple-carry-adder (cdr A) (cdr B) (cdr S) c-prev-out)
             (full-adder (car A) (car B) c-prev-out (car S) C)))
    <span class="ex_comment">; ã‚¨ãƒ©ãƒ¼å‡¦ç†</span>
    (error "å…¥åŠ›ãƒªã‚¹ãƒˆA, B, Sã¯åŒã˜é•·ã•ã®ãƒªã‚¹ãƒˆã«ã—ã¦ãã ã•ã„ã‚ˆ")))
</p>

<p class="exercise"><span class="ex_comment">ãƒãƒ¼ãƒ•ãƒ»ã‚¢ãƒ€ãƒ¼ã¯ã€<img src="ch3-Z-G-25.gif">ãªã®ã§ã€
Cã¾ã§ã®é…å»¶ã¯ and-gate-delay
Dã¾ã§ã®é…å»¶ã¯ or-gate-delay
Eã¾ã§ã®é…å»¶ã¯ and-gate-delay + inverter-delay
Sã¾ã§ã®é…å»¶ã¯
  max(or-gate-delay, and-gate-delay + inverter-delay) + and-gate-delay
= max(or-gate-delay + and-gate-delay, 2 * and-gate-delay + inverter-delay)
ã§ã‚ã‚‹ã€‚å¸¸ã«ã€Sã¾ã§ã®é…å»¶ã®æ–¹ãŒã€Cã¾ã§ã®é…å»¶ã‚ˆã‚Šå¤§ãã„ã€‚
ã‚ˆã£ã¦ã€Sã¾ã§ã®é…å»¶ãŒã€ãƒãƒ¼ãƒ•ãƒ»ã‚¢ãƒ€ãƒ¼å…¨ä½“ã®é…å»¶ã§ã‚ã‚‹ã€‚ã“ã‚Œã‚’ HA-delay ã¨ã™ã‚‹ã€‚

ãƒ•ãƒ«ãƒ»ã‚¢ãƒ€ãƒ¼ã¯ã€<img src="ch3-Z-G-26.gif">ãªã®ã§ã€
SUMã¾ã§ã®é…å»¶ã¯ã€2 * HA-delay ã§ã‚ã‚‹ã€‚
Coutã¾ã§ã®é…å»¶ã¯ã€ç´ æœ´ã«è€ƒãˆã‚‹ã¨ã€
  max(2 * HA-delay, HA-delay) + or-gate-delay = 2 * HA-delay + or-gate-delay
ãªã®ã ãŒã€ãƒãƒ¼ãƒ•ãƒ»ã‚¢ãƒ€ãƒ¼å…¨ä½“ã®é…å»¶ã‚ˆã‚Šã‚‚ã€ãƒãƒ¼ãƒ•ãƒ»ã‚¢ãƒ€ãƒ¼ã§ã®Cã®å‡ºåŠ›ã®é…å»¶ã®æ–¹ãŒ
çŸ­ã„ã“ã¨ã‚’è€ƒæ…®ã™ã‚‹ã¨ã€
  max(HA-delay + and-gate-delay, and-gate-delay) + or-gate-delay
= HA-delay + and-gate-delay + or-gate-delay &le; 2 * HA-delay
ã§ã‚ã‚‹ã€‚
ã¨ã„ã†ã‚ã‘ã§ã€ãƒ•ãƒ«ãƒ»ã‚¢ãƒ€ãƒ¼å…¨ä½“ã®é…å»¶ã¯ã€2 * HA-delay ã ã¨è€ƒãˆã¦ã‚ˆã„ã€‚
ã“ã‚Œã‚’ FA-delay ã¨ã™ã‚‹ã€‚

ã“ã“ã¾ã§ãŒæº–å‚™ã€‚ä»¥ä¸‹æœ¬é¡Œã€‚nãƒ“ãƒƒãƒˆã®ãƒªãƒƒãƒ—ãƒ«ãƒ»ã‚­ãƒ£ãƒªãƒ¼ãƒ»ã‚¢ãƒ€ãƒ¼ã¯ã€
<img src="ch3-Z-G-27.gif"> ã§ã‚ã‚‹ã€‚
ãªãŠã€å³ãŒã‚­ãƒ£ãƒªãƒ¼ã®å…¥åŠ›å´ã§ã€Aã€Bã€Sã®æœ€ä¸‹ä½ãƒ“ãƒƒãƒˆã€‚
å·¦ãŒã‚­ãƒ£ãƒªãƒ¼ã®å‡ºåŠ›å´ã§ã€Aã€Bã€Sã®æœ€ä¸Šä½ãƒ“ãƒƒãƒˆã€‚
ã“ã‚Œã®é…å»¶ã¯ n * FA-delay ã§ã‚ã‚‹ã€‚
ã¨ã„ã†ã‚ã‘ã§ã€
  n * FA-delay
= 2n * HA-delay
= 2n * max(or-gate-delay + and-gate-delay, 2 * and-gate-delay + inverter-delay)
ãŒã€nãƒ“ãƒƒãƒˆã®ãƒªãƒƒãƒ—ãƒ«ãƒ»ã‚­ãƒ£ãƒªãƒ¼ãƒ»ã‚¢ãƒ€ãƒ¼ã®é…å»¶ã§ã‚ã‚‹ã€‚
</span></p>


<a name="%_sec_Temp_384"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_384">Representing wires</a></h4>
<h4 class="trans" lang="ja">é…ç·šã‚’è¡¨ç¾ã™ã‚‹</h4>

<p class="orig" lang="en">
<a name="%_idx_3392"></a>
A wire in our simulation will be a computational object with two local
state variables: a <tt>signal-value</tt> (initially taken to be 0) and a
collection of <tt>action-procedures</tt> to be run when the signal
changes value.  We implement the wire, using message-passing style, as
<a name="%_idx_3394"></a>a collection of local procedures together with a <tt>dispatch</tt>
procedure that selects the appropriate local operation, just as we did
with the simple bank-account object in section
 <a href="20_sec3_1.html#%_sec_3.1.1">3.1.1</a>:</p>

<p class="trans" lang="ja">
ç§ãŸã¡ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã«ãŠã‘ã‚‹é…ç·šã¯ã€äºŒã¤ã®å±€æ‰€çŠ¶æ…‹å¤‰æ•°â€”â€”ã¤ã¾ã‚Šã€<tt>signal-value</tt> (æœ€åˆã¯0ã ã¨è¦‹ãªã•ã‚Œã‚‹) ã¨ã€ä¿¡å·ãŒå€¤ã‚’å¤‰ãˆã‚‹ã¨ãã«å®Ÿè¡Œã•ã‚Œã‚‹ã¹ã <tt>action-procedures</tt> ã®é›†ã¾ã‚Šâ€”â€”ã‚’ã‚‚ã£ãŸã€è¨ˆç®—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ãªã‚‹ã“ã¨ã ã‚ã†ã€‚
ç§ãŸã¡ã¯ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ»ãƒ‘ãƒƒã‚·ãƒ³ã‚°ã®æ§˜å¼ã‚’ä½¿ã£ã¦ã€é…ç·šã‚’ã€å±€æ‰€æ‰‹ç¶šãã®é›†ã¾ã‚Šã¨ã—ã¦ã€é©åˆ‡ãªå±€æ‰€çš„æ¼”ç®—ã‚’é¸æŠã™ã‚‹ <tt>dispatch</tt> ã¨ã„ã†æ‰‹ç¶šãã¨ã¨ã‚‚ã«ã€å®Ÿè£…ã™ã‚‹â€”â€”<a href="20_sec3_1.html#%_sec_3.1.1">3.1.1</a>ç¯€ã§ç°¡å˜ãªéŠ€è¡Œå£åº§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¤ã„ã¦ãã†ã—ãŸã®ã¨ã€ã¡ã‚‡ã†ã©åŒã˜ã‚ˆã†ã«ã€‚
</p>

<p class="lisp"><a name="%_idx_3396"></a>(define (make-wire)
  (let ((signal-value 0) (action-procedures '()))
    (define (set-my-signal! new-value)
      (if (not (= signal-value new-value))
          (begin (set! signal-value new-value)
                 (call-each action-procedures))
          'done))
    (define (accept-action-procedure! proc)
      (set! action-procedures (cons proc action-procedures))
      (proc))
    (define (dispatch m)
      (cond ((eq? m 'get-signal) signal-value)
            ((eq? m 'set-signal!) set-my-signal!)
            ((eq? m 'add-action!) accept-action-procedure!)
            (else (error &quot;Unknown operation -- WIRE&quot; m))))
    dispatch))
</p>

<p class="orig" lang="en">
The local procedure <tt>set-my-signal!</tt> tests whether the new signal
value changes the signal on the wire.  If so, it runs each of the
action procedures, using the following procedure <tt>call-each</tt>,
which calls each of the items in a list of no-argument procedures:</p>

<p class="trans" lang="ja">
<tt>set-my-signal!</tt> ã¨ã„ã†å±€æ‰€æ‰‹ç¶šãã¯ã€æ–°ãŸãªä¿¡å·å€¤ãŒãã®é…ç·šä¸Šã®ä¿¡å·ã‚’å¤‰æ›´ã™ã‚‹ã‹ã©ã†ã‹ã‚’èª¿ã¹ã‚‹ã€‚
ã‚‚ã—å¤‰æ›´ã™ã‚‹ãªã‚‰ã€ã“ã®å±€æ‰€æ‰‹ç¶šãã¯ã€å‹•ä½œæ‰‹ç¶šãã®ãã‚Œãã‚Œã‚’ã€ä»¥ä¸‹ã® <tt>call-each</tt> ã¨ã„ã†æ‰‹ç¶šãâ€”â€”å¼•æ•°ã®ãªã„æ‰‹ç¶šãã®ãƒªã‚¹ãƒˆå†…ã®é …ç›®ã®ãã‚Œãã‚Œã‚’å‘¼ã³å‡ºã™â€”â€”ã‚’ä½¿ã£ã¦ã€å®Ÿè¡Œã™ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_3398"></a>(define (call-each procedures)
  (if (null? procedures)
      'done
      (begin
        ((car procedures))
        (call-each (cdr procedures)))))
</p>

<p class="orig" lang="en">
The local procedure <tt>accept-action-procedure!</tt> adds the given
procedure to the list of procedures to be run, and then runs the new
procedure once.  (See exercise <a href="#%_thm_3.31">3.31</a>.)</p>

<p class="trans" lang="ja">
<tt>accept-action-procedure!</tt> ã¨ã„ã†å±€æ‰€æ‰‹ç¶šãã¯ã€ä¸ãˆã‚‰ã‚ŒãŸæ‰‹ç¶šãã‚’ã€å®Ÿè¡Œã™ã¹ãæ‰‹ç¶šãã®ãƒªã‚¹ãƒˆã¸ã¨ã€ä»˜ã‘åŠ ãˆã‚‹ã€‚ãã—ã¦ã€ãã®æ–°ãŸãªæ‰‹ç¶šãã‚’ã€ä¸€åº¦ã€å®Ÿè¡Œã™ã‚‹ã€‚
(ç·´ç¿’å•é¡Œ<a href="#%_thm_3.31">3.31</a>ã‚’å‚ç…§)ã€‚
</p>

<p class="orig" lang="en">
With the local <tt>dispatch</tt> procedure set up as specified, we can
provide the following procedures to access the local operations on
wires:<a name="call_footnote_Temp_385" href="#footnote_Temp_385"><sup><small>27</small></sup></a></p>

<p class="trans" lang="ja">
ä¸Šã«è¦å®šã—ãŸã‚ˆã†ã«è¨­å®šã•ã‚ŒãŸã€å±€æ‰€çš„ãª <tt>dispatch</tt> ã®æ‰‹ç¶šããŒã‚ã‚‹ã¨ã€é…ç·šã«å¯¾ã™ã‚‹å±€æ‰€çš„æ¼”ç®—ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãŸã‚ã®ä»¥ä¸‹ã®ã‚ˆã†ãªæ‰‹ç¶šãã‚’æä¾›ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_3404"></a>(define (get-signal wire)
  (wire 'get-signal))
<a name="%_idx_3406"></a>(define (set-signal! wire new-value)
  ((wire 'set-signal!) new-value))
<a name="%_idx_3408"></a>(define (add-action! wire action-procedure)
  ((wire 'add-action!) action-procedure))
</p>

<p class="orig" lang="en">
Wires, which have time-varying signals and may be incrementally
attached to devices, are typical of mutable objects.  We have modeled
them as procedures with local state variables that are modified by
assignment.  When a new wire is created, a new set of state variables
is allocated (by the <tt>let</tt> expression in <tt>make-wire</tt>) and a
new <tt>dispatch</tt> procedure is constructed and returned, capturing
the environment with the new state variables.</p>

<p class="trans" lang="ja">
é…ç·šâ€”â€”çµŒæ™‚å¤‰åŒ–ã™ã‚‹ä¿¡å·ã‚’æœ‰ã—ã¦ã„ã¦ã€ãƒ‡ãƒã‚¤ã‚¹ã«å¯¾ã—ã¦å°‘ã—ãšã¤ã€ã¤ãªã’ã‚‰ã‚Œã¦ã„ãã‹ã‚‚ã—ã‚Œãªã„â€”â€”ã¯ã€å¤‰æ›´å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å…¸å‹ã§ã‚ã‚‹ã€‚
ç§ãŸã¡ã¯ã€é…ç·šã‚’ã€<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã«ã‚ˆã‚Šä¿®æ­£ã•ã‚Œã‚‹å±€æ‰€çŠ¶æ…‹å¤‰æ•°ã‚’æŒã£ãŸæ‰‹ç¶šãã¨ã—ã¦ã€ãƒ¢ãƒ‡ãƒ«åŒ–ã—ã¦ããŸã€‚
æ–°ãŸãªé…ç·šãŒä½œæˆã•ã‚Œã‚‹ã¨ã€çŠ¶æ…‹å¤‰æ•°ã®æ–°ãŸãªä¸€å¼ãŒã€(<tt>make-wire</tt> å†…ã® <tt>let</tt>å¼ã«ã‚ˆã£ã¦) å‰²ã‚Šå½“ã¦ã‚‰ã‚Œã¦ã€æ–°ãŸãª <tt>dispatch</tt> ã®æ‰‹ç¶šãâ€”â€”â€”â€”ä¸Šè¨˜ã®æ–°ãŸãªçŠ¶æ…‹å¤‰æ•°ã‚’æœ‰ã™ã‚‹ç’°å¢ƒã‚’ã¤ã‹ã¾ãˆã¦ã„ã‚‹â€”â€”ãŒã€æ§‹ç¯‰ã•ã‚Œã¦è¿”ã•ã‚Œã‚‹ã€‚
</p>

<p class="orig" lang="en">
The wires are shared among the various devices that have been
connected to them.  Thus, a change made by an interaction with one
device will affect all the other devices attached to the wire.  The
wire communicates the change to its neighbors by calling the action
procedures provided to it when the connections were established.</p>

<p class="trans" lang="ja">
é…ç·šã¯ã€ãã‚Œã‚‰ã®é…ç·šã«æ¥ç¶šã•ã‚ŒãŸæ§˜ã€…ãªãƒ‡ãƒã‚¤ã‚¹ã®é–“ã§å…±æœ‰ã•ã‚Œã‚‹ã€‚
ã‚ˆã£ã¦ã€ä¸€ã¤ã®ãƒ‡ãƒã‚¤ã‚¹ã¨ã®ç›¸äº’ä½œç”¨ã«ã‚ˆã‚Šèµ·ããŸå¤‰åŒ–ã¯ã€ãã®é…ç·šã«ã¤ãªãŒã£ã¦ã„ã‚‹æ®‹ã‚Šã®ã™ã¹ã¦ã®ãƒ‡ãƒã‚¤ã‚¹ã«å½±éŸ¿ã™ã‚‹ã ã‚ã†ã€‚
é…ç·šã¯ã€æ¥ç¶šãŒç¢ºç«‹ã•ã‚ŒãŸã¨ãã«ãã®é…ç·šã«å¯¾ã—ã¦ä¸ãˆã‚‰ã‚ŒãŸå‹•ä½œæ‰‹ç¶šãã‚’å‘¼ã³å‡ºã™ã“ã¨ã«ã‚ˆã‚Šã€ãã®å¤‰åŒ–ã‚’ã€è‡ªèº«ã«éš£æ¥ã™ã‚‹ã‚‚ã®ã¸ã¨ä¼é”ã™ã‚‹ã€‚
</p>


<a name="%_sec_Temp_386"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_386">The agenda</a></h4>
<h4 class="trans" lang="ja">ã‚¢ã‚¸ã‚§ãƒ³ãƒ€</h4>

<p class="orig" lang="en">
<a name="%_idx_3410"></a>
The only thing needed to complete the simulator is <tt>after-delay</tt>.
The idea here is that we maintain a data structure, called an <em>agenda</em>, that contains a schedule of things to do.  The following
operations are defined for agendas:</p>

<p class="trans" lang="ja">
ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã‚’å®Œæˆã•ã›ã‚‹ã®ã«å¿…è¦ãªå”¯ä¸€ã®ã‚‚ã®ã¯ã€<tt>after-delay</tt> ã§ã‚ã‚‹ã€‚
ã“ã“ã§ã®è€ƒãˆæ–¹ã¯ã€ã‚„ã‚‹ã¹ãã“ã¨ã®è¨ˆç”»è¡¨ã‚’å«ã‚€ãƒ‡ãƒ¼ã‚¿æ§‹é€ â€”â€”<em>ã‚¢ã‚¸ã‚§ãƒ³ãƒ€</em>ã¨å‘¼ã°ã‚Œã‚‹â€”â€”ã‚’ç¶­æŒã™ã‚‹ã€ã¨ã„ã†ã‚‚ã®ã§ã‚ã‚‹ã€‚
ã‚¢ã‚¸ã‚§ãƒ³ãƒ€ã«å¯¾ã—ã¦ã€ä»¥ä¸‹ã®æ¼”ç®—ãŒå®šç¾©ã•ã‚Œã‚‹ã€‚
</p>


<ul class="orig" lang="en">
<li><a name="%_idx_3412"></a><tt>(make-agenda)</tt>
returns a new empty agenda.</li>

<li><a name="%_idx_3414"></a><tt>(empty-agenda? &lt;<em>agenda</em>&gt;)</tt>
is true if the specified agenda is empty.</li>

<li><a name="%_idx_3416"></a><tt>(first-agenda-item &lt;<em>agenda</em>&gt;)</tt>
returns the first item on the agenda.</li>

<li><a name="%_idx_3418"></a><tt>(remove-first-agenda-item! &lt;<em>agenda</em>&gt;)</tt>
modifies the agenda by removing the first item.</li>

<li><a name="%_idx_3420"></a><tt>(add-to-agenda! &lt;<em>time</em>&gt; &lt;<em>action</em>&gt; &lt;<em>agenda</em>&gt;)</tt>
modifies the agenda by adding the given action procedure to be run at
the specified time.</li>

<li><a name="%_idx_3422"></a><tt>(current-time &lt;<em>agenda</em>&gt;)</tt>
returns the current simulation time.</li>
</ul>

<ul class="trans" lang="ja">
<li><tt>(make-agenda)</tt> ã¯ã€æ–°ãŸãªç©ºã®ã‚¢ã‚¸ã‚§ãƒ³ãƒ€ã‚’è¿”ã™ã€‚</li>
<li><tt>(empty-agenda? &lt;<em class="en">agenda</em>&gt;)</tt> ã¯ã€æŒ‡å®šã•ã‚ŒãŸã‚¢ã‚¸ã‚§ãƒ³ãƒ€ãŒç©ºã®ã¨ãã€çœŸã§ã‚ã‚‹ã€‚</li>
<li><tt>(first-agenda-item &lt;<em class="en">agenda</em>&gt;)</tt> ã¯ã€ãã®ã‚¢ã‚¸ã‚§ãƒ³ãƒ€ä¸Šã®æœ€åˆã®é …ç›®ã‚’è¿”ã™ã€‚</li>
<li><tt>(remove-first-agenda-item! &lt;<em class="en">agenda</em>&gt;)</tt> ã¯ã€æœ€åˆã®é …ç›®ã‚’å–ã‚Šé™¤ãã“ã¨ã«ã‚ˆã‚Šã€ã‚¢ã‚¸ã‚§ãƒ³ãƒ€ã‚’å¤‰æ›´ã™ã‚‹ã€‚</li>
<li><tt>(add-to-agenda! &lt;<em class="en">time</em>&gt; &lt;<em class="en">action</em>&gt; &lt;<em class="en">agenda</em>&gt;)</tt> ã¯ã€æŒ‡å®šã•ã‚ŒãŸæ™‚åˆ»ã«å®Ÿè¡Œã™ã¹ãã€ä¸ãˆã‚‰ã‚ŒãŸå‹•ä½œæ‰‹ç¶šãã‚’ã€è¿½åŠ ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€ã‚¢ã‚¸ã‚§ãƒ³ãƒ€ã‚’å¤‰æ›´ã™ã‚‹ã€‚</li>
<li><tt>(current-time &lt;<em class="en">agenda</em>&gt;)</tt> ã¯ã€ç¾åœ¨ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ™‚åˆ»ã‚’è¿”ã™ã€‚</li>
</ul>

<p class="orig" lang="en">
The particular agenda that we use is denoted by
<tt>the-agenda</tt>.  The procedure <tt>after-delay</tt> adds new
elements to <tt>the-agenda</tt>:</p>

<p class="trans" lang="ja">
ç§ãŸã¡ãŒä½¿ã†ç‰¹å®šã®ã‚¢ã‚¸ã‚§ãƒ³ãƒ€ã¯ã€<tt>the-agenda</tt> ã§ç¤ºã•ã‚Œã‚‹ã€‚
<tt>after-delay</tt> ã®æ‰‹ç¶šãã¯ã€<tt>the-agenda</tt> ã«æ–°ãŸãªè¦ç´ ã‚’è¿½åŠ ã™ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_3424"></a>(define (after-delay delay action)
  (add-to-agenda! (+ delay (current-time the-agenda))
                  action
                  the-agenda))
</p>

<p class="orig" lang="en">
The simulation is driven by the procedure <tt>propagate</tt>, which
operates on <tt>the-agenda</tt>, executing each procedure on the agenda
in sequence.  In general, as the simulation runs, new items will be
added to the agenda, and <tt>propagate</tt> will continue the simulation
as long as there are items on the agenda:</p>

<p class="trans" lang="ja">
ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã¯ã€<tt>propagate</tt> ã¨ã„ã†æ‰‹ç¶šãâ€”â€” <tt>the-agenda</tt> ã«å¯¾ã—ã¦å‹•ä½œã™ã‚‹ã‚‚ã®ã§ã€ã‚¢ã‚¸ã‚§ãƒ³ãƒ€ä¸Šã®å„æ‰‹ç¶šãã‚’é †ã«å®Ÿè¡Œã™ã‚‹â€”â€”ã«ã‚ˆã£ã¦é§†å‹•ã•ã‚Œã‚‹ã€‚
ä¸€èˆ¬ã«ã€ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãŒé€²è¡Œã™ã‚‹ã«ã¤ã‚Œã¦ã€æ–°ãŸãªé …ç›®ãŒã‚¢ã‚¸ã‚§ãƒ³ãƒ€ã«è¿½åŠ ã•ã‚Œã‚‹ã ã‚ã†ã—ã€ã‚¢ã‚¸ã‚§ãƒ³ãƒ€ä¸Šã«é …ç›®ãŒã‚ã‚‹é™ã‚Šã€<tt>propagate</tt> ã¯ç¶™ç¶šã™ã‚‹ã ã‚ã†ã€‚
</p>

<p class="lisp"><a name="%_idx_3426"></a>(define (propagate)
  (if (empty-agenda? the-agenda)
      'done
      (let ((first-item (first-agenda-item the-agenda)))
        (first-item)
        (remove-first-agenda-item! the-agenda)
        (propagate))))
</p>


<a name="%_sec_Temp_387"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_387">A sample simulation</a></h4>
<h4 class="trans" lang="ja">ä¾‹ç¤ºã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³</h4>

<p class="orig" lang="en">
<a name="%_idx_3428"></a><a name="%_idx_3430"></a>
The following procedure, which places a ``probe'' on a wire, shows the
simulator in action.  The probe tells the wire that, whenever its
signal changes value, it should print the new signal value, together
with the current time and a name that identifies the wire:</p>

<p class="trans" lang="ja">
ä»¥ä¸‹ã®æ‰‹ç¶šãâ€”â€”ã€Œãƒ—ãƒ­ãƒ¼ãƒ–ã€ã‚’é…ç·šä¸Šã«ç½®ãâ€”â€”ã¯ã€ä½œå‹•ä¸­ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã‚’è¦‹ã›ã¦ãã‚Œã‚‹ã€‚
ãƒ—ãƒ­ãƒ¼ãƒ–ã¯ã€é…ç·šã«å¯¾ã—ã¦ã“ã†å‘½ä»¤ã™ã‚‹ã®ã ã€‚ã™ãªã‚ã¡ã€ãã®é…ç·šãŒå€¤ã‚’å¤‰ãˆã‚‹ã¨ãã¯ã„ã¤ã§ã‚‚ã€ãã®é…ç·šã¯ã€ç¾åœ¨æ™‚åˆ»ãŠã‚ˆã³å½“è©²é…ç·šã‚’è­˜åˆ¥ã™ã‚‹åå‰ã¨ã¨ã‚‚ã«ã€æ–°ãŸãªä¿¡å·å€¤ã‚’å°å­—ã™ã¹ãã§ã‚ã‚‹ã€ã¨ã€‚
</p>

<p class="lisp"><a name="%_idx_3432"></a>(define (probe name wire)
  (add-action! wire
               (lambda ()        
                 (newline)
                 (display name)
                 (display &quot; &quot;)
                 (display (current-time the-agenda))
                 (display &quot;  New-value = &quot;)
                 (display (get-signal wire)))))
</p>

<p class="orig" lang="en">
We begin by initializing the agenda and specifying delays for the
primitive function boxes:</p>

<p class="trans" lang="ja">
ã‚¢ã‚¸ã‚§ãƒ³ãƒ€ã‚’åˆæœŸåŒ–ã—ã¦ã€åŸå§‹çš„ãªæ©Ÿèƒ½ãƒœãƒƒã‚¯ã‚¹ã«ã¤ã„ã¦ã®é…å»¶ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ã‹ã‚‰ã€å§‹ã‚ã‚ˆã†ã€‚
</p>

<p class="lisp">(define the-agenda (make-agenda))
(define inverter-delay 2)
(define and-gate-delay 3)
(define or-gate-delay 5)
</p>

<p class="orig" lang="en">
Now we define four wires, placing probes on two of them:
</p>

<p class="trans" lang="ja">
ã“ã“ã§ã€4æœ¬ã®é…ç·šã‚’å®šç¾©ã—ã€ãã‚Œã‚‰ã®ã†ã¡ã®2æœ¬ã®ä¸Šãƒ—ãƒ­ãƒ¼ãƒ–ã‚’è¨­ç½®ã™ã‚‹ã€‚
</p>

<p class="lisp">(define input-1 (make-wire))
(define input-2 (make-wire))
(define sum (make-wire))
(define carry (make-wire))
(probe 'sum sum)
<i>sum 0  New-value = 0</i>
(probe 'carry carry)
<i>carry 0  New-value = 0</i>
</p>

<p class="orig" lang="en">
Next we connect the wires in a half-adder circuit (as in
figure <a href="#%_fig_3.25">3.25</a>), set the signal on <tt>input-1</tt> to 1,
and run the simulation:
</p>

<p class="trans" lang="ja">
æ¬¡ã«ã€ã“ã‚Œã‚‰ã®é…ç·šã‚’ (å›³<a href="#%_fig_3.25">3.25</a>ã®ã‚ˆã†ã«) ãƒãƒ¼ãƒ•ãƒ»ã‚¢ãƒ€ãƒ¼å›è·¯ã«æ¥ç¶šã—ã€<tt>input-1</tt> ä¸Šã®ä¿¡å·ã‚’1ã«è¨­å®šã—ã€ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œã™ã‚‹ã€‚
</p>

<p class="lisp">(half-adder input-1 input-2 sum carry)
<i>ok</i>
(set-signal! input-1 1)
<i>done</i>
(propagate)
<i>sum 8  New-value = 1</i>
<i>done</i>
</p>

<p class="orig" lang="en">
The <tt>sum</tt> signal changes to 1 at time 8.  We are now eight time
units from the beginning of the simulation.  At this point, we can set
the signal on <tt>input-2</tt> to 1 and allow the values to propagate:
</p>

<p class="trans" lang="ja">
<tt>sum</tt> ã¨ã„ã†ä¿¡å·ã¯ã€æ™‚åˆ»8ã«ãŠã„ã¦ã€1ã«å¤‰åŒ–ã™ã‚‹ã€‚
ç§ãŸã¡ã¯ä»Šã€ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®é–‹å§‹ã‹ã‚‰ã€æ™‚é–“å˜ä½ã®8å€‹ã¶ã‚“ã ã‘å¾Œã«å±…ã‚‹ã®ã ã€‚
ã“ã®æ™‚ç‚¹ã§ã€ç§ãŸã¡ã¯ã€<tt>input-2</tt> ä¸Šã®ä¿¡å·ã‚’1ã«è¨­å®šã™ã‚‹ã“ã¨ãŒã§ãã€ãã®å€¤ã‚’ä¼æ’­ã•ã›ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
</p>

<p class="lisp">(set-signal! input-2 1)
<i>done</i>
(propagate)
<i>carry 11  New-value = 1</i>
<i>sum 16  New-value = 0</i>
<i>done</i>
</p>

<p class="orig" lang="en">
The <tt>carry</tt> changes to 1 at time 11 and the <tt>sum</tt> changes to 0
at time 16.</p>

<p class="trans" lang="ja">
<tt>carry</tt> ã¯ã€æ™‚åˆ»11ã«ãŠã„ã¦ã€1ã«å¤‰åŒ–ã™ã‚‹ã€‚ãã—ã¦ã€<tt>sum</tt> ã¯ã€æ™‚åˆ»16ã«ãŠã„ã¦ã€0ã«å¤‰åŒ–ã™ã‚‹ã€‚
</p>

<p class="orig" lang="en">
<a name="%_thm_3.31"></a>
<b>Exercise 3.31.</b>  
<a name="%_idx_3434"></a>The internal procedure <tt>accept-action-procedure!</tt> defined in <tt>make-wire</tt> specifies that when a new action procedure is added to
a wire, the procedure is immediately run.  Explain why this initialization
is necessary.  In particular, trace through the half-adder example in
the paragraphs above and say how the system's response would differ if
we had defined <tt>accept-action-procedure!</tt> as
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.31.</b> <tt>make-wire</tt> ã®ä¸­ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ <tt>accept-action-procedure!</tt> ã¨ã„ã†å†…éƒ¨æ‰‹ç¶šãã¯ã€é…ç·šã«å¯¾ã—ã¦æ–°ãŸãªå‹•ä½œãŒè¿½åŠ ã•ã‚ŒãŸã‚‰ã€ãã®æ‰‹ç¶šãã‚’ã™ãã•ã¾å®Ÿè¡Œã™ã‚‹ã€ã¨è¦å®šã—ã¦ã„ã‚‹ã€‚
ãªãœã“ã®ã‚ˆã†ãªåˆæœŸåŒ–ãŒå¿…è¦ãªã®ã‹ã‚’ã€èª¬æ˜ã›ã‚ˆã€‚
ç‰¹ã«ã€ä¸Šè¨˜æ®µè½ã«ãŠã‘ã‚‹ãƒãƒ¼ãƒ•ãƒ»ã‚¢ãƒ€ãƒ¼ã®ä¾‹ã‚’é€šã˜ã¦ãƒˆãƒ¬ãƒ¼ã‚¹ã›ã‚ˆã€‚ãã—ã¦ã€ã‚‚ã—ä»¥ä¸‹ã®ã‚ˆã†ã« <tt>accept-action-procedure!</tt> ã‚’å®šç¾©ã—ã¦ã„ãŸã¨ã—ãŸã‚‰ã€ã‚·ã‚¹ãƒ†ãƒ ã®å¿œç­”ãŒã©ã®ã‚ˆã†ã«ç•°ãªã£ã¦ã„ãŸã ã‚ã†ã‹ã€ã¨ã„ã†ã“ã¨ã‚’è¿°ã¹ã‚ˆã€‚
</p>

<p class="lisp">(define (accept-action-procedure! proc)
  (set! action-procedures (cons proc action-procedures)))
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_Temp_389"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_389">Implementing the agenda</a></h4>
<h4 class="trans" lang="ja">ã‚¢ã‚¸ã‚§ãƒ³ãƒ€ã‚’å®Ÿè£…ã™ã‚‹</h4>


<p class="orig" lang="en">
<a name="%_idx_3436"></a>
Finally, we give details of the agenda data structure, which holds the
procedures that are scheduled for future execution.</p>

<p class="trans" lang="ja">
æœ€å¾Œã«ã€ã‚¢ã‚¸ã‚§ãƒ³ãƒ€ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ â€”â€”å°†æ¥ã®å®Ÿè¡Œã®ãŸã‚ã«äºˆå®šã•ã‚Œã¦ã„ã‚‹è«¸æ‰‹ç¶šãã‚’ä¿æŒã™ã‚‹â€”â€”ã®è©³ç´°ã‚’è¿°ã¹ã‚‹ã€‚
</p>

<p class="orig" lang="en">
The agenda is made up of <a name="%_idx_3438"></a><em>time segments</em>.  Each time segment is a
pair consisting of a number (the time) and a <a name="%_idx_3440"></a>queue (see
exercise <a href="#%_thm_3.32">3.32</a>) that holds the procedures that are
scheduled to be run during that time segment.</p>

<p class="trans" lang="ja">
ã‚¢ã‚¸ã‚§ãƒ³ãƒ€ã¯ã€ã„ãã¤ã‹ã®<em>æ™‚é–“åŒºåˆ†</em>ã‹ã‚‰ãªã£ã¦ã„ã‚‹ã€‚
ãã‚Œãã‚Œã®æ™‚é–“åŒºåˆ†ã¯ã€æ•° (æ™‚åˆ») ã¨ã€ãã®æ™‚é–“åŒºåˆ†ã®é–“ã«å®Ÿè¡Œã™ã¹ãäºˆå®šã•ã‚Œã¦ã„ã‚‹æ‰‹ç¶šãã‚’ä¿æŒã™ã‚‹ã‚­ãƒ¥ãƒ¼ (ç·´ç¿’å•é¡Œ<a href="#%_thm_3.32">3.32</a>ã‚’å‚ç…§) ã¨ã‹ã‚‰æ§‹æˆã•ã‚Œã‚‹ã€å¯¾ã§ã‚ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_3442"></a>(define (make-time-segment time queue)
  (cons time queue))
<a name="%_idx_3444"></a>(define (segment-time s) (car s))
<a name="%_idx_3446"></a>(define (segment-queue s) (cdr s))
</p>

<p class="orig" lang="en">
We will operate on the time-segment queues using the queue operations
described in section <a href="#%_sec_3.3.2">3.3.2</a>.</p>

<p class="trans" lang="ja">
<a href="#%_sec_3.3.2">3.3.2</a>ç¯€ã§èª¬æ˜ã—ãŸã‚­ãƒ¥ãƒ¼æ¼”ç®—ã‚’ä½¿ã£ã¦ã€æ™‚é–“åŒºåˆ†ã®ã‚­ãƒ¥ãƒ¼ã«å¯¾ã—ã¦æ“ä½œã‚’è¡ŒãŠã†ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_3448"></a>The agenda itself is a one-dimensional table of time segments.  It
differs from the tables described in section <a href="#%_sec_3.3.3">3.3.3</a> in that
the segments will be sorted in order of increasing time.  In addition,
we store the <a name="%_idx_3450"></a><em>current time</em> (i.e., the time of the last action
that was processed) at the head of the agenda.  A newly constructed
agenda has no time segments and has a current time of 0:<a name="call_footnote_Temp_390" href="#footnote_Temp_390"><sup><small>28</small></sup></a></p>

<p class="trans" lang="ja">
ã‚¢ã‚¸ã‚§ãƒ³ãƒ€è‡ªä½“ã¯ã€æ™‚é–“åŒºåˆ†ã®ä¸€æ¬¡å…ƒãƒ†ãƒ¼ãƒ–ãƒ«ã§ã‚ã‚‹ã€‚
ã“ã‚Œã¯ã€å¢—åŠ ã—ã¦ã‚†ãæ™‚é–“ã®é †åºã«ã—ãŸãŒã£ã¦åŒºåˆ†ãŒæ ¼ç´ã•ã‚Œã‚‹ã ã‚ã†ã€ã¨ã„ã†ç‚¹ã«ãŠã„ã¦ã€<a href="#%_sec_3.3.3">3.3.3</a>ç¯€ã§èª¬æ˜ã—ãŸãƒ†ãƒ¼ãƒ–ãƒ«ã¨ã¯ç•°ãªã‚‹ã€‚
ã•ã‚‰ã«ã€<em>ç¾åœ¨æ™‚åˆ»</em> (ã™ãªã‚ã¡ã€å‡¦ç†æ¸ˆã¿ã®æœ€å¾Œã®å‹•ä½œã®æ™‚åˆ») ã‚’ã€ã‚¢ã‚¸ã‚§ãƒ³ãƒ€ã®å…ˆé ­ã«æ ¼ç´ã™ã‚‹ã€‚
æ–°ãŸã«æ§‹ç¯‰ã•ã‚ŒãŸã‚¢ã‚¸ã‚§ãƒ³ãƒ€ã¯ã€æ™‚é–“åŒºåˆ†ã‚’æœ‰ã—ã¦ãŠã‚‰ãšã€0 ã¨ã„ã†ç¾åœ¨æ™‚åˆ»ã‚’æœ‰ã™ã‚‹<a  href="#footnote_Temp_390"><sup><small>28</small></sup></a>ã€‚
</p>

<p class="lisp"><a name="%_idx_3456"></a>(define (make-agenda) (list 0))
<a name="%_idx_3458"></a>(define (current-time agenda) (car agenda))
<a name="%_idx_3460"></a>(define (set-current-time! agenda time)
  (set-car! agenda time))
<a name="%_idx_3462"></a>(define (segments agenda) (cdr agenda))
<a name="%_idx_3464"></a>(define (set-segments! agenda segments)
  (set-cdr! agenda segments))
<a name="%_idx_3466"></a>(define (first-segment agenda) (car (segments agenda)))
<a name="%_idx_3468"></a>(define (rest-segments agenda) (cdr (segments agenda)))
</p>

<p class="orig" lang="en">
An agenda is empty if it has no time segments:
</p>

<p class="trans" lang="ja">
æ™‚é–“åŒºåˆ†ãŒãªã„ã¨ãã€ã‚¢ã‚¸ã‚§ãƒ³ãƒ€ã¯ç©ºã§ã‚ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_3470"></a>(define (empty-agenda? agenda)
  (null? (segments agenda)))
</p>

<p class="orig" lang="en">
To add an action to an agenda, we first check if the agenda is empty.
If so, we create a time segment for the action and install this in
the agenda.  Otherwise, we scan the agenda, examining the time of each
segment.  If we find a segment for our appointed time, we add the
action to the associated queue.  If we reach a time later than the one
to which we are appointed, we insert a new time segment into the
agenda just before it.  If we reach the end of the agenda, we must
create a new time segment at the end.
</p>

<p class="trans" lang="ja">
ã‚¢ã‚¸ã‚§ãƒ³ãƒ€ã«å‹•ä½œã‚’è¿½åŠ ã™ã‚‹ã«ã¯ã€ã¾ãšã€ã‚¢ã‚¸ã‚§ãƒ³ãƒ€ãŒç©ºã‹ã©ã†ã‹ã‚’èª¿ã¹ã‚‹ã€‚
ã‚‚ã—ãã†ãªã‚‰ã€ãã®å‹•ä½œç”¨ã®æ–°ãŸãªæ™‚é–“åŒºåˆ†ã‚’ä½œæˆã—ã€ã“ã‚Œã‚’ã‚¢ã‚¸ã‚§ãƒ³ãƒ€ã«çµ„ã¿è¾¼ã‚€ã€‚
ãã†ã§ãªã„å ´åˆã¯ã€å„åŒºåˆ†ã®æ™‚åˆ»ã‚’æ¤œæŸ»ã—ãªãŒã‚‰ã€ã‚¢ã‚¸ã‚§ãƒ³ãƒ€ã‚’èµ°æŸ»ã™ã‚‹ã€‚
ã‚‚ã—ã€æŒ‡å®šã•ã‚ŒãŸæ™‚åˆ»ã®åŒºåˆ†ã‚’è¦‹ã¤ã‘ãŸã‚‰ã€ãã‚Œã«é–¢é€£ã¥ã‘ã‚‰ã‚ŒãŸã‚­ãƒ¥ãƒ¼ã«å½“è©²å‹•ä½œã‚’è¿½åŠ ã™ã‚‹ã€‚
ã‚‚ã—ã€æŒ‡å®šã•ã‚ŒãŸæ™‚åˆ»ã‚ˆã‚Šã‚‚é…ã„æ™‚åˆ»ã«åˆ°é”ã—ãŸã‚‰ã€ãã®æ™‚åˆ»ã®ç›´å‰ã«ãŠã„ã¦ã€æ–°ãŸãªæ™‚é–“åŒºåˆ†ã‚’ã‚¢ã‚¸ã‚§ãƒ³ãƒ€ã«æŒ¿å…¥ã™ã‚‹ã€‚
ã‚‚ã—ã€ã‚¢ã‚¸ã‚§ãƒ³ãƒ€ã®æœ«å°¾ã«åˆ°é”ã—ãŸã‚‰ã€æœ«å°¾ã«ã€æ–°ãŸãªæ™‚é–“åŒºåˆ†ã‚’ä½œæˆã›ã­ã°ãªã‚‰ãªã„ã€‚
</p>

<p class="lisp"><a name="%_idx_3472"></a>(define (add-to-agenda! time action agenda)
  (define (belongs-before? segments)
    (or (null? segments)
        (&lt; time (segment-time (car segments)))))
  (define (make-new-time-segment time action)
    (let ((q (make-queue)))
      (insert-queue! q action)
      (make-time-segment time q)))
  (define (add-to-segments! segments)
    (if (= (segment-time (car segments)) time)
        (insert-queue! (segment-queue (car segments))
                       action)
        (let ((rest (cdr segments)))
          (if (belongs-before? rest)
              (set-cdr!
               segments
               (cons (make-new-time-segment time action)
                     (cdr segments)))
              (add-to-segments! rest)))))
  (let ((segments (segments agenda)))
    (if (belongs-before? segments)
        (set-segments!
         agenda
         (cons (make-new-time-segment time action)
               segments))
        (add-to-segments! segments))))
</p>

<p class="orig" lang="en">
The procedure that removes the first item from the agenda deletes the
item at the front of the queue in the first time segment.  If this
deletion makes the time segment empty, we remove it from the list of
segments:<a name="call_footnote_Temp_391" href="#footnote_Temp_391"><sup><small>29</small></sup></a></p>

<p class="trans" lang="ja">
ã‚¢ã‚¸ã‚§ãƒ³ãƒ€ã‹ã‚‰æœ€åˆã®é …ç›®ã‚’å–ã‚Šé™¤ãæ‰‹ç¶šãã¯ã€æœ€åˆã®æ™‚é–“åŒºåˆ†ã«ãŠã„ã¦ã‚­ãƒ¥ãƒ¼ã®å…ˆé ­ã«ã‚ã‚‹é …ç›®ã‚’ã€å‰Šé™¤ã™ã‚‹ã€‚
ã‚‚ã—ã€ã“ã®å‰Šé™¤ã«ã‚ˆã£ã¦æ™‚é–“åŒºåˆ†ãŒç©ºã«ãªã‚‹ãªã‚‰ã€ãã®æ™‚é–“åŒºåˆ†ã‚’ã€åŒºåˆ†ã®ãƒªã‚¹ãƒˆã‹ã‚‰å–ã‚Šé™¤ã<a href="#footnote_Temp_391"><sup><small>29</small></sup></a>ã€‚
</p>

<p class="lisp"><a name="%_idx_3478"></a>(define (remove-first-agenda-item! agenda)
  (let ((q (segment-queue (first-segment agenda))))
    (delete-queue! q)
    (if (empty-queue? q)
        (set-segments! agenda (rest-segments agenda)))))
</p>

<p class="orig" lang="en">
The first agenda item is found at the head of the queue in the first
time segment.  Whenever we extract an item, we also update the current
time:<a name="call_footnote_Temp_392" href="#footnote_Temp_392"><sup><small>30</small></sup></a></p>

<p class="trans" lang="ja">
æœ€åˆã®ã‚¢ã‚¸ã‚§ãƒ³ãƒ€é …ç›®ã¯ã€æœ€åˆã®æ™‚é–“åŒºåˆ†ã®ã‚­ãƒ¥ãƒ¼ã®å…ˆé ­ã§è¦‹ã¤ã‹ã‚‹ã€‚
é …ç›®ã‚’æŠœãå‡ºã™ã¨ãã¯ã„ã¤ã§ã‚‚ã€ç¾åœ¨æ™‚åˆ»ã‚‚æ›´æ–°ã™ã‚‹<a href="#footnote_Temp_392"><sup><small>30</small></sup></a>ã€‚
</p>

<p class="lisp"><a name="%_idx_3480"></a>(define (first-agenda-item agenda)
  (if (empty-agenda? agenda)
      (error &quot;Agenda is empty -- FIRST-AGENDA-ITEM&quot;)
      (let ((first-seg (first-segment agenda)))
        (set-current-time! agenda (segment-time first-seg))
        (front-queue (segment-queue first-seg)))))
</p>

<p class="orig" lang="en">
<a name="%_thm_3.32"></a>
<b>Exercise 3.32.</b>  The procedures to be run during each time segment of the agenda are
kept in a queue.  Thus, the procedures for each segment are called in
the order in which they were added to the agenda (first in, first
out).  Explain why this order must be used.  In particular, trace the
behavior of an and-gate whose inputs change from 0,1 to 1,0 in the
same segment and say how the behavior would differ if we stored a
segment's procedures in an ordinary list, adding and removing
procedures only at the front (last in, first out).
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.32.</b> ã‚¢ã‚¸ã‚§ãƒ³ãƒ€ã®ãã‚Œãã‚Œã®æ™‚é–“åŒºåˆ†ã®é–“ã«å®Ÿè¡Œã™ã¹ãæ‰‹ç¶šãã¯ã€ã‚­ãƒ¥ãƒ¼ã®ä¸­ã«ä¿æŒã•ã‚Œã¦ã„ã‚‹ã€‚
ã‚ˆã£ã¦ã€å„åŒºåˆ†ã«ã¤ã„ã¦ã®æ‰‹ç¶šãã¯ã€ãã‚Œã‚‰ã®æ‰‹ç¶šããŒã‚¢ã‚¸ã‚§ãƒ³ãƒ€ã«è¿½åŠ ã•ã‚ŒãŸé †åºã§ã€å‘¼ã³å‡ºã•ã‚Œã‚‹ (æœ€åˆã«å…¥ã£ãŸã‚‚ã®ãŒæœ€åˆã«å‡ºã¦ã„ã)ã€‚
ãªãœã“ã®é †åºãŒä½¿ã‚ã‚Œãªãã¦ã¯ãªã‚‰ãªã„ã®ã‹ã€èª¬æ˜ã›ã‚ˆã€‚
ç‰¹ã«ã€åŒã˜åŒºåˆ†å†…ã«ãŠã„ã¦å…¥åŠ›ãŒ0ã¨1ã‹ã‚‰1ã¨0ã¸å¤‰åŒ–ã™ã‚‹ã‚ˆã†ãªANDã‚²ãƒ¼ãƒˆã®æŒ¯ã‚‹èˆã„ã‚’ãƒˆãƒ¬ãƒ¼ã‚¹ã›ã‚ˆã€‚ãã—ã¦ã€ã‚‚ã—åŒºåˆ†ã®æ‰‹ç¶šãã‚’é€šå¸¸ã®ãƒªã‚¹ãƒˆã§è¨˜æ†¶ã—ã¦ã„ãŸã¨ã—ãŸã‚‰â€”â€”ã¤ã¾ã‚Šã€å…ˆé ­ã«ãŠã„ã¦ã ã‘ã€æ‰‹ç¶šãã‚’è¿½åŠ ã—ãŸã‚Šå–ã‚Šé™¤ã„ãŸã‚Šã—ã¦ã„ãŸãªã‚‰ (æœ€å¾Œã«å…¥ã£ãŸã‚‚ã®ãŒæœ€åˆã«å‡ºã¦ã„ã)â€”â€”ãã®æŒ¯ã‚‹èˆã„ãŒã©ã†ç•°ãªã£ã¦ã„ãŸã‹ã€è¿°ã¹ã‚ˆã€‚
</p>


<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_3.3.5"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_3.3.5">3.3.5  Propagation of Constraints</a></h3>
<h3 class="trans" lang="ja">3.3.5 åˆ¶ç´„ã®ä¼æ’­</h3>


<p class="orig" lang="en">
<a name="%_idx_3482"></a><a name="%_idx_3484"></a>
Computer programs are traditionally organized as
one-directional computations, which perform operations on prespecified
arguments to produce desired outputs.  On the other hand, we often
model systems in terms of relations among quantities.  For example, a
mathematical model of a mechanical structure might include the
information that the deflection <em>d</em> of a metal rod is related to the
force <em>F</em> on the rod, the length <em>L</em> of the rod, the cross-sectional
area <em>A</em>, and the elastic modulus <em>E</em> via the equation
</p>

<p class="trans" lang="ja">
ä¼çµ±çš„ã«ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€ä¸€æ–¹å‘ã®è¨ˆç®—â€”â€”äºˆã‚æŒ‡å®šã•ã‚ŒãŸå¼•æ•°ã«å¯¾ã™ã‚‹æ¼”ç®—ã‚’è¡Œã„ã€æ‰€æœ›ã®å‡ºåŠ›ã‚’ç”Ÿã¿å‡ºã™â€”â€”ã¨ã—ã¦ã€çµ„ç¹”åŒ–ã•ã‚Œã‚‹ã€‚
ä»–æ–¹ã€ç§ãŸã¡ã¯ã‚ˆãã€é‡ã¨é‡ã®é–“ã®é–¢ä¿‚ã®è¦³ç‚¹ã‹ã‚‰ã€<ruby><rb>ç³»</rb><rp> (</rp><rt>ã‚·ã‚¹ãƒ†ãƒ </rt><rp>) </rp></ruby>ã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã™ã‚‹ã€‚
ãŸã¨ãˆã°ã€é‡‘å±æ£’ã®å¤‰ä½ <em class="en">d</em> ã¯ã€æ£’ã«ã‹ã‹ã‚‹åŠ› <em class="en">F</em> ã¨æ£’ã®é•·ã• <em class="en">L</em> ã¨æ–­é¢ç© <em class="en">A</em> ã¨å¼¾æ€§ä¿‚æ•° <em class="en">E</em>ã«é–¢ä¿‚ã—ã¦ã„ã‚‹ã€ã¨ã„ã†æƒ…å ±ã‚’ã€æ©Ÿæ¢°çš„æ§‹é€ ã®æ•°å­¦çš„ãƒ¢ãƒ‡ãƒ«ãŒã€ä»¥ä¸‹ã®å¼ã‚’é€šã˜ã¦ã€å«ã‚“ã§ã„ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚
</p>

<figure><img src="ch3-Z-G-28.gif" border="0"></figure>

<p class="orig" lang="en">
Such an equation is not one-directional.  Given any four of the
quantities, we can use it to compute the fifth.  Yet translating the
equation into a traditional computer language would force us to choose
one of the quantities to be computed in terms of the other four.
Thus, a procedure for computing the area <em>A</em> could not be used to
compute the deflection <em>d</em>, even though the computations of <em>A</em> and
<em>d</em> arise from the same equation.<a name="call_footnote_Temp_394" href="#footnote_Temp_394"><sup><small>31</small></sup></a></p>

<p class="trans" lang="ja">
ã“ã†ã„ã†å¼ã¯ã€ä¸€æ–¹å‘çš„ã§ã¯ãªã„ã€‚
ã“ã‚Œã‚‰ã®æ•°é‡ã®ã†ã¡ã®ä»»æ„ã®å››ã¤ãŒä¸ãˆã‚‰ã‚Œã‚‹ã¨ã€ãã‚Œã‚’ä½¿ã£ã¦äº”ç•ªç›®ã®æ•°é‡ã‚’è¨ˆç®—ã§ãã‚‹ã€‚
å¼ã‚’ä¼çµ±çš„ãªã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿è¨€èªã«ç§»ã—å¤‰ãˆã‚‹ã“ã¨ã‚‚ã‚„ã¯ã‚Šã€æ®‹ã‚Šã®å››ã¤ã®æ•°é‡ã‚’ä½¿ã£ã¦è¨ˆç®—ã™ã¹ãæ•°é‡ã®ã†ã¡ã®ä¸€ã¤ã‚’é¸ã¶ã“ã¨ã‚’ã€ç§ãŸã¡ã«å¼·ã„ã‚‹ã®ã§ã‚ã‚‹ã€‚
ã‚ˆã£ã¦ã€<em class="en">A</em> ã¨ <em class="en">d</em> ã®è¨ˆç®—ãŒåŒã˜å¼ã‹ã‚‰ç”Ÿã˜ã¦ã„ã¦ã•ãˆã€é¢ç© <em class="en">A</em> ã‚’è¨ˆç®—ã™ã‚‹ãŸã‚ã®æ‰‹ç¶šãã¯ã€å¤‰ä½ <em class="en">d</em> ã‚’è¨ˆç®—ã™ã‚‹ã®ã«ã¯ä½¿ãˆãªã„ã ã‚ã†<a href="#footnote_Temp_394"><sup><small>31</small></sup></a>ã€‚</p>

<p class="orig" lang="en">
<a name="%_idx_3508"></a>In this section, we sketch the design of a language that enables us to
work in terms of relations themselves.  The primitive elements of the
language are <a name="%_idx_3510"></a><a name="%_idx_3512"></a><em>primitive constraints</em>, which state that certain
relations hold between quantities.  For example, <tt>(adder a b c)</tt>
specifies that the quantities <em>a</em>, <em>b</em>, and <em>c</em> must be related by the
equation <em>a</em> + <em>b</em> = <em>c</em>, <tt>(multiplier x y z)</tt> expresses the constraint
<em>x</em><em>y</em>  =  <em>z</em>, and <tt>(constant 3.14 x)</tt> says that the value of <em>x</em> must
be 3.14.</p>

<p class="trans" lang="ja">
é–¢ä¿‚ãã®ã‚‚ã®ã‚’ä½¿ã£ã¦ä½œæ¥­ã§ãã‚‹ã‚ˆã†ã«ã—ã¦ãã‚Œã‚‹è¨€èªã®è¨­è¨ˆã«ã¤ã„ã¦ã€æœ¬ç¯€ã§æ¦‚ç•¥ã‚’è¿°ã¹ã‚‹ã€‚
ãã®è¨€èªã®åŸå§‹çš„ãªè¦ç´ ã¯ã€<em>åŸå§‹çš„åˆ¶ç´„</em>ã§ã‚ã‚Šã€ãã‚Œã¯ã€é‡ã¨é‡ã®é–“ã«ã€ã‚ã‚‹é–¢ä¿‚ãŒæˆã‚Šç«‹ã¤ã€ã¨è¿°ã¹ã‚‹ã‚‚ã®ã§ã‚ã‚‹ã€‚
ãŸã¨ãˆã°ã€<tt>(adder a b c)</tt> ã¯ã€
<em class="en">a</em> ã¨ <em class="en">b</em> ã¨ <em class="en">c</em> ã¨ã„ã†æ•°é‡åŒå£«ãŒ 
<span class="math"><em class="en">a</em> + <em class="en">b</em> = <em class="en">c</em></span>
ã¨ã„ã†å¼ã«ã‚ˆã‚Šé–¢é€£ã¥ã‘ã‚‰ã‚Œã­ã°ãªã‚‰ãªã„ã€ã¨è¦å®šã—ã¦ãŠã‚Šã€
<tt>(multiplier x y z)</tt> ã¯ã€
<span class="math"><em class="en">xy</em>  =  <em class="en">z</em></span>
ã¨ã„ã†åˆ¶ç´„ã‚’è¡¨ã—ã¦ãŠã‚Šã€
<tt>(constant 3.14 x)</tt> ã¯ã€
<em class="en">x</em> ã®å€¤ãŒ3.14ã§ãªãã¦ã¯ãªã‚‰ãªã„ã€ã¨è¿°ã¹ã¦ã„ã‚‹ã€‚
</p>

<p class="orig" lang="en">
Our language provides a means of combining primitive constraints in
order to express more complex relations.  We combine constraints by
constructing <a name="%_idx_3514"></a><em>constraint networks</em>, in which constraints are
joined by <a name="%_idx_3516"></a><em>connectors</em>.  A connector is an object that ``holds'' a
value that may participate in one or more constraints.  For example,
we know that the relationship between Fahrenheit and Celsius
temperatures is</p>

<p class="trans" lang="ja">
ç§ãŸã¡ã®è¨€èªã¯ã€ã‚ˆã‚Šè¤‡é›‘ãªé–¢ä¿‚ã‚’è¡¨ç¾ã™ã‚‹ãŸã‚ã«åŸå§‹çš„ãªåˆ¶ç´„åŒå£«ã‚’çµåˆã™ã‚‹æ‰‹æ®µã‚’ã€æä¾›ã—ã¦ã„ã‚‹ã€‚
ç§ãŸã¡ã¯ã€<em>åˆ¶ç´„ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯</em>â€”â€”ãã®ä¸­ã§åˆ¶ç´„åŒå£«ã¯<em>ã‚³ãƒã‚¯ã‚¿</em>ã«ã‚ˆã‚Šã¤ãªãŒã‚Œã‚‹â€”â€”ã‚’æ§‹ç¯‰ã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€åˆ¶ç´„åŒå£«ã‚’çµåˆã™ã‚‹ã€‚
ã‚³ãƒã‚¯ã‚¿ã¯ã€ä¸€ã¤ä»¥ä¸Šã®åˆ¶ç´„ã«é–¢ä¸ã™ã‚‹å¯èƒ½æ€§ã®ã‚ã‚‹å€¤ã‚’ã€Œä¿æŒã€ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚‹ã€‚
ãŸã¨ãˆã°ã€è¯æ°æ¸©åº¦ã¨æ‘‚æ°æ¸©åº¦ã®é–¢ä¿‚ãŒä»¥ä¸‹ã®ã¨ãŠã‚Šã§ã‚ã‚‹ã“ã¨ã‚’ã€ç§ãŸã¡ã¯çŸ¥ã£ã¦ã„ã‚‹ã€‚
</p>

<figure><img src="ch3-Z-G-29.gif" border="0"></figure>

<p class="orig" lang="en">
Such a constraint can be thought of as a network consisting of
primitive adder, multiplier, and constant constraints
(figure <a href="#%_fig_3.28">3.28</a>).  In the figure, we see on the left a
multiplier box with three terminals, labeled <em>m</em>1, <em>m</em>2, and <em>p</em>.
These connect the multiplier to the rest of the network as follows:
The <em>m</em>1 terminal is linked to a connector <em>C</em>, which will hold the
Celsius temperature.  The <em>m</em>2 terminal is linked to a connector
<em>w</em>, which is also linked to a constant box that holds 9.  The <em>p</em>
terminal, which the multiplier box constrains to be the product of
<em>m</em>1 and <em>m</em>2, is linked to the <em>p</em> terminal
of another multiplier box, whose <em>m</em>2 is connected to a constant 5 and
whose <em>m</em>1 is connected to one of the terms in a sum.</p>

<p class="trans" lang="ja">
ã“ã†ã„ã†åˆ¶ç´„ã¯ã€åŸå§‹çš„ãªåŠ ç®—å™¨ã¨ä¹—ç®—å™¨ã¨å®šæ•°åˆ¶ç´„ã¨ã‹ã‚‰æ§‹æˆã•ã‚Œã‚‹ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã ã¨è¦‹ãªã›ã‚‹ (å›³<a href="#%_fig_3.28">3.28</a>)ã€‚
ã“ã®å›³ã§ã€ç§ãŸã¡ã¯ã€ä¸‰ã¤ã®ç«¯å­â€”â€”<em class="en">m</em>1ã€<em class="en">m</em>2ã€<em class="en">p</em> ã¨ãƒ©ãƒ™ãƒ«ä»˜ã‘ã•ã‚Œã¦ã„ã‚‹â€”â€”ã®ã‚ã‚‹ä¹—ç®—å™¨ãƒœãƒƒã‚¯ã‚¹ã‚’å·¦å´ã«è¦‹ã¦ã„ã‚‹ã€‚
ã“ã‚Œã‚‰ã®ç«¯å­ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¦ã€ä¹—ç®—å™¨ã‚’ã€ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã®æ®‹ã‚Šã®éƒ¨åˆ†ã¸ã¨æ¥ç¶šã™ã‚‹ã€‚
<em class="en">m</em>1 ã®ç«¯å­ã¯ã€<em class="en">C</em> ã¨ã„ã†ã‚³ãƒã‚¯ã‚¿â€”â€”æ‘‚æ°æ¸©åº¦ã‚’ä¿æŒã™ã‚‹ã“ã¨ã«ãªã‚‹ã ã‚ã†â€”â€”ã«ã¤ãªãŒã‚Œã‚‹ã€‚
<em class="en">m</em>2 ã®ç«¯å­ã¯ã€<em class="en">w</em> ã¨ã„ã†ã‚³ãƒã‚¯ã‚¿ã«ã¤ãªãŒã‚Œã€ã“ã®ã‚³ãƒã‚¯ã‚¿ã‚‚ã€9ã‚’ä¿æŒã™ã‚‹å®šæ•°ãƒœãƒƒã‚¯ã‚¹ã¸ã¨ã¤ãªãŒã‚Œã‚‹ã€‚
<em class="en">p</em> ã¨ã„ã†ç«¯å­â€”â€” <em class="en">m</em>1 ã¨ <em class="en">m</em>2 ã®ç©ã§ã‚ã‚‹ã€ã¨ä¹—ç®—å™¨ãƒœãƒƒã‚¯ã‚¹ãŒåˆ¶ç´„ã—ã¦ã„ã‚‹â€”â€”ã¯ã€ã‚‚ã†ä¸€ã¤ã®ä¹—ç®—å™¨ãƒœãƒƒã‚¯ã‚¹â€”â€”ãã® <em class="en">m</em>2 ã¯5ã¨ã„ã†å®šæ•°ã«æ¥ç¶šã•ã‚Œã€ãã® <em class="en">m</em>1 ã¯ã€ã¨ã‚ã‚‹å’Œã«å«ã¾ã‚Œã‚‹é …ã®ã†ã¡ã®ä¸€ã¤ã«æ¥ç¶šã•ã‚Œã‚‹â€”â€”ã® <em class="en">p</em> ã®ç«¯å­ã«ã¤ãªãŒã‚Œã‚‹ã€‚
</p>

<a name="%_fig_3.28"></a>
<figure>
<img src="ch3-Z-G-30.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 3.28:</b>  The relation 9<em>C</em>  =  5(<em>F</em>  -  32)
expressed as a constraint network.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³3.28:</b> åˆ¶ç´„ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã¨ã—ã¦è¡¨ã•ã‚ŒãŸã€
<span class="math">9<em class="en">C</em>  =  5(<em class="en">F</em>  &minus;  32)</span>
ã¨ã„ã†é–¢ä¿‚</figcaption>
</figure>


<p class="orig" lang="en">
Computation by such a network proceeds as follows: When a connector is
given a value (by the user or by a constraint box to which it is
linked), it awakens all of its associated constraints (except for the
constraint that just awakened it) to inform them that it has a value.
Each awakened constraint box then polls its connectors to see if there
is enough information to determine a value for a connector.  If so,
the box sets that connector, which then awakens all of its associated
constraints, and so on.  For instance, in conversion between
Celsius and Fahrenheit, <em>w</em>, <em>x</em>, and <em>y</em> are immediately set by
the constant boxes to 9, 5, and 32, respectively.  The connectors
awaken the multipliers and the adder, which determine that there is
not enough information to proceed.  If the user (or some other part of
the network) sets <em>C</em> to a value (say 25), the leftmost multiplier
will be awakened, and it will set <em>u</em> to 25 &middot;  9 = 225.  Then <em>u</em>
awakens the second multiplier, which sets <em>v</em> to 45, and <em>v</em> awakens
the adder, which sets <em>F</em> to 77.</p>

<p class="trans" lang="ja">
ã“ã†ã—ãŸãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã«ã‚ˆã‚‹è¨ˆç®—ã¯ã€æ¬¡ã®ã‚ˆã†ã«ã—ã¦é€²ã‚€ã€‚
ã‚³ãƒã‚¯ã‚¿ã«ã€(ãƒ¦ãƒ¼ã‚¶ã«ã‚ˆã£ã¦ã€ã¾ãŸã¯ã€ãã®ã‚³ãƒã‚¯ã‚¿ãŒã¤ãªãŒã‚Œã¦ã„ã‚‹åˆ¶ç´„ãƒœãƒƒã‚¯ã‚¹ã«ã‚ˆã£ã¦) å€¤ãŒä¸ãˆã‚‰ã‚Œã‚‹ã¨ã€ã‚³ãƒã‚¯ã‚¿ã¯ã€è‡ªåˆ†ã«é–¢é€£ã¥ã‘ã‚‰ã‚ŒãŸåˆ¶ç´„ã®ã™ã¹ã¦ (ãŸã ã—ã€ãã®ã‚³ãƒã‚¯ã‚¿ã‚’ã¾ã•ã«ç›®è¦šã‚ã•ã›ãŸå½“è©²åˆ¶ç´„ã‚’é™¤ã) ã‚’ç›®è¦šã‚ã•ã›ã¦ã€ãã‚Œã‚‰ã®åˆ¶ç´„ã«å¯¾ã—ã¦ã€ãã®ã‚³ãƒã‚¯ã‚¿ãŒå€¤ã‚’æŒã£ã¦ã„ã‚‹ã“ã¨ã‚’çŸ¥ã‚‰ã›ã‚‹ã€‚
ã™ã‚‹ã¨ã€èµ·ã“ã•ã‚ŒãŸãã‚Œãã‚Œã®åˆ¶ç´„ãƒœãƒƒã‚¯ã‚¹ã¯ã€è‡ªåˆ†ã®ã‚³ãƒã‚¯ã‚¿ã«å¯¾ã—ã¦å•ã„åˆã‚ã›ã‚’è¡Œã£ã¦ã€ãã®ã‚³ãƒã‚¯ã‚¿ã®å€¤ã‚’æ±ºå®šã™ã‚‹ã®ã«ååˆ†ãªæƒ…å ±ãŒã‚ã‚‹ã‹ã©ã†ã‹ã‚’èª¿ã¹ã‚‹ã€‚
ã‚‚ã—ã‚ã‚Œã°ã€ãã®ãƒœãƒƒã‚¯ã‚¹ã¯ãã®ã‚³ãƒã‚¯ã‚¿ã‚’è¨­å®šã—ã€ã™ã‚‹ã¨ãã®ã‚³ãƒã‚¯ã‚¿ã¯ã€è‡ªåˆ†ã«å¯¾å¿œã¥ã‘ã‚‰ã‚ŒãŸåˆ¶ç´„ã®ã™ã¹ã¦ã‚’ç›®è¦šã‚ã•ã›ã€ã¨ã„ã£ãŸå…·åˆã«ãªã‚‹ã€‚
ãŸã¨ãˆã°ã€æ‘‚æ°ã¨è¯æ°ã®å¤‰æ›ã«ãŠã„ã¦ã€<em class="en">w</em> ã¨ <em class="en">x</em> ã¨ <em class="en">y</em> ã¯ã€åˆ¶ç´„ãƒœãƒƒã‚¯ã‚¹ã«ã‚ˆã£ã¦ç›´æ¥çš„ã«ã€ãã‚Œãã‚Œ9ã¨5ã¨32ã«è¨­å®šã•ã‚Œã‚‹ã€‚
ã“ã‚Œã‚‰ã®ã‚³ãƒã‚¯ã‚¿ã¯ã€ä¹—ç®—å™¨ã¨åŠ ç®—å™¨ã‚’ç›®è¦šã‚ã•ã›ã‚‹ãŒã€ä¹—ç®—å™¨ã¨åŠ ç®—å™¨ã¯ã€å…ˆã«é€²ã‚€ãŸã‚ã®ååˆ†ãªæƒ…å ±ãŒãªã„ã€ã¨åˆ¤å®šã™ã‚‹ã€‚
ã‚‚ã—ãƒ¦ãƒ¼ã‚¶ (ã¾ãŸã¯ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã®ä¸­ã®ä½•ã‚‰ã‹ã®ä»–ã®éƒ¨åˆ†) ãŒ <em class="en">C</em> ã‚’ã‚ã‚‹å€¤ (ãŸã¨ãˆã°25) ã«è¨­å®šã™ã‚‹ã¨ã€ä¸€ç•ªå·¦ã®ä¹—ç®—å™¨ãŒèµ·ã“ã•ã‚Œã‚‹ã ã‚ã†ã€‚ãã—ã¦ã€ä¸€ç•ªå·¦ã®ä¹—ç®—å™¨ã¯ã€<em class="en">u</em> ã‚’ <span class="math">25 &middot;  9 = 225</span>
ã«è¨­å®šã™ã‚‹ã ã‚ã†ã€‚
ã™ã‚‹ã¨ã€<em class="en">u</em> ãŒäºŒç•ªç›®ã®ä¹—ç®—å™¨ã‚’ç›®è¦šã‚ã•ã›ã€ã“ã‚ŒãŒ <em class="en">v</em> ã‚’45ã«è¨­å®šã—ã€ãã—ã¦ã€ <em class="en">v</em> ãŒåŠ ç®—å™¨ã‚’ç›®è¦šã‚ã•ã›ã€åŠ ç®—å™¨ãŒ <em class="en">F</em> ã‚’77ã«è¨­å®šã™ã‚‹ã€‚
</p>

<a name="%_sec_Temp_395"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_395">Using the constraint system</a></h4>
<h4 class="trans" lang="ja">åˆ¶ç´„ã‚·ã‚¹ãƒ†ãƒ ã‚’ä½¿ã†</h4>

<p class="orig" lang="en">
To use the constraint system to carry out the temperature computation
outlined above, we first create two connectors, <tt>C</tt> and <tt>F</tt>,
by calling the constructor <tt>make-connector</tt>, and link <tt>C</tt> and
<tt>F</tt> in an appropriate network:</p>

<p class="trans" lang="ja">
åˆ¶ç´„ã‚·ã‚¹ãƒ†ãƒ ã‚’ä½¿ã£ã¦ã€ä¸Šè¨˜ã«æ¦‚èª¬ã—ãŸæ¸©åº¦è¨ˆç®—ã‚’å®Ÿè¡Œã™ã‚‹ãŸã‚ã«ã¯ã€ç§ãŸã¡ã¯ã¾ãšã€<tt>make-connector</tt> ã¨ã„ã†ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’å‘¼ã³å‡ºã™ã“ã¨ã«ã‚ˆã£ã¦ã€äºŒã¤ã®ã‚³ãƒã‚¯ã‚¿â€”â€”ã¤ã¾ã‚Š <tt>C</tt> ã¨ <tt>F</tt> â€”â€”ã‚’ä½œæˆã—ã€ãã—ã¦ã€<tt>C</tt> ã¨ <tt>F</tt> ã‚’é©åˆ‡ãªãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã®ä¸­ã«ã¤ãªãã€‚
</p>

<p class="lisp">(define C (make-connector))
(define F (make-connector))
(celsius-fahrenheit-converter C F)
<i>ok</i>
</p>

<p class="orig" lang="en">
The procedure that creates the network is defined as follows:</p>

<p class="trans" lang="ja">
ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚’ä½œæˆã™ã‚‹æ‰‹ç¶šãã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_3518"></a>(define (celsius-fahrenheit-converter c f)
  (let ((u (make-connector))
        (v (make-connector))
        (w (make-connector))
        (x (make-connector))
        (y (make-connector)))
    (multiplier c w u)
    (multiplier v x u)
    (adder v y f)
    (constant 9 w)
    (constant 5 x)
    (constant 32 y)
    'ok))
</p>

<p class="orig" lang="en">
This procedure creates the internal connectors <tt>u</tt>, <tt>v</tt>, <tt>w</tt>, <tt>x</tt>, and <tt>y</tt>, and links them as shown in
figure <a href="#%_fig_3.28">3.28</a> using the primitive constraint
constructors <tt>adder</tt>, <tt>multiplier</tt>, and <tt>constant</tt>.  Just
as with the digital-circuit simulator of
section <a href="#%_sec_3.3.4">3.3.4</a>, expressing these combinations of
primitive elements in terms of procedures automatically provides our
language with a means of abstraction for compound objects.
</p>

<p class="trans" lang="ja">
ã“ã®æ‰‹ç¶šãã¯ã€<tt>u</tt> ã¨ <tt>v</tt> ã¨ <tt>w</tt> ã¨ <tt>x</tt> ã¨ <tt>y</tt>ã¨ã„ã†å†…éƒ¨ã‚³ãƒã‚¯ã‚¿ã‚’ä½œæˆã—ã€<tt>adder</tt> ã¨ <tt>multiplier</tt> ã¨ <tt>constant</tt> ã¨ã„ã†åŸå§‹çš„åˆ¶ç´„ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’ç”¨ã„ã¦ã€ã“ã‚Œã‚‰ã®å†…éƒ¨ã‚³ãƒã‚¯ã‚¿ã‚’å›³<a href="#%_fig_3.28">3.28</a>ã«ç¤ºã™ã¨ãŠã‚Šã«ã¤ãªãã€‚
<a href="#%_sec_3.3.4">3.3.4</a>ç¯€ã§ã®ãƒ‡ã‚£ã‚¸ã‚¿ãƒ«å›è·¯ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã«ãŠã‘ã‚‹ã®ã¨ã¡ã‚‡ã†ã©åŒã˜ã‚ˆã†ã«ã€æ‰‹ç¶šãã‚’ç”¨ã„ã¦åŸå§‹çš„ãªè¦ç´ åŒå£«ã®ã“ã‚Œã‚‰ã®çµ„ã¿åˆã‚ã›ã‚’è¡¨ç¾ã™ã‚‹ã¨ã€è‡ªå‹•çš„ã«ã€ç§ãŸã¡ã®è¨€èªã«ã¯ã€è¤‡åˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãŸã‚ã®æŠ½è±¡åŒ–ã®æ‰‹æ®µãŒæä¾›ã•ã‚Œã‚‹ã®ã ã€‚
</p>

<p class="orig" lang="en">
To watch the network in action, we can place probes on the connectors
<tt>C</tt> and <tt>F</tt>, using a <tt>probe</tt> procedure similar to the one
we used to monitor wires in section <a href="#%_sec_3.3.4">3.3.4</a>.
Placing a probe on a connector will cause a message to be printed
whenever the connector is given a value:</p>

<p class="trans" lang="ja">
å‹•ä½œä¸­ã®ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚’è¦‹å¼µã‚‹ãŸã‚ã«ã€<tt>C</tt> ã¨ <tt>F</tt> ã¨ã„ã†ã‚³ãƒã‚¯ã‚¿ã«ãƒ—ãƒ­ãƒ¼ãƒ–ã‚’è¨­ç½®ã™ã‚‹ã“ã¨ãŒã§ãã‚‹â€”â€”<a href="#%_sec_3.3.4">3.3.4</a>ç¯€ã§é…ç·šã‚’ç›£è¦–ã™ã‚‹ã®ã«ç”¨ã„ãŸã‚‚ã®ã«ä¼¼ã¦ã„ã‚‹ã€<tt>probe</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’ä½¿ã£ã¦ã€‚
ã‚³ãƒã‚¯ã‚¿ã«ãƒ—ãƒ­ãƒ¼ãƒ–ã‚’è¨­ç½®ã™ã‚‹ã“ã¨ã¯ã€ã‚³ãƒã‚¯ã‚¿ã«å€¤ãŒä¸ãˆã‚‰ã‚Œã‚‹ãŸã³ã«å°å­—ã™ã¹ããƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ã‚‚ãŸã‚‰ã™ã ã‚ã†ã€‚
</p>

<p class="lisp">(probe &quot;Celsius temp&quot; C)
(probe &quot;Fahrenheit temp&quot; F)
</p>

<p class="orig" lang="en">
Next we set the value of <tt>C</tt> to 25.  (The third argument to <tt>set-value!</tt> tells <tt>C</tt> that this directive comes from the <tt>user</tt>.)</p>

<p class="trans" lang="ja">
æ¬¡ã«ã€<tt>C</tt> ã®å€¤ã‚’25ã«è¨­å®šã™ã‚‹ã€‚
(<tt>set-value!</tt> ã®ä¸‰ç•ªç›®ã®å¼•æ•°ã¯ã€<tt>C</tt> ã«å¯¾ã—ã¦ã€ã“ã®<ruby><rb>æŒ‡ä»¤</rb><rp> (</rp><rt>ãƒ‡ã‚£ãƒ¬ã‚¯ãƒ†ã‚£ãƒ–</rt><rp>) </rp></ruby>ãŒ <tt>user</tt> ã‹ã‚‰æ¥ã¦ã„ã‚‹ã“ã¨ã‚’çŸ¥ã‚‰ã›ã¦ã„ã‚‹ã€‚)
</p>

<p class="lisp">(set-value! C 25 'user)
<i>Probe: Celsius temp = 25</i>
<i>Probe: Fahrenheit temp = 77</i>
<i>done</i>
</p>

<p class="orig" lang="en">
The probe on <tt>C</tt> awakens and reports the value.  <tt>C</tt> also
propagates its value through the network as described above.  This
sets <tt>F</tt> to 77, which is reported by the probe on <tt>F</tt>.
</p>

<p class="trans" lang="ja">
<tt>C</tt> ä¸Šã®ãƒ—ãƒ­ãƒ¼ãƒ–ã¯ã€ç›®è¦šã‚ã¦ã€å€¤ã‚’å ±å‘Šã™ã‚‹ã€‚
<tt>C</tt> ã¯ã€è‡ªåˆ†ã®å€¤ã‚’ã€ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚’é€šã˜ã¦ã€ä¸Šè¿°ã®ã‚ˆã†ã«ä¼æ’­ã•ã›ã‚‹ã€‚
ã“ã‚Œã«ã‚ˆã‚Šã€<tt>F</tt> ãŒ77ã«è¨­å®šã•ã‚Œã€ãã‚ŒãŒ <tt>F</tt> ä¸Šã®ãƒ—ãƒ­ãƒ¼ãƒ–ã«ã‚ˆã‚Šå ±å‘Šã•ã‚Œã‚‹ã€‚
</p>

<p class="orig" lang="en">
Now we can try to set <tt>F</tt> to a new value, say 212:
</p>

<p class="trans" lang="ja">
ã“ã“ã§ã€<tt>F</tt> ã‚’ã€æ–°ãŸãªå€¤â€”â€”ãŸã¨ãˆã°ã€212â€”â€”ã«ã€è¨­å®šã—ã‚ˆã†ã¨è©¦ã¿ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
</p>

<p class="lisp">(set-value! F 212 'user)
<i>Error! Contradiction (77 212)</i>
</p>

<p class="orig" lang="en">
The connector complains that it has sensed a contradiction: Its value
is 77, and someone is trying to set it to 212.  If we really want to
reuse the network with new values, we can tell <tt>C</tt> to forget its
old value:</p>

<p class="trans" lang="ja">
ã‚³ãƒã‚¯ã‚¿ã¯ã€çŸ›ç›¾ã‚’æ„ŸçŸ¥ã—ãŸã€ã¨è¨´ãˆã‚‹ã€‚ã¤ã¾ã‚Šã€ãã®ã‚³ãƒã‚¯ã‚¿ã®å€¤ã¯77ã§ã‚ã‚Šã€ã‹ã¤ã€èª°ã‹ãŒãã‚Œã‚’212ã«è¨­å®šã—ã‚ˆã†ã¨ã—ã¦ã„ã‚‹ã¨ã“ã‚ã ã€ã¨ã€‚
ã‚‚ã—æœ¬å½“ã«ã“ã®æ–°ãŸãªå€¤ã‚’ä½¿ã£ã¦ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚’å†åˆ©ç”¨ã—ãŸã„ãªã‚‰ã°ã€<tt>C</tt> ã«å¯¾ã—ã¦ã€å¤ã„å€¤ã‚’å¿˜ã‚Œã‚‹ã‚ˆã†ã«å‘½ä»¤ã§ãã‚‹ã€‚
</p>

<p class="lisp">(forget-value! C 'user)
<i>Probe: Celsius temp = ?</i>
<i>Probe: Fahrenheit temp = ?</i>
<i>done</i>
</p>

<p class="orig" lang="en">
<tt>C</tt> finds that the <tt>user</tt>, who set its value originally, is
now retracting that value, so <tt>C</tt> agrees to lose its value, as
shown by the probe, and informs the rest of the network of this fact.
This information eventually propagates to <tt>F</tt>, which now finds
that it has no reason for continuing to believe that its own value is
77.  Thus, <tt>F</tt> also gives up its value, as shown by the probe.
</p>

<p class="trans" lang="ja">
<tt>C</tt> ã¯ã€<tt>user</tt> â€”â€”æœ€åˆã« <tt>C</tt> ã®å€¤ã‚’è¨­å®šã—ãŸäººâ€”â€”ãŒã€ä»Šã€ãã®å€¤ã‚’æ’¤å›ã—ã¦ã„ã‚‹ã¨ã“ã‚ã ã€ã¨æ°—ã¥ãã€ãã®ãŸã‚<tt>C</tt> ã¯ã€è‡ªåˆ†ã®å€¤â€”â€”ãƒ—ãƒ­ãƒ¼ãƒ–ã«ã‚ˆã£ã¦ç¤ºã•ã‚Œã¦ã„ã‚‹ã¨ãŠã‚Šã®ã‚‚ã®â€”â€”ã‚’å¤±ã†ã“ã¨ã«åŒæ„ã—ã€ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã®æ®‹ã‚Šã®éƒ¨åˆ†ã«å¯¾ã—ã¦ã€ã“ã®äº‹å®Ÿã‚’çŸ¥ã‚‰ã›ã‚‹ã€‚
ã“ã®çŸ¥ã‚‰ã›ã¯ã€ã¤ã„ã«ã¯ <tt>F</tt> ã¾ã§ä¼æ’­ã—ã€ã™ã‚‹ã¨<tt>F</tt> ã¯ã€è‡ªåˆ†è‡ªèº«ã®å€¤ãŒ77ã ã¨ä¿¡ã˜ç¶šã‘ã‚‹ç†ç”±ãŒãªã„ã“ã¨ã«æ°—ã¥ãã€‚
ã‚ˆã£ã¦ã€<tt>F</tt> ã‚‚ã¾ãŸè‡ªåˆ†ã®å€¤â€”â€”ãƒ—ãƒ­ãƒ¼ãƒ–ã«ã‚ˆã£ã¦ç¤ºã•ã‚Œã¦ã„ã‚‹ã¨ãŠã‚Šã®ã‚‚ã®â€”â€”ã‚’æ¨ã¦å»ã‚‹ã€‚
</p>

<p class="orig" lang="en">
Now that <tt>F</tt> has no value, we are free to set it to 212:</p>

<p class="trans" lang="ja">
ã•ã¦ä»Šã‚„ <tt>F</tt> ã¯å€¤ã‚’æŒã£ã¦ã„ãªã„ã‹ã‚‰ã€ç§ãŸã¡ã¯è‡ªç”±ã«å€¤ã‚’212ã«è¨­å®šã§ãã‚‹ã€‚
</p>

<p class="lisp">(set-value! F 212 'user)
<i>Probe: Fahrenheit temp = 212</i>
<i>Probe: Celsius temp = 100</i>
<i>done</i>
</p>

<p class="orig" lang="en">
This new value, when propagated through the network, forces <tt>C</tt> to
have a value of 100, and this is registered by the probe on <tt>C</tt>.
Notice that the very same network is being used to compute <tt>C</tt>
given <tt>F</tt> and to compute <tt>F</tt> given <tt>C</tt>.  This
nondirectionality of computation is the distinguishing feature of
constraint-based systems.</p>

<p class="trans" lang="ja">
ã“ã®æ–°ãŸãªå€¤ã¯ã€ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚’é€šã˜ã¦ä¼æ’­ã—ã¦ããŸã¨ãã«ã€100ã¨ã„ã†å€¤ã‚’æŒã¤ã‚ˆã†ã« <tt>C</tt> ã«å¼·ã„ã‚‹ã®ã§ã€ã“ã‚ŒãŒ <tt>C</tt> ä¸Šã®ãƒ—ãƒ­ãƒ¼ãƒ–ã«ã‚ˆã‚Šç™»éŒ²ã•ã‚Œã‚‹ã€‚
<tt>F</tt> ã‚’ä¸ãˆã‚‰ã‚Œã¦ <tt>C</tt> ã‚’è¨ˆç®—ã™ã‚‹ã®ã«ã‚‚ã€<tt>C</tt> ã‚’ä¸ãˆã‚‰ã‚Œã¦ <tt>F</tt> ã‚’è¨ˆç®—ã™ã‚‹ã®ã«ã‚‚ã€ã¾ã•ã—ãåŒã˜ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãŒä½¿ã‚ã‚Œã¦ã„ã‚‹ã®ã ã€ã¨ã„ã†ã“ã¨ã«æ°—ã¥ã„ã¦ã»ã—ã„ã€‚
ã“ã®ã‚ˆã†ãªè¨ˆç®—ã®ç„¡æ–¹å‘æ€§ã¯ã€åˆ¶ç´„ã«åŸºã¥ãã‚·ã‚¹ãƒ†ãƒ ã®éš›ç«‹ã£ãŸç‰¹å¾´ã§ã‚ã‚‹ã€‚
<span class="note">(ãªã‚“ã‹Prologã§æ›¸ã‘ãã†ãªæ°—ã‚‚ã™ã‚‹ã‚“ã ãŒã€ç´„20å¹´ã‚‚æ›¸ã„ã¦ã„ãªã„ã¨ã€ã™ã£ã‹ã‚Šã‚‚ã†åˆ†ã‹ã‚‰ãªããªã£ã¦ã„ã‚‹ãªâ€¦â€¦ã€‚ä»Šåº¦ã‚ˆãè€ƒãˆã‚ˆã†ã€‚)</span>
</p>

<a name="%_sec_Temp_396"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_396">Implementing the constraint system</a></h4>
<h4 class="trans" lang="ja">åˆ¶ç´„ã‚·ã‚¹ãƒ†ãƒ ã‚’å®Ÿè£…ã™ã‚‹</h4>

<p class="orig" lang="en">
The constraint system is implemented via procedural objects with local
state, in a manner very similar to the digital-circuit simulator of
section <a href="#%_sec_3.3.4">3.3.4</a>.  Although the primitive objects
of the constraint system are somewhat more complex, the overall system
is simpler, since there is no concern about agendas and logic delays.</p>

<p class="trans" lang="ja">
åˆ¶ç´„ã‚·ã‚¹ãƒ†ãƒ ã¯ã€<a href="#%_sec_3.3.4">3.3.4</a>ç¯€ã®ãƒ‡ã‚£ã‚¸ã‚¿ãƒ«å›è·¯ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã¨ã¨ã¦ã‚‚ã‚ˆãä¼¼ãŸæ–¹æ³•ã§ã€å±€æ‰€çŠ¶æ…‹ã‚’æŒã£ãŸæ‰‹ç¶šãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚ˆã£ã¦ã€å®Ÿè£…ã•ã‚Œã‚‹ã€‚
åˆ¶ç´„ã‚·ã‚¹ãƒ†ãƒ ã®åŸå§‹çš„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€å¤šå°‘ã¯ã€ã‚ˆã‚Šè¤‡é›‘ã§ã¯ã‚ã‚‹ã®ã ãŒã€å…¨ä½“ã®ã‚·ã‚¹ãƒ†ãƒ ã¯ã€ã‚ˆã‚Šå˜ç´”ã§ã‚ã‚‹ã€‚ã¨ã„ã†ã®ã‚‚ã€ã‚¢ã‚¸ã‚§ãƒ³ãƒ€ã¨ãƒ­ã‚¸ãƒƒã‚¯ã®é…å»¶ã«ã¤ã„ã¦ã®æ‡¸å¿µãŒãªã„ã‹ã‚‰ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_3520"></a>The basic operations on connectors are the following:
</p>

<p class="trans" lang="ja">
ã‚³ãƒã‚¯ã‚¿ã«ã¤ã„ã¦ã®åŸºæœ¬æ¼”ç®—ã¯ã€ä»¥ä¸‹ã®ã¨ãŠã‚Šã§ã‚ã‚‹ã€‚
</p>

<ul class="orig" lang="en">
<li><a name="%_idx_3522"></a><tt>(has-value? &lt;<em>connector</em>&gt;)</tt>
tells whether the connector has a value.</li>

<li><a name="%_idx_3524"></a><tt>(get-value &lt;<em>connector</em>&gt;)</tt>
returns the connector's current value.</li>

<li><a name="%_idx_3526"></a><tt>(set-value! &lt;<em>connector</em>&gt; &lt;<em>new-value</em>&gt; &lt;<em>informant</em>&gt;)</tt>
indicates that the informant is requesting the connector to set its
value to the new value.</li>

<li><a name="%_idx_3528"></a><tt>(forget-value! &lt;<em>connector</em>&gt; &lt;<em>retractor</em>&gt;)</tt>
tells the connector that the retractor is requesting it to forget its value.</li>

<li><a name="%_idx_3530"></a><tt>(connect &lt;<em>connector</em>&gt; &lt;<em>new-constraint</em>&gt;)</tt>
tells the connector to participate in the new constraint.</li>
</ul>

<ul class="trans" lang="ja">
<li><tt>(has-value? &lt;<em class="en">connector</em>&gt;)</tt> ã¯ã€ã‚³ãƒã‚¯ã‚¿ãŒå€¤ã‚’æŒã£ã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’çŸ¥ã‚‰ã›ã‚‹ã€‚</li>

<li><tt>(get-value &lt;<em class="en">connector</em>&gt;)</tt> ã¯ã€ã‚³ãƒã‚¯ã‚¿ã®ç¾åœ¨ã®å€¤ã‚’è¿”ã™ã€‚</li>

<li><tt>(set-value! &lt;<em class="en">connector</em>&gt; &lt;<em class="en">new-value</em>&gt; &lt;<em class="en">informant</em>&gt;)</tt> ã¯ã€<ruby><rb>æƒ…å ±æä¾›è€…</rb><rp> (</rp><rt>informant</rt><rp>) </rp></ruby>ãŒã‚³ãƒã‚¯ã‚¿ã«å¯¾ã—ã¦ã€ãã®å€¤ã‚’æ–°ãŸãªå€¤ã«è¨­å®šã™ã‚‹ã“ã¨ã‚’è¦æ±‚ã—ã¦ã„ã‚‹ã€ã¨ã„ã†ã“ã¨ã‚’ç¤ºã™ã€‚</li>

<li><tt>(forget-value! &lt;<em class="en">connector</em>&gt; &lt;<em class="en">retractor</em>&gt;)</tt> ã¯ã€<ruby><rb>æ’¤å›è€…</rb><rp> (</rp><rt>retractor</rt><rp>) </rp></ruby>ãŒã‚³ãƒã‚¯ã‚¿ã«å¯¾ã—ã¦å€¤ã‚’å¿˜ã‚Œã‚‹ã‚ˆã†æ±‚ã‚ã¦ã„ã‚‹ã€ã¨ã„ã†ã“ã¨ã‚’ã‚³ãƒã‚¯ã‚¿ã«ä¼ãˆã‚‹ã€‚</li>

<li><tt>(connect &lt;<em class="en">connector</em>&gt; &lt;<em class="en">new-constraint</em>&gt;)</tt> ã¯ã€ã‚³ãƒã‚¯ã‚¿ã«å¯¾ã—ã¦ã€æ–°ãŸãªåˆ¶ç´„ã«å‚åŠ ã™ã‚‹ã‚ˆã†å‘½ä»¤ã™ã‚‹ã€‚</li>
</ul>

<p class="orig" lang="en">
The connectors communicate with the constraints by means of the
procedures <tt>inform-about-value</tt>, which tells the given
constraint that the connector has a value, and <tt>inform-about-no-value</tt>, which tells the constraint that the connector
has lost its value.
</p>

<p class="trans" lang="ja">
ã‚³ãƒã‚¯ã‚¿ã¯ã€<tt>inform-about-value</tt> â€”â€”ä¸ãˆã‚‰ã‚ŒãŸåˆ¶ç´„ã«å¯¾ã—ã¦ã€ã‚³ãƒã‚¯ã‚¿ãŒå€¤ã‚’æŒã£ã¦ã„ã‚‹ã“ã¨ã‚’ä¼ãˆã‚‹â€”â€”ãŠã‚ˆã³ <tt>inform-about-no-value</tt> â€”â€”åˆ¶ç´„ã«å¯¾ã—ã¦ã€ã‚³ãƒã‚¯ã‚¿ãŒãã®å€¤ã‚’å¤±ã£ãŸã“ã¨ã‚’ä¼ãˆã‚‹â€”â€”ã¨ã„ã†æ‰‹ç¶šãã‚’ç”¨ã„ã¦ã€åˆ¶ç´„ã¨æƒ…å ±ã‚’äº¤æ›ã—ã‚ã†ã€‚
</p>

<p class="orig" lang="en">
<tt>Adder</tt> constructs an adder constraint among summand connectors
<tt>a1</tt> and <tt>a2</tt> and a <tt>sum</tt> connector.  An adder is
implemented as a procedure with local state (the procedure <tt>me</tt>
below):</p>

<p class="trans" lang="ja">
<tt>adder</tt> ã¯ã€<tt>a1</tt> ã¨ <tt>a2</tt> ã¨ã„ã†è¢«åŠ æ•°ã‚³ãƒã‚¯ã‚¿ã¨ã€<tt>sum</tt> ã¨ã„ã†ã‚³ãƒã‚¯ã‚¿ã¨ã®é–“ã§ã®ã€åŠ ç®—å™¨åˆ¶ç´„ã‚’æ§‹ç¯‰ã™ã‚‹ã€‚
åŠ ç®—å™¨ã¯ã€å±€æ‰€çŠ¶æ…‹ã‚’æœ‰ã™ã‚‹æ‰‹ç¶šã (ä¸‹è¨˜ã® <tt>me</tt> ã¨ã„ã†æ‰‹ç¶šã) ã¨ã—ã¦å®Ÿè£…ã•ã‚Œã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_3532"></a>(define (adder a1 a2 sum)
  (define (process-new-value)
    (cond ((and (has-value? a1) (has-value? a2))
           (set-value! sum
                       (+ (get-value a1) (get-value a2))
                       me))
          ((and (has-value? a1) (has-value? sum))
           (set-value! a2
                       (- (get-value sum) (get-value a1))
                       me))
          ((and (has-value? a2) (has-value? sum))
           (set-value! a1
                       (- (get-value sum) (get-value a2))
                       me))))
  (define (process-forget-value)
    (forget-value! sum me)
    (forget-value! a1 me)
    (forget-value! a2 me)
    (process-new-value))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)  
           (process-new-value))
          ((eq? request 'I-lost-my-value) 
           (process-forget-value))
          (else 
           (error &quot;Unknown request -- ADDER&quot; request))))
  (connect a1 me)
  (connect a2 me)
  (connect sum me)
  me)
</p>

<p class="orig" lang="en">
<tt>Adder</tt> connects the new adder to the designated connectors and
returns it as its value.  The procedure <tt>me</tt>, which represents the
adder, acts as a dispatch to the local procedures.  The following
``syntax interfaces'' (see footnote <a href="#footnote_Temp_385">27</a> in
section <a href="#%_sec_3.3.4">3.3.4</a>) are used in conjunction with the
dispatch:</p>

<p class="trans" lang="ja">
<tt>adder</tt> ã¯æ–°ãŸãªåŠ ç®—å™¨ã‚’æŒ‡å®šã•ã‚ŒãŸã‚³ãƒã‚¯ã‚¿ã«æ¥ç¶šã—ã€ãã®åŠ ç®—å™¨ã‚’ã€å€¤ã¨ã—ã¦è¿”ã™ã€‚
<tt>me</tt> ã¨ã„ã†æ‰‹ç¶šãâ€”â€”åŠ ç®—å™¨ã‚’è¡¨ç¾ã—ã¦ã„ã‚‹â€”â€”ã¯ã€å±€æ‰€æ‰‹ç¶šãã¸ã®<ruby><rb>å‰²ã‚ŠæŒ¯ã‚Š</rb><rp> (</rp><rt>ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒ</rt><rp>) </rp></ruby>ã¨ã—ã¦æŒ¯ã‚‹èˆã†ã€‚
ä»¥ä¸‹ã®ã€Œæ§‹æ–‡ä¸Šã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ã‚¤ã‚¹ã€(<a href="#%_sec_3.3.4">3.3.4</a>ç¯€ã®è„šè¨»<a href="#footnote_Temp_385">27</a>ã‚’å‚ç…§) ãŒã€å‰²ã‚ŠæŒ¯ã‚Šã¨ã¨ã‚‚ã«ä½¿ã‚ã‚Œã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_3534"></a>(define (inform-about-value constraint)
  (constraint 'I-have-a-value))
<a name="%_idx_3536"></a>(define (inform-about-no-value constraint)
  (constraint 'I-lost-my-value))
</p>

<p class="orig" lang="en">
The adder's local procedure <tt>process-new-value</tt> is called when the
adder is informed that one of its connectors has a value. The adder
first checks to see if both <tt>a1</tt> and <tt>a2</tt> have values. If so,
it tells <tt>sum</tt> to set its value to the sum of the two addends.
The <tt>informant</tt> argument to <tt>set-value!</tt> is <tt>me</tt>, which is
the adder object itself.  If <tt>a1</tt> and <tt>a2</tt> do not both have
values, then the adder checks to see if perhaps <tt>a1</tt> and <tt>sum</tt>
have values.  If so, it sets <tt>a2</tt> to the difference of these two.
Finally, if <tt>a2</tt> and <tt>sum</tt> have values, this gives the adder
enough information to set <tt>a1</tt>.  If the adder is told that one of
its connectors has lost a value, it requests that all of its
connectors now lose their values.  (Only those values that were set by
this adder are actually lost.)  Then it runs <tt>process-new-value</tt>.
The reason for this last step is that one or more connectors may still
have a value (that is, a connector may have had a value that was not
originally set by the adder), and these values may need to be
propagated back through the adder.
</p>

<p class="trans" lang="ja">
åŠ ç®—å™¨ã® <tt>process-new-value</tt> ã¨ã„ã†å±€æ‰€æ‰‹ç¶šãã¯ã€åŠ ç®—å™¨ã®ã‚³ãƒã‚¯ã‚¿ã®ã†ã¡ã®ä¸€ã¤ãŒå€¤ã‚’æŒã£ã¦ã„ã‚‹ã€ã¨åŠ ç®—å™¨ãŒçŸ¥ã‚‰ã•ã‚ŒãŸã¨ãã«ã€å‘¼ã³å‡ºã•ã‚Œã‚‹ã€‚
åŠ ç®—å™¨ã¯ã¾ãšã€<tt>a1</tt> ã¨ <tt>a2</tt> ã®åŒæ–¹ãŒå€¤ã‚’æŒã£ã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’èª¿ã¹ã‚‹ã€‚
ã‚‚ã—ãã†ãªã‚‰ã€åŠ ç®—å™¨ã¯ <tt>sum</tt> ã«å¯¾ã—ã¦ã€ãã®å€¤ã‚’ã€äºŒã¤ã®è¢«åŠ æ•°ã®å’Œã«è¨­å®šã™ã‚‹ã‚ˆã†ã€å‘½ä»¤ã™ã‚‹ã€‚
<tt>set-value!</tt> ã«å¯¾ã™ã‚‹ <tt>informant</tt> ã®å¼•æ•°ã¯ã€<tt>me</tt> â€”â€”ã¤ã¾ã‚Šã€åŠ ç®—å™¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè‡ªä½“â€”â€”ã§ã‚ã‚‹ã€‚
ã‚‚ã—ã€<tt>a1</tt> ã¨ <tt>a2</tt> ã®åŒæ–¹ã¨ã‚‚ãŒå€¤ã‚’æŒã£ã¦ã„ã‚‹ã€ã¨ã„ã†ã‚ã‘ã§ã¯ãªã„ãªã‚‰ã°ã€åŠ ç®—å™¨ã¯ã€ã‚‚ã—ã‹ã—ã¦ <tt>a1</tt> ã¨ <tt>sum</tt> ãŒå€¤ã‚’æŒã£ã¦ã„ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ãŒã€ã©ã†ãªã®ã‹ãªã€ã¨èª¿ã¹ã‚‹ã€‚
ã‚‚ã—ãã†ãªã‚‰ã€åŠ ç®—å™¨ã¯ã€ã“ã‚Œã‚‰äºŒã¤ã®å€¤ã®å·®åˆ†ã‚’ã€<tt>a2</tt> ã«è¨­å®šã™ã‚‹ã€‚
æœ€å¾Œã«ã€ã‚‚ã— <tt>a2</tt> ã¨ <tt>sum</tt> ãŒå€¤ã‚’æŒã£ã¦ã„ãŸã‚‰ã€ã“ã®ã“ã¨ã¯ã€åŠ ç®—å™¨ã«å¯¾ã—ã¦ã€<tt>a1</tt> ã‚’è¨­å®šã™ã‚‹ã®ã«ååˆ†ãªæƒ…å ±ã‚’ä¸ãˆã¦ã„ã‚‹ã€‚
ã‚‚ã—åŠ ç®—å™¨ãŒã€è‡ªåˆ†ã®ã‚³ãƒã‚¯ã‚¿ã®ã†ã¡ã®ä¸€ã¤ãŒå€¤ã‚’å¤±ã£ãŸã“ã¨ã‚’ä¼ãˆã‚‰ã‚ŒãŸã‚‰ã€åŠ ç®—å™¨ã¯ã€è‡ªåˆ†ã®ã‚³ãƒã‚¯ã‚¿ã®ã™ã¹ã¦ãŒä»Šã‹ã‚‰ã¯å€¤ã‚’å¤±ã†ã€ã¨ã„ã†ã“ã¨ã‚’è¦æ±‚ã™ã‚‹ã€‚
(ã“ã®åŠ ç®—å™¨ã«ã‚ˆã£ã¦è¨­å®šã•ã‚ŒãŸå€¤ã®ã¿ãŒã€å®Ÿéš›ã«å¤±ã‚ã‚Œã‚‹ã€‚)
ãã®å¾Œã€åŠ ç®—å™¨ã¯ã€<tt>process-new-value</tt> ã‚’å®Ÿè¡Œã™ã‚‹ã€‚
ã“ã®æœ€å¾Œã®ã‚¹ãƒ†ãƒƒãƒ—ã‚’è¡Œã†ç†ç”±ã¯ã€ä¸€ã¤ã¾ãŸã¯ãã‚Œä»¥ä¸Šã®ã‚³ãƒã‚¯ã‚¿ãŒä¾ç„¶ã¨ã—ã¦å€¤ã‚’æŒã£ã¦ã„ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ (ã¤ã¾ã‚Šã€ã‚ã‚‹ã‚³ãƒã‚¯ã‚¿ãŒã€ã“ã®åŠ ç®—å™¨ã«ã‚ˆã£ã¦ã‚‚ã¨ã‚‚ã¨è¨­å®šã•ã‚ŒãŸã®ã§ã¯ãªã„å€¤ã‚’æŒã£ã¦ã„ãŸã‹ã‚‚ã—ã‚Œãªã„) ã‹ã‚‰ã§ã‚ã‚Šã€åŠ ç®—å™¨ã‚’é€šã˜ã¦ã“ã‚Œã‚‰ã®å€¤ã‚’é€†å‘ãã«ä¼æ’­ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã‹ã‚‰ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
A multiplier is very similar to an adder. It will set its <tt>product</tt> to 0 if either of the factors is 0, even if the other factor
is not known.</p>

<p class="trans" lang="ja">
ä¹—ç®—å™¨ã¯åŠ ç®—å™¨ã¨ã¨ã¦ã‚‚ã‚ˆãä¼¼ã¦ã„ã‚‹ã€‚
ä¹—ç®—å™¨ã¯ã€å› å­ã®ã„ãšã‚Œã‹ãŒ0ã§ã‚ã‚‹ã¨ãã€ãŸã¨ãˆä»–æ–¹ã®å› å­ãŒä¸æ˜ã§ã‚ã‚ã†ã¨ã‚‚ã€è‡ªåˆ†ã® <tt>product</tt> ã‚’0ã«è¨­å®šã™ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_3538"></a>(define (multiplier m1 m2 product)
  (define (process-new-value)
    (cond ((or (and (has-value? m1) (= (get-value m1) 0))
               (and (has-value? m2) (= (get-value m2) 0)))
           (set-value! product 0 me))
          ((and (has-value? m1) (has-value? m2))
           (set-value! product
                       (* (get-value m1) (get-value m2))
                       me))
          ((and (has-value? product) (has-value? m1))
           (set-value! m2
                       (/ (get-value product) (get-value m1))
                       me))
          ((and (has-value? product) (has-value? m2))
           (set-value! m1
                       (/ (get-value product) (get-value m2))
                       me))))
  (define (process-forget-value)
    (forget-value! product me)
    (forget-value! m1 me)
    (forget-value! m2 me)
    (process-new-value))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)
           (process-new-value))
          ((eq? request 'I-lost-my-value)
           (process-forget-value))
          (else
           (error &quot;Unknown request -- MULTIPLIER&quot; request))))
  (connect m1 me)
  (connect m2 me)
  (connect product me)
  me)
</p>

<p class="orig" lang="en">
A <tt>constant</tt> constructor simply sets the value of the designated
connector.  Any <tt>I-have-a-value</tt> or <tt>I-lost-my-value</tt> message
sent to the constant box will produce an error.</p>

<p class="trans" lang="ja">
<tt>constant</tt> ã¨ã„ã†ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ã€å˜ç´”ã«ã€æŒ‡å®šã•ã‚ŒãŸã‚³ãƒã‚¯ã‚¿ã®å€¤ã‚’è¨­å®šã™ã‚‹ã€‚
å®šæ•°ãƒœãƒƒã‚¯ã‚¹ã«é€ã‚‰ã‚ŒãŸã€<tt>I-have-a-value</tt> ã¾ãŸã¯ <tt>I-lost-my-value</tt> ã¨ã„ã†ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ã©ã‚Œã‚‚ã€ã‚¨ãƒ©ãƒ¼ã‚’å¼•ãèµ·ã“ã™ã ã‚ã†ã€‚
</p>

<p class="lisp"><a name="%_idx_3540"></a>(define (constant value connector)
  (define (me request)
    (error &quot;Unknown request -- CONSTANT&quot; request))
  (connect connector me)
  (set-value! connector value me)
  me)
</p>

<p class="orig" lang="en">
Finally, a probe prints a message about the setting or unsetting of
the designated connector:</p>

<p class="trans" lang="ja">
æœ€å¾Œã«ã€ãƒ—ãƒ­ãƒ¼ãƒ–ã¯ã€æŒ‡å®šã•ã‚ŒãŸã‚³ãƒã‚¯ã‚¿ã®è¨­å®šã¾ãŸã¯éè¨­å®šã«ã¤ã„ã¦ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å°å­—ã™ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_3542"></a>(define (probe name connector)
  (define (print-probe value)
    (newline)
    (display &quot;Probe: &quot;)
    (display name)
    (display &quot; = &quot;)
    (display value))
  (define (process-new-value)
    (print-probe (get-value connector)))
  (define (process-forget-value)
    (print-probe &quot;?&quot;))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)
           (process-new-value))
          ((eq? request 'I-lost-my-value)
           (process-forget-value))
          (else
           (error &quot;Unknown request -- PROBE&quot; request))))
  (connect connector me)
  me)
</p>



<a name="%_sec_Temp_397"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_397">Representing connectors</a></h4>
<h4 class="trans" lang="ja">ã‚³ãƒã‚¯ã‚¿ã‚’è¡¨ç¾ã™ã‚‹</h4>

<p class="orig" lang="en">
<a name="%_idx_3544"></a>
A connector is represented as a procedural object with local state
variables <tt>value</tt>, the current value of the connector; <tt>informant</tt>, the object that set the connector's value; and <tt>constraints</tt>, a list of the constraints in which the connector
participates.</p>

<p class="trans" lang="ja">
ã‚³ãƒã‚¯ã‚¿ã¯ã€<tt>value</tt> â€”â€”ã‚³ãƒã‚¯ã‚¿ã®ç¾åœ¨ã®å€¤â€”â€”ã¨ <tt>infromation</tt> â€”â€”ã‚³ãƒã‚¯ã‚¿ã®å€¤ã‚’è¨­å®šã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆâ€”â€”ã¨ <tt>constraints</tt> â€”â€”ã‚³ãƒã‚¯ã‚¿ãŒå‚åŠ ã—ã¦ã„ã‚‹åˆ¶ç´„ã®ãƒªã‚¹ãƒˆâ€”â€”ã¨ã„ã†å±€æ‰€çŠ¶æ…‹å¤‰æ•°ã‚’ã‚‚ã£ãŸã€æ‰‹ç¶šãçš„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦è¡¨ç¾ã•ã‚Œã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_3546"></a>(define (make-connector)
  (let ((value false) (informant false) (constraints '()))
    (define (set-my-value newval setter)
      (cond ((not (has-value? me))
             (set! value newval)
             (set! informant setter)
             (for-each-except setter
                              inform-about-value
                              constraints))
            ((not (= value newval))
             (error &quot;Contradiction&quot; (list value newval)))
            (else 'ignored)))
    (define (forget-my-value retractor)
      (if (eq? retractor informant)
          (begin (set! informant false)
                 (for-each-except retractor
                                  inform-about-no-value
                                  constraints))
          'ignored))
    (define (connect new-constraint)
      (if (not (memq new-constraint constraints))
          (set! constraints 
                (cons new-constraint constraints)))
      (if (has-value? me)
          (inform-about-value new-constraint))
      'done)
    (define (me request)
      (cond ((eq? request 'has-value?)
             (if informant true false))
            ((eq? request 'value) value)
            ((eq? request 'set-value!) set-my-value)
            ((eq? request 'forget) forget-my-value)
            ((eq? request 'connect) connect)
            (else (error &quot;Unknown operation -- CONNECTOR&quot;
                         request))))
    me))
</p>

<p class="orig" lang="en">
The connector's local procedure <tt>set-my-value</tt> is called when
there is a request to set the connector's value.  If the connector
does not currently have a value, it will set its value and remember as
<tt>informant</tt> the constraint that requested the value to be
set.<a name="call_footnote_Temp_398" href="#footnote_Temp_398"><sup><small>32</small></sup></a>
Then the connector will notify all of its participating
constraints except the constraint that requested the value to be set.
This is accomplished using the following iterator, which applies a
designated procedure to all items in a list except a given one:</p>

<p class="trans" lang="ja">
ã‚³ãƒã‚¯ã‚¿ã® <tt>set-my-value</tt> ã¨ã„ã†å±€æ‰€æ‰‹ç¶šãã¯ã€ã‚³ãƒã‚¯ã‚¿ã®å€¤ã‚’è¨­å®šã™ã‚‹ã‚ˆã†ã«ã€ã¨ã„ã†è¦æ±‚ãŒã‚ã‚‹ã¨ã€å‘¼ã³å‡ºã•ã‚Œã‚‹ã€‚
ã‚‚ã—ã€ã‚³ãƒã‚¯ã‚¿ãŒä»Šã®ã¨ã“ã‚å€¤ã‚’æŒã£ã¦ã„ãªã‘ã‚Œã°ã€ã‚³ãƒã‚¯ã‚¿ã¯è‡ªåˆ†ã®å€¤ã‚’è¨­å®šã—ã¦ã€ãã®å€¤ã‚’è¨­å®šã™ã‚‹ã‚ˆã†ã«è¦æ±‚ã—ãŸåˆ¶ç´„ã‚’ <tt>informant</tt> ã¨ã—ã¦è¨˜æ†¶ã—ã¦ãŠã<a href="#footnote_Temp_398"><sup><small>32</small></sup></a>ã€‚
ãã‚Œã‹ã‚‰ã€ã‚³ãƒã‚¯ã‚¿ã¯ã€ãã®å€¤ã‚’è¨­å®šã™ã‚‹ã‚ˆã†ã«è¦æ±‚ã—ãŸåˆ¶ç´„ã‚’é™¤ã„ã¦ã€è‡ªåˆ†ãŒå‚åŠ ã—ã¦ã„ã‚‹åˆ¶ç´„ã™ã¹ã¦ã«å¯¾ã—ã¦ã€é€šçŸ¥ã™ã‚‹ã ã‚ã†ã€‚
ã“ã‚Œã¯ã€ä»¥ä¸‹ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿â€”â€”ä¸ãˆã‚‰ã‚ŒãŸé …ç›®ã‚’é™¤ãã€ãƒªã‚¹ãƒˆå†…ã®ã™ã¹ã¦ã®é …ç›®ã«å¯¾ã—ã¦ã€æŒ‡å®šã•ã‚ŒãŸæ‰‹ç¶šãã‚’é©ç”¨ã™ã‚‹â€”â€”ã‚’ä½¿ã£ã¦ã€é”æˆã•ã‚Œã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_3548"></a>(define (for-each-except exception procedure list)
  (define (loop items)
    (cond ((null? items) 'done)
          ((eq? (car items) exception) (loop (cdr items)))
          (else (procedure (car items))
                (loop (cdr items)))))
  (loop list))
</p>

<p class="orig" lang="en">
If a connector is asked to forget its value, it runs the local
procedure <tt>forget-my-value</tt>, which first checks to make sure that
the request is coming from the same object that set the value
originally.  If so, the connector informs its associated constraints
about the loss of the value.
</p>

<p class="trans" lang="ja">
ã‚‚ã—ã‚³ãƒã‚¯ã‚¿ãŒã€å€¤ã‚’å¿˜ã‚Œã‚‹ã‚ˆã†ã«æ±‚ã‚ã‚‰ã‚ŒãŸã‚‰ã€ã‚³ãƒã‚¯ã‚¿ã¯ã€<tt>forget-my-value</tt> ã¨ã„ã†å±€æ‰€æ‰‹ç¶šãâ€”â€”ãã®æ±‚ã‚ãŒã€ãã®å€¤ã‚’æœ€åˆã«è¨­å®šã—ãŸã®ã¨åŒã˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰æ¥ã¦ã„ã‚‹ã®ã ã€ã¨ã„ã†ã“ã¨ã‚’ã€ã¾ãšç¢ºã‹ã‚ã‚‹â€”â€”ã‚’å®Ÿè¡Œã™ã‚‹ã€‚
ã‚‚ã—ãã†ãªã‚‰ã€ã‚³ãƒã‚¯ã‚¿ã¯ã€è‡ªåˆ†ã«é–¢é€£ã¥ã‘ã‚‰ã‚Œã¦ã„ã‚‹åˆ¶ç´„ã«å¯¾ã—ã¦ã€å€¤ã®å–ªå¤±ã‚’çŸ¥ã‚‰ã›ã‚‹ã€‚
</p>

<p class="orig" lang="en">
The local procedure <tt>connect</tt> adds the designated new constraint
to the list of constraints if it is not already in that list.  Then,
if the connector has a value, it informs the new constraint of this
fact.
</p>

<p class="trans" lang="ja">
<tt>connect</tt> ã¨ã„ã†å±€æ‰€æ‰‹ç¶šãã¯ã€æŒ‡å®šã•ã‚ŒãŸæ–°ãŸãªåˆ¶ç´„ã‚’ã€åˆ¶ç´„ã®ãƒªã‚¹ãƒˆã«ä»˜ã‘åŠ ãˆã‚‹â€”â€”ã‚‚ã—ãã®ãƒªã‚¹ãƒˆå†…ã«ãã®æ–°ãŸãªåˆ¶ç´„ãŒæ—¢ã«å­˜åœ¨ã—ã¦ã„ãªã‘ã‚Œã°ã€‚
ãã—ã¦ã€ã‚‚ã—ã‚³ãƒã‚¯ã‚¿ãŒå€¤ã‚’æŒã£ã¦ã„ã‚Œã°ã€<tt>connect</tt> ã¯ã€ã“ã®äº‹å®Ÿã‚’ãã®æ–°ãŸãªåˆ¶ç´„ã«çŸ¥ã‚‰ã›ã‚‹ã€‚
</p>

<p class="orig" lang="en">
The connector's procedure <tt>me</tt> serves as a dispatch to the other
internal procedures and also represents the connector as an object.
The following procedures provide a syntax interface for the dispatch:</p>

<p class="trans" lang="ja">
ã‚³ãƒã‚¯ã‚¿ã® <tt>me</tt> ã¨ã„ã†æ‰‹ç¶šãã¯ã€ä»–ã®å†…éƒ¨æ‰‹ç¶šãã¸ã®<ruby><rb>å‰²ã‚ŠæŒ¯ã‚Š</rb><rp> (</rp><rt>ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒ</rt><rp>) </rp></ruby>ã¨ã—ã¦ã¯ãŸã‚‰ãã€ã¾ãŸã€ã‚³ãƒã‚¯ã‚¿ã‚’ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦è¡¨ç¾ã™ã‚‹ã€‚
ä»¥ä¸‹ã®æ‰‹ç¶šãã¯ã€ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒã«å¯¾ã™ã‚‹æ§‹æ–‡ä¸Šã®ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ã‚¤ã‚¹ã‚’æä¾›ã™ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_3550"></a>(define (has-value? connector)
  (connector 'has-value?))
<a name="%_idx_3552"></a>(define (get-value connector)
  (connector 'value))
<a name="%_idx_3554"></a>(define (set-value! connector new-value informant)
  ((connector 'set-value!) new-value informant))
<a name="%_idx_3556"></a>(define (forget-value! connector retractor)
  ((connector 'forget) retractor))
<a name="%_idx_3558"></a>(define (connect connector new-constraint)
  ((connector 'connect) new-constraint))
</p>


<p class="orig" lang="en"><a name="%_thm_3.33"></a>
<b>Exercise 3.33.</b>  Using primitive multiplier, adder, and constant constraints, define a
procedure <a name="%_idx_3560"></a><tt>averager</tt> that takes three connectors <tt>a</tt>, <tt>b</tt>,
and <tt>c</tt> as inputs and establishes the constraint that the value of
<tt>c</tt> is the average of the values of <tt>a</tt> and <tt>b</tt>.
</p>


<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.33.</b> <tt>a</tt> ã¨ <tt>b</tt> ã¨ <tt>c</tt> ã¨ã„ã†ä¸‰ã¤ã®ã‚³ãƒã‚¯ã‚¿ã‚’å…¥åŠ›ã¨ã—ã¦ã¨ã‚Šã€<tt>c</tt> ã®å€¤ãŒ <tt>a</tt> ã¨ <tt>b</tt> ã®å€¤ã®å¹³å‡ã§ã‚ã‚‹ã¨ã„ã†åˆ¶ç´„ã‚’ç¢ºç«‹ã™ã‚‹ã€<tt>averager</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’ã€åŸå§‹çš„ãªä¹—ç®—å™¨åˆ¶ç´„ã¨åŠ ç®—å™¨åˆ¶ç´„ã¨å®šæ•°åˆ¶ç´„ã¨ã‚’ç”¨ã„ã¦ã€å®šç¾©ã›ã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en"><a name="%_thm_3.34"></a>
<b>Exercise 3.34.</b>  <a name="%_idx_3562"></a>Louis Reasoner wants to build a squarer, a constraint device with two
terminals such that the value of connector <tt>b</tt> on the second
terminal will always be the square of the value <tt>a</tt> on the first
terminal.  He proposes the following simple device made from a
multiplier:
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.34.</b> ãƒ«ã‚¤ã‚¹ãƒ»ãƒªãƒ¼ã‚ºãƒŠã¯ã€äºŒä¹—å™¨â€”â€”ã¤ã¾ã‚Šã€ç¬¬äºŒç«¯å­ä¸Šã® <tt>b</tt> ã¨ã„ã†ã‚³ãƒã‚¯ã‚¿ã®å€¤ãŒã€å¸¸ã«ã€ç¬¬ä¸€ç«¯å­ä¸Šã® <tt>a</tt> ã¨ã„ã†å€¤ã®äºŒä¹—ã¨ãªã‚‹ã‚ˆã†ãªã€äºŒç«¯å­ã®åˆ¶ç´„è£…ç½®â€”â€”ã‚’æ§‹ç¯‰ã—ãŸãŒã£ã¦ã„ã‚‹ã€‚
å½¼ã¯ã€ä¹—ç®—å™¨ã‹ã‚‰ä½œã‚‰ã‚ŒãŸã€ä»¥ä¸‹ã®ã‚ˆã†ãªç°¡å˜ãªè£…ç½®ã‚’ææ¡ˆã™ã‚‹ã€‚
</p>

<p class="lisp">(define (squarer a b)
  (multiplier a a b))
</p>

<p class="orig" lang="en">
There is a serious flaw in this idea.  Explain.
</p>

<p class="trans" lang="ja">
ã“ã®è€ƒãˆã«ã¯æ·±åˆ»ãªç‘•ç–µãŒã‚ã‚‹ã€‚èª¬æ˜ã›ã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>


<p class="orig" lang="en"><a name="%_thm_3.35"></a>
<b>Exercise 3.35.</b>  <a name="%_idx_3564"></a>Ben Bitdiddle tells Louis that one way to avoid the trouble in
exercise <a href="#%_thm_3.34">3.34</a> is to define a squarer as a new
primitive constraint.  Fill in the missing portions in Ben's outline
for a procedure to implement such a constraint:
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.35.</b> ç·´ç¿’å•é¡Œ<a href="#%_thm_3.34">3.34</a>ã§ã®å„ä»‹äº‹ã‚’é¿ã‘ã‚‹ãŸã‚ã®ä¸€ã¤ã®æ–¹æ³•ã¯ã€äºŒä¹—å™¨ã‚’æ–°ãŸãªåŸå§‹çš„åˆ¶ç´„ã¨ã—ã¦å®šç¾©ã™ã‚‹ã“ã¨ã§ã‚ã‚‹ã€ã¨ã€ãƒ™ãƒ³ãƒ»ãƒ“ãƒƒãƒˆãƒ‡ã‚£ãƒ‰ãƒ«ã¯ãƒ«ã‚¤ã‚¹ã«æ•™ãˆã‚‹ã€‚
ãã†ã„ã†åˆ¶ç´„ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã®æ‰‹ç¶šãã«ã¤ã„ã¦ã®ãƒ™ãƒ³ã«ã‚ˆã‚‹æ¦‚ç•¥ã®ä¸­ã®ã€æ¬ ã‘ã¦ã„ã‚‹éƒ¨åˆ†ã‚’åŸ‹ã‚ã‚ˆã€‚
</p>


<p class="lisp">(define (squarer a b)
  (define (process-new-value)
    (if (has-value? b)
        (if (&lt; (get-value b) 0)
            (error &quot;square less than 0 -- SQUARER&quot; (get-value b))
            &lt;<em>alternative1</em>&gt;)
        &lt;<em>alternative2</em>&gt;))
  (define (process-forget-value) &lt;<em>body1</em>&gt;)
  (define (me request) &lt;<em>body2</em>&gt;)
  &lt;<em>rest of definition</em>&gt;
  me)
</p>


<p class="exercise"><span class="ex_comment">
</span></p>


<p class="orig" lang="en"><a name="%_thm_3.36"></a>
<b>Exercise 3.36.</b>  Suppose we evaluate the following sequence of expressions in the
global environment:
</p>


<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.36.</b> å¤§åŸŸç’°å¢ƒå†…ã§ä»¥ä¸‹ã®ä¸€é€£ã®å¼ã‚’è©•ä¾¡ã™ã‚‹ã‚‚ã®ã¨æƒ³å®šã—ã‚ˆã†ã€‚
</p>

<p class="lisp">(define a (make-connector))
(define b (make-connector))
(set-value! a 10 'user)
</p>

<p class="orig" lang="en">
At some time during evaluation of the <tt>set-value!</tt>, the following
expression from the connector's local procedure is evaluated:
</p>

<p class="trans" lang="ja">
<tt>set-value!</tt> ã®è©•ä¾¡ã®æœ€ä¸­ã®ã‚ã‚‹æ™‚ç‚¹ã«ãŠã„ã¦ã€ã‚³ãƒã‚¯ã‚¿ã®å±€æ‰€æ‰‹ç¶šãã‹ã‚‰ã®ä»¥ä¸‹ã®å¼ãŒã€è©•ä¾¡ã•ã‚Œã‚‹ã€‚
</p>

<p class="lisp">(for-each-except setter inform-about-value constraints)
</p>

<p class="orig" lang="en">
Draw an environment diagram showing the environment in which the above
expression is evaluated.
</p>

<p class="trans" lang="ja">
ä¸Šè¨˜ã®å¼ãŒè©•ä¾¡ã•ã‚Œã‚‹ç’°å¢ƒã‚’ç¤ºã™ç’°å¢ƒå›³ã‚’æã‘ã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>


<p class="orig" lang="en"><a name="%_thm_3.37"></a>
<b>Exercise 3.37.</b>  The <tt>celsius-fahrenheit-converter</tt> procedure is cumbersome when
compared with a more expression-oriented style of definition, such as
</p>


<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ3.37.</b> <tt>celsius-fahrenheit-converter</tt> ã®æ‰‹ç¶šãã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ãªã€ã‚ˆã‚Šå¼æŒ‡å‘ã®æ§˜å¼ã®å®šç¾©ã¨æ¯”ã¹ã‚‹ã¨ã€ã‚„ã‚„ã“ã—ãã¦éåŠ¹ç‡ã§ã‚ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_3566"></a>(define (celsius-fahrenheit-converter x)
  (c+ (c* (c/ (cv 9) (cv 5))
          x)
      (cv 32)))
(define C (make-connector))
(define F (celsius-fahrenheit-converter C))
</p>

<p class="orig" lang="en">
Here <tt>c+</tt>, <tt>c*</tt>, etc. are the ``constraint'' versions of the
arithmetic operations.  For example, <tt>c+</tt> takes two connectors as
arguments and returns a connector that is related to these by an adder
constraint:
</p>

<p class="trans" lang="ja">
ã“ã“ã§ã€<tt>c+</tt> ã‚„ <tt>c*</tt> ãªã©ã¯ã€ç®—è¡“æ¼”ç®—ã®ã€Œåˆ¶ç´„ã€ç‰ˆã§ã‚ã‚‹ã€‚
ãŸã¨ãˆã°ã€<tt>c+</tt> ã¯ã€äºŒã¤ã®ã‚³ãƒã‚¯ã‚¿ã‚’å¼•æ•°ã¨ã—ã¦ã¨ã‚Šã€ãã—ã¦ã€åŠ ç®—å™¨åˆ¶ç´„ã«ã‚ˆã£ã¦ã“ã‚Œã‚‰ã®ã‚³ãƒã‚¯ã‚¿ã«é–¢é€£ã¥ã‘ã‚‰ã‚Œã¦ã„ã‚‹ã‚³ãƒã‚¯ã‚¿ã‚’è¿”ã™ã€‚
</p>

<p class="lisp">(define (c+ x y)
  (let ((z (make-connector)))
    (adder x y z)
    z))
</p>

<p class="orig" lang="en">
Define analogous procedures <tt>c-</tt>, <tt>c*</tt>, <tt>c/</tt>, and <tt>cv</tt>
(constant value) that enable us to define compound constraints as in
the converter example above.<a name="call_footnote_Temp_404" href="#footnote_Temp_404"><sup><small>33</small></sup></a>
</p>

<p class="trans" lang="ja">
ä¸Šè¨˜ã®å¤‰æ›å™¨ã®äº‹ä¾‹ã«ãŠã‘ã‚‹ã‚ˆã†ãªè¤‡åˆçš„åˆ¶ç´„ã‚’å®šç¾©ã§ãã‚‹ã‚ˆã†ã«ã—ã¦ãã‚Œã‚‹ã€<tt>c-</tt> ã¨ <tt>c*</tt> ã¨ <tt>c/</tt> ã¨ <tt>cv</tt> (å®šæ•°å€¤) ã¨ã„ã†ã€åŒæ§˜ã®æ‰‹ç¶šãã‚’å®šç¾©ã›ã‚ˆ<a href="#footnote_Temp_404"><sup><small>33</small></sup></a>ã€‚
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="footnotes"></a>
<hr>

<p class="orig" lang="en"><a name="footnote_Temp_349" href="#call_footnote_Temp_349"><sup><small>16</small></sup></a> <tt>Set-car!</tt> and <tt>set-cdr!</tt> return implementation-dependent
<a name="%_idx_3148"></a><a name="%_idx_3150"></a><a name="%_idx_3152"></a><a name="%_idx_3154"></a>values.  Like <tt>set!</tt>, they should be used only for their effect.
</p>

<p class="trans" lang="ja">
<tt>set-car!</tt> ã¨ <tt>set-cdr!</tt> ã¯ã€å®Ÿè£…ä¾å­˜ã®å€¤ã‚’è¿”ã™ã€‚
ã“ã‚Œã‚‰ã¯ã€<tt>set!</tt> ã¨åŒæ§˜ã€ãã®ä½œç”¨ã®ãŸã‚ã«ã ã‘ä½¿ã‚ã‚Œã‚‹ã¹ãã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_350" href="#call_footnote_Temp_350"><sup><small>17</small></sup></a> We see from this that mutation operations on lists
can create ``garbage'' that is not part of any accessible structure.
We will see in section <a href="33_sec5_3.html#%_sec_5.3.2">5.3.2</a> that Lisp memory-management
systems include a <a name="%_idx_3156"></a><em>garbage collector</em>, which identifies and
recycles the memory space used by unneeded pairs.
</p>

<p class="trans" lang="ja">
ãƒªã‚¹ãƒˆã«å¯¾ã™ã‚‹å¤‰æ›´æ“ä½œãŒã€ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ãªã„ã‹ãªã‚‹æ§‹é€ ã®ä¸€éƒ¨ã§ã‚‚ãªã„ã‚ˆã†ãªã€Œã”ã¿ã€ã‚’ä½œã‚Šå‡ºã™ã“ã¨ãŒã‚ã‚Šå¾—ã‚‹ã€ã¨ã„ã†ã“ã¨ãŒã€ã“ã®ã“ã¨ã‹ã‚‰åˆ†ã‹ã‚‹ã€‚
<a href="33_sec5_3.html#%_sec_5.3.2">5.3.2</a>ç¯€ã§ã¯ã€Lispã®ãƒ¡ãƒ¢ãƒªç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ãŒ<em><ruby><rb>ã‚¬ãƒ¼ãƒ™ã‚¸ãƒ»ã‚³ãƒ¬ã‚¯ã‚¿</rb><rp> (</rp><rt>ã”ã¿ã‚ã¤ã‚ã‚’ã™ã‚‹ã‚‚ã®</rt><rp>) </rp></ruby></em>â€”â€”ä¸å¿…è¦ãªå¯¾ã«ã‚ˆã‚Šä½¿ã‚ã‚Œã¦ã„ã‚‹ãƒ¡ãƒ¢ãƒªç©ºé–“ã‚’ç‰¹å®šã—ã¦å†åˆ©ç”¨ã™ã‚‹â€”â€”ã‚’å«ã‚€ã€ã¨ã„ã†ã“ã¨ã‚’è¦‹ã‚‹ã“ã¨ã«ã—ã‚ˆã†ã€‚
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_351" href="#call_footnote_Temp_351"><sup><small>18</small></sup></a> <tt>Get-new-pair</tt> is one of the operations that must be implemented as
part of the memory management required by a Lisp implementation.  We
will discuss this in section <a href="33_sec5_3.html#%_sec_5.3.1">5.3.1</a>.
</p>

<p class="trans" lang="ja">
<tt>get-new-pair</tt> ã¯ã€Lispã®å®Ÿè£…ã«ã‚ˆã£ã¦å¿…è¦ã¨ã•ã‚Œã‚‹ãƒ¡ãƒ¢ãƒªç®¡ç†ã®ä¸€éƒ¨ã¨ã—ã¦å®Ÿè£…ã•ã‚Œã­ã°ãªã‚‰ãªã„æ¼”ç®—ã®ã†ã¡ã®ä¸€ã¤ã§ã‚ã‚‹ã€‚
ã“ã‚Œã«ã¤ã„ã¦ã¯ã€<a href="33_sec5_3.html#%_sec_5.3.1">5.3.1</a>ç¯€ã§è­°è«–ã—ã‚ˆã†ã€‚
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_356" href="#call_footnote_Temp_356"><sup><small>19</small></sup></a> The two pairs
are distinct because each call to <tt>cons</tt> returns a new pair.  The
symbols are shared; in Scheme there is a unique symbol with any given
<a name="%_idx_3184"></a>name.  Since Scheme provides no way to mutate a symbol, this sharing is
undetectable.  Note also that the sharing is what enables us to
compare symbols using <tt>eq?</tt>, which simply checks equality of
pointers.
</p>

<p class="trans" lang="ja">
<tt>cons</tt> ã«å¯¾ã™ã‚‹ãã‚Œãã‚Œã®å‘¼ã³å‡ºã—ãŒæ–°ãŸãªå¯¾ã‚’è¿”ã—ã¦ã„ã‚‹ã®ã§ã€ã“ã‚Œã‚‰ã®äºŒã¤ã®å¯¾ã¯åˆ¥å€‹ã®ã‚‚ã®ã§ã‚ã‚‹ã€‚
è¨˜å·ã¯å…±æœ‰ã•ã‚Œã¦ã„ã‚‹ã€‚Schemeã§ã¯ã€ä¸ãˆã‚‰ã‚ŒãŸä»»æ„ã®åå‰ã«ã¤ã„ã¦ã€ä¸€æ„ãªè¨˜å·ãŒå­˜åœ¨ã™ã‚‹ã®ã ã€‚
è¨˜å·ã‚’å¤‰æ›´ã™ã‚‹æ–¹æ³•ã‚’Schemeã¯ä½•ã‚‚æä¾›ã—ãªã„ã®ã§ã€ã“ã†ã—ãŸå…±æœ‰ã¯æ¤œå‡ºä¸èƒ½ã§ã‚ã‚‹ã€‚
ã¾ãŸã€å…±æœ‰ã“ããŒã€<tt>eq?</tt> â€”â€”å˜ã«ãƒã‚¤ãƒ³ã‚¿åŒå£«ã®ç­‰ä¾¡æ€§ã‚’èª¿ã¹ã‚‹â€”â€”ã‚’ä½¿ã£ã¦è¨˜å·åŒå£«ã‚’æ¯”è¼ƒã§ãã‚‹ã‚ˆã†ã«ã—ã¦ãã‚Œã‚‹ã®ã ã€ã¨ã„ã†ã“ã¨ã«ã‚‚æ³¨æ„ã›ã‚ˆã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_357" href="#call_footnote_Temp_357"><sup><small>20</small></sup></a> The
subtleties of dealing with sharing of mutable data objects reflect the
underlying issues of ``sameness'' and ``change'' that were raised in
section <a href="20_sec3_1.html#%_sec_3.1.3">3.1.3</a>.  We mentioned there that
admitting change to our language requires that a compound object must
have an ``identity'' that is something different from the pieces from
which it is composed.  In Lisp, we consider this ``identity'' to be
the quality that is tested by <tt>eq?</tt>, i.e., by equality of
pointers.  Since in most Lisp implementations a pointer is
essentially a memory address, we are ``solving the problem'' of
defining the identity of objects by stipulating that a data object
``itself'' is the information stored in some particular set of memory
locations in the computer.  This suffices for simple Lisp programs,
but is hardly a general way to resolve the issue of ``sameness'' in
computational models.
</p>

<p class="trans" lang="ja">
å¤‰æ›´å¯èƒ½ãªãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å…±æœ‰ã‚’å–ã‚Šæ‰±ã†ã“ã¨ã®æ©Ÿå¾®ã¯ã€<a href="20_sec3_1.html#%_sec_3.1.3">3.1.3</a>ç¯€ã§æèµ·ã•ã‚ŒãŸã€ã€ŒåŒä¸€æ€§ã€ã¨ã€Œå¤‰åŒ–ã€ã«ã¤ã„ã¦ã®ã€è£ã«æ½œã‚“ã§ã„ã‚‹è«–ç‚¹ã‚’åæ˜ ã—ã¦ã„ã‚‹ã€‚
ãã“ã§ã¯ã€ã“ã†è¿°ã¹ãŸã€‚ã™ãªã‚ã¡ã€ç§ãŸã¡ã®è¨€èªã«å¯¾ã—ã¦å¤‰åŒ–ã‚’æŒã¡è¾¼ã‚€ã“ã¨ã‚’å®¹èªã™ã‚‹ã“ã¨ã¯ã€è¤‡åˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã€ãã®è¤‡åˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ§‹æˆã™ã‚‹å…ƒã¨ãªã£ã¦ã„ã‚‹è«¸éƒ¨åˆ†ã¨ã¯ç•°ãªã‚‹ä½•ã‹ã§ã‚ã‚‹ã‚ˆã†ãªã€Œè‡ªå·±åŒä¸€æ€§ã€ã‚’æŒãŸãªãã¦ã¯ãªã‚‰ãªã„ã€ã¨ã„ã†ã“ã¨ã‚’å¿…è¦ã¨ã™ã‚‹ã®ã ã€ã¨ã€‚
Lispã§ã¯ã€ã“ã®ã€Œè‡ªå·±åŒä¸€æ€§ã€ã®ã“ã¨ã‚’ã€<tt>eq?</tt> ã«ã‚ˆã£ã¦â€”â€”ã¤ã¾ã‚Šã€ãƒã‚¤ãƒ³ã‚¿åŒå£«ã®åŒä¸€æ€§ã«ã‚ˆã£ã¦â€”â€”æ¤œæŸ»ã•ã‚Œã‚‹ç‰¹è³ªã§ã‚ã‚‹ã€ã¨è€ƒãˆã‚‹ã€‚
ã»ã¨ã‚“ã©ã®Lispå‡¦ç†ç³»ã«ãŠã„ã¦ã€ãƒã‚¤ãƒ³ã‚¿ã¯ã€æœ¬è³ªçš„ã«ã¯ãƒ¡ãƒ¢ãƒªã‚¢ãƒ‰ãƒ¬ã‚¹ã§ã‚ã‚‹ãŸã‚ã€ç§ãŸã¡ã¯ã€ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€Œãã‚Œè‡ªä½“ã€ã¨ã¯ã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿å†…ã®ã€ã‚ã‚‹ç‰¹å®šã®ä¸€ç¾¤ã®ãƒ¡ãƒ¢ãƒªä½ç½®ã«æ ¼ç´ã•ã‚Œã¦ã„ã‚‹æƒ…å ±ã§ã‚ã‚‹ã€ã¨è¦å®šã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®è‡ªå·±åŒä¸€æ€§ã‚’å®šç¾©ã™ã‚‹ã¨ã„ã†ã€Œå•é¡Œã‚’è§£æ±ºã€ã—ã¦ã„ã‚‹ã€‚
ã“ã‚Œã¯ã€å˜ç´”ãªLispãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ã¨ã£ã¦ã¯ååˆ†ã§ã‚ã‚‹ãŒã€è¨ˆç®—ãƒ¢ãƒ‡ãƒ«ã«ãŠã‘ã‚‹ã€ŒåŒä¸€æ€§ã€ã®è«–ç‚¹ã‚’è§£æ¶ˆã™ã‚‹ãŸã‚ã®ä¸€èˆ¬çš„ãªæ–¹æ³•ãªã©ã§ã¯åˆ°åº•ãªã„ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_364" href="#call_footnote_Temp_364"><sup><small>21</small></sup></a> On the other hand, from the
viewpoint of implementation, assignment requires us to modify the
environment, which is itself a mutable data structure.  Thus,
assignment and mutation are equipotent: Each can be implemented in
terms of the other.
</p>

<p class="trans" lang="ja">
ä¸€æ–¹ã§ã€å®Ÿè£…ã®è¦³ç‚¹ã‹ã‚‰ã¯ã€<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã¯ç§ãŸã¡ã«å¯¾ã—ã¦ã€ç’°å¢ƒâ€”â€”ãã‚Œè‡ªä½“ãŒå¤‰æ›´ã‹ã®ã†ãªãƒ‡ãƒ¼ã‚¿æ§‹é€ ã§ã‚ã‚‹â€”â€”ã‚’ä¿®æ­£ã™ã‚‹ã‚ˆã†ã«æ±‚ã‚ã¦ãã‚‹ã€‚ã‚ˆã£ã¦ã€<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã¨<ruby><rb>å¤‰æ›´</rb><rp> (</rp><rt>ãƒŸãƒ¥ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³</rt><rp>) </rp></ruby>ã¯ã€åŒã˜åŠ¹åŠ›ãŒã‚ã‚‹ã€‚
ã¤ã¾ã‚Šã€å„ã€…ãŒã€ä»–æ–¹ã‚’ç”¨ã„ã¦å®Ÿè£…ã™ã‚‹ã“ã¨ãŒå¯èƒ½ãªã®ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_366" href="#call_footnote_Temp_366"><sup><small>22</small></sup></a> If the first item is
the final item in the queue, the front pointer will be the empty list after
the deletion, which will mark the queue as empty; we needn't worry
about updating the rear pointer, which will still point to the deleted
item, because <tt>empty-queue?</tt> looks only at the front pointer.
</p>

<p class="trans" lang="ja">
ã‚‚ã—ã€ã‚­ãƒ¥ãƒ¼ã«ãŠã„ã¦æœ€åˆã®é …ç›®ãŒæœ€å¾Œã®é …ç›®ã§ã‚ã£ãŸãªã‚‰ã€ãã®å‰Šé™¤ã®å¾Œã«ã¯ã€å…ˆé ­ãƒã‚¤ãƒ³ã‚¿ã¯ç©ºãƒªã‚¹ãƒˆã¨ãªã‚‹ã ã‚ã†ã—ã€ãã‚Œã«ã‚ˆã£ã¦ã‚­ãƒ¥ãƒ¼ã¯ã€ç©ºã§ã‚ã‚‹ã€ã¨ç¤ºã•ã‚Œã‚‹ã ã‚ã†ã€‚
æœ«å°¾ãƒã‚¤ãƒ³ã‚¿â€”â€”å‰Šé™¤ã•ã‚ŒãŸé …ç›®ã‚’ä¾ç„¶ã¨ã—ã¦æŒ‡ã™â€”â€”ã‚’æ›´æ–°ã™ã‚‹ã“ã¨ã«ã¤ã„ã¦ã¯ã€å¿ƒé…ã™ã‚‹å¿…è¦ãŒãªã„ã€‚ãªãœãªã‚‰ã€<tt>empty-queue?</tt> ã¯å…ˆé ­ãƒã‚¤ãƒ³ã‚¿ã®ã¿ã‚’è¦‹ã‚‹ã‹ã‚‰ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_370" href="#call_footnote_Temp_370"><sup><small>23</small></sup></a> Be careful not to
make the interpreter try to print a structure that contains cycles.
(See exercise <a href="#%_thm_3.13">3.13</a>.)
</p>

<p class="trans" lang="ja">
å¾ªç’°ã‚’å«ã‚€æ§‹é€ ã‚’å°å­—ã—ã‚ˆã†ã€ã¨ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«è©¦ã¿ã•ã›ãªã„ã‚ˆã†ã«ã€æ°—ã‚’ã¤ã‘ãŸã¾ãˆ (ç·´ç¿’å•é¡Œ<a href="#%_thm_3.13">3.13</a>ã‚’å‚ç…§)ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_371" href="#call_footnote_Temp_371"><sup><small>24</small></sup></a> Because <tt>assoc</tt>
uses <tt>equal?</tt>, it can recognize keys that are symbols, numbers,
or list structure.
</p>

<p class="trans" lang="ja">
<tt>assoc</tt> ã¯ã€<tt>equal?</tt> ã‚’ä½¿ã†ã®ã§ã€è¨˜å·ã€æ•°ã€ã¾ãŸã¯ãƒªã‚¹ãƒˆæ§‹é€ ã§ã‚ã‚‹ã‚ˆã†ãªã‚­ãƒ¼ã‚’ã€èªè­˜ã§ãã‚‹ã®ã ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_372" href="#call_footnote_Temp_372"><sup><small>25</small></sup></a> Thus, the first backbone pair is the
object that represents the table ``itself''; that is, a pointer to the
table is a pointer to this pair.  This same backbone pair always
starts the table.  If we did not arrange things in this way, <tt>insert!</tt> would have to return a new value for the start of the table
when it added a new record.
</p>

<p class="trans" lang="ja">
ã‚ˆã£ã¦ã€æœ€åˆã®èƒŒéª¨ã®å¯¾ã¯ã€ãƒ†ãƒ¼ãƒ–ãƒ«ã€Œãã‚Œè‡ªä½“ã€ã‚’è¡¨ã™ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚‹ã€‚ã¤ã¾ã‚Šã€ãƒ†ãƒ¼ãƒ–ãƒ«ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã¯ã€ã“ã®å¯¾ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã§ã‚ã‚‹ã€‚
ã“ã®åŒã˜èƒŒéª¨å¯¾ãŒã€å¸¸ã«ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’é–‹å§‹ã•ã›ã‚‹ã®ã§ã‚ã‚‹ã€‚
ã‚‚ã—ã€ã“ã®ã‚ˆã†ãªã‚„ã‚Šæ–¹ã§ã‚‚ã®ã”ã¨ã®æ‰‹ç­ˆã‚’æ•´ãˆãŸã®ã§ãªã‹ã£ãŸã‚‰ã€<tt>insert!</tt> ã¯ã€æ–°ãŸãªãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’è¿½åŠ ã—ãŸã¨ãã«ã€ãƒ†ãƒ¼ãƒ–ãƒ«ã®é–‹å§‹ç‚¹ã®ãŸã‚ã®æ–°ãŸãªå€¤ã‚’è¿”ã•ãªãã¦ã¯ãªã‚‰ãªã‹ã£ãŸã“ã¨ã ã‚ã†ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_379" href="#call_footnote_Temp_379"><sup><small>26</small></sup></a> A
full-adder is a basic circuit element used in adding two binary
numbers.  Here A and B are the bits at corresponding positions in the
two numbers to be added, and C<sub><em>i</em><em>n</em></sub> is the carry bit from the
addition one place to the right.  The circuit generates SUM, which is
the sum bit in the corresponding position, and C<sub><em>o</em><em>u</em><em>t</em></sub>, which is the
carry bit to be propagated to the left.
</p>

<p class="trans" lang="ja">
ãƒ•ãƒ«ãƒ»ã‚¢ãƒ€ãƒ¼ã¯ã€äºŒã¤ã®2é€²æ•°ã‚’è¶³ã™éš›ã«ä½¿ã‚ã‚Œã‚‹ã€åŸºæœ¬çš„å›è·¯è¦ç´ ã§ã‚ã‚‹ã€‚
ã“ã“ã§ã€A ã¨ B ã¯ã€è¶³ã•ã‚Œã‚‹ã¹ãäºŒã¤ã®æ•°ã«ãŠã‘ã‚‹ã€å¯¾å¿œã™ã‚‹ä½ç½®ã«ã‚ã‚‹ãƒ“ãƒƒãƒˆã§ã‚ã‚Šã€ C<sub><em class="en">in</em></sub> ã¯ã€ä¸€ã¤ã¶ã‚“å³å´ã®ä½ç½®ã§ã®åŠ ç®—ã‹ã‚‰ã®<ruby><rb>ç¹°ã‚Šä¸ŠãŒã‚Š</rb><rp> (</rp><rt>ã‚­ãƒ£ãƒªãƒ¼</rt><rp>) </rp></ruby>ã§ã‚ã‚‹ã€‚
ã“ã®å›è·¯ã¯ã€SUM â€”â€”å¯¾å¿œã™ã‚‹ä½ç½®ã«ãŠã‘ã‚‹å’Œã®ãƒ“ãƒƒãƒˆâ€”â€”ã¨ã€C<sub><em class="en">out</em></sub> â€”â€”å·¦ã«ä¼æ’­ã™ã¹ãã‚­ãƒ£ãƒªãƒ¼ãƒ»ãƒ“ãƒƒãƒˆâ€”â€”ã¨ã‚’ç”Ÿæˆã™ã‚‹ã€‚
</p>


<p class="orig" lang="en"><a name="footnote_Temp_385" href="#call_footnote_Temp_385"><sup><small>27</small></sup></a> These procedures are simply syntactic sugar that allow
<a name="%_idx_3400"></a><a name="%_idx_3402"></a>us to use ordinary procedural syntax to access the local procedures of
objects.  It is striking that we can interchange the role of
``procedures'' and ``data'' in such a simple way.  For example, if we
write <tt>(wire 'get-signal)</tt> we think of <tt>wire</tt> as a procedure
that is called with the message <tt>get-signal</tt> as input.
Alternatively, writing <tt>(get-signal wire)</tt> encourages us to think
of <tt>wire</tt> as a data object that is the input to a procedure <tt>get-signal</tt>.  The truth of the matter is that, in a language in which
we can deal with procedures as objects, there is no fundamental
difference between ``procedures'' and ``data,'' and we can choose our
syntactic sugar to allow us to program in whatever style we choose.
</p>

<p class="trans" lang="ja">
ã“ã‚Œã‚‰ã®æ‰‹ç¶šãã¯ã€æ™®é€šã®æ‰‹ç¶šãçš„ãªæ§‹æ–‡ã‚’ä½¿ã£ã¦ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å±€æ‰€æ‰‹ç¶šãã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã‚ˆã†ã«ã—ã¦ãã‚Œã‚‹ã€å˜ãªã‚‹ç³–è¡£æ§‹æ–‡ã§ã‚ã‚‹ã€‚
ã“ã†ã—ãŸå˜ç´”ãªæ–¹æ³•ã§ã€Œæ‰‹ç¶šãã€ã¨ã€Œãƒ‡ãƒ¼ã‚¿ã€ã®å½¹å‰²ã‚’äº¤æ›ã§ãã‚‹ã“ã¨ã¯ã€é­…åŠ›çš„ã§ã‚ã‚‹ã€‚
ãŸã¨ãˆã°ã€<tt>(wire 'get-signal)</tt> ã¨æ›¸ãã¨ãã€ç§ãŸã¡ã¯ã€<tt>wire</tt> ã‚’ã€å…¥åŠ›ã¨ã—ã¦ã® <tt>get-signal</tt> ã¨ã„ã†ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨ã¨ã‚‚ã«å‘¼ã°ã‚Œã‚‹æ‰‹ç¶šãã ã€ã¨è¦‹ãªã—ã¦ã„ã‚‹ã€‚
ãã®ä»£ã‚ã‚Šã€<tt>(get-signal wire)</tt> ã¨æ›¸ãã“ã¨ã§ã€ç§ãŸã¡ã¯ã€<tt>wire</tt> ã‚’ã€<tt>get-signal</tt> ã¨ã„ã†æ‰‹ç¶šãã¸ã®å…¥åŠ›ã§ã‚ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã ã€ã¨è¦‹ãªã™ã‚ˆã†ã«ä»•å‘ã‘ã‚‰ã‚Œã‚‹ã®ã§ã‚ã‚‹ã€‚
å®Ÿã‚’è¨€ã†ã¨ã€æ‰‹ç¶šãã‚’ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦æ‰±ãˆã‚‹è¨€èªã«ãŠã„ã¦ã¯ã€ã€Œæ‰‹ç¶šãã€ã¨ã€Œãƒ‡ãƒ¼ã‚¿ã€ã®é–“ã«æ ¹æœ¬çš„ãªé•ã„ãªã©ãªã„ã—ã€ç§ãŸã¡ã¯ã€è‡ªåˆ†ãŒé¸ã¶ã©ã®ã‚ˆã†ãªæµå„€ã§ã‚‚ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’çµ„ã‚ã‚‹ã‚ˆã†ã«ã—ã¦ãã‚Œã‚‹ã€è‡ªåˆ†ã®ç³–è¡£æ§‹æ–‡ã‚’é¸ã¹ã‚‹ã®ã ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_390" href="#call_footnote_Temp_390"><sup><small>28</small></sup></a> The
agenda is a <a name="%_idx_3452"></a><a name="%_idx_3454"></a>headed list, like the tables in section <a href="#%_sec_3.3.3">3.3.3</a>,
but since the list is headed by the time, we do not need an additional
dummy header (such as the <tt>*table*</tt> symbol used with tables).
</p>

<p class="trans" lang="ja">
ã‚¢ã‚¸ã‚§ãƒ³ãƒ€ã¯ã€<a href="#%_sec_3.3.3">3.3.3</a>ç¯€ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã¨åŒæ§˜ã«é ­ã¤ãã®ãƒªã‚¹ãƒˆã ãŒã€ãƒªã‚¹ãƒˆã®é ­ã«æ™‚åˆ»ãŒä»˜ã„ã¦ã„ã‚‹ãŸã‚ã€è¿½åŠ çš„ãªãƒ€ãƒŸãƒ¼ã®ãƒ˜ãƒƒãƒ€ (ãƒ†ãƒ¼ãƒ–ãƒ«ã¨ã¨ã‚‚ã«ä½¿ã£ãŸã€<tt>*table*</tt> ã¨ã„ã†è¨˜å·ãªã©) ã¯ä¸è¦ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_391" href="#call_footnote_Temp_391"><sup><small>29</small></sup></a> Observe that the <tt>if</tt> expression in
this procedure has no
&lt;<em>alternative</em>&gt; expression.  Such a ``one-armed <tt>if</tt> statement''
<a name="%_idx_3474"></a><a name="%_idx_3476"></a>is used to decide whether to do something, rather than to select
between two expressions.  An <tt>if</tt> expression returns an
unspecified value if the predicate is false and there is no
&lt;<em>alternative</em>&gt;.
</p>

<p class="trans" lang="ja">
ã“ã®æ‰‹ç¶šãã§ã® <tt>if</tt> å¼ã«ã¯ &lt;<em class="en">alternative</em>&gt; å¼ãŒãªã„ã“ã¨ã«æ°—ã¥ã„ã¦ã»ã—ã„ã€‚
ã“ã®ã‚ˆã†ãªã€Œç‰‡è…•ã® <tt>if</tt> æ–‡ã€ã¯ã€äºŒã¤ã®å¼ã®é–“ã§é¸æŠã‚’è¡Œã†ãŸã‚ã€ã¨ã„ã†ã‚ˆã‚Šã‚‚ã‚€ã—ã‚ã€ä½•ã‹ã‚’ã™ã¹ãã‹ã©ã†ã‹ã‚’æ±ºã‚ã‚‹ãŸã‚ã«ã€ä½¿ã‚ã‚Œã‚‹ã€‚
<tt>if</tt> å¼ã¯ã€ã‚‚ã—è¿°èªãŒå½ã§ã€ã‹ã¤ã€&lt;<em class="en">alternative</em>&gt; ãŒãªã‘ã‚Œã°ã€ä¸ç‰¹å®šã®å€¤ã‚’è¿”ã™ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_392" href="#call_footnote_Temp_392"><sup><small>30</small></sup></a> In this way, the current time will always be the time
of the action most recently processed.  Storing this time at the head
of the agenda ensures that it will still be available even if the
associated time segment has been deleted.
</p>

<p class="trans" lang="ja">
ã“ã®ã‚„ã‚Šæ–¹ã§ã€ç¾åœ¨æ™‚åˆ»ã¯å¸¸ã«ã€ä¸€ç•ªæœ€è¿‘ã«å‡¦ç†ã•ã‚ŒãŸå‹•ä½œã®æ™‚åˆ»ã«ãªã‚‹ã ã‚ã†ã€‚
ã“ã®æ™‚åˆ»ã‚’ã‚¢ã‚¸ã‚§ãƒ³ãƒ€ã®å…ˆé ­ã«è¨˜æ†¶ã™ã‚‹ã“ã¨ã§ã€é–¢é€£ã¥ã‘ã‚‰ã‚ŒãŸæ™‚é–“åŒºåˆ†ãŒå‰Šé™¤ã•ã‚Œã¦ã•ãˆã€ãã®æ™‚åˆ»ãŒä¾ç„¶ã¨ã—ã¦åˆ©ç”¨å¯èƒ½ã§ã‚ã‚‹ã ã‚ã†ã€ã¨ã„ã†ã“ã¨ãŒç¢ºå®Ÿã«ãªã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_394" href="#call_footnote_Temp_394"><sup><small>31</small></sup></a> Constraint propagation
first appeared in the incredibly forward-looking <a name="%_idx_3486"></a>SKETCHPAD system of
<a name="%_idx_3488"></a>Ivan Sutherland (1963).  A beautiful constraint-propagation system
based on the <a name="%_idx_3490"></a>Smalltalk language was developed by <a name="%_idx_3492"></a>Alan Borning (1977)
at <a name="%_idx_3494"></a>Xerox Palo Alto Research Center.  Sussman, Stallman, and Steele
<a name="%_idx_3496"></a><a name="%_idx_3498"></a><a name="%_idx_3500"></a><a name="%_idx_3502"></a><a name="%_idx_3504"></a><a name="%_idx_3506"></a>applied constraint propagation to electrical circuit analysis (Sussman
and Stallman 1975; Sussman and Steele 1980). TK!Solver (Konopasek and
Jayaraman 1984) is an extensive modeling environment based on
constraints.
</p>

<p class="trans" lang="ja">åˆ¶ç´„ä¼æ’­ã¯ã€ä¿¡ã˜ãŒãŸã„ãã‚‰ã„å…ˆé€²çš„ãªã€Ivan Sutherland (1963) ã® SKETCHPAD ã‚·ã‚¹ãƒ†ãƒ ã«ã€æœ€åˆã«ç™»å ´ã—ãŸã€‚
Smalltalk è¨€èªã«åŸºã¥ãã€ã™ã°ã‚‰ã—ã„åˆ¶ç´„ä¼æ’­ã‚·ã‚¹ãƒ†ãƒ ã¯ã€Alan Borning (1977) ã«ã‚ˆã‚Šã€Xerox Palo Alto Research Center ã«ãŠã„ã¦é–‹ç™ºã•ã‚ŒãŸã€‚
Sussman ã¨ Stallman ã¨ Steele ã¯ã€åˆ¶ç´„ä¼æ’­ã‚’é›»å­å›è·¯åˆ†æã«é©ç”¨ã—ãŸ (Sussman and Stallman 1975; Sussman and Steele 1980)ã€‚
TK!Solver (Konopasek and Jayaraman 1984) ã¯ã€åˆ¶ç´„ã«åŸºã¥ãå¤§è¦æ¨¡ãƒ¢ãƒ‡ãƒ«åŒ–ç’°å¢ƒã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_398" href="#call_footnote_Temp_398"><sup><small>32</small></sup></a> The <tt>setter</tt> might not be a constraint.  In our
temperature example, we used <tt>user</tt> as the <tt>setter</tt>.
</p>

<p class="trans" lang="ja">
<tt>setter</tt> ã¯åˆ¶ç´„ã§ã¯ãªã„ã‹ã‚‚ã—ã‚Œãªã„ã€‚
ç§ãŸã¡ã®æ¸©åº¦ã®äº‹ä¾‹ã§ã¯ã€<tt>user</tt> ã‚’ <tt>setter</tt> ã¨ã—ã¦ä½¿ã£ãŸã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_404" href="#call_footnote_Temp_404"><sup><small>33</small></sup></a> The expression-oriented format
is convenient because it avoids the need to name the intermediate
expressions in a computation.  Our original formulation of the
<a name="%_idx_3568"></a><a name="%_idx_3570"></a><a name="%_idx_3572"></a><a name="%_idx_3574"></a><a name="%_idx_3576"></a>constraint language is cumbersome in the same way that many languages
are cumbersome when dealing with operations on compound data.  For
example, if we wanted to compute the product (<em>a</em> + <em>b</em>) &middot; (<em>c</em> + <em>d</em>), where the
variables represent vectors, we could work in ``imperative style,''
using procedures that set the values of designated vector arguments
but do not themselves return vectors as values:
</p>

<p class="trans" lang="ja">
å¼æŒ‡å‘ã®å½¢å¼ã¯ã€ã“ã®å½¢å¼ã«ã‚ˆã‚Šã€è¨ˆç®—ä¸­ã®ä¸­é–“ã®å¼ã«åå‰ã‚’ã¤ã‘ã‚‹å¿…è¦æ€§ã‚’å›é¿ã§ãã‚‹ãŸã‚ã€ä¾¿åˆ©ã§ã‚ã‚‹ã€‚
åˆ¶ç´„è¨€èªã«ã¤ã„ã¦ã®ç§ãŸã¡ã®å½“åˆã®å®šå¼åŒ–ã¯ã€è¤‡åˆçš„ãƒ‡ãƒ¼ã‚¿ä¸Šã®æ¼”ç®—ã‚’æ‰±ã†ã¨ãã«å¤šãã®è¨€èªãŒè¤‡é›‘ã§æ‰±ã„ã¥ã‚‰ã„ã®ã¨åŒã˜ã‚ˆã†ã«ã€è¤‡é›‘ã§æ‰±ã„ã¥ã‚‰ã„ã€‚
ãŸã¨ãˆã°ã€å¤‰æ•°ã¯ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¡¨ã™ã‚‚ã®ã¨ã—ã¦ã€
<span class="math">(<em class="en">a</em> + <em class="en">b</em>) &middot; (<em class="en">c</em> + <em class="en">d</em>)</span>
ã¨ã„ã†ç©ã‚’è¨ˆç®—ã—ãŸã„ã¨ã™ã‚‹ã¨ã€æŒ‡å®šã•ã‚ŒãŸãƒ™ã‚¯ãƒˆãƒ«å¼•æ•°ã®å€¤ã‚’è¨­å®šã™ã‚‹ã‚‚ã®ã®è‡ªåˆ†è‡ªèº«ã¯ãƒ™ã‚¯ãƒˆãƒ«ã‚’å€¤ã¨ã—ã¦è¿”ã•ãªã„ã‚ˆã†ãªæ‰‹ç¶šãã‚’ç”¨ã„ã¦ã€ã€Œå‘½ä»¤å‹ã®æµå„€ã€ã§ä½œæ¥­ã§ãã‚‹ã ã‚ã†ã€‚
 </p>

<p class="lisp">(v-sum a b temp1)
(v-sum c d temp2)
(v-prod temp1 temp2 answer)
</p>

<p class="orig" lang="en">Alternatively, we could deal with expressions, using
procedures that return vectors as values, and thus avoid
explicitly mentioning <tt>temp1</tt> and <tt>temp2</tt>:
</p>

<p class="trans" lang="ja">
ä»£ã‚ã‚Šã«ã€ãƒ™ã‚¯ãƒˆãƒ«ã‚’å€¤ã¨ã—ã¦è¿”ã™æ‰‹ç¶šãã‚’ç”¨ã„ã¦å¼ã‚’æ‰±ã†ã“ã¨ã‚‚å¯èƒ½ã ã‚ã†ã—ã€ã‚ˆã£ã¦ã€æ˜ç¤ºçš„ã«  <tt>temp1</tt> ã‚„ <tt>temp2</tt> ã«è¨€åŠã™ã‚‹ã“ã¨ã‚’é¿ã‘ã‚‹ã“ã¨ãŒå¯èƒ½ã ã‚ã†ã€‚
</p>

<p class="lisp">(define answer (v-prod (v-sum a b) (v-sum c d)))
</p>

<p class="orig" lang="en">
Since Lisp allows us to return compound objects as values of
procedures, we can transform our imperative-style constraint language
into an expression-oriented style as shown in this exercise.  In
languages that are impoverished in handling compound objects, such as
Algol, Basic, and Pascal (unless one explicitly uses Pascal pointer
variables), one is usually stuck with the imperative style when
manipulating compound objects.  Given the advantage of the
expression-oriented format, one might ask if there is any reason to
have implemented the system in imperative style, as we did in this
section.  One reason is that the non-expression-oriented constraint
language provides a handle on constraint objects (e.g., the value of
the <tt>adder</tt> procedure) as well as on connector objects.  This is
useful if we wish to extend the system with new operations that
communicate with constraints directly rather than only indirectly via
operations on connectors.  Although it is easy to implement the
expression-oriented style in terms of the imperative implementation,
it is very difficult to do the converse.
</p>

<p class="trans" lang="ja">
Lispã¯ã€æ‰‹ç¶šãã®å€¤ã¨ã—ã¦è¤‡åˆçš„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã™ã“ã¨ã‚’è¨±ã—ã¦ã„ã‚‹ã®ã§ã€æœ¬å•ã«ç¤ºã—ãŸã‚ˆã†ã«ã€ç§ãŸã¡ã®å‘½ä»¤çš„ãªæµå„€ã®åˆ¶ç´„è¨€èªã‚’ã€å¼æŒ‡å‘ã®æµå„€ã¸ã¨ã€å¤‰æ›ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
è¤‡åˆçš„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ‰±ã†ã“ã¨ã«ãŠã„ã¦è²§å¼±ãªè¨€èªâ€”â€”ãŸã¨ãˆã°ã€Algol ã‚„ Basic ã‚„ Pascal (æ˜ç¤ºçš„ã« Pascal ã®ãƒã‚¤ãƒ³ã‚¿å¤‰æ•°ã‚’ä½¿ã‚ãªã„é™ã‚Šã¯) ãªã©â€”â€”ã§ã¯ã€äººã¯æ™®é€šã€è¤‡åˆçš„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ“ä½œã™ã‚‹ã¨ãã«å‘½ä»¤çš„ãªæµå„€ã‹ã‚‰æŠœã‘å‡ºã›ãªã„ã€‚
å¼æŒ‡å‘ã®å½¢å¼ã®åˆ©ç‚¹ã‚’ä¸ãˆã‚‰ã‚Œã‚‹ã¨ã€äººã¯ã€ç§ãŸã¡ãŒæœ¬ç¯€ã§ãã†ã—ãŸã‚ˆã†ã«ã€å‘½ä»¤çš„ãªæµå„€ã§ã‚·ã‚¹ãƒ†ãƒ ã‚’å®Ÿè£…ã—ãŸç†ç”±ãŒä½•ã‹ã‚ã‚‹ã®ã‹ã©ã†ã‹ã‚’å°‹ã­ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚
ä¸€ã¤ã®ç†ç”±ã¯ã€å¼æŒ‡å‘ã§ãªã„åˆ¶ç´„è¨€èªãŒã€ã‚³ãƒã‚¯ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆä¸Šã¨åŒæ§˜ã«ã€åˆ¶ç´„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆä¸Šã§ã‚‚<ruby><rb>æ‰‹ãŒã‹ã‚Š</rb><rp> (</rp><rt>ãƒãƒ³ãƒ‰ãƒ«</rt><rp>) </rp></ruby> (ãŸã¨ãˆã°ã€<tt>adder</tt> æ‰‹ç¶šãã®å€¤) ã‚’æä¾›ã™ã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚
ã“ã‚Œã¯ã€ã‚³ãƒã‚¯ã‚¿ä¸Šã®æ¼”ç®—ã‚’ä»‹ã—ã¦é–“æ¥çš„ã«ã®ã¿ã€ã¨ã„ã†ã‚ˆã‚Šã‚‚ã‚€ã—ã‚ã€ç›´æ¥çš„ã«ã€åˆ¶ç´„ã¨æƒ…å ±ã‚’ã‚„ã‚Šå–ã‚Šã™ã‚‹ã‚ˆã†ãªã€æ–°ãŸãªæ¼”ç®—ã‚’ä½¿ã£ã¦ã€ã‚·ã‚¹ãƒ†ãƒ ã‚’æ‹¡å¼µã—ãŸã„ã¨ãã«ã€æœ‰ç”¨ã§ã‚ã‚‹ã€‚
</p>


</div>

</body>
</html>
