<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<script type="text/javascript" src="toggle.js"></script>
	<link rel="stylesheet" href="sicp.css" type="text/css">
	<base target="_top">
	<title>SICP私訳: 1.1 プログラミングの要素</title>
</head>

<body>

<div class="idx-bar">
<nav>
<a href="https://twitter.com/share" class="twitter-share-button" data-lang="ja">ツイート</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
<span class="status">推敲済み</span>
[
<a href="00_cover.html">先頭へ</a> |
<a href="09_chap1.html">前へ</a> |
<!--a href="11_sec1_2.html">次へ</a>-->次へ | 
<a href="04_toc.html#%_toc_start">目次</a> |
<a href="38_index.html#%_index_start">索引</a>
] [<a href="99_about.html">この対訳版について</a> | <a href="../index.html">ホーム</a>]
[
§<a href="#%_sec_1.1">1.1</a>
§<a href="#%_sec_1.1.1">1.1.1</a>
§<a href="#%_sec_1.1.2">1.1.2</a>
§<a href="#%_sec_1.1.3">1.1.3</a>
🎨<a href="#%_fig_1.1">1.1</a>
§<a href="#%_sec_1.1.4">1.1.4</a>
§<a href="#%_sec_1.1.5">1.1.5</a>
📚<a href="#%_sec_Temp_22">&hellip;</a>
§<a href="#%_sec_1.1.6">1.1.6</a>
📝<a href="#%_thm_1.1">1.1</a>
📝<a href="#%_thm_1.2">1.2</a>
📝<a href="#%_thm_1.3">1.3</a>
📝<a href="#%_thm_1.4">1.4</a>
📝<a href="#%_thm_1.5">1.5</a>
§<a href="#%_sec_1.1.7">1.1.7</a>
📝<a href="#%_thm_1.6">1.6</a>
📝<a href="#%_thm_1.7">1.7</a>
📝<a href="#%_thm_1.8">1.8</a>
§<a href="#%_sec_1.1.8">1.1.8</a>
🎨<a href="#%_fig_1.2">1.2</a>
📚<a href="#%_sec_Temp_41">&hellip;</a>
📚<a href="#%_sec_Temp_43">&hellip;</a>
<a href="#footnotes">脚注</a>
]
</nav>
</div>

<div class="main-txt">

<a name="%_sec_1.1"></a>
<h2 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_1.1">1.1&nbsp;&nbsp;The Elements of Programming</a></h2>
<h2 class="trans" lang="ja">1.1 プログラミングの要素</h2>

<p class="orig" lang="en">
<a name="%_idx_118"></a>
A powerful programming language is more than just a means for
instructing a computer to perform tasks.  The language also serves as
a framework within which we organize our ideas about processes.  Thus,
when we describe a language, we should pay particular attention to the
means that the language provides for combining simple ideas to form
more complex ideas.  Every powerful language has three mechanisms for
accomplishing this:</p>

<p class="trans" lang="ja">
強力なプログラミング言語は、コンピュータにタスクを実行するよう命令するための単なる手段以上のものである。
そのような言語は、私たちがプロセスについての自分の考えを組織立てる枠組みとしてもはたらく。
よって、私たちが言語を記述するときには、単純な観念同士を結合してより複雑な観念を形成するために当該言語が提供している手段に、特別な注意を払うべきである。
どの強力な言語にも、これ<span class="note"> (単純な観念同士を結合してより複雑な観念を形成すること) </span>を達成するための、以下の三つの仕組みがある。
</p>

<ul class="orig" lang="en">
<a name="%_idx_120"></a>
<li><strong>primitive expressions</strong>, which represent the simplest
entities the language is concerned with,</li>
<a name="%_idx_122"></a><a name="%_idx_124"></a>
<li><strong>means of combination</strong>, by which compound
elements are built from simpler ones, and</li>
<a name="%_idx_126"></a>
<li><strong>means of abstraction</strong>, by
which compound elements can be named and manipulated as units.</li>
</ul>

<ul class="trans" lang="ja">
<li><strong><ruby><rb>原始的</rb><rp> (</rp><rt>プリミティブ</rt><rp>) </rp></ruby>な式</strong>——これは、当該言語が関わっている中で、最も単純な実体を表す</li>
<li><strong>結合の手段</strong>——これにより、複合的な要素が、より単純な要素から構築される</li>
<li><strong>抽象化の手段</strong>——これにより、複合的な要素に名前を付けて一つの単位として扱うことができる</li>
</ul>

<p class="orig" lang="en">
In programming, we deal with two kinds of elements: <a name="%_idx_128"></a>procedures and
<a name="%_idx_130"></a>data. (Later we will discover that they are really not so distinct.)
Informally, data is ``stuff'' that we want to manipulate, and
procedures are descriptions of the rules for manipulating the data.
Thus, any powerful programming language should be able to describe
primitive data and primitive procedures and should have methods for
combining and abstracting procedures and data.</p>

<p class="trans" lang="ja">
プログラミングを行う際、私たちは二種類の要素——手続きとデータ——を扱う
(後ほど、手続きとデータが現実にはそれほど違わない、と気づくだろう)。
非形式的には、データは、私たちが操作したい「中身」であり、手続きはデータを操作するための諸規則の記述である。
よって、いかなる強力な言語も、原始的なデータと原始的な手続きを記述することができる<!--べき-->はずなのであり、手続き<!--と-->やデータを結合したり抽象化したりするための方法を有している<!--べき-->はずなのである。
</p>

<p class="orig" lang="en">
In this chapter we will deal only with simple <a name="%_idx_132"></a><a name="%_idx_134"></a>numerical data so that
we can focus on the rules for building procedures.<a name="call_footnote_Temp_10" href="#footnote_Temp_10"><sup><small>4</small></sup></a> In later chapters we will see that
these same rules allow us to build procedures to manipulate compound
data as well.</p>

<p class="trans" lang="ja">
本章で私たちは、手続きを構築するための諸規則に焦点を当てられるように、単純な数値的データだけを扱おう<a href="#footnote_Temp_10"><sup><small>4</small></sup></a>。
複合的なデータを操作するための手続きも、同じこれらの諸規則によって同様に構築できる、ということが、後の章で分かるだろう。
</p>

<a name="%_sec_1.1.1"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_1.1.1">1.1.1&nbsp;&nbsp;Expressions</a></h3>
<h3 class="trans" lang="ja">1.1.1 式</h3>

<p class="orig" lang="en">
One easy way to get started at programming is to examine some typical
interactions with an interpreter for the Scheme dialect of Lisp.
Imagine that you are sitting at a computer terminal.  You type an
<em>expression</em>, and the interpreter responds by displaying the result of
its <em>evaluating</em> that expression.</p>

<p class="trans" lang="ja">
プログラミングを始めるための一つの簡単な方法は、LispのScheme方言用のインタプリタで、いくつかの典型的な<!--対話式操作-->やりとりを調べてみることだ。
君がコンピュータ端末の前に坐っていると想像してみて。
君は、ある<em>式</em>を打ち、するとインタプリタは、その式を<em>評価</em>した結果を表示することによって、応答する。
</p>

<p class="orig" lang="en">
<a name="%_idx_148"></a><a name="%_idx_150"></a>One kind of primitive expression you might type is a number.  (More
precisely, the expression that you type consists of the numerals that
represent the number in base 10.)  If you present Lisp with
a number</p>

<p class="trans" lang="ja">
君が打つかもしれない原始的な式のうちの一種は、数である
(より正確には、君が打つ式は、基数が10の数を表す数字からなる)。
もし君がLispに対して次の数字を提示したなら、
</p>

<p class="lisp">486</p>

<p class="orig" lang="en">
the interpreter will respond by printing<a name="call_footnote_Temp_11" href="#footnote_Temp_11"><sup><small>5</small></sup></a></p>

<p class="trans" lang="ja">
インタプリタは、次のように印字することで応答するだろう<a href="#footnote_Temp_11"><sup><small>5</small></sup></a>。
</p>


<p class="lisp"><i>486</i></p>

<p class="orig" lang="en">
<a name="%_idx_154"></a><a name="%_idx_156"></a>Expressions representing numbers may be combined with an <a name="%_idx_158"></a>expression
representing a <a name="%_idx_160"></a><a name="%_idx_162"></a><a name="%_idx_164"></a><a name="%_idx_166"></a><a name="%_idx_168"></a>primitive procedure (such as <tt>+</tt> or <tt>*</tt>) to form a
compound expression that represents the
application of the procedure to those numbers.  For example:</p>

<p class="trans" lang="ja">
数を表す式は、原始的な手続きを表す式  (<tt>+</tt> や <tt>*</tt> など) と結び付けられて、それらの数にその手続きを適用することを表すような複合的な式を形作ることがある。たとえば、以下のように。
</p>

<p class="lisp">(+ 137 349)
<i>486</i>
<a name="%_idx_170"></a><a name="%_idx_172"></a>(- 1000 334)
<i>666</i>
(* 5 99)
<i>495</i>
<a name="%_idx_174"></a><a name="%_idx_176"></a>(/ 10 5)
<i>2</i>
(+ 2.7 10)
<i>12.7</i>
</p>

<p class="orig" lang="en">
Expressions such as these, formed by <a name="%_idx_178"></a>delimiting a list of expressions
within parentheses in order to denote <a name="%_idx_180"></a>procedure application,
are called <em>combinations</em>.  The leftmost
element in the list is called the <a name="%_idx_182"></a><em>operator</em>, and the other
elements are called <a name="%_idx_184"></a><em>operands</em>.  The <a name="%_idx_186"></a>value of a combination is
obtained by applying the procedure specified by the operator to the
<a name="%_idx_188"></a><em>arguments</em> that are the values of the operands.</p>

<p class="trans" lang="ja">
これらのような式——手続きの適用を示すために、式のリストの範囲を括弧<!--の中に限定する-->で括ることで、形成される——は、<em>コンビネーション</em>と呼ばれる。
リストの最左要素は、<em><ruby><rb>演算子</rb><rp> (</rp><rt>オペレータ</rt><rp>) </rp></ruby></em>と呼ばれ、残りの要素は<em><ruby><rb>被演算子</rb><rp> (</rp><rt>オペランド</rt><rp>) </rp></ruby></em>と呼ばれる。
コンビネーションの値は、オペレータにより指定される手続きを、オペランドの値である<em>引数</em>に適用することで、得られる。
</p>

<p class="orig" lang="en">
The convention of placing the operator to the left of the operands is
known as <a name="%_idx_190"></a><em>prefix notation</em>, and it may be somewhat confusing at
first because it departs significantly from the customary mathematical
convention.  Prefix notation has several advantages, however.  One of
them is that it can accommodate <a name="%_idx_192"></a><a name="%_idx_194"></a>procedures that may take an arbitrary
number of arguments, as in the following examples:</p>

<p class="trans" lang="ja">
オペランドの左にオペレータを置く習慣は、<em>前置記法</em>として知られているが、これは、いつも<!--ながら-->の数学的習慣からは著しくかけ離れているので、最初はやや困惑するかもしれない。
しかし、前置記法にはいくつかの利点がある。
その一つは、任意の個数の引数をとりうる手続きに対処できることである——たとえば以下の例のように。
</p>

<p class="lisp">(+ 21 35 12 7)
<i>75</i>

(* 25 4 12)
<i>1200</i></p>

<p class="orig" lang="en">
No ambiguity can arise, because the operator is always the leftmost
element and the entire combination is delimited by the
parentheses.</p>

<p class="trans" lang="ja">
何の曖昧性も生じない。というのも、オペレータは常に最左要素であり、かつ、コンビネーション全体は括弧で括られて
いるからである。</p>

<p class="orig" lang="en">
<a name="%_idx_196"></a>A second advantage of prefix notation is that it extends in a
straightforward way to allow combinations to be <em>nested</em>, that is,
to have combinations whose elements are themselves
combinations:</p>

<p class="trans" lang="ja">
<!--前置記法の第二の利点は、前置記法が、単純な方法で、コンビネーションが<em>入れ子になる</em>ことを許すように——つまり、自分の要素自体がコンビネーションであるようなコンビネーションを持つように——なっていることである。-->
<!--to allowとto haveが並列と見る-->
前置記法の第二の利点は、コンビネーションが<em>入れ子になる</em>ことを許すように——つまり、自分の要素自体がコンビネーションであるようなコンビネーションが有るように——、前置記法が分かりやすい方法で広がっている点である。
</p>


<p class="lisp">(+ (* 3 5) (- 10 6))
<i>19</i></p>


<p class="orig" lang="en">
There is no limit (in principle) to the depth of such nesting and to
the overall complexity of the expressions that the Lisp interpreter
can evaluate.
It is we humans who get confused by still relatively
simple expressions such as</p>

<p class="trans" lang="ja">
(原理的には) こういう入れ子の深さには限度がなく、Lispインタプリタが評価できる式の、全体としての複雑さにも限度がない。
以下のような、まだ比較的単純な式によって混乱してしまうのは、我々、人間の方である。
</p>


<p class="lisp">(+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))
</p>

<p class="orig" lang="en">
which the interpreter would readily evaluate to be 57.  We can help
ourselves by writing such an expression in the form</p>


<p class="trans" lang="ja">
インタプリタは、この式を57と素早く評価するだろう。
私たちは、次のような形の式を書くことで、自らを助けることができる。
</p>

<p class="lisp">(+ (* 3
      (+ (* 2 4)
         (+ 3 5)))
   (+ (- 10 7)
      6))
</p>

<p class="orig" lang="en">
following a formatting convention known as <a name="%_idx_198"></a><em>pretty-printing</em>, in
which each long combination is written so that the operands are
aligned vertically.  The resulting indentations display clearly the
structure of the expression.<a name="call_footnote_Temp_12" href="#footnote_Temp_12"><sup><small>6</small></sup></a></p>

<p class="trans" lang="ja">
この式は、<em>プリティ・プリント</em>として知られる書式の慣例——長いコンビネーションは、それぞれ、そのオペランドが縦に整列されるように書かれる——にしたがっている。
結果として生じる字下げは、式の構造を明確に表している<a href="#footnote_Temp_12"><sup><small>6</small></sup></a>。
</p>

<p class="orig" lang="en">
Even with complex expressions, the interpreter always operates in the
same basic cycle: It reads an expression from the terminal, 
evaluates the expression, and prints the result.
This mode of operation is often expressed by saying that the
interpreter runs in a <a name="%_idx_204"></a><a name="%_idx_206"></a><em>read-eval-print loop</em>.
Observe in particular that it is not necessary to explicitly
instruct the interpreter to print the value of the expression.<a name="call_footnote_Temp_13" href="#footnote_Temp_13"><sup><small>7</small></sup></a></p>

<p class="trans" lang="ja">
複雑な式についてであっても、インタプリタは、常に同じ基本的な繰り返しで動作する。
つまり、インタプリタは端末から式を読み、その式を評価し、その結果を印字する。
この動作の仕方は、しばしば、「インタプリタが<em>read-eval-printループ</em>で動いている」と言うことにより、表現される。
式の値を印字せよ、とインタプリタに対して明示的に命令することは必要ではない、ということに、特に気づいてほしい<a href="#footnote_Temp_13"><sup><small>7</small></sup></a>。</p>

<a name="%_sec_1.1.2"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_1.1.2">1.1.2&nbsp;&nbsp;Naming and the Environment</a></h3>
<h3 class="trans" lang="ja">1.1.2 名付けと環境</h3>

<p class="orig" lang="en">
A critical aspect of a programming language is the means it provides
for using <a name="%_idx_216"></a>names to refer to computational objects.  We say that the
<a name="%_idx_218"></a>name identifies a <a name="%_idx_220"></a><em>variable</em> whose <a name="%_idx_222"></a><em>value</em> is the object.</p>

<p class="trans" lang="ja">
プログラミング言語の重要な側面は、計算<!--に関する--><!--計算機上の-->オブジェクトを参照するための名前を使うことに対してそのプログラミング言語が与えている手段である。
<!--つまり、名前は、その<em>値</em>が当該オブジェクトであるような<em>変数</em>を識別するのだ、ということを言っているわけだが。-->
名前は、その<em>値</em>が当該オブジェクトであるような<em>変数</em>を識別するのだ、というふうに、私たちは言う。
</p>

<p class="orig" lang="en">
In the Scheme dialect of Lisp, we
name things with <a name="%_idx_224"></a><a name="%_idx_226"></a><tt>define</tt>.  Typing</p>

<p class="trans" lang="ja">
Lisp の Scheme 方言では、<tt>define</tt> を使って、ものに名前をつける。
次のように打つと、
</p>

<p class="lisp">(define size 2)</p>

<p class="orig" lang="en">
causes the interpreter to associate the value 2 with the
name <tt>size</tt>.<a name="call_footnote_Temp_14" href="#footnote_Temp_14"><sup><small>8</small></sup></a>
Once the name <tt>size</tt> has been associated with the number 2, we can 
refer to the value 2 by name:</p>

<p class="trans" lang="ja">
インタプリタに、2という値を<tt>size</tt>という名前に関連づけさせることになる<a href="#footnote_Temp_14"><sup><small>8</small></sup></a>。
一旦、<tt>size</tt>という名前が2という数に関連づけられると、次のように、2という値を、名前によって参照することができるようになる。
</p>

<p class="lisp">size
<i>2</i>
(* 5 size)
<i>10</i></p>

<p class="orig" lang="en">
Here are further examples of the use of <tt>define</tt>:
</p>

<p class="trans" lang="ja">
<tt>define</tt>の使い方の例は、もっとある。
</p>

<p class="lisp">(define pi 3.14159)
(define radius 10)
(* pi (* radius radius))
<i>314.159</i>
(define circumference (* 2 pi radius))
circumference
<i>62.8318</i></p>

<p class="orig" lang="en">
<a name="%_idx_232"></a><tt>Define</tt> is our language's
simplest means of abstraction, for it allows us to use simple names to
refer to the results of compound operations, such as the
<tt>circumference</tt> computed above.
In general, computational objects may have very complex
structures, and it would be extremely inconvenient to have to remember
and repeat their details each time we want to use them.  Indeed,
complex programs are constructed by building, step by step,
computational objects of increasing complexity. The
interpreter makes this step-by-step program construction particularly
convenient because name-object associations can be created
incrementally in successive interactions.  This feature encourages the
<a name="%_idx_234"></a><a name="%_idx_236"></a>incremental development and testing of programs and is largely
responsible for the fact that <a name="%_idx_238"></a>a Lisp program usually consists of a large
number of relatively simple procedures.
</p>

<p class="trans" lang="ja">
<tt>define</tt>は、私たちの言語が有する、もっとも簡単な抽象化手段である。というのも、それによって私たちは、簡単な名前を使って複合的な操作の結果を参照することができるようになるからだ——例えば、上記で計算された<tt>circumference</tt>のように。
一般に、計算<!--に関する-->オブジェクトは、とても複雑な構造を持ち得るし、その複雑な構造を使いたいときに、その都度、その複雑な構造の細部のすべてを覚えておいて繰り返さなくてはならないというのは、きわめて不便であろう。
実際、複雑なプログラムは、複雑さを増してゆく計算オブジェクトを段階的に組み立てることで、構成されるのである。
インタプリタは、この段階的なプログラム構成を、とりわけ便利にしてくれる——なぜなら、名前とオブジェクトの関連づけを、連続するやりとりの中で逐次的に作り出せるからだ。
この特徴により、プログラムを逐次的に開発およびテストすることが促進され、また、この特徴は、Lispプログラムが普通は多数の比較的簡単な手続きからなる、という事実の主な原因である。
</p>

<p class="orig" lang="en">
It should be clear that the possibility of associating values with
symbols and later retrieving them means that the interpreter must
maintain some sort of memory that keeps track of the name-object
pairs.  This memory is called the <a name="%_idx_240"></a><em>environment</em> (more precisely
the <a name="%_idx_242"></a><em>global environment</em>, since we will see later that a
computation may involve a number of different
environments).<a name="call_footnote_Temp_15" href="#footnote_Temp_15"><sup><small>9</small></sup></a>
</p>

<p class="trans" lang="ja">
値を<ruby><rb>記号</rb><rp> (</rp><rt>シンボル</rt><rp>) </rp></ruby>に関連づけておいて後からその値を取り出すことが可能であるということが、名前とオブジェクトの<ruby><rb>対</rb><rp> (</rp><rt>ペア</rt><rp>) </rp></ruby>を把握する何らかの記憶手段をインタプリタが維持していなければならないことを意味する、ということは、明らかなはずである。
この記憶手段は、<em>環境</em>と呼ばれる (より正確には、<em>大域環境</em>と呼ばれる——というのも、計算が多数の異なる環境を伴うことがある、ということを、後に見るからである)<a href="#footnote_Temp_15"><sup><small>9</small></sup></a>。
</p>


<a name="%_sec_1.1.3"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_1.1.3">1.1.3&nbsp;&nbsp;Evaluating Combinations</a></h3>
<h3 class="trans" lang="ja">1.1.3 コンビネーションを評価する</h3>

<p class="orig" lang="en">
<a name="%_idx_244"></a><a name="%_idx_246"></a>
One of our goals in this chapter is to isolate issues about thinking
procedurally.  As a case in point, let us consider that, in evaluating
combinations, the interpreter is itself following a procedure.
</p>

<p class="trans" lang="ja">
本章での私たちの目標のひとつは、手続き的に考えることについての問題点同士を切り離すことだ。
良い例として、コンビネーションを評価する際に、インタプリタが、それ自体、ある手続きに従っていると考えてみよう。
</p>

<ul class="orig" lang="en">
<li>To evaluate a combination, do the following:
<ol>
<li>Evaluate the subexpressions of the combination.</li>
<li>Apply the procedure that is the value of the leftmost 
subexpression (the operator) to the arguments that are the values of
the other subexpressions (the operands).</li>
</ol>
</li>
</ul>

<ul class="trans" lang="ja">
<li>コンビネーションを評価するために、以下のことをせよ。
<ol>
<li>そのコンビネーションの部分式を評価せよ。</li>
<li>最左の部分式 (オペレータ) の値である手続きを、残りの部分式 (オペランド) の値である引数に、適用せよ。</li>
</ol>
</li>
</ul>


<p class="orig" lang="en">
Even this simple rule illustrates some important points about
processes in general.  First, observe that the first step dictates
that in order to accomplish the evaluation process for a combination
we must first perform the evaluation process on each element of the
combination.  Thus, the evaluation rule is <a name="%_idx_248"></a><em>recursive</em> in nature;
that is, it includes, as one of its steps, the need to invoke the rule
itself.<a name="call_footnote_Temp_16" href="#footnote_Temp_16"><sup><small>10</small></sup></a>
</p>

<p class="trans" lang="ja">
この簡単な規則でさえ、プロセス一般についてのいくつかの重要な点を示している。
第一に、コンビネーションの評価プロセスを達成するには、そのコンビネーションの各要素についての評価プロセスを最初に実行せねばならない、ということを、第一のステップが指示していることに気づいてほしい。
このように、評価規則は、本質的に<em>再帰的</em>なのである。
つまり、評価規則は、その規則のステップのうちの一つとして、その規則自体を呼び出す必要性を含んでいる<a href="#footnote_Temp_16"><sup><small>10</small></sup></a>。
</p>

<p class="orig" lang="en">
<a name="%_idx_250"></a>Notice how succinctly the idea of recursion can be used to express
what, in the case of a deeply nested combination, would otherwise be
viewed as a rather complicated process.  For example, evaluating
</p>

<p class="trans" lang="ja">
深く入れ子になったコンビネーションにおいて、再帰という観念が、再帰とは違う方法だとかなり込み入ったプロセスと見なされるであろうものを、どれほど簡潔に表現するのに使えるのか、注目してほしい。
例えば、以下を評価することは、
</p>

<p class="lisp">(* (+ 2 (* 4 6))
   (+ 3 5 7))</p>

<p class="orig" lang="en">
requires that the evaluation rule be applied to four different
combinations.  We can obtain a picture of this process by <a name="%_idx_252"></a>representing
the combination in the form of a <a name="%_idx_254"></a>tree, as shown in
figure&nbsp;<a href="#%_fig_1.1">1.1</a>.  Each combination is represented by a
<a name="%_idx_256"></a>node with <a name="%_idx_258"></a>branches corresponding to the operator and the
operands of the combination stemming from it.
The <a name="%_idx_260"></a>terminal nodes (that is, nodes with
no branches stemming from them) represent either operators or numbers.
Viewing evaluation in terms of the tree, we can imagine that the
values of the operands percolate upward, starting from the terminal
nodes and then combining at higher and higher levels.  In general, we
shall see that recursion is a very powerful technique for dealing with
hierarchical, treelike objects.  In fact, the ``percolate values
upward'' form of the evaluation rule is an example of a general kind
of process known as <a name="%_idx_262"></a><em>tree accumulation</em>.</p>

<p class="trans" lang="ja">
四つの異なるコンビネーションに評価規則が適用される、ということを必要とする。
図<a href="#%_fig_1.1">1.1</a>に示すような木の形でコンビネーションを表現することで、私たちは、このプロセスのイメージを得ることができる。
各コンビネーションはノードにより表現され、そのノードには、当該コンビネーションのオペレータとオペランドに対応していて当該ノードから始まる枝がある。
終端ノード (つまり、そのノードから始まる枝がないようなノード) は、オペレータか数を表現している。
木という観点から評価について見てみると、オペランドの値が上に向かって次第に滲み出てゆく——終端ノードから始まり、そして、段々と高いレベルで結合してゆく——さまを、心に描くことができる。
一般に、再帰は、階層的な、木のようなオブジェクトを扱うための、とても強力な技法である、ということを、私たちは理解することになるだろう。
実際、評価規則での「上に向かって値を次第に滲み出させる」形は、<em>木の累算</em>として知られる、一般的な種類のプロセスの一例である。
</p>

<a name="%_fig_1.1"></a>
<figure>
<img src="ch1-Z-G-1.gif" border="0"><br>
<figcaption class="orig" lang="en">Figure 1.1:</b>&nbsp;&nbsp;Tree representation, showing the value of each subcombination.</figcaption>
<figcaption class="trans" lang="ja">図1.1: 各々の部分コンビネーションの値を示している、木による表現</figcaption>
</figcaption>
</figure>

<p class="orig" lang="en">
Next, observe that the repeated application of the first step brings
us to the point where we need to evaluate, not combinations, but
primitive expressions such as numerals, built-in operators, or other
names.  We take care of the primitive cases by stipulating that</p>

<p class="trans" lang="ja">
次に、第一のステップを繰り返し適用することにより、コンビネーションではなく、数字や組み込みオペレータやその他の名前などの、原始的な式を評価せねばならないところにまで、私たちが連れてこられる、ということを見てほしい。
私たちは、次のように規定することで、原始的な場合を処理する。
</p>

<a name="%_idx_264"></a><a name="%_idx_266"></a>
<ul class="orig" lang="en">
<li>the values of numerals are the numbers that they name,</li>
<li>the values of built-in operators are the machine
instruction sequences that carry out the corresponding operations, and</li>
<li>the values of other names are the objects associated 
with those names in the environment.</li>
</ul>

<ul class="trans" lang="ja">
<li>数字の値は、その数字が名づける数であり、</li>
<li>組み込みオペレータの値は、対応する操作を実行するマシン命令列であり、</li>
<li>その他の名前の値は、環境内においてその名前に関連づけられたオブジェクトである。</li>
</ul>

<p class="orig" lang="en">
We may regard the second rule as a special case of the third one by
stipulating that symbols such as <tt>+</tt> and <tt>*</tt> are also included
in the global environment, and are associated with the sequences of
machine instructions that are their ``values.''  The key point to
notice is the role of the <a name="%_idx_268"></a>environment in determining the meaning of
the symbols in expressions.  In an interactive language such as
Lisp, it is meaningless to speak of the value of an expression such as
<tt>(+ x 1)</tt> without specifying any information about the environment
that would provide a meaning for the symbol&nbsp;<tt>x</tt> (or even for the
symbol <tt>+</tt>).  As we shall see in chapter&nbsp;3, the general notion of
the environment as providing a context in which evaluation takes place
will play an important role in our understanding of program execution.</p>

<p class="trans" lang="ja">
<tt>+</tt> や <tt>*</tt> のような<ruby><rb>記号</rb><rp> (</rp><rt>シンボル</rt><rp>) </rp></ruby>も大域環境に含まれており、かつ、それらのシンボルは、それらのシンボルの「値」であるようなマシン命令列と関連づけられている、と規定することにより、二番目の規則を三番目の規則の特別な場合だと見なしてもよい。
注意すべき重要な点は、式の中のシンボルの意味を決定する際の環境の役割である。
Lispのような対話的な言語では、<tt>x</tt> というシンボルの意味を (あるいは、<tt>+</tt> というシンボルの意味さえをも) 与えるであろう環境についての情報を何も指定せずに、<tt>(+ x 1)</tt> のような式の値について語ることは、無意味である。
3章で見ることになるとおり、環境という一般的概念は、評価が起こる<ruby><rb>文脈</rb><rp> (</rp><rt>コンテクスト</rt><rp>) </rp></ruby>を与えるものなので、プログラム実行を私たちが理解するのに重要な役割を果たすことになるだろう。<!--span class="note"> (as providing ...を文法的にどう解釈すべきか、要検討)</span-->
<!--カンマはないが、挿入句と見て訳した。-->
</p>

<a name="%_idx_270"></a>
<p class="orig" lang="en">
Notice that the
evaluation rule given above does not handle definitions.
For instance, evaluating
<tt>(define x 3)</tt> does not apply <tt>define</tt> to two arguments, one
of which is the value of the symbol <tt>x</tt> and the other of which is
3, since the purpose of the <tt>define</tt> is precisely to associate
<tt>x</tt> with a value.
(That is, <tt>(define x 3)</tt> is not a combination.)</p>

<p class="trans" lang="ja">
上記の評価規則が定義を取り扱っていないことに注意してほしい。
たとえば、<tt>(define x 3)</tt> の評価では、二つの引数——そのうちの一つは <tt>x</tt> というシンボルの値であり、もう一つは3である——に <tt>define</tt> を適用するわけではない。なぜなら、<tt>define</tt> の目的は、まさに、<tt>x</tt> を値に関連づけることだからである
(つまり、<tt>(define x 3)</tt> はコンビネーションではない)。
</p>

<a name="%_idx_272"></a>
<p class="orig" lang="en">
Such exceptions to the general evaluation rule are called <em>special
forms</em>.  <tt>Define</tt> is the only example of a special form that we
have seen so far, but we will meet others shortly.  <a name="%_idx_274"></a>Each special form
has its own evaluation rule. The various kinds of expressions (each
with its associated evaluation rule) constitute the <a name="%_idx_276"></a>syntax of the
programming language.  In comparison with most other programming
languages, Lisp has a very simple syntax; that is, the evaluation rule
for expressions can be described by a simple general rule together
with specialized rules for a small number of special
forms.<a name="call_footnote_Temp_17" href="#footnote_Temp_17"><sup><small>11</small></sup></a></p>

<p class="trans" lang="ja">
一般的な評価規則における、このような例外は、<em><ruby><rb>特殊形式</rb><rp> (</rp><rt>スペシャル・フォーム</rt><rp>)</rp></em>と呼ばれる。
<tt>define</tt> は、私たちが今までに見てきた特殊形式の唯一の例であるが、他の例にもすぐに出会うだろう。
各特殊形式は、それ自身の評価規則を有する。
様々な種類の式 (それぞれの式は、自身に関連づけられた評価規則を持っている) は、プログラミング言語の文法を構成する。
他のほとんどのプログラミング言語と比べると、Lispは、文法がとても単純である。
つまり、式の評価規則は、一つの単純な一般的規則と、少数の特殊形式のための特殊な規則によって、記述できる<a href="#footnote_Temp_17"><sup><small>11</small></sup></a>。
</p>

<a name="%_sec_1.1.4"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_1.1.4">1.1.4&nbsp;&nbsp;Compound Procedures</a></h3>
<h3 class="trans" lang="ja">1.1.4 複合的手続き</h3>

<p class="orig" lang="en">
We have identified in Lisp some of the elements that must appear in
any powerful programming language:</p>

<p class="trans" lang="ja">
強力なプログラミング言語のいずれにおいても現れなくてはならない、いくつかの要素を、私たちはLispにおいて特定してきた。
</p>

<ul class="orig" lang="en">
<li>Numbers and arithmetic operations are 
primitive data and procedures.</li>
<li>Nesting of combinations provides a means of 
combining operations.</li>
<li>Definitions that associate names with values provide a
limited means of abstraction.</li>
</ul>

<ul class="trans" lang="ja">
<li>数および算術演算子は、原始的なデータおよび手続きである。</li>
<li>コンビネーションの入れ子は、演算を結合する手段を提供する。</li>
<li>名前を値に関連づける定義は、抽象化の限定的な手段を提供する。</li>
</ul>

<p class="orig" lang="en">
Now we will learn about
<a name="%_idx_292"></a><em>procedure definitions</em>, a much more powerful abstraction
technique by which a compound operation can be given a name and then
referred to as a unit.</p>

<p class="trans" lang="ja">
さてここで、<em>手続きの定義</em>——複合的な操作に名前を与え、その複合的な操作を一つの単位として参照することを可能とする、より一層強力な抽象化の技法——について学ぼう。
</p>

<p class="orig" lang="en">
We begin by examining how to express the idea of ``squaring.''  We
might say, ``To square something, multiply it by itself.''  This is
expressed in our language as </p>

<p class="trans" lang="ja">
「二乗する」という概念をどうやって表すかについて検討することから始める。
私たちは、「何かを二乗するには、それにそれ自身を掛けよ」と言ってもよいだろう。
これは、私たちの言語では、次のように表される。
</p>

<p class="lisp"><a name="%_idx_294"></a>(define (square x) (* x x))</p>

<p class="orig" lang="en">
We can understand this in the following way:
</p>

<p class="trans" lang="ja">
これを、次のようなやり方で理解することも可能だ。
</p>

<p class="lisp">(define (square  x)        (*         x     x))
   <img src="book-Z-G-D-16.gif" border="0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="book-Z-G-D-16.gif" border="0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="book-Z-G-D-16.gif" border="0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="book-Z-G-D-16.gif" border="0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="book-Z-G-D-16.gif" border="0">&nbsp;&nbsp;&nbsp;&nbsp;<img src="book-Z-G-D-16.gif" border="0">
&nbsp;To&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;square&nbsp;something,&nbsp;multiply&nbsp;&nbsp;&nbsp;it&nbsp;by&nbsp;itself.</p>

<a name="%_idx_296"></a><a name="%_idx_298"></a>
<p class="orig" lang="en">
We have here a <em>compound procedure</em>, which has been given the name
<tt>square</tt>.  The procedure represents the operation of multiplying
something by itself.  The thing to be multiplied is given a local
name, <tt>x</tt>, which plays the same role that a pronoun plays in
natural language.  <a name="%_idx_300"></a><a name="%_idx_302"></a><a name="%_idx_304"></a>Evaluating the definition creates this
compound procedure and associates it with the name <tt>square</tt>.<a name="call_footnote_Temp_18" href="#footnote_Temp_18"><sup><small>12</small></sup></a></p>

<p class="trans" lang="ja">
ここにあるのは、<em>複合的手続き</em>—— <tt>square</tt> という名前を与えられたもの——である。
この手続きは、何かにそれ自身を掛けるという演算を表現している。
掛け算されるべきものには、局所的な名前——すなわち <tt>x</tt> ——が与えられ、この局所的な名前は、自然言語において代名詞が果たす役割と同じ役割を果たす。
定義を評価することにより、この複合的手続きを作成し、この複合的手続きを <tt>square</tt> という名前に関連づけることになる<a href="#footnote_Temp_18"><sup><small>12</small></sup></a>。
</p>

<a name="%_idx_306"></a><a name="%_idx_308"></a>
<p class="orig" lang="en">The general form of a procedure definition is
</p>

<p class="trans" lang="ja">
手続き定義の一般的形式は、以下のとおりである。
</p>

<p class="lisp">(define (&lt;<em>name</em>&gt; &lt;<em>formal parameters</em>&gt;) &lt;<em>body</em>&gt;)</p>

<a name="%_idx_310"></a><a name="%_idx_312"></a>
<p class="orig" lang="en">
The &lt;<em>name</em>&gt; is a symbol to be associated with the procedure
definition in the environment.<a name="call_footnote_Temp_19" href="#footnote_Temp_19"><sup><small>13</small></sup></a>
The <a name="%_idx_318"></a><a name="%_idx_320"></a>&lt;<em>formal parameters</em>&gt; are
the names used within the body of the procedure to refer to the
corresponding arguments of the procedure.  The
<a name="%_idx_322"></a><a name="%_idx_324"></a>&lt;<em>body</em>&gt; is an expression that will yield the value of
the procedure application when the formal parameters are replaced by
the actual arguments to which the procedure is applied.<a name="call_footnote_Temp_20" href="#footnote_Temp_20"><sup><small>14</small></sup></a>
The &lt;<em>name</em>&gt;
and the &lt;<em>formal parameters</em>&gt;
are grouped within <a name="%_idx_328"></a>parentheses, just as they
would be in an actual call to the procedure being defined.</p>

<p class="trans" lang="ja">
&lt;<em class="en">name</em>&gt; (名前) は、環境内で手続き定義に関連づけられるべき<ruby><rb>記号</rb><rp> (</rp><rt>シンボル</rt><rp>) </rp></ruby>である<a href="#footnote_Temp_19"><sup><small>13</small></sup></a>。
&lt;<em class="en">formal parameters</em>&gt; (仮引数) は、その手続きの、対応する実引数を参照するために、その手続きの本体の中で使われる名前である。
&lt;<em class="en">body</em>&gt; (本体) は、その手続きが適用される先の実引数によって、仮引数が置き換えられたときに、手続き適用の値をもたらすことになるであろう、式である<a href="#footnote_Temp_20"><sup><small>14</small></sup></a>。
&lt;<em class="en">name</em>&gt; (名前) と&lt;<em class="en">formal parameters</em>&gt; (仮引数) は、括弧で括られている——ここで定義している手続きに対する実際の呼び出しにおいて、これらが括弧の中に括られるのと同様に。
</p>

<p class="orig" lang="en">
Having defined <tt>square</tt>, we can now use it:</p>

<p class="trans" lang="ja">
<tt>square</tt> を定義したので、今から私たちはそれを使える。
</p>

<p class="lisp">(square 21)
<i>441</i>

(square (+ 2 5))
<i>49</i>

(square (square 3))
<i>81</i>
</p>

<p class="orig" lang="en">
We can also use <tt>square</tt> as a building block in defining other
procedures.  For example, <em>x</em><sup>2</sup>  + <em>y</em><sup>2</sup> can be expressed as</p>

<p class="trans" lang="ja">
他の手続きを定義する際の基本構成要素として、<tt>square</tt> を使うこともできる。
たとえば、
<span class="math"><em class="en">x</em><sup>2</sup> + <em class="en">y</em><sup>2</sup></span>
は次のように表せる。
</p>

<p class="lisp">(+ (square x) (square y))
</p>

<p class="orig" lang="en">
We can easily define a procedure
<tt>sum-of-squares</tt> that, given any two numbers as arguments, produces the
sum of their squares:</p>

<p class="trans" lang="ja">
二つの数を引数として与えられるとそれらの二乗の和を作り出すような、<tt>sum-of-squares</tt> という手続きを、私たちは容易に定義することができる。</p>

<p class="lisp"><a name="%_idx_330"></a>(define (sum-of-squares x y)
  (+ (square x) (square y)))

(sum-of-squares 3 4)
<i>25</i>
</p>

<p class="orig" lang="en">
Now we can use <tt>sum-of-squares</tt> as a building block in constructing
further procedures:</p>

<p class="trans" lang="ja">
これからは、<tt>sum-of-squares</tt> を、さらなる手続きを構成する際の基本構成要素として使える。</p>

<a name="define_f"></a>
<p class="lisp">(define (f a)
  (sum-of-squares (+ a 1) (* a 2)))

(f 5)
<i>136</i>
</p>

<p class="orig" lang="en">
<a name="%_idx_332"></a>Compound procedures are used in exactly the same way as primitive
procedures.  Indeed, one could not tell by looking at the definition
of <tt>sum-of-squares</tt> given above whether <tt>square</tt> was built into
the interpreter, like <tt>+</tt> and <tt>*</tt>, or defined as a compound procedure.</p>

<p class="trans" lang="ja">
複合的手続きは、原始的手続きとまったく同じ方法で使われる。
実際、<tt>+</tt> や <tt>*</tt> と同様に <tt>square</tt> がインタプリタに組み込まれていたのか、それとも、<tt>square</tt> が複合的手続きとして定義されていたのか、ということは、上記の <tt>sum-of-squares</tt> の定義を見ても分からないだろう。
</p>

<a name="%_sec_1.1.5"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_1.1.5">1.1.5&nbsp;&nbsp;The Substitution Model for Procedure Application</a></h3>
<h3 class="trans" lang="ja">1.1.5 手続き適用のための<ruby><rb>代入</rb><rp> (</rp><rt>おきかえ</rt><rp>) </rp></ruby>モデル</h3>

<p class="extra">
<a href="07_prefaceTo1stEd.html">第1版への前書き</a>にも註をつけたが、「おきかえ」の意味の「代入」(substitution) と、「わりあて」の意味の「代入」(assignment) の双方が、本書には出てくる。どちらの概念も日本語では「代入」と呼ぶにもかかわらず、意味の違いが問題になってくる。そのため、とりあえずルビを振って区別してある。
</p>

<a name="%_idx_334"></a>
<p class="orig" lang="en">
To evaluate a combination whose operator names a compound procedure, the
interpreter follows much the same process as for combinations whose
operators name primitive procedures, which we described in
section&nbsp;<a href="#%_sec_1.1.3">1.1.3</a>.  That is, the interpreter
evaluates the elements of the combination and applies the procedure
(which is the value of the operator of the combination) to the
arguments (which are the values of the operands of the combination).</p>

<p class="trans" lang="ja">
<ruby><rb>演算子</rb><rp> (</rp><rt>オペレータ</rt><rp>) </rp></ruby>が複合的手続きを名指ししているようなコンビネーションを評価するために、インタプリタは、オペレータが原始的手続きを名指ししているようなコンビネーションの場合のプロセス——<a href="#%_sec_1.1.3">1.1.3</a>節で説明した——とほとんど同じプロセスにしたがう。
つまり、インタプリタは、当該コンビネーションの要素を評価し、当該手続き (当該コンビネーションのオペレータの値) を、引数 (当該コンビネーションのオペランドの値) に適用する。
</p>

<p class="orig" lang="en">
We can assume that the mechanism for applying primitive procedures to
arguments is built into the interpreter.  For compound procedures, the
application process is as follows:</p>

<p class="trans" lang="ja">
原始的手続きを引数に適用するための仕組みが、インタプリタに組み込まれている、と想定<!--することも可能だ-->することができる。
複合的手続きについては、適用プロセスは以下のようになる。
</p>

<ul class="orig" lang="en">
<li>To apply a compound procedure to arguments, evaluate the body of the
procedure with each formal parameter replaced by the corresponding
argument.</li>
</ul>

<ul class="trans" lang="ja">
<li>複合的手続きを実引数に適用するには、各仮引数をそれに対応する実引数で置き換えた状態で、その手続きの本体を評価せよ。</li>
</ul>

<p class="orig" lang="en">
To illustrate this process, let's evaluate the combination</p>

<p class="trans" lang="ja">
このプロセスを説明するために、次のコンビネーションを評価してみよう。
</p>

<p class="lisp">(f 5)</p>

<p class="orig" lang="en">
where <tt>f</tt> is the procedure defined in
section&nbsp;<a href="#%_sec_1.1.4">1.1.4</a>.  We begin by retrieving the
body of <tt>f</tt>:</p>

<p class="trans" lang="ja">
ここで、<tt>f</tt> は、<a href="#%_sec_1.1.4">1.1.4</a>節で<a href="#define_f">定義された</a>ものである。
<tt>f</tt> の本体を取り出すことから始める。
</p>

<p class="lisp">(sum-of-squares (+ a 1) (* a 2))</p>

<p class="orig" lang="en">
Then we replace the formal parameter <tt>a</tt> by the argument 5:</p>

<p class="trans" lang="ja">
次に、<tt>a</tt>という仮引数を、5という実引数で置き換える。
</p>

<p class="lisp">(sum-of-squares (+ 5 1) (* 5 2))</p>

<p class="orig" lang="en">
Thus the problem reduces to the evaluation of a combination with two
operands and an operator <tt>sum-of-squares</tt>.  Evaluating this
combination involves three subproblems.  We must evaluate the
operator to get the procedure to be applied, and we must evaluate the
operands to get the arguments.  Now <tt>(+ 5 1)</tt> produces 6 and
<tt>(* 5 2)</tt> produces 10, so we must apply the
<tt>sum-of-squares</tt> procedure to 6 and 10.  These values are substituted
for the formal parameters <tt>x</tt> and <tt>y</tt> in the body of <tt>sum-of-squares</tt>,
reducing the expression to</p>

<p class="trans" lang="ja">
こうして、問題は、二つのオペランドと <tt>sum-of-squares</tt> というオペレータとを持つコンビネーションの評価に帰着する。
このコンビネーションを評価することは、三つの副問題を含む。
適用されるべき手続きを知るために、オペレータを評価しなくてはならず、(二つの) 実引数を得るために、(二つの) オペランドを評価せねばならない。
ここで、<tt>(+ 5 1)</tt> は6となり、<tt>(* 5 2)</tt> は10となるので、私たちは、<tt>sum-of-squares</tt> という手続きを6と10に適用せねばならない。
これらの値は、<tt>sum-of-squares</tt> の本体の中の <tt>x</tt> および <tt>y</tt> という仮引数<ruby><rb>に代入され</rb><rp> (</rp><rt>の代わりに使われ</rt><rp>) </rp></ruby>、すると、式は次のようになる。
</p>

<p class="lisp">(+ (square 6) (square 10))</p>

<p class="orig" lang="en">
If we use the definition of <tt>square</tt>, this reduces to</p>

<p class="trans" lang="ja">
<tt>square</tt> の定義を使うと、これは、次のようになる。
</p>

<p class="lisp">(+ (* 6 6) (* 10 10))</p>

<p class="orig" lang="en">
which reduces by multiplication to</p>

<p class="trans" lang="ja">
乗算によって、これは、次のようになる。
</p>

<p class="lisp">(+ 36 100)</p>

<p class="orig" lang="en">
and finally to</p>

<p class="trans" lang="ja">
そして、最後に、以下のようになる。
</p>

<p class="lisp">136</p>

<p class="orig" lang="en">
The process we have just described is called the <em>substitution
model</em> for procedure application.  It can be taken as a model that
determines the ``meaning'' of procedure application, insofar as the
procedures in this chapter are concerned.  However, there are two
points that should be stressed:</p>

<p class="trans" lang="ja">
今まさに説明したプロセスが、手続き適用に関する<em><ruby><rb>代入</rb><rp> (</rp><rt>おきかえ</rt><rp>) </rp></ruby>モデル</em>と呼ばれる。
これは、手続き適用の「意味」を決定するモデルだと理解され得る——本章に出てくる手続きに関する限りは。
しかし、強調すべき点が二つある。
</p>

<ul class="orig" lang="en">
<li>The purpose of the substitution is to help us think about
procedure application, not to provide a description of how
the interpreter really works.  Typical interpreters do not evaluate
procedure applications by manipulating the text of a procedure to
substitute values for the formal parameters.  In practice, the
``substitution'' is accomplished by using a local environment for the
formal parameters.  We will discuss this more fully in chapters 3 and
4 when we examine the implementation of an interpreter in detail.</li>

<li>Over the course of this book, we will present a sequence of
increasingly elaborate models of how interpreters work, culminating
with a complete implementation of an interpreter and compiler in
chapter&nbsp;5.  The substitution model is only the first of these
models -- a way to get started thinking formally about the evaluation
process.  In general, when <a name="%_idx_336"></a>modeling phenomena in science and
engineering, we begin with simplified, incomplete models.  As we
examine things in greater detail, these simple models become
inadequate and must be replaced by more refined models.  The
substitution model is no exception.  In particular, when we address in
chapter&nbsp;3 the use of procedures with ``mutable data,'' we will see that
the substitution model breaks down and must be replaced by a more
complicated model of procedure application.<a name="call_footnote_Temp_21" href="#footnote_Temp_21"><sup><small>15</small></sup></a></li>
</ul>



<ul class="trans" lang="ja">
<li>
<ruby><rb>代入</rb><rp> (</rp><rt>おきかえ</rt><rp>) </rp></ruby>の目的は、私たちが手続き適用について考えるのを手助けすることであって、インタプリタが現実にどう動くのかという説明を与えることではなない。
<!--典型的なインタプリタは、仮引数に値を代入するために手続きの字面を操作することで手続き適用を評価する、というわけではない。-->
典型的なインタプリタは、<ruby><rb>仮引数に値を代入する</rb><rp> (</rp><rt>仮引数を値で置き換える</rt><rp>) </rp></ruby>べく手続きの字面を操作することによって手続き適用を評価する、というわけではない。
実際には、「<ruby><rb>代入</rb><rp> (</rp><rt>おきかえ</rt><rp>) </rp></ruby>」は、仮引数のための局所的な環境を使うことにより、達成される。
このことについては、3章と4章でインタプリタの実装について詳細に検討する際に、もっと詳しく論じよう。
</li>
<li>
本書の課程全体にわたって、私たちは、インタプリタがどう動くのかについての、段々と入念になっていく一連のモデル——5章において、インタプリタとコンパイラの完全な実装にまで達する——を提示してゆこう。
<ruby><rb>代入</rb><rp> (</rp><rt>おきかえ</rt><rp>) </rp></ruby>モデルは、これらのモデルのうちの最初のもの——評価プロセスについて形式的に考えることを始めるための方法——にすぎない。
一般に、科学や工学で諸現象をモデル化するときには、簡略化された不完全なモデルから始めるものである。
私たちがさらに詳細にものごとを検討するにつれて、これらの単純なモデルは、不適切になり、より精巧なモデルに置き換えねばならなくなる。
<ruby><rb>代入</rb><rp> (</rp><rt>おきかえ</rt><rp>) </rp></ruby>モデルも例外ではない。
特に、「<!--変異しやすい--><ruby><rb>変更可能</rb><rp> (</rp><rt>ミュータブル</rt><rp>) </rp></ruby>なデータ」を使った手続きの使い方に3章で取り組むとき、私たちは、<ruby><rb>代入</rb><rp> (</rp><rt>おきかえ</rt><rp>) </rp></ruby>モデルが破綻し、手続き適用についてのより複雑なモデルに置き換えられなくてはならない、と分かるだろう<a href="#footnote_Temp_21"><sup><small>15</small></sup></a>。
</li>
</ul>

<a name="%_sec_Temp_22"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_22">Applicative order versus normal order</a></h4>
<h4 class="trans" lang="ja">適用順と正規順</h4>
<p class="orig" lang="en">
According to the description of evaluation given in
section&nbsp;<a href="#%_sec_1.1.3">1.1.3</a>, the interpreter first
evaluates the operator and operands and then applies the resulting procedure
to the resulting arguments.  This is not the only way to perform
evaluation.  An alternative evaluation model would not evaluate the
operands until their values were needed.  Instead it would first substitute
operand expressions for parameters until
it obtained an expression involving only primitive operators, and
would then perform the evaluation.  If we used this method, the
evaluation of</p>

<p class="trans" lang="ja">
<a href="#%_sec_1.1.3">1.1.3</a>節での評価の説明によれば、インタプリタは、最初に<ruby><rb>演算子</rb><rp> (</rp><rt>オペレータ</rt><rp>) </rp></ruby>とオペランドを評価し、それから、結果として得られた手続きを、結果として得られた実引数に適用する。
これは、評価を実行するための唯一の方法ではない。
別の評価モデルでは、オペランドの値が必要になるまでは、オペランドを評価しないだろう。
<!--代わりに、先に仮引数にオペランド式を代入することを、原始的オペレータのみを含む式を得るまで続け、それから評価を実行するだろう。-->
その代わり、先に<ruby><rb>オペランドの式を仮引数に代入する</rb><rp> (</rp><rt>オペランドの式で仮引数を置き換える</rt><rp>) </rp></ruby>ことを、原始的演算子のみを含む一つの式を得るまで続け、それから評価を実行するだろう。
もしこの方法を使ったなら、以下のものの評価は、
</p>

<p class="lisp">(f 5)</p>

<p class="orig" lang="en">
would proceed according to the sequence of expansions</p>

<p class="trans" lang="ja">
以下の一連の式にしたがって進むだろう。
</p>

<p class="lisp">(sum-of-squares (+ 5 1) (* 5 2))

(+    (square (+ 5 1))      (square (* 5 2))  )

(+    (* (+ 5 1) (+ 5 1))   (* (* 5 2) (* 5 2)))
</p>

<p class="orig" lang="en">
followed by the reductions</p>

<p class="trans" lang="ja">
その後、以下の簡約<!--縮約--><!--還元-->が続く。
</p>

<p class="lisp">(+         (* 6 6)             (* 10 10))

(+           36                   100)

                    136
</p>

<p class="orig" lang="en">
This gives the same answer as our previous evaluation model, but the
process is different.  In particular, the evaluations
of <tt>(+ 5 1)</tt> and <tt>(* 5 2)</tt> are each performed twice here,
corresponding to the reduction of the expression</p>

<p class="trans" lang="ja">
これは、前の評価モデルと同じ答えを与えてくれるが、過程が異なる。
特に、<tt>(+ 5 1)</tt> と <tt>(* 5 2)</tt> の評価が、ここではそれぞれ2回ずつ実行される——それは、次の式の簡約<!--縮約-->に対応しており、
</p>

<p class="lisp">(* x x)</p>

<p class="orig" lang="en">
with <tt>x</tt> replaced respectively by <tt>(+ 5 1)</tt> and <tt>(* 5 2)</tt>.</p>

<p class="trans" lang="ja">
ここでの <tt>x</tt> は、<tt>(+ 5 1)</tt> と <tt>(* 5 2)</tt> のそれぞれに置き換えられている。
</p>

<p class="orig" lang="en">
This alternative ``fully expand and then reduce'' evaluation method is
known as <a name="%_idx_340"></a><em>normal-order evaluation</em>, in contrast to the ``evaluate
the arguments and then apply'' method that the interpreter actually
uses, which is called <a name="%_idx_342"></a><em>applicative-order evaluation</em>.  It can be
shown that, for procedure applications that can be modeled using
substitution (including all the procedures in the first two chapters
of this book) and that yield legitimate values, normal-order and
applicative-order evaluation produce the same value.  (See
exercise&nbsp;<a href="#%_thm_1.5">1.5</a> for an instance of
an ``illegitimate'' value where normal-order and applicative-order
evaluation do not give the same result.)</p>

<p class="trans" lang="ja">
この代替的な「完全に展開して、それから簡約<!--縮約-->する」評価方法は、<em>正規順の評価</em>として知られていて、これは、インタプリタが実際に使っている「実引数を評価して、それから適用する」方法——<em>適用順の評価</em>と呼ばれる——とは対照的である。
<ruby><rb>代入</rb><rp> (</rp><rt>おきかえ</rt><rp>) </rp></ruby>を使ってモデル化できる手続き適用 (本書の最初の二つの章の中のすべての手続きを含む) であって、正当な値を生み出すものに関しては、正規順と適用順の評価が同じ値をもたらす、と示せる
(正規順と適用順の評価が同じ結果にならないような「不法な」値の例については、練習問題<a href="#%_thm_1.5">1.5</a>を参照のこと)。
</p>

<p class="orig" lang="en">
<a name="%_idx_344"></a><a name="%_idx_346"></a>Lisp uses applicative-order evaluation, partly because of the
additional efficiency obtained from avoiding multiple evaluations of
expressions such as those illustrated with <tt>(+ 5 1)</tt> and <tt>(* 5
2)</tt> above and, more significantly, because normal-order evaluation
becomes much more complicated to deal with when we leave the realm of
procedures that can be modeled by substitution.  On the other hand,
normal-order evaluation can be an extremely valuable tool, and we will
investigate some of its implications in chapters 3 and 4.<a name="call_footnote_Temp_23" href="#footnote_Temp_23"><sup><small>16</small></sup></a></p>

<p class="trans" lang="ja">
Lispは適用順の評価を使う——これは、ある程度は、上記の <tt>(+ 5 1)</tt> と <tt>(* 5 2)</tt> で例示したような、式の複数回の評価を避けることから得られる追加的な効率性のためであり、より重大なことには、<ruby><rb>代入</rb><rp> (</rp><rt>おきかえ</rt><rp>) </rp></ruby>によりモデル化できる手続きの領域を出たときに、正規順の評価は、うまく取り扱える程度よりも、ずっと複雑になってしまうからである。
その一方で、正規順の評価は、きわめて有益な道具であり、私たちは、正規順の評価の含意のいくつかを3章と4章で研究するつもりだ<a href="#footnote_Temp_23"><sup><small>16</small></sup></a></a>。
</p>

<a name="%_sec_1.1.6"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_1.1.6">1.1.6&nbsp;&nbsp;Conditional Expressions and Predicates</a></h3>
<h3 class="trans" lang="ja">1.1.6 条件付きの式と述語</h3>

<p class="orig" lang="en">
The expressive power of the class of procedures that we can define at
this point is very limited, because we have no way to make tests and
to perform different operations depending on the result of a test.
For instance, we cannot define a procedure that computes the <a name="%_idx_348"></a>absolute
value of a number by testing whether the number is positive, negative,
or zero and taking different actions in the different cases according
to the rule</p>

<p class="trans" lang="ja">
現時点で私たちが定義できる部類の手続きの表現能力は、とても限定されている。なぜなら、テストを行い、テストの結果に応じて異なる演算を実行する方法がないからだ。
たとえば、数が正か負かゼロかをテストし、以下の規則にしたがって、異なる場合に異なる行動をとることによって、数の絶対値を計算するような手続きを、定義することができないのだ。
</p>

<figure><img src="ch1-Z-G-2.gif" border="0"></figure>

<p class="orig" lang="en">
<a name="%_idx_350"></a>This construct is called a <em>case analysis</em>, and
there is a special form in Lisp for notating such a case
analysis.  It is called <a name="%_idx_352"></a><a name="%_idx_354"></a><a name="%_idx_356"></a><tt>cond</tt> (which stands for
``conditional''), and it is used as follows:</p>

<p class="trans" lang="ja">
この構成法は、<em>場合わけ分析</em>と呼ばれ、Lispには、そういう場合わけ分析を記述するための特殊形式がある。
それは <tt>cond</tt> と呼ばれ (&ldquo;conditional&rdquo;の略である)、次のように使われる。
</p>

<p class="lisp"><a name="%_idx_358"></a>(define (abs x)
  (cond ((&gt; x 0) x)
        ((= x 0) 0)
        ((&lt; x 0) (- x))))
</p>

<p class="orig" lang="en">
The general form of a conditional expression is</p>

<p class="trans" lang="ja">
条件付きの式の一般的形式は以下のとおりで、
</p>

<p class="lisp">(cond (&lt;<em>p<sub>1</sub></em>&gt; &lt;<em>e<sub>1</sub></em>&gt;)
      (&lt;<em>p<sub>2</sub></em>&gt; &lt;<em>e<sub>2</sub></em>&gt;)
      <img src="book-Z-G-D-18.gif" border="0">
      (&lt;<em>p<sub><em>n</em></sub></em>&gt; &lt;<em>e<sub><em>n</em></sub></em>&gt;))
</p>

<p class="orig" lang="en">
consisting of the symbol <tt>cond</tt> followed by
<a name="%_idx_360"></a>parenthesized pairs of expressions <tt>(&lt;<em>p</em>&gt;&nbsp;&lt;<em>e</em>&gt;)</tt>
called <a name="%_idx_362"></a><a name="%_idx_364"></a><em>clauses</em>. The first expression in each pair is a <a name="%_idx_366"></a><em>predicate</em> -- that is, an expression whose value is interpreted as
either true or false.<a name="call_footnote_Temp_24" href="#footnote_Temp_24"><sup><small>17</small></sup></a></p>

<p class="trans" lang="ja">
<tt>cond</tt> という<ruby><rb>記号</rb><rp> (</rp><rt>シンボル</rt><rp>) </rp></ruby>と、それに続く、
<tt>(&lt;<em class="en">p</em>&gt; &lt;<em class="en">e</em>&gt;)</tt>
という<!--ふうに-->括弧で囲まれた式のペア——<em><ruby><rb>節</rb><rp> (</rp><rt>せつ</rt><rp>) </rp></ruby></em>と呼ばれる——のいくつかからなる。
各ペアの一番目の式は、<em>述語</em>——つまり、その値が真か偽と解釈される式——である<a href="#footnote_Temp_24"><sup><small>17</small></sup></a>。
</p>

<p class="orig" lang="en">
<a name="%_idx_384"></a><a name="%_idx_386"></a>Conditional expressions are evaluated as follows.  The predicate
&lt;<em>p<sub>1</sub></em>&gt; is evaluated first.  If its value is false, then
&lt;<em>p<sub>2</sub></em>&gt; is evaluated.  If &lt;<em>p<sub>2</sub></em>&gt;'s value is also false, then
&lt;<em>p<sub>3</sub></em>&gt; is evaluated.  This process continues until a predicate is
found whose value is true, in which case the interpreter returns the
value of the corresponding <a name="%_idx_388"></a><em>consequent expression</em> &lt;<em>e</em>&gt; of the
clause as the value of the conditional expression.  If none of the
&lt;<em>p</em>&gt;'s is found to be true, the value of the <tt>cond</tt> is
undefined.</p>

<p class="trans" lang="ja">
条件付きの式は、次のように評価される。
最初に、
&lt;<em class="en">p<sub>1</sub></em>&gt;
という述語が評価される。
もしその値が偽なら、
&lt;<em class="en">p<sub>2</sub></em>&gt;
が評価される。
もし
&lt;<em class="en">p<sub>2</sub></em>&gt;
の値も偽なら、
&lt;<em class="en">p<sub>3</sub></em>&gt;
が評価される。
このプロセスは、値が真の述語が見つかるまで続き、値が真の述語が見つかった場合、インタプリタは、同じ節の中の、
&lt;<em class="en">e</em>&gt;
という、対応する<em>帰結式</em>の値を、条件付きの式の値として返す。
&lt;<em class="en">p</em>&gt;
のうちのどれも真でないと判明した場合には、<tt>cond</tt> の値は未定義である。
</p>

<p class="orig" lang="en">
<a name="%_idx_390"></a>The word <em>predicate</em> is used for procedures that return true
or false, as well as for expressions that evaluate to true or false.
The absolute-value procedure <tt>abs</tt> makes use of the <a name="%_idx_392"></a><a name="%_idx_394"></a><a name="%_idx_396"></a><a name="%_idx_398"></a><a name="%_idx_400"></a><a name="%_idx_402"></a><a name="%_idx_404"></a><a name="%_idx_406"></a><a name="%_idx_408"></a>primitive
predicates <tt>&gt;</tt>, <tt>&lt;</tt>, and <tt>=</tt>.<a name="call_footnote_Temp_25" href="#footnote_Temp_25"><sup><small>18</small></sup></a> These take two
numbers as arguments and test whether the first number is,
respectively, greater than, less than, or equal to the second number,
returning true or false accordingly.</p>

<p class="trans" lang="ja">
<em>述語</em>という言葉は、真または偽を返す手続きに対して使われ、評価すると真または偽になる式に対しても使われる。
<tt>abs</tt> という、絶対値についての手続きは、<tt>&gt;</tt> と <tt>&lt;</tt> と<tt>=</tt> という原始的述語を利用している<a href="#footnote_Temp_25"><sup><small>18</small></sup></a>。
これらの原始的述語は、二つの数を引数として取り、それぞれ、一番目の数が二番目の数より大きいか、二番目の数より小さいか、二番目の数と同じか、をテストし、その結果にしたがって、真または偽を返す。
</p>

<p class="orig" lang="en">
Another way to write the absolute-value procedure is</p>


<p class="trans" lang="ja">
絶対値についての手続きを書くための、もう一つの方法は、以下のとおりである。
</p>

<p class="lisp"><a name="%_idx_414"></a>(define (abs x)
  (cond ((&lt; x 0) (- x))
        (else x)))
</p>

<p class="orig" lang="en">
which could be expressed in English as ``If <em>x</em> is less than zero
return  - <em>x</em>; otherwise return <em>x</em>.''  <a name="%_idx_416"></a><tt>Else</tt> is a special symbol
that can be used in place of the &lt;<em>p</em>&gt; in the final clause of a <tt>cond</tt>.  This causes the <tt>cond</tt> to return as its value the value of
the corresponding &lt;<em>e</em>&gt; whenever all previous clauses have been
bypassed.  In fact, any expression that always evaluates to a true
value could be used as the &lt;<em>p</em>&gt; here.</p>

<p class="trans" lang="ja">
これは、英語で
&ldquo;If <em class="en">x</em> is less than zero return  <em class="en">&minus;x</em>; otherwise return <em class="en">x</em>&rdquo; 
(もし <em class="en">x</em> がゼロより小さければ <em class="en">&minus;x</em> を返し、さもなくば <em class="en">x</em> を返せ) と表現できるだろう。
<tt>else</tt> は、<tt>cond</tt> の最後の節の中で 
&lt;<em class="en">p</em>&gt;
の代わりに使える特殊な<ruby><rb>記号</rb><rp> (</rp><rt>シンボル</rt><rp>) </rp></ruby>である。
これ <span class="note">(<tt>else</tt> という記号) </span>は、<tt>cond</tt> に、先立つすべての節が<ruby><rb>迂回</rb><rp> (</rp><rt>バイパス</rt><rp>) </rp></ruby>された<!--避けられた-->ときにはいつでも、<span class="note">(<tt>else</tt> に) </span>対応する
&lt;<em class="en">e</em>&gt; の値を、<tt>cond</tt> の値として返させる。
実際、常に真値という評価になるような式は何であれ、ここの
&lt;<em class="en">p</em>&gt;
として使えただろう。
</p>

<p class="orig" lang="en">
Here is yet another way to write the absolute-value procedure:</p>

<p class="trans" lang="ja">
絶対値についての手続きを書くための、さらに別の方法は、以下のとおりである。
</p>

<p class="lisp"><a name="%_idx_418"></a>(define (abs x)
  (if (&lt; x 0)
      (- x)
      x))
</p>

<p class="orig" lang="en">
<a name="%_idx_420"></a><a name="%_idx_422"></a><a name="%_idx_424"></a>This uses the special form <tt>if</tt>, a restricted type of conditional
that can be used when there are precisely <a name="%_idx_426"></a>two cases in the case
analysis.  The general form of an <tt>if</tt> expression is</p>

<p class="trans" lang="ja">
これは、<tt>if</tt> という特殊形式——すなわち、場合わけ分析において、ちょうど二つの場合が存在するときに使えるような、限定された種類の条件節——を使っている。
<tt>if</tt> 式の一般的形式は、以下のとおりである。
</p>

<p class="lisp">(if &lt;<em>predicate</em>&gt; &lt;<em>consequent</em>&gt; &lt;<em>alternative</em>&gt;)
</p>

<p class="orig" lang="en">
<a name="%_idx_428"></a><a name="%_idx_430"></a><a name="%_idx_432"></a>To evaluate an <tt>if</tt> expression, the interpreter starts by evaluating
the <a name="%_idx_434"></a>&lt;<em>predicate</em>&gt; part of the expression.  If the &lt;<em>predicate</em>&gt;
evaluates to a true value, the interpreter then evaluates
the <a name="%_idx_436"></a>&lt;<em>consequent</em>&gt; and returns its value.  Otherwise it evaluates
the <a name="%_idx_438"></a>&lt;<em>alternative</em>&gt; and returns its value.<a name="call_footnote_Temp_26" href="#footnote_Temp_26"><sup><small>19</small></sup></a></p>

<p class="trans" lang="ja">
<tt>if</tt> 式を評価するために、インタプリタは、この式の
&lt;<em class="en">predicate</em>&gt;
部分を評価することから始める。
もし、
&lt;<em class="en">predicate</em>&gt;
が真値という評価になったら、インタプリタは、次に
&lt;<em class="en">consequent</em>&gt;
を評価して、その値を返す。
それ以外の場合、インタプリタは、
&lt;<em class="en">alternative</em>&gt;
を評価して、その値を返す<a href="#footnote_Temp_26"><sup><small>19</small></sup></a>。
</p>

<p class="orig" lang="en">
In addition to primitive
predicates such as <tt>&lt;</tt>, <tt>=</tt>, and <tt>&gt;</tt>, there are logical
composition operations, which enable us to construct compound
predicates.  The three most frequently used are these:</p>

<p class="trans" lang="ja">
<tt>&lt;</tt> や <tt>=</tt> や <tt>&gt;</tt> などの原始的述語に加えて、論理的合成演算があり、それによって、複合的な述語を構成することが可能となる。
もっとも頻繁に使われる三つの論理的合成演算は、以下のとおりである。
</p>

<ul class="orig" lang="en">
<a name="%_idx_446"></a><a name="%_idx_448"></a><a name="%_idx_450"></a><a name="%_idx_452"></a>
<li><tt>(and &lt;<em>e<sub>1</sub></em>&gt; <tt>...</tt> &lt;<em>e<sub><em>n</em></sub></em>&gt;)</tt>
<br>
The interpreter
evaluates the expressions &lt;<em>e</em>&gt; one at a time, in left-to-right order.  If
any &lt;<em>e</em>&gt; evaluates to false, the value of the <tt>and</tt>
expression is false, and the rest of the &lt;<em>e</em>&gt;'s are not evaluated.
If all &lt;<em>e</em>&gt;'s evaluate to true values, the value of the <tt>and</tt>
expression is the value of the last one.</li>

<a name="%_idx_454"></a><a name="%_idx_456"></a><a name="%_idx_458"></a><a name="%_idx_460"></a>
<li><tt>(or &lt;<em>e<sub>1</sub></em>&gt; <tt>...</tt> &lt;<em>e<sub><em>n</em></sub></em>&gt;)</tt>
<br>
The interpreter
evaluates the expressions &lt;<em>e</em>&gt; one at a time, in left-to-right order.  If
any &lt;<em>e</em>&gt; evaluates to a true value, that value is
returned as the value of the <tt>or</tt> expression,
and the rest of the &lt;<em>e</em>&gt;'s are not evaluated.
If all &lt;<em>e</em>&gt;'s evaluate to false,
the value of the <tt>or</tt> expression is false.</li>

<a name="%_idx_462"></a><a name="%_idx_464"></a>
<li><tt>(not &lt;<em>e</em>&gt;)</tt>
<br>
The value of a <tt>not</tt> expression is true
when the expression &lt;<em>e</em>&gt; evaluates to false, and false otherwise.</li>
</ul>

<ul class="trans" lang="ja">
<li><tt>(and 
&lt;<em class="en">e<sub>1</sub></em>&gt; <tt>...</tt> 
&lt;<em class="en">e<sub>n</sub></em>&gt;)</tt>
<br>
インタプリタは、左から右の順で、
&lt;<em class="en">e</em>&gt;
という式を一つずつ評価してゆく。
もし、
&lt;<em class="en">e</em>&gt;
のどれかが偽という評価になったら、<tt>and</tt> 式の値は偽であり、残りの
&lt;<em class="en">e</em>&gt;
は評価されない。
<!--
<span class="note"> (この「残りは評価されない」という点は、副作用のある式を並べたときなどに、影響をよく考えるべき点である)</span>
-->
もし、すべての
&lt;<em class="en">e</em>&gt;
が真値という評価になったら、<tt>and</tt> 式の値は最後の
&lt;<em class="en">e</em>&gt;
の値である。</li>

<li><tt>(or 
&lt;<em class="en">e<sub>1</sub></em>&gt; <tt>...</tt> 
&lt;<em class="en">e<sub>n</sub></em>&gt;)</tt>
<br>
インタプリタは、左から右の順で、
&lt;<em class="en">e</em>&gt;
という式を一つずつ評価してゆく。
もし、
&lt;<em class="en">e</em>&gt;
のどれかが真値という評価になったら、その値が <tt>or</tt> 式の値として返され、残りの
&lt;<em class="en">e</em>&gt;
は評価されない。
もし、すべての
&lt;<em class="en">e</em>&gt;
が偽という評価になったら、<tt>or</tt> 式の値は偽である。</li>

<li><tt>(not &lt;<em class="en">e</em>&gt;)</tt>
<br>
<tt>not</tt> 式の値は、
&lt;<em class="en">e</em>&gt;
という式が偽という評価のときには真であり、その他の場合には偽である。</li>
</ul>

<p class="orig" lang="en">
<a name="%_idx_466"></a><a name="%_idx_468"></a>Notice that <tt>and</tt> and <tt>or</tt> are special forms, not procedures,
because the subexpressions are not necessarily all evaluated.
<tt>Not</tt> is an ordinary procedure.</p>

<p class="trans" lang="ja">
<tt>and</tt> と <tt>or</tt> が、特殊形式であり、手続きではない——なぜなら、部分式が必ずしもすべて評価されるわけではないから——ということに注意してほしい。
<tt>not</tt> は普通の手続きである。
</p>

<p class="orig" lang="en">
As an example of how these are used, the condition that a number <em>x</em>
be in the range 5 &lt; <em>x</em> &lt; 10 may be expressed as</p>

<p class="trans" lang="ja">
これらをどのように使うのか、という例として、<em class="en">x</em> という数が、
<span class="math">5 &lt; <em class="en">x</em> &lt; 10</span>
という範囲にあるという条件を、次のように表してみてもよい。
</p>

<p class="lisp">(and (&gt; x 5) (&lt; x 10))
</p>

<p class="orig" lang="en">
As another example, we can define a predicate to test whether one
number is greater than or equal to another as</p>

<p class="trans" lang="ja">
別の例として、一つの数がもう一つの数以上であるか否かをテストするための述語を、次のように定義することができる。
</p>

<p class="lisp"><a name="%_idx_470"></a>(define (&gt;= x y)
  (or (&gt; x y) (= x y)))
</p>

<p class="orig" lang="en">
or alternatively as</p>

<p class="trans" lang="ja">
あるいは次のようにしてもよい。
</p>

<p class="lisp"><a name="%_idx_472"></a>(define (&gt;= x y)
  (not (&lt; x y)))</p>

<p class="orig" lang="en">
<a name="%_thm_1.1"></a>
<b>Exercise 1.1.</b>&nbsp;&nbsp;Below is a sequence of expressions.  
What is the result printed by the interpreter in response to each
expression?  Assume that the sequence is to be evaluated in the order
in which it is presented.</p>

<p class="trans" lang="ja">
<b>練習問題 1.1</b>以下に示すのは、式の連なりである。
各々の式に応答してインタプリタにより印字される結果は何か?
なお、この式の連なりは、提示された順序で評価されることになる、と想定せよ。
</p>

<p class="lisp">10
(+ 5 3 4)
(- 9 1)
(/ 6 2)
(+ (* 2 4) (- 4 6))
(define a 3)
(define b (+ a 1))
(+ a b (* a b))
(= a b)
(if (and (&gt; b a) (&lt; b (* a b)))
    b
    a)
(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25))
(+ 2 (if (&gt; b a) b a))
(* (cond ((&gt; a b) a)
         ((&lt; a b) b)
         (else -1))
   (+ a 1))</p>

<p class="exercise">10
<i>10</i>

(+ 5 3 4)
<i>12</i>

(- 9 1)
<i>8</i>

(/ 6 2)
<i>3</i>

(+ (* 2 4) (- 4 6))
<i>6</i>

(define a 3)
<i><span class="ex_comment">[返り値は実装依存: ここでa=3となる]</span></i>

(define b (+ a 1))
<i><span class="ex_comment">[返り値は実装依存: ここでb=4となる]</span></i>

(+ a b (* a b))
<i>19</i>
  
(= a b)
<i>false</i>
  
(if (and (&gt; b a) (&lt; b (* a b)))
    b
    a)
<i>4</i>

(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25))
<i>16</i>

(+ 2 (if (&gt; b a) b a))
<i>6</i>

(* (cond ((&gt; a b) a)
         ((&lt; a b) b)
         (else -1))
   (+ a 1))
<i>16</i></p>


<p class="orig" lang="en">
<a name="%_thm_1.2"></a>
<b>Exercise 1.2.</b>&nbsp;&nbsp;Translate the following expression into prefix form</p>

<p class="trans" lang="ja">
<b>練習問題 1.2</b> 次の式を前置形式に書き直せ。
</p>

<figure>
<img src="ch1-Z-G-3.gif" border="0">
</figure>

<p class="exercise">(/ (+ 5 (+ 4 (- 2 (- 3 (+ 6 (/ 4 3))))))
   (* 3 (* (- 6 2) (- 2 7))))
<span class="ex_comment">; あるいは、以下でもよい。</span>
(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 3)))))
   (* 3 (- 6 2) (- 2 7)))</p>

<p class="orig" lang="en">
<a name="%_thm_1.3"></a>
<b>Exercise 1.3.</b>&nbsp;&nbsp;Define a procedure that takes three numbers as arguments and returns
the sum of the squares of the two larger numbers.</p>

<p class="trans" lang="ja">
<b>練習問題 1.3</b> 三つの数を引数として取り、そのうち大きい方から二つの数の二乗和を返すような手続きを定義せよ。
</p>

<p class="exercise">(define (sum-of-squares-of-larger-two a b c)
  (cond 
    <span class="ex_comment">; a&le;b かつ a&le;c なら、aを二乗和の対象から外してよい。</span>
    ((and (not (&lt; b a)) (not (&lt; c a)))
     (+ (* b b) (* c c)))
    <span class="ex_comment">; こう書くと、実際には、以下の場合がこの条件に該当する。</span>
    <span class="ex_comment">; a&lt;b&lt;c OR a&lt;b=c OR a=b&lt;c OR a=b=c OR a&lt;c&lt;b OR a=c&lt;b</span>

    <span class="ex_comment">; b&le;c かつ b&le;a なら、bを二乗和の対象から外してよい。</span>
    ((and (not (&lt; c b)) (not (&lt; a b)))
     (+ (* a a) (* c c)))
    <span class="ex_comment">; こう書くと、実際には、以下の場合がこの条件に該当する。</span>
    <span class="ex_comment">; b&lt;a&lt;c OR b&lt;a=c OR b&lt;c&lt;a OR b=c&lt;a</span>

    <span class="ex_comment">; その他。実際には、以下の場合がここに該当する。</span>
    <span class="ex_comment">; c&lt;a&lt;b OR c&lt;a=b OR c&lt;b&lt;a</span>
    (else (+ (* a a) (* b b)))))
</p>

<p class="orig" lang="en">
<a name="%_thm_1.4"></a>
<b>Exercise 1.4.</b>&nbsp;&nbsp;<a name="%_idx_474"></a><a name="%_idx_476"></a><a name="%_idx_478"></a>Observe that our model of evaluation allows for combinations whose
operators are compound expressions.  Use this observation to
describe the behavior of the following procedure:</p>

<p class="trans" lang="ja">
<b>練習問題 1.4.</b> 私たちの評価のモデルは、<ruby><rb>演算子</rb><rp> (</rp><rt>オペレータ</rt><rp>) </rp></ruby>が複合的な式であるようなコンビネーションを見越していることを観察せよ。
この観察結果を、以下の手続きの振る舞いを記述するのに使え。
</p>

<p class="lisp">(define (a-plus-abs-b a b)
  ((if (&gt; b 0) + -) a b))
</p>

<p class="exercise"><span class="ex_comment"><tt>b</tt> が正のとき、if節の値が <tt>+</tt> となって、<tt>(+ a b)</tt> が評価される。
一方、<tt>b</tt> がゼロか負のとき、if節の値が <tt>-</tt>となって、<tt>(- a b)</tt> が評価される
(と、いうことでしょう)</span>。</p>

<p class="orig" lang="en">
<a name="%_thm_1.5"></a>
<b>Exercise 1.5.</b>&nbsp;&nbsp;<a name="%_idx_480"></a><a name="%_idx_482"></a>Ben Bitdiddle has invented a test to determine whether the interpreter
he is faced with is using applicative-order evaluation or normal-order
evaluation.  He defines the following two procedures:</p>

<p class="trans" lang="ja">
<b>練習問題 1.5</b> ベン・ビットディドルは、自分が対面しているインタプリタが、適用順の評価を使っているのか、それとも正規順の評価を使っているのかを判定するテストを思いついた。
彼は、以下の二つの手続きを定義する。
</p>

<p class="lisp">(define (p) (p))

(define (test x y)
  (if (= x 0)
      0
      y))</p>

<p class="orig" lang="en">
Then he evaluates the expression</p>

<p class="trans" lang="ja">
そして、彼は以下の式を評価する。
</p>

<p class="lisp">(test 0 (p))</p>

<p class="orig" lang="en">
What behavior will Ben observe with an interpreter that uses
applicative-order evaluation?  What behavior will he observe with an
interpreter that uses normal-order evaluation?  Explain your answer.
<a name="%_idx_484"></a><a name="%_idx_486"></a>(Assume that the evaluation rule for the special form <tt>if</tt> is the
same whether the interpreter is using normal or applicative order:
The predicate expression is evaluated first, and the result
determines whether to evaluate
the consequent or the alternative expression.)</p>

<p class="trans" lang="ja">
適用順の評価を使うインタプリタを使ったとき、ベンはどのような振る舞いを観察するだろうか?
正規順の評価を使うインタプリタを使ったとき、彼はどのような振る舞いを観察するだろうか?
君の答えを説明せよ
(なお、インタプリタが正規順を使おうと、適用順を使おうと、<tt>if</tt>という特殊形式のための評価規則は同じである、と想定せよ。
つまり、述語式がまず評価され、その結果が、帰結式を評価すべきなのか代替式を評価すべきなのかを決定する、と想定せよ)。
</p>

<p class="exercise"><span class="ex_comment">ちょっと自分でも混乱したので、評価規則についてまとめてみた。
細かい順序を明文化すると、ほぼ以下のようになるかと思う
(本当に厳密なことを言い出すと、オペレータ自体が複合的な式の場合や
特殊形式の扱いに関して、どういう優先順で規則を適用していくのかが、
この書き方ではまだ少し曖昧なままなのかな、とも思うが)。

** 適用順の評価規則 **
(1) 評価すべき対象が単なる数なら、評価結果はその数自身である。
    特殊形式なら、特殊形式の評価規則にしたがって評価する。
    数でも特殊形式でもなければ (普通のコンビネーションなら)、(2)へ進む。
(2) 各オペランドを、本規則にしたがって評価する。
(3) オペレータが原始的なら (原始的演算をその値とする記号であるなら)、
    (2)の評価結果にオペレータを適用する。
    オペレータが原始的でないとき (ユーザにより定義された手続きをその値と
    する記号であるとき) は、その手続き定義の本体を取り出し、その本体の
    中の仮引数を(2)の評価結果で置き換え、こうして得られた式を、本規則に
    したがって評価する。
    オペレータ自体が複合的な式であれば、その式を本規則にしたがって評価し、
    その評価結果である手続きを、(2)の評価結果に適用する。

** 正規順の評価規則 **
(1) まず「展開」する。
(1-1) 展開の対象が単なる数なら、その数自身が展開結果である。
(1-2) 展開の対象が特殊形式なら、特殊形式の評価規則にしたがった順序で
      評価を進める。ただし、そうやって部分式を「評価」する際には、本規則に
      したがって、その部分式を評価する。
(1-3) 数でも特殊形式でもない普通のコンビネーションであって、かつ、その
      オペレータが原始的な場合 (原始的演算をその値とする記号である場合) は、
      各オペランドについて、(1)の作業を行う (それにより、オペランドを
      「展開」する)。
(1-4) 数でも特殊形式でもない普通のコンビネーションであって、かつ、その
      オペレータが原始的でない場合 (ユーザにより定義された手続きをその値と
      する記号の場合) は、その手続き定義の本体を取り出し、その本体の中の
      仮引数を、いま展開の対象としている式のオペランドで置き換える。
      そして、こうして「展開」した式について、(1)の作業を行う (それにより、
      「展開」をさらに進める)。
(1-5) 数でも特殊形式でもない普通のコンビネーションであって、かつ、その
      オペレータが自体が複合的な式であれば、その式を本規則にしたがって
      展開・評価して、その結果得られた式について、(1)の作業を行う (それに
      より、「展開」を進める)。
(2) 以上により、「入れ子になったすべての部分式においてオペレータが原始的で
    あるような式」が得られるはずである (完全に展開し終わった状態になって
    いるはずである)。そこで、次に「評価」を行う。
(2-1) 評価すべき対象が単なる数なら、評価結果はその数自身である。
(2-2) 評価すべき対象がコンビネーションなら、各オペランドを、(2-1)と(2-2)の
      規則にしたがって評価し、その評価結果に、オペレータを適用する。

以上を踏まえて、以下に本問の解答案を示す。</span></p>

<p class="exercise"><span class="ex_comment">** 適用順の場合 **

(1) <tt>(test <span class="hilit1">0</span> <span class="hilit2">(p)</span>)</tt> の実引数をまず評価しようとする。<span class="hilit1"><tt>0</tt></span> の評価結果は 0 そのものだから、
    ここまでは何も問題がない。
(2) 次の引数である <tt><span class="hilit2">(p)</span></tt> を評価しようとする。ここで、この <tt><span class="hilit2">(p)</span></tt> というコンビネーションの
    オペレータは <tt>p</tt> という手続きであり、オペランドはない (0個 である)。
(3) オペランドがないからオペランドの評価は終わり。これも問題なし。
(4) そこで、次の段階として、オペレータである <tt>p</tt> の定義を調べると、
    <tt>(define (p) <span class="hilit3">(p)</span>)</tt> である。つまり、この手続き定義の本体、すなわち、<tt><span class="hilit3">(p)</span></tt> を
    評価することで、(2) で評価しようとしている <tt><span class="hilit2">(p)</span></tt> の評価結果が得られるということ。
     そこで、「さあ、<tt><span class="hilit3">(p)</span></tt> を評価するぞ」となるのだが……。
(5) これはつまり、(2) の<tt><span class="hilit2">(p)</span></tt> の評価のためにはまず (4) の <tt><span class="hilit3">(p)</span></tt> を評価せねばならず、
    その (4) の <tt><span class="hilit3">(p)</span></tt> の評価のためにはこれの手続き本体である <tt><span class="hilit4">(p)</span></tt> を評価せねばならず……、
    という無限ループに陥ることを意味する。

と、いうわけで、
  * まったく何も応答が返ってこない、あるいは、
  * しばらくしてスタックオーバフローのエラーメッセージが出る、
といった、正常でない状態となり、返り値は得られない (と、思う)。</span></p>

<p class="exercise"><span class="ex_comment">** 正規順の場合 **

(1) <tt>(test 0 (p))</tt> のオペレータである <tt>test</tt> は原始的ではないので、<tt>test</tt> の定義を
    調べると、<tt>(define (test x y) <span class="hilit5">(if (= x 0) 0 y)</span>)</tt> である。
(2) よって、この本体 <tt><span class="hilit5">(if (= x 0) 0 y)</span></tt> において、<tt>x</tt> を <tt>0</tt> という実引数で置き換え、
    <tt>y</tt> を <tt>(p)</tt> という実引数で置き換える。すると、<tt>(if <span class="hilit6">(= 0 0)</span> <span class="hilit7">0</span> <span class="hilit8">(p)</span>)</tt> となる。
(3) さて、<tt>if</tt> は特殊形式なので、まず<span class="hilit6">述語式</span>を評価する。
    ここでは、<span class="hilit6">述語式</span>の評価結果は真である。つまり、<tt><span class="hilit6">(= 0 0)</span></tt> という条件が成立している。
(4) よって、<span class="hilit7">帰結式</span> (すなわち <span class="hilit7"><tt>0</tt></span> のこと) を評価すればよく、これの評価結果は 0 自体である。
    <span class="hilit8">代替式</span> (すなわち <span class="hilit8"><tt>(p)</tt></span> のこと) の評価にはまったく踏み込まなくてよい。
(5) 以上のとおり、<tt>(if <span class="hilit6">(= 0 0)</span> <span class="hilit7">0</span> <span class="hilit8">(p)</span>)</tt> という <tt>if</tt> 式の評価結果は 0 である、と分かった。
    つまり、<tt>(test 0 (p))</tt> の評価結果として 0 が得られたということである。
    めでたしめでたし。</span></p>

<p class="exercise"><span class="ex_comment">ところでGaucheでトレースすると、以下のとおりで、止まらないのであった。</span>

gosh&gt; (use slib)
#&lt;undef&gt;
gosh&gt; (require 'trace)
#t
gosh&gt; (define (p) (p))
p
gosh&gt; (define (test x y)
  (if (= x 0)
      0
      y))
test
gosh&gt; (trace p test)
#&lt;closure (debug:trace-procedure debug:trace-procedure)&gt;
gosh&gt; (test 0 (p))
CALL p
  CALL p
    CALL p
      CALL p
        CALL p
<span class="ex_comment">(以下省略)</span>


<span class="ex_comment">MIT Schemeでトレースしてみても、以下のとおりで、止まらないのであった。</span>

1 ]=&gt; (define (p) (p))

;Value: p

1 ]=&gt; (define (test x y)
  (if (= x 0)
      0
      y))

;Value: test

1 ]=&gt; (trace p)

;Unspecified return value

1 ]=&gt; (trace test)

;Unspecified return value

1 ]=&gt; (test 0 (p))

[Entering #[compound-procedure 2 p]]
[Entering #[compound-procedure 2 p]]
[Entering #[compound-procedure 2 p]]
[Entering #[compound-procedure 2 p]]
[Entering #[compound-procedure 2 p]]
[Entering #[compound-procedure 2 p]]
[Entering #[compound-procedure 2 p]]
[Entering #[compound-procedure 2 p]]
[Entering #[compound-procedure 2 p]]
[Entering #[compound-procedure 2 p]]
[Entering #[compound-procedure 2 p]]
[Entering #[compound-procedure 2 p]]

<span class="ex_comment">(以下省略)</span>
</p>

<a name="%_sec_1.1.7"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_1.1.7">1.1.7&nbsp;&nbsp;Example: Square Roots by Newton's Method</a></h3>
<h3 class="trans" lang="ja">1.1.7 例: ニュートン法による二乗根</h3>

<p class="orig" lang="en">
<a name="%_idx_488"></a><a name="%_idx_490"></a>Procedures, as introduced above, are much like ordinary mathematical
functions.  They specify a value that is determined by one or more
parameters.  But there is an important difference between
mathematical functions and computer procedures.  Procedures must be
effective.</p>

<p class="trans" lang="ja">
ここまでで導入したような手続きは、通常の数学的関数によく似ている。
それらは、一つ以上のパラメタにより決められる値を指定する。
しかし、数学的関数とコンピュータ手続きの間には、重要な違いがある。
手続きは、効力を生じるものでなければならない。
</p>

<p class="orig" lang="en">
As a case in point, consider the problem of computing square
roots.  We can define the square-root function as</p>

<p class="trans" lang="ja">
適切な例として、二乗根を計算する問題を考えよう。
二乗根の関数は、以下のように定義できる。
</p>

<figure>
<img src="ch1-Z-G-4.gif" border="0">
</figure>

<p class="orig" lang="en">
This describes a perfectly legitimate mathematical function.  We could
use it to recognize whether one number is the square root of another, or
to derive facts about square roots in general.  On the other hand, the
definition does not describe a procedure.  Indeed, it tells us almost
nothing about how to actually find the square root of a given number.  It
will not help matters to rephrase this definition in pseudo-Lisp:</p>

<p class="trans" lang="ja">
これは、完全に論理的正当性のある数学的関数である。
ある一つの数が、もう一つの別の数の二乗根であるかどうかを判別するために、あるいは、二乗根に関する一般的な事実を導出するために、この数学的関数を使うこともできるだろう。
一方、この定義は、手続きを記述していない。
実際、与えられた値の二乗根を現実にどうやって見つけるのかについては、この数学的関数は、ほとんど何も示していない。
この定義を以下のような擬似Lispで言い換えても、事態を解決することにはならないだろう。
</p>

<p class="lisp">(define (sqrt x)
  (the y (and (&gt;= y 0)
              (= (square y) x))))</p>

<p class="orig" lang="en">
This only begs the question.</p>

<p class="trans" lang="ja">
これは、問題が解決したふりをしているだけだ。
</p>

<p class="orig" lang="en">
The contrast between function and procedure is a reflection of the
general distinction between describing properties of things and
describing how to do things, or, as it is sometimes referred to, the
distinction between <a name="%_idx_492"></a><a name="%_idx_494"></a>declarative knowledge and imperative knowledge.
In <a name="%_idx_496"></a><a name="%_idx_498"></a>mathematics we are usually concerned with declarative (what is)
descriptions, whereas in computer science we are usually concerned
with imperative (how to) descriptions.<a name="call_footnote_Temp_32" href="#footnote_Temp_32"><sup><small>20</small></sup></a></p>

<p class="trans" lang="ja">
関数と手続きの相違は、ものごとの性質を記述することと、ものごとをどうやって行うのかを記述することとの間の一般的な区別——つまり、ときどき言われる言い方をするなら、宣言的知識と命令的知識の区別——を反映したものである。
数学では、私たちは普通、宣言的な (何か、という) 記述に関心があり、それに対して、計算機科学では、私たちは普通、命令的な (どうやって、という) 記述に関心がある<a href="#footnote_Temp_32"><sup><small>20</small></sup></a>。
</p>

<p class="orig" lang="en">
<a name="%_idx_508"></a><a name="%_idx_510"></a>
How does one compute square roots?  The most common way is to use
Newton's method of successive approximations, which says that whenever
we have a guess <em>y</em> for the value of the square root of a number <em>x</em>,
we can perform a simple manipulation to get a better guess (one closer
to the actual square root) by averaging <em>y</em> with
<em>x</em>/<em>y</em>.<a name="call_footnote_Temp_33" href="#footnote_Temp_33"><sup><small>21</small></sup></a> For example, we can compute
the square root of 2 as follows.  Suppose our initial guess is 1:</p>

<p class="trans" lang="ja">
人はどのようにして二乗根を計算するのか?
一番ありふれた方法は、近似を連続して行うニュートン法—— <em class="en">x</em> という数の二乗根の値についての見積もりである <em class="en">y</em> がありさえすれば、いつでも、より良い見積もり (実際の二乗根にさらに近い見積もり) を得るための単純な処理を、<em class="en">y</em> と 
<span class="math"><em class="en">x</em>/<em class="en">y</em></span>
の平均をとることで、実行できる、と述べている手法である——を使うことだ<a href="#footnote_Temp_33"><sup><small>21</small></sup></a>。
たとえば、2の二乗根を以下のように計算できる。
最初の見積もりを1としよう。
</p>

<figure>
<table class="common">
<tr><td>Guess </td><td>Quotient </td><td>Average</td></tr>
<tr><td>1      </td><td> (2/1)  =  2        </td><td>
((2 + 1)/2)  =  1.5 </td></tr>
<tr><td>1.5    </td><td> (2/1.5)  =  1.3333 </td><td>
((1.3333 + 1.5)/2)  =  1.4167 </td></tr>
<tr><td>1.4167 </td><td> (2/1.4167)  =  1.4118 </td><td>
((1.4167 + 1.4118)/2)  =  1.4142 </td></tr>
<tr><td>1.4142 </td><td><tt>...</tt></td><td><tt>...</tt></td></tr>
</table>
</figure>

<p class="orig" lang="en">
Continuing this process, we obtain better and better
approximations to the square root.</p>


<p class="trans" lang="ja">
このプロセスを続けると、二乗根についてのどんどん良い近似が得られる。
</p>

<p class="orig" lang="en">
Now let's formalize the process in terms of procedures.  We start with
a value for the <a name="%_idx_514"></a>radicand (the number whose square root we are trying
to compute) and a value for the guess.  If the guess is good enough
for our purposes, we are done; if not, we must repeat the process with an
improved guess.  We write this basic strategy as a procedure:</p>

<p class="trans" lang="ja">
では、このプロセスを、手続きの観点から形式化してみよう。
私たちは、被開数 (二乗根を計算しようとしている対象の数) の値と、見積もりの値から始める。
もし、見積もりが私たちの目的にとって十分に良ければ、完了である。
そうでなければ、改善した見積もりを使って、このプロセスを繰り返さなくてはならない。
この基本的な戦略を、私たちは次のような手続きとして書く。
</p>

<p class="lisp" id="define-sqrt-iter">(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x)
                 x)))
</p>

<p class="orig" lang="en">
A guess is improved by averaging
it with the quotient of the radicand and the old guess:</p>

<p class="trans" lang="ja">
見積もりの改善は、その見積もりを、被開数とその古くなった見積もり<!--と-->の商とあわせて平均することで、行われる。
<!--見積もりは、被開数と古い見積もりの商と、その見積もりとの平均をとることで、改善される。-->
<!--見積もりは、その見積もりを、被開数と古くなったその見積もりの商とあわせて平均をとることで、改善される。-->
<!--見積もりと、被開数と古くなったその見積もりの商とをあわせて平均をとることで、見積もりを改善する。-->
</p>


<p class="lisp" id="define-improve">(define (improve guess x)
  (average guess (/ x guess)))
</p>

<p class="orig" lang="en">where</p>
<p class="trans" lang="ja">ここで、以下のとおりとする。</p>

<p class="lisp"><a name="%_idx_516"></a>(define (average x y)
  (/ (+ x y) 2))
</p>

<p class="orig" lang="en">
We also have to say what we mean by ``good enough.''  The
following will do for illustration, but it is not really a very good
test.  (See exercise <a href="#%_thm_1.7">1.7</a>.)
The idea is to improve the answer until it is close enough so that its
square differs from the radicand by less than a predetermined
tolerance (here 0.001):<a name="call_footnote_Temp_34" href="#footnote_Temp_34"><sup><small>22</small></sup></a>
</p>

<p class="trans" lang="ja">
「十分に良い」とは何を意味するのか、についても述べなくてはならない。
以下に示すものは、説明の役には立つだろうが、現実にとても良いテストというわけではない
(練習問題<a href="#%_thm_1.7">1.7</a>を参照)。
ここで重要な点は、答えの二乗と被開数との差が所定の許容誤差 (ここでは0.001) 未満となるように、答えが十分に近づくまで、答えを改善するということである<a href="#footnote_Temp_34"><sup><small>22</small></sup></a>。
</p>

<p class="lisp" id="define-good-enough">(define (good-enough? guess x)
  (&lt; (abs (- (square guess) x)) 0.001))
</p>

<p class="orig" lang="en">
Finally, we need a way to get started.  For instance, we can
always guess that the square root of any number is 1:<a name="call_footnote_Temp_35" href="#footnote_Temp_35"><sup><small>23</small></sup></a></p>

<p class="trans" lang="ja">
最後に、処理を開始するための方法が必要だ。
たとえば、いかなる数の二乗根も1である、と常に同じように見積もることも可能だ<a href="#footnote_Temp_35"><sup><small>23</small></sup></a>。
</p>


<p class="lisp" id="define-sqrt"><a name="%_idx_550"></a>(define (sqrt x)
  (sqrt-iter 1.0 x))
</p>

<p class="orig" lang="en">If we type these definitions to the interpreter, we can use <tt>sqrt</tt>
just as we can use any procedure:</p>

<p class="trans" lang="ja">
これらの定義をインタプリタに打ち込んだ暁には、私たちは、どんな手続きでも使えるのと同様に、<tt>sqrt</tt>を使えるようになる。
</p>

<p class="lisp">(sqrt 9)
<i>3.00009155413138</i>
(sqrt (+ 100 37))
<i>11.704699917758145</i>
(sqrt (+ (sqrt 2) (sqrt 3)))
<i>1.7739279023207892</i>
(square (sqrt 1000))
<i>1000.000369924366</i>
</p>

<a name="%_idx_552"></a>
<p class="orig" lang="en">
The <tt>sqrt</tt> program also illustrates that the simple procedural
language we have introduced so far is sufficient for writing any
purely numerical program that one could write in, say, C or
Pascal.  This might seem surprising, since we have not included in
our language any iterative <a name="%_idx_554"></a>(looping) constructs that direct the
computer to do something over and over again.  <tt>Sqrt-iter</tt>, on the
other hand, demonstrates how iteration can be accomplished using no
special construct other than the ordinary ability to call a
procedure.<a name="call_footnote_Temp_36" href="#footnote_Temp_36"><sup><small>24</small></sup></a>
</p>

<p class="trans" lang="ja">
<tt>sqrt</tt>プログラムは、私たちが今までに導入してきた単純な手続き的言語に、例えばCまたはPascalで書き得るような純粋に数値的なプログラムなら何でも書けるだけの十分な能力があることをも、示している。
このことは意外かもしれない——というのも、コンピュータに対して何かを何度も繰り返して行うよう命令する繰り返し (ループ) 構造を、まだ何も私たちの言語には含めてはいないからだ。
一方、<tt>sqrt-iter</tt> は、手続きを呼び出す通常の能力以外の特殊な構造を何も使わずに、どうやったら反復を達成できるのか、ということを実証している<a href="#footnote_Temp_36"><sup><small>24</small></sup></a>。
</p>

<a name="%_thm_1.6"></a>
<p class="orig" lang="en">
<b>Exercise 1.6.</b>&nbsp;&nbsp;<a name="%_idx_556"></a><a name="%_idx_558"></a>Alyssa P. Hacker doesn't see why <tt>if</tt> needs
to be provided as a special form.  ``Why can't I just define it as an
ordinary procedure in terms of <tt>cond</tt>?'' she asks.
Alyssa's friend Eva Lu Ator claims this can indeed be done, and
she defines a new version of <tt>if</tt>:</p>

<p class="trans" lang="ja">
<b>練習問題 1.6.</b> アリッサ・P・ハッカは、なぜ<tt>if</tt>が特殊形式として提供される必要があるのか、分からない。
彼女は、「なぜ、単に<tt>cond</tt>の観点で書かれた普通の手続きとして、<tt>if</tt>を定義してはいけないの?」と尋ねる。
アリッサの友人のエヴァ・リュ・エイタは、実際それは可能だと主張し、<tt>if</tt>の新たなバージョンを次のように定義する。
</p>

<p class="lisp">(define (new-if predicate then-clause else-clause)
  (cond (predicate then-clause)
        (else else-clause)))
</p>

<p class="orig" lang="en">
Eva demonstrates the program for Alyssa:</p>

<p class="trans" lang="ja">
エヴァはこのプログラムをアリッサに対して実演してみせる。
</p>

<p class="lisp">(new-if (= 2 3) 0 5)
<i>5</i>

(new-if (= 1 1) 0 5)
<i>0</i>
</p>

<p class="orig" lang="en">
Delighted, Alyssa uses <tt>new-if</tt> to rewrite the square-root
program:</p>

<p class="trans" lang="ja">
アリッサは喜んで、<tt>new-if</tt>を使って、二乗根のプログラムを次のように書き換える。
</p>

<p class="lisp">(define (sqrt-iter guess x)
  (new-if (good-enough? guess x)
          guess
          (sqrt-iter (improve guess x)
                     x)))
</p>

<p class="orig" lang="en">
What happens when Alyssa attempts to use this to compute square roots?
Explain.</p>

<p class="trans" lang="ja">
二乗根を計算するためにアリッサがこれを使おうとすると、何が起こるか、説明せよ。
</p>

<p class="exercise"><span class="ex_comment">結論から言うと、<a href="#%_thm_1.5">練習問題 1.5</a>と同様に、正規順では問題が生じないが、
適用順だと無限ループに陥る。
なぜなら、<tt>if</tt>は特殊形式だが、<tt>new-if</tt>はそうではないためである。
以下、煩雑になるのを避けるため、<tt>abs</tt> は組み込みの関数 (原始的な
手続き) を使うものとして、計算の例を挙げる。</span></p>

<p class="exercise"><span class="ex_comment">(A) 正規順の場合の例
(1)</span> (<span class="hilit1">sqrt</span> 9) <span class="ex_comment">を展開して、</span>
<span id="ex1_5_A1">(<span class="hilit1">sqrt-iter</span> 1.0 9) <span class="ex_comment">となり、これをさらに展開して、</span>
(<span class="hilit1">new-if</span> <span class="hilit2">(good-enough? 1.0 9)</span>
        1.0
        <span class="hilit3">(sqrt-iter (improve 1.0 9) 9)</span>)
<span class="ex_comment">となり、これをさらに展開して、</span>
(cond (<span class="hilit2">(good-enough? 1.0 9)</span> 1.0)
      (else <span class="hilit3">(sqrt-iter (improve 1.0 9) 9)</span>))
<span class="ex_comment">となる。ここで <tt>cond</tt> は特殊形式なので、まず先に</span> <span class="hilit2">(good-enough? 1.0 9)</span> <span class="ex_comment">を評価する。</span>
<span class="ex_comment">その結果に応じて、</span> <span class="hilit3">(sqrt-iter (improve 1.0 9) 9)</span> <span class="ex_comment">を評価するかどうかが決まる。

(2) さて、</span>
(<span class="hilit2">good-enough?</span> 1.0 9)
<span class="ex_comment">を展開すると、</span>
(&lt; (abs (- (<span class="hilit2">square</span> 1.0) 9)) 0.001)
<span class="ex_comment">となり、これをさらに展開して、</span>
(&lt; (abs (- (* 1.0 1.0) 9)) 0.001)
<span class="ex_comment">となる。|1.0 &minus; 9| = 8 &gt; 0.001 だから、結局、評価結果は偽である。

(3) よって、今度は、(1) の最後に出てきた <tt>else</tt> 節の</span>
(<span class="hilit3">sqrt-iter</span> (improve 1.0 9) 9)
<span class="ex_comment">の評価に進む訳だが、これを展開すると、</span>
(<span class="hilit3">new-if</span> <span class="hilit4">(good-enough? (improve 1.0 9) 9)</span>
        (improve 1.0 9) 
        <span class="hilit5">(sqrt-iter (improve (improve 1.0 9) 9) 9)</span>)
<span class="ex_comment">となり、これをさらに展開して、</span>
(cond (<span class="hilit4">(good-enough? (improve 1.0 9) 9)</span> (improve 1.0 9))
      (else <span class="hilit5">(sqrt-iter (improve (improve 1.0 9) 9) 9)</span>))
<span class="ex_comment">となる。

(4) ここで <tt>cond</tt> は特殊形式なので、まず先に</span>
(<span class="hilit4">good-enough?</span> <span class="hilit6">(improve 1.0 9)</span> 9)
<span class="ex_comment">を評価するために、これを展開すると、</span>
(&lt; (abs (- (<span class="hilit4">square</span> <span class="hilit6">(improve 1.0 9)</span>) 9)) 0.001)
<span class="ex_comment">となり、これをさらに展開して、</span>
(&lt; (abs (- (* <span class="hilit6">(improve 1.0 9)</span> <span class="hilit6">(improve 1.0 9)</span>) 9)) 0.001)
<span class="ex_comment">となり、これをさらに展開して、</span>
(&lt; (abs (- (* <span class="hilit6">(average 1.0 (/ 9 1.0))</span> <span class="hilit6">(average 1.0 (/ 9 1.0))</span>) 9)) 0.001)
<span class="ex_comment">となり、これをさらに展開して、</span>
(&lt; (abs (- (* <span class="hilit6">(/ (+ 1.0 (/ 9 1.0)) 2)</span> <span class="hilit6">(/ (+ 1.0 (/ 9 1.0)) 2)</span>) 9)) 0.001)
<span class="ex_comment">もうプリミティブな演算子・関数のみだから、どんどん適用すると、</span>
(&lt; (abs (- (* 5.0 5.0) 9)) 0.001)
<span class="ex_comment">となって、さらに、</span>
(&lt; 16.0 0.001)
<span class="ex_comment">となって、結果は偽。

(5) よって、今度は、(3) の最後に出てきた <tt>else</tt> 節の</span>
(<span class="hilit5">sqrt-iter</span> (improve (improve 1.0 9) 9) 9)
<span class="ex_comment">の評価に進む訳だが、これを展開すると、</span>
(<span class="hilit5">new-if</span> <span class="hilit7">(good-enough? (improve (improve 1.0 9) 9) 9)</span>
        (improve (improve 1.0 9) 9)
        <span class="hilit8">(sqrt-iter (improve (improve (improve 1.0 9) 9) 9) 9)</span>)
<span class="ex_comment">となり、これをさらに展開して、</span>
(cond (<span class="hilit7">(good-enough? (improve (improve 1.0 9) 9) 9)</span>
         (improve (improve 1.0 9) 9))
      (else <span class="hilit8">(sqrt-iter (improve (improve (improve 1.0 9) 9) 9) 9)</span>))
<span class="ex_comment">となる。

(6) ここで <tt>cond</tt> は特殊形式なので、まず先に</span>
(<span class="hilit7">good-enough?</span> (improve (improve 1.0 9) 9) 9)
<span class="ex_comment">を評価する。展開と評価の途中の詳細は略すが、</span>
(&lt; (abs (- (* 3.4 3.4) 9)) 0.001)
<span class="ex_comment">に帰着する。これは偽である。

(7) よって、今度は、(5) の最後に出てきた <tt>else</tt> 節の</span>
(<span class="hilit8">sqrt-iter</span> (improve (improve (improve 1.0 9) 9) 9) 9)
<span class="ex_comment">の評価に進む訳だが、上記と同様にして <tt>sqrt-iter</tt> から <tt>new-if</tt> へ、
そしてそこから <tt>cond</tt> へ、という展開により、</span>
(cond (<span class="hilit9">(good-enough? (improve (improve (improve 1.0 9) 9) 9) 9)</span>
         (improve (improve (improve 1.0 9) 9) 9))
      (else <span class="hilit10">(sqrt-iter (improve (improve (improve (improve 1.0 9) 9) 9) 9) 9)</span>))
<span class="ex_comment">となる。

(8) ここで <tt>cond</tt> は特殊形式なので、まず先に</span>
(<span class="hilit9">good-enough?</span> (improve (improve (improve 1.0 9) 9) 9) 9)
<span class="ex_comment">を評価する。展開と評価の途中の詳細は略すが、</span>
(&lt; (abs (- (* 3.023529411764706 3.023529411764706) 9)) 0.001)
<span class="ex_comment">に帰着する。これは偽である。

(9) よって、今度は、(7) の最後に出てきた <tt>else</tt> 節の</span>
(<span class="hilit10">sqrt-iter</span> (improve (improve (improve (improve 1.0 9) 9) 9) 9) 9)
<span class="ex_comment">の評価に進む訳だが、上記と同様にして <tt>sqrt-iter</tt> から <tt>new-if</tt> へ、
そしてそこから <tt>cond</tt> へ、という展開により、</span>
(cond (<span class="hilit11">(good-enough? (improve (improve (improve (improve 1.0 9) 9) 9) 9) 9)</span>
         <span class="hilit12">(improve (improve (improve (improve 1.0 9) 9) 9) 9)</span>)
      (else <span class="hilit13">(sqrt-iter (improve (improve (improve (improve 1.0 9) 9) 9) 9) 9)</span>))
<span class="ex_comment">となる。

(10) ここで <tt>cond</tt> は特殊形式なので、まず先に</span>
(<span class="hilit11">good-enough?</span> (improve (improve (improve (improve 1.0 9) 9) 9) 9) 9)
<span class="ex_comment">を評価する。展開と評価の途中の詳細は略すが、</span>
(&lt; (abs (- (* 3.00009155413138 3.00009155413138) 9)) 0.001)
<span class="ex_comment">に帰着する。これは真である。

(11) よって、今度は、<span class="hilit12">(9) の帰結式</span>、すなわち、</span>
<span class="hilit12">(improve (improve (improve (improve 1.0 9) 9) 9) 9)</span>
<span class="ex_comment">を評価する。展開と評価の途中経過は略すが、(10)に書いた数値と同じ値、つまり、
<tt>3.00009155413138</tt> が得られる。
これは、<span class="hilit12">(9) の帰結式</span>の値であり、したがって、(9)の <tt>cond</tt> 式の値である。
よって、これは、<span class="hilit10">(7) の <tt>else</tt> 節の式</span>の値であり、したがって、(7)の <tt>cond</tt> 式の値である。
よって、これは、<span class="hilit8">(5) の <tt>else</tt> 節の式</span>の値であり、したがって、(5)の <tt>cond</tt> 式の値である。
よって、これは、<span class="hilit5">(3) の <tt>else</tt> 節の式</span>の値であり、したがって、(3)の <tt>cond</tt> 式の値である。
よって、これは、<span class="hilit3">(1) の <tt>else</tt> 節の式</span>の値であり、したがって、(1)の <tt>cond</tt> 式の値である。
ゆえに、これは、<span class="hilit1">(1) の <tt>new-if</tt> 手続き</span>の値であり、<span class="hilit1">(1) の <tt>sqrt-iter</tt> 手続き</span>の値であり、
つまりは <span class="hilit1">(1) の <tt>sqrt</tt> 手続き</span>の値である。
……ふう、長かった!</span>
</p>

<p class="exercise"><span class="ex_comment">(B) ちなみに、正規順の場合、<tt>new-if</tt> ではなく元のとおり <tt>if</tt> を使ったとしても、結果は
ほとんど似たようなもの。つまり、<tt>new-if</tt> を <tt>cond</tt> に展開する代わりに、すぐさま 
<tt>if</tt> を特殊形式の評価規則にしたがって評価することになるだけであって、それ以外の点は、
評価の対象となる式も評価の順序も変わらない。</span></p>

<p class="exercise"><span class="ex_comment">(C) 適用順の場合
(1)</span> (sqrt 9)
<span class="ex_comment">のオベランドを評価すると9である。オペランドの評価はこれで終わり。

(2) そこで、次に <tt>sqrt</tt> の本体を展開して (本体の中の仮引数を、実引数
すなわち(1)での評価結果で置き換えて)、</span>
(sqrt-iter 1.0 9)
<span class="ex_comment">となる。オペランドを評価すると1.0と9であり、オペランドの評価は終わり。

(3) そこで、次に <tt>sqrt-iter</tt> の本体を展開して、</span>
(new-if <span class="hilit1">(good-enough? 1.0 9)</span> 1.0 <span class="hilit2">(sqrt-iter (improve 1.0 9) 9)</span>)
<span class="ex_comment">となる。
<span class="hilit1">第1引数</span>を評価すると、結果だけ見れば上記(A)の(2)と同じである。
つまり、評価結果は偽である。また、第2引数を評価すると1.0である。ここまでは問題なし。

(4) そこで、次は<span class="hilit2">第3引数</span>を評価するわけだが、</span>
<span class="hilit2">(sqrt-iter <span class="hilit3">(improve 1.0 9)</span> 9)</span>
<span class="ex_comment">はコンビネーションなので、まずこれの<span class="hilit3">第1引数</span>から評価する。

(5) この</span> <span class="hilit3">(improve 1.0 9)</span> <span class="ex_comment">自体がまたしてもコンビネーションなので、
その引数である1.0と9を評価すると、その結果は1.0と9自体である。
オペランドの評価が終わったので、<tt>improve</tt> の本体の展開に進んで、
そこから先は上記(A)の(4)に部分式として示したのと同じであり、
すなわち、</span><span class="hilit3">(improve 1.0 9)</span> <span class="ex_comment">の評価結果は5.0である。

(6) そして、9の評価結果は9である。したがって、次は、</span>
<span class="hilit2">(sqrt-iter <span class="hilit3">5.0</span> 9)</span>
<span class="ex_comment">の本体を展開することになり、すると、</span>
(new-if <span class="hilit4">(good-enough? 5.0 9)</span> 5.0 <span class="hilit5">(sqrt-iter (improve 5.0 9) 9)</span>)
<span class="ex_comment">となる。つまり、(3) の <tt>new-if</tt> の<span class="hilit2">第3引数</span>を評価している最中に、別の <tt>new-if</tt> が
出現してしまったということである。この辺でもう、お察しなのだが、一応もう少し
進めてみる。

(7) <span class="hilit4">第1引数</span>を評価すると、上記(A)の(4)と同じ結果となる。つまり、評価結果は偽である。
そして、第2引数を評価すると5.0である。そこで、次は<span class="hilit5">第3引数</span>を評価するわけだが、</span>
<span class="hilit5">(sqrt-iter <span class="hilit6">(improve 5.0 9)</span> 9)</span>
<span class="ex_comment">はコンビネーションなので、まずこれの<span class="hilit6">第1引数</span>から評価する。これ自体がまた
コンビネーションなので、その引数である5.0と9を評価すると、その結果は
5.0と9自体である。
こうしてオペランドの評価が終わると、次は</span> <span class="hilit6">improve</span> <span class="ex_comment">本体の展開に進み、あとは、</span>
(average 5.0 (/ 9 5.0))
(average 5.0 1.8)
(/ (+ 5.0 1.8) 2)
(/ 6.8 2)
<span class="hilit6">3.4</span>
<span class="ex_comment">というふうに評価が進む。
そして、9の評価結果は9である。

(8) したがって、次は、</span>
<span class="hilit5">(sqrt-iter <span class="hilit6">3.4</span> 9)</span>
<span class="ex_comment">の本体を展開することになり、すると、</span>
(new-if <span class="hilit7">(good-enough? 3.4 9)</span> 3.4 <span class="hilit8">(sqrt-iter (improve 3.4 9) 9)</span>)
<span class="ex_comment">となる。これの<span class="hilit7">第1引数</span>を評価すると、上記(A)の(6)と同様に偽となり、第2引数を評価すると
3.4となる。
確認のために書いておくと、全体としては、</span>
(new-if <span class="hilit1">false</span> 1.0 (new-if <span class="hilit4">false</span> 5.0 (new-if <span class="hilit7">false</span> 3.4 <span class="hilit8">...</span>)))
                                                      <span class="ex_comment">↑</span>
                                                      <span class="ex_comment">イマココ
という状況である。もう無限ループに陥るパタンが見え見えな感じである。

(9) 一応続けると、今は、(8)で新たに出てきた <tt>new-if</tt> 手続きの第3引数の</span>
<span class="hilit8">(sqrt-iter <span class="hilit9">(improve 3.4 9)</span> 9)</span>
<span class="ex_comment">を評価しようとしているところであるが、これ自体がまたコンビネーションである。
評価の途中の詳細はもう省略するが、この<span class="hilit9">第1引数</span>の評価結果は、
3.023529411764706 である。また、もちろん第2引数の評価結果は9自体である。

(10) したがって、次は、</span>
<span class="hilit8">(sqrt-iter <span class="hilit9">3.023529411764706</span> 9)</span>
<span class="ex_comment">の本体を展開することになり、すると、</span>
(new-if <span class="hilit10">(good-enough? 3.023529411764706 9)</span> 3.023529411764706
        <span class="hilit11">(sqrt-iter (improve 3.023529411764706 9) 9)</span>)
<span class="ex_comment">となる。これの<span class="hilit10">第1引数</span>を評価すると、上記(A)の(8)と同様に偽となり、第2引数を評価すると
3.023529411764706 自体となる。そこで、次は<span class="hilit11">第3引数</span>を評価するわけだが、</span>
<span class="hilit11">(sqrt-iter <span class="hilit12">(improve 3.023529411764706 9)</span> 9)</span>
<span class="ex_comment">はコンビネーションなので、まずこれの<span class="hilit12">第1引数</span>を評価する。これ自体がまた
コンビネーションだが、途中経過を省略して結果のみを述べると、3.00009155413138 である。
そして、第2引数の評価結果は9自体である。

(12) したがって、次は、</span>
<span class="hilit11">(sqrt-iter <span class="hilit12">3.00009155413138</span> 9)</span>
<span class="ex_comment">の本体を展開することになり、すると、</span>
(new-if <span class="hilit1">(good-enough? 3.00009155413138 9)</span> 3.00009155413138
        <span class="hilit2">(sqrt-iter (improve 3.00009155413138 9) 9)</span>)
<span class="ex_comment">となる。これの<span class="hilit1">第1引数</span>を評価すると、上記(A)の(10)と同様にめでたく真となる。
そして、第2引数を評価すると 3.00009155413138 自体となる。

(13) だがここで、<span style="text-decoration: underline"><tt>new-if</tt> は特殊形式ではなく、今は適用順の評価をしているところ</span>
なので、たとえ </span><span class="hilit1">(good-enough? 3.00009155413138 9)</span> <span class="ex_comment">が<span style="text-decoration: underline">真であっても</span>、第3引数の</span>
<span class="hilit2">(sqrt-iter (improve 3.00009155413138 9) 9)</span>
<span class="ex_comment">の<span style="text-decoration: underline">評価を省略できるわけではない</span>。
よって、まず第1引数の</span> (improve 3.00009155413138 9) <span class="ex_comment">というコンビネーションを
評価して、3.000000001396984 という結果を得る。第2引数の9の評価結果は9自体である。

(14) よって、次は、</span>
<span class="hilit2">(sqrt-iter 3.000000001396984 9)</span>
<span class="ex_comment">の本体を展開することになり、すると、</span>
(new-if <span class="hilit3">(good-enough? 3.000000001396984 9)</span> 3.000000001396984
        <span class="hilit4">(sqrt-iter (improve 3.000000001396984 9) 9)</span>)
<span class="ex_comment">となる。これの<span class="hilit3">第1引数</span>を評価すると真となり、
第2引数を評価した結果は 3.000000001396984 自体である。
そして、<span class="hilit4">第3引数</span>の評価を省略できないのは(13)と同様である。
つまり、今の状況を全体として表すと、</span>
(new-if false 1.0
    (new-if false 5.0
        (new-if false 3.4
            (new-if false 3.023529411764706
                (new-if <span class="hilit1">true</span> 3.00009155413138
                    (new-if <span class="hilit3">true</span> 3.000000001396984 <span class="hilit4">...</span>))))))
<span class="ex_comment">となっていて、以下同様に無限に続く。

(15) このように、外側の <tt>new-if</tt> の本体を展開する前に、そのオペランドに出てくる 
<tt>sqrt-iter</tt> の展開の過程で内側に <tt>new-if</tt> が出現する。
要するに、<tt>sqrt-iter</tt> と <tt>new-if</tt> の展開が無限に続いてしまう。
別の言い方をするなら、オペランドの評価が終わらないので、永遠にオペレータの
適用に進めない。</span></p>


<p class="exercise"><span class="ex_comment">(D) <tt>new-if</tt> でなく元の <tt>if</tt> を使った定義だと、なぜ適用順でも問題がないのかを示す。

(1) たとえば、</span>
(sqrt 9)
<span class="ex_comment">のオベランドを評価すると9である。

(2) オベランドの評価が終わったので、次に <tt>sqrt</tt> の本体を展開して、</span>
(sqrt-iter 1.0 9)
<span class="ex_comment">となる。オペランドを評価すると1.0と9である。

(3) オベランドの評価が終わったので、次に <tt>sqrt-iter</tt> の本体を展開して、</span>
(if <span class="hilit1">(good-enough? 1.0 9)</span> 1.0 <span class="hilit2">(sqrt-iter (improve 1.0 9) 9)</span>)
<span class="ex_comment">となる。ここで、<tt>if</tt> は特殊形式なので、</span>
<span class="hilit1">(good-enough? 1.0 9)</span>
<span class="ex_comment">が成立すれば、</span>
<span class="hilit2">(sqrt-iter (improve 1.0 9) 9)</span>
<span class="ex_comment">は評価しないで無視できる。とは言え、この場合、</span>
<span class="hilit1">(good-enough? 1.0 9)</span>
<span class="ex_comment">を評価した結果は、上記の(C)の(3)のとおり、偽である。

(4) ということで、</span>
<span class="hilit2">(sqrt-iter <span class="hilit3">(improve 1.0 9)</span> 9)</span>
<span class="ex_comment">の評価へと進む。まず、(C)の(4)〜(5)と同様に、</span>
<span class="hilit3">(improve 1.0 9)</span>
<span class="ex_comment">の評価結果として5.0が得られる。そして、9の評価結果は9である。
したがって、次は、</span>
<span class="hilit2">(sqrt-iter <span class="hilit3">5.0</span> 9)</span>
<span class="ex_comment">の本体を展開することになるから、</span>
(if <span class="hilit4">(good-enough? 5.0 9)</span> 5.0 <span class="hilit5">(sqrt-iter (improve 5.0 9) 9)</span>)
<span class="ex_comment">となる。

(5) ここで <tt>if</tt> は特殊形式なので、まず</span>
<span class="hilit4">(good-enough? 5.0 9)</span>
<span class="ex_comment">を評価すると、(C)の(7)と同様に偽となる。よって、次は、</span>
<span class="hilit5">(sqrt-iter <span class="hilit6">(improve 5.0 9)</span> 9)</span>
<span class="ex_comment">の評価へと進む。

(6) まず、(C)の(7)と同様に</span>
<span class="hilit6">(improve 5.0 9)</span>
<span class="ex_comment">の評価結果として3.4が得られる。そして、9の評価結果は9である。
したがって、次は、</span>
<span class="hilit5">(sqrt-iter <span class="hilit6">3.4</span> 9)</span>
<span class="ex_comment">の本体を展開することになるから、</span>
(if <span class="hilit7">(good-enough? 3.4 9)</span> 3.4 <span class="hilit8">(sqrt-iter (improve 3.4 9) 9)</span>)
<span class="ex_comment">となる。

(7) ここで <tt>if</tt> は特殊形式なので、まず</span>
<span class="hilit7">(good-enough? 3.4 9)</span>
<span class="ex_comment">を評価すると、(C)の(8)と同様に偽となる。よって、次は、</span>
<span class="hilit8">(sqrt-iter <span class="hilit9">(improve 3.4 9)</span> 9)</span>
<span class="ex_comment">の評価へと進む。

(8) まず、(C)の(9)と同様に</span>
<span class="hilit9">(improve 3.4 9)</span>
<span class="ex_comment">の評価結果として 3.023529411764706 が
得られる。そして、9の評価結果は9である。したがって、次は、</span>
<span class="hilit8">(sqrt-iter <span class="hilit9">3.023529411764706</span> 9)</span>
<span class="ex_comment">の本体を展開することになるから、</span>
(if <span class="hilit10">(good-enough? 3.023529411764706 9)</span> 3.023529411764706
    <span class="hilit11">(sqrt-iter (improve 3.023529411764706 9) 9)</span>)
<span class="ex_comment">となる。

(9) ここで <tt>if</tt> は特殊形式なので、まず</span>
<span class="hilit10">(good-enough? 3.023529411764706 9)</span>
<span class="ex_comment">を評価すると、(C)の(10)と同様に偽となる。よって、次は、</span>
<span class="hilit11">(sqrt-iter <span class="hilit12">(improve 3.023529411764706 9)</span> 9)</span>
<span class="ex_comment">の評価へと進む。

(10) まず、(C)の(10)と同様に</span>
<span class="hilit12">(improve 3.023529411764706 9)</span>
<span class="ex_comment">の評価結果として 3.00009155413138 が
得られる。そして、9の評価結果は9である。したがって、次は、</span>
<span class="hilit11">(sqrt-iter <span class="hilit12">3.00009155413138</span> 9)</span>
<span class="ex_comment">の本体を展開することになるから、</span>
(if <span class="hilit1">(good-enough? 3.00009155413138 9)</span> <span class="hilit2">3.00009155413138</span> 
    <span class="hilit3">(sqrt-iter (improve 3.00009155413138 9) 9)</span>)
<span class="ex_comment">となる。

(11) ここで <tt>if</tt> は特殊形式なので、まず</span>
<span class="hilit1">(good-enough? 3.00009155413138 9)</span> 
<span class="ex_comment">を評価すると、(C)の(12)と同様に真となる。
だが、真という結果は同じでも、ここから先が(C)の場合とは違う。
すなわち、この <tt><span class="hilit1">good-enough?</span></tt> が真なので、帰結式である 
<tt><span class="hilit2">3.00009155413138</span></tt> を次に評価する。評価結果はこの数値自体である。
そしてこの 3.00009155413138 は、(10)の <tt>if</tt> 式の値でもある。
したがって、これは、(10)の</span>
<span class="hilit11">(sqrt-iter <span class="hilit12">3.00009155413138</span> 9)</span> <span class="ex_comment">の値であり、
つまり、(8)の <tt>if</tt> 式の値でもある。したがって、これは、(8)の</span>
<span class="hilit8">(sqrt-iter <span class="hilit9">3.023529411764706</span> 9)</span> <span class="ex_comment">の値であり、
つまり、(6)の <tt>if</tt> 式の値でもある。したがって、これは、(6)の</span>
<span class="hilit5">(sqrt-iter <span class="hilit6">3.4</span> 9)</span> <span class="ex_comment">の値であり、
つまり、(4)の <tt>if</tt> 式の値でもある。したがって、これは、(4)の</span>
<span class="hilit2">(sqrt-iter <span class="hilit3">5.0</span> 9)</span> <span class="ex_comment">の値であり、
つまり、(3)の <tt>if</tt> 式の値でもある。したがって、これは、(2)の</span>
(sqrt-iter 1.0 9) <span class="ex_comment">の値であり、
つまり、(1)の</span> (sqrt 9) <span class="ex_comment">の値である。
はあ、長かった。けれども、適用順でも無事に停止して答えが得られましたね!

つまり、<tt>new-if</tt> を使うと、<tt>new-if</tt> の入れ子が無限に深まってゆくのに対し、
<tt>if</tt>を使うと、<tt>if</tt> が特殊形式であるおかげで、<tt>if</tt> の入れ子は深まらないで済む。
そして、ある時点で <tt>good-enough?</tt> が成立すれば、その後ろの <tt>sqrt-iter</tt> 
(のオペランドと、当該 <tt>sqrt-iter</tt> の本体) は展開せずに済む。
</span></p>


<a name="%_thm_1.7"></a>
<p class="orig" lang="en">
<b>Exercise 1.7.</b>&nbsp;&nbsp;The <tt>good-enough?</tt> test used in computing square roots will not be
very effective for finding the square roots of very small numbers.
Also, in real computers, arithmetic operations are almost always
performed with limited precision.  This makes our test inadequate for
very large numbers.  Explain these statements, with examples showing
how the test fails for small and large numbers.  An alternative
strategy for implementing <tt>good-enough?</tt> is to watch how <tt>guess</tt> changes from one iteration to the next and to stop when the
change is a very small fraction of the guess.  Design a square-root
procedure that uses this kind of end test.  Does this work better for
small and large numbers?
</p>

<p class="trans" lang="ja">
<b>練習問題 1.7.</b> 二乗根を計算する際に使われる <tt>good-enough?</tt> テストは、とても小さな数の二乗根を見つけるためには、とても有効だというわけではないだろう。
また、実際のコンピュータでは、算術演算は、ほとんどいつも、限られた精度で実行される。
そのせいで、私たちのテストは、とても大きな数に関して不適切なものとなってしまう。
以上の陳述について説明せよ——なお、小さな数および大きな数に対してテストがどのようにして失敗してしまうのかを示す例を使うこと。
<tt>good-enough?</tt> を実装するための別の戦略は、ある反復の回から次の回で<tt>guess</tt> がどれほど変化するかを見張り、その変化が <tt>guess</tt> に対してとても小さな割合<!--になった-->ならば停止する<!--こと-->、というものである。
この種の終了テストを使う二乗根の手続きを設計せよ。
これは、小さな数や大きな数に対して、よりうまく動くだろうか?
</p>

<p class="exercise"><span class="ex_comment"><tt>x</tt> が小さいとき、<tt>good-enough?</tt> の中の定数 <tt>0.001</tt>が、
「<tt>x</tt> や <tt>x</tt> の二乗根に対して無視できるほど小さい許容誤差」
とは言えなくなる。そのせいで、
「現実にはまだ十分に良い近似が得られていない」
という段階でも、<tt>good-enough?</tt> が真になり、反復が停止ししてしまうはず。

逆に、<tt>x</tt> がとても大きい場合、
「使える桁数が限られているため、数が巨大になると、刻み幅も大きくなる」
せいで、
「<tt>good-enough?</tt> を満たせるほど真の解に近い数値は表現不能」
という場合があり得る。この場合、
「<tt>good-enough?</tt> がどうしても満たせないまま、無限ループに陥った」
ということになる可能性がある。

以上のことを、もっとちゃんと考えると、以下のとおり。
</span></p>

<div class="exercise"><span class="ex_comment">*** xが小さい場合の問題について ***
xの真の二乗根をrとし、誤差を&epsilon;とする。つまり、x=r<sup>2</sup> であり guess=r+&epsilon; である。
<tt><a href="#define-good-enough">good-enough?</a></tt> が成立するということは、
| (r+&epsilon;)<sup>2</sup> &minus; x | &lt; 0.001    である。これを展開すると、
| r<sup>2</sup> + 2&epsilon;r + &epsilon;<sup>2</sup> &minus; x | &lt; 0.001    となり、x=r<sup>2</sup> より、これはつまり、
&minus;0.001 &lt; 2&epsilon;r + &epsilon;<sup>2</sup> &lt; 0.001    ということである。よって、
&epsilon;<sup>2</sup> + 2r&epsilon; + 0.001 &gt; 0  &hellip;&hellip;(1-1)    かつ 
&epsilon;<sup>2</sup> + 2r&epsilon; &minus;0.001 &lt; 0 &hellip;&hellip;(1-2)    である。

(1-1) と (1-2) を<u>&epsilon;について解く</u>ことで、<tt>good-enough?</tt> が成立する条件を調べる。

まず、(1-1) の不等式について。ここで、不等号を等号に変えた式
&epsilon;<sup>2</sup> + 2r&epsilon; + 0.001 = 0     の判別式を D<sub>1</sub> とすると、
D<sub>1</sub> = 4r<sup>2</sup> &minus; 0.004 = 4 (r<sup>2</sup> &minus; 0.001) = 4 (x &minus; 0.001)    である。
* D<sub>1</sub> &gt; 0 のとき (つまり r &gt; &radic;<span class="radic">0.001</span> &cong; 0.032 のとき)、(1-1) の解は、
   &epsilon; &lt; &minus;r &minus; &radic;<span class="radic">(r<sup>2</sup> &minus; 0.001)</span>    または    &epsilon; &gt; &minus;r + &radic;<span class="radic">(r<sup>2</sup> &minus; 0.001)</span>    である。
* D<sub>1</sub> &lt; 0 のとき (つまり 0 &le; r &lt; &radic;<span class="radic">0.001</span> &cong; 0.032 のとき)、(1-1) の不等式は常に成立。
* D<sub>1</sub> = 0 のとき (つまり r = &radic;<span class="radic">0.001</span> &cong; 0.032 のとき)、(1-1) の不等式は、
   &epsilon; = &minus;r = &minus;&radic;<span class="radic">0.001</span> の一点を除いて常に成立。

次に、(1-2) の不等式 (&epsilon;<sup>2</sup> + 2r&epsilon; &minus;0.001 &lt; 0) について。ここで、不等号を等号に変えた式
&epsilon;<sup>2</sup> + 2r&epsilon; &minus;0.001 = 0    の判別式を D<sub>2</sub> とすると、
D<sub>2</sub> = 4r<sup>2</sup> + 0.004 = 4 (r<sup>2</sup> + 0.001) = 4 (x + 0.001) &gt; 0    である。
よって、(1-2) の不等式の解は、r の値によらず、
&minus;r &minus; &radic;<span class="radic">(r<sup>2</sup> + 0.001)</span> &lt; &epsilon; &lt; &minus;r + &radic;<span class="radic">(r<sup>2</sup> + 0.001)</span>    である。

したがって、(1-1) と (1-2) を満たす &epsilon; の範囲は、以下のように表せる。
</span>
    <div class="inline-aa">   *** r &gt; &radic;<span class="radic">0.001</span> のとき ***

│　　│
│┌─┼   &minus;r &minus; &radic;<span class="radic">(r<sup>2</sup> + 0.001)</span>
││　│
││　┼   &minus;2r
││　│
└┼─┼   &minus;r &minus; &radic;<span class="radic">(r<sup>2</sup> &minus; 0.001)</span>
　│　│
　│　│
　│　│
　│　│
　│　┼   &minus;r 
　│　│
　│　│
　│　│
　│　│
┌┼─┼   &minus;r + &radic;<span class="radic">(r<sup>2</sup> &minus; 0.001)</span>
││　│
││　┼   0
││　│
│└─┼   &minus;r + &radic;<span class="radic">(r<sup>2</sup> + 0.001)</span>
│　　│
　　　↓
　　　&epsilon;
</div>       <div class="inline-aa">   *** r &le; &radic;<span class="radic">0.001</span> のとき ***

　　│
┌─┼   &minus;r &minus; &radic;<span class="radic">(r<sup>2</sup> + 0.001)</span>
│　│
│　┼   &minus;2r
│　┼   &minus;r 
│　┼   0
│　│
└─┼   &minus;r + &radic;<span class="radic">(r<sup>2</sup> + 0.001)</span>
　　│
　　↓
　　&epsilon;

(ただし r=&radic;<span class="radic">0.001</span> の場合は &epsilon;= &minus;r の点を除く)
</div>


<span class="ex_comment">ところで、<tt><a href="#define-improve">improve</a></tt> と <tt><a href="#%_idx_516">average</a></tt> の定義より、最初に与える見積もりが正なら、
以後の反復において計算される見積もりも正である。
そして、<tt><a href="#define-sqrt">sqrt</a></tt> の定義では、最初の見積もりとして 1.0 が与えられている。
よって、実際には、見積もり (r+&epsilon;) は常に正である。つまり、常に &minus;r &lt; &epsilon; である。
ということは、<tt><a href="#define-good-enough">good-enough?</a></tt> が成立するのは、上の図のうち、
さらに &minus;r &lt; &epsilon; の場合のみに限られる。

以上をまとめると、<tt><a href="#define-good-enough">good-enough?</a></tt> が成立する &epsilon; の範囲は、
  (a) r &gt; &radic;<span class="radic">0.001</span> のときは、&minus;r + &radic;<span class="radic">(r<sup>2</sup> &minus; 0.001)</span> &lt; &epsilon; &lt; &minus;r + &radic;<span class="radic">(r<sup>2</sup> + 0.001)</span>
  (b) r &le; &radic;<span class="radic">0.001</span> のときは、&minus;r &lt; &epsilon; &lt; &minus;r + &radic;<span class="radic">(r<sup>2</sup> + 0.001)</span>
である。

これが具体的にはどんな値になるのか、いくつか具体例を見てみる。</span>

$ bc
scale=4
define lower_lim(r) { return(-r+sqrt(r*r-0.001)) }
define upper_lim(r) { return(-r+sqrt(r*r+0.001)) }
lower_lim(0.5)
-.0011
upper_lim(0.5)
.0009
lower_lim(0.1)
-.0052
upper_lim(0.1)
.0048
lower_lim(0.05)
-.0113
upper_lim(0.05)
.0091
upper_lim(0.03)
.0135
upper_lim(0.01)
.0231

<span class="ex_comment">つまり、(a)に該当する例は、たとえば、以下のようなものである。
* r=0.5 のとき (x=0.25) なら、誤差範囲は、約&minus;0.0011 &lt; &epsilon; &lt; 約0.0009 ということ。
* r=0.1 のとき (x= 0.01) なら、誤差範囲は、約&minus;0.0052 &lt; &epsilon; &lt; 約0.0048 ということ。
* r=0.05 のとき (x=0.0025) なら、誤差範囲は、約&minus;0.0113 &lt; &epsilon; &lt; 約0.0091 ということ。

そして、(b)に該当する例は、たとえば、以下のようなものである。
* r=0.03 のとき (x=0.0009) なら、誤差範囲は、&minus;0.03 &lt; &epsilon; &lt; 約0.0135 ということ。
* r=0.01のとき (x=0.0001) なら、誤差範囲は、約&minus;0.01 &lt; &epsilon; &lt; 約0.0231 ということ。

以上のとおり、rが小さくなるほど、
「誤差が、まだ r に対して相対的に無視できないほどに大きなものであっても、
それが許容されて <tt>good-enough?</tt> が成立してしまう」
という傾向になる。実際、Gaucheで試してみると、以下のとおり。</span>

<span class="ex_comment">; 有効数字4桁としても問題ない。</span>
gosh&gt; (sqrt 3)
1.7321428571428572
gosh&gt; (sqrt 2)
1.4142156862745097

<span class="ex_comment">; このあたりから精度が落ちているのが目に見えてくる。</span>
gosh&gt; (sqrt 0.04)
0.2006099040777959
gosh&gt; (sqrt 0.03)
0.174492093914502
gosh&gt; (sqrt 0.02)
0.1444238094866232

<span class="ex_comment">; もはや答えが当てにならないレベルになってゆく。</span>
gosh&gt; (sqrt 0.0025)  <span class="ex_comment">; 返り値として0.05を期待。</span>
0.05423762280896765
gosh&gt; (sqrt 0.0016)  <span class="ex_comment">; 返り値として0.04を期待。</span>
0.04669259597054016
gosh&gt; (sqrt 0.0009)  <span class="ex_comment">; 返り値として0.03を期待。</span>
0.04030062264654547
gosh&gt; (sqrt 0.0004)  <span class="ex_comment">; 返り値として0.02を期待。</span>
0.0354008825558513
gosh&gt; (sqrt 0.0001)  <span class="ex_comment">; 返り値として0.01を期待。</span>
0.03230844833048122
gosh&gt; (sqrt 0.000001)  <span class="ex_comment">; 返り値として0.001を期待。</span>
0.031260655525445276
</div>

<p class="exercise"><span class="ex_comment">*** x がとても大きい場合の不具合について ***

とても大きな x の真の二乗根に十分に近づいた (が、まだ誤差を含む) 見積もりを、
g とする。
また、Lispインタプリタの実装に<a href="../comp/ref/floating-point-numbers.html#double">倍精度浮動小数点数</a>が使われている、
と仮定すると、仮数部が52桁である。この「52」に着目すると、kを整数として、
「2<sup>k</sup> &le; g &lt; 2<sup>k+1</sup> の範囲では、2<sup>k&minus;52</sup> 刻みで数が表現される」
と言える。
(なお、倍精度浮動小数点数の仕様から、正確には、k は 1023以下である。
 だが、それより大きい数は、「無限大」を除いてそもそも表現できない仕様なので、
 k が 1024 以上の場合については、ここでの考察から除外してよい。)
 
ここで、hを、2<sup>k&minus;52</sup> または &minus;2<sup>k&minus;52</sup> とする。
つまり、g+h は、表現可能な数の中で g に一番近い数 (のうちの一方) である。

<tt>(improve g x)</tt> は、<a href="#define-improve">定義</a>より <tt>(average g (/ x g))</tt> であるが、
g は x の真の二乗根に十分に近いから、x/g は、g 自体に極めて近い値になり得る。
つまり、x/g = g+h となり得る (なお、厳密に言うと、この等号は、「真に等しい」
ことを保証するものではなく、「<tt>(/ x g)</tt> の計算結果は、倍精度浮動小数点数で
表現可能な数としては、g+h になる」という意味であり、以下でも同様である)。

仮に x/g = g+2h であれば (せめてそれくらい x/g と g の間に差があれば)、
<tt>(improve g x) = (average g (/x g))</tt> = (g + (g+2h))/2 = g+h
となって、improve の第1引数と返り値が違う値になり得る。
しかし、x/g = g+h だと、精度に限界があるせい (いわゆる「丸め」のせい) で、
<tt>(improve g x)</tt> = (g + (g+h))/2 = g
とされる (improve の第1引数と返り値が同じになって、無限ループに陥る) 
可能性がある。

ここで、「では、x/g = g+hになるのはどのようなときか?」と考える。
なお、上記の注意書きのとおり、ここでの等号は「真に等しい」ことを
保証するものではないが、今はひとまず「どのようなときか?」という
見当をつけたいだけなので、とりあえずその誤差の問題は措いておくと、
x/g = g+h より x = g (g+h) = g<sup>2</sup>+gh ということになるから、
x&minus;g<sup>2</sup>=gh である。

この場合において、もし <tt><a href="#define-good-enough">good-enough?</a></tt> のテストに通らないと、
<tt><a href="#define-sqrt-iter">sqrt-iter</a></tt> が再度呼ばれる訳だが、その際の第1引数である 
<tt>(improve g x)</tt> は、上記のとおり g から変化していないので、同じことが
繰り返されて、無限ループに陥ってしまう。

<tt>good-enough?</tt>のテストに通らないのは、定義より、
|g<sup>2</sup> &minus; x| &ge; 0.001
の場合だが、この式に上記の x&minus;g<sup>2</sup>=gh を代入すると、
|gh| &ge; 0.001 のときに <tt>good-enough?</tt> のテストに通らない、
と分かる。  &hellip;&hellip;  (※)
ここで、2<sup>k</sup> &le; g &lt; 2<sup>k+1</sup> より、
|h| &times; 2<sup>k</sup> &le; |gh| &lt; |h| &times; 2<sup>k+1</sup> であり、ここに |h|=2<sup>k&minus;52</sup> を代入すると、
2<sup>k&minus;52+k</sup> &le; |gh| &lt; 2<sup>k&minus;52+k+1</sup> となり、これを整理すると、
2<sup>2k&minus;52</sup> &le; |gh| &lt; 2<sup>2k&minus;51</sup>
である。
また、その一方で、上記の定数 0.001 については、
1/1024 = 2<sup>&minus;10</sup> &lt; 0.001 = 1/1000 &lt; 2<sup>&minus;9</sup> = 1/512  が成立する。
以上をまとめると、「x/g = g+h が成立するほどまでに見積もり g が真の
二乗根に近づいているとき」に関して、次のことが言える。

* k&le;20 だったら、2k&minus;51 &le; &minus;11 だから、|gh| &lt; 2<sup>2k&minus;51</sup> &le; 2<sup>&minus;11</sup> &lt; 0.001
  なので、good-enough? のテストに通る (※を参照)。
* k=21 だったら、2k&minus;52 = &minus;10 だから、2<sup>&minus;10</sup> = 2<sup>2k&minus;52</sup> &le; |gh| &lt; 2<sup>2k&minus;51</sup> = 2<sup>&minus;9</sup>
  なので、|gh| と 0.001 が互いに近い値であり、したがって、
  場合によっては good-enough? のテストに通らない (※を参照)。
* k&ge;22 だったら、2k&minus;52&ge;&minus;8 だから、0.001 &lt; 2<sup>&minus;8</sup> &le; 2<sup>2k&minus;52</sup> &le; |gh|
  なので、good-enough? のテストに通らない (※を参照)。

というわけで、無限ループに陥る (すなわち、表現可能な数のうちでは、これ
以上はもう見積もりを改善できないくらいまで見積もりが真の値に近づいている
にもかかわらず、good-enough? のテストに通らないせいで、同じ見積もりを
引数として sqrt-iter が永遠に呼ばれ続ける羽目に陥る) かどうかの境界は、
k=21 あたりに存在する。
k=21 のとき、2<sup>k</sup> &le; g &lt; 2<sup>k+1</sup> という k の定義より、2<sup>21</sup> &le; g &lt; 2<sup>22</sup> なので、
2<sup>42</sup> &le; g<sup>2</sup> &lt; 2<sup>44</sup> である。
そして、g<sup>2</sup> は x に近いから、2<sup>42</sup> &le; x  &lt; 2<sup>44</sup> の範囲を目安に、いくつか x を
試してみれば、無限ループに陥るかどうかの境界の、手前側と向こう側の例が
得られるはず。ちなみに、しつこいようだが、
* 2<sup>42</sup> 以上 2<sup>43</sup> 未満の区間で表現可能な数同士の間隔は 2<sup>&minus;10</sup> (= 2<sup>42&minus;52</sup> = 1/1024) であり、
  それは0.001より多少は小さいが、
* 2<sup>43</sup> 以上 2<sup>44</sup> 未満の区間で表現可能な数同士の間隔は 2<sup>&minus;9</sup> (= 2<sup>43&minus;52</sup> = 1/512) であり、
  それは0.001より大きい。

以下は、実際に試してみた結果である。
</span><!--

; 以下は、goshで入力するときのコピペ用
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x)
                 x)))

(define (improve guess x)
  (average guess (/ x guess)))

(define (average x y)
  (/ (+ x y) 2))

(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))

(define (square x) (* x x))

(define (sqrt x)
  (sqrt-iter 1.0 x))
-->
<span class="ex_comment">; まずはtraceするためのおまじない3連発。</span>
gosh&gt; (use slib)
#&lt;undef&gt;
gosh&gt; (require 'trace)
#t 
gosh&gt; (trace sqrt-iter improve average good-enough?)
#&lt;closure (debug:trace-procedure debug:trace-procedure)&gt;
<span class="ex_comment">; とりあえず 2<sup>42</sup>だとどうなるか、を試してみる。</span>
gosh&gt; (define p1 (expt 2.0 42))
p1
<span class="ex_comment">; トレースは長いので<span class="btn" onclick="toggle('ex1_7_tr1')">必要に応じて展開する</span>形で示しておくが、以下のとおり、
; ちゃんと停止して答えが出る。</span>
gosh&gt; (sqrt p1)<span id="ex1_7_tr1" style="display: none;">
CALL sqrt-iter 1.0 4.398046511104e12
  CALL good-enough? 1.0 4.398046511104e12
  RETN good-enough? #f
  CALL improve 1.0 4.398046511104e12
    CALL average 1.0 4.398046511104e12
    RETN average 2.1990232555525e12
  RETN improve 2.1990232555525e12
  CALL sqrt-iter 2.1990232555525e12 4.398046511104e12
    CALL good-enough? 2.1990232555525e12 4.398046511104e12
    RETN good-enough? #f
    CALL improve 2.1990232555525e12 4.398046511104e12
      CALL average 2.1990232555525e12 1.9999999999995453
      RETN average 1.09951162777725e12
    RETN improve 1.09951162777725e12
    CALL sqrt-iter 1.09951162777725e12 4.398046511104e12
      CALL good-enough? 1.09951162777725e12 4.398046511104e12
      RETN good-enough? #f
      CALL improve 1.09951162777725e12 4.398046511104e12
        CALL average 1.09951162777725e12 3.9999999999954525
        RETN average 5.49755813890625e11
      RETN improve 5.49755813890625e11
      CALL sqrt-iter 5.49755813890625e11 4.398046511104e12
        CALL good-enough? 5.49755813890625e11 4.398046511104e12
        RETN good-enough? #f
        CALL improve 5.49755813890625e11 4.398046511104e12
          CALL average 5.49755813890625e11 7.999999999961801
          RETN average 2.748779069493125e11
        RETN improve 2.748779069493125e11
        CALL sqrt-iter 2.748779069493125e11 4.398046511104e12
          CALL good-enough? 2.748779069493125e11 4.398046511104e12
          RETN good-enough? #f
          CALL improve 2.748779069493125e11 4.398046511104e12
            CALL average 2.748779069493125e11 15.999999999690772
            RETN average 1.3743895348265625e11
          RETN improve 1.3743895348265625e11
          CALL good-enough? 1.3743895348265625e11 4.398046511104e12
          RETN good-enough? #f
          CALL improve 1.3743895348265625e11 4.398046511104e12
            CALL average 1.3743895348265625e11 31.9999999975189
            RETN average 6.871947675732812e10
          RETN improve 6.871947675732812e10
          CALL good-enough? 6.871947675732812e10 4.398046511104e12
          RETN good-enough? #f
          CALL improve 6.871947675732812e10 4.398046511104e12
            CALL average 6.871947675732812e10 63.999999980136636
            RETN average 3.435973841066406e10
          RETN improve 3.435973841066406e10
          CALL good-enough? 3.435973841066406e10 4.398046511104e12
          RETN good-enough? #f
          CALL improve 3.435973841066406e10 4.398046511104e12
            CALL average 3.435973841066406e10 127.99999984106398
            RETN average 1.717986926933203e10
          RETN improve 1.717986926933203e10
          CALL good-enough? 1.717986926933203e10 4.398046511104e12
          RETN good-enough? #f
          CALL improve 1.717986926933203e10 4.398046511104e12
            CALL average 1.717986926933203e10 255.99999872845365
            RETN average 8.589934762666016e9
          RETN improve 8.589934762666016e9
          CALL good-enough? 8.589934762666016e9 4.398046511104e12
          RETN good-enough? #f
          CALL improve 8.589934762666016e9 4.398046511104e12
            CALL average 8.589934762666016e9 511.999989827513
            RETN average 4.294967637333003e9
          RETN improve 4.294967637333003e9
          CALL good-enough? 4.294967637333003e9 4.398046511104e12
          RETN good-enough? #f
          CALL improve 4.294967637333003e9 4.398046511104e12
            CALL average 4.294967637333003e9 1023.9999186198769
            RETN average 2.147484330666461e9
          RETN improve 2.147484330666461e9
          CALL good-enough? 2.147484330666461e9 4.398046511104e12
          RETN good-enough? #f
          CALL improve 2.147484330666461e9 4.398046511104e12
            CALL average 2.147484330666461e9 2047.9993489587364
            RETN average 1.073743189332905e9
          RETN improve 1.073743189332905e9
          CALL good-enough? 1.073743189332905e9 4.398046511104e12
          RETN good-enough? #f
          CALL improve 1.073743189332905e9 4.398046511104e12
            CALL average 1.073743189332905e9 4095.9947916749234
            RETN average 536873642.6638484
          RETN improve 536873642.6638484
          CALL good-enough? 536873642.6638484 4.398046511104e12
          RETN good-enough? #f
          CALL improve 536873642.6638484 4.398046511104e12
            CALL average 536873642.6638484 8191.958333588263
            RETN average 268440917.311091
          RETN improve 268440917.311091
          CALL good-enough? 268440917.311091 4.398046511104e12
          RETN good-enough? #f
          CALL improve 268440917.311091 4.398046511104e12
            CALL average 268440917.311091 16383.666674805721
            RETN average 134228650.4888829
          RETN improve 134228650.4888829
          CALL good-enough? 134228650.4888829 4.398046511104e12
          RETN good-enough? #f
          CALL improve 134228650.4888829 4.398046511104e12
            CALL average 134228650.4888829 32765.33359372674
            RETN average 67130707.91123831
          RETN improve 67130707.91123831
          CALL good-enough? 67130707.91123831 4.398046511104e12
          RETN good-enough? #f
          CALL improve 67130707.91123831 4.398046511104e12
            CALL average 67130707.91123831 65514.67499671228
            RETN average 33598111.293117516
          RETN improve 33598111.293117516
          CALL good-enough? 33598111.293117516 4.398046511104e12
          RETN good-enough? #f
          CALL improve 33598111.293117516 4.398046511104e12
            CALL average 33598111.293117516 130901.5995790492
            RETN average 16864506.446348283
          RETN improve 16864506.446348283
          CALL good-enough? 16864506.446348283 4.398046511104e12
          RETN good-enough? #f
          CALL improve 16864506.446348283 4.398046511104e12
            CALL average 16864506.446348283 260787.14637132597
            RETN average 8562646.796359805
          RETN improve 8562646.796359805
          CALL good-enough? 8562646.796359805 4.398046511104e12
          RETN good-enough? #f
          CALL improve 8562646.796359805 4.398046511104e12
            CALL average 8562646.796359805 513631.6626973005
            RETN average 4538139.229528553
          RETN improve 4538139.229528553
          CALL good-enough? 4538139.229528553 4.398046511104e12
          RETN good-enough? #f
          CALL improve 4538139.229528553 4.398046511104e12
            CALL average 4538139.229528553 969129.920582206
            RETN average 2753634.5750553794
          RETN improve 2753634.5750553794
          CALL good-enough? 2753634.5750553794 4.398046511104e12
          RETN good-enough? #f
          CALL improve 2753634.5750553794 4.398046511104e12
            CALL average 2753634.5750553794 1597178.7073510105
            RETN average 2175406.641203195
          RETN improve 2175406.641203195
          CALL good-enough? 2175406.641203195 4.398046511104e12
          RETN good-enough? #f
          CALL improve 2175406.641203195 4.398046511104e12
            CALL average 2175406.641203195 2021712.367611182
            RETN average 2098559.5044071884
          RETN improve 2098559.5044071884
          CALL good-enough? 2098559.5044071884 4.398046511104e12
          RETN good-enough? #f
          CALL improve 2098559.5044071884 4.398046511104e12
            CALL average 2098559.5044071884 2095745.4396063848
            RETN average 2097152.4720067866
          RETN improve 2097152.4720067866
          CALL good-enough? 2097152.4720067866 4.398046511104e12
          RETN good-enough? #f
          CALL improve 2097152.4720067866 4.398046511104e12
            CALL average 2097152.4720067866 2097151.5279933196
            RETN average 2097152.000000053
          RETN improve 2097152.000000053
          CALL good-enough? 2097152.000000053 4.398046511104e12
          RETN good-enough? #f
          CALL improve 2097152.000000053 4.398046511104e12
            CALL average 2097152.000000053 2097151.999999947
            RETN average 2097152.0
          RETN improve 2097152.0
          CALL good-enough? 2097152.0 4.398046511104e12
          RETN good-enough? #t
        RETN sqrt-iter 2097152.0
      RETN sqrt-iter 2097152.0
    RETN sqrt-iter 2097152.0
  RETN sqrt-iter 2097152.0
RETN sqrt-iter 2097152.0</span>
2097152.0
<span class="ex_comment">; では 2<sup>43</sup> だとどうかな、と試すと、以下のとおりで、止まらなくなるのであった
: (ループに陥るところを<span class="em-red">赤字</span>にしておく)</span>
gosh&gt; (define p2 (expt 2.0 43))
p2
gosh&gt; (sqrt p2)
CALL sqrt-iter 1.0 8.796093022208e12
  CALL good-enough? 1.0 8.796093022208e12
  RETN good-enough? #f
  CALL improve 1.0 8.796093022208e12
    CALL average 1.0 8.796093022208e12
    RETN average 4.3980465111045e12
  RETN improve 4.3980465111045e12
  CALL sqrt-iter 4.3980465111045e12 8.796093022208e12
    CALL good-enough? 4.3980465111045e12 8.796093022208e12
    RETN good-enough? #f
    CALL improve 4.3980465111045e12 8.796093022208e12
      CALL average 4.3980465111045e12 1.9999999999997726
      RETN average 2.19902325555325e12
    RETN improve 2.19902325555325e12
    CALL sqrt-iter 2.19902325555325e12 8.796093022208e12
      CALL good-enough? 2.19902325555325e12 8.796093022208e12
      RETN good-enough? #f
      CALL improve 2.19902325555325e12 8.796093022208e12
        CALL average 2.19902325555325e12 3.9999999999977263
        RETN average 1.099511627778625e12
      RETN improve 1.099511627778625e12
      CALL sqrt-iter 1.099511627778625e12 8.796093022208e12
        CALL good-enough? 1.099511627778625e12 8.796093022208e12
        RETN good-enough? #f
        CALL improve 1.099511627778625e12 8.796093022208e12
          CALL average 1.099511627778625e12 7.999999999980901
          RETN average 5.497558138933125e11
        RETN improve 5.497558138933125e11
        CALL sqrt-iter 5.497558138933125e11 8.796093022208e12
          CALL good-enough? 5.497558138933125e11 8.796093022208e12
          RETN good-enough? #f
          CALL improve 5.497558138933125e11 8.796093022208e12
            CALL average 5.497558138933125e11 15.999999999845386
            RETN average 2.7487790695465625e11
          RETN improve 2.7487790695465625e11
          CALL good-enough? 2.7487790695465625e11 8.796093022208e12
          RETN good-enough? #f
          CALL improve 2.7487790695465625e11 8.796093022208e12
            CALL average 2.7487790695465625e11 31.99999999875945
            RETN average 1.3743895349332812e11
          RETN improve 1.3743895349332812e11
          CALL good-enough? 1.3743895349332812e11 8.796093022208e12
          RETN good-enough? #f
          CALL improve 1.3743895349332812e11 8.796093022208e12
            CALL average 1.3743895349332812e11 63.99999999006832
            RETN average 6.871947677866406e10
          RETN improve 6.871947677866406e10
          CALL good-enough? 6.871947677866406e10 8.796093022208e12
          RETN good-enough? #f
          CALL improve 6.871947677866406e10 8.796093022208e12
            CALL average 6.871947677866406e10 127.99999992053199
            RETN average 3.435973845333203e10
          RETN improve 3.435973845333203e10
          CALL good-enough? 3.435973845333203e10 8.796093022208e12
          RETN good-enough? #f
          CALL improve 3.435973845333203e10 8.796093022208e12
            CALL average 3.435973845333203e10 255.99999936422682
            RETN average 1.7179869354666016e10
          RETN improve 1.7179869354666016e10
          CALL good-enough? 1.7179869354666016e10 8.796093022208e12
          RETN good-enough? #f
          CALL improve 1.7179869354666016e10 8.796093022208e12
            CALL average 1.7179869354666016e10 511.99999491375644
            RETN average 8.589934933333006e9
          RETN improve 8.589934933333006e9
          CALL good-enough? 8.589934933333006e9 8.796093022208e12
          RETN good-enough? #f
          CALL improve 8.589934933333006e9 8.796093022208e12
            CALL average 8.589934933333006e9 1023.9999593099365
            RETN average 4.294967978666483e9
          RETN improve 4.294967978666483e9
          CALL good-enough? 4.294967978666483e9 8.796093022208e12
          RETN good-enough? #f
          CALL improve 4.294967978666483e9 8.796093022208e12
            CALL average 4.294967978666483e9 2047.9996744793061
            RETN average 2.147485013333079e9
          RETN improve 2.147485013333079e9
          CALL good-enough? 2.147485013333079e9 8.796093022208e12
          RETN good-enough? #f
          CALL improve 2.147485013333079e9 8.796093022208e12
            CALL average 2.147485013333079e9 4095.9973958354744
            RETN average 1.0737445546652374e9
          RETN improve 1.0737445546652374e9
          CALL good-enough? 1.0737445546652374e9 8.796093022208e12
          RETN good-enough? #f
          CALL improve 1.0737445546652374e9 8.796093022208e12
            CALL average 1.0737445546652374e9 8191.979166730553
            RETN average 536876373.3222021
          RETN improve 536876373.3222021
          CALL good-enough? 536876373.3222021 8.796093022208e12
          RETN good-enough? #f
          CALL improve 536876373.3222021 8.796093022208e12
            CALL average 536876373.3222021 16383.833335368428
            RETN average 268446378.57776874
          RETN improve 268446378.57776874
          CALL good-enough? 268446378.57776874 8.796093022208e12
          RETN good-enough? #f
          CALL improve 268446378.57776874 8.796093022208e12
            CALL average 268446378.57776874 32766.666731768844
            RETN average 134239572.62225026
          RETN improve 134239572.62225026
          CALL good-enough? 134239572.62225026 8.796093022208e12
          RETN good-enough? #f
          CALL improve 134239572.62225026 8.796093022208e12
            CALL average 134239572.62225026 65525.33541625746
            RETN average 67152548.97883326
          RETN improve 67152548.97883326
          CALL good-enough? 67152548.97883326 8.796093022208e12
          RETN good-enough? #f
          CALL improve 67152548.97883326 8.796093022208e12
            CALL average 67152548.97883326 130986.73328067655
            RETN average 33641767.856056966
          RETN improve 33641767.856056966
          CALL good-enough? 33641767.856056966 8.796093022208e12
          RETN good-enough? #f
          CALL improve 33641767.856056966 8.796093022208e12
            CALL average 33641767.856056966 261463.45994193418
            RETN average 16951615.65799945
          RETN improve 16951615.65799945
          CALL good-enough? 16951615.65799945 8.796093022208e12
          RETN good-enough? #f
          CALL improve 16951615.65799945 8.796093022208e12
            CALL average 16951615.65799945 518894.08063927724
            RETN average 8735254.869319363
          RETN improve 8735254.869319363
          CALL good-enough? 8735254.869319363 8.796093022208e12
          RETN good-enough? #f
          CALL improve 8735254.869319363 8.796093022208e12
            CALL average 8735254.869319363 1006964.6683237965
            RETN average 4871109.768821579
          RETN improve 4871109.768821579
          CALL good-enough? 4871109.768821579 8.796093022208e12
          RETN good-enough? #f
          CALL improve 4871109.768821579 8.796093022208e12
            CALL average 4871109.768821579 1805767.7694945384
            RETN average 3338438.769158059
          RETN improve 3338438.769158059
          CALL good-enough? 3338438.769158059 8.796093022208e12
          RETN good-enough? #f
          CALL improve 3338438.769158059 8.796093022208e12
            CALL average 3338438.769158059 2634792.3776437393
            RETN average 2986615.573400899
          RETN improve 2986615.573400899
          CALL good-enough? 2986615.573400899 8.796093022208e12
          RETN good-enough? #f
          CALL improve 2986615.573400899 8.796093022208e12
            CALL average 2986615.573400899 2945170.8149341
            RETN average 2965893.1941674994
          RETN improve 2965893.1941674994
          CALL good-enough? 2965893.1941674994 8.796093022208e12
          RETN good-enough? #f
          CALL improve 2965893.1941674994 8.796093022208e12
            CALL average 2965893.1941674994 2965748.409115247
            RETN average 2965820.801641373
          RETN improve 2965820.801641373
          CALL good-enough? 2965820.801641373 8.796093022208e12
          RETN good-enough? #f
          CALL improve 2965820.801641373 8.796093022208e12
            CALL average 2965820.801641373 2965820.799874349
            RETN average 2965820.8007578608
          RETN improve 2965820.8007578608
          CALL good-enough? 2965820.8007578608 8.796093022208e12
          RETN good-enough? #f</span>
<span class="em-red">          CALL improve 2965820.8007578608 8.796093022208e12
            CALL average 2965820.8007578608 2965820.800757861
            RETN average 2965820.8007578608
          RETN improve 2965820.8007578608
          CALL good-enough? 2965820.8007578608 8.796093022208e12
          RETN good-enough? #f
          CALL improve 2965820.8007578608 8.796093022208e12
            CALL average 2965820.8007578608 2965820.800757861
            RETN average 2965820.8007578608
          RETN improve 2965820.8007578608
          CALL good-enough? 2965820.8007578608 8.796093022208e12
          RETN good-enough? #f
             .... 以下省略 ...</span>

<span class="ex_comment">これを見ると、
* average の第一引数と返り値が同じになってしまい、
* その結果、improve も第一引数と返り値が同じになってしまい、
* したがって、近似値 (guess) をさらに真の値へと近づけることがまったく
  できない状態になり、
* そこまで収束しつつある状態といえども、誤差の絶対値は 0.001 に比べれば
  大きいため、good-enough? のテストには合格せず、
* そのせいで、前回とまったく同じ引数のまま improve を呼び出すことになり、
  無限ループに陥っている、
ということが分かる。</span>

</p>

<p class="exercise"><span class="ex_comment">; プログラムの書き換え案</span>
(define (sqrt-iter guess old-guess x)
  (if (good-enough? guess old-guess)
      guess
      (sqrt-iter (improve guess x) guess x)))

<span class="ex_comment">; improveとaverageは同じまま。再掲。</span>
(define (improve guess x) (average guess (/ x guess))) 
(define (average x y) (/ (+ x y) 2))

(define (good-enough? guess old-guess)
  (&lt; (abs (- 1.0 (/ guess old-guess))) 0.001))

<span class="ex_comment">; 絶対にgood-enough?が真にならないような値をold-guessの初期値とする。</span>
(define (sqrt x) (sqrt-iter 1.0 2.0 x))

<span class="ex_comment">; さて実行してみますか。
; まずは普通の数。いい感じですね。</span>
gosh&gt; (sqrt 3)
1.7320508100147274
gosh&gt; (sqrt 2)
1.4142135623746899
<span class="ex_comment">; 次は小さい数。これも良い精度だ。</span>
gosh&gt; (sqrt 0.04)
0.2000000000021489
gosh&gt; (sqrt 0.01)
0.10000000000139897
gosh&gt; (sqrt 0.0025)
0.05000000000074607
gosh&gt; (sqrt 0.0016)
0.04000000010092315
gosh&gt; (sqrt 0.0009)
0.030000012746348552
gosh&gt; (sqrt 0.0004)
0.020000000050877154
gosh&gt; (sqrt 0.0001)
0.010000000025490743
gosh&gt; (sqrt 0.000001)
0.0010000001533016628
<span class="ex_comment">; 次は大きい数。ちゃんと止まる。</span>
gosh&gt; (define p1 (expt 2.0 42))
p1
gosh&gt; (sqrt p1)
2097152.4720067866
gosh&gt; (define p2 (expt 2.0 43))
p2
gosh&gt; (sqrt p2)
2965820.801641373
gosh&gt; (define p3 (expt 2.0 44))
p3
gosh&gt; (sqrt p3)
4194304.944013573
<span class="ex_comment">; 一応答え合わせをしておきます。</span>
gosh&gt; (expt 2.0 21)
2097152.0
gosh&gt; (expt 2.0 21.5)
2965820.800757861
gosh&gt; (expt 2.0 22)
4194304.0
</p>


<a name="%_thm_1.8"></a>
<p class="orig" lang="en">
<b>Exercise 1.8.</b>&nbsp;&nbsp;<a name="%_idx_560"></a><a name="%_idx_562"></a>Newton's method for cube roots is based on the fact that if <em>y</em> is an
approximation to the cube root of <em>x</em>, then a better approximation is
given by the value</p>

<p class="trans" lang="ja">
<b>Exercise 1.8.</b> 三乗根についてのニュートン法は、もし<em class="en">y</em>が<em class="en">x</em>の三乗根の近似であれば、以下の値によって、より良い近似が与えられる、という事実に基づいている。
</p>

<figure><img src="ch1-Z-G-5.gif" border="0"></figure>

<p class="orig" lang="en">
Use this formula to implement a cube-root procedure analogous to the
square-root procedure.  (In section&nbsp;<a href="12_sec1_3.html#%_sec_1.3.4">1.3.4</a> we
will see how to implement Newton's method in general as an abstraction
of these square-root and cube-root procedures.)
</p>

<p class="trans" lang="ja">
この式を用いて、二乗根の手続きと類似した三乗根の手続きを実装せよ
(これらの二乗根と三乗根の手続きの抽象化として、一般のニュートン法をどのように実装するのかについては、<a href="12_sec1_3.html#%_sec_1.3.4">1.3.4</a>節で見ることにしよう)。
</p>

<p class="exercise"><span class="ex_comment">; 手続きの名前が違うだけで二乗根のときと同じ。練習問題1.7の答えを参照して改良してある。</span>
(define (cube-root-iter guess old-guess x)
  (if (good-enough? guess old-guess)
      guess
      (cube-root-iter (improve guess x) guess x)))
<span class="ex_comment">; 上記の与えられた式によってimproveの定義を書く。</span>
(define (improve guess x)
  (/ (+ (/ x (* guess guess)) (* 2 guess)) 3))
<span class="ex_comment">; 練習問題1.7の答えと同じ。</span>
(define (good-enough? guess old-guess)
  (&lt; (abs (- 1.0 (/ guess old-guess))) 0.001))
<span class="ex_comment">; 最初の呼び出し用。</span>
(define (cube-root x) (cube-root-iter 1.0 2.0 x))

<span class="ex_comment">; 試してみよう。</span>
gosh&gt; (cube-root 27)
3.0000005410641766
gosh&gt; (cube-root 0.000027)  
0.030000000409701272
gosh&gt; (cube-root 0.000008)
0.020000000273168006
<span class="ex_comment">; 適当な大きな数も試してみる。</span>
gosh&gt; (define b (expt 2.0 53))
b
gosh&gt; (define c (cube-root b))
c
gosh&gt; c
208063.83563879892
<span class="ex_comment">; 誤差の絶対値自体は、結構大きいんですね。</span>
gosh&gt; (- b (* c c c))
-643543126.0
<span class="ex_comment">; けれども、有効桁数という点から見れば、c<sup>3</sup>はbに十分に近いと言えるんじゃないかな
; (7桁まで一致していることを示すために強調表示しておく)。</span>
gosh&gt; (* c c c)
<b>9.007199</b>898284118<b>e15</b>
gosh&gt; b
<b>9.007199</b>254740992<b>e15</b>
</p>

<a name="%_sec_1.1.8"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_1.1.8">1.1.8&nbsp;&nbsp;Procedures as Black-Box Abstractions</a></h3>
<h3 class="trans" lang="ja">1.1.8 ブラック・ボックス的な抽象としての手続き</h3>

<p class="orig" lang="en">
<tt>Sqrt</tt> is our first example of a process defined by a set of
mutually defined procedures.  Notice that the definition of <tt>sqrt-iter</tt> is <a name="%_idx_564"></a><em>recursive</em>; that is, the procedure is defined in
terms of itself.  The idea of being able to define a procedure in
terms of itself may be disturbing; it may seem unclear how such a
``circular'' definition could make sense at all, much less specify a
well-defined process to be carried out by a computer.  This will be
addressed more carefully in
section&nbsp;<a href="11_sec1_2.html#%_sec_1.2">1.2</a>.  But first let's consider
some other important points illustrated by the <tt>sqrt</tt> example.</p>

<p class="trans" lang="ja">
<tt>sqrt</tt> は、相互に定義された諸手続きの集まりによって定義されるプロセスの最初の例である。
<tt>sqrt-iter</tt> の定義が<em>再帰的</em>であること——つまり、手続きが、それ自体との関係から定義されていること——に注目してほしい。
手続きをそれ自体との関係から定義できるという概念は、ひとを不安にさせるものかもしれない。そのような「循環的な」定義が、一体どうやったら意味を持ち得たり、ましてや、コンピュータにより実行されるべき、明確に定義されたプロセスを指定し得たりするのか、ということが、不明に思えるかもしれない。
このことには、<a href="11_sec1_2.html#%_sec_1.2">1.2</a>節でもっと注意深く取り組むことにしよう。
だが、まずは、<tt>sqrt</tt> の例で示された、他のいくつかの重要な点について考えよう。
</p>

<a name="%_idx_566"></a>
<p class="orig" lang="en">
Observe that the problem of computing square roots breaks up naturally
into a number of subproblems: how to tell whether a guess is good
enough, how to improve a guess, and so on.  Each of these tasks is
accomplished by a separate procedure.  The entire <tt>sqrt</tt> program
can be viewed as a cluster of procedures (shown in
figure&nbsp;<a href="#%_fig_1.2">1.2</a>) that mirrors the decomposition of
the problem into subproblems.</p>

<p class="trans" lang="ja">
二乗根を計算する問題が、<!--当然ながら-->自然と、いくつかの下位問題——見積もりが十分に良いかどうかをいかにして判断するか、見積もりをいかにして改善するか、など——へと分解されることに気づいてほしい。
これらの課題の各々は、別々の手続きとして達成される。
<tt>sqrt</tt> の全体のプログラムは、問題から下位問題への分解を反映している、(図<a href="#%_fig_1.2">1.2</a>に示したような) 一群の手続きだ、と見なすことができる。
</p>

<a name="%_fig_1.2"></a>
<figure>
	<img src="ch1-Z-G-6.gif" border="0">
	<figcaption class="orig" lang="en">Figure 1.2:</b>&nbsp;&nbsp;Procedural decomposition of the <tt>sqrt</tt> program.</figcaption>
	<figcaption class="trans" lang="ja">図 1.2:</b> <tt>sqrt</tt>のプログラムの手続き的分解</figcaption>
</figure>

<a name="%_idx_568"></a>
<p class="orig" lang="en">The importance of this decomposition strategy is not simply that one
is dividing the program into parts.  After all, we could take any
large program and divide it into parts -- the first ten lines, the next
ten lines, the next ten lines, and so on.  Rather, it is crucial that
each procedure accomplishes an identifiable task that can be used as a
module in defining other procedures.  <a name="%_idx_570"></a>For example, when we define the
<tt>good-enough?</tt> procedure in terms of <tt>square</tt>, we are able to
regard the <tt>square</tt> procedure as a <a name="%_idx_572"></a>``black box.''  We are not at
that moment concerned with <em>how</em> the procedure computes its
result, only with the fact that it computes the square.  The details
of how the square is computed can be suppressed, to be considered at a
later time.  Indeed, as far as the <tt>good-enough?</tt> procedure is
concerned, <tt>square</tt> is not quite a procedure but rather an
abstraction of a procedure, a so-called <a name="%_idx_574"></a><a name="%_idx_576"></a><em>procedural abstraction</em>.
At this level of abstraction, any procedure that computes the square
is equally good.</p>

<p class="trans" lang="ja">
この分解戦略の重要な点は、単にプログラムをいくつかの部分に分割しているという点ではない。
私たちは、結局は、どれほど大きなプログラムでも受け止め、それをいくつかの部分へと分割できるだろう——最初の10行、次の10行、そのまた次の10行、というふうに。
むしろ、各手続きが、他の手続きを定義する際にモジュールとして使えるような識別可能な課題を達成することが、決定的に重要である。
たとえば、<tt>square</tt> を用いて <tt>good-enough?</tt> の手続きを定義するとき、<tt>square</tt> の手続きを「ブラックボックス」と見なすことができる。
その時点では、<em>どうやって</em>その手続きが結果を計算するのか、ということには関心がなく、ただ、その手続きが二乗を計算するという事実にのみ関心がある。
どのように二乗が計算されるのか、という詳細は、隠され得る——後に考えるべきものとして。
実際、<tt>good-enough?</tt> の手続きに関する限り、<tt>square</tt> はまったくの手続きというわけではなく、むしろ、手続きの抽象概念——いわゆる<em>手続き的抽象</em>——である。
抽象化のこのレベルでは、二乗を計算するいかなる手続きも、等しく好適である。
</p>

<p class="orig" lang="en">
Thus, considering only the values they return, the following two procedures for
squaring a number should be indistinguishable.  Each takes a numerical
argument and produces the square of that number as the
value.<a name="call_footnote_Temp_40" href="#footnote_Temp_40"><sup><small>25</small></sup></a>
</p>

<p class="trans" lang="ja">
よって、手続きが返す値だけを考えることにすると、ある数を二乗するための以下の二つの手続きは、互いに区別できないに違いない。
各々の手続きは、数値的な引数を取り、その数の二乗を、値として生み出す<a href="#footnote_Temp_40"><sup><small>25</small></sup></a>。
</p>

<p class="lisp">(define (square x) (* x x))

(define (square x) 
  (exp (double (log x))))

(define (double x) (+ x x))
</p>

<p class="orig" lang="en">
So a procedure definition should be able to suppress detail.  The
users of the procedure may not have written the procedure themselves,
but may have obtained it from another programmer as a black box.  A
user should not need to know how the procedure is implemented in order
to use it.</p>

<p class="trans" lang="ja">
このように、手続き定義は、詳細を隠すことができるべきなのだ。
手続きを使う人たちは、その手続き自体を書いたわけではないかもしれず、その手続きを、ブラックボックスとして他のプログラマから手に入れたのかもしれない。
<!--手続きがどのように実装されているのかを、手続きを使うためにユーザが知っておく必要性は、なくすべきだ。-->
手続きがどのように実装されているのかを、手続きを使うためにユーザが知っておく必要はないはずである。
</p>

<a name="%_sec_Temp_41"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_41">Local names</a></h4>
<h4 class="trans" lang="ja">局所的な名前</h4>

<a name="%_idx_578"></a>
<p class="orig" lang="en">
One detail of a procedure's implementation that should not matter to
the user of the procedure is the implementer's choice of names for the
procedure's formal parameters.  Thus, the following procedures should
not be distinguishable:</p>

<p class="trans" lang="ja">
手続きを使う人にとって重要であるべきではない、手続きの実装の細目のひとつは、実装者がその手続きの仮引数にどんな名前を選んだかということだ。<!--その手続きの仮引数の名前についての、実装者の選択である。-->
よって、以下の手続き同士は、区別可能であるべきではない。
</p>

<p class="lisp">(define (square x) (* x x))

(define (square y) (* y y))
</p>

<p class="orig" lang="en">
This principle -- that the meaning of a procedure should be independent
of the parameter names used by its author -- seems on the surface to be
self-evident, but its consequences are profound.  The simplest
consequence is that the parameter names of a procedure must be local
to the body of the procedure.  For example, we used <tt>square</tt> in
the definition of <tt>good-enough?</tt> in our square-root procedure:</p>

<p class="trans" lang="ja">
この原則——手続きの意味は、手続きを書いた人が使ったパラメタ名に依存すべきではない、という原則——は、表面的には自明なように見えるが、その影響は深刻である。
もっとも単純な影響は、手続きのパラメタ名は、その手続きの本体に局所的なものでなくてはならない、というものである。
たとえば、私たちは、二乗根の手続きの中で、以下のとおり、<tt>good-enough?</tt> の定義に <tt>square</tt> を使った。
</p>

<p class="lisp">(define (good-enough? guess x)
  (&lt; (abs (- (square guess) x)) 0.001))
</p>

<p class="orig" lang="en">
The intention of the author of <tt>good-enough?</tt> is to determine if
the square of the first argument is within a given tolerance of the
second argument.  We see that the author of <tt>good-enough?</tt> used
the name <tt>guess</tt> to refer to the first argument and <tt>x</tt> to
refer to the second argument.  The argument of <tt>square</tt> is <tt>guess</tt>.  If the author of <tt>square</tt> used <tt>x</tt> (as above)
to refer to that argument, we see that the <tt>x</tt> in <tt>good-enough?</tt> must be a different <tt>x</tt> than the one in <tt>square</tt>.  Running the procedure <tt>square</tt> must not affect the value
of <tt>x</tt> that is used by <tt>good-enough?</tt>, because that value of
<tt>x</tt> may be needed by <tt>good-enough?</tt> after <tt>square</tt> is done
computing.</p>

<p class="trans" lang="ja">
<tt>good-enough?</tt> の作者の意図は、第一引数の二乗が、第二引数から所定の許容誤差範囲内にあるかどうかを判定することである。
<tt>good-enough?</tt> の作者が、第一引数を参照するのに <tt>guess</tt> という名前を使い、第二引数を参照するのに <tt>x</tt> という名前を使ったことが分かる。
<tt>square</tt> の引数は <tt>guess</tt> である。
もし、<tt>square</tt> の作者が (上記のとおり) その引数を参照するのに <tt>x</tt> を使ったなら、<tt>good-enough?</tt> 内の <tt>x</tt> は <tt>square</tt> 内の <tt>x</tt> とは異なる <tt>x</tt> でなくてはならない、ということが分かるはずだ。
<tt>square</tt> という手続きを実行することは、<tt>good-enough?</tt> で使われる <tt>x</tt> の値に影響してはならない——なぜなら、その <tt>x</tt> の値は、<tt>square</tt> の完了後に <tt>good-enough?</tt> で必要とされるかもしれないからだ。
</p>

<p class="orig" lang="en">
If the parameters were not local to the bodies of their respective
procedures, then the parameter <tt>x</tt> in <tt>square</tt> could be
confused with the parameter <tt>x</tt> in <tt>good-enough?</tt>, and the
behavior of <tt>good-enough?</tt> would depend upon which version of
<tt>square</tt> we used.  Thus, <tt>square</tt> would not be the black box
we desired.</p>

<p class="trans" lang="ja">
もしパラメタが、それぞれの手続きの本体に局所的なものでなければ、<tt>square</tt> 内の <tt>x</tt> というパラメタは、<tt>good-enough?</tt> 内の <tt>x</tt> というパラメタと混同され得るだろうし、<tt>good-enough?</tt> の振る舞いが、どのバージョンの <tt>square</tt> を私たちが使ったのか、ということに依存してしまうだろう。
よって、<tt>square</tt> は、私たちが望んだブラックボックスではなくなってしまうだろう。
</p>

<a name="%_idx_580"></a><a name="%_idx_582"></a>
<p class="orig" lang="en">
A formal parameter of a procedure has a very special role in the
procedure definition, in that it doesn't matter what name the formal
parameter has.  Such a name is called a <a name="%_idx_584"></a><a name="%_idx_586"></a><em>bound variable</em>, and we
say that the procedure definition <a name="%_idx_588"></a><em>binds</em> its formal parameters.
The meaning of a procedure definition is unchanged if a bound variable
is consistently renamed throughout the definition.<a name="call_footnote_Temp_42" href="#footnote_Temp_42"><sup><small>26</small></sup></a>  If a variable is not bound, we say that it is <a name="%_idx_590"></a><a name="%_idx_592"></a><em>free</em>.  The
set of expressions for which a binding defines a name is called the
<a name="%_idx_594"></a><a name="%_idx_596"></a><em>scope</em> of that name.
In a procedure definition, the bound variables
declared as the <a name="%_idx_598"></a><a name="%_idx_600"></a><a name="%_idx_602"></a>formal parameters of the procedure have the body of
the procedure as their scope.</p>

<p class="trans" lang="ja">
手続きの仮引数は、手続き定義において非常に特殊な——その仮引数がどのような名前なのかは重要でない、という点で——役割を果たす。
そのような名前は<em>束縛変数</em>と呼ばれ、手続き定義がそれ自体の仮引数を<em>束縛する</em>、という言い方をする。
手続き定義の意味は、もし束縛変数が、その定義全体を通して首尾一貫して別の名前にされたなら、変わらない<a href="#footnote_Temp_42"><sup><small>26</small></sup></a>。
もし、変数が束縛されていなければ、その変数は<em>自由</em>だ、という言い方をする。
<!--束縛により名前を定義する対象であるような、-->束縛が名前を定義している対象たる式の集まりは、その名前の<em>スコープ</em>と呼ばれる。
手続き定義では、その手続きの仮引数として宣言された束縛変数は、当該手続きの本体をスコープとする。
</p>

<p class="orig" lang="en">
In the definition of <tt>good-enough?</tt> above, <tt>guess</tt> and <tt>x</tt> are
bound variables but <tt>&lt;</tt>, <tt>-</tt>, <tt>abs</tt>, and <tt>square</tt> are free.
The meaning of <tt>good-enough?</tt> should be independent of the names we
choose for <tt>guess</tt> and <tt>x</tt> so long as they are distinct and
different from <tt>&lt;</tt>, <tt>-</tt>, <tt>abs</tt>, and <tt>square</tt>.  (If we renamed
<tt>guess</tt> to <tt>abs</tt> we would have introduced a bug by <a name="%_idx_604"></a><a name="%_idx_606"></a><a name="%_idx_608"></a><em>capturing</em>
the variable <tt>abs</tt>.  It would have changed from free to bound.)  The
meaning of <tt>good-enough?</tt> is not independent of the names of its
free variables, however.  It surely depends upon the fact (external to
this definition) that the symbol <tt>abs</tt> names a procedure for
computing the absolute value of a number.  <tt>Good-enough?</tt> will
compute a different function if we substitute <tt>cos</tt> for <tt>abs</tt> in
its definition.</p>

<p class="trans" lang="ja">
上記の <tt>good-enough?</tt> の定義では、<tt>guess</tt> と <tt>x</tt> が束縛変数だが、<tt>&lt;</tt> と <tt>-</tt> と <tt>abs</tt> と <tt>square</tt> は自由である。
<tt>good-enough?</tt> の意味は、<tt>guess</tt> と <tt>x</tt> のために選ぶ名前とは独立しているべきである——それらの名前が、<tt>&lt;</tt> と <tt>-</tt> と <tt>abs</tt> と <tt>square</tt> とは別の異なるものである限りは
(もし、<tt>guess</tt> を <tt>abs</tt> と改名したなら、変数 <tt>abs</tt> の<em>取り込み</em>によって、バグを持ち込んでしまっただろう。
それに、<tt>abs</tt> は自由な状態から束縛された状態へと変わってしまっただろう)。
しかし、<tt>good-enough?</tt> の意味は、自由変数の名前と独立ではない。
<tt>good-enough?</tt> の意味は、<tt>abs</tt> というシンボルが、数の絶対値を計算するための手続きを名指ししている、という (この定義の外側の) 事実に、確かに依存しているのだ。
もし、<tt>good-enough?</tt> の定義において <tt>cos</tt> を <tt>abs</tt> の代わりに用いたら、 <tt>good-enough?</tt> は別の関数を計算することになるだろう。</p>

<a name="%_sec_Temp_43"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_43">Internal definitions and block structure</a></h4>
<h4 class="trans" lang="ja">内部定義とブロック構造</h4>

<p class="orig" lang="en">
We have one kind of name isolation available to us so far: The formal
parameters of a procedure are local to the body of the procedure.  The
square-root program illustrates another way in which we would like to
control the use of names.  <a name="%_idx_610"></a>The existing program consists of
separate procedures:</p>

<p class="trans" lang="ja">
私たちには、今までのところ利用可能な、一種の名前隔離がある——手続きの仮引数は、その手続きの本体に局所的だ、というものだ。
二乗根のプログラムは、私たちが名前の使用を制御するのに使いたいと思うような、もう一つの方法を示している。
既存のプログラムは、以下のとおり、別々の手続きからなる。
</p>

<p class="lisp">(define (sqrt x)
  (sqrt-iter 1.0 x))
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x)))
(define (good-enough? guess x)
  (&lt; (abs (- (square guess) x)) 0.001))
(define (improve guess x)
  (average guess (/ x guess)))
</p>

<p class="orig" lang="en">
The problem with this program is that the only procedure that is
important to users of <tt>sqrt</tt> is <tt>sqrt</tt>.  The other
procedures (<tt>sqrt-iter</tt>, <tt>good-enough?</tt>, and <tt>improve</tt>)
only clutter up their minds.  They may not define any other procedure
called <tt>good-enough?</tt> as part of another program to work together
with the square-root program, because <tt>sqrt</tt> needs it.  The
problem is especially severe in the construction of large systems by
many separate programmers.  For example, in the construction of a
large library of numerical procedures, many numerical functions are
computed as successive approximations and thus might have procedures
named <tt>good-enough?</tt> and <tt>improve</tt> as auxiliary procedures.
We would like to localize the subprocedures, hiding them inside <tt>sqrt</tt> so that <tt>sqrt</tt> could coexist with other successive
approximations, each having its own private
<tt>good-enough?</tt> procedure.  To make this possible, we allow a
procedure to have
<a name="%_idx_612"></a><a name="%_idx_614"></a>internal definitions that are local to that procedure.  For example,
in the square-root problem we can write</p>


<p class="trans" lang="ja">
このプログラムについての問題は、<tt>sqrt</tt> の使い手にとって重要な唯一の手続きは <tt>sqrt</tt> だ、という点だ。
他の手続き (<tt>sqrt-iter</tt> と <tt>good-enough?</tt> と <tt>improve</tt>) は、かれらの頭をぐちゃぐちゃにするだけだ。
かれらは、<tt>good-enough?</tt> と呼ばれる他のいかなる手続きも、二乗根のプログラムと一緒に動く別のプログラムの一部として定義してはいけない——なぜなら、<tt>sqrt</tt> が <tt>good-enough?</tt> を必要とするからである。
多くの別々のプログラマによる大規模システムの構築において、この問題はとりわけ深刻である。
たとえば、数値的手続きの大規模ライブラリの構築では、多くの数値的関数が、連続する近似として計算され、したがって、<tt>good-enough?</tt> や <tt>improve</tt> と名付けられた手続きを補助関数として持つかもしれない。
私たちは、下位手続きを局所化したい——各自が自身の非公開の <tt>good-enough?</tt> という手続きを有するような他の連続近似法と、<tt>sqrt</tt> とが共存できるように、<tt>sqrt</tt> の下位手続きを <tt>sqrt</tt> の内部に隠してしまうのだ。
これを可能にするために、手続きが、その手続きに局所的な内部定義を持てるようにする。
たとえば、二乗根の問題では、次のように書ける。
</p>

<p class="lisp">(define (sqrt x)
  (define (good-enough? guess x)
    (&lt; (abs (- (square guess) x)) 0.001))
  (define (improve guess x)
    (average guess (/ x guess)))
  (define (sqrt-iter guess x)
    (if (good-enough? guess x)
        guess
        (sqrt-iter (improve guess x) x)))
  (sqrt-iter 1.0 x))
</p>

<p class="orig" lang="en">
Such nesting of definitions, called <em>block structure</em>,
is basically the right solution to the simplest 
name-packaging problem.  But there is a better idea lurking here.  In
addition to internalizing the definitions of the auxiliary procedures,
we can simplify them.  Since <tt>x</tt> is bound in the definition of
<tt>sqrt</tt>, the procedures <tt>good-enough?</tt>, <tt>improve</tt>, and
<tt>sqrt-iter</tt>, which are defined internally to <tt>sqrt</tt>, are in the
scope of <tt>x</tt>.  Thus, it is not necessary to pass <tt>x</tt> explicitly to
each of these procedures.  Instead, we allow <tt>x</tt> to be a <a name="%_idx_616"></a><a name="%_idx_618"></a>free
variable in the internal definitions, as shown below. Then <tt>x</tt>
gets its value from the argument with which the enclosing
procedure <tt>sqrt</tt> is called.  This discipline is called <a name="%_idx_620"></a><em>lexical
scoping</em>.<a name="call_footnote_Temp_44" href="#footnote_Temp_44"><sup><small>27</small></sup></a>
</p>

<p class="trans" lang="ja">
このような定義の入れ子——<em>ブロック構造</em>と呼ばれる——は、基本的には、もっとも単純な名前パッケージ化問題に対する、正しい解決策である。
しかし、ここに、より良い考えが潜んでいる。
補助手続きの定義を内部化するのに加えて、補助手続きの定義を簡素化することもできる。
<tt>x</tt> は <tt>sqrt</tt> の定義の中で束縛されているので、<tt>good-enough?</tt> と<tt>improve</tt> と <tt>sqrt-iter</tt> という手続き—— <tt>sqrt</tt> の内部で定義されているもの——は、<tt>x</tt> のスコープの中にある。
よって、これらの手続きのそれぞれに対して <tt>x</tt> を明示的に受け渡す必要はない。
代わりに、以下に示すとおり、<tt>x</tt> を内部定義の中での自由変数としておける。
すると、<tt>x</tt> は、自身の値を、外側を囲っている <tt>sqrt</tt> という手続きが呼ばれるときの実引数から、得る。
この規律は、<em>レキシカル・スコープ</em>と呼ばれる<a href="#footnote_Temp_44"><sup><small>27</small></sup></a>。
</p>

<p class="lisp"><a name="%_idx_624"></a>(define (sqrt x)
  (define (good-enough? guess)
    (&lt; (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))
</p>

<p class="orig" lang="en">
We will use block structure extensively to help us break
up large programs into tractable pieces.<a name="call_footnote_Temp_45" href="#footnote_Temp_45"><sup><small>28</small></sup></a>
The idea of block structure originated with the
programming language <a name="%_idx_628"></a>Algol 60.  It appears in most advanced
programming languages and is an important tool for helping to organize
the construction of large programs.</p>

<p class="trans" lang="ja">
大きな問題を、扱いやすい部分へと分解するのを手助けするために、ブロック構造を広範囲にわたって使うことにしよう<a href="#footnote_Temp_45"><sup><small>28</small></sup></a>。
ブロック構造の考え方は、Algol 60というプログラミング言語を起源としている。
ブロック構造の考え方は、ほとんどの先進的なプログラミング言語に現れており、大規模プログラムの構築を系統立てるのを助けるための重要な手段となっている。
</p>

<a name="footnotes"></a>
<hr>
<p class="orig" lang="en"><a name="footnote_Temp_10" href="#call_footnote_Temp_10"><sup><small>4</small></sup></a> The
characterization of numbers as ``simple data'' is a barefaced bluff.
In fact, the treatment of numbers is one of the trickiest and most
confusing aspects of any programming language.  Some typical issues
involved are these:
<a name="%_idx_136"></a><a name="%_idx_138"></a><a name="%_idx_140"></a>Some computer systems distinguish <em>integers</em>, such as 2, from
<em>real numbers</em>, such as 2.71.  Is the real number 2.00 different
from the integer 2?
Are the arithmetic operations used
for integers the same as the operations used for real numbers?  Does 6
divided by 2 produce 3, or 3.0?  How large a number can we represent?
How many decimal places of accuracy can we represent?  Is the range of
integers the same as the range of real numbers?  <a name="%_idx_142"></a><a name="%_idx_144"></a><a name="%_idx_146"></a>Above and beyond
these questions, of course, lies a collection of issues concerning
roundoff and truncation errors -- the entire science of numerical
analysis.  Since our focus in this book is on large-scale program
design rather than on numerical techniques, we are going to ignore
these problems.  The numerical examples in this chapter will exhibit
the usual roundoff behavior that one observes when using arithmetic
operations that preserve a limited number of decimal places of
accuracy in noninteger operations.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_10"><sup><small>4</small></sup></a>
数を「単純なデータ」として特徴づけることは、白々しいはったりである。
実際、数の扱いは、どのプログラミング言語でも、最も巧妙かつ最も紛らわしい側面の一つなのである。
関連するいくつかの典型的な論点は、以下のようなものである。
ある種のコンピュータ・システムは、2のような<em>整数</em>と、2.71のような<em>実数</em>を区別する。
2.00という実数は、2という整数と異なるのだろうか?
整数同士に使われる算術演算は、実数同士に使われる演算と同じなのか?
6を2で割ったら、3になるのか、それとも3.0になるのか?
どれくらい大きな数を表現できるのか?
小数点以下の何桁の精度まで表現できるのか?
整数の範囲は、実数の範囲と同じか?
これらの疑問以上に、もちろん、四捨五入と丸めによる誤差に関する論点の山——まったくの数値的解析の科学——がある。
本書で私たちは、数値的な技法よりもむしろ、大規模なプログラムの設計に焦点を当てているので、私たちは、これらの問題を無視するつもりだ。
本章での数値例は、非整数の演算において限られた桁数の精度を保つ算術演算を使ったときに見られる、通常の四捨五入の振る舞いを示すだろう。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_11" href="#call_footnote_Temp_11"><sup><small>5</small></sup></a> Throughout this book,
<a name="%_idx_152"></a>when we wish to emphasize the distinction between the input typed by
the user and the response printed by the interpreter, we will show the
latter in slanted characters.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_11"><sup><small>5</small></sup></a>
本書の全体を通じて、ユーザによって打ち込まれた入力と、インタプリタによって印字された応答との区別を強調したい場合には、後者を斜体文字で示すことにしよう。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_12" href="#call_footnote_Temp_12"><sup><small>6</small></sup></a> <a name="%_idx_200"></a><a name="%_idx_202"></a>Lisp systems typically provide
features to aid the user in formatting expressions.  Two especially
useful features are one that automatically indents to the proper
pretty-print position whenever a new line is started and one that
highlights the matching left parenthesis whenever a right parenthesis
is typed.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_12"><sup><small>6</small></sup></a>
Lispシステムは、典型的には、ユーザが式の形式を整えるのを手助けするための機能を提供している。
特に有用な二つの機能は、新たな行が開始されるときにはいつでも、適切なプリティ・プリントの位置へと自動的に字下げする機能と、右括弧が打ち込まれたときにはいつでも、対応する左括弧を目立たせる機能である。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_13" href="#call_footnote_Temp_13"><sup><small>7</small></sup></a> <a name="%_idx_208"></a><a name="%_idx_210"></a><a name="%_idx_212"></a><a name="%_idx_214"></a>Lisp obeys the convention that every
expression has a value. This convention, together with the old
reputation of Lisp as an inefficient language, is the source of the
quip by Alan Perlis (paraphrasing Oscar Wilde)
that ``Lisp programmers know the value of
everything but the cost of nothing.''</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_13"><sup><small>7</small></sup></a>
Lispは、あらゆる式には値がある、という慣習に従っている。
この慣習は、Lispのことを非効率な言語だと言う昔ながらの世評とともに、アラン・パーリスの「Lispプログラマは、あらゆるものの値を知っているが、どのものについてもコストは知らない」という皮肉 (オスカー・ワイルドの<span class="note"> (『ウィンダミア卿夫人の扇』第三幕の終わり近くの &ldquo;a man who knows the price of everything and the value of nothing&rdquo; という) </span>言葉のもじり) の源泉となっている。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_14" href="#call_footnote_Temp_14"><sup><small>8</small></sup></a> <a name="%_idx_228"></a><a name="%_idx_230"></a>In this book, we do not show the interpreter's response to
evaluating definitions, since this is highly
implementation-dependent.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_14"><sup><small>8</small></sup></a>
本書では、定義を評価することに対するインタプリタの応答は、示さない。というのも、これは実装に依存する度合いが高いので。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_15" href="#call_footnote_Temp_15"><sup><small>9</small></sup></a> Chapter&nbsp;3 will show that this notion of
environment is crucial, both for understanding how the interpreter
works and for implementing interpreters.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_15"><sup><small>9</small></sup></a>
環境というこの概念が、インタプリタがどう動くのかを理解するためにも、インタプリタを実装するためにも、極めて重大だ、ということが、3章で分かるだろう。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_16" href="#call_footnote_Temp_16"><sup><small>10</small></sup></a> It may seem strange that the evaluation rule says, as
part of the first step, that we should evaluate the leftmost element
of a combination, since at this point that can only be an operator
such as <tt>+</tt> or <tt>*</tt>
representing a built-in primitive procedure such as addition or
multiplication.  We will see later that it is useful to be able to work with
combinations whose operators are themselves compound expressions.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_16"><sup><small>10</small></sup></a>
評価規則が、第一のステップの一部として、コンビネーションの最左要素を評価せねばならないことを述べているのは、奇妙に見えるかもしれない。というのも、この場所に置けるものは、加算や乗算のような組み込みの原始的手続きを表す <tt>+</tt> や <tt>*</tt> などの演算子だけなので。
後で、演算子それ自体が複合式であるようなコンビネーションを使って作業することが可能なことは有用である、ということが分かるだろう。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_17" href="#call_footnote_Temp_17"><sup><small>11</small></sup></a> <a name="%_idx_278"></a><a name="%_idx_280"></a><a name="%_idx_282"></a><a name="%_idx_284"></a><a name="%_idx_286"></a><a name="%_idx_288"></a><a name="%_idx_290"></a>Special syntactic forms that are simply convenient
alternative surface structures for things that can be written in more
uniform ways are sometimes called <em>syntactic sugar</em>, to use a
phrase coined by Peter Landin.  In comparison with users of other
languages, Lisp programmers, as a rule, are less concerned with
matters of syntax.  (By contrast, examine any Pascal manual and notice
how much of it is devoted to descriptions of syntax.)  This disdain
for syntax is due partly to the flexibility of Lisp, which makes it
easy to change surface syntax, and partly to the observation that many
``convenient'' syntactic constructs, which make the language less
uniform, end up causing more trouble than they are worth when programs
become large and complex.  In the words of Alan Perlis, ``Syntactic
sugar causes cancer of the semicolon.''</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_17"><sup><small>11</small></sup></a>
より一律な方法で書けるものに対する、単に便利な代わりの表層構造であるような、特殊な文法形式は、ときとして、<em>文法的糖衣</em><span class="note"> (糖衣構文) </span>と呼ばれる——ピーター・ランディンによって新造された言い方を使うならば。
他の言語のユーザと比べると、Lispプログラマは、概して、文法に関する事柄にそれほど関心を持っていない
(逆に、どれかPascalのマニュアルを調べてみてほしい。そして、そのマニュアルのどれほど多くの部分が文法の説明に当てられているのか、ということに注目してほしい)。
文法に対するこの<!--軽蔑-->軽視は、ある程度は、Lisp——表層的な文法を変更するのを簡単にする——の柔軟性によるものであり、ある程度は、プログラムが大規模かつ複雑になったときに、多くの「便利な」文法的構造——言語の一律性を低下させる——が、価値があるという以上に、厄介なことを最終的に引き起こしてしまうのだ、という観察結果によるものだ。
アラン・パーリスの言葉を借りるなら、「文法的糖衣は、セミコロンの癌を引き起こす」わけだ
<span class="note">(Lispのコメントはセミコロンから始まるので、この言葉はおそらく、「糖衣構文の“お約束”が多すぎると、それに頼って書かれたプログラムはコメントがないと理解しづらいので、おのずとコメントの嵐になるよ」ということだろう、と、勝手に推測してみたが、どうだろうか)</span>。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_18" href="#call_footnote_Temp_18"><sup><small>12</small></sup></a> Observe that there are two different operations
being combined here: we are creating the procedure, and we are giving
it the name <tt>square</tt>.  It is possible, indeed important, to be
able to separate these two notions -- to create procedures without
naming them, and to give names to procedures that have already been
created.  We will see how to do this in section&nbsp;<a href="12_sec1_3.html#%_sec_1.3.2">1.3.2</a>.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_18"><sup><small>12</small></sup></a>
ここで結合されている最中の二つの異なる操作が存在することに気づいてほしい。つまり、私たちは、手続きを作成しているところであり、かつ、その手続きに <tt>square</tt> という名前を与えているところなのだ。
<!--実に重要なことに、これら二つの概念を分離できる機能を持つことが可能である——名前をつけずに手続きを作成し、そして、作成済みの手続きに名前を与えるために。-->
実に重要なことに、これら二つの概念を分離する——名前をつけずに手続きを作成し、そして、作成済みの手続きに名前を与えるように、分離する——能力を持つことが可能である。
このことをどのように行うのかについては、<a href="12_sec1_3.html#%_sec_1.3.2">1.3.2</a>節で見ることにしよう。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_19" href="#call_footnote_Temp_19"><sup><small>13</small></sup></a> Throughout this book, we will
<a name="%_idx_314"></a><a name="%_idx_316"></a>describe the general syntax of expressions by using italic symbols
delimited by angle brackets -- e.g., &lt;<em>name</em>&gt; -- to denote the
``slots'' in the expression to be filled in when such an expression is
actually used.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_19"><sup><small>13</small></sup></a>
本書の全体を通じて、私たちは、式が実際に使われるときに埋められるべき、式の中の「場所」を示すための、角括弧で括られたイタリック体のシンボル——例えば &lt;<em class="en">name</em>&gt; ——を使って、式の一般的文法を説明してゆこう。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_20" href="#call_footnote_Temp_20"><sup><small>14</small></sup></a> More
<a name="%_idx_326"></a>generally, the body of the procedure can be a sequence of expressions.
In this case, the interpreter evaluates each expression in the
sequence in turn and returns the value of the final expression as the
value of the procedure application.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_20"><sup><small>14</small></sup></a>
より一般的には、手続きの本体は、式の連なりであってもよい。
この場合、インタプリタは、その連なりの中のそれぞれの式を順に評価し、手続き適用の値として、最後の式の値を返す。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_21" href="#call_footnote_Temp_21"><sup><small>15</small></sup></a> Despite the
simplicity of the substitution idea, it turns out to be surprisingly
complicated to give a rigorous mathematical definition of the
substitution process.  The problem arises from the possibility of
confusion between the names used for the formal parameters of a
procedure and the (possibly identical) names used in the expressions
to which the procedure may be applied.  Indeed, there is a long
history of erroneous definitions of <em>substitution</em> in the
literature of logic and programming semantics.  <a name="%_idx_338"></a>See Stoy 1977 for a
careful discussion of substitution.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_21"><sup><small>15</small></sup></a>
<ruby><rb>代入</rb><rp> (</rp><rt>おきかえ</rt><rp>) </rp></ruby>概念の単純さにもかかわらず、<ruby><rb>代入</rb><rp> (</rp><rt>おきかえ</rt><rp>) </rp></ruby>プロセスの厳密な数学的定義を与えることは、驚くほど複雑なことだと分かる。
手続きの仮引数に使われる名前と、その手続きが適用されるかもしれない式において使われる (もしかしたら同一の) 名前との間の混同の可能性から、問題が生じる。
実際、論理学とプログラミング意味論の文献において、<em><ruby><rb>代入</rb><rp> (</rp><rt>おきかえ</rt><rp>) </rp></ruby></em>の間違った定義の長い歴史があるのだ。
<ruby><rb>代入</rb><rp> (</rp><rt>おきかえ</rt><rp>) </rp></ruby>についての注意深い議論については、Stoy 1977を参照のこと。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_23" href="#call_footnote_Temp_23"><sup><small>16</small></sup></a> In
chapter&nbsp;3 we will introduce <em>stream processing</em>, which is a way of
handling apparently ``infinite'' data structures by incorporating a
limited form of normal-order evaluation.  In
section&nbsp;<a href="27_sec4_2.html#%_sec_4.2">4.2</a> we will modify the Scheme
interpreter to produce a normal-order variant of Scheme.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_23"><sup><small>16</small></sup></a>
3章で、<em>ストリーム処理</em>—— 一見すると「無限の」データ構造を、正規順の評価の限られた形を取り入れることによって、うまく扱う方法——を導入しよう。
<a href="27_sec4_2.html#%_sec_4.2">4.2</a>節では、Schemeインタプリタを変更して、正規順で動くSchemeの変種を作り出そう。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_24" href="#call_footnote_Temp_24"><sup><small>17</small></sup></a> <a name="%_idx_368"></a><a name="%_idx_370"></a><a name="%_idx_372"></a><a name="%_idx_374"></a><a name="%_idx_376"></a><a name="%_idx_378"></a><a name="%_idx_380"></a><a name="%_idx_382"></a>``Interpreted as either true or false''
means this: In Scheme, there are two distinguished values that are
denoted by the constants <tt>#t</tt> and <tt>#f</tt>.  When the interpreter
checks a predicate's value, it interprets <tt>#f</tt> as false.  Any other value
is treated as true.  (Thus, providing <tt>#t</tt> is logically
unnecessary, but it is convenient.)  In this book we will use
names <tt>true</tt> and <tt>false</tt>, which are associated
with the values <tt>#t</tt> and <tt>#f</tt> respectively.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_24"><sup><small>17</small></sup></a>
「真か偽と解釈される」とは、次のような意味である。
Schemeでは、<tt>#t</tt> および <tt>#f</tt> という定数により示される、二つの際立った値がある。
インタプリタは、述語の値をチェックするとき、<tt>#f</tt> を偽と解釈する。
他のいかなる値も、真として扱われる
(よって、<tt>#t</tt> を提供することは、論理的には不要なのだが、<tt>#t</tt> は便利である)。
本書で私たちは、<tt>true</tt> (真) および<tt>false</tt> (偽) という名前—— <tt>#t</tt> および <tt>#f</tt> という値にそれぞれ関連づけられている——を使おう。
</p>
<div class="extra">
<table class="expl">
<tr><th>言語</th><th>真</th><th>偽</th></tr>
<tr><th>Scheme</th><td><tt>#f</tt> 以外なんでも (<tt>#t</tt> とか 0 とか <tt>()</tt> とか 5 とか)</td><td><tt>#f</tt></td></tr>
<tr><th>Common Lisp</th><td><tt>nil</tt> 以外なんでも (<tt>t</tt> とか 0 とか 5 とか
)</td><td><tt>nil</tt> すなわち <tt>()</tt></td></tr>
<tr><th>C</th><td>0 (および、NULL など 0 と等しいもの) 以外なんでも</td><td>0</td></tr>
</table>

<p>Scheme だって Lisp なのに、Common Lisp とは空リストの扱いが違うとか、罠ですよ……。</p>
</div>

<p class="orig" lang="en"><a name="footnote_Temp_25" href="#call_footnote_Temp_25"><sup><small>18</small></sup></a> <tt>Abs</tt> also uses
<a name="%_idx_410"></a><a name="%_idx_412"></a>the ``minus'' operator <tt>-</tt>, which, when used with a single
operand, as in <tt>(- x)</tt>, indicates negation.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_25"><sup><small>18</small></sup></a>
<tt>abs</tt> では、<tt>-</tt> という「マイナス」演算子も使っており、これは、
<tt>(- x)</tt>
のように単一のオペランドとともに使われたときには、正負反転を示す。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_26" href="#call_footnote_Temp_26"><sup><small>19</small></sup></a> A minor difference
<a name="%_idx_440"></a><a name="%_idx_442"></a><a name="%_idx_444"></a>between <tt>if</tt> and <tt>cond</tt> is that the
&lt;<em>e</em>&gt; part of each <tt>cond</tt> clause may be a sequence of expressions.
If the corresponding &lt;<em>p</em>&gt; is found to be true, the expressions
&lt;<em>e</em>&gt; are evaluated in sequence and the value of the final
expression in the sequence is returned as the value of the <tt>cond</tt>.
In an <tt>if</tt> expression, however, the &lt;<em>consequent</em>&gt; and
&lt;<em>alternative</em>&gt; must be single expressions.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_26"><sup><small>19</small></sup></a>
<tt>if</tt> と <tt>cond</tt> の小さな違いは、各 <tt>cond</tt> 節の
&lt;<em class="en">e</em>&gt;
部分が、式の連なりであってもよい、という点である。
もし、対応する
&lt;<em class="en">p</em>&gt;
が真だと判明したら、それらの式である
&lt;<em class="en">e</em>&gt;
が、順番どおりに評価され、それらの式の連なりの中で最後の式の値が、<tt>cond</tt> の値として返される。
しかし、<tt>if</tt> 式では、
&lt;<em class="en">consequent</em>&gt;
と
&lt;<em class="en">alternative</em>&gt;
は、単一の式でなくてはならない。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_32" href="#call_footnote_Temp_32"><sup><small>20</small></sup></a> Declarative and
imperative descriptions are intimately related, as indeed are
mathematics and computer science.  For instance, to say that the
answer produced by a program is <a name="%_idx_500"></a>``correct'' is to make a declarative
statement about the program.  There is a large amount of research
aimed at establishing techniques for <a name="%_idx_502"></a>proving that programs are
correct, and much of the technical difficulty of this subject has to
do with negotiating the transition between imperative statements (from
which programs are constructed) and declarative statements (which can
be used to deduce things).  In a related vein, an important current
area in programming-language design is the exploration of so-called
<a name="%_idx_504"></a><a name="%_idx_506"></a>very high-level languages, in which one actually programs in terms of
declarative statements.  The idea is to make interpreters
sophisticated enough so that, given ``what is'' knowledge specified by
the programmer, they can generate ``how to'' knowledge automatically.
This cannot be done in general, but there are important areas where
progress has been made.  We shall revisit this idea in chapter&nbsp;4.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_32"><sup><small>20</small></sup></a>
宣言的な記述と命令的な記述は、密接に関連している——数学と計算機科学が確かに密接に関連しているのと同様に。
たとえば、プログラムにより生み出される答えが「正しい」と述べることは、そのプログラムについての宣言的な陳述をすることなのだ。
プログラムが正しいと証明するための技法を確立することを目的とした研究が大量にあり、この主題での技術的困難の大部分は、(プログラムを構成する元となっている) 命令的陳述から、(ものごとを演繹するのに使える) 宣言的陳述への転換を乗り越えることと関係がある。
関連した調子で、プログラミング言語の設計についての重要な最新の領域は、いわゆる非常に高水準な言語——宣言的な陳述の観点から実際にプログラムを書ける言語——の探究である。
ここで大事なことは、プログラマにより指定される、「何なのか」についての知識が与えられたときに、インタプリタが、「どうやって」についての知識を自動的に生成できるように、インタプリタを十分に洗練することである。
これは、一般にはできないのだが、進展があった重要な分野が存在する。
この考えについては、4章で再検討することになるだろう。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_33" href="#call_footnote_Temp_33"><sup><small>21</small></sup></a> This square-root algorithm is actually a special case
of Newton's method, which is a general technique for finding roots of
equations.  The square-root algorithm itself was developed by Heron of
<a name="%_idx_512"></a>Alexandria in the first century <font size=-2>A</font>.<font size=-2>D</font>.  We will see how to express
the general Newton's method as a Lisp procedure in
section&nbsp;<a href="12_sec1_3.html#%_sec_1.3.4">1.3.4</a>.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_33"><sup><small>21</small></sup></a>
この二乗根アルゴリズムは、実際、ニュートン法——方程式の解を見つけ出すための一般的技法——の特殊な場合である。
二乗根アルゴリズム自体は、アレクサンドリアのヘロンによって、紀元1世紀に開発された。
一般的なニュートン法をLisp手続きでどのように表すのか、<a href="12_sec1_3.html#%_sec_1.3.4">1.3.4</a>節で見ることにしよう。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_34" href="#call_footnote_Temp_34"><sup><small>22</small></sup></a> We will usually give
<a name="%_idx_518"></a><a name="%_idx_520"></a><a name="%_idx_522"></a><a name="%_idx_524"></a>predicates names ending with question marks, to help us
remember that they are predicates.  This
is just a stylistic convention.  As far as the interpreter is
concerned, the question mark is just an ordinary character.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_34"><sup><small>22</small></sup></a>
私たちは普通、述語には、疑問符で終わる名前を与えることにしよう——それが述語なのだと自分で思い出しやすくするために。
これは単に、文体上の慣習である。
インタプリタに関する限りは、疑問符は単に普通の文字にすぎない。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_35" href="#call_footnote_Temp_35"><sup><small>23</small></sup></a> Observe that we express our initial guess as 1.0 rather than
1.  This would not make any difference in many Lisp implementations.
<a name="%_idx_526"></a><a name="%_idx_528"></a><a name="%_idx_530"></a><a name="%_idx_532"></a><a name="%_idx_534"></a><a name="%_idx_536"></a><a name="%_idx_538"></a><a name="%_idx_540"></a><a name="%_idx_542"></a><a name="%_idx_544"></a><a name="%_idx_546"></a><a name="%_idx_548"></a>MIT Scheme, however, distinguishes between exact integers and decimal
values, and dividing two integers produces a rational number rather
than a decimal.  For example, dividing 10 by 6 yields 5/3, while
dividing 10.0 by 6.0 yields 1.6666666666666667.  (We will learn how to
implement arithmetic on rational numbers in
section&nbsp;<a href="14_sec2_1.html#%_sec_2.1.1">2.1.1</a>.)  If we start with an initial guess of 1
in our square-root program, and <em>x</em> is an exact integer, all
subsequent values produced in the square-root computation will be
rational numbers rather than decimals.  Mixed operations on rational
numbers and decimals always yield decimals, so starting with an
initial guess of 1.0 forces all subsequent values to be decimals.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_35"><sup><small>23</small></sup></a>
最初の見積もりを1でなくて1.0と表していることに気づいてほしい。
これは、多くのLisp実装では、何の違いも引き起こさないだろう。
しかし、MIT Schemeは、厳密な整数と小数値とを区別しており、二つの整数間での除算では、小数ではなく有理数を作り出す。
たとえば、10を6で割ると5/3となるが、10.0を6.0で割ると1.6666666666666667となる
(有理数上での算術をどう実装するかについては、<a href="14_sec2_1.html#%_sec_2.1.1">2.1.1</a>節で学ぼう)。
もし、私たちの二乗根プロクラムにおいて、1という最初の見積もりから始めて、しかも <em class="en">x</em> がぴったりまさに整数だとすると、二乗根の計算の間に生み出されるすべての後続の値は、小数ではなく有理数になるだろう。
有理数と小数に対する混合演算は、常に小数を生み出す——よって、1.0という最初の見積もりから始めることで、すべての後続の値は、強制的に小数となる。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_36" href="#call_footnote_Temp_36"><sup><small>24</small></sup></a> Readers who are worried about the efficiency
issues involved in using procedure calls to implement iteration should
note the remarks on ``tail recursion'' in
section&nbsp;<a href="11_sec1_2.html#%_sec_1.2.1">1.2.1</a>.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_36"><sup><small>24</small></sup></a>
反復を実装するために手続き呼び出しを使うことにともなう、効率性の論点を心配する読者は、<a href="11_sec1_2.html#%_sec_1.2.1">1.2.1</a>節の「末尾再帰」についての註記に注意するとよい。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_40" href="#call_footnote_Temp_40"><sup><small>25</small></sup></a> It is not even clear which of these procedures is a
more efficient implementation.  This depends upon the hardware
available.  There are machines for which the ``obvious''
implementation is the less efficient one.  Consider a machine that has
extensive tables of logarithms and antilogarithms stored in a very
efficient manner.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_40"><sup><small>25</small></sup></a>
これらの手続きのうちのどちらの方がより効率的な実装なのか、ということでさえ、明白ではない。
このことは、利用可能なハードウェアに依存する。
「自明な」実装の方が効率が低いようなマシンもある。
非常に効率的な方法で格納されている、広範囲にわたる対数と逆対数のテーブルを有するマシンを考えてみたまえ。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_42" href="#call_footnote_Temp_42"><sup><small>26</small></sup></a> The
concept of consistent renaming is actually subtle and difficult to
define formally.  Famous logicians have made embarrassing errors
here.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_42"><sup><small>26</small></sup></a>
首尾一貫した名前の付け替えという概念は、形式的に定義するには、実際には微妙で困難である。
有名な論理学者たちが、この問題で恥ずかしい間違いを犯してきたのだ。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_44" href="#call_footnote_Temp_44"><sup><small>27</small></sup></a> Lexical
scoping dictates that free variables in a procedure are taken to refer to
bindings made by enclosing procedure definitions;
that is, they are looked up in
<a name="%_idx_622"></a>the environment in which the procedure was defined.  We will see how
this works in detail in chapter&nbsp;3 when we study environments and the
detailed behavior of the interpreter.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_44"><sup><small>27</small></sup></a>
レキシカル・スコープは、手続き内の自由変数が、外側を囲っている手続き定義によって作られた束縛を参照するために使われることを指示するものである。つまり、手続き内の自由変数は、その手続きが定義された環境の中で調べられる。
これがどのようにしてうまく動くのかについては、3章で環境とインタプリタの詳しい振る舞いについて検討するときに、詳しく見ることにしよう。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_45" href="#call_footnote_Temp_45"><sup><small>28</small></sup></a> Embedded definitions
<a name="%_idx_626"></a>must come first in a procedure body.  The management is not responsible
for the consequences of running programs that intertwine definition
and use.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_45"><sup><small>28</small></sup></a>
埋め込まれた定義は、手続き本体の最初に来なくてはならない。
定義と使用を絡み合わせているようなプログラムの実行結果には、運営側は、責任を持たない。
</p>

</div>
</body>
</html>
