<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="sicp.css" type="text/css">
<base target="_top">
<title>SICPç§è¨³: 4.1 ãƒ¡ã‚¿å¾ªç’°çš„ãªè©•ä¾¡å™¨</title>
<link rel="canonical" href="https://piyo-ko.github.io/SICP/26_sec4_1.html" />
</head>
<body>

<div class="idx-bar">
<nav>
<span class="status">æ¨æ•²å¾…ã¡</span>
[
<a href="00_cover.html">å…ˆé ­ã¸</a> |
<a href="25_chap4.html">å‰ã¸</a> |
<a href="27_sec4_2.html">æ¬¡ã¸</a> |
<a href="04_toc.html#%_toc_start">ç›®æ¬¡</a> |
<a href="38_index.html#%_index_start">ç´¢å¼•</a>
] [<a href="99_about.html">ã“ã®å¯¾è¨³ç‰ˆã«ã¤ã„ã¦</a> | <a href="../index.html">ãƒ›ãƒ¼ãƒ </a>]
[
Â§<a href="#%_sec_4.1">4.1</a>
Â§<a href="#%_sec_4.1.1">4.1.1</a>
ğŸ¨<a href="#%_fig_4.1">4.1</a>
ğŸ“š<a href="#%_sec_Temp_512">&hellip;</a>
ğŸ€<a href="#%_sec_Temp_513">&hellip;</a>
ğŸ€<a href="#%_sec_Temp_514">&hellip;</a>
ğŸ€<a href="#%_sec_Temp_515">&hellip;</a>
ğŸ“š<a href="#%_sec_Temp_516">&hellip;</a>
ğŸ“š<a href="#%_sec_Temp_517">&hellip;</a>
ğŸ“š<a href="#%_sec_Temp_519">&hellip;</a>
ğŸ“š<a href="#%_sec_Temp_521">&hellip;</a>
ğŸ“š<a href="#%_sec_Temp_522">&hellip;</a>
ğŸ“<a href="#%_thm_4.1">4.1</a>
Â§<a href="#%_sec_4.1.2">4.1.2</a>
ğŸ“š<a href="#%_sec_Temp_529">&hellip;</a>
ğŸ“<a href="#%_thm_4.2">4.2</a>
ğŸ“<a href="#%_thm_4.3">4.3</a>
ğŸ“<a href="#%_thm_4.4">4.4</a>
ğŸ“<a href="#%_thm_4.5">4.5</a>
ğŸ“<a href="#%_thm_4.6">4.6</a>
ğŸ“<a href="#%_thm_4.7">4.7</a>
ğŸ“<a href="#%_thm_4.8">4.8</a>
ğŸ“<a href="#%_thm_4.9">4.9</a>
ğŸ“<a href="#%_thm_4.10">4.10</a>
Â§<a href="#%_sec_4.1.3">4.1.3</a>
ğŸ“š<a href="#%_sec_Temp_541">&hellip;</a>
ğŸ“š<a href="#%_sec_Temp_542">&hellip;</a>
ğŸ“š<a href="#%_sec_Temp_543">&hellip;</a>
ğŸ“<a href="#%_thm_4.11">4.11</a>
ğŸ“<a href="#%_thm_4.12">4.12</a>
ğŸ“<a href="#%_thm_4.13">4.13</a>
Â§<a href="#%_sec_4.1.4">4.1.4</a>
ğŸ“<a href="#%_thm_4.14">4.14</a>
Â§<a href="#%_sec_4.1.5">4.1.5</a>
ğŸ¨<a href="#%_fig_4.2">4.2</a>
ğŸ¨<a href="#%_fig_4.3">4.3</a>
ğŸ“<a href="#%_thm_4.15">4.15</a>
Â§<a href="#%_sec_4.1.6">4.1.6</a>
ğŸ“<a href="#%_thm_4.16">4.16</a>
ğŸ“<a href="#%_thm_4.17">4.17</a>
ğŸ“<a href="#%_thm_4.18">4.18</a>
ğŸ“<a href="#%_thm_4.19">4.19</a>
ğŸ“<a href="#%_thm_4.20">4.20</a>
ğŸ“<a href="#%_thm_4.21">4.21</a>
Â§<a href="#%_sec_4.1.7">4.1.7</a>
ğŸ“<a href="#%_thm_4.22">4.22</a>
ğŸ“<a href="#%_thm_4.23">4.23</a>
ğŸ“<a href="#%_thm_4.24">4.24</a>
<a href="#footnotes">è„šæ³¨</a>
]
</nav>

</div>

<!--
$ curl -o ch4-Z-G-#1.gif https://mitpress.mit.edu/sicp/full-text/book/ch4-Z-G-[1-10].gif
-->

<div class="main-txt">

<a name="%_sec_4.1"></a>
<h2 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_4.1">4.1  The Metacircular Evaluator</a></h2>
<h2 class="trans" lang="ja">4.1 ãƒ¡ã‚¿å¾ªç’°çš„ãªè©•ä¾¡å™¨</h2>


<a name="%_idx_4210"></a>
<p class="orig" lang="en">
Our evaluator for Lisp will be implemented as a Lisp program.  It may
seem circular to think about evaluating Lisp programs using an
evaluator that is itself implemented in Lisp.  However, evaluation is
a process, so it is appropriate to describe the evaluation process
using Lisp, which, after all, is our tool for describing
processes.<a name="call_footnote_Temp_510" href="#footnote_Temp_510"><sup><small>3</small></sup></a>  An evaluator that is written in the same language
<a name="%_idx_4212"></a><a name="%_idx_4214"></a>that it evaluates is said to be <em>metacircular</em>.</p>

<p class="trans" lang="ja">
Lispã«å¯¾ã™ã‚‹ç§ãŸã¡ã®è©•ä¾¡å™¨ã¯ã€Lispãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¨ã—ã¦å®Ÿè£…ã•ã‚Œã‚‹ã ã‚ã†ã€‚
ãã‚Œè‡ªä½“ãŒLispã§å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹è©•ä¾¡å™¨ã‚’ä½¿ã£ã¦Lispãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’è©•ä¾¡ã™ã‚‹ã€ã¨ã„ã†ã“ã¨ã«ã¤ã„ã¦è€ƒãˆã‚‹ã“ã¨ã¯ã€å¾ªç’°çš„ãªã‚ˆã†ã«è¦‹ãˆã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚
ã—ã‹ã—ã€è©•ä¾¡ã¯ãƒ—ãƒ­ã‚»ã‚¹ã§ã‚ã‚Šã€ã—ãŸãŒã£ã¦ã€Lispã‚’ä½¿ã£ã¦è©•ä¾¡ãƒ—ãƒ­ã‚»ã‚¹ã‚’è¨˜è¿°ã™ã‚‹ã“ã¨ã¯é©åˆ‡ãªã®ã§ã‚ã‚‹â€”â€”Lispã¯ã€çµå±€ã®ã¨ã“ã‚ã€ãƒ—ãƒ­ã‚»ã‚¹ã‚’è¨˜è¿°ã™ã‚‹ãŸã‚ã®é“å…·ãªã®ã <a href="#footnote_Temp_510"><sup><small>3</small></sup></a>ã€‚
è©•ä¾¡ã™ã‚‹å¯¾è±¡ã¨åŒã˜è¨€èªã§æ›¸ã‹ã‚Œã¦ã„ã‚‹è©•ä¾¡å™¨ã¯ã€<em>ãƒ¡ã‚¿å¾ªç’°çš„</em>ã¨è¨€ã‚ã‚Œã‚‹ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_4216"></a><a name="%_idx_4218"></a>The metacircular evaluator is essentially a Scheme formulation of the
environment model of evaluation described in
section <a href="21_sec3_2.html#%_sec_3.2">3.2</a>.  Recall that the model has two
basic parts:</p>

<p class="trans" lang="ja">
ãƒ¡ã‚¿å¾ªç’°çš„ãªè©•ä¾¡å™¨ã¯ã€æœ¬è³ªçš„ã«ã€<a href="21_sec3_2.html#%_sec_3.2">3.2</a>ç¯€ã§èª¬æ˜ã—ãŸã€è©•ä¾¡ã«ã¤ã„ã¦ã®ç’°å¢ƒãƒ¢ãƒ‡ãƒ«ã®Schemeå®šå¼åŒ–ã§ã‚ã‚‹ã€‚
ã‚ã®ãƒ¢ãƒ‡ãƒ«ã«ã¯äºŒã¤ã®åŸºæœ¬çš„éƒ¨åˆ†ãŒã‚ã‚‹ã“ã¨ã‚’æ€ã„å‡ºãã†ã€‚
</p>

<ol class="orig" lang="en">
<li> To evaluate a combination (a compound expression other than a 
special form), evaluate the subexpressions and then apply the value of
the operator subexpression to the values of the operand
subexpressions.</li>

<li>To apply a compound procedure to a set of arguments, evaluate the
body of the procedure in a new environment.  To construct this
environment, extend the environment part of the procedure object by a
frame in which the formal parameters of the procedure are bound to the
arguments to which the procedure is applied.
</li>
</ol>


<ol class="trans" lang="ja">
<li>ã‚³ãƒ³ãƒ“ãƒãƒ¼ã‚·ãƒ§ãƒ³ (ç‰¹æ®Šå½¢å¼ä»¥å¤–ã®è¤‡åˆçš„ãªå¼) ã‚’è©•ä¾¡ã™ã‚‹ã«ã¯ã€éƒ¨åˆ†å¼ã‚’è©•ä¾¡ã—ã€ãã‚Œã‹ã‚‰ã€ã‚ªãƒšãƒ¬ãƒ¼ã‚¿éƒ¨åˆ†å¼ã®å€¤ã‚’ã€ã‚ªãƒšãƒ©ãƒ³ãƒ‰éƒ¨åˆ†å¼ã®å€¤ã«é©ç”¨ã›ã‚ˆã€‚</li>
<li>è¤‡åˆçš„ãªæ‰‹ç¶šãã‚’ã€ä¸€æƒã„ã®å¼•æ•°ã«é©ç”¨ã™ã‚‹ã«ã¯ã€æ‰‹ç¶šãã®æœ¬ä½“ã‚’æ–°ãŸãªç’°å¢ƒå†…ã§è©•ä¾¡ã›ã‚ˆã€‚ã“ã®ç’°å¢ƒã‚’æ§‹ç¯‰ã™ã‚‹ã«ã¯ã€æ‰‹ç¶šãã®é©ç”¨å…ˆã®å®Ÿå¼•æ•°ã«æ‰‹ç¶šãã®ä»®å¼•æ•°ãŒæŸç¸›ã•ã‚Œã¦ã„ã‚‹ã‚ˆã†ãªãƒ•ãƒ¬ãƒ¼ãƒ ã®ã¶ã‚“ã ã‘ã€æ‰‹ç¶šãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç’°å¢ƒéƒ¨åˆ†ã‚’æ‹¡å¼µã›ã‚ˆã€‚</li>
</ol>

<p class="orig" lang="en">
<a name="%_idx_4220"></a>These two rules describe the essence of the evaluation process, a
basic cycle in which expressions to be evaluated in environments are
reduced to procedures to be applied to arguments, which in turn are
reduced to new expressions to be evaluated in new environments, and so
on, until we get down to symbols, whose values are looked
up in the environment, and to primitive procedures, which are applied
directly (see figure <a href="#%_fig_4.1">4.1</a>).<a name="call_footnote_Temp_511" href="#footnote_Temp_511"><sup><small>4</small></sup></a>
This evaluation cycle will be embodied by the interplay between the two
critical procedures in the evaluator, <tt>eval</tt> and <tt>apply</tt>,
which are described in section <a href="#%_sec_4.1.1">4.1.1</a>
(see figure <a href="#%_fig_4.1">4.1</a>).</p>

<p class="trans" lang="ja">
ã“ã‚Œã‚‰äºŒã¤ã®è¦å‰‡ã¯ã€è©•ä¾¡ãƒ—ãƒ­ã‚»ã‚¹ã®æœ¬è³ªã‚’ã€èª¬æ˜ã—ã¦ã„ã‚‹ã€‚ã™ãªã‚ã¡ã€ç’°å¢ƒå†…ã§è©•ä¾¡ã•ã‚Œã‚‹ã¹ãå¼ã‚’ã€å®Ÿå¼•æ•°ã«é©ç”¨ã•ã‚Œã‚‹ã¹ãæ‰‹ç¶šãã¸ã¨é‚„å…ƒã—ã€ä»Šåº¦ã¯ãã®æ‰‹ç¶šãã‚’ã€æ–°ãŸãªç’°å¢ƒã§è©•ä¾¡ã•ã‚Œã‚‹ã¹ãæ–°ãŸãªå¼ã¸ã¨é‚„å…ƒã—ã€<!--ã¨ã„ã†ãµã†ã«ã—ã¦-->ä»¥ä¸‹åŒæ§˜ã«ã—ã¦ã€è¨˜å·â€”â€”ç’°å¢ƒå†…ã§å€¤ã‚’èª¿ã¹ã‚‰ã‚Œã‚‹ã‚‚ã®â€”â€”ã¨åŸå§‹çš„æ‰‹ç¶šãâ€”â€”ç›´æ¥çš„ã«é©ç”¨ã•ã‚Œã‚‹ã‚‚ã®â€”â€”ã®ã¨ã“ã‚ã¸é™ã‚Šã¦ãŸã©ã‚Šç€ãã¾ã§ç¶šã‘ã‚‹ã€ã¨ã„ã†åŸºæœ¬çš„ãªå¾ªç’°ã‚’ã€èª¬æ˜ã—ã¦ã„ã‚‹ã®ã  (å›³<a href="#%_fig_4.1">4.1</a>ã‚’å‚ç…§)<a href="#footnote_Temp_511"><sup><small>4</small></sup></a>ã€‚
ã“ã®è©•ä¾¡ã®å¾ªç’°ã¯ã€è©•ä¾¡å™¨ã«ãŠã‘ã‚‹äºŒã¤ã®é‡è¦ãªæ‰‹ç¶šãâ€”â€”ã™ãªã‚ã¡ <tt>eval</tt> ã¨<tt>apply</tt> ã§ã‚ã‚Šã€<a href="#%_sec_4.1.1">4.1.1</a>ç¯€ã§ã“ã‚Œã‚‰ã‚’èª¬æ˜ã™ã‚‹â€”â€”ã®é–“ã®ç›¸äº’ä½œç”¨ã«ã‚ˆã£ã¦ã€å®Ÿä½“åŒ–ã•ã‚Œã‚‹ã ã‚ã† (å›³<a href="#%_fig_4.1">4.1</a>ã‚’å‚ç…§)ã€‚
</p>

<p class="orig" lang="en">
The implementation of the evaluator will depend upon procedures that
define the <em>syntax</em> of the expressions to be evaluated.  We will
use <a name="%_idx_4224"></a>data abstraction to make the evaluator independent of the
representation of the language.  For example, rather than committing
to a choice that an assignment is to be represented by a list
beginning with the symbol <tt>set!</tt> we use an abstract predicate
<tt>assignment?</tt> to test for an assignment, and we use abstract
selectors <tt>assignment-variable</tt> and <tt>assignment-value</tt> to
access the parts of an assignment.  Implementation of expressions will
be described in detail in section <a href="#%_sec_4.1.2">4.1.2</a>.
There are also operations, described in
section <a href="#%_sec_4.1.3">4.1.3</a>, that specify the
representation of procedures and environments.  For example, <tt>make-procedure</tt> constructs compound procedures, <tt>lookup-variable-value</tt> accesses the values of variables, and <tt>apply-primitive-procedure</tt> applies a primitive procedure to a given list
of arguments.</p>

<p class="trans" lang="ja">
è©•ä¾¡å™¨ã®å®Ÿè£…ã¯ã€è©•ä¾¡ã•ã‚Œã‚‹ã¹ãå¼ã®<em><ruby><rb>æ§‹æ–‡</rb><rp> (</rp><rt>ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹</rt><rp>) </rp></ruby></em>ã‚’å®šç¾©ã™ã‚‹æ‰‹ç¶šãã«ä¾å­˜ã™ã‚‹ã ã‚ã†ã€‚
ç§ãŸã¡ã¯ã€è©•ä¾¡å™¨ã‚’è¨€èªã®è¡¨ç¾ã¨ã¯ç‹¬ç«‹ã—ãŸã‚‚ã®ã¨ã™ã‚‹ãŸã‚ã«ã€ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ã‚’ä½¿ãŠã†ã€‚
ãŸã¨ãˆã°ã€<tt>set!</tt> ã¨ã„ã†è¨˜å·ã§å§‹ã¾ã‚‹ãƒªã‚¹ãƒˆã«ã‚ˆã£ã¦<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ãŒè¡¨ç¾ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€ã¨ã„ã†é¸æŠè‚¢ã«å…¥ã‚Œè¾¼ã‚€ã‚ˆã‚Šã‚‚ã‚€ã—ã‚ã€ç§ãŸã¡ã¯ã€<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã«ã¤ã„ã¦èª¿ã¹ã‚‹ãŸã‚ã® <tt>assignment?</tt> ã¨ã„ã†æŠ½è±¡çš„è¿°èªã‚’ä½¿ã„ã€ãã—ã¦ã€<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã®éƒ¨åˆ†éƒ¨åˆ†ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãŸã‚ã® <tt>assignment-variable</tt> ãŠã‚ˆã³ <tt>assignment-value</tt> ã¨ã„ã†æŠ½è±¡çš„ã‚»ãƒ¬ã‚¯ã‚¿ã‚’ä½¿ã†ã€‚
å¼ã®å®Ÿè£…ã¯ã€<a href="#%_sec_4.1.2">4.1.2</a>ç¯€ã§è©³ã—ãèª¬æ˜ã—ã‚ˆã†ã€‚
æ‰‹ç¶šãã¨ç’°å¢ƒã‚’æŒ‡å®šã™ã‚‹æ¼”ç®—â€”â€”<a href="#%_sec_4.1.3">4.1.3</a>ç¯€ã§èª¬æ˜ã™ã‚‹â€”â€”ã‚‚ã€å­˜åœ¨ã™ã‚‹ã€‚
ãŸã¨ãˆã°ã€<tt>make-procedure</tt> ã¯è¤‡åˆçš„æ‰‹ç¶šãã‚’æ§‹ç¯‰ã—ã€<tt>lookup-variable-value</tt> ã¯å¤‰æ•°ã®å€¤ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã€<tt>apply-primitive-procedure</tt> ã¯ä¸ãˆã‚‰ã‚ŒãŸå¼•æ•°ã®ãƒªã‚¹ãƒˆã«åŸå§‹çš„æ‰‹ç¶šãã‚’é©ç”¨ã™ã‚‹ã€‚
</p>

<a name="%_sec_4.1.1"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_4.1.1">4.1.1  The Core of the Evaluator</a></h3>
<h3 class="trans" lang="ja">4.1.1 è©•ä¾¡å™¨ã®æ ¸</h3>


<a name="%_idx_4226"></a>
<a name="%_fig_4.1"></a>
<figure>
<img src="ch4-Z-G-1.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 4.1:</b>  The <tt>eval</tt>-<tt>apply</tt> cycle exposes the essence
of a computer language.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³4.1:</b> <tt>eval</tt>-<tt>apply</tt> ã®å¾ªç’°ãŒã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿è¨€èªã®æœ¬è³ªã‚’<ruby><rb>éœ²</rb><rp> (</rp><rt>ã‚ã‚‰</rt><rp>) </rp></ruby>ã‚ã«ã™ã‚‹ã€‚</figcaption>
<a name="%_idx_4228"></a>
</figure>


<p class="orig" lang="en">
The evaluation process can be described as the interplay between two
procedures: <tt>eval</tt> and <tt>apply</tt>.</p>

<p class="trans" lang="ja">
è©•ä¾¡ãƒ—ãƒ­ã‚»ã‚¹ã¯ã€äºŒã¤ã®æ‰‹ç¶šãâ€”â€”ã™ãªã‚ã¡ <tt>eval</tt> ã¨ <tt>apply</tt> â€”â€”ã®é–“ã®ç›¸äº’ä½œç”¨ã¨ã—ã¦ã€è¨˜è¿°ã™ã‚‹ã“ã¨ãŒå¯èƒ½ã§ã‚ã‚‹ã€‚
</p>


<a name="%_sec_Temp_512"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_512">Eval</a></h4>
<h4 class="trans" lang="ja">eval</h4>

<p class="orig" lang="en">
<a name="%_idx_4230"></a><tt>Eval</tt> takes as arguments an expression and an environment.  It
classifies the expression and directs its evaluation.  <tt>Eval</tt> is
structured as a case analysis of the syntactic type of the expression
to be evaluated.  In order to keep the procedure general, we express
the determination of the type of an expression abstractly, making no
commitment to any particular <a name="%_idx_4232"></a>representation for the various types of
expressions.  Each type of expression has a predicate that tests for
it and an abstract means for selecting its parts.  This <a name="%_idx_4234"></a><a name="%_idx_4236"></a><em>abstract
syntax</em> makes it easy to see how we can change the syntax of the
language by using the same evaluator, but with a different collection of
syntax procedures.</p>

<p class="trans" lang="ja">
<tt>eval</tt> ã¯ã€å¼•æ•°ã¨ã—ã¦å¼ã¨ç’°å¢ƒã‚’ã¨ã‚‹ã€‚
<tt>eval</tt> ã¯ã€ãã®å¼ã‚’åˆ†é¡ã—ã¦ã€ãã®å¼ã®è©•ä¾¡ã‚’æŒ‡æ®ã™ã‚‹ã€‚
<tt>eval</tt> ã¯ã€è©•ä¾¡ã™ã¹ãå¼ã®æ–‡æ³•ä¸Šã®ç¨®é¡ã«ã¤ã„ã¦ã®å ´åˆåˆ†ã‘åˆ†æã¨ã—ã¦ã€æ§‹é€ åŒ–ã•ã‚Œã‚‹ã€‚
ã“ã®æ‰‹ç¶šãã‚’ä¸€èˆ¬çš„ãªã¾ã¾ã«ä¿ã¤ãŸã‚ã«ã€ç§ãŸã¡ã¯ã€æ§˜ã€…ãªç¨®é¡ã®å¼ã®ã€ã„ã‹ãªã‚‹ç‰¹å®šã®è¡¨ç¾ã«ã‚‚é–¢ä¸ã›ãšã«ã€å¼ã®ç¨®é¡ã®æ±ºå®šã‚’æŠ½è±¡çš„ã«è¡¨ç¾ã™ã‚‹ã€‚
ãã‚Œãã‚Œã®ç¨®é¡ã®å¼ã«ã¯ã€ãã®ç¨®é¡ã®å¼ã‹ã©ã†ã‹ã‚’æ¤œæŸ»ã™ã‚‹ãŸã‚ã®è¿°èªã¨ã€ãã®ç¨®é¡ã®å¼ã®ã†ã¡ã®ä¸€éƒ¨ã‚’é¸æŠã™ã‚‹ãŸã‚ã®æŠ½è±¡çš„æ‰‹æ®µãŒã‚ã‚‹ã€‚
ã“ã®<em>æŠ½è±¡çš„æ–‡æ³•</em>ã«ã‚ˆã‚Šã€ã©ã†ã™ã‚Œã°åŒã˜è©•ä¾¡å™¨â€”â€”ãŸã ã—ã€æ–‡æ³•æ‰‹ç¶šãã®åˆ¥ã®é›†ã¾ã‚Šã‚’ä¼´ã†ã‚‚ã®â€”â€”ã‚’ä½¿ã£ã¦è¨€èªã®æ–‡æ³•ã‚’å¤‰ãˆã‚‰ã‚Œã‚‹ã®ã‹ã‚’ç†è§£ã™ã‚‹ã“ã¨ãŒã€ç°¡å˜ã«ãªã‚‹ã€‚
</p>


<a name="%_sec_Temp_513"></a>
<h5 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_513">Primitive expressions</a></h5>
<h5 class="trans" lang="ja">åŸå§‹çš„ãªå¼</h5>

<ul class="orig" lang="en">
<li><a name="%_idx_4238"></a><a name="%_idx_4240"></a>For self-evaluating expressions, such as numbers, <tt>eval</tt> returns
the expression itself.</li>

<li><tt>Eval</tt> must look up variables in the environment to find their values.</li>
</ul>

<ul class="trans" lang="ja">
<li>æ•°ãªã©ã®è‡ªå·±è©•ä¾¡çš„ãªå¼ã«ã¤ã„ã¦ã¯ã€<tt>eval</tt> ã¯ã€ãã®å¼è‡ªä½“ã‚’è¿”ã™ã€‚</li>
<li><tt>eval</tt> ã¯ã€å¤‰æ•°ã®å€¤ã‚’è¦‹ã¤ã‘ã‚‹ãŸã‚ã«ã€ç’°å¢ƒå†…ã§å¤‰æ•°ã‚’èª¿ã¹ãªãã¦ã¯ãªã‚‰ãªã„ã€‚</li>
</ul>

<a name="%_sec_Temp_514"></a>
<h5 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_514">Special forms</a></h5>
<h5 class="trans" lang="ja">ç‰¹æ®Šå½¢å¼</h5>


<ul class="orig" lang="en">
<li>For quoted expressions, <tt>eval</tt> returns the expression that was
quoted.</li>

<li>An assignment to (or a definition of) a variable must recursively call
<tt>eval</tt> to compute the new value to be associated with the
variable.  The environment must be modified to change (or create) the
binding of the variable.</li>

<li>An <tt>if</tt> expression requires special processing of its parts, so as to
evaluate the consequent if the predicate is true, and otherwise to
evaluate the alternative.</li>

<li>A <tt>lambda</tt> expression must be transformed into an
applicable procedure by packaging together the parameters and body
specified by the <tt>lambda</tt> expression with the environment of the
evaluation.</li>

<li>A <tt>begin</tt> expression requires evaluating its sequence of
expressions in the order in which they appear.</li>

<li>A case analysis (<tt>cond</tt>) is transformed into a nest of <tt>if</tt>
expressions and then evaluated.</li>
</ul>

<ul class="trans" lang="ja">
<li>å¼•ç”¨ã•ã‚ŒãŸå¼ã«ã¤ã„ã¦ã¯ã€<tt>eval</tt> ã¯ã€å¼•ç”¨ã•ã‚ŒãŸå¼ã‚’è¿”ã™ã€‚</li>
<li>å¤‰æ•°ã¸ã®<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby> (ã¾ãŸã¯å¤‰æ•°ã®å®šç¾©) ã¯ã€ãã®å¤‰æ•°ã«é–¢é€£ã¥ã‘ã‚‰ã‚Œã‚‹ã¹ãæ–°ãŸãªå€¤ã‚’è¨ˆç®—ã™ã‚‹ãŸã‚ã«ã€å†å¸°çš„ã« <tt>eval</tt> ã‚’å‘¼ã°ãªãã¦ã¯ãªã‚‰ãªã„ã€‚
ç’°å¢ƒã¯ã€ãã®å¤‰æ•°ã®æŸç¸›ã‚’å¤‰æ›´ã™ã‚‹ (ã¾ãŸã¯ä½œæˆã™ã‚‹) ã‚ˆã†ã«ä¿®æ­£ã•ã‚Œã­ã°ãªã‚‰ãªã„ã€‚</li>
<li><tt>if</tt> å¼ã¯ã€<tt>if</tt> å¼ã®ä¸€éƒ¨ã«ã¤ã„ã¦ç‰¹æ®Šãªå‡¦ç†ã‚’ã™ã‚‹â€”â€”ã‚‚ã—è¿°èªãŒçœŸãªã‚‰å¸°çµå¼ã‚’è©•ä¾¡ã—ã€ãã‚Œä»¥å¤–ã®å ´åˆã¯ä»£æ›¿å¼ã‚’è©•ä¾¡ã™ã‚‹ã‚ˆã†ã«ã™ã‚‹â€”â€”ã“ã¨ã‚’è¦ã™ã‚‹ã€‚</li>
<li><tt>lambda</tt> å¼ã¯ã€<tt>lambda</tt> å¼ã«ã‚ˆã‚ŠæŒ‡å®šã•ã‚Œã‚‹ä»®å¼•æ•°ã¨æœ¬ä½“ã‚’ã€è©•ä¾¡ã®ç’°å¢ƒã¨ä¸€ç·’ã«ä¸€åŒ…ã¿ã«ã™ã‚‹ã“ã¨ã§ã€é©ç”¨å¯èƒ½ãªæ‰‹ç¶šãã¸ã¨å¤‰å½¢ã•ã‚Œã­ã°ãªã‚‰ãªã„ã€‚</li>
<li><tt>begin</tt> å¼ã¯ã€<tt>begin</tt> å¼ã®ä¸€é€£ã®å¼ã‚’ã€ãã‚Œã‚‰ã®å¼ãŒç¾ã‚Œã‚‹é †ã«è©•ä¾¡ã™ã‚‹ã“ã¨ã‚’è¦ã™ã‚‹ã€‚</li>
<li>å ´åˆåˆ†ã‘åˆ†æ (<tt>cond</tt>) ã¯ã€<tt>if</tt> å¼ã®å…¥ã‚Œå­ã¸ã¨å¤‰å½¢ã•ã‚Œã€ãã‚Œã‹ã‚‰è©•ä¾¡ã•ã‚Œã‚‹ã€‚</li>
</ul>


<a name="%_sec_Temp_515"></a>
<h5 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_515">Combinations</a></h5>
<h5 class="trans" lang="ja">ã‚³ãƒ³ãƒ“ãƒãƒ¼ã‚·ãƒ§ãƒ³</h5>

<ul class="orig" lang="en">
<li>For a procedure application, <tt>eval</tt> must recursively
evaluate the operator part and the operands of the combination.  The
resulting procedure and arguments are passed to <tt>apply</tt>, which
handles the actual procedure application.</li>
</ul>

<ul class="trans" lang="ja">
<li>æ‰‹ç¶šãé©ç”¨ã«ã¤ã„ã¦ã€<tt>eval</tt> ã¯ã€ã‚³ãƒ³ãƒ“ãƒãƒ¼ã‚·ãƒ§ãƒ³ã®æ¼”ç®—å­éƒ¨åˆ†ã¨ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã¨ã‚’ã€å†å¸°çš„ã«è©•ä¾¡ã›ã­ã°ãªã‚‰ãªã„ã€‚
çµæœã¨ã—ã¦ç”Ÿã˜ã‚‹æ‰‹ç¶šãã¨å®Ÿå¼•æ•°ãŒ <tt>apply</tt> ã«æ¸¡ã•ã‚Œã€<tt>apply</tt> ãŒå®Ÿéš›ã®æ‰‹ç¶šãé©ç”¨ã‚’å–ã‚Šæ‰±ã†ã€‚</li>
</ul>

<p class="orig" lang="en">
<a name="%_idx_4242"></a>Here is the definition of <tt>eval</tt>:</p>

<p class="trans" lang="ja">
ã“ã“ã« <tt>eval</tt> ã®å®šç¾©ã‚’ç¤ºã™ã€‚
</p>

<p class="lisp">(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp) 
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond-&gt;if exp) env))
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error &quot;Unknown expression type -- EVAL&quot; exp))))
</p>


<p class="orig" lang="en">
<a name="%_idx_4244"></a><a name="%_idx_4246"></a>For clarity, <tt>eval</tt> has been implemented as a case analysis using
<tt>cond</tt>.  The disadvantage of this is that our procedure handles
only a few distinguishable types of expressions, and no new ones can
be defined without editing the definition of <tt>eval</tt>.  In most Lisp
implementations, dispatching on the type of an expression is done in a
data-directed style.  This allows a user to add new types of
expressions that <tt>eval</tt> can distinguish, without modifying the
definition of <tt>eval</tt> itself.
(See exercise <a href="#%_thm_4.3">4.3</a>.)</p>

<p class="trans" lang="ja">
æ˜ç¢ºã•ã®ãŸã‚ã«ã€<tt>eval</tt> ã¯ã€<tt>cond</tt> ã‚’ç”¨ã„ãŸå ´åˆåˆ†ã‘åˆ†æã¨ã—ã¦å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ã€‚
ã“ã®ã“ã¨ã®æ¬ ç‚¹ã¯ã€ç§ãŸã¡ã®æ‰‹ç¶šããŒå°‘æ•°ã®åŒºåˆ¥å¯èƒ½ãªç¨®é¡ã®å¼ã®ã¿ã—ã‹æ‰±ã‚ãšã€<tt>eval</tt> ã®å®šç¾©ã‚’ç·¨é›†ã—ãªã„ã“ã¨ã«ã¯æ–°ãŸãªç¨®é¡ã®å¼ã‚’ä½•ã‚‚å®šç¾©ã§ããªã„ã€ã¨ã„ã†ç‚¹ã§ã‚ã‚‹ã€‚
ã»ã¨ã‚“ã©ã®Lispå‡¦ç†ç³»ã«ãŠã„ã¦ã€å¼ã®ç¨®é¡ã«ã‚ˆã‚‹<ruby><rb>æŒ¯ã‚Šåˆ†ã‘</rb><rp> (</rp><rt>ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒ</rt><rp>) </rp></ruby>ã¯ã€ãƒ‡ãƒ¼ã‚¿æŒ‡å‘çš„ãªæµå„€ã§è¡Œã‚ã‚Œã‚‹ã€‚
ã“ã‚Œã«ã‚ˆã£ã¦ãƒ¦ãƒ¼ã‚¶ã¯ã€<tt>eval</tt> ãŒåŒºåˆ¥ã§ãã‚‹æ–°ãŸãªç¨®é¡ã®å¼ã‚’ã€<tt>eval</tt> è‡ªä½“ã®å®šç¾©ã‚’ä¿®æ­£ã›ãšã«ã€è¿½åŠ ã§ãã‚‹ã‚ˆã†ã«ãªã‚‹ (ç·´ç¿’å•é¡Œ<a href="#%_thm_4.3">4.3</a>ã‚’å‚ç…§)ã€‚
</p>


<a name="%_sec_Temp_516"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_516">Apply</a></h4>
<h4 class="trans" lang="ja">apply</h4>


<p class="orig" lang="en">
<tt>Apply</tt> takes two arguments, a procedure and a list of arguments
to which the procedure should be applied.  <tt>Apply</tt> classifies
procedures into two kinds: It calls <a name="%_idx_4248"></a><tt>apply-primitive-procedure</tt> to apply primitives; it applies compound
procedures by sequentially evaluating the expressions that
make up the body of the procedure.  The environment for the
evaluation of the body of a compound procedure
is constructed by extending the base environment carried by
the procedure to include a frame that binds the parameters of the
procedure to the arguments to which the procedure is to be applied.
Here is the definition of <tt>apply</tt>:</p>

<p class="trans" lang="ja">
<tt>apply</tt> ã¯äºŒã¤ã®å®Ÿå¼•æ•°ã‚’ã¨ã‚‹â€”â€”ã¤ã¾ã‚Šã€æ‰‹ç¶šãã¨ã€ãã®æ‰‹ç¶šããŒé©ç”¨ã•ã‚Œã‚‹ã¹ãå®Ÿå¼•æ•°ã®ãƒªã‚¹ãƒˆã§ã‚ã‚‹ã€‚
<tt>apply</tt> ã¯æ‰‹ç¶šãã‚’äºŒç¨®é¡ã«åˆ†é¡ã™ã‚‹ã€‚
ã¤ã¾ã‚Šã€<tt>apply</tt> ã¯ã€ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã‚’é©ç”¨ã™ã‚‹ãŸã‚ã«ã¯ <tt>apply-primitive-procedure</tt> ã‚’å‘¼ã³å‡ºã™ã€‚
ãã®ä¸€æ–¹ã§ã€<tt>apply</tt> ã¯ã€è¤‡åˆçš„ãªæ‰‹ç¶šãã®æœ¬ä½“ã‚’æ§‹æˆã™ã‚‹å¼ã‚’é †ã«è©•ä¾¡ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€è¤‡åˆçš„ãªæ‰‹ç¶šãã‚’é©ç”¨ã™ã‚‹ã®ã§ã‚ã‚‹ã€‚
è¤‡åˆçš„ãªæ‰‹ç¶šãã®æœ¬ä½“ã®è©•ä¾¡ã®ãŸã‚ã®ç’°å¢ƒã¯ã€ãã®æ‰‹ç¶šããŒé©ç”¨ã•ã‚Œã‚‹ã¹ãå®Ÿå¼•æ•°ã«ãã®æ‰‹ç¶šãã®ä»®å¼•æ•°ã‚’æŸç¸›ã™ã‚‹ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’å«ã‚€ã‚ˆã†ã«ã€ãã®æ‰‹ç¶šãã«ã‚ˆã£ã¦æŒã¡é‹ã°ã‚Œã‚‹åŸºç¤ç’°å¢ƒã‚’æ‹¡å¼µã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€æ§‹ç¯‰ã•ã‚Œã‚‹ã€‚
ã“ã“ã«ã€<tt>apply</tt> ã®å®šç¾©ã‚’ç¤ºã™ã€‚
</p>

<p class="lisp"><a name="%_idx_4250"></a>(define (apply procedure arguments)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure)
         (eval-sequence
           (procedure-body procedure)
           (extend-environment
             (procedure-parameters procedure)
             arguments
             (procedure-environment procedure))))
        (else
         (error
          &quot;Unknown procedure type -- APPLY&quot; procedure))))
</p>


<a name="%_sec_Temp_517"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_517">Procedure arguments</a></h4>
<h4 class="trans" lang="ja">æ‰‹ç¶šãã®å®Ÿå¼•æ•°</h4>

<p class="orig" lang="en">
When <tt>eval</tt> processes a
procedure application, it uses <tt>list-of-values</tt> to produce the
list of arguments to which the procedure is to be applied. <tt>List-of-values</tt> takes as an argument the operands of the combination.
It evaluates each operand and returns a list of the corresponding
values:<a name="call_footnote_Temp_518" href="#footnote_Temp_518"><sup><small>5</small></sup></a></p>

<p class="trans" lang="ja">
<tt>eval</tt> ãŒæ‰‹ç¶šãé©ç”¨ã‚’å‡¦ç†ã™ã‚‹ã¨ãã€<tt>eval</tt> ã¯ã€<tt>list-of-values</tt> ã‚’ç”¨ã„ã¦ã€ãã®æ‰‹ç¶šããŒé©ç”¨ã•ã‚Œã‚‹ã¹ãå®Ÿå¼•æ•°ã®ãƒªã‚¹ãƒˆã‚’ä½œã‚Šå‡ºã™ã€‚
<tt>list-of-values</tt> ã¯ã€å¼•æ•°ã¨ã—ã¦ã€ã‚³ãƒ³ãƒ“ãƒãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã‚’ã¨ã‚‹ã€‚
<tt>list-of-values</tt> ã¯ã€å„ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã‚’è©•ä¾¡ã—ã€å¯¾å¿œã™ã‚‹å€¤ã®ãƒªã‚¹ãƒˆã‚’è¿”ã™<a name="call_footnote_Temp_518" href="#footnote_Temp_518"><sup><small>5</small></sup></a>ã€‚
</p>

<p class="lisp"><a name="%_idx_4256"></a>(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (cons (eval (first-operand exps) env)
            (list-of-values (rest-operands exps) env))))
</p>

<a name="%_sec_Temp_519"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_519">Conditionals</a></h4>
<h4 class="trans" lang="ja">æ¡ä»¶å¼</h4>


<p class="orig" lang="en">
<tt>Eval-if</tt> evaluates the predicate part of an <tt>if</tt> expression
in the given environment.  If
the result is true, <tt>eval-if</tt> evaluates the consequent, otherwise
it evaluates the alternative:</p>

<p class="trans" lang="ja">
<tt>eval-if</tt> ã¯ã€<tt>if</tt> å¼ã®è¿°èªéƒ¨åˆ†ã‚’ã€ä¸ãˆã‚‰ã‚ŒãŸç’°å¢ƒå†…ã§è©•ä¾¡ã™ã‚‹ã€‚
ã‚‚ã—çµæœãŒçœŸãªã‚‰ã€<tt>eval-if</tt> ã¯å¸°çµå¼ã‚’è©•ä¾¡ã—ã€ãã†ã§ãªã‘ã‚Œã°ã€<tt>eval-if</tt> ã¯ä»£æ›¿å¼ã‚’è©•ä¾¡ã™ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_4258"></a>(define (eval-if exp env)
  (if (true? (eval (if-predicate exp) env))
      (eval (if-consequent exp) env)
      (eval (if-alternative exp) env)))
</p>

<p class="orig" lang="en">
<a name="%_idx_4260"></a>The use of <tt>true?</tt> in <tt>eval-if</tt> highlights the issue of the
connection between an implemented language and an implementation
language.  The <tt>if-predicate</tt> is evaluated in the language being
implemented and thus yields a value in that language.  The interpreter
predicate <tt>true?</tt> translates that value into a value that can be
tested by the <tt>if</tt> in the implementation language: The
metacircular representation of truth might not be the same as that of
the underlying Scheme.<a name="call_footnote_Temp_520" href="#footnote_Temp_520"><sup><small>6</small></sup></a></p>

<p class="trans" lang="ja">
<tt>eval-if</tt> ã«ãŠã‘ã‚‹ <tt>true?</tt> ã®ä½¿ç”¨ã¯ã€å®Ÿè£…ã•ã‚Œã‚‹è¨€èªã¨å®Ÿè£…è¨€èªã¨ã®é–“ã®é–¢ä¿‚ã®å•é¡Œã‚’ç›®ç«‹ãŸã›ã¦ã„ã‚‹ã€‚
<tt>if-predicate</tt> ã¯ã€å®Ÿè£…ã•ã‚Œã‚‹è¨€èªã«ãŠã„ã¦è©•ä¾¡ã•ã‚Œã€ã—ãŸãŒã£ã¦ã€ãã®è¨€èªã§ã®å€¤ã‚’ç”Ÿã¿å‡ºã™ã€‚
<tt>true?</tt> ã¨ã„ã†ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿è¿°èªã¯ã€ãã®å€¤ã‚’ã€å®Ÿè£…è¨€èªã«ãŠã‘ã‚‹ <tt>if</tt> ã«ã‚ˆã£ã¦æ¤œæŸ»ã§ãã‚‹å€¤ã¸ã¨ã€å¤‰æ›ã™ã‚‹ã€‚
ã¤ã¾ã‚Šã€çœŸã§ã‚ã‚‹ã“ã¨ã®ãƒ¡ã‚¿å¾ªç’°çš„ãªè¡¨ç¾ã¯ã€æ ¹åº•ã«ã‚ã‚‹Schemeã§ã®ã€çœŸã§ã‚ã‚‹ã“ã¨ã®è¡¨ç¾ã¨ã¯ã€åŒã˜ã§ã¯ãªã„ã‹ã‚‚ã—ã‚Œãªã„ã®ã§ã‚ã‚‹<a href="#footnote_Temp_520"><sup><small>6</small></sup></a>ã€‚
</p>

<a name="%_sec_Temp_521"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_521">Sequences</a></h4>
<h4 class="trans" lang="ja">ä¸¦ã³</h4>


<p class="orig" lang="en">
<tt>Eval-sequence</tt> is used by <tt>apply</tt> to evaluate the sequence of
expressions in a procedure body and by <tt>eval</tt> to evaluate the
sequence of expressions in a <tt>begin</tt>
expression.  It takes as arguments a sequence of expressions and an
environment, and evaluates the expressions in the order in which they
occur.  The value returned is the value of the final expression.</p>

<p class="trans" lang="ja">
<tt>eval-sequence</tt> ã¯ã€æ‰‹ç¶šãæœ¬ä½“ã®ä¸­ã®ä¸€é€£ã®å¼ã®ä¸¦ã³ã‚’è©•ä¾¡ã™ã‚‹ãŸã‚ã« <tt>apply</tt> ã«ã‚ˆã£ã¦ä½¿ã‚ã‚Œã€ã¾ãŸã€<tt>begin</tt> å¼ã®ä¸­ã®ä¸€é€£ã®å¼ã®ä¸¦ã³ã‚’è©•ä¾¡ã™ã‚‹ãŸã‚ã«ã€<tt>eval</tt> ã«ã‚ˆã£ã¦ä½¿ã‚ã‚Œã‚‹ã€‚
<tt>eval-sequence</tt> ã¯ã€å¼•æ•°ã¨ã—ã¦ã€ä¸€é€£ã®å¼ã®ä¸¦ã³ã¨ç’°å¢ƒã‚’ã¨ã‚Šã€ãã‚Œã‚‰ã®å¼ãŒç¾ã‚Œã‚‹é †ã§ãã‚Œã‚‰ã®å¼ã‚’è©•ä¾¡ã™ã‚‹ã€‚
è¿”ã•ã‚Œã‚‹å€¤ã¯ã€æœ€å¾Œã®å¼ã®å€¤ã§ã‚ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_4264"></a>(define (eval-sequence exps env)
  (cond ((last-exp? exps) (eval (first-exp exps) env))
        (else (eval (first-exp exps) env)
              (eval-sequence (rest-exps exps) env))))
</p>

<a name="%_sec_Temp_522"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_522">Assignments and definitions</a></h4>
<h4 class="trans" lang="ja"><ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã¨å®šç¾©</h4>

<p class="orig" lang="en">
The following procedure handles assignments to variables.  It calls
<tt>eval</tt> to find the value to be assigned and transmits the variable
and the resulting value to <tt>set-variable-value!</tt> to be installed
in the designated environment.</p>

<p class="trans" lang="ja">
æ¬¡ã®æ‰‹ç¶šãã¯ã€å¤‰æ•°ã¸ã®<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã‚’å–ã‚Šæ‰±ã†ã€‚
ã“ã‚Œã¯ã€<tt>eval</tt> ã‚’å‘¼ã³å‡ºã—ã¦ã€<ruby><rb>ä»£å…¥ã•ã‚Œã‚‹</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦ã‚‰ã‚Œã‚‹</rt><rp>) </rp></ruby>ã¹ãå€¤ã‚’æ‰‹ã«å…¥ã‚Œã€ãã—ã¦ã€å¤‰æ•°ã¨ã€çµæœã¨ã—ã¦å¾—ã‚‰ã‚ŒãŸå€¤ã¨ã‚’ <tt>set-variable-value!</tt> ã«ä¼ãˆã¦ã€æŒ‡å®šã•ã‚ŒãŸç’°å¢ƒã«ã“ã‚Œã‚‰ãŒçµ„ã¿è¾¼ã¾ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹ã€‚<span class="note">(to be installed ... ã®è¨³ã«ã¤ã„ã¦å†æ¤œè¨ãŒå¿…è¦ã‹ã‚‚?)</span>
</p>

<p class="lisp"><a name="%_idx_4266"></a>(define (eval-assignment exp env)
  (set-variable-value! (assignment-variable exp)
                       (eval (assignment-value exp) env)
                       env)
  'ok)
</p>

<p class="orig" lang="en">Definitions of variables are handled in a similar
manner.<a name="call_footnote_Temp_523" href="#footnote_Temp_523"><sup><small>7</small></sup></a></p>

<p class="trans" lang="ja">
ä¼¼ãŸã‚ˆã†ãªæ–¹æ³•ã§ã€å¤‰æ•°ã®å®šç¾©ãŒæ‰±ã‚ã‚Œã‚‹<a href="#footnote_Temp_523"><sup><small>7</small></sup></a>ã€‚
</p>

<p class="lisp"><a name="%_idx_4268"></a>(define (eval-definition exp env)
  (define-variable! (definition-variable exp)
                    (eval (definition-value exp) env)
                    env)
  'ok)
</p>

<p class="orig" lang="en">We have chosen here to return the symbol <tt>ok</tt> as the value
of an assignment or a definition.<a name="call_footnote_Temp_524" href="#footnote_Temp_524"><sup><small>8</small></sup></a></p>

<p class="trans" lang="ja">
ã“ã“ã§ã¯ã€<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã¾ãŸã¯å®šç¾©ã®å€¤ã¨ã—ã¦ã€<tt>ok</tt> ã¨ã„ã†è¨˜å·ã‚’è¿”ã™ã“ã¨ã‚’é¸ã‚“ã <a href="#footnote_Temp_524"><sup><small>8</small></sup></a>ã€‚
</p>

<p class="orig" lang="en">
<a name="%_thm_4.1"></a>
<b>Exercise 4.1.</b>  <a name="%_idx_4270"></a><a name="%_idx_4272"></a>Notice that we cannot tell whether the metacircular evaluator
evaluates operands from left to right or from right to left.  Its evaluation
order is inherited from the underlying Lisp:
If the arguments to <tt>cons</tt> in <tt>list-of-values</tt>
are evaluated from left to right, then <tt>list-of-values</tt> will
evaluate operands from left to right; and 
if the arguments to <tt>cons</tt>
are evaluated from right to left, then <tt>list-of-values</tt> will
evaluate operands from right to left.</p>


<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.1.</b> ãƒ¡ã‚¿å¾ªç’°çš„ãªè©•ä¾¡å™¨ãŒã‚ªãƒšãƒ©ãƒ³ãƒ‰ã‚’å·¦ã‹ã‚‰å³ã¸è©•ä¾¡ã™ã‚‹ã®ã‹ã€ãã‚Œã¨ã‚‚å³ã‹ã‚‰å·¦ã¸è©•ä¾¡ã™ã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’ç§ãŸã¡ã¯åˆ¤æ–­ã§ããªã„ã®ã ã€ã¨ã„ã†ã“ã¨ã«æ°—ã¥ã„ã¦ã»ã—ã„ã€‚
è©•ä¾¡å™¨ã®è©•ä¾¡é †åºã¯ã€æ ¹åº•ã«ã‚ã‚‹Lispã‹ã‚‰å—ã‘ç¶™ãŒã‚Œã‚‹ã€‚
ã‚‚ã—ã€<tt>list-of-values</tt> ã«ãŠã‘ã‚‹ <tt>cons</tt> ã¸ã®å®Ÿå¼•æ•°ãŒå·¦ã‹ã‚‰å³ã¸è©•ä¾¡ã•ã‚Œã‚‹ãªã‚‰ã€<tt>list-of-values</tt> ã¯ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã‚’å·¦ã‹ã‚‰å³ã¸è©•ä¾¡ã™ã‚‹ã ã‚ã†ã—ã€ã‚‚ã—ã€<tt>cons</tt> ã¸ã®å®Ÿå¼•æ•°ãŒå³ã‹ã‚‰å·¦ã¸è©•ä¾¡ã•ã‚Œã‚‹ãªã‚‰ã€<tt>list-of-values</tt> ã¯ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã‚’å³ã‹ã‚‰å·¦ã¸è©•ä¾¡ã™ã‚‹ã ã‚ã†ã€‚
</p>

<p class="orig" lang="en">
Write a version of <tt>list-of-values</tt> that evaluates operands
from left to right regardless of the order of evaluation in the underlying
Lisp.  Also write a version of <tt>list-of-values</tt> that evaluates operands
from right to left.


<p class="trans" lang="ja">
æ ¹åº•ã«ã‚ã‚‹Lispã«ãŠã‘ã‚‹è©•ä¾¡ã®é †åºã«ã‚ˆã‚‰ãšã«ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã‚’å·¦ã‹ã‚‰å³ã¸è©•ä¾¡ã™ã‚‹ã‚ˆã†ãªã€<tt>list-of-values</tt> ã®ä¸€ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’æ›¸ã‘ã€‚
ã¾ãŸã€ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã‚’å³ã‹ã‚‰å·¦ã¸è©•ä¾¡ã™ã‚‹ã‚ˆã†ãªã€<tt>list-of-values</tt> ã®ä¸€ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚‚æ›¸ã‘ã€‚
</p>


<p class="exercise"><span class="ex_comment"></span></p>

<a name="%_sec_4.1.2"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_4.1.2">4.1.2  Representing Expressions</a></h3>
<h3 class="trans" lang="ja">4.1.2 å¼ã‚’è¡¨ç¾ã™ã‚‹</h3>

<p class="orig" lang="en">
<a name="%_idx_4274"></a><a name="%_idx_4276"></a>
<a name="%_idx_4278"></a>The evaluator is reminiscent of the symbolic differentiation program
discussed in section <a href="16_sec2_3.html#%_sec_2.3.2">2.3.2</a>.  Both
programs operate on symbolic expressions.  In both programs, the
result of operating on a compound expression is determined by
operating recursively on the pieces of the expression and combining
the results in a way that depends on the type of the expression.  In
both programs we used <a name="%_idx_4280"></a>data abstraction to decouple the general rules
of operation from the details of how expressions are represented.  In
the differentiation program this meant that the same differentiation
procedure could deal with algebraic expressions in prefix form, in
infix form, or in some other form.  For the evaluator, this means that
the syntax of the language being evaluated is determined solely by the
procedures that classify and extract pieces of expressions.</p>

<p class="trans" lang="ja">
ã“ã®è©•ä¾¡å™¨ã¯ã€<a href="16_sec2_3.html#%_sec_2.3.2">2.3.2</a>ç¯€ã§è­°è«–ã—ãŸè¨˜å·å¾®åˆ†ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’å²ã°ã›ã‚‹ã€‚
åŒæ–¹ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€è¨˜å·çš„ãªå¼ã«å¯¾ã—ã¦æ¼”ç®—ã‚’è¡Œã†<!--å‹•ä½œã™ã‚‹-->ã€‚
åŒæ–¹ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ãŠã„ã¦ã€è¤‡åˆçš„ãªå¼ã«å¯¾ã—ã¦æ¼”ç®—ã‚’è¡Œã†<!--å‹•ä½œã™ã‚‹-->ã“ã¨ã®çµæœã¯ã€ãã®å¼ã®éƒ¨åˆ†ã«å¯¾ã—ã¦å†å¸°çš„ã«æ¼”ç®—ã‚’è¡Œã£ã¦<!--å‹•ä½œã—ã¦-->ã‹ã‚‰å¼ã®ç¨®é¡ã«å¿œã˜ãŸæ–¹æ³•ã§ãã®çµæœã‚’çµåˆã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€æ±ºå®šã•ã‚Œã‚‹ã€‚
åŒæ–¹ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ãŠã„ã¦ã€ç§ãŸã¡ã¯ã€å¼ãŒã©ã®ã‚ˆã†ã«è¡¨ç¾ã•ã‚Œã‚‹ã®ã‹ã¨ã„ã†ç´°ç›®ã‹ã‚‰æ¼”ç®—ã®ä¸€èˆ¬çš„ãªè¦å‰‡ã‚’åˆ†é›¢ã™ã‚‹ãŸã‚ã«ã€ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ã‚’ç”¨ã„ãŸã€‚
å¾®åˆ†ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã¯ã€ã“ã‚Œã¯ã€å‰ç½®å½¢å¼ã ã‚ã†ã¨ã€ä¸­ç½®å½¢å¼ã ã‚ã†ã¨ã€ã‚ã‚‹ã„ã¯ä½•ã‚‰ã‹ã®ä»–ã®å½¢å¼ã ã‚ã†ã¨ã€åŒã˜å¾®åˆ†æ‰‹ç¶šããŒä»£æ•°çš„ãªå¼ã‚’æ‰±ãˆã‚‹ã ã‚ã†ã€ã¨ã„ã†ã“ã¨ã‚’æ„å‘³ã—ãŸã€‚
è©•ä¾¡å™¨ã«ã¤ã„ã¦ã¯ã€ã“ã‚Œã¯ã€è©•ä¾¡ã•ã‚Œã¦ã„ã‚‹è¨€èªã®æ–‡æ³•ãŒã€å¼ã®éƒ¨åˆ†ã‚’åˆ†é¡ãƒ»æŠ½å‡ºã™ã‚‹æ‰‹ç¶šãã«ã‚ˆã£ã¦ã®ã¿æ±ºå®šã•ã‚Œã‚‹ã®ã ã€ã¨ã„ã†ã“ã¨ã‚’æ„å‘³ã™ã‚‹ã€‚
</p>

<p class="orig" lang="en">
Here is the specification of the syntax of our language:
</p>

<p class="trans" lang="ja">
ã“ã“ã«ç§ãŸã¡ã®è¨€èªã®æ–‡æ³•ã®ä»•æ§˜æ›¸ã‚’ç¤ºã™ã€‚
</p>

<p class="orig" lang="en">
&curren; The only self-evaluating items are numbers and
strings:</p>

<ul class="trans white" lang="ja">
<li>è‡ªå·±è©•ä¾¡çš„ãªé …ç›®ã¯ã€æ•°ã¨æ–‡å­—åˆ—ã®ã¿ã§ã‚ã‚‹ã€‚</li>
</ul>


<p class="lisp"><a name="%_idx_4282"></a>(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        (else false)))
</p>

<p class="orig" lang="en">&curren; Variables are represented by symbols:</p>


<ul class="trans white" lang="ja">
<li>å¤‰æ•°ã¯è¨˜å·ã«ã‚ˆã‚Šè¡¨ã•ã‚Œã‚‹ã€‚</li>
</ul>

<p class="lisp"><a name="%_idx_4284"></a>(define (variable? exp) (symbol? exp))
</p>


<p class="orig" lang="en">&curren; Quotations have the form <tt>(quote
&lt;<em>text-of-quotation</em>&gt;)</tt>:<a name="call_footnote_Temp_526" href="#footnote_Temp_526"><sup><small>9</small></sup></a></p>


<ul class="trans white" lang="ja">
<li>å¼•ç”¨ã¯ <tt>(quote &lt;<em class="en">text-of-quotation</em>&gt;)</tt> ã¨ã„ã†å½¢ã‚’ã—ã¦ã„ã‚‹<a href="#footnote_Temp_526"><sup><small>9</small></sup></a>ã€‚</li>
</ul>

<p class="lisp"><a name="%_idx_4286"></a>(define (quoted? exp)
  (tagged-list? exp 'quote))

<a name="%_idx_4288"></a>(define (text-of-quotation exp) (cadr exp))
</p>


<p class="orig" lang="en"><tt>Quoted?</tt> is defined in terms of the procedure <tt>tagged-list?</tt>, which identifies lists beginning with a designated
symbol:</p>

<p class="trans" lang="ja">
<tt>quoted?</tt> ã¯ <tt>tagged-list?</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’ä½¿ã£ã¦å®šç¾©ã•ã‚Œã‚‹ãŒã€ã“ã‚Œã¯ã€æŒ‡å®šã•ã‚ŒãŸè¨˜å·ã§å§‹ã¾ã‚‹ãƒªã‚¹ãƒˆã‚’è¦‹åˆ†ã‘ã‚‹ã‚‚ã®ã§ã‚ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_4290"></a>(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      false))
</p>

<p class="orig" lang="en">&curren; Assignments have the form <tt>(set!
&lt;<em>var</em>&gt; &lt;<em>value</em>&gt;)</tt>:</p>


<ul class="trans white" lang="ja">
<li><ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã¯ 
<tt>(set! &lt;<em class="en">var</em>&gt; &lt;<em class="en">value</em>&gt;)</tt>
ã¨ã„ã†å½¢ã‚’ã—ã¦ã„ã‚‹ã€‚</li>
</ul>

<p class="lisp"><a name="%_idx_4292"></a>(define (assignment? exp)
  (tagged-list? exp 'set!))
<a name="%_idx_4294"></a>(define (assignment-variable exp) (cadr exp))
<a name="%_idx_4296"></a>(define (assignment-value exp) (caddr exp))
</p>

<p class="orig" lang="en">&curren; Definitions have the form</p>


<ul class="trans white" lang="ja">
<li>å®šç¾©ã¯æ¬¡ã®ã‚ˆã†ãªå½¢ã‚’ã—ã¦ã„ã‚‹</li>
</ul>

<p class="lisp">(define &lt;<em>var</em>&gt; &lt;<em>value</em>&gt;)
</p>

<p class="orig" lang="en">or the form</p>

<p class="trans" lang="ja">
ã‹ã€ã‚ã‚‹ã„ã¯ã€æ¬¡ã®ã‚ˆã†ãªå½¢ã‚’ã—ã¦ã„ã‚‹ã€‚
</p>

<p class="lisp">(define (&lt;<em>var</em>&gt; &lt;<em>parameter<sub>1</sub></em>&gt; <tt>...</tt> &lt;<em>parameter<sub><em>n</em></sub></em>&gt;)
  &lt;<em>body</em>&gt;)
</p>

<p class="orig" lang="en"><a name="%_idx_4298"></a><a name="%_idx_4300"></a>The latter form (standard procedure definition) is syntactic sugar for</p>

<p class="trans" lang="ja">
å¾Œè€…ã®å½¢ (æ¨™æº–çš„ãªæ‰‹ç¶šãå®šç¾©) ã¯ã€ä»¥ä¸‹ã®ã‚‚ã®ã«å¯¾ã™ã‚‹ç³–è¡£æ§‹æ–‡ã§ã‚ã‚‹ã€‚
</p>

<p class="lisp">(define &lt;<em>var</em>&gt;
  (lambda (&lt;<em>parameter<sub>1</sub></em>&gt; <tt>...</tt> &lt;<em>parameter<sub><em>n</em></sub></em>&gt;)
    &lt;<em>body</em>&gt;))
</p>

<p class="orig" lang="en">The corresponding syntax procedures are the following:</p>

<p class="trans" lang="ja">
å¯¾å¿œã™ã‚‹æ–‡æ³•æ‰‹ç¶šãã¯ä»¥ä¸‹ã®ã¨ãŠã‚Šã§ã‚ã‚‹ã€‚
</p>


<p class="lisp"><a name="%_idx_4302"></a>(define (definition? exp)
  (tagged-list? exp 'define))
<a name="%_idx_4304"></a>(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))
<a name="%_idx_4306"></a>(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)   <em>; formal parameters</em>
                   (cddr exp)))) <em>; body</em>
</p>

<p class="orig" lang="en">&curren; <tt>Lambda</tt> expressions are lists that begin with the
symbol <tt>lambda</tt>:</p>


<ul class="trans white" lang="ja">
<li><tt>lambda</tt> å¼ã¯ã€<tt>lambda</tt> ã¨ã„ã†è¨˜å·ã§å§‹ã¾ã‚‹ãƒªã‚¹ãƒˆã§ã‚ã‚‹ã€‚</li>
</ul>

<p class="lisp"><a name="%_idx_4308"></a>(define (lambda? exp) (tagged-list? exp 'lambda))
<a name="%_idx_4310"></a>(define (lambda-parameters exp) (cadr exp))
<a name="%_idx_4312"></a>(define (lambda-body exp) (cddr exp))
</p>

<p class="orig" lang="en">We also provide a constructor for <tt>lambda</tt> expressions,
which is used by <tt>definition-value</tt>, above:
</p>

<p class="trans" lang="ja">
<tt>lambda</tt> å¼ã«å¯¾ã™ã‚‹ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿â€”â€”ä¸Šè¨˜ã® <tt>definition-value</tt> ã«ã‚ˆã‚Šä½¿ã‚ã‚Œã‚‹â€”â€”ã‚‚æä¾›ã™ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_4314"></a>(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))
</p>

<p class="orig" lang="en">&curren; Conditionals begin with <tt>if</tt> and have a predicate, a
consequent, and an (optional) alternative.  If the expression has no
alternative part, we provide <tt>false</tt> as the alternative.<a name="call_footnote_Temp_527" href="#footnote_Temp_527"><sup><small>10</small></sup></a></p>


<ul class="trans white" lang="ja">
<li>æ¡ä»¶å¼ã¯ã€<tt>if</tt> ã§å§‹ã¾ã‚Šã€ã‹ã¤ã€è¿°èªã¨å¸°çµå¼ã¨ (ã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«ãª) ä»£æ›¿å¼ã‚’æœ‰ã™ã‚‹ã€‚
ã‚‚ã—ã€ãã®å¼ã«ä»£æ›¿å¼ã®éƒ¨åˆ†ãŒãªã‘ã‚Œã°ã€<tt>false</tt> ã‚’ä»£æ›¿å¼ã¨ã—ã¦æä¾›ã™ã‚‹<a href="#footnote_Temp_527"><sup><small>10</small></sup></a>ã€‚</li>
</ul>

<p class="lisp"><a name="%_idx_4316"></a>(define (if? exp) (tagged-list? exp 'if))
<a name="%_idx_4318"></a>(define (if-predicate exp) (cadr exp))
<a name="%_idx_4320"></a>(define (if-consequent exp) (caddr exp))
<a name="%_idx_4322"></a>(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))
</p>

<p class="orig" lang="en">We also provide a constructor for <tt>if</tt> expressions,
to be used by <tt>cond-&gt;if</tt> to transform <tt>cond</tt> expressions
into <tt>if</tt> expressions:
</p>

<p class="trans" lang="ja">
<tt>if</tt> å¼ã®ãŸã‚ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚‚æä¾›ã™ã‚‹â€”â€”ã“ã‚Œã¯ã€<tt>cond</tt> å¼ã‚’ <tt>if</tt> å¼ã«å¤‰å½¢ã™ã‚‹ãŸã‚ã« <tt>cond-&gt;if</tt> ã«ã‚ˆã‚Šä½¿ã‚ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_4324"></a>(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))
</p>

<p class="orig" lang="en">&curren; <tt>Begin</tt> packages a sequence of expressions into a single
expression.  We include syntax operations on <tt>begin</tt> expressions
to extract the actual sequence from the <tt>begin</tt> expression, as
well as selectors that return the first expression and the rest of the
expressions in the sequence.<a name="call_footnote_Temp_528" href="#footnote_Temp_528"><sup><small>11</small></sup></a></p>


<ul class="trans white" lang="ja">
<li><tt>begin</tt> ã¯ä¸€é€£ã®å¼ã®ä¸¦ã³ã‚’ä¸€åŒ…ã¿ã«ã—ã¦ã€ä¸€ã¤ã®å¼ã«ã¾ã¨ã‚ã‚‹ã€‚
ç§ãŸã¡ã¯ã€æœ€åˆã®å¼ã‚’è¿”ã™ã‚»ãƒ¬ã‚¯ã‚¿ã¨ã€ä¸¦ã³ã®ã†ã¡ã®æ®‹ã‚Šã™ã¹ã¦ã®å¼ã‚’è¿”ã™ã‚»ãƒ¬ã‚¯ã‚¿ã‚’å«ã‚ã‚‹ã¨ã¨ã‚‚ã«ã€<tt>begin</tt> å¼ã‹ã‚‰å®Ÿéš›ã®ä¸¦ã³ã‚’æŠ½å‡ºã™ã‚‹ãŸã‚ã®ã€<tt>begin</tt> å¼ã«å¯¾ã™ã‚‹æ–‡æ³•æ¼”ç®—ã‚’å«ã‚ã‚‹<a href="#footnote_Temp_528"><sup><small>11</small></sup></a>ã€‚
</li>
</ul>

<p class="lisp"><a name="%_idx_4326"></a>(define (begin? exp) (tagged-list? exp 'begin))
<a name="%_idx_4328"></a>(define (begin-actions exp) (cdr exp))
<a name="%_idx_4330"></a>(define (last-exp? seq) (null? (cdr seq)))
<a name="%_idx_4332"></a>(define (first-exp seq) (car seq))
<a name="%_idx_4334"></a>(define (rest-exps seq) (cdr seq))
</p>

<p class="orig" lang="en">We also include a constructor <tt>sequence-&gt;exp</tt> (for use by
<tt>cond-&gt;if</tt>) that transforms a sequence into a single expression,
using <tt>begin</tt> if necessary:</p>

<p class="trans" lang="ja">
ã‚‚ã—å¿…è¦ãªã‚‰ <tt>begin</tt> ã‚’ä½¿ã£ã¦ä¸¦ã³ã‚’å˜ä¸€ã®å¼ã¸ã¨å¤‰å½¢ã™ã‚‹ã€(<tt>cond-&gt;if</tt> ãŒä½¿ã†ãŸã‚ã®) <tt>sequence-&gt;exp</tt> ã¨ã„ã†ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚‚ã€å«ã‚ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_4336"></a>(define (sequence-&gt;exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq))
        (else (make-begin seq))))
<a name="%_idx_4338"></a>(define (make-begin seq) (cons 'begin seq))
</p>

<p class="orig" lang="en">&curren; A procedure application is any compound expression
that is not one of the above expression types.  The <tt>car</tt> of the
expression is the operator, and the <tt>cdr</tt> is the list of operands:</p>


<ul class="trans white" lang="ja">
<li>æ‰‹ç¶šãé©ç”¨ã¯ã€ä¸Šè¨˜ã®å¼ã®ç¨®é¡ã®ã†ã¡ã®ä¸€ã¤ã§ã¯ãªã„ã‚ˆã†ãªã€ä»»æ„ã®è¤‡åˆçš„ãªå¼ã§ã‚ã‚‹ã€‚
ãã®å¼ã® <tt>car</tt> ã¯æ¼”ç®—å­ã§ã‚ã‚Šã€<tt>cdr</tt> ã¯ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã®ãƒªã‚¹ãƒˆã§ã‚ã‚‹ã€‚</li>
</ul>

<p class="lisp"><a name="%_idx_4340"></a>(define (application? exp) (pair? exp))
<a name="%_idx_4342"></a>(define (operator exp) (car exp))
<a name="%_idx_4344"></a>(define (operands exp) (cdr exp))
<a name="%_idx_4346"></a>(define (no-operands? ops) (null? ops))
<a name="%_idx_4348"></a>(define (first-operand ops) (car ops))
<a name="%_idx_4350"></a>(define (rest-operands ops) (cdr ops))
</p>

<a name="%_sec_Temp_529"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_529">Derived expressions</a></h4>
<h4 class="trans" lang="ja">æ´¾ç”Ÿã—ãŸå¼</h4>


<p class="orig" lang="en">
<a name="%_idx_4352"></a><a name="%_idx_4354"></a><a name="%_idx_4356"></a><a name="%_idx_4358"></a>
Some special forms in our language can be defined in terms of
expressions involving other special forms, rather than being
implemented directly.  One example is <tt>cond</tt>, which can be
implemented as a nest of <tt>if</tt> expressions.  For example,
we can reduce the problem of evaluating the expression</p>

<p class="trans" lang="ja">
ç§ãŸã¡ã®è¨€èªã«ãŠã‘ã‚‹å¹¾ã¤ã‹ã®ç‰¹æ®Šå½¢å¼ã¯ã€ç›´æ¥çš„ã«å®Ÿè£…ã•ã‚Œã‚‹ã¨ã„ã†ã‚ˆã‚Šã‚‚ã‚€ã—ã‚ã€ä»–ã®ç‰¹æ®Šå½¢å¼ã‚’å«ã‚€å¼ã‚’ç”¨ã„ã¦å®šç¾©ã§ãã‚‹ã€‚
ä¸€ä¾‹ã¯ <tt>cond</tt> ã§ã‚ã‚Šã€ã“ã‚Œã¯ã€<tt>if</tt> å¼ã®å…¥ã‚Œå­ã¨ã—ã¦å®Ÿè£…ã§ãã‚‹ã€‚
ãŸã¨ãˆã°ã€ä»¥ä¸‹ã®å¼ã‚’è©•ä¾¡ã™ã‚‹ã€ã¨ã„ã†å•é¡Œã‚’é‚„å…ƒã—ã¦ã€
</p>

<p class="lisp">(cond ((&gt; x 0) x)
      ((= x 0) (display 'zero) 0)
      (else (- x)))
</p>

<p class="orig" lang="en">to the problem of evaluating the following
expression involving <tt>if</tt> and <tt>begin</tt> expressions:</p>

<p class="trans" lang="ja">
<tt>if</tt> å¼ã¨ <tt>begin</tt> å¼ã‚’å«ã‚€ä»¥ä¸‹ã®å¼ã‚’è©•ä¾¡ã™ã‚‹ã€ã¨ã„ã†å•é¡Œã¸ã¨å¸°ç€ã•ã›ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
</p>

<p class="lisp">(if (&gt; x 0)
    x
    (if (= x 0)
        (begin (display 'zero)
               0)
        (- x)))
</p>

<p class="orig" lang="en">
Implementing the evaluation of <tt>cond</tt> in this way
simplifies the evaluator because it reduces the number of special
forms for which the evaluation process must be explicitly specified.</p>

<p class="trans" lang="ja">
ã“ã®æ–¹æ³•ã§ã® <tt>cond</tt> ã®è©•ä¾¡ã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ã§ã€è©•ä¾¡ãƒ—ãƒ­ã‚»ã‚¹ã‚’æ˜ç¤ºçš„ã«æŒ‡å®šã›ã­ã°ãªã‚‰ãªã„ç‰¹æ®Šå½¢å¼ã®æ•°ã‚’æ¸›ã‚‰ã™ã“ã¨ã«ãªã‚‹ãŸã‚ã€è©•ä¾¡å™¨ã¯ç°¡ç´ åŒ–ã•ã‚Œã‚‹ã€‚
</p>

<p class="orig" lang="en">
We include syntax procedures that extract the parts of a <tt>cond</tt>
expression, and a procedure <tt>cond-&gt;if</tt> that transforms <tt>cond</tt>
expressions into <tt>if</tt> expressions.  A case analysis begins with <tt>cond</tt> and has a list of predicate-action clauses.  A clause is an <tt>else</tt> clause if its predicate is the symbol <tt>else</tt>.<a name="call_footnote_Temp_530" href="#footnote_Temp_530"><sup><small>12</small></sup></a></p>

<p class="trans" lang="ja">
ç§ãŸã¡ã¯ã€<tt>cond</tt> å¼ã®éƒ¨åˆ†ã‚’æŠ½å‡ºã™ã‚‹æ–‡æ³•æ‰‹ç¶šãã¨ã€<tt>cond</tt> å¼ã‚’ <tt>if</tt> å¼ã¸ã¨å¤‰å½¢ã™ã‚‹ <tt>cond-&gt;if</tt> ã¨ã„ã†æ‰‹ç¶šãã¨ã‚’å«ã‚ã‚‹ã€‚
å ´åˆåˆ†ã‘åˆ†æã¯ã€<tt>cond</tt> ã§å§‹ã¾ã£ã¦ã€è¿°èªãƒ»å‹•ä½œã®ç¯€ã®ãƒªã‚¹ãƒˆã‚’æœ‰ã™ã‚‹ã€‚
ç¯€ã¯ã€ã‚‚ã—ãã®ç¯€ã®è¿°èªãŒ <tt>else</tt> ã¨ã„ã†è¨˜å·ãªã‚‰ã€<tt>else</tt> ç¯€ã§ã‚ã‚‹<a href="#footnote_Temp_530"><sup><small>12</small></sup></a>ã€‚
</p>

<p class="lisp"><a name="%_idx_4360"></a>(define (cond? exp) (tagged-list? exp 'cond))
<a name="%_idx_4362"></a>(define (cond-clauses exp) (cdr exp))
<a name="%_idx_4364"></a>(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
<a name="%_idx_4366"></a>(define (cond-predicate clause) (car clause))
<a name="%_idx_4368"></a>(define (cond-actions clause) (cdr clause))
<a name="%_idx_4370"></a>(define (cond-&gt;if exp)
  (expand-clauses (cond-clauses exp)))

<a name="%_idx_4372"></a>(define (expand-clauses clauses)
  (if (null? clauses)
      'false                          <em>; no <tt>else</tt> clause</em>
      (let ((first (car clauses))
            (rest (cdr clauses)))
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence-&gt;exp (cond-actions first))
                (error &quot;ELSE clause isn't last -- COND-&gt;IF&quot;
                       clauses))
            (make-if (cond-predicate first)
                     (sequence-&gt;exp (cond-actions first))
                     (expand-clauses rest))))))
</p>

<p class="orig" lang="en">
Expressions (such as <tt>cond</tt>) that we choose to implement as syntactic
transformations are called <em>derived expressions</em>.
<tt>Let</tt> expressions are also derived expressions
(see exercise <a href="#%_thm_4.6">4.6</a>).<a name="call_footnote_Temp_531" href="#footnote_Temp_531"><sup><small>13</small></sup></a></p>

<p class="trans" lang="ja">
æ–‡æ³•ä¸Šã®å¤‰å½¢ã¨ã—ã¦å®Ÿè£…ã™ã‚‹ã“ã¨ã‚’ç§ãŸã¡ãŒé¸ã¶å¼ (<tt>cond</tt> ãªã©) ã¯ã€<em>æ´¾ç”Ÿå¼</em>ã¨å‘¼ã°ã‚Œã‚‹ã€‚
<tt>let</tt> å¼ã‚‚ã€æ´¾ç”Ÿå¼ã§ã‚ã‚‹ (ç·´ç¿’å•é¡Œ<a href="#%_thm_4.6">4.6</a>ã‚’å‚ç…§)<a href="#footnote_Temp_531"><sup><small>13</small></sup></a>ã€‚
</p>

<p class="orig" lang="en">
<a name="%_thm_4.2"></a>
<b>Exercise 4.2.</b>  <a name="%_idx_4384"></a>Louis Reasoner plans to reorder the <tt>cond</tt> clauses
in <tt>eval</tt> so that the clause for procedure applications appears
before the clause for assignments.  He argues that this will make the
interpreter more efficient:  Since programs usually contain more
applications than assignments, definitions, and so on,
his modified <tt>eval</tt> will usually check fewer
clauses than the original <tt>eval</tt> before identifying the type of an
expression.</p>


<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.2.</b> ãƒ«ã‚¤ã‚¹ãƒ»ãƒªãƒ¼ã‚ºãƒŠã¯ã€æ‰‹ç¶šãé©ç”¨ã®ãŸã‚ã®ç¯€ãŒ<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã®ãŸã‚ã®ç¯€ã‚ˆã‚Šå‰ã«ç¾ã‚Œã‚‹ã‚ˆã†ã«ã€<tt>eval</tt> ã®ä¸­ã® <tt>cond</tt> ç¯€ã‚’æ•´ç†ã—ç›´ã™ã¤ã‚‚ã‚Šã ã€‚
ãƒ«ã‚¤ã‚¹ã¯ã€ã“ã‚Œã«ã‚ˆã£ã¦ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ãŒã‚ˆã‚ŠåŠ¹ç‡çš„ã«ãªã‚‹ã ã‚ã†ã€ã¨ä¸»å¼µã™ã‚‹ã€‚
ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯é€šå¸¸ã€<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã‚„å®šç¾©ãªã©ã‚ˆã‚Šã‚‚å¤šãã®é©ç”¨ã‚’å«ã‚€ã®ã ã‹ã‚‰ã€ãƒ«ã‚¤ã‚¹ã®ä¿®æ­£ã—ãŸ <tt>eval</tt> ã¯ã€é€šå¸¸ã€å¼ã®ç¨®é¡ã‚’çªãæ­¢ã‚ã‚‹ã¾ã§ã«å…ƒã® <tt>eval</tt> ã‚ˆã‚Šã‚‚å°‘æ•°ã®ç¯€ã‚’èª¿ã¹ã‚‹ã ã‘ã§æ¸ˆã‚€ã ã‚ã†ã€‚
</p>


<ol class="orig alph" lang="en">
<li>What is wrong with Louis's plan?  (Hint: What will
Louis's evaluator do with the expression <tt>(define x 3)</tt>?)
</li>
<li>
<a name="%_idx_4386"></a>Louis is upset that his plan didn't work.
He is willing to go to any lengths to make his evaluator
recognize procedure applications before it checks for most other
kinds of expressions.
Help him by changing the syntax of the evaluated language so that
procedure applications start with <tt>call</tt>.  For example, instead of
<tt>(factorial 3)</tt> we will now have to write <tt>(call factorial 3)</tt>
and instead of <tt>(+ 1 2)</tt> we will have to write <tt>(call + 1 2)</tt>.
</li>
</ol>


<ol class="trans alph" lang="ja">
<li>ãƒ«ã‚¤ã‚¹ã®æ§‹æƒ³ã®ä½•ãŒãŠã‹ã—ã„ã®ã ã‚ã†ã‹?
(ãƒ’ãƒ³ãƒˆ: <tt>(define x 3)</tt> ã¨ã„ã†å¼ãŒã‚ã‚‹ã¨ã€ãƒ«ã‚¤ã‚¹ã®è©•ä¾¡å™¨ã¯ä½•ã‚’ã™ã‚‹ã ã‚ã†?)</li>
<li>ãƒ«ã‚¤ã‚¹ã¯ã€è‡ªåˆ†ã®æ§‹æƒ³ãŒã†ã¾ãã„ã‹ãªã‹ã£ãŸã®ã§ã†ã‚ãŸãˆãŸã€‚
å½¼ã¯ã€ä½•ã¨ã—ã¦ã§ã‚‚è‡ªåˆ†ã®è©•ä¾¡å™¨ã«ã€ä»–ã®ã»ã¨ã‚“ã©ã®ç¨®é¡ã®å¼ã‚’èª¿ã¹ã‚‹å‰ã«æ‰‹ç¶šãé©ç”¨ã‚’èªè­˜ã™ã‚‹ã‚ˆã†ã«ã•ã›ãŸã„ã€‚
æ‰‹ç¶šãé©ç”¨ãŒ <tt>call</tt> ã§å§‹ã¾ã‚‹ã‚ˆã†ã«ã€è©•ä¾¡ã•ã‚Œã‚‹å´ã®è¨€èªã®æ–‡æ³•ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€å½¼ã‚’åŠ©ã‘ã¦ã‚„ã£ã¦ãã‚ŒãŸã¾ãˆã€‚
ãŸã¨ãˆã°ã€<tt>(factorial 3)</tt> ã®ä»£ã‚ã‚Šã«ã€ç§ãŸã¡ã¯ã“ã‚Œã‹ã‚‰ã€<tt>(call factorial 3)</tt> ã¨æ›¸ã‹ã­ã°ãªã‚‰ãªã„ã ã‚ã†ã—ã€<tt>(+ 1 2)</tt>  ã®ä»£ã‚ã‚Šã«ã€ç§ãŸã¡ã¯ã“ã‚Œã‹ã‚‰ã€<tt>(call + 1 2)</tt> ã¨æ›¸ã‹ã­ã°ãªã‚‰ãªã„ã ã‚ã†ã€‚</li>
</ol>

<p class="exercise"><span class="ex_comment"></span></p>

<p class="orig" lang="en">
<a name="%_thm_4.3"></a>
<b>Exercise 4.3.</b>  <a name="%_idx_4388"></a><a name="%_idx_4390"></a><a name="%_idx_4392"></a>Rewrite <tt>eval</tt> so that the dispatch is done in data-directed
style.  Compare this with the data-directed
differentiation procedure of
exercise <a href="17_sec2_4.html#%_thm_2.73">2.73</a>.
(You may use the <tt>car</tt> of a compound expression as the
type of the expression, as is appropriate for the syntax implemented
in this section.)
.</p>


<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.3.</b> ãƒ‡ãƒ¼ã‚¿æŒ‡å‘çš„ãªæµå„€ã§æŒ¯ã‚Šåˆ†ã‘ãŒè¡Œã‚ã‚Œã‚‹ã‚ˆã†ã«ã€<tt>eval</tt> ã‚’æ›¸ãç›´ã›ã€‚
ã“ã‚Œã‚’ã€ç·´ç¿’å•é¡Œ<a href="17_sec2_4.html#%_thm_2.73">2.73</a>ã®ãƒ‡ãƒ¼ã‚¿æŒ‡å‘çš„ãªå¾®åˆ†æ‰‹ç¶šãã¨æ¯”è¼ƒã›ã‚ˆ
(æœ¬ç¯€ã§å®Ÿè£…ã•ã‚Œã‚‹æ–‡æ³•ã«ã¨ã£ã¦é©åˆ‡ãªã¨ãŠã‚Šã€å›ã¯ã€è¤‡åˆçš„ãªå¼ã® <tt>car</tt> ã‚’ã€ãã®å¼ã®ç¨®é¡ã¨ã—ã¦ä½¿ã£ã¦ã‚‚ã‚ˆã„)ã€‚
</p>

<p class="exercise"><span class="ex_comment"></span></p>

<p class="orig" lang="en">
<a name="%_thm_4.4"></a>
<b>Exercise 4.4.</b>  <a name="%_idx_4394"></a><a name="%_idx_4396"></a><a name="%_idx_4398"></a>Recall the definitions of the special forms <tt>and</tt> and <tt>or</tt>
from chapter 1:</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.4.</b> 1ç« ã§ã®ã€<tt>and</tt> ãŠã‚ˆã³ <tt>or</tt> ã¨ã„ã†ç‰¹æ®Šå½¢å¼ã®å®šç¾©ã‚’æ€ã„å‡ºãã†ã€‚
</p>

<ul class="orig" lang="en">
<li><tt>and</tt>: The expressions are evaluated from
left to right.  If any expression evaluates to
false, false is returned; any remaining expressions are not
evaluated.  If all the expressions evaluate to true values, the value
of the last expression is returned.  If there are no expressions then
true is returned.</li>

<li><tt>or</tt>: The expressions are evaluated from left to right.  If any
expression evaluates to a true value, that value is
returned; any remaining expressions are not evaluated.  If all
expressions evaluate to false, or if there are no expressions,
then false is returned.</li>
</ul>

<ul class="trans" lang="ja">
<li><tt>and</tt>: å¼ã¯å·¦ã‹ã‚‰å³ã¸è©•ä¾¡ã•ã‚Œã‚‹ã€‚
ã‚‚ã—ã€ã„ãšã‚Œã‹ã®å¼ãŒå½ã¨ã„ã†è©•ä¾¡ã«ãªã£ãŸã‚‰ã€å½ãŒè¿”ã•ã‚Œã‚‹ã€‚
ãã—ã¦ã€æ®‹ã‚Šã®ã©ã®å¼ã‚‚ã€è©•ä¾¡ã•ã‚Œãªã„ã€‚
ã‚‚ã—ã€ã™ã¹ã¦ã®å¼ãŒçœŸå€¤ã¨ã„ã†è©•ä¾¡ã«ãªã£ãŸã‚‰ã€æœ€å¾Œã®å¼ã®å€¤ãŒè¿”ã•ã‚Œã‚‹ã€‚
ã‚‚ã—ã€å¼ãŒä½•ã‚‚ãªã‘ã‚Œã°ã€çœŸãŒè¿”ã•ã‚Œã‚‹ã€‚</li>
<li><tt>or</tt>: å¼ã¯å·¦ã‹ã‚‰å³ã¸è©•ä¾¡ã•ã‚Œã‚‹ã€‚
ã‚‚ã—ã€ã„ãšã‚Œã‹ã®å¼ãŒçœŸå€¤ã¨ã„ã†è©•ä¾¡ã«ãªã£ãŸã‚‰ã€ãã®å€¤ãŒè¿”ã•ã‚Œã‚‹ã€‚
ãã—ã¦ã€æ®‹ã‚Šã®ã©ã®å¼ã‚‚ã€è©•ä¾¡ã•ã‚Œãªã„ã€‚
ã‚‚ã—ã€ã™ã¹ã¦ã®å¼ãŒå½ã¨ã„ã†è©•ä¾¡ã«ãªã£ãŸã‚‰ã€ã‚ã‚‹ã„ã¯ã€ã‚‚ã—ã€å¼ãŒä½•ã‚‚ãªã‹ã£ãŸã‚‰ã€å½ãŒè¿”ã•ã‚Œã‚‹ã€‚</li>
</ul>

<p class="orig" lang="en">Install <tt>and</tt> and <tt>or</tt> as new special forms for the evaluator
by defining appropriate syntax procedures and evaluation
procedures <tt>eval-and</tt> and <tt>eval-or</tt>.  Alternatively, show how
to implement <tt>and</tt> and <tt>or</tt> as derived expressions.
</p>

<p class="trans" lang="ja">
é©åˆ‡ãªæ–‡æ³•æ‰‹ç¶šãã¨ã€<tt>eval-and</tt> ãŠã‚ˆã³ <tt>eval-or</tt> ã¨ã„ã†è©•ä¾¡æ‰‹ç¶šãã¨ã‚’å®šç¾©ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€è©•ä¾¡å™¨ã«å¯¾ã™ã‚‹æ–°ãŸãªç‰¹æ®Šå½¢å¼ã¨ã—ã¦ã€<tt>and</tt> ãŠã‚ˆã³ <tt>or</tt> ã‚’çµ„ã¿è¾¼ã‚ã€‚
ã‚ã‚‹ã„ã¯ã€<tt>and</tt> ãŠã‚ˆã³ <tt>or</tt> ã‚’æ´¾ç”Ÿå¼ã¨ã—ã¦å®Ÿè£…ã™ã‚‹æ–¹æ³•ã‚’ç¤ºã›ã€‚
</p>


<p class="exercise"><span class="ex_comment"></span></p>

<p class="orig" lang="en">
<a name="%_thm_4.5"></a>
<b>Exercise 4.5.</b>  <a name="%_idx_4400"></a><a name="%_idx_4402"></a><a name="%_idx_4404"></a>Scheme allows an additional syntax for <tt>cond</tt> clauses, <tt>(&lt;<em>test</em>&gt; =&gt; &lt;<em>recipient</em>&gt;)</tt>.  If &lt;<em>test</em>&gt;
evaluates to a true value, then &lt;<em>recipient</em>&gt; is evaluated.  Its
value must be a procedure of one argument; this procedure is then
invoked on the value of the &lt;<em>test</em>&gt;, and the result is returned as
the value of the <tt>cond</tt> expression.  For example</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.5.</b> Schemeã¯ <tt>cond</tt> ç¯€ã«å¯¾ã—ã¦ã€è¿½åŠ çš„ãªæ§‹æ–‡ã€ã™ãªã‚ã¡ã€
<tt>(&lt;<em class="en">test</em>&gt; =&gt; &lt;<em class="en">recipient</em>&gt;)</tt>
ã‚’è¨±ã—ã¦ã„ã‚‹ã€‚
ã‚‚ã— &lt;<em class="en">test</em>&gt; ãŒã€çœŸå€¤ã¨ã„ã†è©•ä¾¡ã«ãªã£ãŸã‚‰ã€&lt;<em class="en">recipient</em>&gt; ãŒè©•ä¾¡ã•ã‚Œã‚‹ã€‚
ãã®å€¤ã¯ã€ä¸€å¼•æ•°ã®æ‰‹ç¶šãã§ãªãã¦ã¯ãªã‚‰ãªã„ã€‚ãã—ã¦ã€ã“ã®æ‰‹ç¶šããŒ &lt;<em class="en">test</em>&gt; ã®å€¤ã«å¯¾ã—ã¦å‘¼ã³å‡ºã•ã‚Œã¦ã€ãã®çµæœãŒã€<tt>cond</tt> å¼ã®å€¤ã¨ã—ã¦è¿”ã•ã‚Œã‚‹ã€‚
ãŸã¨ãˆã°ã€
</p>

<p class="lisp">(cond ((assoc 'b '((a 1) (b 2))) =&gt; cadr)
      (else false))
</p>

<p class="orig" lang="en">returns 2.
Modify the handling of <tt>cond</tt> so that it supports this extended
syntax.
</p>

<p class="trans" lang="ja">
ã¯ã€2ã‚’è¿”ã™ã€‚
<tt>cond</tt> ãŒã“ã®æ‹¡å¼µæ§‹æ–‡ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚ˆã†ã«ã€ <tt>cond</tt> ã®å–ã‚Šæ‰±ã„ã‚’ä¿®æ­£ã›ã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment"></span></p>

<p class="orig" lang="en">
<a name="%_thm_4.6"></a>
<b>Exercise 4.6.</b>  <a name="%_idx_4406"></a><tt>Let</tt> expressions are derived expressions, because</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.6.</b> <tt>let</tt> å¼ã¯æ´¾ç”Ÿå¼ã§ã‚ã‚‹ã€‚ãªãœãªã‚‰ã€
</p>


<p class="lisp">(let ((&lt;<em>var<sub>1</sub></em>&gt; &lt;<em>exp<sub>1</sub></em>&gt;) <tt>...</tt> (&lt;<em>var<sub><em>n</em></sub></em>&gt; &lt;<em>exp<sub><em>n</em></sub></em>&gt;))
  &lt;<em>body</em>&gt;)
</p>

<p class="orig" lang="en">is equivalent to</p>

<p class="trans" lang="ja">
ã¯ã€ä»¥ä¸‹ã®ã‚‚ã®ã¨ç­‰ä¾¡ã ã‹ã‚‰ã§ã‚ã‚‹ã€‚
</p>

<p class="lisp">((lambda (&lt;<em>var<sub>1</sub></em>&gt; <tt>...</tt> &lt;<em>var<sub><em>n</em></sub></em>&gt;)
   &lt;<em>body</em>&gt;)
 &lt;<em>exp<sub>1</sub></em>&gt;
 <img src="book-Z-G-D-18.gif" border="0">
 &lt;<em>exp<sub><em>n</em></sub></em>&gt;)
</p>

<p class="orig" lang="en">Implement a syntactic transformation <tt>let-&gt;combination</tt> that
reduces evaluating <tt>let</tt> expressions to evaluating combinations of
the type shown above, and add the appropriate clause to <tt>eval</tt> to
handle <tt>let</tt> expressions.
</p>

<p class="trans" lang="ja">
<tt>let</tt> å¼ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ã‚’ã€ä¸Šã«ç¤ºã—ãŸç¨®é¡ã®ã‚³ãƒ³ãƒ“ãƒãƒ¼ã‚·ãƒ§ãƒ³ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ã¸ã¨å¸°ç€ã•ã›ã‚‹ã‚ˆã†ãªã€<tt>let-&gt;combination</tt> ã¨ã„ã†æ–‡æ³•ä¸Šã®å¤‰å½¢ã‚’å®Ÿè£…ã›ã‚ˆã€‚ãã—ã¦ã€<tt>let</tt> å¼ã‚’æ‰±ã†ãŸã‚ã«ã€<tt>eval</tt> ã«é©åˆ‡ãªç¯€ã‚’è¿½åŠ ã›ã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment"></span></p>

<p class="orig" lang="en">
<a name="%_thm_4.7"></a>
<b>Exercise 4.7.</b>  <a name="%_idx_4408"></a><a name="%_idx_4410"></a><a name="%_idx_4412"></a><tt>Let*</tt> is similar to <tt>let</tt>, except that the bindings of the <del><tt>let</tt></del> <ins><tt>let*</tt></ins> variables are performed sequentially from left to right, and each
binding is made in an environment in which all of the preceding
bindings are visible.  For example
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.7.</b> <tt>let*</tt> ã¯ <tt>let</tt> ã«ä¼¼ã¦ã„ã‚‹â€”â€”ãŸã ã—ã€<tt>let*</tt> å¤‰æ•°<span class="note"> (æ­£èª¤è¡¨ã«ã—ãŸãŒã£ã¦ä¿®æ­£ã—ãŸ) </span>ã®æŸç¸›ãŒå·¦ã‹ã‚‰å³ã¸é †ã«è¡Œã‚ã‚Œã€ã‹ã¤ã€ãã‚Œãã‚Œã®æŸç¸›ã¯ã€å…ˆè¡Œã™ã‚‹æŸç¸›ã™ã¹ã¦ãŒè¦‹ãˆã¦ã„ã‚‹ç’°å¢ƒã«ãŠã„ã¦ãªã•ã‚Œã‚‹ã€ã¨ã„ã†ç‚¹ã‚’é™¤ã„ã¦ã€‚
ãŸã¨ãˆã°ã€
</p>

<p class="lisp">(let* ((x 3)
       (y (+ x 2))
       (z (+ x y 5)))
  (* x z))
</p>

<p class="orig" lang="en">returns 39.  Explain how a <tt>let*</tt> expression can be rewritten as a
set of nested <tt>let</tt> expressions, and write a procedure <tt>let*-&gt;nested-lets</tt> that performs this transformation.  If we
have already implemented <tt>let</tt> (exercise <a href="#%_thm_4.6">4.6</a>)
and we want to
extend the evaluator to handle <tt>let*</tt>, is it sufficient to add
a clause to <tt>eval</tt> whose action is
</p>

<p class="trans" lang="ja">
ã¯39ã‚’è¿”ã™ã€‚<span class="note">(x=3, y=5, z=13ã¨ãªã‚‹ã‹ã‚‰ã€‚)</span>
ã©ã®ã‚ˆã†ã«ã—ãŸã‚‰ <tt>let*</tt> å¼ã‚’ã€å…¥ã‚Œå­ã«ãªã£ãŸä¸€æƒã„ã® <tt>let</tt> å¼ã¨ã—ã¦æ›¸ãç›´ã›ã‚‹ã®ã‹ã€èª¬æ˜ã›ã‚ˆã€‚ãã—ã¦ã€ã“ã®å¤‰å½¢ã‚’è¡Œã† <tt>let*-&gt;nested-lets</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’æ›¸ã‘ã€‚
ã‚‚ã—æ—¢ã« <tt>let</tt> ã‚’å®Ÿè£…ã—ã¦ã„ã¦ (ç·´ç¿’å•é¡Œ<a href="#%_thm_4.6">4.6</a>)ã€ã‹ã¤ã€<tt>let*</tt> ã‚’æ‰±ã†ã‚ˆã†ã«è©•ä¾¡å™¨ã‚’æ‹¡å¼µã—ãŸã„ã¨ã™ã‚‹ã¨ã€å‹•ä½œãŒä»¥ä¸‹ã®é€šã‚Šã§ã‚ã‚‹ã‚ˆã†ãªç¯€ã‚’ <tt>eval</tt> ã«è¿½åŠ ã™ã‚‹ã ã‘ã§ååˆ†ã ã‚ã†ã‹ã€
</p>

<p class="lisp">(eval (let*-&gt;nested-lets exp) env)
</p>

<p class="orig" lang="en">or must we
explicitly expand <tt>let*</tt> in terms of non-derived expressions?
</p>

<p class="trans" lang="ja">
ãã‚Œã¨ã‚‚ã€éæ´¾ç”Ÿå¼ã‚’ä½¿ã£ã¦æ˜ç¤ºçš„ã« <tt>let*</tt> ã‚’å±•é–‹ã›ã­ã°ãªã‚‰ãªã„ã®ã ã‚ã†ã‹?
</p>

<p class="exercise"><span class="ex_comment"></span></p>

<p class="orig" lang="en">
<a name="%_thm_4.8"></a>
<b>Exercise 4.8.</b>  <a name="%_idx_4414"></a><a name="%_idx_4416"></a><a name="%_idx_4418"></a><a name="%_idx_4420"></a>``Named <tt>let</tt>'' is a variant of <tt>let</tt> that has the form
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.8.</b> ã€Œåå‰ã¤ã <tt>let</tt>ã€ã¯ã€ä»¥ä¸‹ã®å½¢å¼ã‚’æœ‰ã™ã‚‹ã€<tt>let</tt> ã®å¤‰ç¨®ã§ã‚ã‚‹ã€‚
</p>

<p class="lisp">(let &lt;<em>var</em>&gt; &lt;<em>bindings</em>&gt; &lt;<em>body</em>&gt;)
</p>

<p class="orig" lang="en">The &lt;<em>bindings</em>&gt; and &lt;<em>body</em>&gt; are just as in ordinary <tt>let</tt>, except that &lt;<em>var</em>&gt; is bound within &lt;<em>body</em>&gt; to a
procedure whose body is &lt;<em>body</em>&gt; and whose parameters are the
variables in the &lt;<em>bindings</em>&gt;.  Thus, one can repeatedly execute the
&lt;<em>body</em>&gt; by invoking the procedure named &lt;<em>var</em>&gt;.  For example,
the iterative Fibonacci procedure (section <a href="11_sec1_2.html#%_sec_1.2.2">1.2.2</a>)
can be rewritten using named <tt>let</tt> as follows:
</p>

<p class="trans" lang="ja">
æœ¬ä½“ãŒ &lt;<em class="en">body</em>&gt; ã§ã‚ã‚Šä»®å¼•æ•°ãŒ &lt;<em class="en">bindings</em>&gt; å†…ã®å¤‰æ•°ã§ã‚ã‚‹ã‚ˆã†ãªæ‰‹ç¶šãã¸ã¨ã€&lt;<em class="en">var</em>&gt; ãŒ &lt;<em class="en">body</em>&gt; ã«ãŠã„ã¦æŸç¸›ã•ã‚Œã‚‹ã€ã¨ã„ã†ç‚¹ã‚’é™¤ã„ã¦ã€&lt;<em class="en">bindings</em>&gt; ã¨ &lt;<em class="en">body</em>&gt; ã¯å…ƒã€…ã® <tt>let</tt> ã¨ã¡ã‚‡ã†ã©åŒã˜ã§ã‚ã‚‹ã€‚
ã‚ˆã£ã¦ã€&lt;<em class="en">var</em>&gt; ã¨åä»˜ã‘ã‚‰ã‚ŒãŸæ‰‹ç¶šãã‚’å‘¼ã³å‡ºã™ã“ã¨ã«ã‚ˆã£ã¦ã€ç¹°ã‚Šè¿”ã— &lt;<em class="en">body</em>&gt; ã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ãŒå¯èƒ½ã ã€‚
ãŸã¨ãˆã°ã€åå¾©çš„ãªãƒ•ã‚£ãƒœãƒŠãƒƒãƒæ‰‹ç¶šã (<a href="11_sec1_2.html#%_sec_1.2.2">1.2.2</a>ç¯€) ã¯ã€åå‰ã¤ã <tt>let</tt> ã‚’ç”¨ã„ã¦ä»¥ä¸‹ã®ã‚ˆã†ã«æ›¸ãæ›ãˆã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_4422"></a>(define (fib n)
  (let fib-iter ((a 1)
                 (b 0)
                 (count n))
    (if (= count 0)
        b
        (fib-iter (+ a b) a (- count 1)))))
</p>

<p class="orig" lang="en">Modify <tt>let-&gt;combination</tt> of exercise <a href="#%_thm_4.6">4.6</a> to
also support named <tt>let</tt>.
</p>

<p class="trans" lang="ja">
åå‰ã¤ã <tt>let</tt> ã‚‚ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚ˆã†ã«ã€ç·´ç¿’å•é¡Œ<a href="#%_thm_4.6">4.6</a>ã® <tt>let-&gt;combination</tt> ã‚’ä¿®æ­£ã›ã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment"></span></p>

<p class="orig" lang="en">
<a name="%_thm_4.9"></a>
<b>Exercise 4.9.</b>  <a name="%_idx_4424"></a><a name="%_idx_4426"></a>Many languages support a variety of iteration constructs, such as <tt>do</tt>, <tt>for</tt>, <tt>while</tt>, and <tt>until</tt>.  In Scheme,
iterative processes can be expressed in terms of ordinary procedure
calls, so special iteration constructs provide no essential gain in
computational power.  On the other hand, such constructs are often
convenient.  Design some iteration constructs, give examples of their
use, and show how to implement them as derived expressions.
</p>


<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.9.</b> å¤šãã®è¨€èªã¯ã€<tt>do</tt> ã‚„ <tt>for</tt> ã‚„ <tt>while</tt> ã‚„ <tt>until</tt> ãªã©ã®ã€æ§˜ã€…ãªåå¾©æ§‹æˆã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã€‚
Schemeã§ã¯ã€åå¾©çš„ãƒ—ãƒ­ã‚»ã‚¹ã¯ã€æ™®é€šã®æ‰‹ç¶šãå‘¼ã³å‡ºã—ã‚’ä½¿ã£ã¦è¡¨ç¾ã™ã‚‹ã“ã¨ãŒå¯èƒ½ã§ã‚ã‚Šã€ãã®ãŸã‚ã€ç‰¹æ®Šãªåå¾©æ§‹æˆã¯ã€è¨ˆç®—èƒ½åŠ›ã«ãŠã„ã¦ä½•ã‚‚æœ¬è³ªçš„ãªé€²æ­©ã‚’ã‚‚ãŸã‚‰ã•ãªã„ã€‚
ä»–æ–¹ã€ãã†ã—ãŸæ§‹æˆã¯ã€ã—ã°ã—ã°ä¾¿åˆ©ã§ã‚ã‚‹ã€‚
ã„ãã¤ã‹ã®åå¾©æ§‹æˆã‚’è¨­è¨ˆã—ã€ãã®ä½¿ç”¨ä¾‹ã‚’ç¤ºã—ã€ãã‚Œã‚‰ã‚’æ´¾ç”Ÿå¼ã¨ã—ã¦å®Ÿè£…ã™ã‚‹æ–¹æ³•ã‚’ç¤ºã›ã€‚
</p>

<p class="exercise"><span class="ex_comment"></span></p>

<p class="orig" lang="en">
<a name="%_thm_4.10"></a>
<b>Exercise 4.10.</b>  <a name="%_idx_4428"></a><a name="%_idx_4430"></a>By using data abstraction, we were able to write an <tt>eval</tt>
procedure that is independent of the particular syntax of the language
to be evaluated.  To illustrate this, design and implement a new
syntax for Scheme by modifying the procedures in this section, without
changing <tt>eval</tt> or <tt>apply</tt>.


<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.10.</b> ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ã‚’ç”¨ã„ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€è©•ä¾¡ã•ã‚Œã‚‹ã¹ãè¨€èªã®ç‰¹å®šã®æ–‡æ³•ã¨ã¯ç‹¬ç«‹ã—ã¦ã„ã‚‹ <tt>eval</tt> æ‰‹ç¶šãã‚’æ›¸ãã“ã¨ã‚‚å¯èƒ½ã ã£ãŸã‚ã†ã€‚
ã“ã‚Œã‚’ä¾‹ç¤ºã™ã‚‹ãŸã‚ã«ã€<tt>eval</tt> ã‚‚ <tt>apply</tt> ã‚‚å¤‰æ›´ã›ãšã«æœ¬ç¯€ã®æ‰‹ç¶šãã‚’ä¿®æ­£ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€Schemeç”¨ã®æ–°ãŸãªæ–‡æ³•ã‚’è¨­è¨ˆãŠã‚ˆã³å®Ÿè£…ã›ã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment"></span></p>

<a name="%_sec_4.1.3"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_4.1.3">4.1.3  Evaluator Data Structures</a></h3>
<h3 class="trans" lang="ja">4.1.3 è©•ä¾¡å™¨ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ </h3>

<p class="orig" lang="en">
In addition to defining the external syntax of expressions, the
evaluator implementation must also define the data structures that the
evaluator manipulates internally, as part of the execution of a
program, such as the representation of procedures and environments and
the representation of true and false.</p>

<p class="trans" lang="ja">
å¼ã«ã¤ã„ã¦ã®å¤–éƒ¨çš„æ–‡æ³•ã‚’å®šç¾©ã™ã‚‹ã®ã«åŠ ãˆã¦ã€è©•ä¾¡å™¨ã®å®Ÿè£…ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®å®Ÿè¡Œã®ä¸€éƒ¨ã¨ã—ã¦è©•ä¾¡å™¨ãŒå†…éƒ¨çš„ã«æ“ä½œã™ã‚‹ãƒ‡ãƒ¼ã‚¿æ§‹é€ â€”â€”æ‰‹ç¶šãã¨ç’°å¢ƒã®è¡¨ç¾ã‚„ã€çœŸã¨å½ã®è¡¨ç¾ãªã©â€”â€”ã‚‚ã€å®šç¾©ã›ã­ã°ãªã‚‰ãªã„ã€‚
</p>


<a name="%_sec_Temp_541"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_541">Testing of predicates</a></h4>
<h4 class="trans" lang="ja">è¿°èªã®æ¤œæŸ»</h4>

<p class="orig" lang="en">
<a name="%_idx_4432"></a>For conditionals, we accept anything to be true that is not
the explicit <tt>false</tt> object.</p>

<p class="trans" lang="ja">
æ¡ä»¶å¼ã«ã¤ã„ã¦ã¯ã€æ˜ç¤ºçš„ãª <tt>false</tt> ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ãªã„ã‚‚ã®ã¯ä½•ã§ã‚‚ã€çœŸã¨èªã‚ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_4434"></a>(define (true? x)
  (not (eq? x false)))
<a name="%_idx_4436"></a>(define (false? x)
  (eq? x false))
</p>

<a name="%_sec_Temp_542"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_542">Representing procedures</a></h4>
<h4 class="trans" lang="ja">æ‰‹ç¶šãã‚’è¡¨ç¾ã™ã‚‹</h4>


<p class="orig" lang="en">
<a name="%_idx_4438"></a>
To handle primitives, we assume that we have available the
following procedures:</p>

<p class="trans" lang="ja">
ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã‚’æ‰±ã†ãŸã‚ã«ã€ç§ãŸã¡ã¯ã€ä»¥ä¸‹ã®æ‰‹ç¶šãã‚’åˆ©ç”¨å¯èƒ½ã«ã—ã¦ã‚ã‚‹ã‚‚ã®ã¨æƒ³å®šã™ã‚‹ã€‚
</p>

<ul class="orig" lang="en">
<li><a name="%_idx_4440"></a><tt>(apply-primitive-procedure &lt;<em>proc</em>&gt; &lt;<em>args</em>&gt;)</tt>
applies the given primitive procedure to the argument values in the
list &lt;<em>args</em>&gt; and returns the result of the application.</li>

<li><a name="%_idx_4442"></a><tt>(primitive-procedure? &lt;<em>proc</em>&gt;)</tt>
tests whether &lt;<em>proc</em>&gt; is a primitive procedure.</li>
</ul>

<ul class="trans" lang="ja">
<li><tt>(apply-primitive-procedure &lt;<em class="en">proc</em>&gt; &lt;<em class="en">args</em>&gt;)</tt>
ã¯ã€ä¸ãˆã‚‰ã‚ŒãŸåŸå§‹çš„æ‰‹ç¶šãã‚’ã€&lt;<em class="en">args</em>&gt; ã¨ã„ã†ãƒªã‚¹ãƒˆå†…ã®å®Ÿå¼•æ•°ã®å€¤ã¸ã¨é©ç”¨ã—ã€é©ç”¨ã®çµæœã‚’è¿”ã™ã€‚</li>
<li><tt>(primitive-procedure? &lt;<em class="en">proc</em>&gt;)</tt>
ã¯ã€&lt;<em class="en">proc</em>&gt; ãŒåŸå§‹çš„æ‰‹ç¶šãã‹å¦ã‹ã‚’èª¿ã¹ã‚‹ã€‚</li>
</ul>

<p class="orig" lang="en">
These mechanisms for handling primitives are further described in
section <a href="#%_sec_4.1.4">4.1.4</a>.</p>

<p class="trans" lang="ja">
ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã‚’æ‰±ã†ãŸã‚ã®ã“ã‚Œã‚‰ã®ä»•çµ„ã¿ã¯ã€<a href="#%_sec_4.1.4">4.1.4</a>ç¯€ã§ã•ã‚‰ã«èª¬æ˜ã•ã‚Œã‚‹ã€‚
</p>

<p class="orig" lang="en">
Compound procedures are constructed from parameters, procedure
bodies, and environments using the constructor <tt>make-procedure</tt>:</p>

<p class="trans" lang="ja">
è¤‡åˆçš„ãªæ‰‹ç¶šãã¯ã€ä»®å¼•æ•°ã¨æ‰‹ç¶šãæœ¬ä½“ã¨ç’°å¢ƒã‹ã‚‰ã€<tt>make-procedure</tt> ã¨ã„ã†ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’ç”¨ã„ã¦æ§‹ç¯‰ã•ã‚Œã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_4444"></a>(define (make-procedure parameters body env)
  (list 'procedure parameters body env))
<a name="%_idx_4446"></a>(define (compound-procedure? p)
  (tagged-list? p 'procedure))
<a name="%_idx_4448"></a>(define (procedure-parameters p) (cadr p))
<a name="%_idx_4450"></a>(define (procedure-body p) (caddr p))
<a name="%_idx_4452"></a>(define (procedure-environment p) (cadddr p))
</p>

<a name="%_sec_Temp_543"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_543">Operations on Environments</a></h4>
<h4 class="trans" lang="ja">ç’°å¢ƒã«å¯¾ã™ã‚‹æ“ä½œ</h4>

<p class="orig" lang="en">
<a name="%_idx_4454"></a>
The evaluator needs operations for manipulating environments.  As
explained in section <a href="21_sec3_2.html#%_sec_3.2">3.2</a>, an environment is a
sequence of frames, where each frame is a table of bindings that
associate variables with their corresponding values.  We use
the following operations for manipulating environments:</p>

<p class="trans" lang="ja">
è©•ä¾¡å™¨ã«ã¯ã€ç’°å¢ƒã‚’æ“ä½œã™ã‚‹ãŸã‚ã®æ¼”ç®—ãŒå¿…è¦ã ã€‚
<a href="21_sec3_2.html#%_sec_3.2">3.2</a>ç¯€ã§èª¬æ˜ã—ãŸã‚ˆã†ã«ã€ç’°å¢ƒã¨ã¯ä¸€é€£ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã§ã‚ã‚Šã€ã“ã“ã§å„ãƒ•ãƒ¬ãƒ¼ãƒ ã¯ã€å¤‰æ•°ã‚’ãã‚Œã«å¯¾å¿œã™ã‚‹å€¤ã«é–¢é€£ã¥ã‘ã‚‹æŸç¸›ã®è¡¨ã§ã‚ã‚‹ã€‚
ç§ãŸã¡ã¯ã€ç’°å¢ƒã‚’æ“ä½œã™ã‚‹ãŸã‚ã«ä»¥ä¸‹ã®æ¼”ç®—ã‚’ä½¿ã†ã€‚
</p>

<ul class="orig" lang="en">
<a name="%_idx_4456"></a><li><tt>(lookup-variable-value &lt;<em>var</em>&gt; &lt;<em>env</em>&gt;)</tt>
returns the value that is bound to the symbol &lt;<em>var</em>&gt; in the
environment &lt;<em>env</em>&gt;, or signals an error if the variable is unbound.</li>

<li><a name="%_idx_4458"></a><tt>(extend-environment &lt;<em>variables</em>&gt; &lt;<em>values</em>&gt; &lt;<em>base-env</em>&gt;)</tt>
returns a new environment, consisting of a new frame in which the
symbols in the list &lt;<em>variables</em>&gt; are bound to the corresponding
elements in the list &lt;<em>values</em>&gt;, where the enclosing environment is
the environment &lt;<em>base-env</em>&gt;.</li>

<li><a name="%_idx_4460"></a><tt>(define-variable! &lt;<em>var</em>&gt; &lt;<em>value</em>&gt; &lt;<em>env</em>&gt;)</tt>
adds to the first frame in the environment &lt;<em>env</em>&gt; a new binding that
associates the variable &lt;<em>var</em>&gt; with the value &lt;<em>value</em>&gt;.</li>

<li><a name="%_idx_4462"></a><tt>(set-variable-value! &lt;<em>var</em>&gt; &lt;<em>value</em>&gt; &lt;<em>env</em>&gt;)</tt>
changes the binding of the variable &lt;<em>var</em>&gt; in the environment &lt;<em>env</em>&gt;
so that the variable is now bound to the value &lt;<em>value</em>&gt;, or signals
an error if the variable is unbound.</li>
</ul>

<ul class="trans" lang="ja">
<li><tt>(lookup-variable-value &lt;<em class="en">var</em>&gt; &lt;<em class="en">env</em>&gt;)</tt>
ã¯ã€&lt;<em class="en">env</em>&gt; ã¨ã„ã†ç’°å¢ƒã«ãŠã„ã¦ &lt;<em class="en">var</em>&gt; ã¨ã„ã†è¨˜å·ã«æŸç¸›ã•ã‚Œã¦ã„ã‚‹å€¤ã‚’è¿”ã™ã€‚ã‚ã‚‹ã„ã¯ã€ã‚‚ã—ãã®å¤‰æ•°ãŒæŸç¸›ã•ã‚Œã¦ã„ãªã‘ã‚Œã°ã€ã‚¨ãƒ©ãƒ¼ã®åˆå›³ã‚’å‡ºã™ã€‚
</li>
<li><tt>(extend-environment &lt;<em class="en">variables</em>&gt; &lt;<em class="en">values</em>&gt; &lt;<em class="en">base-env</em>&gt;)</tt>
ã¯ã€æ–°ãŸãªç’°å¢ƒâ€”â€” &lt;<em class="en">variables</em>&gt; ã¨ã„ã†ãƒªã‚¹ãƒˆå†…ã®è¨˜å·ãŒã€&lt;<em class="en">values</em>&gt; ã¨ã„ã†ãƒªã‚¹ãƒˆå†…ã®å¯¾å¿œã™ã‚‹è¦ç´ ã«æŸç¸›ã•ã‚Œã¦ã„ã‚‹ã‚ˆã†ãªã€æ–°ãŸãªãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰ãªã‚Šã€å¤–å´ã‚’å›²ã†ç’°å¢ƒã¯ &lt;<em class="en">base-env</em>&gt; ã¨ã„ã†ç’°å¢ƒã§ã‚ã‚‹ã€ã¨ã„ã†ã‚‚ã®â€”â€”ã‚’è¿”ã™ã€‚
</li>
<li><tt>(define-variable! &lt;<em class="en">var</em>&gt; &lt;<em class="en">value</em>&gt; &lt;<em class="en">env</em>&gt;)</tt>
ã¯ã€&lt;<em class="en">var</em>&gt; ã¨ã„ã†å¤‰æ•°ã‚’ &lt;<em class="en">value</em>&gt; ã¨ã„ã†å€¤ã«é–¢é€£ã¥ã‘ã‚‹æ–°ãŸãªæŸç¸›ã‚’ã€&lt;<em class="en">env</em>&gt; ã¨ã„ã†ç’°å¢ƒå†…ã®æœ€åˆã®ãƒ•ãƒ¬ãƒ¼ãƒ ã«è¿½åŠ ã™ã‚‹ã€‚
</li>
<li><tt>(set-variable-value! &lt;<em class="en">var</em>&gt; &lt;<em class="en">value</em>&gt; &lt;<em class="en">env</em>&gt;)</tt>
ã¯ã€ &lt;<em class="en">env</em>&gt; ã¨ã„ã†ç’°å¢ƒå†…ã® &lt;<em class="en">var</em>&gt; ã¨ã„ã†å¤‰æ•°ã®æŸç¸›ã‚’ã€ã“ã®å¤‰æ•°ãŒä»Šã‹ã‚‰ã¯ &lt;<em class="en">value</em>&gt; ã¨ã„ã†å€¤ã«æŸç¸›ã•ã‚Œã‚‹ã‚ˆã†ã«ã€å¤‰æ›´ã™ã‚‹ã€‚ã‚ã‚‹ã„ã¯ã€ã‚‚ã—ãã®å¤‰æ•°ãŒæŸç¸›ã•ã‚Œã¦ã„ãªã‘ã‚Œã°ã€ã‚¨ãƒ©ãƒ¼ã®åˆå›³ã‚’å‡ºã™ã€‚
</li>
</ul>

<p class="orig" lang="en">
<a name="%_idx_4464"></a>To implement these operations we represent an environment as a list of
frames.  The enclosing environment of an environment is the <tt>cdr</tt> of
the list.  The empty environment is simply the empty list.</p>

<p class="trans" lang="ja">
ã“ã‚Œã‚‰ã®æ¼”ç®—ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã«ã€ãƒ•ãƒ¬ãƒ¼ãƒ ã®ãƒªã‚¹ãƒˆã¨ã—ã¦ç’°å¢ƒã‚’è¡¨ç¾ã™ã‚‹ã€‚
ã‚ã‚‹ç’°å¢ƒã®ã€å¤–å´ã‚’å›²ã†ç’°å¢ƒã¯ã€ãã®ãƒªã‚¹ãƒˆã® <tt>cdr</tt> ã§ã‚ã‚‹ã€‚
ç©ºã®ç’°å¢ƒã¯ã€å˜ã«ã€ç©ºãƒªã‚¹ãƒˆã§ã‚ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_4466"></a>(define (enclosing-environment env) (cdr env))
<a name="%_idx_4468"></a>(define (first-frame env) (car env))
(define the-empty-environment '())
</p>

<p class="orig" lang="en">Each frame of an environment is represented as a pair of lists: a list
of the variables bound in that frame and a list of the associated values.<a name="call_footnote_Temp_544" href="#footnote_Temp_544"><sup><small>14</small></sup></a>
</p>


<p class="trans" lang="ja">
ã‚ã‚‹ç’°å¢ƒã®ãã‚Œãã‚Œã®ãƒ•ãƒ¬ãƒ¼ãƒ ã¯ã€ãƒªã‚¹ãƒˆâ€”â€”ãã®ãƒ•ãƒ¬ãƒ¼ãƒ ã§æŸç¸›ã•ã‚Œã‚‹å¤‰æ•°ã®ãƒªã‚¹ãƒˆã¨ã€é–¢é€£ã¥ã‘ã‚‰ã‚ŒãŸå€¤ã®ãƒªã‚¹ãƒˆâ€”â€”ã®å¯¾ã¨ã—ã¦ã€è¡¨ç¾ã•ã‚Œã‚‹<a href="#footnote_Temp_544"><sup><small>14</small></sup></a>ã€‚
</p>

<p class="lisp"><a name="%_idx_4470"></a>(define (make-frame variables values)
  (cons variables values))
<a name="%_idx_4472"></a>(define (frame-variables frame) (car frame))
<a name="%_idx_4474"></a>(define (frame-values frame) (cdr frame))
<a name="%_idx_4476"></a>(define (add-binding-to-frame! var val frame)
  (set-car! frame (cons var (car frame)))
  (set-cdr! frame (cons val (cdr frame))))
</p>

<p class="orig" lang="en">
To extend an environment by a new frame that associates variables with
values, we make a frame consisting of the list of variables and the
list of values, and we adjoin this to the environment.  We signal
an error if the number of variables does not match the number of values.</p>

<p class="trans" lang="ja">
å¤‰æ•°ã‚’å€¤ã«é–¢é€£ã¥ã‘ã‚‹æ–°ãŸãªãƒ•ãƒ¬ãƒ¼ãƒ ã«ã‚ˆã£ã¦ç’°å¢ƒã‚’æ‹¡å¼µã™ã‚‹ãŸã‚ã«ã¯ã€å¤‰æ•°ã®ãƒªã‚¹ãƒˆã¨å€¤ã®ãƒªã‚¹ãƒˆã‹ã‚‰ãªã‚‹ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ä½œã‚Šã€ã“ã‚Œã‚’ç’°å¢ƒã«ä»˜ã‘åŠ ãˆã‚‹ã€‚
ã‚‚ã—ã€å¤‰æ•°ã®å€‹æ•°ãŒå€¤ã®å€‹æ•°ã¨ä¸€è‡´ã—ãªã‹ã£ãŸã‚‰ã€ã‚¨ãƒ©ãƒ¼ã®åˆå›³ã‚’é€ã‚‹ã€‚
</p>


<p class="lisp"><a name="%_idx_4478"></a>(define (extend-environment vars vals base-env)
  (if (= (length vars) (length vals))
      (cons (make-frame vars vals) base-env)
      (if (&lt; (length vars) (length vals))
          (error &quot;Too many arguments supplied&quot; vars vals)
          (error &quot;Too few arguments supplied&quot; vars vals))))
</p>

<p class="orig" lang="en">
To look up a variable in an environment, we scan the list of variables
in the first frame.  If we find the desired variable, we return
the corresponding element in the list of values.  If we do not find
the variable in the current frame, we search the enclosing environment,
and so on.  If we reach the empty environment, we signal an ``unbound
variable'' error.</p>

<p class="trans" lang="ja">
ç’°å¢ƒå†…ã§å¤‰æ•°ã‚’èª¿ã¹ã‚‹ãŸã‚ã«ã¯ã€æœ€åˆã®ãƒ•ãƒ¬ãƒ¼ãƒ ã§å¤‰æ•°ã®ãƒªã‚¹ãƒˆã‚’èµ°æŸ»ã™ã‚‹ã€‚
æ‰€æœ›ã®å¤‰æ•°ã‚’è¦‹ã¤ã‘ãŸã‚‰ã€å€¤ã®ãƒªã‚¹ãƒˆå†…ã®å¯¾å¿œã™ã‚‹è¦ç´ ã‚’è¿”ã™ã€‚
ç¾åœ¨ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã§ã¯ãã®å¤‰æ•°ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸã‚‰ã€å¤–å´ã‚’å›²ã†ç’°å¢ƒã‚’æ¢ç´¢ã—ã€ä»¥ä¸‹åŒæ§˜ã§ã‚ã‚‹ã€‚
ã‚‚ã—ç©ºã®ç’°å¢ƒã«ãŸã©ã‚Šç€ã„ãŸã‚‰ã€ã€ŒæœªæŸç¸›å¤‰æ•°ã€ã‚¨ãƒ©ãƒ¼ã®åˆå›³ã‚’å‡ºã™ã€‚
</p>

<p class="lisp"><a name="%_idx_4480"></a>(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (car vals))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error &quot;Unbound variable&quot; var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))
</p>


<p class="orig" lang="en">
To set a variable to a new value in a specified environment, we scan
for the variable, just as in <tt>lookup-variable-value</tt>, and change
the corresponding value when we find it.</p>

<p class="trans" lang="ja">
æŒ‡å®šã•ã‚ŒãŸç’°å¢ƒå†…ã§å¤‰æ•°ã‚’æ–°ãŸãªå€¤ã«è¨­å®šã™ã‚‹ã«ã¯ã€<tt>lookup-variable-value</tt> ã«ãŠã‘ã‚‹ã®ã¨ã¡ã‚‡ã†ã©åŒã˜ã‚ˆã†ã«ã—ã¦ã€ãã®å¤‰æ•°ã‚’æ±‚ã‚ã¦èµ°æŸ»ã—ã€ã‚‚ã—ãã®å¤‰æ•°ã‚’è¦‹ã¤ã‘ãŸã‚‰ã€å¯¾å¿œã™ã‚‹å€¤ã‚’å¤‰æ›´ã™ã‚‹ã€‚
</p>


<p class="lisp"><a name="%_idx_4482"></a>(define (set-variable-value! var val env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error &quot;Unbound variable -- SET!&quot; var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))
</p>

<p class="orig" lang="en">
To define a variable, we search the first frame for a binding for
the variable, and change the binding if it exists
(just as in <tt>set-variable-value!</tt>).  If no such binding
exists, we adjoin one to the first frame.</p>

<p class="trans" lang="ja">
å¤‰æ•°ã‚’å®šç¾©ã™ã‚‹ã«ã¯ã€ãã®å¤‰æ•°ã«ã¤ã„ã¦ã®æŸç¸›ã‚’æœ€åˆã®ãƒ•ãƒ¬ãƒ¼ãƒ ã«ãŠã„ã¦æ¢ã—ã€ã‚‚ã—ãã®å¤‰æ•°ãŒå­˜åœ¨ã™ã‚Œã°ã€æŸç¸›ã‚’å¤‰æ›´ã™ã‚‹ (<tt>set-variable-value!</tt> ã«ãŠã‘ã‚‹ã®ã¨ã¡ã‚‡ã†ã©åŒã˜ã‚ˆã†ã«ã™ã‚‹)ã€‚
ã‚‚ã—ãã®ã‚ˆã†ãªæŸç¸›ãŒå­˜åœ¨ã—ãªã‘ã‚Œã°ã€ãã®ã‚ˆã†ãªæŸç¸›ã‚’æœ€åˆã®ãƒ•ãƒ¬ãƒ¼ãƒ ã«ä»˜ã‘åŠ ãˆã‚‹ã€‚
</p>


<p class="lisp"><a name="%_idx_4484"></a>(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (define (scan vars vals)
      (cond ((null? vars)
             (add-binding-to-frame! var val frame))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (scan (frame-variables frame)
          (frame-values frame))))
</p>

<p class="orig" lang="en">
<a name="%_idx_4486"></a>The method described here is only one of many plausible ways to
represent environments.  Since we used data abstraction to isolate the
rest of the evaluator from the detailed choice of representation, we
could change the environment representation if we wanted to.  (See
exercise <a href="#%_thm_4.11">4.11</a>.)  In a
production-quality Lisp system, the speed of the evaluator's
environment operations -- especially that of variable lookup -- has a
major impact on the performance of the system.  The representation
described here, although conceptually simple, is not efficient and
would not ordinarily be used in a production system.<a name="call_footnote_Temp_545" href="#footnote_Temp_545"><sup><small>15</small></sup></a></p>

<p class="trans" lang="ja">
ã“ã“ã§èª¬æ˜ã—ãŸæ–¹æ³•ã¯ã€ç’°å¢ƒã‚’è¡¨ç¾ã™ã‚‹ãŸã‚ã®å¤šãã®ã‚‚ã£ã¨ã‚‚ã‚‰ã—ã„æ–¹æ³•ã®ã†ã¡ã®ä¸€ã¤ã«ã™ããªã„ã€‚
è¡¨ç¾ã«ã¤ã„ã¦ã®è©³ç´°ãªé¸æŠè‚¢ã‹ã‚‰ã€è©•ä¾¡å™¨ã®æ®‹ã‚Šã®éƒ¨åˆ†ã‚’åˆ‡ã‚Šé›¢ã™ãŸã‚ã«ã€ç§ãŸã¡ã¯ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ã‚’ä½¿ã£ãŸã®ã§ã€ã‚‚ã—æœ›ã‚€ãªã‚‰ç’°å¢ƒã®è¡¨ç¾ã‚’å¤‰ãˆã‚‹ã“ã¨ã‚‚ã§ããŸã ã‚ã† (ç·´ç¿’å•é¡Œ<a href="#%_thm_4.11">4.11</a>ã‚’å‚ç…§)ã€‚
è£½å“ãƒ¬ãƒ™ãƒ«ã®å“è³ªã®Lispã‚·ã‚¹ãƒ†ãƒ ã§ã¯ã€è©•ä¾¡å™¨ã®ç’°å¢ƒæ¼”ç®—ã®é€Ÿã•â€”â€”ã¨ã‚Šã‚ã‘ã€å¤‰æ•°ã‚’èª¿ã¹ã‚‹ã“ã¨ã®é€Ÿã•â€”â€”ãŒã€ã‚·ã‚¹ãƒ†ãƒ ã®æ€§èƒ½ã«å¯¾ã—ã¦å¤§ããªå½±éŸ¿ã‚’ä¸ãˆã‚‹ã€‚
ã“ã“ã§èª¬æ˜ã—ãŸè¡¨ç¾ã¯ã€æ¦‚å¿µçš„ã«ç°¡ç´ ã§ã¯ã‚ã‚‹ã®ã ãŒã€åŠ¹ç‡çš„ã§ã¯ãªãã€è£½å“ã‚·ã‚¹ãƒ†ãƒ ã§ã¯æ™®é€šã¯ä½¿ã‚ã‚Œãªã„ã§ã‚ã‚ã†<a href="#footnote_Temp_545"><sup><small>15</small></sup></a>ã€‚
</p>

<p class="orig" lang="en">
<a name="%_thm_4.11"></a>
<b>Exercise 4.11.</b>  Instead of representing a frame as a pair of lists, we can represent a
frame as a list of bindings, where each binding is a name-value pair.
Rewrite the environment operations to use this alternative
representation.
</p>


<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.11.</b> ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ãƒªã‚¹ãƒˆã®å¯¾ã¨ã—ã¦è¡¨ç¾ã™ã‚‹ä»£ã‚ã‚Šã«ã€ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’æŸç¸›ã®ãƒªã‚¹ãƒˆâ€”â€”ãŸã ã—ã€å„æŸç¸›ã¯ã€åå‰ã¨å€¤ã®å¯¾ã§ã‚ã‚‹â€”â€”ã¨ã—ã¦è¡¨ç¾ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
ã“ã®ä»£æ›¿è¡¨ç¾ã‚’ä½¿ã†ã‚ˆã†ã«ã€ç’°å¢ƒæ¼”ç®—ã‚’æ›¸ãç›´ã›ã€‚
</p>

<p class="exercise"><span class="ex_comment"></span></p>

<p class="orig" lang="en">
<a name="%_thm_4.12"></a>
<b>Exercise 4.12.</b>  The procedures <tt>set-variable-value!</tt>, <tt>define-variable!</tt>,
and <tt>lookup-variable-value</tt> can be expressed in terms of
more abstract procedures for traversing the environment structure.
Define abstractions that capture the common patterns and redefine
the three procedures in terms of these abstractions.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.12.</b>  <tt>set-variable-value!</tt> ã¨ <tt>define-variable!</tt> ã¨ <tt>lookup-variable-value</tt> ã¨ã„ã†æ‰‹ç¶šãã¯ã€ç’°å¢ƒæ§‹é€ ã‚’<ruby><rb>ãƒˆãƒ©ãƒãƒ¼ã‚¹ã™ã‚‹</rb><rp> (</rp><rt>ã‚ã¡ã“ã¡ã¿ã¦ã¾ã‚ã‚‹</rt><rp>) </rp></ruby>ãŸã‚ã®ã€ã‚ˆã‚ŠæŠ½è±¡çš„ãªæ‰‹ç¶šãã‚’ä½¿ã£ã¦è¡¨ã›ã‚‹ã€‚
å…±é€šã®ãƒ‘ã‚¿ãƒ³ã‚’ã¤ã‹ã¾ãˆã‚‹æŠ½è±¡æ¦‚å¿µã‚’å®šç¾©ã—ã€ã“ã®æŠ½è±¡æ¦‚å¿µã‚’ä½¿ã£ã¦ã€ä¸Šè¨˜ã®ä¸‰ã¤ã®æ‰‹ç¶šãã‚’å†å®šç¾©ã›ã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment"></span></p>

<p class="orig" lang="en">
<a name="%_thm_4.13"></a>
<b>Exercise 4.13.</b>  Scheme allows us to create new bindings for variables by means of <tt>define</tt>, but provides no way to get rid of bindings.  Implement for
the evaluator a special form <tt>make-unbound!</tt> that removes the
binding of a given symbol from the environment in which the
<tt>make-unbound!</tt> expression is evaluated.
This problem is not completely specified.  For example,
should we remove only the binding in the first frame of the
environment?  Complete the specification and justify any choices you
make.
</p>


<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.13.</b> Schemeã¯ã€<tt>define</tt> ã‚’ç”¨ã„ã¦å¤‰æ•°ã«å¯¾ã™ã‚‹æ–°ãŸãªæŸç¸›ã‚’ä½œæˆã™ã‚‹ã“ã¨ã‚’å¯èƒ½ã¨ã—ã¦ã„ã‚‹ãŒã€æŸç¸›ã‚’å–ã‚Šé™¤ããŸã‚ã®æ–¹æ³•ã¯ä½•ã‚‚æä¾›ã—ã¦ã„ãªã„ã€‚
<tt>make-unbound!</tt> ã¨ã„ã†ç‰¹æ®Šå½¢å¼â€”â€” <tt>make-unbound!</tt> å¼ãŒè©•ä¾¡ã•ã‚Œã‚‹ç’°å¢ƒã‹ã‚‰ã€ä¸ãˆã‚‰ã‚ŒãŸè¨˜å·ã®æŸç¸›ã‚’é™¤å»ã™ã‚‹ã‚‚ã®â€”â€”ã‚’ã€è©•ä¾¡å™¨ã®ãŸã‚ã«å®Ÿè£…ã›ã‚ˆã€‚
ã“ã®å•é¡Œã¯ã€å®Œå…¨ã«ä»•æ§˜ãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹ã‚ã‘ã§ã¯ãªã„ã€‚
ãŸã¨ãˆã°ã€ç’°å¢ƒã®æœ€åˆã®ãƒ•ãƒ¬ãƒ¼ãƒ å†…ã®æŸç¸›ã®ã¿ã‚’å–ã‚Šé™¤ãã¹ããªã®ã‹?
ä»•æ§˜ã‚’å®Œæˆã•ã›ã€å›ã®ãŠã“ãªã£ãŸã©ã®é¸æŠã«ã¤ã„ã¦ã‚‚ã€ãã‚ŒãŒæ­£ã—ã„ã“ã¨ã‚’ç¤ºã›ã€‚
</p>

<p class="exercise"><span class="ex_comment"></span></p>

<a name="%_sec_4.1.4"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_4.1.4">4.1.4  Running the Evaluator as a Program</a></h3>
<h3 class="trans" lang="ja">4.1.4 è©•ä¾¡å™¨ã‚’ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¨ã—ã¦å®Ÿè¡Œã™ã‚‹</h3>

<p class="orig" lang="en">
<a name="%_idx_4492"></a>
Given the evaluator, we have in our hands a description
(expressed in Lisp) of the process
by which Lisp expressions are evaluated.  One advantage of expressing the
evaluator as a program is that we can run the program.  This gives us,
running within Lisp, a working model of how Lisp itself evaluates
expressions.  This can serve as a framework for experimenting with
evaluation rules, as we shall do later in this chapter.</p>

<p class="trans" lang="ja">
è©•ä¾¡å™¨ãŒä¸ãˆã‚‰ã‚Œã‚‹ã¨ã€ç§ãŸã¡ã¯ã€Lispå¼ã‚’è©•ä¾¡ã™ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã®ã€(Lisp ã§è¡¨ç¾ã•ã‚ŒãŸ) èª¬æ˜æ›¸ã‚’æ‰‹ã«ã—ã¦ã„ã‚‹ã“ã¨ã«ãªã‚‹ã€‚
è©•ä¾¡å™¨ã‚’ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¨ã—ã¦è¡¨ã™ã“ã¨ã®ä¸€ã¤ã®åˆ©ç‚¹ã¯ã€ãã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’å®Ÿè¡Œã§ãã‚‹ç‚¹ã ã€‚
Lispå†…ã§<!--å®Ÿè¡Œã™ã‚‹ã¨-->å‹•ä½œã—ã¦ã„ã‚‹ã¨ãã€ã“ã‚Œã¯ã€Lispè‡ªä½“ãŒã©ã®ã‚ˆã†ã«ã—ã¦å¼ã‚’è©•ä¾¡ã™ã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã«ã¤ã„ã¦ã®ã€ãã¡ã‚“ã¨æ©Ÿèƒ½ã™ã‚‹ãƒ¢ãƒ‡ãƒ«ã‚’ä¸ãˆã¦ãã‚Œã‚‹ã€‚
ã“ã®ã“ã¨ã¯ã€è©•ä¾¡è¦å‰‡ã‚’ä½¿ã£ã¦å®Ÿé¨“ã‚’è¡Œã†ãŸã‚ã®æ çµ„ã¿ã¨ã—ã¦ã€å½¹ç«‹ã¤ã“ã¨ãŒã§ãã‚‹â€”â€”æœ¬ç« ã§å¾Œã«ç§ãŸã¡ãŒè¡Œã†ã“ã¨ã«ãªã‚‹ã¨ãŠã‚Šã«ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_4494"></a>Our evaluator program reduces expressions ultimately to the
application of primitive procedures.  Therefore, all that we need to
run the evaluator is to create a mechanism that calls on the underlying
Lisp system to model the application of primitive procedures.</p>

<p class="trans" lang="ja">
ç§ãŸã¡ã®è©•ä¾¡å™¨ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€å¼ã‚’ã€ç©¶æ¥µçš„ã«ã¯åŸå§‹çš„æ‰‹ç¶šãã®é©ç”¨ã«ã¾ã§é‚„å…ƒã™ã‚‹ã€‚
ã—ãŸãŒã£ã¦ã€è©•ä¾¡å™¨ã‚’å®Ÿè¡Œã™ã‚‹ãŸã‚ã«ç§ãŸã¡ãŒå¿…è¦ã¨ã—ã¦ã„ã‚‹ã“ã¨ã¯ã€ãŸã ã€æ ¹åº•ã«ã‚ã‚‹Lispã‚·ã‚¹ãƒ†ãƒ ã«å¯¾ã—ã¦ã€åŸå§‹çš„æ‰‹ç¶šãã®é©ç”¨ã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã—ã¦ãã‚Œã‚‹ã‚ˆã†ã«ä¾é ¼ã™ã‚‹ä»•çµ„ã¿ã‚’ä½œæˆã™ã‚‹ã“ã¨ã ã‘ãªã®ã ã€‚
</p>

<p class="orig" lang="en">
There must be a binding for each primitive procedure name, so that when
<tt>eval</tt> evaluates the operator of an application of a primitive, it
will find an object to pass to <tt>apply</tt>.  We thus set up a <a name="%_idx_4496"></a><a name="%_idx_4498"></a>global
environment that associates unique objects with the names of the
primitive procedures that can appear
in the expressions we will be evaluating.  The
global environment also includes bindings for the symbols <a name="%_idx_4500"></a><tt>true</tt> and
<tt>false</tt>, so that they can be used as variables in expressions
to be evaluated.</p>

<p class="trans" lang="ja">
ãã‚Œãã‚Œã®åŸå§‹çš„æ‰‹ç¶šãåã«å¯¾ã—ã¦æŸç¸›ãŒã‚ã‚‹ã¯ãšã§ã‚ã‚Šã€ãã®çµæœã€<tt>eval</tt> ã¯ã€ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã®é©ç”¨ã®æ¼”ç®—å­ã‚’è©•ä¾¡ã™ã‚‹ã¨ãã«ã€<tt>apply</tt> ã«æ¸¡ã™ã¹ãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¦‹ã¤ã‘ã‚‹ã“ã¨ã«ãªã‚‹ã ã‚ã†ã€‚
ã‚ˆã£ã¦ã€ç§ãŸã¡ãŒè©•ä¾¡ã—ã¦ã„ã‚‹ã§ã‚ã‚ã†å¼ã®ä¸­ã«ç¾ã‚Œã‚‹ã“ã¨ãŒå¯èƒ½ãªåŸå§‹çš„æ‰‹ç¶šãã®åå‰ã«ä¸€æ„ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’é–¢é€£ã¥ã‘ã‚‹å¤§åŸŸç’°å¢ƒã‚’ã€ç§ãŸã¡ã¯è¨­å®šã™ã‚‹ã€‚
å¤§åŸŸç’°å¢ƒã¯ã€<tt>true</tt> ãŠã‚ˆã³ <tt>false</tt> ã¨ã„ã†è¨˜å·ã«å¯¾ã™ã‚‹æŸç¸›ã‚‚å«ã¿ã€ãã®çµæœã€ãã‚Œã‚‰ã®è¨˜å·ã‚’ã€è©•ä¾¡ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹å¼ã®ä¸­ã§å¤‰æ•°ã¨ã—ã¦ä½¿ã†ã“ã¨ãŒå¯èƒ½ã¨ãªã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_4502"></a>(define (setup-environment)
  (let ((initial-env
         (extend-environment (primitive-procedure-names)
                             (primitive-procedure-objects)
                             the-empty-environment)))
    (define-variable! 'true true initial-env)
    (define-variable! 'false false initial-env)
    initial-env))
<a name="%_idx_4504"></a>(define the-global-environment (setup-environment))
</p>

<p class="orig" lang="en">
It does not matter how we represent the primitive procedure objects,
so long as <tt>apply</tt> can identify and apply them by using the
procedures <tt>primitive-procedure?</tt> and <tt>apply-primitive-procedure</tt>.  We have chosen to represent a primitive
procedure as a list beginning with the symbol <tt>primitive</tt> and
containing a procedure in the underlying Lisp that implements that primitive.</p>

<p class="trans" lang="ja">
åŸå§‹çš„æ‰‹ç¶šãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã©ã®ã‚ˆã†ã«è¡¨ç¾ã™ã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã¯ã€<tt>primitive-procedure?</tt> ãŠã‚ˆã³ <tt>apply-primitive-procedure</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’ä½¿ã£ã¦ <tt>apply</tt> ãŒãã‚Œã‚‰åŸå§‹çš„æ‰‹ç¶šãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è­˜åˆ¥ã—ã¦é©ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã‚‹é™ã‚Šã«ãŠã„ã¦ã€é‡è¦ã§ã¯ãªã„ã€‚
ç§ãŸã¡ã¯åŸå§‹çš„æ‰‹ç¶šãã‚’ã€<tt>primitive</tt> ã¨ã„ã†è¨˜å·ã§å§‹ã¾ã‚Šã€ã‹ã¤ã€ãã®ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ã€æ ¹åº•ã«ã‚ã‚‹Lispã§ã®æ‰‹ç¶šãã‚’å«ã‚“ã§ã„ã‚‹ã‚ˆã†ãªãƒªã‚¹ãƒˆã¨ã—ã¦ã€è¡¨ç¾ã™ã‚‹ã“ã¨ã‚’é¸ã‚“ã ã€‚
</p>

<p class="lisp"><a name="%_idx_4506"></a>(define (primitive-procedure? proc)
  (tagged-list? proc 'primitive))

<a name="%_idx_4508"></a>(define (primitive-implementation proc) (cadr proc))
</p>


<p class="orig" lang="en">
<tt>Setup-environment</tt> will get the primitive names and implementation
procedures from a list:<a name="call_footnote_Temp_549" href="#footnote_Temp_549"><sup><small>16</small></sup></a></p>

<p class="trans" lang="ja">
<tt>setup-environment</tt> ã¯ã€ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–åã¨å®Ÿè£…æ‰‹ç¶šãã¨ã‚’ãƒªã‚¹ãƒˆã‹ã‚‰å–å¾—ã™ã‚‹ã ã‚ã†<a href="#footnote_Temp_549"><sup><small>16</small></sup></a>ã€‚
</p>

<p class="lisp">(define primitive-procedures
  (list (list 'car car)
        (list 'cdr cdr)
        (list 'cons cons)
        (list 'null? null?)
        &lt;<em>more primitives</em>&gt;
        ))
<a name="%_idx_4510"></a>(define (primitive-procedure-names)
  (map car
       primitive-procedures))

(define (primitive-procedure-objects)
<a name="%_idx_4512"></a>  (map (lambda (proc) (list 'primitive (cadr proc)))
       primitive-procedures))
</p>

<p class="orig" lang="en">
To apply a primitive procedure, we simply apply the implementation
procedure to the arguments, using the underlying Lisp system:<a name="call_footnote_Temp_550" href="#footnote_Temp_550"><sup><small>17</small></sup></a></p>

<p class="trans" lang="ja">
åŸå§‹çš„æ‰‹ç¶šãã‚’é©ç”¨ã™ã‚‹ãŸã‚ã«ã¯ã€å˜ã«ã€æ ¹åº•ã«ã‚ã‚‹Lispã‚·ã‚¹ãƒ†ãƒ ã‚’ä½¿ã£ã¦ã€å®Ÿè£…æ‰‹ç¶šãã‚’å®Ÿå¼•æ•°ã«é©ç”¨ã™ã‚‹<a href="#footnote_Temp_550"><sup><small>17</small></sup></a>ã€‚
</p>

<p class="lisp"><a name="%_idx_4514"></a>(define (apply-primitive-procedure proc args)
  (apply-in-underlying-scheme
   (primitive-implementation proc) args))
</p>


<p class="orig" lang="en">
<a name="%_idx_4516"></a><a name="%_idx_4518"></a>For convenience in running the metacircular evaluator, we provide a <em>driver loop</em> that models the read-eval-print loop of the underlying
Lisp system.  It prints a <a name="%_idx_4520"></a><em>prompt</em>, reads an input expression,
evaluates this expression in the global environment, and prints the
result.  We precede each printed result by an <em>output prompt</em> so
as to distinguish the value of the expression from other
output that may be printed.<a name="call_footnote_Temp_551" href="#footnote_Temp_551"><sup><small>18</small></sup></a></p>

<p class="trans" lang="ja">
ãƒ¡ã‚¿å¾ªç’°çš„ãªè©•ä¾¡å™¨ã‚’å®Ÿè¡Œã™ã‚‹ä¾¿å®œä¸Šã€ç§ãŸã¡ã¯ã€æ ¹åº•ã«ã‚ã‚‹Lispã‚·ã‚¹ãƒ†ãƒ ã®<ruby><rb>èª­ã¿è¾¼ã¿ãƒ»è©•ä¾¡ãƒ»å°å­—</rb><rp> (</rp><rt>read - eval - print</rt><rp>) </rp></ruby>ãƒ«ãƒ¼ãƒ—ã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã™ã‚‹<em>ãƒ‰ãƒ©ã‚¤ãƒãƒ»ãƒ«ãƒ¼ãƒ—</em>ã‚’æä¾›ã™ã‚‹ã€‚
ã“ã‚Œã¯ã€<em>ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ</em>ã‚’å°å­—ã—ã€å…¥åŠ›å¼ã‚’èª­ã¿è¾¼ã¿ã€ã“ã®å¼ã‚’å¤§åŸŸç’°å¢ƒå†…ã§è©•ä¾¡ã—ã€ãã®çµæœã‚’å°å­—ã™ã‚‹ã€‚
ãã®å¼ã®å€¤ã‚’ã€å°å­—ã•ã‚Œã‚‹å¯èƒ½æ€§ã®ã‚ã‚‹ä»–ã®å‡ºåŠ›ã¨ã¯åŒºåˆ¥ã™ã‚‹ã‚ˆã†ã«ã€ãã‚Œãã‚Œã®å°å­—ã•ã‚Œã‚‹çµæœã«å…ˆç«‹ã£ã¦ã€<em>å‡ºåŠ›ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ</em>ã‚’ç½®ã<a href="#footnote_Temp_551"><sup><small>18</small></sup></a>ã€‚
</p>


<p class="lisp"><a name="%_idx_4530"></a>(define input-prompt &quot;;;; M-Eval input:&quot;)
(define output-prompt &quot;;;; M-Eval value:&quot;)
<a name="%_idx_4532"></a>(define (driver-loop)
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (let ((output (eval input the-global-environment)))
      (announce-output output-prompt)
      (user-print output)))
  (driver-loop))
<a name="%_idx_4534"></a>(define (prompt-for-input string)
  (newline) (newline) (display string) (newline))

<a name="%_idx_4536"></a>(define (announce-output string)
  (newline) (display string) (newline))
</p>

<p class="orig" lang="en">We use a special printing procedure, <tt>user-print</tt>, to avoid printing the
environment part of a compound procedure, which may be a very long list
(or may even contain cycles).</p>

<p class="trans" lang="ja">
è¤‡åˆçš„ãªå¼ã®ã†ã¡ã®ç’°å¢ƒã®éƒ¨åˆ†â€”â€”éå¸¸ã«é•·ã„ãƒªã‚¹ãƒˆã§ã‚ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ (ã‚ã‚‹ã„ã¯ã€å¾ªç’°ã‚’å«ã‚€ã“ã¨ã•ãˆã‚ã‚Šå¾—ã‚‹) â€”â€”ã‚’å°å­—ã™ã‚‹ã“ã¨ã‚’é¿ã‘ã‚‹ãŸã‚ã«ã€ç‰¹æ®Šãªå°å­—æ‰‹ç¶šãâ€”â€”ã™ãªã‚ã¡ã€<tt>user-print</tt> â€”â€”ã‚’ä½¿ã†ã€‚
</p>

<p class="lisp"><a name="%_idx_4538"></a>(define (user-print object)
  (if (compound-procedure? object)
      (display (list 'compound-procedure
                     (procedure-parameters object)
                     (procedure-body object)
                     '&lt;procedure-env&gt;))
      (display object)))
</p>

<p class="orig" lang="en">
Now all we need to do to run the evaluator is to initialize the
global environment and start the driver loop.  Here is a sample
interaction:</p>

<p class="trans" lang="ja">
ã•ã¦ä»Šã‚„ã€è©•ä¾¡å™¨ã‚’å®Ÿè¡Œã™ã‚‹ãŸã‚ã«ã›ã­ã°ãªã‚‰ãªã„ã“ã¨ã¯ã€ãŸã ã€å¤§åŸŸç’°å¢ƒã‚’åˆæœŸåŒ–ã—ã¦ãƒ‰ãƒ©ã‚¤ãƒãƒ»ãƒ«ãƒ¼ãƒ—ã‚’é–‹å§‹ã•ã›ã‚‹ã“ã¨ã®ã¿ã§ã‚ã‚‹ã€‚
ã“ã“ã«ä¾‹ç¤ºã®ã‚„ã‚Šã¨ã‚Šã‚’ç¤ºã™ã€‚
</p>


<p class="lisp">(define the-global-environment (setup-environment))
(driver-loop)
<i>;;; M-Eval input:</i>
(define (append x y)
  (if (null? x)
      y
      (cons (car x)
            (append (cdr x) y))))
<i>;;; M-Eval value:</i>
<i>ok</i>
<i>;;; M-Eval input:</i>
(append '(a b c) '(d e f))
<i>;;; M-Eval value:</i>
<i>(a b c d e f)</i>
</p>


<p class="orig" lang="en">
<a name="%_thm_4.14"></a>
<b>Exercise 4.14.</b>  Eva Lu Ator and Louis Reasoner are each experimenting with the
metacircular evaluator.  Eva types in the definition of <tt>map</tt>, and
runs some test programs that use it.  They work fine.  Louis, in contrast,
has installed the system version of <tt>map</tt> as a primitive for the
metacircular evaluator.  When he tries it, things go terribly
wrong.  Explain why Louis's <tt>map</tt> fails even though Eva's works.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.14.</b> ã‚¨ãƒ´ã‚¡ãƒ»ãƒªãƒ¥ãƒ»ã‚¨ã‚¤ã‚¿ã¨ãƒ«ã‚¤ã‚¹ãƒ»ãƒªãƒ¼ã‚ºãƒŠã¯ã€å„ã€…ã€ãƒ¡ã‚¿å¾ªç’°çš„ãªè©•ä¾¡å™¨ã‚’ä½¿ã£ã¦å®Ÿé¨“ã‚’ã—ã¦ã„ã‚‹ã¨ã“ã‚ã ã€‚
ã‚¨ãƒ´ã‚¡ã¯ <tt>map</tt> ã®å®šç¾©ã‚’æ‰“ã¡è¾¼ã¿ã€ãã‚Œã‚’ä½¿ã†ã„ãã¤ã‹ã®ãƒ†ã‚¹ãƒˆãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’å®Ÿè¡Œã™ã‚‹ã€‚
ãã‚Œã‚‰ã®ãƒ†ã‚¹ãƒˆãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã†ã¾ãå‹•ãã€‚
ä¸€æ–¹ã€ãƒ«ã‚¤ã‚¹ã¯ãƒ¡ã‚¿å¾ªç’°çš„ãªè©•ä¾¡å™¨ç”¨ã®ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã¨ã—ã¦ã€ã‚·ã‚¹ãƒ†ãƒ ç‰ˆã® <tt>map</tt> ã‚’å–ã‚Šå…¥ã‚ŒãŸã€‚
ãƒ«ã‚¤ã‚¹ãŒãã® <tt>map</tt> ã‚’è©¦ã—ã¦ã¿ã‚‹ã¨ã€çŠ¶æ³ã¯ã²ã©ãã¾ãšããªã£ã¦ã—ã¾ã†ã€‚
ãªãœã€ã‚¨ãƒ´ã‚¡ã® <tt>map</tt> ãŒã†ã¾ãæ©Ÿèƒ½ã™ã‚‹ã«ã‚‚ã‹ã‹ã‚ã‚‰ãšã€ãƒ«ã‚¤ã‚¹ã® <tt>map</tt> ã¯ã†ã¾ãã„ã‹ãªã„ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’èª¬æ˜ã›ã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment"></span></p>


<a name="%_sec_4.1.5"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_4.1.5">4.1.5  Data as Programs</a></h3>
<h3 class="trans" lang="ja">4.1.5 ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¨ã—ã¦ã®ãƒ‡ãƒ¼ã‚¿</h3>

<p class="orig" lang="en">
<a name="%_idx_4540"></a><a name="%_idx_4542"></a>
In thinking about a Lisp program that evaluates Lisp expressions, an
analogy might be helpful.  One operational view of the meaning of a
program is that a <a name="%_idx_4544"></a>program is a description of an abstract (perhaps
infinitely large) machine.  For example, consider the familiar
program to compute factorials:</p>


<p class="trans" lang="ja">
Lispå¼ã‚’è©•ä¾¡ã™ã‚‹Lispãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ã¤ã„ã¦è€ƒãˆã‚‹éš›ã€é¡æ¨ãŒå½¹ç«‹ã¤ã‹ã‚‚ã—ã‚Œãªã„ã€‚
ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®æ„å‘³ã«ã¤ã„ã¦ã®ä¸€ã¤ã®æ“ä½œçš„ãªè¦‹æ–¹ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¨ã¯æŠ½è±¡çš„ãª (ãŠãã‚‰ãã¯ç„¡é™ã«å¤§ãã„) æ©Ÿæ¢°ã®èª¬æ˜æ›¸ãªã®ã ã€ã¨ã„ã†ã‚‚ã®ã§ã‚ã‚‹ã€‚
ãŸã¨ãˆã°ã€éšä¹—ã‚’è¨ˆç®—ã™ã‚‹ãŸã‚ã®ãŠãªã˜ã¿ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’è€ƒãˆã‚ˆã†ã€‚
</p>


<p class="lisp">(define (factorial n)
  (if (= n 1)
      1
      (* (factorial (- n 1)) n)))
</p>


<p class="orig" lang="en"><a name="%_idx_4546"></a>We may regard this program as the description of a machine containing
parts that decrement, multiply, and test for equality, together with a
two-position switch and another factorial machine. (The factorial
machine is infinite because it contains another factorial machine
within it.)  Figure <a href="#%_fig_4.2">4.2</a> is a flow diagram for the
factorial machine, showing how the parts are wired together.</p>

<p class="trans" lang="ja">
ç§ãŸã¡ã¯ã€ã“ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ã€ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã‚’è¡Œã†éƒ¨åˆ†ã¨ã€ä¹—ç®—ã‚’è¡Œã†éƒ¨åˆ†ã¨ã€ç­‰ä¾¡æ€§ã‚’æ¤œæŸ»ã™ã‚‹éƒ¨åˆ†ã¨ã‚’å«ã‚€æ©Ÿæ¢°â€”â€”äºŒã¤ã®ä½ç½®ãŒã‚ã‚‹ã‚¹ã‚¤ãƒƒãƒã¨ã€ã‚‚ã†ä¸€ã¤ã®éšä¹—æ©Ÿæ¢°ã‚‚å«ã‚€â€”â€”ã®ã€èª¬æ˜æ›¸ã ã¨è¦‹ãªã—ã¦ã‚‚ã‚ˆã„ã®ã 
(éšä¹—æ©Ÿæ¢°ã¯ã€ãã®ä¸­ã«åˆ¥ã®éšä¹—æ©Ÿæ¢°ã‚’å«ã‚€ã®ã§ã€ç„¡é™ã§ã‚ã‚‹)ã€‚
å›³<a href="#%_fig_4.2">4.2</a>ã¯ã€éšä¹—æ©Ÿæ¢°ã®ãŸã‚ã®æµã‚Œå›³ã§ã‚ã‚Šã€éƒ¨åˆ†åŒå£«ãŒã©ã®ã‚ˆã†ã«é…ç·šã•ã‚Œã¦ç¹‹ãŒã‚Œã‚‹ã®ã‹ã‚’ç¤ºã—ã¦ã„ã‚‹ã€‚
</p>

<a name="%_fig_4.2"></a>
<figure>
<img src="ch4-Z-G-2.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 4.2:</b>  The factorial program, viewed as an abstract machine.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³4.2:</b> æŠ½è±¡çš„æ©Ÿæ¢°ã¨ã—ã¦è¦‹ãŸéšä¹—ãƒ—ãƒ­ã‚°ãƒ©ãƒ </figcaption>
</figure>

<p class="orig" lang="en">
<a name="%_idx_4548"></a>In a similar way, we can regard the evaluator as a very special
machine that takes as input a description of a machine.  Given this
input, the evaluator configures itself to emulate the machine
described.  For example, if we feed our evaluator the definition of
<tt>factorial</tt>, as shown in figure <a href="#%_fig_4.3">4.3</a>, the
evaluator will be able to compute factorials.</p>

<p class="trans" lang="ja">
åŒæ§˜ã«ã—ã¦ã€è©•ä¾¡å™¨ã®ã“ã¨ã‚’ã€æ©Ÿæ¢°ã®èª¬æ˜æ›¸ã‚’å…¥åŠ›ã¨ã—ã¦å–ã‚‹ã‚ˆã†ãªéå¸¸ã«ç‰¹æ®Šãªæ©Ÿæ¢°ã ã€ã¨è¦‹ãªã™ã“ã¨ãŒå¯èƒ½ã ã€‚
ã“ã®<span class="note"> (æ©Ÿæ¢°ã®èª¬æ˜æ›¸ã¨ã„ã†) </span>å…¥åŠ›ãŒä¸ãˆã‚‰ã‚Œã‚‹ã¨ã€è©•ä¾¡å™¨ã¯ã€è¨˜è¿°ã•ã‚ŒãŸæ©Ÿæ¢°ã‚’<ruby><rb>æ¨¡å€£</rb><rp> (</rp><rt>ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ</rt><rp>) </rp></ruby>ã™ã‚‹ã‚ˆã†ã«ã€è‡ªåˆ†è‡ªèº«ã‚’æ§‹æˆã™ã‚‹ã€‚
ãŸã¨ãˆã°ã€ã‚‚ã—ã€å›³<a href="#%_fig_4.3">4.3</a>ã«ç¤ºã™ã‚ˆã†ã«ã€ç§ãŸã¡ã®è©•ä¾¡å™¨ã« <tt>factorial</tt> ã®å®šç¾©ã‚’ä¸ãˆãŸã‚‰ã€è©•ä¾¡å™¨ã¯éšä¹—ã‚’è¨ˆç®—ã§ãã‚‹ã‚ˆã†ã«ãªã‚‹ã ã‚ã†ã€‚
</p>

<a name="%_fig_4.3"></a>
<figure>
<img src="ch4-Z-G-3.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 4.3:</b>  The evaluator emulating a factorial machine.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³4.3:</b> éšä¹—æ©Ÿæ¢°ã‚’ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã™ã‚‹è©•ä¾¡å™¨</figcaption>
</figure>

<p class="orig" lang="en">
<a name="%_idx_4550"></a><a name="%_idx_4552"></a>From this perspective, our evaluator is seen to be a <em>universal machine</em>.
It mimics other machines when these are described as Lisp programs.<a name="call_footnote_Temp_553" href="#footnote_Temp_553"><sup><small>19</small></sup></a>
This is striking. Try to imagine an analogous evaluator for electrical
circuits.  This would be a circuit that takes as input a signal
encoding the plans for some other circuit, such as a filter.  Given
this input, the circuit evaluator would then behave like a filter with
the same description.  Such a universal electrical circuit is
almost unimaginably complex.  It is remarkable that the program
evaluator is a rather simple program.<a name="call_footnote_Temp_554" href="#footnote_Temp_554"><sup><small>20</small></sup></a></p>

<p class="trans" lang="ja">
ã“ã®è¦³ç‚¹ã‹ã‚‰ã™ã‚‹ã¨ã€ç§ãŸã¡ã®è©•ä¾¡å™¨ã¯ã€<em>æ™®éæ©Ÿæ¢°</em>ã ã¨è¦‹ãªã•ã‚Œã‚‹ã€‚
ä»–ã®æ©Ÿæ¢°ãŒLispãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¨ã—ã¦è¨˜è¿°ã•ã‚Œã‚‹ã¨ã€æ™®éæ©Ÿæ¢°ã¯ã€ãã‚Œã‚‰ã®ä»–ã®æ©Ÿæ¢°ã‚’ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã™ã‚‹<a href="#footnote_Temp_553"><sup><small>19</small></sup></a>ã€‚
ã“ã‚Œã¯é­…åŠ›çš„ã ã€‚
é›»æ°—å›è·¯ã«ã¤ã„ã¦ã®é¡ä¼¼ã®è©•ä¾¡å™¨ã‚’æƒ³åƒã—ã‚ˆã†ã¨ã—ã¦ã¿ãŸã¾ãˆã€‚
ã“ã‚Œã¯ã€ãŸã¨ãˆã°ãƒ•ã‚£ãƒ«ã‚¿ãªã©ã®ä»–ã®ä½•ã‚‰ã‹ã®å›è·¯ã®é…ç½®å›³é¢ã‚’ç¬¦å·åŒ–ã—ã¦ã„ã‚‹ä¿¡å·ã‚’å…¥åŠ›ã¨ã—ã¦ã¨ã‚‹å›è·¯ã§ã‚ã‚ã†ã€‚
ã“ã®å…¥åŠ›ãŒä¸ãˆã‚‰ã‚Œã‚‹ã¨ã€å›è·¯è©•ä¾¡å™¨ã¯ã€åŒã˜èª¬æ˜æ›¸ã®ä»˜ã„ãŸãƒ•ã‚£ãƒ«ã‚¿ã¨åŒæ§˜ã«æŒ¯ã‚‹èˆã†ã“ã¨ã ã‚ã†ã€‚
ãã†ã—ãŸæ™®éçš„ãªé›»æ°—å›è·¯ã¯ã€ã»ã¨ã‚“ã©æƒ³åƒã§ããªã„ãã‚‰ã„è¤‡é›‘ã§ã‚ã‚‹ã€‚
<span class="note">(ã§ã‚‚ã¾ã‚FPGAã¨ã‹ãã‚“ãªæ„Ÿã˜ãªã®ã§ã¯?)</span>
ãƒ—ãƒ­ã‚°ãƒ©ãƒ è©•ä¾¡å™¨ãŒã‹ãªã‚Šå˜ç´”ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã‚ã‚‹ã¨ã„ã†ã“ã¨ã¯ã€é©šãã¹ãã“ã¨ã§ã‚ã‚‹<a href="#footnote_Temp_554"><sup><small>20</small></sup></a>ã€‚
</p>

<p class="orig" lang="en">
Another striking aspect of the evaluator is that it acts as a bridge
between the data objects that are manipulated by our programming
language and the programming language itself.  Imagine that the
evaluator program (implemented in Lisp) is running, and that a user is
typing expressions to the evaluator and observing the results.  From
the perspective of the user, an input expression such as <tt>(* x x)</tt>
is an expression in the programming language, which the evaluator
should execute.  From the perspective of the evaluator, however, the
expression is simply a list (in this case, a list of three symbols:
<tt>*</tt>, <tt>x</tt>, and <tt>x</tt>) that is to be manipulated according to
a well-defined set of rules.</p>

<p class="trans" lang="ja">
è©•ä¾¡å™¨ã®åˆ¥ã®é­…åŠ›çš„ãªå´é¢ã¯ã€è©•ä¾¡å™¨ãŒã€ç§ãŸã¡ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã«ã‚ˆã‚Šæ“ä½œã•ã‚Œã‚‹ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªè‡ªä½“ã¨ã®é–“ã®æ¶ã‘æ©‹ã¨ã—ã¦ã¯ãŸã‚‰ãã€ã¨ã„ã†ã“ã¨ã§ã‚ã‚‹ã€‚
è©•ä¾¡å™¨ãƒ—ãƒ­ã‚°ãƒ©ãƒ  (Lispã§å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹) ãŒå®Ÿè¡Œä¸­ã§ã‚ã‚Šã€ãƒ¦ãƒ¼ã‚¶ãŒã€ãã®è©•ä¾¡å™¨ã«å¯¾ã—ã¦å¼ã‚’æ‰“ã¡è¾¼ã‚“ã§çµæœã‚’è¦³å¯Ÿã—ã¦ã„ã‚‹ã¨ã“ã‚ã§ã‚ã‚‹ã€ã¨æƒ³åƒã›ã‚ˆã€‚
ãƒ¦ãƒ¼ã‚¶ã®è¦–ç‚¹ã‹ã‚‰ã™ã‚‹ã¨ã€<tt>(* x x)</tt> ã¨ã„ã£ãŸå…¥åŠ›å¼ã¯ã€ãã®ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã§ã®å¼ã§ã‚ã‚Šã€è©•ä¾¡å™¨ãŒå®Ÿè¡Œã™ã¹ãã‚‚ã®ã§ã‚ã‚‹ã€‚
ã—ã‹ã—ã€è©•ä¾¡å™¨ã®è¦–ç‚¹ã‹ã‚‰ã™ã‚‹ã¨ã€ãã®å¼ã¯å˜ã«ã€ãã¡ã‚“ã¨å®šç¾©ã•ã‚ŒãŸä¸€æƒã„ã®è¦å‰‡ã«ã—ãŸãŒã£ã¦æ“ä½œã•ã‚Œã‚‹ã¹ããƒªã‚¹ãƒˆ (ã“ã“ã§ã¯ã€ä¸‰ã¤ã®è¨˜å·ã€ã™ãªã‚ã¡ã€<tt>*</tt> ã¨ <tt>x</tt> ã¨ <tt>x</tt> ã®ãƒªã‚¹ãƒˆ) ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
That the user's programs are the evaluator's data need not be a source
of confusion.  In fact, it is sometimes convenient to ignore this
distinction, and to give the user the ability to explicitly evaluate a
data object as a Lisp expression, by making <tt>eval</tt> available for
use in programs.  Many Lisp dialects provide a <a name="%_idx_4572"></a><a name="%_idx_4574"></a>primitive <tt>eval</tt>
procedure that takes as arguments an expression and an environment and
evaluates the expression relative to the environment.<a name="call_footnote_Temp_555" href="#footnote_Temp_555"><sup><small>21</small></sup></a>
Thus,</p>


<p class="trans" lang="ja">
ãƒ¦ãƒ¼ã‚¶ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒè©•ä¾¡å™¨ã®ãƒ‡ãƒ¼ã‚¿ã§ã‚ã‚‹ã€ã¨ã„ã†ã“ã¨ã¯ã€æ··ä¹±ã®å…ƒã§ã‚ã‚‹ã¨ã¯é™ã‚‰ãªã„ã€‚
å®Ÿéš›ã€ã“ã®å·®ç•°ã‚’ç„¡è¦–ã—ã¦ã€ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’Lispå¼ã¨ã—ã¦æ˜ç¤ºçš„ã«è©•ä¾¡ã™ã‚‹èƒ½åŠ›ã‚’ãƒ¦ãƒ¼ã‚¶ã«ä¸ãˆã‚‹â€”â€”ãƒ—ãƒ­ã‚°ãƒ©ãƒ ä¸­ã§ã®ä½¿ç”¨ã®ãŸã‚ã« <tt>eval</tt> ã‚’ä½¿ãˆã‚‹ã‚ˆã†ã«ã—ã¦ãŠãã“ã¨ã«ã‚ˆã£ã¦ã€ãã†ã™ã‚‹â€”â€”ã“ã¨ãŒã€ã¨ãã«ã¯ä¾¿åˆ©ãªã®ã ã€‚
å¤šãã®Lispæ–¹è¨€ã¯ã€å¼ã¨ç’°å¢ƒã‚’å¼•æ•°ã¨ã—ã¦ã¨ã£ã¦ãã®å¼ã‚’ãã®ç’°å¢ƒã«é–¢ã—ã¦è©•ä¾¡ã™ã‚‹ã€åŸå§‹çš„ãª <tt>eval</tt> æ‰‹ç¶šãã‚’ã€æä¾›ã—ã¦ã„ã‚‹<a href="#footnote_Temp_555"><sup><small>21</small></sup></a>ã€‚
ã—ãŸãŒã£ã¦ã€
</p>

<p class="lisp">(eval '(* 5 5) user-initial-environment)
</p>

<p class="orig" lang="en">and</p>

<p class="trans" lang="ja">
ã¨
</p>

<p class="lisp">(eval (cons '* (list 5 5)) user-initial-environment)
</p>

<p class="orig" lang="en">will both return 25.<a name="call_footnote_Temp_556" href="#footnote_Temp_556"><sup><small>22</small></sup></a></p>

<p class="trans" lang="ja">
ã¯ã€ã¨ã‚‚ã«25ã‚’è¿”ã™ã ã‚ã†<a href="#footnote_Temp_556"><sup><small>22</small></sup></a>ã€‚
</p>

<p class="orig" lang="en">
<a name="%_thm_4.15"></a>
<b>Exercise 4.15.</b>  <a name="%_idx_4588"></a>Given a one-argument procedure <tt>p</tt> and an object <tt>a</tt>, <tt>p</tt>
is said to ``halt'' on <tt>a</tt> if evaluating the expression <tt>(p
a)</tt> returns a value (as opposed to terminating with an error message
or running forever).  Show that it is impossible to write a procedure
<tt>halts?</tt> that correctly determines whether <tt>p</tt> halts on <tt>a</tt> for any procedure <tt>p</tt> and object <tt>a</tt>.  Use the following
reasoning: If you had such a procedure <tt>halts?</tt>, you could
implement the following program:
</p>


<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.15.</b> ä¸€å¼•æ•°ã® <tt>p</tt> ã¨ã„ã†æ‰‹ç¶šãã¨ <tt>a</tt> ã¨ã„ã†ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒä¸ãˆã‚‰ã‚ŒãŸå ´åˆã«ã€ã‚‚ã— <tt>(p a)</tt> ã¨ã„ã†å¼ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ã§ã€(ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨ã¨ã‚‚ã«çµ‚äº†ã—ãŸã‚Šã€ã‚ã‚‹ã„ã¯æ°¸é ã«å‹•ä½œä¸­ã ã£ãŸã‚Šã™ã‚‹ã®ã¨ã¯é•ã£ã¦) å€¤ãŒè¿”ã‚‹ãªã‚‰ã°ã€<tt>p</tt> ã¯ <tt>a</tt> ã«é–¢ã—ã¦ã€Œåœæ­¢ã™ã‚‹ã€ã¨è¨€ã‚ã‚Œã‚‹ã€‚
ä»»æ„ã®æ‰‹ç¶šã <tt>p</tt> ã¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ <tt>a</tt> ã«å¯¾ã—ã¦ã€<tt>p</tt> ãŒ <tt>a</tt> ã«é–¢ã—ã¦åœæ­¢ã™ã‚‹ã‹ã©ã†ã‹ã‚’æ­£ã—ãåˆ¤å®šã™ã‚‹ã‚ˆã†ãª <tt>halts?</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’æ›¸ãã“ã¨ã¯ä¸å¯èƒ½ã§ã‚ã‚‹ã€ã¨ç¤ºã›ã€‚
ä»¥ä¸‹ã®æ¨è«–ã‚’ä½¿ã„ãŸã¾ãˆã€‚ã™ãªã‚ã¡ã€ã‚‚ã—ãã®ã‚ˆã†ãª <tt>halts?</tt> ã¨ã„ã†æ‰‹ç¶šããŒã‚ã£ãŸã‚‰ã€å›ã¯æ¬¡ã®ã‚ˆã†ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’å®Ÿè£…ã§ãã‚‹ã ã‚ã†ã€‚
</p>


<p class="lisp">(define (run-forever) (run-forever))

(define (try p)
  (if (halts? p p)
      (run-forever)
      'halted))
</p>

<p class="orig" lang="en">Now consider evaluating the expression <tt>(try try)</tt> and show that
any possible outcome (either halting or running forever) violates the
intended behavior of <tt>halts?</tt>.<a name="call_footnote_Temp_558" href="#footnote_Temp_558"><sup><small>23</small></sup></a>
</p>


<p class="trans" lang="ja">
ã“ã“ã§ã€<tt>(try try)</tt> ã¨ã„ã†å¼ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ã‚’è€ƒãˆã‚ˆã€‚ãã—ã¦ã€ã„ã‹ãªã‚‹å¯èƒ½ãªçµæœã‚‚ (åœæ­¢ã™ã‚‹ã®ã§ã‚ã‚Œã€ã‚ã‚‹ã„ã¯æ°¸é ã«å‹•ä½œä¸­ã¨ãªã‚‹ã®ã§ã‚ã‚Œ)ã€<tt>halts?</tt> ã®æ„å›³ã—ãŸæŒ¯ã‚‹èˆã„ã«é•åã™ã‚‹ã€ã¨ç¤ºã›<a href="#footnote_Temp_558"><sup><small>23</small></sup></a>ã€‚
</p>

<p class="exercise"><span class="ex_comment"></span></p>

<a name="%_sec_4.1.6"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_4.1.6">4.1.6  Internal Definitions</a></h3>
<h3 class="trans" lang="ja">4.1.6 å†…éƒ¨å®šç¾©</h3>

<p class="orig" lang="en">
<a name="%_idx_4598"></a><a name="%_idx_4600"></a>
<a name="%_idx_4602"></a>Our environment model of evaluation and our metacircular evaluator execute
definitions in sequence, extending the environment frame one
definition at a time.  This is particularly convenient for interactive
program development, in which the programmer needs to freely mix the
application of procedures with the definition of new procedures.
However, if we think carefully about the internal definitions
used to implement block structure (introduced in
section <a href="10_sec1_1.html#%_sec_1.1.8">1.1.8</a>), we will find that name-by-name extension
of the environment may not be the best way to define local variables.</p>

<p class="trans" lang="ja">
è©•ä¾¡ã«ã¤ã„ã¦ã®ç§ãŸã¡ã®ç’°å¢ƒãƒ¢ãƒ‡ãƒ«ã¨ç§ãŸã¡ã®ãƒ¡ã‚¿å¾ªç’°çš„ãªè©•ä¾¡å™¨ã¯ã€ä¸€åº¦ã«ä¸€ã¤ã®å®šç¾©ã®ã¶ã‚“ã ã‘ç’°å¢ƒãƒ•ãƒ¬ãƒ¼ãƒ ã‚’æ‹¡å¼µã—ãªãŒã‚‰ã€å®šç¾©ã‚’é †ã«å®Ÿè¡Œã™ã‚‹ã€‚
ã“ã‚Œã¯ã€åå¾©çš„ãƒ—ãƒ­ã‚°ãƒ©ãƒ é–‹ç™ºâ€”â€”ãƒ—ãƒ­ã‚°ãƒ©ãƒã¯ã€æ‰‹ç¶šãã®é©ç”¨ã‚’ã€æ–°ãŸãªæ‰‹ç¶šãã®å®šç¾©ã¨è‡ªç”±ã«æ··ãœåˆã‚ã›ã‚‹å¿…è¦ãŒã‚ã‚‹â€”â€”ã«ã¨ã£ã¦ã€ç‰¹ã«ä¾¿åˆ©ã§ã‚ã‚‹ã€‚
ã—ã‹ã—ã€ãƒ–ãƒ­ãƒƒã‚¯æ§‹é€ ã‚’å®Ÿè£…ã™ã‚‹ã®ã«ä½¿ã‚ã‚Œã‚‹å†…éƒ¨å®šç¾© (<a href="10_sec1_1.html#%_sec_1.1.8">1.1.8</a>ç¯€ã§å°å…¥ã—ãŸ) ã«ã¤ã„ã¦ã€ã‚‚ã—æ³¨æ„æ·±ãè€ƒãˆã‚‹ãªã‚‰ã°ã€ç§ãŸã¡ã¯ã€åå‰ã”ã¨ã«ç’°å¢ƒã‚’æ‹¡å¼µã™ã‚‹ã“ã¨ãŒå±€æ‰€å¤‰æ•°ã‚’å®šç¾©ã™ã‚‹ãŸã‚ã®æœ€å–„ã®æ–¹æ³•ã§ã¯ãªã„ã‹ã‚‚ã—ã‚Œãªã„ã€ã¨æ°—ã¥ãã ã‚ã†ã€‚
</p>

<p class="orig" lang="en">
Consider a procedure with internal definitions, such as</p>

<p class="trans" lang="ja">
ä»¥ä¸‹ã®ã‚ˆã†ã«ã€å†…éƒ¨å®šç¾©ã®ã‚ã‚‹æ‰‹ç¶šãã‚’è€ƒãˆã‚ˆã€‚
</p>

<p class="lisp">(define (f x)
  (define (even? n)
    (if (= n 0)
        true
        (odd? (- n 1))))
  (define (odd? n)
    (if (= n 0)
        false
        (even? (- n 1))))
  &lt;<em>rest of body of <tt>f</tt></em>&gt;)
</p>

<p class="orig" lang="en">Our intention here is that the name <tt>odd?</tt> in the body of the
procedure <tt>even?</tt> should refer to the procedure <tt>odd?</tt> that is
defined after <tt>even?</tt>.  The scope of the name <tt>odd?</tt> is the
entire body of <tt>f</tt>, not just the portion of the body of <tt>f</tt>
starting at the point where the <tt>define</tt> for <tt>odd?</tt> occurs.
Indeed, when we consider that <tt>odd?</tt> is itself defined in terms of
<tt>even?</tt> -- so that <tt>even?</tt> and <tt>odd?</tt> are mutually
recursive procedures -- we see that the only satisfactory
interpretation of the two <tt>define</tt>s is to regard them as if the
names <tt>even?</tt> and <tt>odd?</tt> were being added to the environment
simultaneously.
More generally, in block structure, the scope of a local name is the
entire procedure body in which the <tt>define</tt> is evaluated.</p>

<p class="trans" lang="ja">
ã“ã“ã§ã®ç§ãŸã¡ã®æ„å›³ã¨ã¯ã€<tt>even?</tt> ã¨ã„ã†æ‰‹ç¶šãã®æœ¬ä½“ã§ã® <tt>odd?</tt> ã¨ã„ã†åå‰ã¯ã€<tt>even?</tt> ã®å¾Œã«å®šç¾©ã•ã‚Œã‚‹ <tt>odd?</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’æŒ‡ã™ã¹ãã ã€ã¨ã„ã†ã“ã¨ã§ã‚ã‚‹ã€‚
<tt>odd?</tt> ã¨ã„ã†åå‰ã®<ruby><rb>ç¯„å›²</rb><rp> (</rp><rt>ã‚¹ã‚³ãƒ¼ãƒ—</rt><rp>) </rp></ruby>ã¯ã€<tt>f</tt> ã®æœ¬ä½“å…¨ä½“ãªã®ã§ã‚ã‚Šã€<tt>f</tt> ã®æœ¬ä½“ã®ã†ã¡ã®ã€<tt>odd?</tt> ã«ã¤ã„ã¦ã® <tt>define</tt> ãŒç¾ã‚Œã‚‹ç‚¹ã‹ã‚‰å§‹ã¾ã‚‹éƒ¨åˆ†ã ã‘ãªã®ã§ã¯ãªã„ã€‚
å®Ÿéš›ã€<tt>odd?</tt> è‡ªä½“ãŒ <tt>even?</tt> ã‚’ä½¿ã£ã¦å®šç¾©ã•ã‚Œã‚‹â€”â€” <tt>even?</tt> ã¨ <tt>odd?</tt> ãŒç›¸äº’ã«å†å¸°çš„ãªæ‰‹ç¶šãã¨ãªã‚‹ã‚ˆã†ã«â€”â€”ã¨ã„ã†ã“ã¨ã‚’è€ƒãˆã¦ã¿ã‚‹ã¨ã€äºŒã¤ã® <tt>define</tt> ã«ã¤ã„ã¦ã®ç”³ã—åˆ†ã®ãªã„å”¯ä¸€ã®è§£é‡ˆã¨ã¯ã€ãã‚Œã‚‰äºŒã¤ã® <tt>define</tt> ã‚’ã€ã‚ãŸã‹ã‚‚ <tt>even?</tt> ã¨ <tt>odd?</tt> ã¨ã„ã†åå‰ãŒåŒæ™‚ã«ç’°å¢ƒã«åŠ ãˆã‚‰ã‚ŒãŸã‹ã®ã‚ˆã†ã«ã€è¦‹ãªã™ã“ã¨ãªã®ã ã€‚
ã‚ˆã‚Šä¸€èˆ¬çš„ã«ã¯ã€ãƒ–ãƒ­ãƒƒã‚¯æ§‹é€ ã«ãŠã„ã¦ã¯å±€æ‰€çš„ãªåå‰ã®ã‚¹ã‚³ãƒ¼ãƒ—ã¯ã€<tt>define</tt> ãŒè©•ä¾¡ã•ã‚Œã‚‹æ‰‹ç¶šãæœ¬ä½“å…¨ä½“ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
As it happens, our interpreter will evaluate calls to <tt>f</tt>
correctly, but for an ``accidental'' reason: Since the definitions of
the internal procedures come first, no calls to these procedures will
be evaluated until all of them have been defined.  Hence, <tt>odd?</tt>
will have been defined by the time <tt>even?</tt> is executed.  In fact,
our sequential evaluation mechanism will give the same result as a
mechanism that directly implements simultaneous definition for any
procedure in which the <a name="%_idx_4604"></a>internal definitions come first in a body and
evaluation of the value expressions for the defined variables doesn't
actually use any of the defined variables.
(For an example of a procedure that doesn't obey these restrictions,
so that sequential definition isn't equivalent to simultaneous definition,
see exercise <a href="#%_thm_4.19">4.19</a>.)<a name="call_footnote_Temp_559" href="#footnote_Temp_559"><sup><small>24</small></sup></a></p>

<p class="trans" lang="ja">
ãŸã¾ãŸã¾ã€ç§ãŸã¡ã®ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã¯ã€ã€Œå¶ç„¶ã®ã€ç†ç”±ã‚’é™¤ã‘ã°ã€<tt>f</tt> ã«å¯¾ã™ã‚‹å‘¼ã³å‡ºã—ã‚’æ­£ã—ãè©•ä¾¡ã™ã‚‹ã ã‚ã†ã€‚
ã¤ã¾ã‚Šã€å†…éƒ¨çš„æ‰‹ç¶šãã®å®šç¾©ãŒæœ€åˆã«æ¥ã¦ã„ã‚‹ã®ã§ã€ã“ã‚Œã‚‰ã®æ‰‹ç¶šãã®ã™ã¹ã¦ãŒå®šç¾©æ¸ˆã¿ã«ãªã‚‹ã¾ã§ã¯ã€ã“ã‚Œã‚‰ã®æ‰‹ç¶šãã«å¯¾ã™ã‚‹å‘¼ã³å‡ºã—ã¯ä½•ã‚‚è©•ä¾¡ã•ã‚Œãªã„ã ã‚ã†ã€‚
ã‚ˆã£ã¦ã€<tt>odd?</tt> ã¯ã€<tt>even?</tt> ãŒå®Ÿè¡Œã•ã‚Œã‚‹æ™‚ç‚¹ã¾ã§ã«ã¯å®šç¾©æ¸ˆã¿ã¨ãªã‚‹ã ã‚ã†ã€‚
å†…éƒ¨å®šç¾©ãŒæœ¬ä½“ã®æœ€åˆã«æ¥ã¦ã€ã‹ã¤ã€å®šç¾©ã•ã‚ŒãŸå¤‰æ•°ã«ã¤ã„ã¦ã®ã€å€¤ã®å¼ã®è©•ä¾¡ãŒã€å®šç¾©ã•ã‚ŒãŸå¤‰æ•°ã®ã†ã¡ã®ã„ãšã‚Œã‚’ã‚‚å®Ÿéš›ã«ã¯ä½¿ã‚ãªã„ã‚ˆã†ãªã€ã©ã®æ‰‹ç¶šãã«å¯¾ã—ã¦ã‚‚ç›´æ¥çš„ã«åŒæ™‚çš„å®šç¾©ã‚’å®Ÿè£…ã™ã‚‹ä»•çµ„ã¿ã¨ã€ç§ãŸã¡ã®é€æ¬¡çš„è©•ä¾¡ã®ä»•çµ„ã¿ã¯ã€å®Ÿéš›ã®ã¨ã“ã‚ã€åŒã˜çµæœã‚’ã‚‚ãŸã‚‰ã™ã§ã‚ã‚ã†
(ã“ã‚Œã‚‰ã®åˆ¶ç´„ã«å¾“ã‚ãšã€ãã®ãŸã‚ã€é€æ¬¡çš„å®šç¾©ãŒåŒæ™‚çš„å®šç¾©ã¨ã¯ç­‰ä¾¡ã§ãªã„ã‚ˆã†ãªæ‰‹ç¶šãã®ä¾‹ã«ã¤ã„ã¦ã¯ã€ç·´ç¿’å•é¡Œ<a href="#%_thm_4.19">4.19</a>ã‚’å‚ç…§ã®ã“ã¨)<a href="#footnote_Temp_559"><sup><small>24</small></sup></a>ã€‚
</p>

<p class="orig" lang="en">
There is, however, a simple way to treat definitions so that
internally defined names have truly simultaneous scope -- just create
all local variables that will be in the current environment before
evaluating any of the value expressions.  One way to do this is by a
syntax transformation on <tt>lambda</tt> expressions.  Before evaluating
the body of a <tt>lambda</tt> expression, we <a name="%_idx_4606"></a><a name="%_idx_4608"></a>``scan out'' and eliminate
all the internal definitions in the body.  The internally defined
variables will be created with a <tt>let</tt> and then set to their
values by assignment.  For example, the procedure</p>

<p class="trans" lang="ja">
ã—ã‹ã—ã€å†…éƒ¨çš„ã«å®šç¾©ã•ã‚ŒãŸåå‰ãŒçœŸã«åŒæ™‚çš„ãªã‚¹ã‚³ãƒ¼ãƒ—ã‚’æœ‰ã™ã‚‹ã‚ˆã†ã«ã€å®šç¾©ã‚’å–ã‚Šæ‰±ã†ãŸã‚ã®ç°¡å˜ãªæ–¹æ³•ãŒã‚ã‚‹â€”â€”ãŸã å˜ã«ã€ç¾åœ¨ã®ç’°å¢ƒã®ä¸­ã«å­˜åœ¨ã™ã‚‹ã“ã¨ã«ãªã‚‹ã§ã‚ã‚ã†ã™ã¹ã¦ã®å±€æ‰€å¤‰æ•°ã‚’ã€å€¤ã®å¼ã®ã„ãšã‚Œã‹ã‚’è©•ä¾¡ã™ã‚‹å‰ã«ä½œã‚Œã°ã‚ˆã„ã€‚
ã“ã†ã™ã‚‹ãŸã‚ã®ä¸€ã¤ã®æ–¹æ³•ã¯ã€<tt>lambda</tt> å¼ã«å¯¾ã™ã‚‹æ–‡æ³•å¤‰å½¢ã«ã‚ˆã‚‹ã‚‚ã®ã§ã‚ã‚‹ã€‚
<tt>lambda</tt> å¼ã®æœ¬ä½“ã‚’è©•ä¾¡ã™ã‚‹å‰ã«ã€ãã®æœ¬ä½“ã®ä¸­ã®ã™ã¹ã¦ã®å†…éƒ¨å®šç¾©ã‚’ã€ã€Œèµ°æŸ»ã—ã¤ãã—ã€ã¦å‰Šé™¤ã™ã‚‹ã®ã ã€‚
å†…éƒ¨çš„ã«å®šç¾©ã•ã‚ŒãŸå¤‰æ•°ã¯ã€<tt>let</tt> ã‚’ä½¿ã£ã¦ä½œæˆã•ã‚Œã€ãã‚Œã‹ã‚‰ã€<ruby><rb>ä»£å…¥</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦</rt><rp>) </rp></ruby>ã«ã‚ˆã‚Šã€ãã‚Œã‚‰å¤‰æ•°ã®å€¤ã¸ã¨è¨­å®šã•ã‚Œã‚‹ã“ã¨ã ã‚ã†ã€‚
ãŸã¨ãˆã°ã€æ¬¡ã®æ‰‹ç¶šãã¯ã€
</p>

<p class="lisp">(lambda &lt;<em>vars</em>&gt;
  (define u &lt;<em>e1</em>&gt;)
  (define v &lt;<em>e2</em>&gt;)
  &lt;<em>e3</em>&gt;)
</p>

<p class="orig" lang="en">would be transformed into</p>

<p class="trans" lang="ja">
ä»¥ä¸‹ã®ã‚ˆã†ã«å¤‰å½¢ã•ã‚Œã‚‹ã ã‚ã†ã€‚
</p>

<p class="lisp">(lambda &lt;<em>vars</em>&gt;
  (let ((u '*unassigned*)
        (v '*unassigned*))
    (set! u &lt;<em>e1</em>&gt;)
    (set! v &lt;<em>e2</em>&gt;)
    &lt;<em>e3</em>&gt;))
</p>

<p class="orig" lang="en">where <tt>*unassigned*</tt> is a special symbol that causes looking up a
variable to signal an error if an attempt is made to use the value of
the not-yet-assigned variable.</p>

<p class="trans" lang="ja">
ãŸã ã—ã“ã“ã§ <tt>*unassigned*</tt> ã¯ã€<ruby><rb>æœªä»£å…¥ã®</rb><rp> (</rp><rt>ã¾ã ã‚ã‚Šã‚ã¦ã‚‰ã‚Œã¦ã„ãªã„</rt><rp>) </rp></ruby>å¤‰æ•°ã®å€¤ã‚’ä½¿ã†ãŸã‚ã«ä½•ã‚‰ã‹ã®è©¦ã¿ãŒãªã•ã‚ŒãŸå ´åˆã«ã€ã‚¨ãƒ©ãƒ¼ã®åˆå›³ã‚’å‡ºã™ãŸã‚ã®å¤‰æ•°ã®ãƒ«ãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’å¼•ãèµ·ã“ã™ã€ç‰¹æ®Šãªè¨˜å·ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
An alternative strategy for scanning out internal definitions is shown
in exercise <a href="#%_thm_4.18">4.18</a>.  Unlike the transformation
shown above, this enforces the restriction that the defined variables'
values can be evaluated without using any of the variables' values.<a name="call_footnote_Temp_560" href="#footnote_Temp_560"><sup><small>25</small></sup></a></p>

<p class="trans" lang="ja">
å†…éƒ¨å®šç¾©ã‚’èµ°æŸ»ã—ã¤ãã™ãŸã‚ã®ä»£æ›¿çš„æˆ¦ç•¥ã¯ã€ç·´ç¿’å•é¡Œ<a href="#%_thm_4.18">4.18</a>ã«ç¤ºã•ã‚Œã¦ã„ã‚‹ã€‚
ã“ã‚Œã¯ã€ä¸Šã«ç¤ºã—ãŸå¤‰å½¢ã¨ã¯é•ã£ã¦ã€å®šç¾©ã•ã‚ŒãŸå¤‰æ•°ã®å€¤ã‚’ã€ãã‚Œã‚‰å¤‰æ•°ã®å€¤ã®ã„ãšã‚Œã‚’ã‚‚ä½¿ã‚ãšã«è©•ä¾¡ã§ãã‚‹ã€ã¨ã„ã†åˆ¶ç´„ã‚’å¼·è¦ã™ã‚‹<a href="#footnote_Temp_560"><sup><small>25</small></sup></a>ã€‚
</p>

<p class="orig" lang="en">
<a name="%_thm_4.16"></a>
<b>Exercise 4.16.</b>  In this exercise we implement the method just described for
interpreting internal definitions.
We assume that the evaluator supports <tt>let</tt>
(see exercise <a href="#%_thm_4.6">4.6</a>).</p>


<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.16.</b> ã“ã®ç·´ç¿’å•é¡Œã§ã¯ã€å†…éƒ¨å®šç¾©ã‚’è§£é‡ˆã™ã‚‹ãŸã‚ã«ä»Šèª¬æ˜ã—ãŸã°ã‹ã‚Šã®æ–¹æ³•ã‚’å®Ÿè£…ã™ã‚‹ã€‚
è©•ä¾¡å™¨ãŒ <tt>let</tt> ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚‚ã®ã¨ã™ã‚‹ (ç·´ç¿’å•é¡Œ<a href="#%_thm_4.6">4.6</a>ã‚’å‚ç…§)ã€‚
</p>

<ol class="orig alph" lang="en">
<li><a name="%_idx_4612"></a>Change <tt>lookup-variable-value</tt>
(section <a href="#%_sec_4.1.3">4.1.3</a>) to signal an error if
the value it finds is the symbol <tt>*unassigned*</tt>.</li>

<li><a name="%_idx_4614"></a> Write a procedure <tt>scan-out-defines</tt> that takes a
procedure body and returns an equivalent one that has no internal
definitions, by making the transformation described above.</li>

<li>Install <tt>scan-out-defines</tt> in the interpreter, either in <tt>make-procedure</tt> or in <tt>procedure-body</tt> (see
section <a href="#%_sec_4.1.3">4.1.3</a>).  Which place is better?
Why?</li>
</ol>


<ol class="trans alph" lang="ja">
<li><tt>lookup-variable-value</tt> (<a href="#%_sec_4.1.3">4.1.3</a>ç¯€) ã‚’å¤‰æ›´ã—ã¦ã€ã‚‚ã—ã“ã‚ŒãŒè¦‹ã¤ã‘ãŸå€¤ãŒ <tt>*unassigned*</tt> ã ã£ãŸã‚‰ã‚¨ãƒ©ãƒ¼ã®åˆå›³ã‚’å‡ºã™ã‚ˆã†ã«ã›ã‚ˆã€‚</li>
<li>æ‰‹ç¶šãæœ¬ä½“ã‚’ã¨ã£ã¦ã€ä¸Šè¿°ã®å¤‰å½¢ã‚’è¡Œã†ã“ã¨ã§ã€å†…éƒ¨å®šç¾©ã‚’å«ã¾ãªã„ç­‰ä¾¡ç‰©ã‚’è¿”ã™ã‚ˆã†ãªã€<tt>scan-out-defines</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’æ›¸ã‘ã€‚</li>
<li><tt>scan-out-defines</tt> ã‚’ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«â€”â€”  <tt>make-procedure</tt> ã¾ãŸã¯ <tt>procedure-body</tt>ã®ã„ãšã‚Œã‹ã«â€”â€”çµ„ã¿è¾¼ã‚ (<a href="#%_sec_4.1.3">4.1.3</a>ç¯€å‚ç…§)ã€‚
ã©ã¡ã‚‰ã®å ´æ‰€ã®æ–¹ãŒè‰¯ã„ã ã‚ã†? 
ãã‚Œã¯ãªãœ?</li>
</ol>

<p class="exercise"><span class="ex_comment"></span></p>

<p class="orig" lang="en">
<a name="%_thm_4.17"></a>
<b>Exercise 4.17.</b>  Draw diagrams of the environment in effect when evaluating the
expression &lt;<em>e3</em>&gt; in the procedure in the text, comparing how this
will be structured when definitions are interpreted sequentially with
how it will be structured if definitions are scanned out as described.
Why is there an extra frame in the transformed program?  Explain why
this difference in environment structure can never make a difference
in the behavior of a correct program.  Design a way to make the
interpreter implement the ``simultaneous'' scope rule for internal
definitions without constructing the extra frame.



<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.17.</b> æœ¬æ–‡ã®æ‰‹ç¶šãã®ä¸­ã® &lt;<em class="en">e3</em>&gt; ã¨ã„ã†å¼ã‚’è©•ä¾¡ã™ã‚‹ã¨ãã«æœ‰åŠ¹ã«ãªã£ã¦ã„ã‚‹ç’°å¢ƒã®å›³ã‚’æã‘â€”â€”å®šç¾©ãŒé€æ¬¡çš„ã«è§£é‡ˆã•ã‚Œã‚‹å ´åˆã«ã¯ã“ã®ç’°å¢ƒãŒã©ã®ã‚ˆã†ã«æ§‹é€ åŒ–ã•ã‚Œã‚‹ã ã‚ã†ã‹ã€ã¨ã„ã†ã“ã¨ã‚’ã€ä¸Šè¨˜ã®ã‚ˆã†ã«å®šç¾©ãŒèµ°æŸ»ã—ã¤ãã•ã‚Œã‚‹å ´åˆã«ã¯ã“ã®ç’°å¢ƒãŒã©ã®ã‚ˆã†ã«æ§‹é€ åŒ–ã•ã‚Œã‚‹ã ã‚ã†ã‹ã€ã¨ã„ã†ã“ã¨ã¨æ¯”è¼ƒã—ãªãŒã‚‰ã€‚
å¤‰å½¢ã•ã‚ŒãŸãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ã¯ã€ãªãœã€è¿½åŠ ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãŒã‚ã‚‹ã®ã ã‚ã†ã‹?
ç’°å¢ƒæ§‹é€ ã«ãŠã‘ã‚‹ã“ã®é•ã„ãŒã€ãªãœã€æ­£ã—ã„ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®æŒ¯ã‚‹èˆã„ã«ãŠã‘ã‚‹é•ã„ã‚’ã‚‚ãŸã‚‰ã™ã“ã¨ãŒã‚ã‚Šå¾—ãªã„ã®ã‹ã€èª¬æ˜ã›ã‚ˆã€‚
ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«ã€è¿½åŠ ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’æ§‹ç¯‰ã›ãšã«å†…éƒ¨å®šç¾©ã«ã¤ã„ã¦ã®ã€ŒåŒæ™‚ã€ã‚¹ã‚³ãƒ¼ãƒ—è¦å‰‡ã‚’å®Ÿè£…ã•ã›ã‚‹ãŸã‚ã®ã€æ–¹æ³•ã‚’è¨­è¨ˆã›ã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment"></span></p>

<p class="orig" lang="en">
<a name="%_thm_4.18"></a>
<b>Exercise 4.18.</b>  Consider an alternative strategy for scanning out definitions that
translates the example in the text to
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.18.</b> æœ¬æ–‡ã®ä¾‹ã‚’ä»¥ä¸‹ã®ã‚ˆã†ã«å¤‰æ›ã™ã‚‹ã‚ˆã†ãªã€å®šç¾©ã‚’èµ°æŸ»ã—ã¤ãã™ãŸã‚ã®ä»£æ›¿çš„æˆ¦ç•¥ã«ã¤ã„ã¦è€ƒãˆã‚ˆã†ã€‚
</p>

<p class="lisp">(lambda &lt;<em>vars</em>&gt;
  (let ((u '*unassigned*)
        (v '*unassigned*))
    (let ((a &lt;<em>e1</em>&gt;)
          (b &lt;<em>e2</em>&gt;))
      (set! u a)
      (set! v b))
    &lt;<em>e3</em>&gt;))
</p>

<p class="orig" lang="en">Here <tt>a</tt> and <tt>b</tt> are meant to represent new variable names,
created by the interpreter, that do not appear in the user's
program.
Consider the <tt>solve</tt> procedure from
section <a href="24_sec3_5.html#%_sec_3.5.4">3.5.4</a>:</p>

<p class="trans" lang="ja">
ã“ã“ã§ã€<tt>a</tt> ã¨ <tt>b</tt> ã¯ã€ãƒ¦ãƒ¼ã‚¶ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ã¯ç¾ã‚Œãªã„æ–°ã—ã„å¤‰æ•°åâ€”â€”ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«ã‚ˆã‚Šä½œæˆã•ã‚Œã‚‹â€”â€”ã‚’è¡¨ã™ã¤ã‚‚ã‚Šã®ã‚‚ã®ã§ã‚ã‚‹ã€‚
<a href="24_sec3_5.html#%_sec_3.5.4">3.5.4</a>ç¯€ã® <tt>solve</tt> ã¨ã„ã†æ‰‹ç¶šãã‚’è€ƒãˆã‚ˆã†ã€‚
</p>

<p class="lisp"><a name="%_idx_4616"></a>(define (solve f y0 dt)
  (define y (integral (delay dy) y0 dt))
  (define dy (stream-map f y))
  y)
</p>

<p class="orig" lang="en">Will this procedure work if internal definitions are scanned out as
shown in this exercise?  What if they are scanned out as shown in the
text?  Explain.
</p>

<p class="trans" lang="ja">
ã‚‚ã—ã€ã“ã®ç·´ç¿’å•é¡Œã«ç¤ºã•ã‚ŒãŸã‚ˆã†ã«ã—ã¦å†…éƒ¨å®šç¾©ãŒèµ°æŸ»ã—ã¤ãã•ã‚ŒãŸã‚‰ã€ã“ã®æ‰‹ç¶šãã¯ã€ã†ã¾ãå‹•ãã ã‚ã†ã‹?
ã‚‚ã—ã€æœ¬æ–‡ã«ç¤ºã•ã‚ŒãŸã‚ˆã†ã«ã—ã¦å†…éƒ¨å®šç¾©ãŒèµ°æŸ»ã—ã¤ãã•ã‚ŒãŸã‚‰ã€ã©ã†ãªã‚‹ã ã‚ã†?
èª¬æ˜ã›ã‚ˆã€‚
</p>

<p class="exercise"><span class="ex_comment"></span></p>

<p class="orig" lang="en">
<a name="%_thm_4.19"></a>
<b>Exercise 4.19.</b>  Ben Bitdiddle, Alyssa P. Hacker, and Eva Lu Ator are arguing about
the desired result of evaluating the expression</p>


<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.19.</b> ãƒ™ãƒ³ãƒ»ãƒ“ãƒƒãƒˆãƒ‡ã‚£ãƒ‰ãƒ«ã¨ã€ã‚¢ãƒªãƒƒã‚µãƒ»Pãƒ»ãƒãƒƒã‚«ã¨ã€ã‚¨ãƒ´ã‚¡ãƒ»ãƒªãƒ¥ãƒ»ã‚¨ã‚¤ã‚¿ã¯ã€ä»¥ä¸‹ã®å¼ã‚’è©•ä¾¡ã—ãŸã¨ãã®æœ›ã¾ã‚Œã‚‹çµæœã«ã¤ã„ã¦ã€è­°è«–ã—ã¦ã„ã‚‹ã€‚
</p>


<p class="lisp">(let ((a 1))
  (define (f x)
    (define b (+ a x))
    (define a 5)
    (+ a b))
  (f 10))
</p>

<p class="orig" lang="en">Ben asserts that the result should be obtained using the sequential
rule for <tt>define</tt>: <tt>b</tt> is defined to be 11, then <tt>a</tt> is
defined to be 5, so the result is 16.  Alyssa objects that mutual
recursion requires the simultaneous scope rule for internal procedure
definitions, and that it is unreasonable to treat procedure names
differently from other names.  Thus, she argues for the mechanism
implemented in exercise <a href="#%_thm_4.16">4.16</a>.  This would lead to
<tt>a</tt> being unassigned at the time that the value for <tt>b</tt> is to
be computed.  Hence, in Alyssa's view the procedure should produce an
error.  Eva has a third opinion.  She says that if the definitions of
<tt>a</tt> and <tt>b</tt> are truly meant to be simultaneous, then the value
5 for <tt>a</tt> should be used in evaluating <tt>b</tt>.  Hence, in Eva's
view <tt>a</tt> should be 5, <tt>b</tt> should be 15, and the result should
be 20.  Which (if any) of these viewpoints do you support?  Can you
devise a way to implement internal definitions so that they behave as
Eva prefers?<a name="call_footnote_Temp_565" href="#footnote_Temp_565"><sup><small>26</small></sup></a>
</p>

<p class="trans" lang="ja">
ãƒ™ãƒ³ã¯ã€<tt>define</tt> ã«å¯¾ã—ã¦é€æ¬¡çš„ãªè¦å‰‡ã‚’ä½¿ã£ã¦ã€çµæœãŒå¾—ã‚‰ã‚Œã‚‹ã¯ãšã ã€ã¨ä¸»å¼µã™ã‚‹ã€‚ã¤ã¾ã‚Šã€<tt>b</tt> ã¯11ã ã¨å®šç¾©ã•ã‚Œã€ãã‚Œã‹ã‚‰ã€<tt>a</tt> ã¯5ã ã¨å®šç¾©ã•ã‚Œã€ãã®ãŸã‚ã€çµæœã¯16ã ã€ã¨ã„ã†ã®ã ã€‚
ã‚¢ãƒªãƒƒã‚µã¯ã€ç›¸äº’çš„ãªå†å¸°ã¯å†…éƒ¨ã®æ‰‹ç¶šãå®šç¾©ã«ã¤ã„ã¦åŒæ™‚çš„ã‚¹ã‚³ãƒ¼ãƒ—ã®è¦å‰‡ã‚’è¦è«‹ã™ã‚‹ã—ã€æ‰‹ç¶šãåã‚’ãŸã®åå‰ã¨ã¯åˆ¥ã®æ–¹æ³•ã§æ‰±ã†ã®ã¯ä¸åˆç†ã ã€ã¨ç•°è­°ã‚’å”±ãˆã‚‹ã€‚
ã‚ˆã£ã¦ã€ã‚¢ãƒªãƒƒã‚µã¯ã€ç·´ç¿’å•é¡Œ<a href="#%_thm_4.16">4.16</a>ã§å®Ÿè£…ã—ãŸä»•çµ„ã¿ã«è³›æˆã™ã‚‹ã€‚
ã“ã‚Œã¯ã€<tt>b</tt> ã®å€¤ãŒè¨ˆç®—ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹æ™‚ç‚¹ã§ã¯ã€<tt>a</tt> ãŒã¾ã <ruby><rb>ä»£å…¥ã•ã‚Œã¦</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦ã‚‰ã‚Œã¦</rt><rp>) </rp></ruby>ã„ãªã„ã€ã¨ã„ã†äº‹æ…‹ã«ã¤ãªãŒã‚‹ã€‚
ã‚ˆã£ã¦ã€ã‚¢ãƒªãƒƒã‚µã®è¦‹æ–¹ã§ã¯ã€ã“ã®æ‰‹ç¶šãã¯ã‚¨ãƒ©ãƒ¼ã‚’ç”Ÿã¿å‡ºã™ã¯ãšã§ã‚ã‚‹ã€‚
ã‚¨ãƒ´ã‚¡ã¯ç¬¬ä¸‰ã®æ„è¦‹ã‚’æŒã£ã¦ã„ã‚‹ã€‚
ã‚‚ã— <tt>a</tt> ã¨ <tt>b</tt> ã®å®šç¾©ãŒæœ¬å½“ã«åŒæ™‚ã§ã‚ã‚‹ã“ã¨ã‚’æ„å›³ã—ãŸã‚‚ã®ãªã‚‰ã€<tt>a</tt> ã«å¯¾ã™ã‚‹5ã¨ã„ã†å€¤ãŒã€<tt>b</tt> ã‚’è©•ä¾¡ã™ã‚‹éš›ã«ä½¿ã‚ã‚Œã‚‹ã¯ãšã ã€ã¨ã‚¨ãƒ´ã‚¡ã¯è¨€ã†ã€‚
ã‚ˆã£ã¦ã€ã‚¨ãƒ´ã‚¡ã®è¦‹æ–¹ã§ã¯ã€<tt>a</tt> ã¯5ã®ã¯ãšã§ã€<tt>b</tt> ã¯15ã®ã¯ãšã§ã€çµæœã¯20ã®ã¯ãšã§ã‚ã‚‹ã€‚
å›ã¯ã€ã“ã‚Œã‚‰ã®è¦³ç‚¹ã®ã†ã¡ (ã‚‚ã—æ”¯æŒã™ã‚‹ã‚‚ã®ãŒã‚ã‚Œã°) ã„ãšã‚Œã‚’æ”¯æŒã™ã‚‹ã‹ãª?
ã‚¨ãƒ´ã‚¡ãŒè‰¯ã„ã¨æ€ã£ã¦ã„ã‚‹ã¨ãŠã‚Šã«å†…éƒ¨å®šç¾©ãŒæŒ¯ã‚‹èˆã†ã‚ˆã†ã«ã€å†…éƒ¨å®šç¾©ã‚’å®Ÿè£…ã™ã‚‹æ–¹æ³•ã‚’ã€å›ã¯è€ƒæ¡ˆã§ãã‚‹ã‹ãª?<a href="#footnote_Temp_565"><sup><small>26</small></sup></a>
</p>

<p class="exercise"><span class="ex_comment"></span></p>

<p class="orig" lang="en">
<a name="%_thm_4.20"></a>
<b>Exercise 4.20.</b>  <a name="%_idx_4618"></a><a name="%_idx_4620"></a>Because internal definitions look sequential but are actually
simultaneous, some people prefer to avoid them entirely, and use the
special form <tt>letrec</tt> instead.  <tt>Letrec</tt> looks like <tt>let</tt>,
so it is not surprising that the variables it binds are bound
simultaneously and have the same scope as each other.  The sample
procedure <tt>f</tt> above can be written without internal definitions,
but with exactly the same meaning, as</p>


<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.20.</b> å†…éƒ¨å®šç¾©ã¯é€æ¬¡çš„ã«è¦‹ãˆã‚‹ãŒã€å®Ÿéš›ã¯åŒæ™‚çš„ãªã®ã§ã€å†…éƒ¨å®šç¾©ã‚’å®Œå…¨ã«é¿ã‘ã¦ãã®ä»£ã‚ã‚Šã« <tt>letrec</tt> ã¨ã„ã†ç‰¹æ®Šå½¢å¼ã‚’ä½¿ã†ã“ã¨ã‚’å¥½ã‚€äººã‚‚ã„ã‚‹ã€‚
<tt>letrec</tt> ã¯ <tt>let</tt> ã«ä¼¼ã¦ãŠã‚Šã€ãã®ãŸã‚ã€<tt>letrec</tt> ã®æŸç¸›ã™ã‚‹å¤‰æ•°ã¯ã€åŒæ™‚ã«æŸç¸›ã•ã‚Œã¦ã€ãŠäº’ã„ã«åŒã˜ã‚¹ã‚³ãƒ¼ãƒ—ã‚’æŒã¤ã®ã ã€ã¨ã„ã†ã“ã¨ã¯åˆ¥ã«é©šãã«å½“ãŸã‚‰ãªã„ã€‚
ä¸Šè¨˜ã® <tt>f</tt> ã¨ã„ã†ä¾‹ç¤ºçš„æ‰‹ç¶šãã¯ã€å†…éƒ¨å®šç¾©ãªã—ã«ã€ã—ã‹ã—ã¾ã£ãŸãåŒä¸€ã®æ„å‘³ã‚’æŒã£ã¦ã€ä»¥ä¸‹ã®ã‚ˆã†ã«æ›¸ã‘ã‚‹ã€‚
</p>

<p class="lisp">(define (f x)
  (letrec ((even?
            (lambda (n)
              (if (= n 0)
                  true
                  (odd? (- n 1)))))
           (odd?
            (lambda (n)
              (if (= n 0)
                  false
                  (even? (- n 1))))))
    &lt;<em>rest of body of <tt>f</tt></em>&gt;))
</p>

<p class="orig" lang="en"><tt>Letrec</tt> expressions, which have the form</p>


<p class="trans" lang="ja">
<tt>letrec</tt> å¼ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ãªå½¢å¼ã‚’æŒã¤ã‚ã‘ã ãŒã€
</p>

<p class="lisp">(letrec ((&lt;<em>var<sub>1</sub></em>&gt; &lt;<em>exp<sub>1</sub></em>&gt;) <tt>...</tt> (&lt;<em>var<sub><em>n</em></sub></em>&gt; &lt;<em>exp<sub><em>n</em></sub></em>&gt;))
  &lt;<em>body</em>&gt;)
</p>

<p class="orig" lang="en">are a variation on <tt>let</tt> in which the expressions
&lt;<em>exp<sub><em>k</em></sub></em>&gt; that provide the initial values for the variables &lt;<em>var<sub><em>k</em></sub></em>&gt;
are evaluated in an environment that includes all the <tt>letrec</tt>
bindings.  This permits recursion in the bindings, such as the mutual
recursion of <tt>even?</tt> and <tt>odd?</tt> in the example above, or
<a name="%_idx_4622"></a>the evaluation of 10 factorial with</p>

<p class="trans" lang="ja">
&lt;<em>var<sub>k</sub></em>&gt; ã¨ã„ã†å¤‰æ•°ã«åˆæœŸå€¤ã‚’ä¸ãˆã‚‹ &lt;<em>exp<sub>k</sub></em>&gt; ã¨ã„ã†å¼ãŒã€ã™ã¹ã¦ã® <tt>letrec</tt> æŸç¸›ã‚’å«ã‚€ç’°å¢ƒã§è©•ä¾¡ã•ã‚Œã‚‹ã€ã¨ã„ã†ã€<tt>let</tt> ã®å¤‰ç¨®ãªã®ã§ã‚ã‚‹ã€‚
ã“ã‚Œã«ã‚ˆã£ã¦æŸç¸›ã«ãŠã‘ã‚‹å†å¸°â€”â€”ä¸Šè¨˜ã®ä¾‹ã«ãŠã‘ã‚‹ã€<tt>even?</tt> ã¨ <tt>odd?</tt> ã®ç›¸äº’å†å¸°ã€ã‚ã‚‹ã„ã¯ã€ä»¥ä¸‹ã®ã‚‚ã®ã‚’ä½¿ã£ãŸ10ã®éšä¹—ã®è©•ä¾¡ãªã©â€”â€”ãŒå¯èƒ½ã¨ãªã‚‹ã€‚
</p>

<p class="lisp">(letrec ((fact
          (lambda (n)
            (if (= n 1)
                1
                (* n (fact (- n 1)))))))
  (fact 10))
</p>


<ol class="orig alph" lang="en">
<li>Implement <tt>letrec</tt> as a derived expression, by transforming
a <tt>letrec</tt> expression into a <tt>let</tt> expression as shown in
the text above or in exercise <a href="#%_thm_4.18">4.18</a>.
That is, the <tt>letrec</tt> variables should be created with a <tt>let</tt>
and then be assigned their values with <tt>set!</tt>.</li>

<li>Louis Reasoner is confused by all this fuss about internal
definitions.  The way he sees it, if you don't like to use <tt>define</tt> inside a procedure, you can just use <tt>let</tt>.  Illustrate
what is loose about his reasoning by drawing an environment diagram
that shows the environment in which the &lt;<em>rest of body of <tt>f</tt></em>&gt;
is evaluated during evaluation of the expression <tt>(f 5)</tt>, with
<tt>f</tt> defined as in this exercise.  Draw
an environment diagram for the same evaluation, but with <tt>let</tt> in
place of <tt>letrec</tt> in the definition of <tt>f</tt>.
</li>
</ol>

<ol class="trans alph" lang="ja">
<li>ä¸Šè¿°ã®æœ¬æ–‡ã¾ãŸã¯ç·´ç¿’å•é¡Œ<a href="#%_thm_4.18">4.18</a> ã«ç¤ºã•ã‚Œã¦ã„ã‚‹ã‚ˆã†ã«ã—ã¦ <tt>letrec</tt> å¼ã‚’ <tt>let</tt> å¼ã¸ã¨å¤‰å½¢ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€<tt>letrec</tt> ã‚’æ´¾ç”Ÿå¼ã¨ã—ã¦å®Ÿè£…ã›ã‚ˆã€‚
ã¤ã¾ã‚Šã€<tt>letrec</tt> å¤‰æ•°ã¯ <tt>let</tt> ã‚’ä½¿ã£ã¦ä½œæˆã•ã‚Œã‚‹ã¯ãšã§ã€ãã®å¾Œã€<tt>set!</tt> ã‚’ä½¿ã£ã¦ãã®å€¤ãŒ<ruby><rb>ä»£å…¥ã•ã‚Œã‚‹</rb><rp> (</rp><rt>ã‚ã‚Šã‚ã¦ã‚‰ã‚Œã‚‹</rt><rp>) </rp></ruby>ã¯ãšã§ã‚ã‚‹ã€‚</li>
<li>ãƒ«ã‚¤ã‚¹ãƒ»ãƒªãƒ¼ã‚ºãƒŠã¯ã€å†…éƒ¨å®šç¾©ã«ã¤ã„ã¦ã®ã“ã®ã‚„ã‚„ã“ã—ã„æ‰‹é–“ã®ã™ã¹ã¦ã«å›°æƒ‘ã—ã¦ã„ã‚‹ã€‚
å½¼ã®è¦‹æ–¹ã¯ã€ã‚‚ã—æ‰‹ç¶šãã®å†…éƒ¨ã§ <tt>define</tt> ã‚’ä½¿ã„ãŸããªã„ãªã‚‰ã€ãŸã  <tt>let</tt> ãŒä½¿ãˆã‚‹ã‚ˆã­ã€ã¨ã„ã†ã‚‚ã®ã ã€‚
ã“ã®ç·´ç¿’å•é¡Œã§ã®ã‚ˆã†ã«å®šç¾©ã•ã‚ŒãŸ <tt>f</tt> ã‚’ä½¿ã£ãŸã¨ã—ã¦ã€<tt>(f 5)</tt> ã¨ã„ã†å¼ã®è©•ä¾¡ã®æœ€ä¸­ã« 
<span class="math">&lt;<em class="en">rest of body of <tt>f</tt></em>&gt;</span>
ãŒè©•ä¾¡ã•ã‚Œã‚‹ç’°å¢ƒã‚’ç¤ºã™ç’°å¢ƒå›³ã‚’æãã“ã¨ã«ã‚ˆã£ã¦ã€ãƒ«ã‚¤ã‚¹ã®æ¨è«–ã«é–¢ã—ã¦ã€ç²—ã„ã¨ã“ã‚ã‚’èª¬æ˜ã›ã‚ˆã€‚
<tt>f</tt> ã®å®šç¾©ã«ãŠã„ã¦ <tt>letrec</tt> ã®ä»£ã‚ã‚Šã« <tt>let</tt> ã‚’ä½¿ã£ãŸå ´åˆã®ã€åŒã˜è©•ä¾¡ã«ã¤ã„ã¦ã®ç’°å¢ƒå›³ã‚’æã‘ã€‚
</li>
</ol>

<p class="exercise"><span class="ex_comment"></span></p>

<p class="orig" lang="en">
<a name="%_thm_4.21"></a>
<b>Exercise 4.21.</b>  <a name="%_idx_4624"></a>Amazingly, Louis's intuition in exercise <a href="#%_thm_4.20">4.20</a>
is correct.  It is indeed possible to specify recursive procedures
without using <tt>letrec</tt> (or even <tt>define</tt>), although the method
for accomplishing this is much more subtle than Louis imagined.  The
following expression computes 10 factorial by applying a recursive
<a name="%_idx_4626"></a>factorial procedure:<a name="call_footnote_Temp_568" href="#footnote_Temp_568"><sup><small>27</small></sup></a>
</p>


<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.21.</b> é©šãã¹ãã“ã¨ã«ã€ç·´ç¿’å•é¡Œ<a href="#%_thm_4.20">4.20</a>ã§ã®ãƒ«ã‚¤ã‚¹ã®ç›´è¦³ã¯æ­£ã—ã„ã€‚
å®Ÿéš›ã€<tt>letrec</tt> ã‚’ (ãã‚Œã©ã“ã‚ã‹ <tt>define</tt> ã•ãˆã‚‚) ä½¿ã‚ãšã«ã€å†å¸°çš„æ‰‹ç¶šãã‚’è¦å®šã™ã‚‹ã“ã¨ãŒå¯èƒ½ã§ã‚ã‚‹â€”â€”ã‚‚ã£ã¨ã‚‚ã€ã“ã‚Œã‚’é”æˆã™ã‚‹ãŸã‚ã®æ–¹æ³•ã¯ã€ãƒ«ã‚¤ã‚¹ãŒæƒ³åƒã—ãŸã®ã‚ˆã‚Šã‚‚ãšã£ã¨å¾®å¦™ãªã‚‚ã®ã§ã¯ã‚ã‚‹ã®ã ãŒã€‚
ä»¥ä¸‹ã®å¼ã¯ã€å†å¸°çš„ãªéšä¹—æ‰‹ç¶šãã‚’é©ç”¨ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€10ã®éšä¹—ã‚’è¨ˆç®—ã™ã‚‹<a href="#footnote_Temp_568"><sup><small>27</small></sup></a>ã€‚
</p>

<p class="lisp">((lambda (n)
   ((lambda (fact)
      (fact fact n))
    (lambda (ft k)
      (if (= k 1)
          1
          (* k (ft ft (- k 1)))))))
 10)
</p>

<ol class="orig alph" lang="en">
<li>Check (by evaluating the expression) that this really does compute
factorials.  Devise an analogous expression for computing Fibonacci numbers.
</li>
<li>Consider the following procedure, which includes mutually recursive
internal definitions:
</li>
</ol>

<ol class="trans alph" lang="ja">
<li>(å¼ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦) ã“ã‚ŒãŒæœ¬å½“ã«éšä¹—ã‚’è¨ˆç®—ã™ã‚‹ã®ã ã€ã¨ã„ã†ã“ã¨ã‚’ç¢ºèªã›ã‚ˆã€‚
ãƒ•ã‚£ãƒœãƒŠãƒƒãƒæ•°ã‚’è¨ˆç®—ã™ã‚‹ãŸã‚ã®é¡ä¼¼ã®å¼ã‚’è€ƒæ¡ˆã›ã‚ˆã€‚</li>
<li>ä»¥ä¸‹ã®æ‰‹ç¶šãâ€”â€”ç›¸äº’å†å¸°çš„ãªå†…éƒ¨å®šç¾©ã‚’å«ã‚€â€”â€”ã‚’è€ƒãˆã‚ˆã†ã€‚</li>
</ol>

<p class="lisp">(define (f x)
  (define (even? n)
    (if (= n 0)
        true
        (odd? (- n 1))))
  (define (odd? n)
    (if (= n 0)
        false
        (even? (- n 1))))
  (even? x))
</p>

<p class="orig" lang="en">Fill in the missing expressions to complete an alternative definition
of <tt>f</tt>, which uses neither internal definitions nor <tt>letrec</tt>:
</p>


<p class="trans" lang="ja">
***
</p>

<p class="lisp">(define (f x)
  ((lambda (even? odd?)
     (even? even? odd? x))
   (lambda (ev? od? n)
     (if (= n 0) true (od? &lt;??&gt; &lt;??&gt; &lt;??&gt;)))
   (lambda (ev? od? n)
     (if (= n 0) false (ev? &lt;??&gt; &lt;??&gt; &lt;??&gt;)))))
</p>

<p class="exercise"><span class="ex_comment"></span></p>

<a name="%_sec_4.1.7"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_4.1.7">4.1.7  Separating Syntactic Analysis from Execution</a></h3>
<h3 class="trans" lang="ja">4.1.7 æ–‡æ³•çš„ãªåˆ†æã‚’å®Ÿè¡Œã‹ã‚‰åˆ‡ã‚Šé›¢ã™</h3>


<p class="orig" lang="en">
<a name="%_idx_4634"></a><a name="%_idx_4636"></a><a name="%_idx_4638"></a>
<a name="%_idx_4640"></a><a name="%_idx_4642"></a>The evaluator implemented above is simple, but it is very
inefficient, because the syntactic analysis of expressions is interleaved
with their execution.  Thus if a program is executed many times, its
syntax is analyzed many times.  Consider, for example, evaluating <tt>(factorial 4)</tt> using the following definition of <tt>factorial</tt>:</p>

<p class="trans" lang="ja">
ä¸Šè¨˜ã§å®Ÿè£…ã—ãŸè©•ä¾¡å™¨ã¯ã€å˜ç´”ãªã®ã ãŒã€å¼ã®æ–‡æ³•çš„è§£æãŒãã®å¼ã®å®Ÿè¡Œã¨äº’ã„é•ã„ã«ãªã£ã¦ã„ã‚‹ãŸã‚ã€ã¨ã¦ã‚‚éåŠ¹ç‡ã ã€‚
ã‚ˆã£ã¦ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒä½•å›ã‚‚å®Ÿè¡Œã•ã‚Œã‚‹å ´åˆã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®æ–‡æ³•ãŒä½•å›ã‚‚è§£æã•ã‚Œã‚‹ã€‚
ãŸã¨ãˆã°ã€ä»¥ä¸‹ã® <tt>factorial</tt> ã®å®šç¾©ã‚’ä½¿ã£ã¦ <tt>(factorial 4)</tt> ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ã‚’è€ƒãˆã‚ˆã†ã€‚
</p>

<p class="lisp">(define (factorial n)
  (if (= n 1)
      1
      (* (factorial (- n 1)) n)))
</p>

<p class="orig" lang="en">
Each time <tt>factorial</tt> is called, the evaluator must determine that
the body is an <tt>if</tt> expression and extract the predicate.
Only then can it evaluate the
predicate and dispatch on its value.  Each time it evaluates the
expression <tt>(* (factorial (- n 1)) n)</tt>,
or the subexpressions <tt>(factorial (- n 1))</tt> and <tt>(- n 1)</tt>,
the evaluator must perform
the case analysis in <tt>eval</tt> to determine that the expression is an
application, and must extract its operator and operands.  This
analysis is expensive.  Performing it repeatedly is wasteful.</p>

<p class="trans" lang="ja">
<tt>factorial</tt> ãŒå‘¼ã°ã‚Œã‚‹ãŸã³ã«ã€è©•ä¾¡å™¨ã¯ã€æœ¬ä½“ãŒ <tt>if</tt> å¼ã§ã‚ã‚‹ã¨åˆ¤å®šã›ã­ã°ãªã‚‰ãªã„ã—ã€è¿°èªã‚’æŠ½å‡ºã›ã­ã°ãªã‚‰ãªã„ã€‚
ãã†ã—ã¦ã‹ã‚‰åˆã‚ã¦ã€è©•ä¾¡å™¨ã¯ã€è¿°èªã‚’è©•ä¾¡ã—ã¦è¿°èªã®å€¤ã«å¿œã˜ã¦æŒ¯ã‚Šåˆ†ã‘ã‚’è¡Œã†ã“ã¨ãŒã§ãã‚‹ã€‚
è©•ä¾¡å™¨ãŒ <tt>(* (factorial (- n 1)) n)</tt> ã¨ã„ã†å¼ã‚’è©•ä¾¡ã™ã‚‹ãŸã³ã«ã€ã‚ã‚‹ã„ã¯ã€<tt>(factorial (- n 1))</tt> ã‚„ <tt>(- n 1)</tt> ã¨ã„ã†éƒ¨åˆ†å¼ã‚’è©•ä¾¡ã™ã‚‹ãŸã³ã«ã€è©•ä¾¡å™¨ã¯ã€<tt>eval</tt> ã§ã®å ´åˆåˆ†ã‘åˆ†æã‚’å®Ÿè¡Œã—ã¦ã€ãã®å¼ãŒé©ç”¨ã§ã‚ã‚‹ã€ã¨åˆ¤å®šã›ã­ã°ãªã‚‰ãªã„ã—ã€ãã®å¼ã®ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ã¨ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã‚’æŠ½å‡ºã›ã­ã°ãªã‚‰ãªã„ã€‚
ã“ã®åˆ†æã¯é«˜ãã¤ãã€‚
ã“ã®åˆ†æã‚’ç¹°ã‚Šè¿”ã—å®Ÿè¡Œã™ã‚‹ã“ã¨ã¯ã€ç„¡é§„ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
We can transform the evaluator to be significantly more efficient by
arranging things so that syntactic analysis is performed only
once.<a name="call_footnote_Temp_569" href="#footnote_Temp_569"><sup><small>28</small></sup></a> We split <tt>eval</tt>, which takes an
expression and an environment, into two parts.  The procedure <tt>analyze</tt> takes only the expression.  It performs the syntactic
analysis and returns a new procedure, the <a name="%_idx_4652"></a><em>execution procedure</em>, that
encapsulates the work to be done in executing the analyzed
expression.  The execution procedure takes an environment as its
argument and completes the evaluation.  This saves work because <tt>analyze</tt> will be called only once on an expression, while the
execution procedure may be called many times.</p>

<p class="trans" lang="ja">
æ–‡æ³•çš„è§£æãŒãŸã£ãŸä¸€åº¦ã ã‘å®Ÿè¡Œã•ã‚Œã‚‹ã‚ˆã†ã«ç‰©äº‹ã‚’æ•´ç†ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€è©•ä¾¡å™¨ã‚’ã€è‘—ã—ãã‚ˆã‚ŠåŠ¹ç‡çš„ãªã‚‚ã®ã«å¤‰å½¢ã™ã‚‹ã“ã¨ãŒã§ãã‚‹<a href="#footnote_Temp_569"><sup><small>28</small></sup></a>ã€‚
<tt>eval</tt> ã¯ã€å¼ã¨ç’°å¢ƒã‚’ã¨ã‚‹ã‚‚ã®ã ãŒã€ã“ã® <tt>eval</tt> ã‚’äºŒã¤ã®éƒ¨åˆ†ã«åˆ†ã‘ã‚‹ã€‚
<tt>analyze</tt> ã¯ã€å¼ã®ã¿ã‚’ã¨ã‚‹ã€‚
<tt>analyze</tt> ã¯ã€æ–‡æ³•çš„è§£æã®ã¿ã‚’è¡Œã„ã€åˆ†æã—ãŸå¼ã‚’å®Ÿè¡Œã™ã‚‹éš›ã«è¡Œã‚ã‚Œã‚‹ã¹ãä½œæ¥­ã‚’ã‚«ãƒ—ã‚»ãƒ«åŒ–ã—ã¦ã„ã‚‹æ–°ãŸãªæ‰‹ç¶šãã€ã™ãªã‚ã¡<em>å®Ÿè¡Œæ‰‹ç¶šã</em>ã‚’è¿”ã™ã€‚
å®Ÿè¡Œæ‰‹ç¶šãã¯ã€å¼•æ•°ã¨ã—ã¦ç’°å¢ƒã‚’ã¨ã‚Šã€è©•ä¾¡ã‚’å®Œæˆã•ã›ã‚‹ã€‚
ã“ã‚Œã«ã‚ˆã£ã¦ä½œæ¥­ãŒç¯€ç´„ã•ã‚Œã‚‹ã€‚ã¨ã„ã†ã®ã‚‚ã€å®Ÿè¡Œæ‰‹ç¶šãã¯ä½•åº¦ã‚‚å‘¼ã°ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œãªã„ãŒã€<tt>analyze</tt> ã¯ä¸€ã¤ã®å¼ã«å¯¾ã—ã¦ãŸã ä¸€åº¦ã ã‘å‘¼ã°ã‚Œã‚‹ã§ã‚ã‚ã†ã‹ã‚‰ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
With the separation into analysis and execution, <tt>eval</tt> now becomes</p>

<p class="trans" lang="ja">
åˆ†æã¨å®Ÿè¡Œã¸ã®åˆ†é›¢ã‚’è¡Œã†ã¨ã€ã“ã“ã§ <tt>eval</tt> ã¯ã€æ¬¡ã®ã‚ˆã†ã«ãªã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_4654"></a>(define (eval exp env)
  ((analyze exp) env))
</p>

<p class="orig" lang="en">
The result of calling <tt>analyze</tt> is the execution procedure to
be applied to the environment.  The <tt>analyze</tt> procedure is
the same case analysis as performed by the original <tt>eval</tt> of
section <a href="#%_sec_4.1.1">4.1.1</a>, except that the procedures to
which we dispatch perform only analysis, not full evaluation:</p>

<p class="trans" lang="ja">
<tt>analyze</tt> ã‚’å‘¼ã³å‡ºã—ãŸçµæœã¯ã€ç’°å¢ƒã«å¯¾ã—ã¦é©ç”¨ã™ã¹ãå®Ÿè¡Œæ‰‹ç¶šãã§ã‚ã‚‹ã€‚
æŒ¯ã‚Šåˆ†ã‘å…ˆã®æ‰‹ç¶šããŒã€åˆ†æã®ã¿ã‚’è¡Œã„ã€å®Œå…¨ãªè©•ä¾¡ã¯è¡Œã‚ãªã„ã€ã¨ã„ã†ç‚¹ã‚’é™¤ã„ã¦ã€<tt>analyze</tt> ã¨ã„ã†æ‰‹ç¶šãã¯ã€<a href="#%_sec_4.1.1">4.1.1</a>ç¯€ã®å…ƒã® <tt>eval</tt> ã«ã‚ˆã‚Šè¡Œã‚ã‚Œã‚‹ã®ã¨åŒã˜ã€å ´åˆåˆ†ã‘åˆ†æã§ã‚ã‚‹ã€‚
</p>

<p class="lisp"><a name="%_idx_4656"></a>(define (analyze exp)
  (cond ((self-evaluating? exp) 
         (analyze-self-evaluating exp))
        ((quoted? exp) (analyze-quoted exp))
        ((variable? exp) (analyze-variable exp))
        ((assignment? exp) (analyze-assignment exp))
        ((definition? exp) (analyze-definition exp))
        ((if? exp) (analyze-if exp))
        ((lambda? exp) (analyze-lambda exp))
        ((begin? exp) (analyze-sequence (begin-actions exp)))
        ((cond? exp) (analyze (cond-&gt;if exp)))
        ((application? exp) (analyze-application exp))
        (else
         (error &quot;Unknown expression type -- ANALYZE&quot; exp))))
</p>

<p class="orig" lang="en">
Here is the simplest syntactic analysis procedure, which handles
self-evaluating expressions.  It returns an execution procedure that
ignores its environment argument and just returns the expression:</p>

<p class="trans" lang="ja">
ã“ã“ã«ã€ã‚‚ã£ã¨ã‚‚ç°¡å˜ãªæ–‡æ³•çš„è§£ææ‰‹ç¶šãã‚’ç¤ºã™ãŒã€ã“ã‚Œã¯ã€è‡ªå·±è©•ä¾¡å¼ã‚’å–ã‚Šæ‰±ã£ã¦ã„ã‚‹ã€‚
ã“ã‚Œã¯ã€ç’°å¢ƒå¼•æ•°ã‚’ç„¡è¦–ã—ã¦ãŸã å¼ã‚’è¿”ã™ã ã‘ã®ã€å®Ÿè¡Œæ‰‹ç¶šãã‚’è¿”ã™ã€‚
</p>

<a name="%_idx_4658"></a><p class="lisp">(define (analyze-self-evaluating exp)
  (lambda (env) exp))
</p>


<p class="orig" lang="en">
For a quoted expression, we can gain a little efficiency by
extracting the text of the quotation only once, in the analysis phase,
rather than in the execution phase.</p>

<p class="trans" lang="ja">
å¼•ç”¨ã•ã‚ŒãŸå¼ã«ã¤ã„ã¦ã¯ã€å®Ÿè¡Œæ®µéšã§ã¯ãªãã‚€ã—ã‚åˆ†ææ®µéšã«ãŠã„ã¦ãŸã ä¸€å›ã ã‘ã€ãã®å¼•ç”¨ã§ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’æŠ½å‡ºã™ã‚‹ã“ã¨ã§ã€å°‘ã—åŠ¹ç‡ã‚’ä¸Šã’ã‚‰ã‚Œã‚‹ã€‚
</p>


<p class="lisp">(define (analyze-quoted exp)
  (let ((qval (text-of-quotation exp)))
    (lambda (env) qval)))
</p>


<p class="orig" lang="en">
Looking up a variable value must still be done in the execution phase,
since this depends upon knowing the environment.<a name="call_footnote_Temp_570" href="#footnote_Temp_570"><sup><small>29</small></sup></a></p>

<p class="trans" lang="ja">
å¤‰æ•°ã®å€¤ã‚’èª¿ã¹ã‚‹ã“ã¨ã¯ã€ç’°å¢ƒã‚’çŸ¥ã‚‹ã“ã¨ã«ä¾å­˜ã™ã‚‹ã®ã§ã€ä¾ç„¶ã¨ã—ã¦ã€å®Ÿè¡Œæ®µéšã§è¡Œã‚ã‚Œãªãã¦ã¯ãªã‚‰ãªã„<a href="#footnote_Temp_570"><sup><small>29</small></sup></a>ã€‚
</p>

<p class="lisp">(define (analyze-variable exp)
  (lambda (env) (lookup-variable-value exp env)))
</p>

<p class="orig" lang="en">
<tt>Analyze-assignment</tt> also must defer actually setting the variable
until the execution, when the environment has been supplied.  However,
the fact that the <tt>assignment-value</tt> expression can be
analyzed (recursively) during analysis is a major gain in efficiency,
because the <tt>assignment-value</tt> expression will now be analyzed
only once.  The same holds true for definitions.</p>

<p class="trans" lang="ja">
<tt>analyze-assignment</tt> ã‚‚ã€å¤‰æ•°ã‚’å®Ÿéš›ã«è¨­å®šã™ã‚‹ã“ã¨ã‚’ã€å®Ÿè¡Œæ™‚â€”â€”ç’°å¢ƒãŒä¸ãˆã‚‰ã‚Œã‚‹ã¨ãâ€”â€”ã¾ã§ã€å»¶æœŸã›ã­ã°ãªã‚‰ãªã„ã€‚
ã—ã‹ã—ã€è§£æã®é–“ã« <tt>analyze-value</tt> å¼ã‚’ (å†å¸°çš„ã«) è§£æã§ãã‚‹ã€ã¨ã„ã†äº‹å®Ÿã¯ã€åŠ¹ç‡ã«ãŠã‘ã‚‹å¤§ããªé€²æ­©ã§ã‚ã‚‹ã€‚ã¨ã„ã†ã®ã‚‚ã€<tt>analyze-value</tt> å¼ã¯ä»Šã‚„ãŸã ä¸€åº¦ã ã‘è§£æã•ã‚Œã‚‹ã‹ã‚‰ã§ã‚ã‚‹ã€‚
åŒã˜ã“ã¨ã¯ã€å®šç¾©ã«ã¤ã„ã¦ã‚‚æˆã‚Šç«‹ã¤ã€‚
</p>

<p class="lisp">(define (analyze-assignment exp)
  (let ((var (assignment-variable exp))
        (vproc (analyze (assignment-value exp))))
    (lambda (env)
      (set-variable-value! var (vproc env) env)
      'ok)))
(define (analyze-definition exp)
  (let ((var (definition-variable exp))
        (vproc (analyze (definition-value exp))))
    (lambda (env)
      (define-variable! var (vproc env) env)
      'ok)))
</p>

<p class="orig" lang="en">
For <tt>if</tt> expressions, we extract and analyze the predicate,
consequent, and alternative at analysis time.</p>

<p class="trans" lang="ja">
<tt>if</tt> å¼ã«å¯¾ã—ã¦ã¯ã€è§£ææ™‚ã«ã€è¿°èªã¨å¸°çµå¼ã¨ä»£æ›¿å¼ã¨ã‚’æŠ½å‡ºãŠã‚ˆã³è§£æã™ã‚‹ã€‚
</p>

<p class="lisp">(define (analyze-if exp)
  (let ((pproc (analyze (if-predicate exp)))
        (cproc (analyze (if-consequent exp)))
        (aproc (analyze (if-alternative exp))))
    (lambda (env)
      (if (true? (pproc env))
          (cproc env)
          (aproc env)))))
</p>

<p class="orig" lang="en">
Analyzing a <tt>lambda</tt> expression also achieves a major
gain in efficiency: We analyze the <tt>lambda</tt> body only once, even though
procedures resulting from evaluation of the <tt>lambda</tt>
may be applied many times.</p>

<p class="trans" lang="ja">
<tt>lambda</tt> å¼ã‚’è§£æã™ã‚‹ã“ã¨ã‚‚ã€åŠ¹ç‡ã«ãŠã‘ã‚‹å¤§ããªé€²æ­©ã‚’é”æˆã™ã‚‹ã€‚
ãŸã¨ãˆã€<tt>lambda</tt> ã®è©•ä¾¡ã«ã‚ˆã‚Šç”Ÿã˜ã‚‹æ‰‹ç¶šããŒã€ä½•åº¦ã‚‚é©ç”¨ã•ã‚Œã‚‹ã“ã¨ãŒã‚ã‚‹ã®ã ã¨ã—ã¦ã‚‚ã€ç§ãŸã¡ã¯ã€<tt>lambda</tt> æœ¬ä½“ã‚’ãŸã£ãŸä¸€åº¦è§£æã™ã‚‹ã ã‘ãªã®ã ã€‚
</p>

<p class="lisp">(define (analyze-lambda exp)
  (let ((vars (lambda-parameters exp))
        (bproc (analyze-sequence (lambda-body exp))))
    (lambda (env) (make-procedure vars bproc env))))
</p>

<p class="orig" lang="en">
Analysis of a sequence of expressions (as in a <tt>begin</tt> or the body
of a <tt>lambda</tt> expression) is more involved.<a name="call_footnote_Temp_571" href="#footnote_Temp_571"><sup><small>30</small></sup></a>
Each expression
in the sequence is analyzed, yielding an execution
procedure.  These execution procedures are combined to produce an
execution
procedure that takes an environment as argument and sequentially calls
each individual execution procedure with the environment as argument.</p>

<p class="trans" lang="ja">
å¼ã®é€£ãªã‚Š (<tt>begin</tt> ã®ä¸­ã«ã‚ã‚‹ã‚ˆã†ãªã‚‚ã®ã€ã‚ã‚‹ã„ã¯ã€<tt>lambda</tt> å¼ã®æœ¬ä½“ã®ã‚ˆã†ãªã‚‚ã®) ã®è§£æã¯ã€ã‚ˆã‚Šè¾¼ã¿å…¥ã£ã¦ã„ã‚‹<a href="#footnote_Temp_571"><sup><small>30</small></sup></a>ã€‚
ãã®é€£ãªã‚Šã®ä¸­ã®ãã‚Œãã‚Œã®å¼ãŒè§£æã•ã‚Œã€å®Ÿè¡Œæ‰‹ç¶šãã‚’ä½œã‚Šå‡ºã™ã€‚
<!--ã“ã‚Œã‚‰ã®å®Ÿè¡Œæ‰‹ç¶šãã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ãªå®Ÿè¡Œæ‰‹ç¶šãã‚’ä½œã‚Šå‡ºã™ã‚ˆã†ã«çµåˆã•ã‚Œã‚‹ã€‚ã™ãªã‚ã¡ã€å¼•æ•°ã¨ã—ã¦ç’°å¢ƒã‚’ã¨ã‚Šã€å€‹åˆ¥ã®å„å®Ÿè¡Œæ‰‹ç¶šãã‚’ã€å½“è©²ç’°å¢ƒã‚’å¼•æ•°ã¨ã—ã¦ã€é †ã«å‘¼ã³å‡ºã™ã‚ˆã†ãªå®Ÿè¡Œæ‰‹ç¶šãã§ã‚ã‚‹ã€‚-->
<!--å¼•æ•°ã¨ã—ã¦ç’°å¢ƒã‚’ã¨ã‚Šã€å€‹åˆ¥ã®å„å®Ÿè¡Œæ‰‹ç¶šãã‚’ã€å½“è©²ç’°å¢ƒã‚’å¼•æ•°ã¨ã—ã¦ã€é †ã«å‘¼ã³å‡ºã™ã‚ˆã†ãªå®Ÿè¡Œæ‰‹ç¶šãã‚’ä½œã‚Šå‡ºã™ã‚ˆã†ã«ã€ã“ã‚Œã‚‰ã®å®Ÿè¡Œæ‰‹ç¶šããŒçµåˆã•ã‚Œã‚‹ã€‚-->
ã“ã‚Œã‚‰ã®å®Ÿè¡Œæ‰‹ç¶šãã¯ã€å¼•æ•°ã¨ã—ã¦ç’°å¢ƒã‚’ã¨ã£ã¦å½“è©²ç’°å¢ƒã‚’å¼•æ•°ã«ã—ã¦å€‹åˆ¥ã®å„å®Ÿè¡Œæ‰‹ç¶šãã‚’é †ã«å‘¼ã³å‡ºã™ã‚ˆã†ãªä¸€ã¤ã®å®Ÿè¡Œæ‰‹ç¶šãã‚’ä½œã‚Šå‡ºã™ã‚ˆã†ã«ã€çµåˆã•ã‚Œã‚‹ã€‚
</p>

<p class="lisp">(define (analyze-sequence exps)
  (define (sequentially proc1 proc2)
    (lambda (env) (proc1 env) (proc2 env)))
  (define (loop first-proc rest-procs)
    (if (null? rest-procs)
        first-proc
        (loop (sequentially first-proc (car rest-procs))
              (cdr rest-procs))))
  (let ((procs (map analyze exps)))
    (if (null? procs)
        (error &quot;Empty sequence -- ANALYZE&quot;))
    (loop (car procs) (cdr procs))))
</p>

<p class="orig" lang="en">
To analyze an application, we analyze the operator and operands and
construct an execution procedure that
calls the operator execution procedure (to obtain the
actual procedure to be applied) and the operand execution
procedures (to obtain the actual arguments).  We then pass these to <tt>execute-application</tt>, which is the analog of <tt>apply</tt> in
section <a href="#%_sec_4.1.1">4.1.1</a>.
<tt>Execute-application</tt> differs from <tt>apply</tt> in that the procedure body for a compound procedure has already
been analyzed, so there is no need to do further analysis.  Instead,
we just call the execution procedure for the body on the extended
environment.
</p>


<p class="trans" lang="ja">
é©ç”¨ã‚’è§£æã™ã‚‹ã«ã¯ã€ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ã¨ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã‚’è§£æã—ã€ãã—ã¦ã€(é©ç”¨ã™ã¹ãå®Ÿéš›ã®æ‰‹ç¶šãã‚’å¾—ã‚‹ã¹ãï¼‰ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ã®å®Ÿè¡Œçš„ç¶šãã‚’å‘¼ã³å‡ºã™ã¨ã¨ã‚‚ã« (å®Ÿéš›ã®å®Ÿå¼•æ•°ã‚’å¾—ã‚‹ã¹ã) ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã®å®Ÿè¡Œçš„ç¶šãã‚’å‘¼ã³å‡ºã™ã‚ˆã†ãªå®Ÿè¡Œæ‰‹ç¶šãã‚’ã€æ§‹ç¯‰ã™ã‚‹ã€‚
ãã‚Œã‹ã‚‰ã€ã“ã‚Œã‚‰ã‚’ <tt>execute-application</tt> â€”â€”<a href="#%_sec_4.1.1">4.1.1</a>ç¯€ã® <tt>apply</tt> ã®ç›¸ä¼¼ç‰©â€”â€”ã¸ã¨æ¸¡ã™ã€‚
<tt>execute-application</tt> ã¯ã€è¤‡åˆçš„æ‰‹ç¶šãã®æ‰‹ç¶šãæœ¬ä½“ãŒã™ã§ã«è§£æã•ã‚Œã¦ã„ã¦ã€ãã®ãŸã‚ã€ã•ã‚‰ãªã‚‹è§£æã¯ä¸è¦ã§ã‚ã‚‹ã€ã¨ã„ã†ç‚¹ã§ã€<tt>apply</tt> ã¨ã¯ç•°ãªã‚‹ã€‚
ä»£ã‚ã‚Šã«ã€å˜ã«æ‹¡å¼µã•ã‚ŒãŸç’°å¢ƒä¸Šã§ã€æœ¬ä½“ã«ã¤ã„ã¦ã®å®Ÿè¡Œæ‰‹ç¶šãã‚’å‘¼ã³å‡ºã™ã ã‘ã§ã‚ˆã„ã€‚
</p>

<p class="lisp">(define (analyze-application exp)
  (let ((fproc (analyze (operator exp)))
        (aprocs (map analyze (operands exp))))
    (lambda (env)
      (execute-application (fproc env)
                           (map (lambda (aproc) (aproc env))
                                aprocs)))))
<a name="%_idx_4660"></a>(define (execute-application proc args)
  (cond ((primitive-procedure? proc)
         (apply-primitive-procedure proc args))
        ((compound-procedure? proc)
         ((procedure-body proc)
          (extend-environment (procedure-parameters proc)
                              args
                              (procedure-environment proc))))
        (else
         (error
          &quot;Unknown procedure type -- EXECUTE-APPLICATION&quot;
          proc))))
</p>

<p class="orig" lang="en">
Our new evaluator uses the same data structures, syntax
procedures, and run-time support procedures as in
sections <a href="#%_sec_4.1.2">4.1.2</a>,
 <a href="#%_sec_4.1.3">4.1.3</a>, and <a href="#%_sec_4.1.4">4.1.4</a>.</p>

<p class="trans" lang="ja">
æ–°ãŸãªè©•ä¾¡å™¨ã¯ã€<a href="#%_sec_4.1.2">4.1.2</a>ç¯€ã‚„<a href="#%_sec_4.1.3">4.1.3</a>ç¯€ã‚„<a href="#%_sec_4.1.4">4.1.4</a>ç¯€ã§ã®ã‚‚ã®ã¨åŒã˜ã€ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã¨ã€æ–‡æ³•ä¸Šã®æ‰‹ç¶šãã¨ã€å®Ÿè¡Œæ™‚ã®ã‚µãƒãƒ¼ãƒˆæ‰‹ç¶šãã¨ã‚’ç”¨ã„ã‚‹ã€‚
</p>

<p class="orig" lang="en">
<a name="%_thm_4.22"></a>
<b>Exercise 4.22.</b>  <a name="%_idx_4662"></a>Extend the evaluator in this section to support the special form <tt>let</tt>.
(See exercise <a href="#%_thm_4.6">4.6</a>.)
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.22.</b> ç‰¹æ®Šå½¢å¼ <tt>let</tt> ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚ˆã†ã«ã€æœ¬ç¯€ã®è©•ä¾¡å™¨ã‚’æ‹¡å¼µã›ã‚ˆ (ç·´ç¿’å•é¡Œ<a href="#%_thm_4.6">4.6</a>ã‚’å‚ç…§)ã€‚
</p>

<p class="exercise"><span class="ex_comment"></span></p>

<p class="orig" lang="en">
<a name="%_thm_4.23"></a>
<b>Exercise 4.23.</b>  <a name="%_idx_4664"></a>Alyssa P. Hacker doesn't understand why <tt>analyze-sequence</tt> needs to be
so complicated.  All the other analysis procedures
are straightforward transformations of the corresponding evaluation
procedures (or <tt>eval</tt> clauses) in section <a href="#%_sec_4.1.1">4.1.1</a>.
She expected <tt>analyze-sequence</tt> to look like this:</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.23.</b> ã‚¢ãƒªãƒƒã‚µãƒ»Pãƒ»ãƒãƒƒã‚«ã¯ã€ãªãœ <tt>analyze-sequence</tt> ãŒã‚ã‚“ãªã«è¤‡é›‘ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚‹ã®ã‹ã€ç†è§£ã§ããªã„ã€‚
ä»–ã®ã™ã¹ã¦ã®è§£ææ‰‹ç¶šãã¯ã€<a href="#%_sec_4.1.1">4.1.1</a>ç¯€ã«ãŠã‘ã‚‹ã€å¯¾å¿œã™ã‚‹è©•ä¾¡æ‰‹ç¶šã (ã‚‚ã—ãã¯ <tt>eval</tt> ç¯€) ã®ã€å˜ç´”ãªå¤‰å½¢ã§ã‚ã‚‹ã€‚
ã‚¢ãƒªãƒƒã‚µã¯ã€<tt>analyze-sequence</tt> ãŒä»¥ä¸‹ã®ã‚ˆã†ãªã‚‚ã®ã ã€ã¨äºˆæ¸¬ã—ã¦ã„ãŸã€‚
</p>


<p class="lisp">(define (analyze-sequence exps)
  (define (execute-sequence procs env)
    (cond ((null? (cdr procs)) ((car procs) env))
          (else ((car procs) env)
                (execute-sequence (cdr procs) env))))
  (let ((procs (map analyze exps)))
    (if (null? procs)
        (error &quot;Empty sequence -- ANALYZE&quot;))
    (lambda (env) (execute-sequence procs env))))
</p>

<p class="orig" lang="en">Eva Lu Ator explains to Alyssa that the version in the text does more
of the work of evaluating a sequence at analysis time.  Alyssa's
sequence-execution procedure, rather than having the calls to the
individual execution procedures built in, loops through the procedures
in order to call them: In effect, although the individual expressions
in the sequence have been analyzed, the sequence itself has not been.</p>

<p class="trans" lang="ja">
ã‚¨ãƒ´ã‚¡ãƒ»ãƒªãƒ¥ãƒ»ã‚¨ã‚¤ã‚¿ã¯ã€ã‚¢ãƒªãƒƒã‚µã«å¯¾ã—ã¦ã“ã†èª¬æ˜ã™ã‚‹ã€‚ã™ãªã‚ã¡ã€æœ¬æ–‡ä¸­ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯ã€è§£ææ™‚ã«ã€é€£ãªã‚Šã‚’è©•ä¾¡ã™ã‚‹ã¨ã„ã†ä½œæ¥­ä»¥ä¸Šã®ã“ã¨ã‚’ã™ã‚‹ã®ã ã€ã¨ã€‚
ã‚¢ãƒªãƒƒã‚µã®é€£ãªã‚Šã«ã¤ã„ã¦ã®å®Ÿè¡Œæ‰‹ç¶šãã¯ã€å€‹ã€…ã®å®Ÿè¡Œæ‰‹ç¶šãã¸ã®å‘¼ã³å‡ºã—ãŒçµ„ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹ã‚ˆã†ã«ã™ã‚‹ã€ã¨ã„ã†ã‚ˆã‚Šã‚€ã—ã‚ã€æ‰‹ç¶šãã‚’å‘¼ã³å‡ºã™ãŸã‚ã«ãã‚Œã‚‰ã®æ‰‹ç¶šãã‚’å§‹ã‚ã‹ã‚‰çµ‚ã‚ã‚Šã¾ã§ãƒ«ãƒ¼ãƒ—ã—ã¦ã„ã‚‹ã€‚
äº‹å®Ÿä¸Šã€é€£ãªã‚Šã«ãŠã‘ã‚‹å€‹ã€…ã®å¼ãŒè§£æã•ã‚Œã¦ã¯ã„ã‚‹ã®ã ãŒã€ãã®é€£ãªã‚Šãã®ã‚‚ã®ã¯ã¾ã è§£æã•ã‚Œã¦ã„ãªã„ã®ã ã€‚
</p>

<p class="orig" lang="en">
Compare the two versions of <tt>analyze-sequence</tt>.  For example,
consider the common case (typical of procedure bodies) where the
sequence has just one expression.  What work will the execution
procedure produced by Alyssa's program do?  What about the execution
procedure produced by the program in the text above?  How do the two
versions compare for a sequence with two expressions?
</p>

<p class="trans" lang="ja">
<tt>analyze-sequence</tt> ã®äºŒã¤ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’æ¯”è¼ƒã›ã‚ˆã€‚
ãŸã¨ãˆã°ã€é€£ãªã‚ŠãŒãŸã ä¸€ã¤ã®å¼ã ã‘ã‚’æœ‰ã™ã‚‹ã‚ˆã†ãªã€ã‚ˆãã‚ã‚‹å ´åˆ (æ‰‹ç¶šãæœ¬ä½“ã®å…¸å‹ã§ã‚ã‚‹) ã‚’è€ƒãˆã‚ˆã†ã€‚
ã‚¢ãƒªãƒƒã‚µã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ã‚ˆã‚Šä½œã‚Šå‡ºã•ã‚Œã‚‹å®Ÿè¡Œæ‰‹ç¶šãã¯ã€ã©ã®ã‚ˆã†ãªä½œæ¥­ã‚’è¡Œã†ã ã‚ã†ã€‚
ä¸Šè¨˜æœ¬æ–‡ä¸­ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ã‚ˆã‚Šä½œã‚Šå‡ºã•ã‚Œã‚‹å®Ÿè¡Œæ‰‹ç¶šãã«ã¤ã„ã¦ã¯ã€ã©ã†ã ã‚ã†?
äºŒã¤ã®å¼ã‚’æŒã¤é€£ãªã‚Šã«ã¤ã„ã¦ã¯ã€ã“ã®äºŒã¤ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯ã©ã†å¯¾æ¯”ã•ã‚Œã‚‹ã ã‚ã†?
</p>

<p class="exercise"><span class="ex_comment"></span></p>

<p class="orig" lang="en">
<a name="%_thm_4.24"></a>
<b>Exercise 4.24.</b>  Design and carry out some experiments to 
compare the speed of the original metacircular evaluator
with the version in this section.  Use your results to estimate the fraction
of time that is spent in analysis versus execution for various
procedures.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ4.24.</b> å…ƒã®ãƒ¡ã‚¿å¾ªç’°çš„è©•ä¾¡å™¨ã®é€Ÿåº¦ã‚’æœ¬ç¯€ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¨æ¯”ã¹ã‚‹ãŸã‚ã®ã€ä½•ã‚‰ã‹ã®å®Ÿé¨“ã‚’è¨­è¨ˆã—ã€å®Ÿè¡Œã›ã‚ˆã€‚
å›ã®çµæœã‚’ä½¿ã£ã¦ã€æ§˜ã€…ãªæ‰‹ç¶šãã«ã¤ã„ã¦ã€è§£æã¨å®Ÿè¡Œã«è²»ã‚„ã•ã‚Œã‚‹æ™‚é–“ã®å‰²åˆã‚’è¦‹ç©ã‚‚ã‚Œã€‚
</p>

<p class="exercise"><span class="ex_comment"></span></p>

<a name="footnotes"></a>
<hr>

<p class="orig" lang="en"><a name="footnote_Temp_510" href="#call_footnote_Temp_510"><sup><small>3</small></sup></a> Even so, there will remain important aspects of
the evaluation process that are not elucidated by our evaluator.  The
most important of these are the detailed mechanisms by which
procedures call other procedures and return values to their callers.
We will address these issues in chapter 5, where we take a closer look
at the evaluation process by implementing the evaluator as a simple
register machine.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_510"><sup><small>3</small></sup></a>
ãŸã¨ãˆãã†ã§ã‚ã£ã¦ã‚‚ã€ç§ãŸã¡ã®è©•ä¾¡å™¨ã«ã‚ˆã£ã¦ã¯æ˜ã‚‰ã‹ã«ã•ã‚Œã¦ã„ãªã„ã‚ˆã†ãªã€è©•ä¾¡ã®é‡è¦ãªå´é¢ãŒã€æ®‹ã‚‹ã§ã‚ã‚ã†ã€‚
ã“ã‚Œã‚‰ã®å´é¢ã®ã†ã¡ã§æœ€ã‚‚é‡è¦ãªã‚‚ã®ã¯ã€æ‰‹ç¶šããŒä»–ã®æ‰‹ç¶šãã‚’å‘¼ã³å‡ºã—ã¦å€¤ã‚’å‘¼ã³å‡ºã—å…ƒã¸ã¨è¿”ã™ã‚ˆã†ã«ã™ã‚‹è©³ç´°ãªä»•çµ„ã¿ã§ã‚ã‚‹ã€‚
ã“ã‚Œã‚‰ã®è«–ç‚¹ã«ã¯5ç« ã§å–ã‚Šçµ„ã‚‚ã†â€”â€”ãã“ã§ã¯ã€è©•ä¾¡å™¨ã‚’å˜ç´”ãªãƒ¬ã‚¸ã‚¹ã‚¿ãƒã‚·ãƒ³ã¨ã—ã¦å®Ÿè£…ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€ã‚ˆã‚Šç¶¿å¯†ã«è©•ä¾¡ãƒ—ãƒ­ã‚»ã‚¹ã‚’èª¿ã¹ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_511" href="#call_footnote_Temp_511"><sup><small>4</small></sup></a> If we grant ourselves the ability to apply primitives,
<a name="%_idx_4222"></a>then what remains for us to implement in the evaluator?  The job of
the evaluator is not to specify the primitives of the language, but rather
to provide the connective tissue -- the means of combination and the
means of abstraction -- that binds a collection of primitives to form a
language.  Specifically:
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_511"><sup><small>4</small></sup></a>
ã‚‚ã—ç§ãŸã¡ãŒã€ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã‚’é©ç”¨ã™ã‚‹èƒ½åŠ›ã‚’è‡ªåˆ†è‡ªèº«ã«ä¸ãˆã‚‹ãªã‚‰ã€ç§ãŸã¡ãŒè©•ä¾¡å™¨ã®ä¸­ã«å®Ÿè£…ã™ã¹ãã‚‚ã®ã¨ã—ã¦ä½•ãŒæ®‹ã£ã¦ã„ã‚‹ã ã‚ã†?
è©•ä¾¡å™¨ã®ä»•äº‹ã¯ã€è¨€èªã®ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ã§ã¯ãªãã€ã‚€ã—ã‚ã€è¨€èªã‚’å½¢æˆã™ã‚‹ã‚ˆã†ã«ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã®é›†ã¾ã‚Šã‚’æŸç¸›ã™ã‚‹ã‚ˆã†ãªçµåˆçµ„ç¹”â€”â€”çµåˆã®æ‰‹æ®µã¨æŠ½è±¡åŒ–ã®æ‰‹æ®µâ€”â€”ã‚’æä¾›ã™ã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚å…·ä½“çš„ã«ã¯ã€æ¬¡ã®ã¨ãŠã‚Šã§ã‚ã‚‹ã€‚
</p>

<ul class="orig" lang="en">
<li>The evaluator enables us to deal with nested expressions.  For
example, although simply applying primitives
would suffice for evaluating
the expression <tt>(+ 1 6)</tt>, it is not adequate for handling <tt>(+ 1 (* 2
3))</tt>.  As far as the primitive procedure <tt>+</tt> is concerned,
its arguments must be numbers, and it would choke if we passed it the
expression <tt>(* 2 3)</tt> as an argument.  One important role of the
evaluator is to choreograph procedure composition so that <tt>(* 2
3)</tt> is reduced to 6 before being passed as an argument to <tt>+</tt>.</li>

<li>The evaluator allows us to use variables.  For example, the
primitive procedure for addition has no way to deal with expressions such
as <tt>(+ x 1)</tt>.  We need an evaluator to keep track of variables and
obtain their values before invoking the primitive
procedures.</li>

<li>The evaluator allows us to define compound procedures.  This
involves keeping track of procedure definitions, knowing how to use
these definitions in evaluating expressions, and providing a mechanism
that enables procedures to accept arguments.</li>

<li>The evaluator provides the special forms, which must be
evaluated differently from procedure calls.</li>
</ul>

<ul class="trans" lang="ja">
<li>è©•ä¾¡å™¨ã¯ã€å…¥ã‚Œå­ã«ãªã£ãŸå¼ã‚’æ‰±ãˆã‚‹ã‚ˆã†ã«ã—ã¦ãã‚Œã‚‹ã€‚
ãŸã¨ãˆã°ã€<tt>(+ 1 6)</tt> ã¨ã„ã†å¼ã‚’è©•ä¾¡ã™ã‚‹ã«ã¯ã€å˜ç´”ã«ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã‚’é©ç”¨ã™ã‚‹ã“ã¨ã ã‘ã§ååˆ†ã ãŒã€<tt>(+ 1 (* 2 3))</tt> ã‚’æ‰±ã†ã«ã¯ã€ã“ã‚Œã¯ååˆ†æº€è¶³ãªã‚‚ã®ã§ã¯ãªã„ã€‚

<tt>+</tt> ã¨ã„ã†åŸå§‹çš„æ‰‹ç¶šãã«é–¢ã™ã‚‹é™ã‚Šã€ã“ã‚Œã®å®Ÿå¼•æ•°ã¯æ•°ã§ãªãã¦ã¯ãªã‚‰ãšã€ã‚‚ã—ã“ã‚Œã« <tt>(* 2 3)</tt> ã¨ã„ã†å¼ã‚’å®Ÿå¼•æ•°ã¨ã—ã¦æ¸¡ã—ãŸã‚‰ã€ã“ã‚Œã¯çª’æ¯ã—ã¦ã—ã¾ã†ã ã‚ã†ã€‚
è©•ä¾¡å™¨ã®ã€é‡è¦ãªä¸€ã¤ã®å½¹å‰²ã¯ã€<tt>(* 2 3)</tt> ãŒã€<tt>+</tt> ã¸ã®å¼•æ•°ã¨ã—ã¦æ¸¡ã•ã‚Œã‚‹å‰ã«6ã¸ã¨ç°¡ç´„åŒ–ã•ã‚Œã‚‹ã‚ˆã†ã«ã€æ‰‹ç¶šãã®æ§‹æˆã‚’æŒ‡æ®ã™ã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚
</li>
<li>è©•ä¾¡å™¨ã¯ã€å¤‰æ•°ã‚’ä½¿ãˆã‚‹ã‚ˆã†ã«ã—ã¦ãã‚Œã‚‹ã€‚
ãŸã¨ãˆã°ã€åŠ ç®—ã®ãŸã‚ã®åŸå§‹çš„æ‰‹ç¶šãã¯ã€<tt>(+ x 1)</tt> ã®ã‚ˆã†ãªå¼ã‚’æ‰±ã†è¡“ã‚’æŒãŸãªã„ã€‚
å¤‰æ•°ã‚’è¿½ã„ã‹ã‘ã¦æŠŠæ¡ã—ã€ãã—ã¦ã€åŸå§‹çš„æ‰‹ç¶šãã‚’å‘¼ã³å‡ºã™å‰ã«å¤‰æ•°ã®å€¤ã‚’å–å¾—ã™ã‚‹ã“ã¨ã‚’ã€ç§ãŸã¡ã¯è©•ä¾¡å™¨ã«æ±‚ã‚ã‚‹ã€‚</li>
<li>è©•ä¾¡å™¨ã¯ã€è¤‡åˆçš„æ‰‹ç¶šãã‚’å®šç¾©ã§ãã‚‹ã‚ˆã†ã«ã—ã¦ãã‚Œã‚‹ã€‚
ã“ã‚Œã¯ã€æ‰‹ç¶šãã‚’å®šç¾©ã‚’è¿½ã„ã‹ã‘ã¦æŠŠæ¡ã™ã‚‹ã“ã¨ã¨ã€å¼ã‚’è©•ä¾¡ã™ã‚‹éš›ã«ã“ã‚Œã‚‰ã®å®šç¾©ã‚’ã©ã®ã‚ˆã†ã«ä½¿ã†ã®ã‹ã‚’çŸ¥ã£ã¦ã„ã‚‹ã“ã¨ã¨ã€æ‰‹ç¶šããŒå®Ÿå¼•æ•°ã‚’å—ã‘å…¥ã‚Œã‚‹ã“ã¨ã‚’å¯èƒ½ã«ã™ã‚‹ä»•çµ„ã¿ã‚’æä¾›ã™ã‚‹ã“ã¨ã‚’ã€ä¼´ã†ã€‚</li>
<li>è©•ä¾¡å™¨ã¯ã€ç‰¹æ®Šå½¢å¼â€”â€”æ‰‹ç¶šãå‘¼ã³å‡ºã—ã¨ã¯ç•°ãªã‚‹æ–¹æ³•ã§è©•ä¾¡ã•ã‚Œã­ã°ãªã‚‰ãªã„â€”â€”ã‚’æä¾›ã™ã‚‹ã€‚</li>
</ul>

<p class="orig" lang="en">
<a name="footnote_Temp_518" href="#call_footnote_Temp_518"><sup><small>5</small></sup></a> We could have simplified the <tt>application?</tt> clause in <tt>eval</tt> by using <tt>map</tt>
(and stipulating that <tt>operands</tt> returns a list) rather than
writing an explicit <tt>list-of-values</tt> procedure.  We chose not to
use <tt>map</tt> here to emphasize the fact that the <a name="%_idx_4252"></a><a name="%_idx_4254"></a>evaluator can be
implemented without any use of higher-order procedures
(and thus could be written in a language that doesn't have
higher-order procedures), even though
the language that it supports will include higher-order procedures.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_518"><sup><small>5</small></sup></a>
æ˜ç¤ºçš„ãª <tt>list-of-values</tt> ã®æ‰‹ç¶šãã‚’æ›¸ãã‚ˆã‚Šã‚‚ã‚€ã—ã‚ã€<tt>map</tt> ã‚’ä½¿ã†ã“ã¨ã«ã‚ˆã£ã¦ (ãã—ã¦ã€<tt>operands</tt> ã¯ãƒªã‚¹ãƒˆã‚’è¿”ã™ã€ã¨è¦å®šã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦)ã€<tt>eval</tt> ã«ãŠã‘ã‚‹ <tt>application?</tt> ç¯€ã‚’ç°¡ç´ åŒ–ã™ã‚‹ã“ã¨ã‚‚ã§ããŸã§ã‚ã‚ã†ã€‚
ãŸã¨ãˆè©•ä¾¡å™¨<span class="note"> (itã‚’è©•ä¾¡å™¨ã¨è§£é‡ˆã—ãŸ) </span>ãŒã‚µãƒãƒ¼ãƒˆã™ã‚‹è¨€èªãŒã€é«˜éšæ‰‹ç¶šãã‚’å«ã‚€ã“ã¨ã«ãªã‚‹ã ã‚ã†ã¨ã—ã¦ã‚‚ã€é«˜éšæ‰‹ç¶šãã‚’ä½•ã‚‚ä½¿ã‚ãªã„ã§è©•ä¾¡å™¨ã‚’å®Ÿè£…ã§ãã‚‹ (ã‚ˆã£ã¦ã€é«˜éšæ‰‹ç¶šãã‚’æŒãŸãªã„è¨€èªã§ã‚‚è©•ä¾¡å™¨ã‚’æ›¸ã‘ãŸã ã‚ã†)ã€ã¨ã„ã†äº‹å®Ÿã‚’å¼·èª¿ã™ã‚‹ãŸã‚ã«ã€ç§ãŸã¡ã¯ã€ã“ã“ã§ã¯ <tt>map</tt> ã‚’ä½¿ã‚ãªã„ã“ã¨ã‚’é¸ã‚“ã ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_520" href="#call_footnote_Temp_520"><sup><small>6</small></sup></a> In this case, the language being implemented and the
implementation language are the same.  Contemplation of the meaning of
<a name="%_idx_4262"></a><tt>true?</tt> here yields expansion of consciousness without the abuse
of substance.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_520"><sup><small>6</small></sup></a>
ã“ã®å ´åˆã€å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹è¨€èªã¨å®Ÿè£…è¨€èªã¯ã€åŒã˜ã§ã‚ã‚‹ã€‚
ã“ã“ã§ã® <tt>true?</tt> ã®æ„å‘³ã«ã¤ã„ã¦ã®ç†Ÿè€ƒã¯ã€å®Ÿè³ªã‚’ä¾µå®³ã™ã‚‹ã“ã¨ãªãã€æ„è­˜ã®æ‹¡å¤§ã‚’ç”Ÿã¿å‡ºã™ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_523" href="#call_footnote_Temp_523"><sup><small>7</small></sup></a> This implementation of <tt>define</tt> ignores a subtle
issue in the handling of internal definitions, although it works
correctly in most cases.  We will see what the problem is and how to
solve it in section <a href="#%_sec_4.1.6">4.1.6</a>.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_523"><sup><small>7</small></sup></a>
<tt>define</tt> ã®å®Ÿè£…ã¯ã€ã»ã¨ã‚“ã©ã®å ´åˆã«ãŠã„ã¦æ­£ã—ãå‹•ä½œã™ã‚‹ã¨ã¯ã„ãˆã€å†…éƒ¨å®šç¾©ã®å–ã‚Šæ‰±ã„ã«ãŠã‘ã‚‹å¾®å¦™ãªè«–ç‚¹ã‚’ç„¡è¦–ã—ã¦ã„ã‚‹ã€‚
å•é¡Œã¯ãªã‚“ãªã®ã‹ã€ãã—ã¦ãã®å•é¡Œã‚’ã©ã†è§£æ±ºã™ã‚‹ã®ã‹ã€ã«ã¤ã„ã¦ã¯ã€<a href="#%_sec_4.1.6">4.1.6</a>ç¯€ã§è¦‹ã‚‹ã“ã¨ã«ã—ã‚ˆã†ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_524" href="#call_footnote_Temp_524"><sup><small>8</small></sup></a> As we said when we
introduced <tt>define</tt> and <tt>set!</tt>, these values
are implementation-dependent in Scheme -- that is, the implementor
can choose what value to return.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_524"><sup><small>8</small></sup></a>
<tt>define</tt> ã¨ <tt>set!</tt> ã‚’å°å…¥ã—ãŸã¨ãã«è¨€ã£ãŸã¨ãŠã‚Šã€Schemeã§ã¯ã€ã“ã‚Œã‚‰ã®å€¤ã¯å®Ÿè£…ä¾å­˜ã§ã‚ã‚‹ã€‚ã¤ã¾ã‚Šã€ã©ã‚“ãªå€¤ã‚’è¿”ã™ã®ã‹ã‚’å®Ÿè£…è€…ãŒé¸ã¹ã‚‹ã®ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_526" href="#call_footnote_Temp_526"><sup><small>9</small></sup></a> As mentioned in
section <a href="16_sec2_3.html#%_sec_2.3.1">2.3.1</a>, the evaluator sees a quoted expression as
a list beginning with <tt>quote</tt>, even if the
expression is typed with the quotation mark.  For example, the
expression <tt>'a</tt> would be seen by the evaluator as <tt>(quote a)</tt>.
See exercise <a href="16_sec2_3.html#%_thm_2.55">2.55</a>.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_526"><sup><small>9</small></sup></a>
<a href="16_sec2_3.html#%_sec_2.3.1">2.3.1</a>ç¯€ã§è¿°ã¹ãŸã‚ˆã†ã«ã€è©•ä¾¡å™¨ã¯ã€å¼•ç”¨ã•ã‚ŒãŸå¼ã‚’ã€ãŸã¨ãˆãã®å¼ãŒå¼•ç”¨ç¬¦ã¨ã¨ã‚‚ã«æ‰“ã¡è¾¼ã¾ã‚ŒãŸã‚‚ã®ã§ã‚ã£ã¦ã‚‚ã€<tt>quote</tt> ã§å§‹ã¾ã‚‹ãƒªã‚¹ãƒˆã¨ã—ã¦è¦‹ã‚‹ã€‚
ãŸã¨ãˆã°ã€<tt>'a</tt> ã¨ã„ã†å¼ã¯ã€è©•ä¾¡å™¨ã«ã‚ˆã‚Šã€<tt>(quote a)</tt> ã ã¨è¦‹ã‚‰ã‚Œã‚‹ã ã‚ã†ã€‚
ç·´ç¿’å•é¡Œ<a href="16_sec2_3.html#%_thm_2.55">2.55</a>ã‚’å‚ç…§ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_527" href="#call_footnote_Temp_527"><sup><small>10</small></sup></a> The value of an <tt>if</tt> expression when the predicate
is false and there is no alternative
is unspecified in Scheme; we have chosen here to make it false.
We will support the use of the variables <tt>true</tt> and <tt>false</tt>
in expressions to be evaluated by binding them in the global
environment.  See section <a href="#%_sec_4.1.4">4.1.4</a>.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_527"><sup><small>10</small></sup></a>
è¿°èªãŒå½ã§ã‚ã‚Šã€ã‹ã¤ã€ä»£æ›¿å¼ãŒãªã„å ´åˆã® <tt>if</tt> ã®å€¤ã¯ã€Schemeã§ã¯æŒ‡å®šã•ã‚Œã¦ã„ãªã„ã€‚
ç§ãŸã¡ã¯ã€ã“ã“ã§ã¯ã€ãã®å€¤ã‚’å½ã¨ã™ã‚‹ã“ã¨ã‚’é¸ã‚“ã ã€‚
ç§ãŸã¡ã¯ã€è©•ä¾¡ã™ã¹ãå¼ã®ä¸­ã§ã® <tt>true</tt> ã¨ <tt>false</tt> ã¨ã„ã†å¤‰æ•°ã®ä½¿ç”¨ã‚’ã€ã“ã‚Œã‚‰ã®å¤‰æ•°ã‚’å¤§åŸŸç’°å¢ƒã«ãŠã„ã¦æŸç¸›ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€ã‚µãƒãƒ¼ãƒˆã—ã‚ˆã†ã€‚
<a href="#%_sec_4.1.4">4.1.4</a>ç¯€ã‚’å‚ç…§ã®ã“ã¨ã€‚
</p>


<p class="orig" lang="en"><a name="footnote_Temp_528" href="#call_footnote_Temp_528"><sup><small>11</small></sup></a> These selectors for a list of expressions -- and the
corresponding ones for a list of operands -- are not intended as a data
abstraction.  They are introduced as mnemonic names for the basic list
operations in order to make it easier to understand the explicit-control
evaluator in section <a href="34_sec5_4.html#%_sec_5.4">5.4</a>.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_528"><sup><small>11</small></sup></a>
å¼ã®ãƒªã‚¹ãƒˆã«å¯¾ã™ã‚‹ã“ã‚Œã‚‰ã®ã‚»ãƒ¬ã‚¯ã‚¿â€”â€”ãŠã‚ˆã³ã€ãã‚Œã«å¯¾å¿œã™ã‚‹ã€ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã®ãƒªã‚¹ãƒˆã«å¯¾ã™ã‚‹ã‚»ãƒ¬ã‚¯ã‚¿â€”â€”ã¯ã€ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ã¨ã—ã¦æ„å›³ã•ã‚Œã¦ã„ã‚‹ã‚ã‘ã§ã¯ãªã„ã€‚
ãã‚Œã‚‰ã¯ã€<a href="34_sec5_4.html#%_sec_5.4">5.4</a>ç¯€ã§ã®æ˜ç¤ºçš„åˆ¶å¾¡ã®<span class="note"> (?) </span>è©•ä¾¡å™¨ã‚’ç†è§£ã™ã‚‹ã“ã¨ã‚’ã‚ˆã‚Šæ˜“ã—ãã™ã‚‹ãŸã‚ã«ã€åŸºæœ¬çš„ãƒªã‚¹ãƒˆæ¼”ç®—ã«å¯¾ã™ã‚‹è¨˜æ†¶ã—ã‚„ã™ã„åå‰ã¨ã—ã¦ã€å°å…¥ã•ã‚Œã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_530" href="#call_footnote_Temp_530"><sup><small>12</small></sup></a> The value of a <tt>cond</tt> expression when all the predicates
are false and there is no <tt>else</tt> clause
is unspecified in Scheme; we have chosen here to make it false.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_530"><sup><small>12</small></sup></a>
ã™ã¹ã¦ã®è¿°èªãŒå½ã§ã‚ã‚Šã€ã‹ã¤ã€<tt>else</tt> ç¯€ãŒãªã„å ´åˆã®ã€<tt>cond</tt> å¼ã®å€¤ã¯ã€Schemeã§ã¯æŒ‡å®šã•ã‚Œã¦ã„ãªã„ã€‚
ç§ãŸã¡ã¯ã€ã“ã“ã§ã¯ã€ãã®å€¤ã‚’å½ã¨ã™ã‚‹ã“ã¨ã‚’é¸ã‚“ã ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_531" href="#call_footnote_Temp_531"><sup><small>13</small></sup></a> Practical Lisp systems provide a
mechanism that allows a user to add new derived expressions and
specify their implementation as syntactic transformations without
modifying the evaluator.  Such a user-defined transformation is called a
<a name="%_idx_4374"></a><em>macro</em>.
Although it is easy to add an elementary mechanism for defining macros,
the resulting language has subtle name-conflict problems.
There has been much research on mechanisms for macro definition
that do not cause these difficulties.  See,
<a name="%_idx_4376"></a><a name="%_idx_4378"></a><a name="%_idx_4380"></a><a name="%_idx_4382"></a>for example, Kohlbecker 1986, Clinger and Rees 1991, and Hanson 1991.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_531"><sup><small>13</small></sup></a>
ãƒ¦ãƒ¼ã‚¶ãŒæ–°ãŸãªæ´¾ç”Ÿå¼ã‚’åŠ ãˆã€è©•ä¾¡å™¨ã‚’ä¿®æ­£ã›ãšã«ãã®æ´¾ç”Ÿå¼ã®å®Ÿè£…ã‚’æ–‡æ³•ä¸Šã®å¤‰å½¢ã¨ã—ã¦æŒ‡å®šã™ã‚‹ã“ã¨ã‚’å¯èƒ½ã¨ã™ã‚‹ã‚ˆã†ãªä»•çµ„ã¿ã‚’ã€å®Ÿç”¨çš„ãªLispã‚·ã‚¹ãƒ†ãƒ ã¯æä¾›ã—ã¦ã„ã‚‹ã€‚
ãƒ¦ãƒ¼ã‚¶ãŒå®šç¾©ã—ãŸãã†ã—ãŸå¤‰å½¢ã¯ã€<em>ãƒã‚¯ãƒ­</em>ã¨å‘¼ã°ã‚Œã‚‹ã€‚
ãƒã‚¯ãƒ­ã‚’å®šç¾©ã™ã‚‹ãŸã‚ã®åŸºæœ¬çš„ãªä»•çµ„ã¿ã‚’è¿½åŠ ã™ã‚‹ã“ã¨ã¯ç°¡å˜ã ãŒã€çµæœã¨ã—ã¦ç”Ÿã˜ã‚‹è¨€èªã«ã¯ã€åå‰è¡çªã®å¾®å¦™ãªå•é¡ŒãŒã‚ã‚‹ã€‚
ã“ã®ã‚ˆã†ãªå„ä»‹äº‹ã‚’å¼•ãèµ·ã“ã•ãªã„ã‚ˆã†ãªãƒã‚¯ãƒ­å®šç¾©ç”¨ã®ä»•çµ„ã¿ã«ã¤ã„ã¦ã¯ã€ãŸãã•ã‚“ã®ç ”ç©¶ãŒãªã•ã‚Œã¦ããŸã€‚
ãŸã¨ãˆã°ã€Kohlbecker 1986 ã‚„ã€Clinger and Rees 1991 ã‚„ã€Hanson 1991 ã‚’å‚ç…§ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_544" href="#call_footnote_Temp_544"><sup><small>14</small></sup></a> Frames are not really a data abstraction in the following code:
<tt>Set-variable-value!</tt> and <tt>define-variable!</tt> use <tt>set-car!</tt>
to directly modify the values in a frame.  The purpose of the frame
procedures is to make the environment-manipulation procedures easy to read.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_544"><sup><small>14</small></sup></a>
ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã«ãŠã„ã¦ã€ãƒ•ãƒ¬ãƒ¼ãƒ ã¯ã€æœ¬å½“ã¯ãƒ‡ãƒ¼ã‚¿æŠ½è±¡åŒ–ã§ã¯ãªã„ã€‚
ã™ãªã‚ã¡ã€<tt>set-variable-value!</tt> ã¨ <tt>define-variable!</tt> ã¯ã€<tt>set-car!</tt> ã‚’ä½¿ã£ã¦ç›´æ¥çš„ã«ãƒ•ãƒ¬ãƒ¼ãƒ å†…ã®å€¤ã‚’å¤‰ãˆã‚‹ã€‚
ãƒ•ãƒ¬ãƒ¼ãƒ æ‰‹ç¶šãã®ç›®çš„ã¯ã€ç’°å¢ƒæ“ä½œæ‰‹ç¶šãã‚’èª­ã¿ã‚„ã™ãã™ã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_545" href="#call_footnote_Temp_545"><sup><small>15</small></sup></a> The drawback of this representation (as well as the variant in
exercise <a href="#%_thm_4.11">4.11</a>) is that the evaluator
may have to search through many frames in order to find the binding
for a given variable.
<a name="%_idx_4488"></a><a name="%_idx_4490"></a>(Such an approach is referred to as <em>deep binding</em>.) 
One way to avoid
this inefficiency is to make use of a strategy called <em>lexical
addressing</em>, which will be discussed in
section <a href="35_sec5_5.html#%_sec_5.5.6">5.5.6</a>.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_545"><sup><small>15</small></sup></a>
ã“ã®è¡¨ç¾ (ç·´ç¿’å•é¡Œ<a href="#%_thm_4.11">4.11</a>ã§ã®å¤‰ç¨®ã‚‚åŒæ§˜) ã®ä¸åˆ©ãªç‚¹ã¯ã€ä¸ãˆã‚‰ã‚ŒãŸå¤‰æ•°ã«å¯¾ã™ã‚‹æŸç¸›ã‚’è¦‹ã¤ã‘ã‚‹ãŸã‚ã«ã€è©•ä¾¡å™¨ãŒå¤šãã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’æ¢ã—å›ã‚‰ã­ã°ãªã‚‰ãªã„å ´åˆãŒã‚ã‚‹ã€ã¨ã„ã†ç‚¹ã§ã‚ã‚‹
(ãã†ã—ãŸæ‰‹æ³•ã¯<em>æ·±ã„æŸç¸›</em>ã¨å‘¼ã°ã‚Œã‚‹)ã€‚
ã“ã®éåŠ¹ç‡ã•ã‚’é¿ã‘ã‚‹ãŸã‚ã®ä¸€æ³•ã¯ã€<em>ãƒ¬ã‚­ã‚·ã‚«ãƒ«ãƒ»ã‚¢ãƒ‰ãƒ¬ã‚·ãƒ³ã‚°</em>ã¨å‘¼ã°ã‚Œã‚‹æˆ¦ç•¥ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ã ãŒã€ã“ã‚Œã«ã¤ã„ã¦ã¯ã€<a href="35_sec5_5.html#%_sec_5.5.6">5.5.6</a>ç¯€ã§è­°è«–ã—ã‚ˆã†ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_549" href="#call_footnote_Temp_549"><sup><small>16</small></sup></a> Any procedure defined in the underlying Lisp can be used as
a primitive for the metacircular evaluator.  The name of a
primitive installed in the evaluator need not be the same as the name
of its implementation in the underlying Lisp; the names are the same
here because the metacircular evaluator implements Scheme itself.
Thus, for example, we could put <tt>(list 'first car)</tt> or <tt>(list
'square (lambda (x) (* x x)))</tt> in the list of <tt>primitive-procedures</tt>.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_549"><sup><small>16</small></sup></a>
æ ¹åº•ã«ã‚ã‚‹Lispã«ãŠã„ã¦å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã©ã®æ‰‹ç¶šãã‚‚ã€ãƒ¡ã‚¿å¾ªç’°çš„ãªè©•ä¾¡å™¨ç”¨ã®ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã¨ã—ã¦ä½¿ãˆã‚‹ã€‚
è©•ä¾¡å™¨ã«çµ„ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã®åå‰ã¯ã€æ ¹åº•ã«ã‚ã‚‹Lispã«ãŠã‘ã‚‹ãã®ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã®å®Ÿè£…ã®åå‰ã¨åŒã˜ã§ã‚ã‚‹å¿…è¦ã¯ãªã„ã€‚
ãŸã ã€ã“ã“ã§ã¯ã€ãƒ¡ã‚¿å¾ªç’°çš„ãªè©•ä¾¡å™¨ãŒSchemeè‡ªä½“ã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ã®ã§ã€åå‰ã¯åŒã˜ã§ã‚ã‚‹ã€‚
ã‚ˆã£ã¦ã€ãŸã¨ãˆã°ã€<tt>primitive-procedures</tt> ã®ãƒªã‚¹ãƒˆã®ä¸­ã«ã€<tt>(list 'first car)</tt> ã¾ãŸã¯ <tt>(list 'square (lambda (x) (* x x)))</tt> ã‚’å…¥ã‚Œã¦ãŠãã“ã¨ã‚‚ã§ãã‚‹ã ã‚ã†ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_550" href="#call_footnote_Temp_550"><sup><small>17</small></sup></a> <tt>Apply-in-underlying-scheme</tt> is the <tt>apply</tt> procedure
we have used in earlier chapters.  The metacircular evaluator's <tt>apply</tt> procedure (section <a href="#%_sec_4.1.1">4.1.1</a>) models the
working of this primitive.  Having two different things called <tt>apply</tt> leads to a technical problem in running the metacircular
evaluator, because defining the metacircular evaluator's <tt>apply</tt>
will mask the definition of the primitive.  One way around this is to
rename the metacircular <tt>apply</tt> to avoid conflict with the name of
the primitive procedure.  We have assumed instead that we have saved a
reference to the underlying <tt>apply</tt> by doing
</p>


<p class="trans" lang="ja">
<a href="#call_footnote_Temp_550"><sup><small>17</small></sup></a>
<tt>apply-in-underlying-scheme</tt> ã¯ã€ä»¥å‰ã®ç« ã§ä½¿ã£ãŸ <tt>apply</tt> ã¨ã„ã†æ‰‹ç¶šãã§ã‚ã‚‹ã€‚
ãƒ¡ã‚¿å¾ªç’°çš„ãªè©•ä¾¡å™¨ã® <tt>apply</tt> ã¨ã„ã†æ‰‹ç¶šã (<a href="#%_sec_4.1.1">4.1.1</a>ç¯€) ã¯ã€ã“ã®ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã®åƒãã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã—ã¦ã„ã‚‹ã€‚
<tt>apply</tt> ã¨å‘¼ã°ã‚Œã‚‹äºŒã¤ã®ç•°ãªã‚‹ã‚‚ã®ãŒã‚ã‚‹ã¨ã€ãƒ¡ã‚¿å¾ªç’°çš„ãªè©•ä¾¡å™¨ã‚’å®Ÿè¡Œã™ã‚‹ä¸Šã§ã®æŠ€è¡“ä¸Šã®å•é¡Œã‚’æ‹›ã„ã¦ã—ã¾ã†ã€‚ãªãœãªã‚‰ã€ãƒ¡ã‚¿å¾ªç’°çš„ãªè©•ä¾¡å™¨ ã®<tt>apply</tt> ã‚’å®šç¾©ã™ã‚‹ã“ã¨ã¯ã€ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã®å®šç¾©ã‚’è¦†ã„éš ã—ã¦ã—ã¾ã†ã ã‚ã†ã‹ã‚‰ã§ã‚ã‚‹ã€‚
ã“ã‚Œã«ã¾ã¤ã‚ã‚‹ä¸€ã¤ã®æ–¹æ³•ã¯ã€ãƒ¡ã‚¿å¾ªç’°çš„ãª <tt>apply</tt> ã‚’æ”¹åã—ã¦ã€åŸå§‹çš„æ‰‹ç¶šãã®åå‰ã¨ã®è¡çªã‚’é¿ã‘ã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚
ç§ãŸã¡ã¯ãã®ä»£ã‚ã‚Šã«ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ã™ã‚‹ã“ã¨ã§ã€æ ¹åº•ã«ã‚ã‚‹ <tt>apply</tt> ã¸ã®å‚ç…§ã‚’é€€é¿ã—ãŸã€ã¨æƒ³å®šã—ãŸã€‚
</p>

<p class="lisp">(define apply-in-underlying-scheme apply)
</p>


<p class="orig" lang="en">before defining the metacircular <tt>apply</tt>.  This allows us to
access the original version of <tt>apply</tt> under a different name.
</p>

<p class="trans" lang="ja">
ãŸã ã—ã“ã‚Œã¯ã€ãƒ¡ã‚¿å¾ªç’°çš„ãª <tt>apply</tt> ã‚’å®šç¾©ã™ã‚‹å‰ã«è¡Œã†ã‚‚ã®ã¨ã™ã‚‹ã€‚
ã“ã‚Œã«ã‚ˆã£ã¦ç§ãŸã¡ã¯ã€é•ã†åå‰ã®ã‚‚ã¨ã§ <tt>apply</tt> ã®å…ƒã€…ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã“ã¨ãŒå¯èƒ½ã¨ãªã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_551" href="#call_footnote_Temp_551"><sup><small>18</small></sup></a> The primitive procedure <a name="%_idx_4522"></a><a name="%_idx_4524"></a><tt>read</tt> waits for input from the user,
and returns the next complete expression that is typed.
For example, if the user types <tt>(+ 23 x)</tt>, <tt>read</tt> returns
a three-element list containing the symbol <tt>+</tt>, the number 23,
and the symbol <tt>x</tt>.
<a name="%_idx_4526"></a><a name="%_idx_4528"></a>If the user types <tt>'x</tt>, <tt>read</tt> returns a two-element list
containing the symbol <tt>quote</tt> and the symbol <tt>x</tt>.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_551"><sup><small>18</small></sup></a>
<tt>read</tt> ã¨ã„ã†åŸå§‹çš„æ‰‹ç¶šãã¯ã€ãƒ¦ãƒ¼ã‚¶ã‹ã‚‰ã®å…¥åŠ›ã‚’å¾…ã¡ã€æ‰“ã¡è¾¼ã¾ã‚Œã‚‹æ¬¡ã®å®Œå…¨ãªå¼ã‚’è¿”ã™ã€‚
ãŸã¨ãˆã°ã€ã‚‚ã—ãƒ¦ãƒ¼ã‚¶ãŒ <tt>(+ 23 x)</tt> ã¨æ‰“ã¡è¾¼ã‚“ã ã‚‰ã€<tt>read</tt> ã¯ã€<tt>+</tt> ã¨ã„ã†è¨˜å·ã¨23ã¨ã„ã†æ•°ã¨ <tt>x</tt> ã¨ã„ã†è¨˜å·ã¨ã‚’å«ã‚€ã€ä¸‰è¦ç´ ã®ãƒªã‚¹ãƒˆã‚’è¿”ã™ã€‚
ã‚‚ã—ãƒ¦ãƒ¼ã‚¶ãŒ <tt>'x</tt> ã¨æ‰“ã¡è¾¼ã‚“ã ã‚‰ã€<tt>read</tt> ã¯ã€<tt>quote</tt> ã¨ã„ã†è¨˜å·ã¨ <tt>x</tt> ã¨ã„ã†è¨˜å·ã¨ã‚’å«ã‚€ã€äºŒè¦ç´ ã®ãƒªã‚¹ãƒˆã‚’è¿”ã™ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_553" href="#call_footnote_Temp_553"><sup><small>19</small></sup></a> The fact that the machines are described in Lisp is
inessential.  If we give our evaluator a Lisp program
that behaves as an evaluator for
some other language, say C, the Lisp evaluator will emulate the C
evaluator, which in turn can emulate any machine described as a C
program.  Similarly, writing a Lisp evaluator in C produces a C
program that can execute any Lisp program.  The deep idea here is that
any evaluator can emulate any other.  Thus, the notion of ``what can
in principle be computed'' (ignoring practicalities of time and
memory required) is independent of the language or the computer, and
instead reflects an underlying notion of <a name="%_idx_4554"></a><em>computability</em>.  This
was first demonstrated in a clear way by <a name="%_idx_4556"></a>Alan M. Turing (1912-1954),
whose 1936 paper laid the foundations for theoretical <a name="%_idx_4558"></a>computer
science.  In the paper, Turing presented a simple computational
model -- now known as a <a name="%_idx_4560"></a><em>Turing machine</em> -- and argued that any
``effective process'' can be formulated as a program for such a
machine.  (This argument is known as the <a name="%_idx_4562"></a><em>Church-Turing thesis</em>.)
Turing then implemented a universal machine, i.e., a Turing machine
that behaves as an evaluator for Turing-machine programs.  He used
this framework to demonstrate that there are well-posed problems that
cannot be computed by Turing machines (see
exercise <a href="#%_thm_4.15">4.15</a>), and so by implication cannot be
formulated as ``effective processes.''  Turing went on to make
fundamental contributions to practical computer science as well.  For
example, he invented the idea of <a name="%_idx_4564"></a>structuring programs using
general-purpose subroutines.  See <a name="%_idx_4566"></a>Hodges 1983 for a biography of
Turing.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_553"><sup><small>19</small></sup></a>
æ©Ÿæ¢°ãŒLispã§è¨˜è¿°ã•ã‚Œã‚‹ã€ã¨ã„ã†äº‹å®Ÿã¯ã€éæœ¬è³ªçš„ã§ã‚ã‚‹ã€‚
ã‚‚ã—ã€ä½•ã‚‰ã‹ã®ä»–ã®è¨€èªâ€”â€”ãŸã¨ãˆã° C â€”â€”ã®è©•ä¾¡å™¨ã¨ã—ã¦æŒ¯ã‚‹èˆã†Lispãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ã€ç§ãŸã¡ã®è©•ä¾¡å™¨ã«ä¸ãˆã‚Œã°ã€Lispè©•ä¾¡å™¨ã¯ã€Cè©•ä¾¡å™¨ã‚’ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã™ã‚‹ã ã‚ã†ã—ã€ä»Šåº¦ã¯ãã®Cè©•ä¾¡å™¨ãŒã€Cãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¨ã—ã¦è¨˜è¿°ã•ã‚Œã‚‹ä»»æ„ã®æ©Ÿæ¢°ã‚’ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã§ãã‚‹ã ã‚ã†ã€‚
åŒæ§˜ã«ã€Cã§Lispè©•ä¾¡å™¨ã‚’æ›¸ãã“ã¨ã§ã€ä»»æ„ã®Lispãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’å®Ÿè¡Œã§ãã‚‹Cãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒä½œã‚Šå‡ºã•ã‚Œã‚‹ã€‚
ã“ã“ã§ã®æ·±é ãªè€ƒãˆã¯ã€ä»»æ„ã®è©•ä¾¡å™¨ã¯ä»»æ„ã®ä»–ã®è©•ä¾¡å™¨ã‚’ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã§ãã‚‹ã€ã¨ã„ã†ã‚‚ã®ã ã€‚
ã‚†ãˆã«ã€ã€ŒåŸç†çš„ã«ä½•ãŒè¨ˆç®—ã§ãã‚‹ã®ã‹ã€ã¨ã„ã†æ¦‚å¿µ (å¿…è¦ã¨ã•ã‚Œã‚‹æ™‚é–“ã¨ãƒ¡ãƒ¢ãƒªã«ã¤ã„ã¦ã®ç¾å®Ÿçš„å´é¢ã¯ç„¡è¦–ã™ã‚‹) ã¯ã€è¨€èªãªã„ã—ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã‹ã‚‰ç‹¬ç«‹ãªã®ã§ã‚ã‚Šã€ãã®ä»£ã‚ã‚Šã€<em>è¨ˆç®—å¯èƒ½æ€§</em>ã¨ã„ã†ã€æ ¹åº•ã«ã‚ã‚‹æ¦‚å¿µã‚’åæ˜ ã—ã¦ã„ã‚‹ã®ã§ã‚ã‚‹ã€‚
ã“ã®ã“ã¨ã¯ã€ã‚¢ãƒ©ãƒ³ãƒ»Mãƒ»ãƒãƒ¥ãƒ¼ãƒªãƒ³ã‚° (1912ã€œ1954å¹´) ã«ã‚ˆã£ã¦åˆã‚ã¦æ˜å¿«ãªæ–¹æ³•ã§ç«‹è¨¼ã•ã‚Œã€å½¼ã®1936å¹´ã®è«–æ–‡ã¯ã€ç†è«–è¨ˆç®—æ©Ÿç§‘å­¦ã®åŸºç¤ã‚’ç¯‰ã„ãŸã€‚
ãã®è«–æ–‡ã§ã€ãƒãƒ¥ãƒ¼ãƒªãƒ³ã‚°ã¯ã€å˜ç´”ãªè¨ˆç®—ãƒ¢ãƒ‡ãƒ«â€”â€”ä»Šã§ã¯<em>ãƒãƒ¥ãƒ¼ãƒªãƒ³ã‚°æ©Ÿæ¢°</em>ã¨ã—ã¦çŸ¥ã‚‰ã‚Œã‚‹â€”â€”ã‚’æç¤ºã—ã€ã„ã‹ãªã‚‹ã€Œæœ‰åŠ¹ãªãƒ—ãƒ­ã‚»ã‚¹ã€ã‚‚ãã®ã‚ˆã†ãªæ©Ÿæ¢°ã®ãŸã‚ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¨ã—ã¦å®šå¼åŒ–ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã®ã ã€ã¨ä¸»å¼µã—ãŸ
(ã“ã®ä¸»å¼µã¯ã€<em>ãƒãƒ£ãƒ¼ãƒãƒ»ãƒãƒ¥ãƒ¼ãƒªãƒ³ã‚°ã®å®šç†</em>ã¨ã—ã¦çŸ¥ã‚‰ã‚Œã‚‹)ã€‚
ãƒãƒ¥ãƒ¼ãƒªãƒ³ã‚°ã¯ãã‚Œã‹ã‚‰ã€æ™®éæ©Ÿæ¢°â€”â€”ã™ãªã‚ã¡ã€ãƒãƒ¥ãƒ¼ãƒªãƒ³ã‚°æ©Ÿæ¢°ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ç”¨ã®è©•ä¾¡å™¨ã¨ã—ã¦æŒ¯ã‚‹èˆã†ãƒãƒ¥ãƒ¼ãƒªãƒ³ã‚°æ©Ÿæ¢°â€”â€”ã‚’å®Ÿè£…ã—ãŸã€‚
å½¼ã¯ã“ã®æ çµ„ã¿ã‚’ä½¿ã£ã¦ã€ãƒãƒ¥ãƒ¼ãƒªãƒ³ã‚°æ©Ÿæ¢°ã§ã¯è¨ˆç®—ã§ããªã„â€”â€”ãã®ãŸã‚è«–ç†åŒ…å«ã«ã‚ˆã£ã¦ã¯ã€Œæœ‰åŠ¹ãªãƒ—ãƒ­ã‚»ã‚¹ã€ã¨ã—ã¦å®šå¼åŒ–ã§ããªã„â€”â€”è‰¯è¨­å®šå•é¡ŒãŒå­˜åœ¨ã™ã‚‹ã“ã¨ã‚’ã€ç«‹è¨¼ã—ãŸ (ç·´ç¿’å•é¡Œ<a href="#%_thm_4.15">4.15</a>ã‚’å‚ç…§)ã€‚
<span class="note">(and so by ... ã®ã¨ã“ã‚ã®æ„å‘³ãŒã¡ã‚ƒã‚“ã¨å–ã‚Œã¦ã„ãªã„ã‹ã‚‚ã€‚è¦æ¤œè¨ã€‚)</span>
ãƒãƒ¥ãƒ¼ãƒªãƒ³ã‚°ã¯ã€å¼•ãç¶šãã€å®Ÿéš›çš„ãªè¨ˆç®—æ©Ÿç§‘å­¦ã«å¯¾ã—ã¦ã‚‚åŸºç¤ã‚’ãªã™é‡è¦ãªè²¢çŒ®ã‚’è¡Œã£ãŸã€‚
ãŸã¨ãˆã°ã€å½¼ã¯ã€æ±ç”¨ã‚µãƒ–ãƒ«ãƒ¼ãƒãƒ³ã‚’ä½¿ã£ã¦ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ§‹é€ åŒ–ã™ã‚‹ã€ã¨ã„ã†æ¦‚å¿µã‚’è€ƒæ¡ˆã—ãŸã€‚
ãƒãƒ¥ãƒ¼ãƒªãƒ³ã‚°ã®ä¼è¨˜ã«ã¤ã„ã¦ã¯ã€Hodges 1983ã‚’å‚ç…§ã®ã“ã¨ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_554" href="#call_footnote_Temp_554"><sup><small>20</small></sup></a> Some people find it
counterintuitive that an evaluator, which is implemented by a
relatively simple procedure, can emulate programs that are more
complex than the evaluator itself.  The existence of a universal
evaluator machine is a deep and wonderful property of computation.
<a name="%_idx_4568"></a><em>Recursion theory</em>, a branch of mathematical logic, is concerned
with logical limits of computation.  <a name="%_idx_4570"></a>Douglas Hofstadter's beautiful
book <em>G&ouml;del, Escher, Bach</em> (1979) explores some of these ideas.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_554"><sup><small>20</small></sup></a>
è©•ä¾¡å™¨â€”â€”æ¯”è¼ƒçš„å˜ç´”ãªæ‰‹ç¶šãã«ã‚ˆã£ã¦å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹â€”â€”ãŒã€è©•ä¾¡å™¨è‡ªä½“ã‚ˆã‚Šã‚‚è¤‡é›‘ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã§ãã‚‹ã“ã¨ã‚’ã€ç›´æ„Ÿã«åã—ã¦ã„ã‚‹ã€ã¨æ„Ÿã˜ã‚‹äººã‚‚ã„ã‚‹ã€‚
æ™®éçš„ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿æ©Ÿæ¢°ã®å­˜åœ¨ã¯ã€è¨ˆç®—ã®æ·±é ã‹ã¤é©šç•°çš„ãªæ€§è³ªãªã®ã ã€‚
<em>å†å¸°ç†è«–</em>â€”â€”æ•°å­¦çš„è«–ç†å­¦ã®ä¸€åˆ†é‡â€”â€”ã¯ã€è¨ˆç®—ã®è«–ç†çš„é™ç•Œã«é–¢ä¿‚ã™ã‚‹ã€‚
ãƒ€ã‚°ãƒ©ã‚¹ãƒ»ãƒ›ãƒ•ã‚¹ã‚¿ãƒƒã‚¿ãƒ¼ã®ã€<a href="https://www.amazon.co.jp/ã‚²ãƒ¼ãƒ‡ãƒ«ã€ã‚¨ãƒƒã‚·ãƒ£ãƒ¼ã€ãƒãƒƒãƒâ€•ã‚ã‚‹ã„ã¯ä¸æ€è­°ã®ç’°-20å‘¨å¹´è¨˜å¿µç‰ˆ-ãƒ€ã‚°ãƒ©ã‚¹ãƒ»R-ãƒ›ãƒ•ã‚¹ã‚¿ãƒƒã‚¿ãƒ¼/dp/4826901259" target="_blank">ã‚²ãƒ¼ãƒ‡ãƒ«ã€ã‚¨ãƒƒã‚·ãƒ£ãƒ¼ã€ãƒãƒƒãƒ</a>ã€ã¨ã„ã†ç´ æ™´ã‚‰ã—ã„æœ¬ (1979å¹´) ã¯ã€ã“ã‚Œã‚‰ã®æ¦‚å¿µã®ã†ã¡ã®ã„ãã¤ã‹ã‚’æ¢æ±‚ã—ã¦ã„ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_555" href="#call_footnote_Temp_555"><sup><small>21</small></sup></a> Warning:
<a name="%_idx_4576"></a>This <tt>eval</tt> primitive is not
identical to the <tt>eval</tt> procedure we implemented in
section <a href="#%_sec_4.1.1">4.1.1</a>, because it uses <em>actual</em>
Scheme environments rather than the sample environment structures we
built in section <a href="#%_sec_4.1.3">4.1.3</a>.  These actual
environments cannot be manipulated by the user as ordinary lists; they
must be accessed via <tt>eval</tt> or other special operations.
<a name="%_idx_4578"></a>Similarly, the <tt>apply</tt> primitive we saw earlier is not identical
to the metacircular <tt>apply</tt>, because it uses actual Scheme procedures
rather than the procedure objects we constructed in
sections <a href="#%_sec_4.1.3">4.1.3</a> and <a href="#%_sec_4.1.4">4.1.4</a>.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_555"><sup><small>21</small></sup></a>
è­¦å‘Š: ã“ã® <tt>eval</tt> ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã¯ã€<a href="#%_sec_4.1.1">4.1.1</a>ç¯€ã§å®Ÿè£…ã—ãŸ  <tt>eval</tt> æ‰‹ç¶šãã¨åŒä¸€ã§ã¯ãªã„ã€‚ãªãœãªã‚‰ã€ã“ã® <tt>eval</tt> ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã¯ã€<a href="#%_sec_4.1.3">4.1.3</a>ç¯€ã§çµ„ã¿è¾¼ã‚“ã ã‚µãƒ³ãƒ—ãƒ«ç’°å¢ƒæ§‹é€ ã§ã¯ãªãã€ã‚€ã—ã‚ã€<em>å®Ÿéš›ã®</em>Schemeç’°å¢ƒã‚’ä½¿ã†ã‹ã‚‰ã§ã‚ã‚‹ã€‚
ã“ã†ã—ãŸå®Ÿéš›ã®ç’°å¢ƒãŒã€ãƒ¦ãƒ¼ã‚¶ã«ã‚ˆã£ã¦é€šå¸¸ã®ãƒªã‚¹ãƒˆã¨ã—ã¦æ‰±ã‚ã‚Œã‚‹ã“ã¨ã¯ã‚ã‚Šãˆãªã„ã€‚
ã“ã†ã—ãŸå®Ÿéš›ã®ç’°å¢ƒã¯ã€<tt>eval</tt> ã¾ãŸã¯ä»–ã®ç‰¹æ®Šãªæ¼”ç®—ã‚’ä»‹ã—ã¦ã‚¢ã‚¯ã‚»ã‚¹ã•ã‚Œã­ã°ãªã‚‰ãªã„ã€‚
åŒæ§˜ã«ã€ä»¥å‰ã«è¦‹ãŸ <tt>apply</tt> ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã¯ã€ãƒ¡ã‚¿å¾ªç’°çš„ãª <tt>apply</tt> ã¨åŒä¸€ã§ã¯ãªã„ã€‚ãªãœãªã‚‰ã€ä»¥å‰ã«è¦‹ãŸ <tt>apply</tt> ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã¯ã€<a href="#%_sec_4.1.3">4.1.3</a>ç¯€ã¨<a href="#%_sec_4.1.4">4.1.4</a>ç¯€ã§æ§‹ç¯‰ã—ãŸæ‰‹ç¶šãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ãªãã€ã‚€ã—ã‚ã€å®Ÿéš›ã®Schemeæ‰‹ç¶šãã‚’ä½¿ã†ã‹ã‚‰ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_556" href="#call_footnote_Temp_556"><sup><small>22</small></sup></a> The MIT
<a name="%_idx_4580"></a><a name="%_idx_4582"></a><a name="%_idx_4584"></a><a name="%_idx_4586"></a>implementation of Scheme includes <tt>eval</tt>, as well as a symbol <tt>user-initial-environment</tt> that is bound to the initial environment in
which the user's input expressions are evaluated.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_556"><sup><small>22</small></sup></a>
Schemeã®MITã§ã®å®Ÿè£…ã¯ã€ãƒ¦ãƒ¼ã‚¶ã®å…¥åŠ›å¼ãŒè©•ä¾¡ã•ã‚Œã‚‹åˆæœŸç’°å¢ƒã«æŸç¸›ã•ã‚Œã¦ã„ã‚‹ <tt>user-initial-environment</tt> ã¨ã„ã†è¨˜å·ã¨ã¨ã‚‚ã«ã€<tt>eval</tt> ã‚’å«ã‚“ã§ã„ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_558" href="#call_footnote_Temp_558"><sup><small>23</small></sup></a> Although we stipulated that <tt>halts?</tt> is given a procedure object,
notice that this reasoning still applies even if <tt>halts?</tt> can gain
access to the procedure's text and its environment.
<a name="%_idx_4590"></a><a name="%_idx_4592"></a><a name="%_idx_4594"></a><a name="%_idx_4596"></a>This is Turing's celebrated <em>Halting Theorem</em>, which gave
the first clear example of a <em>non-computable</em> problem, i.e., a
well-posed task that cannot be carried out as a computational
procedure.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_558"><sup><small>23</small></sup></a>
<tt>halts?</tt> ã«ã¯æ‰‹ç¶šãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒä¸ãˆã‚‰ã‚Œã‚‹ã®ã ã€ã¨è¦å®šã—ãŸã‚ã‘ã ãŒã€ã“ã“ã§ã®æ¨è«–ã¯ã€ãŸã¨ãˆ <tt>halts?</tt> ãŒãã®æ‰‹ç¶šãã®æ–‡é¢ãŠã‚ˆã³ãã®æ‰‹ç¶šãã®ç’°å¢ƒã¸ã®ã‚¢ã‚¯ã‚»ã‚¹æ¨©ã‚’å¾—ã‚‹ã“ã¨ãŒã§ãã‚‹ã®ã ã¨ã—ã¦ã‚‚ã€ä¾ç„¶ã¨ã—ã¦æˆã‚Šç«‹ã¤ã€‚
ã“ã‚ŒãŒãƒãƒ¥ãƒ¼ãƒªãƒ³ã‚°ã®è‘—åãª<em>åœæ­¢å®šç†</em>ã§ã‚ã‚Šã€åœæ­¢å®šç†ã¯ã€<em>è¨ˆç®—ä¸èƒ½ãª</em>å•é¡Œâ€”â€”ã™ãªã‚ã¡ã€è¨ˆç®—æ‰‹ç¶šãã¨ã—ã¦å®Ÿè¡Œã§ããªã„è‰¯è¨­å®šã‚¿ã‚¹ã‚¯â€”â€”ã®æœ€åˆã®æ˜å¿«ãªä¾‹ã‚’ç¤ºã—ãŸã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_559" href="#call_footnote_Temp_559"><sup><small>24</small></sup></a> Wanting programs to not depend on this evaluation
mechanism is the reason for the ``management is not
responsible'' remark in footnote <a href="10_sec1_1.html#footnote_Temp_45">28</a> of chapter 1.
By insisting that internal definitions come first and do not use each
other while the definitions are being evaluated, the IEEE standard
for Scheme leaves implementors some choice in the mechanism used to
evaluate these definitions.  The choice of one evaluation rule rather
than another here may seem like a small issue, affecting only the
interpretation of ``badly formed'' programs.  However, we will see in
section <a href="35_sec5_5.html#%_sec_5.5.6">5.5.6</a> that moving to a model of
simultaneous scoping for internal definitions avoids some nasty
difficulties that would otherwise arise in implementing a compiler.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_559"><sup><small>24</small></sup></a>
ã“ã®è©•ä¾¡ã®ä»•çµ„ã¿ã«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒä¾å­˜ã—ã¦ã»ã—ããªã„ã€ã¨æœ›ã‚“ã§ã„ã‚‹ã“ã¨ãŒã€1ç« ã®è„šæ³¨<a href="10_sec1_1.html#footnote_Temp_45">28</a>ã«ã‚ã‚‹ã€Œé‹å–¶å´ã¯ã€è²¬ä»»ã‚’æŒãŸãªã„ã€ã¨ã„ã†ç™ºè¨€ã®ç†ç”±ã§ã‚ã‚‹ã€‚
å†…éƒ¨å®šç¾©ã¯æœ€åˆã«æ¥ã¦ã€ã‹ã¤ã€ãã‚Œã‚‰ã®å®šç¾©ãŒè©•ä¾¡ã•ã‚Œã¦ã„ã‚‹æœ€ä¸­ã«ã¯äº’ã„ã‚’ä½¿ã‚ãªã„ã®ã ã€ã¨å¼·ãä¸»å¼µã™ã‚‹ã“ã¨ã§ã€Schemeã«ã¤ã„ã¦ã®IEEEæ¨™æº–ã¯ã€ã“ã‚Œã‚‰ã®å®šç¾©ã‚’è©•ä¾¡ã™ã‚‹ã®ã«ä½¿ã‚ã‚Œã‚‹ä»•çµ„ã¿ã«ã¤ã„ã¦ã€ã‚ã‚‹ç¨‹åº¦ã®é¸æŠã®è‡ªç”±ã‚’å®Ÿè£…è€…ã«æ®‹ã—ã¦ã„ã‚‹ã€‚
ä»–ã§ã‚‚ãªã„ä¸€ã¤ã®è©•ä¾¡è¦å‰‡ã‚’ã“ã“ã§é¸ã‚“ã ã“ã¨ã¯ã€å°ã•ãªå•é¡Œã®ã‚ˆã†ã«â€”â€”ã€Œã¾ãšãå½¢æˆã•ã‚ŒãŸã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®è§£é‡ˆã«ã—ã‹å½±éŸ¿ã—ãªã„ã€ã¨â€”â€”è¦‹ãˆã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚
ã—ã‹ã—ã€å†…éƒ¨å®šç¾©ã«ã¤ã„ã¦åŒæ™‚ã«ç¯„å›²ã‚’æ±ºã‚ã‚‹ã€ã¨ã„ã†ãƒ¢ãƒ‡ãƒ«ã¸ã¨ç§»ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€ä»–ã®æ–¹æ³•ã ã¨ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã‚’å®Ÿè£…ã™ã‚‹éš›ã«èµ·ã“ã‚‹ã§ã‚ã‚ã†å¹¾ã¤ã‹ã®å­ãªå„ä»‹äº‹ã‚’é¿ã‘ã‚‰ã‚Œã‚‹ã®ã ã€ã¨ã„ã†ã“ã¨ã‚’<a href="35_sec5_5.html#%_sec_5.5.6">5.5.6</a>ç¯€ã«ãŠã„ã¦è¦‹ã‚‹ã“ã¨ã«ãªã‚‹ã ã‚ã†ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_560" href="#call_footnote_Temp_560"><sup><small>25</small></sup></a> The IEEE standard for Scheme
allows for different implementation strategies by specifying that it
is up to the programmer to obey this restriction, not up to the
implementation to enforce it.  Some Scheme implementations, including
<a name="%_idx_4610"></a>MIT Scheme, use the transformation shown above.  Thus, some programs
that don't obey this restriction will in fact run in such implementations.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_560"><sup><small>25</small></sup></a>
Schemeã«ã¤ã„ã¦ã®IEEEæ¨™æº–ã¯ã€ã“ã®åˆ¶ç´„ã«å¾“ã†ã“ã¨ã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒã®è²¬ä»»ã§ã‚ã£ã¦ã€ã“ã®åˆ¶ç´„ã‚’å¼·åˆ¶ã™ã‚‹ã“ã¨ã¯å‡¦ç†ç³»ã®è²¬ä»»ã§ã¯ãªã„ã€ã¨æ˜ç¢ºã«è¦å®šã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€ç•°ãªã‚‹å®Ÿè£…æˆ¦ç•¥ã‚’æƒ³å®šã—ã¦ã„ã‚‹ã€‚
MIT Schemeã‚’å«ã‚€ã„ãã¤ã‹ã®Schemeå‡¦ç†ç³»ã¯ã€ä¸Šã«ç¤ºã—ãŸå¤‰å½¢ã‚’ä½¿ã†ã€‚
ã‚ˆã£ã¦ã€ãã†ã—ãŸå‡¦ç†ç³»ã§ã¯ã€ã“ã®åˆ¶ç´„ã«å¾“ã‚ãªã„ã‚ã‚‹ç¨®ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒã€å®Ÿéš›ã«å‹•ä½œã™ã‚‹ã“ã¨ã ã‚ã†ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_565" href="#call_footnote_Temp_565"><sup><small>26</small></sup></a> The MIT implementors of Scheme support Alyssa on
the following grounds: Eva is in principle correct -- the definitions
should be regarded as simultaneous.  But it seems difficult to
implement a general, efficient mechanism that does what Eva requires.
In the absence of such a mechanism, it is better to generate an error
in the difficult cases of simultaneous definitions (Alyssa's notion)
than to produce an incorrect answer (as Ben would have it).
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_565"><sup><small>26</small></sup></a>
Schemeã®MITã§ã®å‡¦ç†ç³»ã¯ã€ä»¥ä¸‹ã®ç†ç”±ã«ã‚ˆã‚Šã‚¢ãƒªãƒƒã‚µã‚’æ”¯æŒã—ã¦ã„ã‚‹ã€‚
ã‚¨ãƒ´ã‚¡ã¯åŸå‰‡ã¨ã—ã¦æ­£ã—ã„â€”â€”å®šç¾©ã¯ã€åŒæ™‚çš„ã ã¨è¦‹ãªã•ã‚Œã‚‹ã¹ãã§ã‚ã‚‹ã€‚
ã—ã‹ã—ã€ã‚¨ãƒ´ã‚¡ãŒè¦æ±‚ã™ã‚‹ã“ã¨ã‚’è¡Œã†ã‚ˆã†ãªã€ä¸€èˆ¬çš„ã§åŠ¹ç‡çš„ãªä»•çµ„ã¿ã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ã¯ã€é›£ã—ã„ã‚ˆã†ã ã€‚
ãã†ã—ãŸä»•çµ„ã¿ãŒãªã„å ´åˆã€åŒæ™‚çš„ãªå®šç¾©ã®é›£ã—ã„äº‹ä¾‹ã«ãŠã„ã¦ã¯ã€ã‚¨ãƒ©ãƒ¼ã‚’ç”Ÿæˆã™ã‚‹ã“ã¨ (ã‚¢ãƒªãƒƒã‚µã®è¦‹è§£) ã®æ–¹ãŒã€(ãƒ™ãƒ³ãŒä¸»å¼µã—ãŸã‚ˆã†ãª) æ­£ã—ããªã„ç­”ãˆã‚’ä½œã‚Šå‡ºã™ã“ã¨ã‚ˆã‚Šã‚‚ã€ã¾ã—ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_568" href="#call_footnote_Temp_568"><sup><small>27</small></sup></a> This example illustrates a programming trick for
formulating recursive procedures without using <tt>define</tt>.  The
<a name="%_idx_4628"></a>most general trick of this sort is the <em>Y</em> <em>operator</em>, which can
be used to give a ``pure <img src="book-Z-G-D-6.gif" border="0">-calculus'' implementation of
<a name="%_idx_4630"></a><a name="%_idx_4632"></a>recursion.  (See Stoy 1977 for details on the lambda calculus, and
Gabriel 1988 for an exposition of the <em>Y</em> operator in Scheme.)
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_568"><sup><small>27</small></sup></a>
ã“ã®ä¾‹ã¯ã€<tt>define</tt> ã‚’ä½¿ã‚ãªã„ã§å†å¸°çš„æ‰‹ç¶šãã‚’å®šå¼åŒ–ã™ã‚‹ãŸã‚ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®æŠ€ã‚’ä¾‹è§£ã—ã¦ã„ã‚‹ã€‚
ã“ã®ç¨®ã®ã‚‚ã®ã§ã‚‚ã£ã¨ã‚‚ä¸€èˆ¬çš„ãªæŠ€ã¯ã€<em class="en">Y</em><em>ã‚ªãƒšãƒ¬ãƒ¼ã‚¿</em>ã§ã‚ã‚‹ãŒã€ã“ã‚Œã¯ã€å†å¸°ã«ã¤ã„ã¦ã®ã€Œç´”ç²‹ãª&lambda;è¨ˆç®—ã€ã®å®Ÿè£…ã‚’ä¸ãˆã‚‹ãŸã‚ã«ä½¿ãˆã‚‹
(ãƒ©ãƒ ãƒ€è¨ˆç®—ã«ã¤ã„ã¦ã®è©³ç´°ã«ã¤ã„ã¦ã¯ Stoy 1977 ã‚’ã€Schemeã«ãŠã‘ã‚‹<em class="en">Y</em><em>ã‚ªãƒšãƒ¬ãƒ¼ã‚¿</em>ã®è§£èª¬ã«ã¤ã„ã¦ã¯ Gabriel 1988 ã‚’ã€å‚ç…§ã•ã‚ŒãŸã„)ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_569" href="#call_footnote_Temp_569"><sup><small>28</small></sup></a> This technique is an integral part of the compilation
process, which we shall discuss in chapter 5.  Jonathan Rees wrote a Scheme
<a name="%_idx_4644"></a><a name="%_idx_4646"></a><a name="%_idx_4648"></a><a name="%_idx_4650"></a>interpreter like this in about 1982 for the T project (Rees and Adams
1982).  Marc Feeley (1986) (see also Feeley and Lapalme 1987)
independently invented this technique
in his master's thesis.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_569"><sup><small>28</small></sup></a>
ã“ã®æŠ€æ³•ã¯ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ãƒ»ãƒ—ãƒ­ã‚»ã‚¹â€”â€”5ç« ã§è­°è«–ã™ã‚‹ã“ã¨ã«ã—ã‚ˆã†â€”â€”ã«ãŠã‘ã‚‹ä¸å¯æ¬ ãªéƒ¨åˆ†ã§ã‚ã‚‹ã€‚
ã‚¸ãƒ§ãƒŠã‚µãƒ³ãƒ»ãƒªãƒ¼ã‚ºã¯ã€ã“ã®ã‚ˆã†ãªSchemeã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã‚’ã€Tãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ãŸã‚ã«1982å¹´å‰å¾Œã«æ›¸ã„ãŸ (Rees and Adams 1982)ã€‚
ãã‚Œã¨ã¯ç‹¬ç«‹ã«ã€Marc Feeley (1986) (Feeley and Lapalme 1987 ã‚‚å‚ç…§) ãŒã€å½¼ã®ä¿®å£«è«–æ–‡ã®ä¸­ã§ã“ã®æŠ€æ³•ã‚’è€ƒæ¡ˆã—ãŸã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_570" href="#call_footnote_Temp_570"><sup><small>29</small></sup></a> There is,
however, an important part of the variable search that <em>can</em> be
done as part of the syntactic analysis.  As we will show in
section <a href="35_sec5_5.html#%_sec_5.5.6">5.5.6</a>, one can determine the position
in the environment structure where the value of the variable will be
found, thus obviating the need to scan the environment for the entry
that matches the variable.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_570"><sup><small>29</small></sup></a>
ã—ã‹ã—ã€æ–‡æ³•çš„è§£æã®ä¸€éƒ¨ã¨ã—ã¦ãªã—<em>å¾—ã‚‹</em>ã€å¤‰æ•°æ¢ç´¢ã®é‡è¦ãªéƒ¨åˆ†ãŒã‚ã‚‹ã€‚
<a href="35_sec5_5.html#%_sec_5.5.6">5.5.6</a>ç¯€ã§è¦‹ã‚‹ã“ã¨ã«ãªã‚‹ã¨ãŠã‚Šã€å¤‰æ•°ã®å€¤ãŒè¦‹ã¤ã‹ã‚‹ã§ã‚ã‚ã†ç’°å¢ƒæ§‹é€ å†…ã®ä½ç½®ã‚’çªãæ­¢ã‚ã‚‹ã“ã¨ãŒå¯èƒ½ã§ã‚ã‚Šã€ã‚ˆã£ã¦ã€å¤‰æ•°ã«åˆè‡´ã™ã‚‹<ruby><rb>é …ç›®</rb><rp> (</rp><rt>ã‚¨ãƒ³ãƒˆãƒª</rt><rp>) </rp></ruby>ã‚’æ±‚ã‚ã¦ç’°å¢ƒã‚’èµ°æŸ»ã™ã‚‹å¿…è¦ã‚’ãªãã›ã‚‹ã®ã ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_571" href="#call_footnote_Temp_571"><sup><small>30</small></sup></a> See exercise <a href="#%_thm_4.23">4.23</a> for some insight
into the processing of sequences.
</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_571"><sup><small>30</small></sup></a>
é€£ãªã‚Šã®å‡¦ç†ã«å¯¾ã™ã‚‹ã„ãã¤ã‹ã®æ´å¯Ÿã«ã¤ã„ã¦ã¯ã€ç·´ç¿’å•é¡Œ<a href="#%_thm_4.23">4.23</a>ã‚’å‚ç…§ã€‚
</p>

</div>

</body>
</html>
