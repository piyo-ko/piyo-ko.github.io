<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="sicp.css" type="text/css">
<base target="_top">
<title>SICP私訳: 5.1 レジスタ・マシンを設計する</title>
<link rel="canonical" href="https://piyo-ko.github.io/SICP/31_sec5_1.html" />
</head>
<body>

<div class="idx-bar">
<nav>
<a href="https://twitter.com/share" class="twitter-share-button" data-lang="ja">ツイート</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
<span class="status">推敲待ち</span>
[
<a href="00_cover.html">先頭へ</a> |
<a href="30_chap5.html">前へ</a> |
<a href="32_sec5_2.html">次へ</a> |
<a href="04_toc.html#%_toc_start">目次</a> |
<a href="38_index.html#%_index_start">索引</a>
] [<a href="99_about.html">この対訳版について</a> | <a href="../index.html">ホーム</a>]
[
§<a href="#%_sec_5.1">5.1</a>
🎨<a href="#%_fig_5.1">5.1</a>
🎨<a href="#%_fig_5.2">5.2</a>
📝<a href="#%_thm_5.1">5.1</a>
§<a href="#%_sec_5.1.1">5.1.1</a>
🎨<a href="#%_fig_5.3">5.3</a>
📝<a href="#%_thm_5.2">5.2</a>
📚<a href="#%_sec_Temp_714">&hellip;</a>
🎨<a href="#%_fig_5.4">5.4</a>
§<a href="#%_sec_5.1.2">5.1.2</a>
🎨<a href="#%_fig_5.5">5.5</a>
🎨<a href="#%_fig_5.6">5.6</a>
📝<a href="#%_thm_5.3">5.3</a>
§<a href="#%_sec_5.1.3">5.1.3</a>
🎨<a href="#%_fig_5.7">5.7</a>
🎨<a href="#%_fig_5.8">5.8</a>
🎨<a href="#%_fig_5.9">5.9</a>
🎨<a href="#%_fig_5.10">5.10</a>
§<a href="#%_sec_5.1.4">5.1.4</a>
📚<a href="#%_sec_Temp_719">&hellip;</a>
🎨<a href="#%_fig_5.11">5.11</a>
🎨<a href="#%_fig_5.12">5.12</a>
📝<a href="#%_thm_5.4">5.4</a>
📝<a href="#%_thm_5.5">5.5</a>
📝<a href="#%_thm_5.6">5.6</a>
§<a href="#%_sec_5.1.5">5.1.5</a>
<a href="#footnotes">脚注</a>
]</nav>

</div>

<div class="main-txt">

<a name="%_sec_5.1"></a>
<h2 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_5.1">5.1  Designing Register Machines</a></h2>
<h2 class="trans" lang="ja">5.1 レジスタ・マシンを設計する</h2>

<a name="%_idx_5462"></a><a name="%_idx_5464"></a><a name="%_idx_5466"></a><a name="%_idx_5468"></a><a name="%_idx_5470"></a><a name="%_idx_5472"></a>

<p class="orig" lang="en">
To design a register machine, we must design its <em>data paths</em>
(registers and operations) and the <em>controller</em> that sequences
these operations.  To illustrate the design of a simple register
machine, let us examine Euclid's Algorithm, which is used to compute
<a name="%_idx_5474"></a>the greatest common divisor (GCD) of two integers.  As we saw in
<a name="%_idx_5476"></a>section <a href="11_sec1_2.html#%_sec_1.2.5">1.2.5</a>, Euclid's Algorithm can be carried out by an iterative
process, as specified by the following procedure:</p>

<p class="trans" lang="ja">
レジスタ・マシンを設計するには、その<em>データ<ruby><rb>経路</rb><rp> (</rp><rt>パス</rt><rp>) </rp></ruby></em> (レジスタおよび演算）と、これらの演算を順番に並べる <em>コントローラ</em> とを、設計しなくてはならない。
単純なレジスタ・マシンの設計を例示するために、ユークリッドの<ruby><rb>互除法</rb><rp> (</rp><rt>アルゴリズム</rt><rp>) </rp></ruby> ——二つの整数の最大公約数 (GCD) を計算するのに使われる——を吟味しよう。
<a href="11_sec1_2.html#%_sec_1.2.5">1.2.5</a>節で見たとおり、以下の手続きにより規定されるような反復的プロセスによって、ユークリッドの互除法を実行できる。
</p>


<p class="lisp">(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
</p>

<p class="orig" lang="en">
A machine to carry out this algorithm must keep track of two numbers,
<em>a</em> and <em>b</em>, so let us assume that these numbers are stored in two
registers with those names.  The basic operations required are testing
whether the contents of register <tt>b</tt> is zero and computing the
remainder of the contents of register <tt>a</tt> divided by the contents
of register <tt>b</tt>.  The remainder operation is a complex process,
but assume for the moment that we have a primitive device that
computes remainders.  On each cycle of the GCD algorithm, the contents
of register <tt>a</tt> must be replaced by the contents of register <tt>b</tt>, and the contents of <tt>b</tt> must be replaced by the remainder of
the old contents of <tt>a</tt> divided by the old contents of <tt>b</tt>.
It would be convenient if these replacements could be done
simultaneously, but in our model of register machines we will assume
that only one register can be assigned a new value at each step.  To
accomplish the replacements, our machine will use a third
``temporary'' register, which we call <tt>t</tt>.  (First the remainder
will be placed in <tt>t</tt>, then the contents of <tt>b</tt> will be placed
in <tt>a</tt>, and finally the remainder stored in <tt>t</tt> will be placed
in <tt>b</tt>.)</p>

<p class="trans" lang="ja">
このアルゴリズムを実行するためのマシンは、二つの数、つまり <em class="en">a</em> と <em class="en">b</em> を、把握し続けねばならない。そこで、これら二つの数が、その名前のレジスタに格納されるものだと仮定しよう。
必要とされる基本的演算は、レジスタ <tt>b</tt> の中身がゼロかどうかを検査することと、レジスタ <tt>b</tt> の中身でレジスタ <tt>a</tt> の中身を割った余りを計算することである。
剰余演算は複雑なプロセスだが、しばらくの間は、剰余を計算するプリミティブな装置があるものと仮定しよう。
GCD アルゴリズムの各サイクルにおいて、レジスタ <tt>a</tt> の中身をレジスタ <tt>b</tt> の中身で置き換えねばならず、レジスタ <tt>b</tt> の古い中身でレジスタ <tt>a</tt> の古い中身を割った余りで、レジスタ <tt>b</tt> の中身を置き換えねばならない。
もし、これらの置き換えが同時にできれば便利だろうが、私たちのレジスタ・マシンのモデルでは、各ステップにおいて一つのレジスタにしか新たな値を割り当てられないものと仮定しよう。
置き換えを達成するために、私たちのマシンは、第三の「一時的な」レジスタ—— <tt>t</tt> と呼ぶ——を使うことだろう
(まず、余りを <tt>t</tt> に置き、それから、<tt>b</tt> の中身を <tt>a</tt> に置き、最後に、<tt>t</tt> に格納されている余りを <tt>b</tt> に置くことになるだろう)。
</p>


<p class="orig" lang="en">
<a name="%_idx_5478"></a><a name="%_idx_5480"></a>We can illustrate the registers and operations required for this
machine by using the data-path diagram shown in
figure <a href="#%_fig_5.1">5.1</a>.  In this
diagram, the registers (<tt>a</tt>, <tt>b</tt>, and <tt>t</tt>) are represented
by rectangles.  Each way to assign a value to a register is
indicated by an arrow with an <tt>X</tt> behind the head, pointing from
the source of data to the register.  We can think of the <tt>X</tt> as a
button that, when pushed, allows the value at the source to ``flow''
into the designated register.  The label next to each button is the
name we will use to refer to the button.  The names are arbitrary, and
can be chosen to have mnemonic value (for example, <tt>a&lt;-b</tt> denotes
pushing the button that assigns the contents of register <tt>b</tt> to
register <tt>a</tt>).  The source of data for a register can be another
register (as in the <tt>a&lt;-b</tt> assignment), an operation result (as in
the <tt>t&lt;-r</tt> assignment), or a constant (a built-in value that
cannot be changed, represented in a data-path diagram by a triangle
containing the constant).</p>

<p class="trans" lang="ja">
このマシンに必要なレジスタと演算を、図<a href="#%_fig_5.1">5.1</a>に示すデータ経路図を用いて図示することができる。
この図では、レジスタ (<tt>a</tt> と <tt>b</tt> と <tt>t</tt>) を矩形で表している。
レジスタに値を割り当てるためのそれぞれの道筋は、データ源から当該レジスタに向かっている、先端部の後ろに <tt>X</tt> のついた矢印によって、示されている。
<tt>X</tt> は、ボタンだと——それが押されたときには、源にある値が、指定されたレジスタへと「流れる」ことを可能とする、そういったボタンだと——見なせる。
各ボタンの隣にあるラベルは、そのボタンを参照するときに私たちが使うつもりの名前である。
名前は任意であり、記憶しやすい値となるように選べる (たとえば、<tt>a&lt;-b</tt> は、レジスタ <tt>b</tt> の中身をレジスタ <tt>a</tt> に割り当てるボタンを押すことを示す)。
レジスタに対するデータ源は、(<tt>a&lt;-b</tt> の割り当てにおけるごとく) 別のレジスタということもあり得るし、(<tt>t&lt;-r</tt> の割り当てにおけるごとく) 演算結果ということもあり得るし、または、定数 (変更不能な組み込み値であり、データ経路図では、その定数を含む三角形によって表されている) ということもあり得る。
</p>

<p class="orig" lang="en">
An operation that computes a value from constants and the contents
of registers is represented in a data-path diagram by a trapezoid
containing a name for the operation.  For example, the box marked <tt>rem</tt> in figure <a href="#%_fig_5.1">5.1</a> represents an
operation that computes the remainder of the contents of the
registers <tt>a</tt> and <tt>b</tt> to which it is attached.  Arrows
(without buttons) point from the input registers and constants to the
box, and arrows connect the operation's output value to registers.
A test is represented by a circle containing a name for the test.  For
example, our GCD machine has an operation that
tests whether the contents of register
<tt>b</tt> is zero.  A test also has arrows from its input
<a name="%_idx_5482"></a><a name="%_idx_5484"></a>registers and constants, but it has no output
arrows; its value is used by the controller rather than by the data
paths.  Overall, the data-path diagram shows the registers and
operations that are required for the machine and how they must be
connected.  If we view the arrows as wires and the <tt>X</tt> buttons as
switches, the data-path diagram is very like the wiring diagram for a
machine that could be constructed from electrical components.</p>

<p class="trans" lang="ja">
定数やレジスタの中身から値を計算する演算は、データ経路図では、その演算の名前を含む台形によって表されている。
たとえば、図<a href="#%_fig_5.1">5.1</a>で <tt>rem</tt> という印がつけられた箱は、この箱が接続されているレジスタ <tt>a</tt> と <tt>b</tt> の中身の剰余を計算する演算を表す。
(ボタンなしの) 矢印が、入力レジスタや定数から箱に向かっており、矢印が演算の出力値をレジスタへとつないでいる。
検査は、その検査の名前を含む円により表されている。
たとえば、私たちの GCD マシンには、レジスタ <tt>b</tt> の中身がゼロかどうかを検査する演算がある。
テストにも、その入力のレジスタや定数からの矢印があるのだが、テストには出力矢印がない。テストの値は、データ経路によってではなく、むしろコントローラによって、使われる。
全体として、データ経路図は、マシンに必要なレジスタおよび演算と、それらをどう接続しなくてはならないのかということとを、示している。
もし、矢印を配線と見なし、<tt>X</tt> ボタンをスイッチと見なすならば、データ経路図は、電気部品から構築することができるであろうマシンについての配線図と、非常によく似ている。
</p>

<figure>
<a name="%_fig_5.1"></a>
<img src="ch5-Z-G-1.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 5.1:</b>  Data paths for a GCD machine.</figcaption>
<figcaption class="trans" lang="ja"><b>図5.1.:</b> GCD マシンに対するデータ経路図</figcaption>
</figure>

<p class="orig" lang="en">
<a name="%_idx_5486"></a><a name="%_idx_5488"></a>In order for the data paths to actually compute GCDs, the buttons must
be pushed in the correct sequence.  We will describe this sequence in
terms of a controller diagram, as illustrated in
figure <a href="#%_fig_5.2">5.2</a>.  The elements of the controller
diagram indicate how the
data-path components should be operated.  The rectangular boxes in the
controller diagram identify data-path buttons to be pushed, and the
arrows describe the sequencing from one step to the next.  The diamond
in the diagram represents a decision.  One of the two sequencing
arrows will be followed, depending on the value of the data-path test
identified in the diamond.  We can interpret the controller in terms
of a physical analogy: Think of the diagram as a maze in which a
marble is rolling.  When the marble rolls into a box, it pushes the
data-path button that is named by the box.  When the marble rolls into
a decision node (such as the test for <tt>b</tt>   = 0), it leaves the
node on the path determined by the result of the indicated test.
Taken together, the data paths and the controller completely describe
a machine for computing GCDs.  We start the controller (the rolling
marble) at the place marked <tt>start</tt>, after placing numbers in
registers <tt>a</tt> and <tt>b</tt>.  When the controller reaches <tt>done</tt>, we will find the value of the GCD in register <tt>a</tt>.
</p>

<p class="trans" lang="ja">
このデータ経路が実際に GCD を計算するためには、ボタンが正しい順で押されなくてはならない。
この順序を、図<a href="#%_fig_5.2">5.2</a>に示したような、コントローラ図の観点から記述しよう。
コントローラ図の要素は、データ経路構成要素をどのように動作させるべきかを示す。
コントローラ図での矩形の箱は、押すべきデータ経路ボタンを識別しており、矢印は、一つのステップから次のステップへの並びを記述している。
図中の菱形は、決定を表している。
菱形の中で識別されているデータ経路検査の値に応じて、並びを定める二本の矢印のうちの一本を、たどることになる。
物理との<ruby><rb>類推</rb><rp> (</rp><rt>アナロジー</rt><rp>) </rp></ruby>の観点から、コントローラを解釈できる。
菱形を、その中でビー玉が転がっている迷路だと見なそう。
ビー玉が箱の中に転がり込んだら、ビー玉は、その箱により名付けられたデータ経路ボタンを押す。
ビー玉が (<span class="math"><tt>b</tt> = 0</span> のような) 決定ノードの中に転がり込んだら、ビー玉は、示されている検査の結果により定まる経路で、当該ノードを後にする。
総合的には、GCD を計算するためのマシンを、データ経路とコントローラが完全に記述している。
私たちは、レジスタ <tt>a</tt> と <tt>b</tt> に数を入れてから、<tt>start</tt> という印のついた場所で、コントローラ (転がるビー玉) を始動させる。
コントローラが <tt>done</tt> に到達したときに、私たちは、レジスタ <tt>a</tt> の中に GCD の値を見出すであろう。
</p>

<figure>
<a name="%_fig_5.2"></a>
<img src="ch5-Z-G-2.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 5.2:</b>  Controller for a GCD machine.</figcaption>
<figcaption class="trans" lang="ja"><b>図5.2.:</b> GCD マシンに対するコントローラ</figcaption>
</figure>

<p class="orig" lang="en">
<a name="%_thm_5.1"></a>
<b>Exercise 5.1.</b>  <a name="%_idx_5490"></a>Design a register machine to compute factorials using the iterative
algorithm specified by the following procedure.  Draw data-path and
controller diagrams for this machine.</p>

<p class="trans" lang="ja">
<b>練習問題5.1.</b> 以下の手続きにより規定される反復的アルゴリズムを用いて階乗を計算するマシンを、設計せよ。
このマシンについての、データ経路図とコントローラ図を描け。
</p>

<p class="lisp">(define (factorial n)
  (define (iter product counter)
    (if (&gt; counter n)
        product
        (iter (* counter product)
              (+ counter 1))))
  (iter 1 1))
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_5.1.1"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_5.1.1">5.1.1  A Language for Describing Register Machines</a></h3>
<h3 class="trans" lang="ja">5.1.1 レジスタ・マシンを記述するための言語</h3>

<p class="orig" lang="en"><a name="%_idx_5492"></a>
Data-path and controller diagrams are adequate for representing simple
machines such as GCD, but they are unwieldy for describing large
machines such as a Lisp interpreter.  To make it possible to deal with
complex machines, we will create a language that presents, in textual
form, all the information given by the data-path and controller
diagrams.  We will start with a notation that directly mirrors the diagrams.</p>

<p class="trans" lang="ja">
データ経路図とコントローラ図は、GCD のような単純なマシンを表現するのには適切だが、Lisp インタプリタのような大規模マシンを記述するのには、非効率で扱いづらい。
複雑なマシンを扱うことを可能とするために、私たちは、データ経路図とコントローラ図により与えられる全情報をテキスト形式で表す言語を、作成しよう。
図を直接的に鏡うつしにする表記法から始めよう。
</p>

<p class="orig" lang="en">
We define the data paths of a machine by describing the registers and
the operations.  To describe a register, we give it a name
and specify the buttons that control assignment to it.  We give each
of these buttons a name and specify the source of the data that enters
the register under the button's control.  (The source is a register, a
constant, or an operation.)
To describe an operation, we give
it a name and specify its inputs (registers or constants).</p>

<p class="trans" lang="ja">
レジスタと演算を記述することで、マシンのデータ経路を定義する。
レジスタを記述するためには、そのレジスタに名前を与え、かつ、そのレジスタへの割り当てを制御するボタンを指定する。
これらのボタンの各々に名前を与え、かつ、当該ボタンの制御のもとで当該レジスタに入るデータの源を指定する
(その源とは、レジスタか、定数か、または演算である)。
演算を記述するためには、その演算に名前を与え、かつ、その演算の入力 (レジスタまたは定数) を指定する。
</p>

<p class="orig" lang="en">
We define the controller of a machine as a sequence of <a name="%_idx_5494"></a><em>instructions</em> together with <a name="%_idx_5496"></a><a name="%_idx_5498"></a><em>labels</em> that identify <em>entry
points</em> in the sequence. An instruction is one of the following:
</p>

<p class="trans" lang="ja">
マシンのコントローラを、列の中における<em>エントリ・ポイント</em>を特定する<em>ラベル</em>付きの<em>命令</em>列として、定義する。
命令とは、以下のもののうちの一つである。
</p>

<ul class="orig" lang="en">
<li>The name of a data-path button to push to assign a value to
a register.  (This corresponds to a box in the controller diagram.)</li>

<a name="%_idx_5500"></a><a name="%_idx_5502"></a><li>A <tt>test</tt> instruction, that performs a specified test.</li>

<a name="%_idx_5504"></a><a name="%_idx_5506"></a><a name="%_idx_5508"></a><a name="%_idx_5510"></a><li>A conditional branch (<tt>branch</tt> instruction) to a
location indicated by a controller label, based on the result of the
previous test.  (The test and branch together correspond to a diamond
in the controller diagram.)  If the test is false, the controller
should continue with the next instruction in the sequence.  Otherwise,
the controller should continue with the instruction after the label.</li>

<a name="%_idx_5512"></a><a name="%_idx_5514"></a><li>An unconditional branch (<tt>goto</tt> instruction) naming a
controller label at which to continue execution.</li>
</ul>

<ul class="trans" lang="ja">
<li>レジスタに値を割り当てるために押すべき、データ経路ボタンの名前
(これは、コントローラ図での箱に対応する)。</li>
<li>指定された検査を行う、<tt>test</tt> 命令。</li>
<li>コントローラ・ラベルにより示される場所への、前の検査の結果に基づいた、条件分岐 (<tt>branch</tt> 命令)
(検査と分岐は、まとめて、コントローラ図での菱形に対応する)。
もし検査が偽なら、コントローラは、列における次の命令を続行すべきである。
そうでなければ、コントローラは、当該ラベルの後の命令を続行すべきである。
</li>
<li>実行を続行すべき箇所のコントローラ・ラベルの名前を示す、無条件分岐 (<tt>goto</tt> 命令)。</li>
</ul>

<p class="orig" lang="en">The machine starts at the beginning of the controller instruction
sequence and stops when execution reaches the end of the sequence.
Except when a branch changes the flow of control, instructions are
executed in the order in which they are listed.</p>

<p class="trans" lang="ja">
マシンは、コントローラ命令列の最初から始めて、実行が列の最後に達したら停止する。
分岐が制御の流れを変える場合を除いて、命令は、それら命令が並べられている順に実行される。
</p>

<figure>
<a name="%_fig_5.3"></a><p class="infig-lisp">(data-paths
 (registers
  ((name a)
   (buttons ((name a&lt;-b) (source (register b)))))
  ((name b)
   (buttons ((name b&lt;-t) (source (register t)))))
  ((name t)
   (buttons ((name t&lt;-r) (source (operation rem))))))

 (operations
  ((name rem)
   (inputs (register a) (register b)))
  ((name =)
   (inputs (register b) (constant 0)))))

(controller
 test-b                           <em>; label</em>
   (test =)                       <em>; test</em>
   (branch (label gcd-done))      <em>; conditional branch</em>
   (t&lt;-r)                         <em>; button push</em>
   (a&lt;-b)                         <em>; button push</em>
   (b&lt;-t)                         <em>; button push</em>
   (goto (label test-b))          <em>; unconditional branch</em>
 gcd-done)                        <em>; label</em>
</p>

<figcaption class="orig" lang="en"><b>Figure 5.3:</b>  A specification of the GCD machine.</figcaption>
<figcaption class="trans" lang="ja"><b>図5.3.:</b> GCDマシンの仕様</figcaption>
</figure>


<p class="orig" lang="en">
Figure <a href="#%_fig_5.3">5.3</a> shows the GCD machine described in
this way.  This example only hints at the generality of these
descriptions, since the GCD machine is a very simple case: Each
register has only one button, and each button and test is used only
once in the controller.</p>

<p class="trans" lang="ja">
図<a href="#%_fig_5.3">5.3</a>は、こうした方法で記述した GCD マシンを示している。
この例は、単に、こうした記述の一般性をほのめかすのに過ぎない。なぜなら、GCD マシンは非常に単純な事例だからである。
各レジスタには一つしかボタンがないし、各ボタンと各検査は、コントローラにおいてたった一度しか使われないのだ。
</p>

<p class="orig" lang="en">
Unfortunately, it is difficult to read such a description.  In order
to understand the controller instructions we must constantly refer
back to the definitions of the button names and the operation names,
and to understand what the buttons do we may have to refer to the
definitions of the operation names.  We will thus transform our
notation to combine the information from the data-path and controller
descriptions so that we see it all together.</p>

<p class="trans" lang="ja">
あいにく、このような記述を読むのは難しい。
コントローラ命令を理解するためには、絶えずボタン名や演算名の定義へと戻って参照せねばならないし、ボタンが何をするのかを理解するには、演算名の定義を参照しなくてはならないこともある。
そのため、私たちは、データ経路記述とコントローラ記述からの情報を、すべて一緒に目に入るように結びつけるために、表記法を変形しよう。
</p>

<p class="orig" lang="en">
To obtain this form of description, we will replace the arbitrary
button and operation names by the definitions of their behavior.  That
is, instead of saying (in the controller) ``Push button <tt>t&lt;-r</tt>''
and separately saying (in the data paths) ``Button <tt>t&lt;-r</tt> assigns
the value of the <tt>rem</tt> operation to register <tt>t</tt>'' and ``The
<tt>rem</tt> operation's inputs are the contents of registers
<a name="%_idx_5516"></a><a name="%_idx_5518"></a><a name="%_idx_5520"></a><a name="%_idx_5522"></a><a name="%_idx_5524"></a><a name="%_idx_5526"></a><tt>a</tt> and <tt>b</tt>,'' we will say (in the controller) ``Push the
button that assigns to register <tt>t</tt> the value of the <tt>rem</tt>
operation on the contents of registers <tt>a</tt> and <tt>b</tt>.''
Similarly, instead of saying (in the controller) ``Perform the <tt>=</tt> test'' and separately saying (in the data paths) ``The <tt>=</tt> test operates on the contents of register <tt>b</tt> and the
constant 0,'' we will say ``Perform the <tt>=</tt> test on the
<a name="%_idx_5528"></a><a name="%_idx_5530"></a>contents of register <tt>b</tt> and the constant 0.''  We will omit the
data-path description, leaving only the controller sequence.  Thus,
the GCD machine is described as follows:</p>

<p class="trans" lang="ja">
この形式の記述を得るために、任意のボタン名および演算名を、その振る舞いで置き換えよう。
つまり、(コントローラにおいて)「<tt>t&lt;-r</tt> というボタンを押せ」と述べつつ、別途 (データ経路において)「<tt>t&lt;-r</tt> というボタンは、<tt>rem</tt> という演算の値を、<tt>t</tt> というレジスタに割り当てる」および「<tt>rem</tt> という演算の入力は、<tt>a</tt> と <tt>b</tt> というレジスタの中身である」と述べる、とする代わりに、(コントローラにおいて)「<tt>a</tt> と <tt>b</tt> というレジスタの中身に対する <tt>rem</tt> という演算の値を <tt>t</tt> というレジスタに割り当てるボタンを、押せ」と述べることにしよう。
同様に、(コントローラにおいて)「<tt>=</tt> の検査を実行せよ」と述べつつ、別途 (データ経路において)「<tt>=</tt> の検査は、<tt>b</tt> というレジスタの中身と、0 という定数とに対して、作用する」と述べる、とする代わりに、「<tt>b</tt> というレジスタの中身と、0 という定数とに対して、<tt>=</tt> の検査を実行せよ」と述べることにしよう。
私たちは、データ経路記述を省略することになり、するとコントローラ列のみを残すことになる。
よって、GCD マシンは、次のように記述される。
</p>

<p class="lisp">(controller
 test-b
   (test (op =) (reg b) (const 0))
   (branch (label gcd-done))
   (assign t (op rem) (reg a) (reg b))
   (assign a (reg b))
   (assign b (reg t))
   (goto (label test-b))
 gcd-done)
</p>

<p class="orig" lang="en">
This form of description is easier to read than the kind illustrated
in figure <a href="#%_fig_5.3">5.3</a>, but it also has disadvantages:
</p>

<p class="trans" lang="ja">
この形式の記述は、図<a href="#%_fig_5.3">5.3</a>に示した類の記述よりも読みやすいのだが、欠点もある。
</p>

<ul class="orig" lang="en">
<li>It is more verbose for large machines,
because complete descriptions of the data-path elements are repeated
whenever the elements are mentioned in the controller instruction
sequence.  (This is not a problem in the GCD example, because each
operation and button is used only once.)  Moreover, repeating the
data-path descriptions obscures the actual data-path structure of the
machine; it is not obvious for a large machine how many registers,
operations, and buttons there are and how they are interconnected.
</li>

<li>Because the controller instructions in a machine definition
look like Lisp expressions, it is easy to forget that they are
not arbitrary Lisp expressions.  They can notate only legal machine
operations.  For example, operations can operate directly only on
constants and the contents of registers, not on the results of other
operations.</li>
</ul>

<ul class="trans" lang="ja">
<li>大規模なマシンについては、より冗長になってしまう。というのも、データ経路要素の完全な記述が、当該要素がコントローラ命令列の中で言及されるたびに、繰り返されるからである (これは、GCD の事例では問題ではない。なぜなら、各演算と各ボタンが一度しか使われないためである)。
さらに、データ経路記述を繰り返すことによって、マシンの実際のデータ経路構造を分かりにくくしてしまう。大規模マシンについては、レジスタや演算やボタンがいくつあるのかということや、それらがどのように互いに接続されているのかということが、明らかではない。</li>
<li>マシン定義におけるコントローラ命令が Lisp 式のように見えるせいで、それらの命令が任意の Lisp 式ではないのだということを忘れやすい。
それらは、ただ適法なマシン演算を表記できるのにすぎない。
たとえば、演算は、定数、および、レジスタの中身に対してのみ、直接的に作用することができるのであって、他の演算の結果に対して直接的に作用することができるのではない。
</li>
</ul>

<p class="orig" lang="en">In spite of these disadvantages, we will use this register-machine
language throughout this chapter, because we will be more concerned with
understanding controllers than with understanding the elements and
connections in data paths.  We should keep in mind,
however, that data-path design is crucial in designing real machines.</p>

<p class="trans" lang="ja">
これらの欠点にもかかわらず、私たちは本章全体を通じて、このレジスタ・マシン言語を使うことにしよう。なぜなら、データ経路における要素と接続を理解することよりも、コントローラを理解することの方に、私たちはより多くの関心を持つであろうから。
しかし、現実のマシンを設計する際にはデータ経路設計が決定的に重要だということは、心に留めておくべきである。
</p>

<p class="orig" lang="en">
<a name="%_thm_5.2"></a>
<b>Exercise 5.2.</b>  <a name="%_idx_5532"></a>Use the register-machine language to describe
the iterative factorial machine of exercise <a href="#%_thm_5.1">5.1</a>.
</p>

<p class="trans" lang="ja">
<b>練習問題5.2.</b> レジスタ・マシン言語を使って、練習問題<a href="#%_thm_5.1">5.1</a>の反復式の階乗マシンを記述せよ。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_Temp_714"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_714">Actions</a></h4>
<h4 class="trans" lang="ja"><ruby><rb>動作</rb><rp> (</rp><rt>アクション</rt><rp>) </rp></ruby></h4>


<p class="orig" lang="en">
<a name="%_idx_5534"></a><a name="%_idx_5536"></a>
Let us modify the GCD machine so that we can type in the numbers
whose GCD we want and get the answer printed at our terminal.  We will
not discuss how to make a machine that can read and print, but will
assume (as we do when we use <tt>read</tt> and <tt>display</tt> in Scheme) that
they are available as primitive operations.<a name="call_footnote_Temp_715" href="#footnote_Temp_715"><sup><small>1</small></sup></a></p>

<p class="trans" lang="ja">
GCD を求めたい数をタイプ入力できるように、そして、自分の端末に答えを印字できるように、GCD マシンを改修しよう。
読み込みや印字ができるマシンをどうやって作るのか、ということについては、議論しないでおこう。しかし、(Scheme で <tt>read</tt> と <tt>display</tt> を使うときにそう仮定するのと同じように) 原始的演算として <tt>read</tt> と <tt>display</tt> が利用可能なのだと仮定しよう<a href="#footnote_Temp_715"><sup><small>1</small></sup></a>。
</p>

<p class="orig" lang="en">
<a name="%_idx_5538"></a><tt>Read</tt> is like the operations we have been using in that it
produces a value that can be stored in a register.  But <tt>read</tt>
does not take inputs from any registers; its value depends on
something that happens outside the parts of the machine we are
designing.  We will allow our machine's operations to have such
behavior, and thus will draw and notate the use of <tt>read</tt> just as
we do any other operation that computes a value.</p>

<p class="trans" lang="ja">
<tt>read</tt> は、レジスタに格納できる値を作り出すという点においては、これまで使ってきた諸演算に似ている。
しかし、<tt>read</tt> は、どのレジスタからの入力も取らない。<tt>read</tt> の値は、私たちが設計中のマシンの諸部品の外側で起こるような何かに、依存するのだ。
私たちのマシンの演算がそうした振る舞いを有することを許すことにし、したがって、値を計算する任意の他の演算を描いたり表記したりするのとちょうど同じように、<tt>read</tt> の使用を描いたり表記したりしよう。
</p>


<p class="orig" lang="en">
<a name="%_idx_5540"></a><tt>Print</tt>, on the other hand, differs from the operations we have
been using in a fundamental way: It does not produce an output value
to be stored in a register.  Though it has an effect, this effect is
not on a part of the machine we are designing.  We will refer to this
kind of operation as an <em>action</em>.  We will represent an action in
a data-path diagram just as we represent an operation that computes a
value -- as a trapezoid that contains the name of the action.
Arrows point to the action box from any inputs (registers or
constants).  We also associate a button with the action.  Pushing the
button makes the action happen.  To make a controller push an action
<a name="%_idx_5542"></a><a name="%_idx_5544"></a>button we use a new kind of instruction called <tt>perform</tt>.  Thus,
the action of printing the contents of register <tt>a</tt> is represented
in a controller sequence by the instruction</p>

<p class="trans" lang="ja">
他方、<tt>print</tt> は、これまで使ってきた諸演算とは根本的な点で異なる。<tt>print</tt> は、レジスタに格納すべき出力値を生み出さないのだ。
<tt>print</tt> は効果を有するが、この効果は、私たちが設計中のマシンの一部に対するものではない。
この種の演算を<em>アクション</em>と呼ぶことにしよう。
データ経路図では、値を計算する演算を表すのとちょうど同じように、アクションを——そのアクションの名前を含む台形として——表すことにしよう。
矢印は、どの入力 (レジスタか定数) からでも、アクションの箱を指す。
私たちは、ボタンもアクションに関連づける。
ボタンを押すことで、そのアクションを起こす。
コントローラにアクション・ボタンを押させるためには、<tt>perform</tt> と呼ばれる新たな種類の命令を使う。
よって、<tt>a</tt> というレジスタの中身を印字するというアクションは、コントローラ列において、以下の命令により表される。
</p>

<p class="lisp">(perform (op print) (reg a))
</p>

<p class="orig" lang="en">
Figure <a href="#%_fig_5.4">5.4</a> shows the data paths and controller for
the new GCD machine.  Instead of having the machine stop after
printing the answer, we have made it start over, so that it repeatedly
reads a pair of numbers, computes their GCD, and prints the result.
This structure is like the driver loops we used in the interpreters of
chapter 4.</p>

<p class="trans" lang="ja">
図<a href="#%_fig_5.4">5.4</a>は、新たな GCD マシン用のデータ経路とコントローラを示している。
答えを印字した後にマシンを停止させる代わりに、私たちは、マシンに最初からやり直させる。するとその結果、マシンは繰り返し、一対の数を読み込み、それらの GCD を計算し、結果を印字する。
この構造は、4章のインタプリタで使ったドライバ・ループと似ている。
</p>

<figure>
<a name="%_fig_5.4"></a>
<img src="ch5-Z-G-3.gif" border="0">
<p class="infig-lisp">(controller
  gcd-loop
    (assign a (op read))
    (assign b (op read))
  test-b
    (test (op =) (reg b) (const 0))
    (branch (label gcd-done))
    (assign t (op rem) (reg a) (reg b))
    (assign a (reg b))
    (assign b (reg t))
    (goto (label test-b))
  gcd-done
    (perform (op print) (reg a))
    (goto (label gcd-loop)))
</p>
<figcaption class="orig" lang="en"><b>Figure 5.4:</b>  A GCD machine that reads inputs and prints results.</figcaption>
<figcaption class="trans" lang="ja"><b>図5.4.:</b> 入力を読み込んで結果を印字する GCD マシン</figcaption>
</figure>

<a name="%_sec_5.1.2"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_5.1.2">5.1.2  Abstraction in Machine Design</a></h3>
<h3 class="trans" lang="ja">5.1.2 マシン設計での抽象化</h3>

<p class="orig" lang="en"><a name="%_idx_5546"></a>
We will often define a machine to include ``primitive'' operations that are
actually very complex.  For example, in sections <a href="34_sec5_4.html#%_sec_5.4">5.4</a> and
<a href="35_sec5_5.html#%_sec_5.5">5.5</a> we will treat Scheme's environment
manipulations as primitive.  Such abstraction is valuable because it
allows us to ignore the details of parts of a machine so that we can
concentrate on other aspects of the design.  The fact that we have
swept a lot of complexity under the rug, however, does not mean that a
machine design is unrealistic.  We can always replace the complex
``primitives'' by simpler primitive operations.</p>

<p class="trans" lang="ja">
私たちは、しばしば、実際にはとても複雑な「<ruby><rb>原始的</rb><rp> (</rp><rt>プリミティブ</rt><rp>) </rp></ruby>」演算を含むようにマシンを定義することだろう。
たとえば、<a href="34_sec5_4.html#%_sec_5.4">5.4</a>節と<a href="35_sec5_5.html#%_sec_5.5">5.5</a>節では、Scheme の環境操作をプリミティブとして取り扱おう。
そうした抽象化は、有益である。なぜなら、設計の別の側面に集中できるように、マシンの諸部分の詳細を無視することを、可能にしてくれるからである。
しかし、大量の複雑性を絨毯の下へと掃いて隠したという事実は、マシン設計が非現実的だということを意味するわけではない。
複雑な「プリミティブ」は、いつでも、より単純な原始的演算に置き換えることができるのだ。
</p>

<p class="orig" lang="en">
Consider the GCD machine. The machine has an instruction that computes
the remainder of the contents of registers <tt>a</tt> and <tt>b</tt> and
assigns the result to register <tt>t</tt>.  If we want to construct the
GCD machine without using a primitive remainder operation,
we must specify how to compute remainders in terms of simpler
operations, such as subtraction.  Indeed, we can write a Scheme
procedure that finds remainders in this way:</p>

<p class="trans" lang="ja">
GCD マシンを考えよう。
このマシンには、<tt>a</tt> と <tt>b</tt> というレジスタの中身の剰余を計算して結果を <tt>t</tt> というレジスタに割り当てる命令がある。
もし、原始的剰余演算を使わずに GCD マシンを構築したければ、減算のような、より単純な演算を用いて剰余を計算する方法を指定しなくてはならない。
確かに、こうした方法で剰余を求める Scheme 手続きを、書くことができる。
</p>

<p class="lisp">(define (remainder n d)
  (if (&lt; n d)
      n
      (remainder (- n d) d)))
</p>

<p class="orig" lang="en">We can thus replace the remainder operation in the GCD machine's
data paths with a subtraction operation and a comparison test.
Figure <a href="#%_fig_5.5">5.5</a> shows the data paths and controller
for the elaborated machine.
The instruction</p>

<p class="trans" lang="ja">
よって、GCD マシンのデータ経路における剰余演算を、減算演算と比較検査に置き換えられる。
図<a href="#%_fig_5.5">5.5</a>は、複雑化したマシンについての、データ経路とコントローラを示している。
次の命令は、
</p>

<figure>
<a name="%_fig_5.5"></a>
<img src="ch5-Z-G-4.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 5.5:</b>  Data paths and controller for the elaborated GCD  machine.</figcaption>
<figcaption class="trans" lang="ja"><b>図5.5.:</b> 複雑化した GCD マシンについての、データ経路とコントローラ</figcaption>
</figure>

<p class="lisp">(assign t (op rem) (reg a) (reg b))
</p>

<p class="orig" lang="en">in the GCD controller definition is replaced by a sequence of
instructions that contains a loop, as shown in
figure <a href="#%_fig_5.6">5.6</a>.</p>

<p class="trans" lang="ja">
GCD コントローラ定義において、図<a href="#%_fig_5.6">5.6</a>に示されるように、ループを含む命令列に置き換えられる。
</p>

<figure>
<a name="%_fig_5.6"></a>
<p class="infig-lisp">(controller
 test-b
   (test (op =) (reg b) (const 0))
   (branch (label gcd-done))
   (assign t (reg a))
 rem-loop
   (test (op &lt;) (reg t) (reg b))
   (branch (label rem-done))
   (assign t (op -) (reg t) (reg b))
   (goto (label rem-loop))
 rem-done
   (assign a (reg b))
   (assign b (reg t))
   (goto (label test-b))
 gcd-done)
</p>
<figcaption class="orig" lang="en"><b>Figure 5.6:</b>  Controller instruction sequence for the GCD machine in
figure <a href="#%_fig_5.5">5.5</a>.</figcaption>
<figcaption class="trans" lang="ja"><b>図5.6.:</b> 図<a href="#%_fig_5.5">5.5</a>の GCD マシンについての、コントローラ命令列</figcaption>
</figure>

<p class="orig" lang="en">
<a name="%_thm_5.3"></a>
<b>Exercise 5.3.</b>  <a name="%_idx_5548"></a>Design a machine to compute square roots using Newton's method, as
described in section <a href="10_sec1_1.html#%_sec_1.1.7">1.1.7</a>:</p>

<p class="trans" lang="ja">
<b>練習問題5.3.</b> <a href="10_sec1_1.html#%_sec_1.1.7">1.1.7</a>節で説明したようなニュートン法を使って二乗根を計算するマシンを設計せよ。
</p>

<p class="lisp">(define (sqrt x)
  (define (good-enough? guess)
    (&lt; (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))
</p>

<p class="orig" lang="en">Begin by assuming that <tt>good-enough?</tt> and <tt>improve</tt> operations
are available as primitives.  Then show how to expand these in terms
of arithmetic operations.  Describe each version of the <tt>sqrt</tt>
machine design by drawing a data-path diagram and writing a controller
definition in the register-machine language.
</p>

<p class="trans" lang="ja">
<tt>good-enough?</tt> と <tt>improve</tt> の演算がプリミティブとして利用可能だ、と仮定するところから始めよ。
その後、これらの演算を、算術演算を用いて展開する方法を示せ。
データ経路図を描くこと、および、コントローラ定義をレジスタ・マシン言語で書くことによって、<tt>sqrt</tt> マシン設計の各バージョンを記述せよ。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_5.1.3"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_5.1.3">5.1.3  Subroutines</a></h3>
<h3 class="trans" lang="ja">5.1.3 サブルーチン</h3>

<p class="orig" lang="en"><a name="%_idx_5550"></a><a name="%_idx_5552"></a>
When designing a machine to perform a computation, we would often
prefer to arrange for components to be shared by different parts of
the computation rather than duplicate the components.  Consider a
machine that includes two GCD computations -- one that finds the GCD of
the contents of registers <tt>a</tt> and <tt>b</tt> and one that finds the
GCD of the contents of registers <tt>c</tt> and <tt>d</tt>.  We might start
by assuming we have a primitive <tt>gcd</tt> operation, then expand the
two instances of <tt>gcd</tt> in terms of more primitive operations.
Figure <a href="#%_fig_5.7">5.7</a> shows just the GCD portions of the
resulting machine's data paths, without showing how they connect to
the rest of the machine.  The figure also shows the corresponding
portions of the machine's controller sequence.</p>

<p class="trans" lang="ja">
計算を実行するマシンを設計する際、しばしば私たちは、その計算の異なる部分により構成要素が共有されるように手筈を整えることを、それら構成要素を複製するよりも、むしろ好むことだろう。
二つの GCD 計算—— <tt>a</tt> と <tt>b</tt> というレジスタの中身の GCD を求めるものと、<tt>c</tt> と <tt>d</tt> というレジスタの中身の GCD を求めるもの——を含むマシンを考えよう。
原始的な <tt>gcd</tt> 演算がある、と仮定するところから始めて、それから、より原始的な演算を用いて、<tt>gcd</tt> の二つの<ruby><rb>具体例</rb><rp> (</rp><rt>インスタンス</rt><rp>) </rp></ruby>を展開する、というふうにしてもよいかもしれない。
図<a href="#%_fig_5.7">5.7</a>は、結果としてできるマシンのデータ経路のうちの、GCD 部分だけを示していて、それら GCD 部分がマシンの残りの部分にどのように接続しているのかは示していない。
この図は、このマシンのコントローラ列の、対応する部分も示している。
</p>

<figure>
<a name="%_fig_5.7"></a>
<img src="ch5-Z-G-5.gif" border="0">

<p class="infig-lisp">gcd-1
 (test (op =) (reg b) (const 0))
 (branch (label after-gcd-1))
 (assign t (op rem) (reg a) (reg b))
 (assign a (reg b))
 (assign b (reg t))
 (goto (label gcd-1))
after-gcd-1
   <img src="book-Z-G-D-18.gif" border="0"> 
gcd-2
 (test (op =) (reg d) (const 0))
 (branch (label after-gcd-2))
 (assign s (op rem) (reg c) (reg d))
 (assign c (reg d))
 (assign d (reg s))
 (goto (label gcd-2))
after-gcd-2
</p>
<figcaption class="orig" lang="en"><b>Figure 5.7:</b>  Portions of the data paths and controller sequence for
a machine with two GCD computations.</figcaption>
<figcaption class="trans" lang="ja"><b>図5.7.:</b> 二つの GCD 計算を伴うマシンについての、データ経路とコントローラ列のいくつかの部分</figcaption>
</figure>


<p class="orig" lang="en">
This machine has two remainder operation boxes and two boxes for
testing equality.  If the duplicated components are complicated, as is the
remainder box, this will not be an economical way to build the
machine.  We can avoid duplicating the data-path components by using
the same components for both GCD computations, provided that doing so
will not affect the rest of the larger machine's computation.  If the
values in registers <tt>a</tt> and <tt>b</tt> are not needed by the time the
controller gets to <tt>gcd-2</tt> (or if these values can be moved to
other registers for safekeeping), we can change the machine so that
it uses registers <tt>a</tt> and <tt>b</tt>, rather than registers <tt>c</tt>
and <tt>d</tt>, in computing the second GCD as well as the first.  If we
do this, we obtain the controller sequence shown in
figure <a href="#%_fig_5.8">5.8</a>.</p>

<p class="trans" lang="ja">
このマシンには、二つの剰余演算の箱と、等価性を検査するための二つの箱がある。
もし、複製された構成要素が、剰余の箱のように入り組んでいたら、これは、マシンを構築するのに無駄のないやり方ではないだろう。
同じ構成要素を双方の GCD 計算に使うことによって、データ経路構成要素を複製することを防げる——ただし、そのようにすることが、より大きなマシンの計算の残りの部分に影響しないだろう、という場合に限って。
もし、コントローラが <tt>gcd-2</tt> に達する時点まで、<tt>a</tt> と <tt>b</tt> というレジスタの中の値が必要とされないならば (あるいは、もし、これらの値を、安全のために別のレジスタに移動できるならば)、私たちは、第一の GCD を計算する際と同様、第二の GCD を計算する際にも、<tt>c</tt> と <tt>d</tt> というレジスタではなく、むしろ <tt>a</tt> と <tt>b</tt> というレジスタを使うように、マシンを変更できる。
もし、このようにすれば、私たちは、図<a href="#%_fig_5.8">5.8</a>に示すコントローラ列を得る。
</p>

<p class="orig" lang="en">
We have removed the duplicate data-path components
(so that the data paths are again as in figure <a href="#%_fig_5.1">5.1</a>),
but the controller
now has two GCD sequences that differ only in their entry-point
labels.  It would be better to replace these two sequences by branches
to a single sequence -- a <tt>gcd</tt> <em>subroutine</em> -- at the end of
which we branch back to the correct place in the main instruction
sequence.  We can accomplish this as follows: Before branching to <tt>gcd</tt>, we place a distinguishing value (such as 0 or 1) into a special
register, <a name="%_idx_5554"></a><tt>continue</tt>.  At the end of the <tt>gcd</tt> subroutine we
return either to <tt>after-gcd-1</tt> or to <tt>after-gcd-2</tt>, depending
on the value of the <tt>continue</tt> register.
Figure <a href="#%_fig_5.9">5.9</a> shows the relevant portion of the
resulting controller sequence, which includes only a single copy of the
<tt>gcd</tt> instructions.</p>

<p class="trans" lang="ja">
(データ経路が再び図<a href="#%_fig_5.1">5.1</a>のようになるように) 重複データ経路構成要素を取り除いたわけだが、今ここで、コントローラには、エントリ・ポイント・ラベルのみが異なる二つの GCD 列がある。
これら二つの列を、最後には<ruby><rb>本筋</rb><rp> (</rp><rt>メイン</rt><rp>) </rp></ruby>の命令列における正しい場所へと分岐して戻るような一つの列—— <tt>gcd</tt> という<em>サブルーチン</em>——への分岐によって置き換えると、より良いだろう。
これは次のようにして達成できる。
<tt>gcd</tt> へと分岐する前に、(0 または 1 といったような) 識別力のある値を、特別なレジスタ——つまり <tt>continue</tt> ——に入れる。
<tt>gcd</tt> のサブルーチンの最後で、<tt>continue</tt> というレジスタの値によって、<tt>after-gcd-1</tt> か <tt>after-gcd-2</tt> のいずれかへと戻る。
図<a href="#%_fig_5.9">5.9</a>は、結果としてできるコントローラ列の一部を示しており、これは、<tt>gcd</tt> の命令一式を一組だけしか含まない。
</p>

<figure>
<a name="%_fig_5.8"></a>
<p class="infig-lisp">gcd-1
 (test (op =) (reg b) (const 0))
 (branch (label after-gcd-1))
 (assign t (op rem) (reg a) (reg b))
 (assign a (reg b))
 (assign b (reg t))
 (goto (label gcd-1))
after-gcd-1
  <img src="book-Z-G-D-18.gif" border="0">
gcd-2
 (test (op =) (reg b) (const 0))
 (branch (label after-gcd-2))
 (assign t (op rem) (reg a) (reg b))
 (assign a (reg b))
 (assign b (reg t))
 (goto (label gcd-2))
after-gcd-2
</p>

<figcaption class="orig" lang="en"><b>Figure 5.8:</b>  Portions of the controller sequence for a machine that
uses the same data-path components for two different GCD
computations.</figcaption>
<figcaption class="trans" lang="ja"><b>図5.8.:</b> 二つの異なる GCD 計算に対して同じデータ経路構成要素を用いるマシンについての、コントローラ列の部分</figcaption>
</figure>

<figure>
<a name="%_fig_5.9"></a>
<p class="infig-lisp">gcd
 (test (op =) (reg b) (const 0))
 (branch (label gcd-done))
 (assign t (op rem) (reg a) (reg b))
 (assign a (reg b))
 (assign b (reg t))
 (goto (label gcd))
gcd-done
 (test (op =) (reg continue) (const 0))       
 (branch (label after-gcd-1))
 (goto (label after-gcd-2))
  <img src="book-Z-G-D-18.gif" border="0">
<em>;; Before branching to <tt>gcd</tt> from the first place where</em>
<em>;; it is needed, we place 0 in the <tt>continue</tt> register</em>
<em>;; (<tt>gcd</tt> が必要とされる最初の場所から <tt>gcd</tt> へと分岐する前に </em>
<em>;;  <tt>continue</tt> というレジスタに 0 を置く)</em>
 (assign continue (const 0))
 (goto (label gcd))
after-gcd-1
  <img src="book-Z-G-D-18.gif" border="0">
<em>;; Before the second use of <tt>gcd</tt>, we place 1 in the <tt>continue</tt> register</em>
<em>;; (<tt>gcd</tt> を二度目に使う前に、<tt>continue</tt> というレジスタに 1 を置く)</em>
 (assign continue (const 1))
 (goto (label gcd))
after-gcd-2
</p>

<figcaption class="orig" lang="en"><b>Figure 5.9:</b>  Using a <tt>continue</tt> register to avoid
the duplicate controller sequence in figure <a href="#%_fig_5.8">5.8</a>.</figcaption>
<figcaption class="trans" lang="ja"><b>図5.9.:</b> 図<a href="#%_fig_5.8">5.8</a>での重複コントローラ列を避けるために、<tt>continue</tt> というレジスタを使う</figcaption>
</figure>

<figure>
<a name="%_fig_5.10"></a>
<p class="infig-lisp">gcd
 (test (op =) (reg b) (const 0))
 (branch (label gcd-done))
 (assign t (op rem) (reg a) (reg b))
 (assign a (reg b))
 (assign b (reg t))
 (goto (label gcd))
gcd-done
 (goto (reg continue))
   <img src="book-Z-G-D-18.gif" border="0">
<em>;; Before calling <tt>gcd</tt>, we assign to <tt>continue</tt></em>
<em>;; the label to which <tt>gcd</tt> should return.</em>
<em>;; (<tt>gcd</tt> を呼び出す前に、<tt>gcd</tt> が戻るべき先のラベルを <tt>continue</tt> に割り当てる)</em>
 (assign continue (label after-gcd-1))
 (goto (label gcd))
after-gcd-1
   <img src="book-Z-G-D-18.gif" border="0">
<em>;; Here is the second call to <tt>gcd</tt>, with a different continuation.</em>
<em>;; (ここが、<tt>gcd</tt> に対する二度目の呼び出しであり、異なる継続をともなっている)</em>
 (assign continue (label after-gcd-2))
 (goto (label gcd))
after-gcd-2
</p>

<figcaption class="orig" lang="en"><b>Figure 5.10:</b>  Assigning labels to the <tt>continue</tt> register simplifies
and generalizes the strategy shown in figure <a href="#%_fig_5.9">5.9</a>.</figcaption>
<figcaption class="trans" lang="ja"><b>図5.10.:</b> <tt>continue</tt> というレジスタにラベルを割り当てることで、図<a href="#%_fig_5.9">5.9</a>に示した戦略が簡略化され、かつ一般化される</figcaption>
</figure>

<p class="orig" lang="en">
This is a reasonable approach for handling small problems, but it
would be awkward if there were many instances of GCD computations in
the controller sequence.  To decide where to continue executing after
the <tt>gcd</tt> subroutine, we would need tests in the data paths and
branch instructions in the controller for all the places that use <tt>gcd</tt>.  A more powerful method for implementing subroutines is to have
the <tt>continue</tt> register hold the label of the entry point in the
controller sequence at which execution should continue when the
subroutine is finished.  Implementing this strategy requires a new
kind of connection between the data paths and the controller of a
register machine: There must be a way to assign to a register a label
in the controller sequence in such a way that this value can be fetched
from the register and used to continue execution at the designated
entry point.</p>

<p class="trans" lang="ja">
これは、小さな問題については合理的な手法である。しかし、もし、コントローラ列に多数の GCD 計算があれば、厄介なものになるだろう。
<tt>gcd</tt> サブルーチンの後で実行を続けるべき場所を決定するためには、<tt>gcd</tt> を使うすべての場所について、データ経路における検査と、コントローラにおける分岐命令とが必要となるだろう。
サブルーチンを実装するためのより強力な方法は、サブルーチンが終了したときに実行が続くべき箇所である、コントローラ列内のエントリ・ポイントの、ラベルを <tt>continue</tt> レジスタに保持させることである。
この戦略を実装することは、レジスタ・マシンのデータ経路とコントローラとの間の、新たな種類の接続を要する。
コントローラ列におけるラベルをレジスタに割り当てるための——しかも、そのレジスタからこの値を取り出すことができ、かつ、指定されたエントリ・ポイントで実行を続行するのにこの値を使うことができるような方法で、割り当てるための——方法が、存在せねばならないのだ。
</p>

<p class="orig" lang="en">
<a name="%_idx_5556"></a><a name="%_idx_5558"></a>To reflect this ability, we will extend the <tt>assign</tt>
instruction of the register-machine language to allow a register to be
assigned as value a label from the controller sequence (as a special
kind of constant).  We will also extend the <tt>goto</tt> instruction to
allow execution to continue at the entry point described by the
contents of a register rather than only at an entry point described by
a constant label.  Using these new constructs we can terminate the
<tt>gcd</tt> subroutine with a branch to the location stored in the <tt>continue</tt> register.  This leads to the controller sequence shown in
figure <a href="#%_fig_5.10">5.10</a>.</p>

<p class="trans" lang="ja">
この能力を反映するために、レジスタ・マシン言語における <tt>assign</tt> 命令を拡張して、コントローラ列からのラベルを値として (特別な種類の定数として) レジスタに割り当てることができるようにしよう。
また、<tt>goto</tt> 命令も拡張して、定数ラベルにより記述されるエントリ・ポイントにおいてのみ、というよりもむしろ、レジスタの中身により記述されるエントリ・ポイントにおいて、実行が続行できるようにしよう。
これらの新たな構成を用いると、<tt>continue</tt> レジスタに記憶されている場所への分岐をともなう形で <tt>gcd</tt> サブルーチンを終わらせることができる。
これは、図<a href="#%_fig_5.10">5.10</a>に示すコントローラ列、という結果になる。
</p>

<p class="orig" lang="en">
A machine with more than one subroutine could use multiple
continuation registers (e.g., <tt>gcd-continue</tt>, <tt>factorial-continue</tt>) or we could have all subroutines share a single
<tt>continue</tt> register.  Sharing is more economical, but we must be
careful if we have a subroutine (<tt>sub1</tt>) that calls another
subroutine (<tt>sub2</tt>).  Unless <tt>sub1</tt> saves the contents of <tt>continue</tt> in some other register before setting up <tt>continue</tt> for
the call to <tt>sub2</tt>, <tt>sub1</tt> will not know where to go when it
is finished.  The mechanism developed in the next section to handle
recursion also provides a better solution to this problem of nested
subroutine calls.
</p>

<p class="trans" lang="ja">
<!-- 一つより多くの -->二つ以上のサブルーチンをともなうマシンが、複数個の継続レジスタ (たとえば、<tt>gcd-continue</tt> や <tt>factorial-continue</tt>) を使うことがあり得る。あるいは、すべてのサブルーチンに、単一の <tt>continue</tt> レジスタを共有させることもできよう。
共有は、無駄がより少ない。しかし、別のサブルーチン (<tt>sub2</tt>) を呼び出すようなサブルーチン (<tt>sub1</tt>) がある場合は、注意深くあらねばならない。
<tt>sub2</tt> への呼び出しのために <tt>continue</tt> を設定する前に、<tt>sub1</tt> が <tt>continue</tt> の中身を何らかの別のレジスタに退避するのでない限り、<tt>sub1</tt> は、自分が終了したときにどこへ行けばいいのかが分からないだろう。
再帰を扱うために次節で開発される仕組みも、入れ子になったサブルーチン呼び出しという本問題に対する、より良い解決策を提供してくれる。
</p>

<a name="%_sec_5.1.4"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_5.1.4">5.1.4  Using a Stack to Implement Recursion</a></h3>
<h3 class="trans" lang="ja">5.1.4 再帰を実装するためにスタックを使う</h3>

<p class="orig" lang="en"><a name="%_idx_5560"></a><a name="%_idx_5562"></a><a name="%_idx_5564"></a>
<a name="%_idx_5566"></a>With the ideas illustrated so far, we can implement any iterative
process by specifying a register machine that has a register
corresponding to each state variable of the process.  The machine
repeatedly executes a controller loop, changing the contents
of the registers, until some termination condition is satisfied.  At
each point in the controller sequence, the state of the machine
(representing the state of the iterative process) is completely
determined by the contents of the registers (the values of the state
variables).</p>

<p class="trans" lang="ja">
ここまで説明してきた考え方を用いると、私たちは、プロセスの各状態変数に対応するレジスタを有するレジスタ・マシンの明細を規定することにより、どのような反復的プロセスも実装できる。
何らかの終了条件が満たされるまで、マシンは、レジスタの中身を変更しながら、繰り返しコントローラ・ループを実行する。
コントローラ列における各ポイントにおいて、マシンの状態 (反復的プロセスの状態を表す) は、完全に、レジスタの中身 (状態変数の値) によって定まる。
</p>

<p class="orig" lang="en">
<a name="%_idx_5568"></a><a name="%_idx_5570"></a><a name="%_idx_5572"></a>Implementing recursive processes, however, requires an additional
mechanism.  Consider the following recursive method for computing
factorials, which we first examined in
section <a href="11_sec1_2.html#%_sec_1.2.1">1.2.1</a>:</p>

<p class="trans" lang="ja">
しかし、再帰的プロセスを実装することは、付加的な仕組みを要する。
階乗を計算するための、以下の再帰的方法——<a href="11_sec1_2.html#%_sec_1.2.1">1.2.1</a>節で最初に吟味したもの——を考えよう。
</p>

<p class="lisp">(define (factorial n)
  (if (= n 1)
      1
      (* (factorial (- n 1)) n)))
</p>

<p class="orig" lang="en">As we see from the procedure, computing <em>n</em>! requires computing
(<em>n</em> - 1)!.  Our GCD machine, modeled on the procedure</p>

<p class="trans" lang="ja">
手続きから見てとれるように、<em class="en">n</em>! を計算することは、
<span class="math">(<em class="en">n</em> &minus; 1)!</span> を計算することを要する。
私たちの GCD マシン——以下の手続きについてモデル化されるもの——は、
</p>

<p class="lisp">(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
</p>

<p class="orig" lang="en">similarly had to compute another GCD.  But there is an important
difference between the <tt>gcd</tt> procedure, which reduces the original
computation to a new GCD computation, and <tt>factorial</tt>, which
requires computing another factorial as a subproblem.  In GCD, the
answer to the new GCD computation is the answer to the original
problem.  To compute the next GCD, we simply place the new arguments
in the input registers of the GCD machine and reuse the
machine's data paths by executing the same controller sequence.  When
the machine is finished solving the final GCD problem, it has
completed the entire computation.</p>

<p class="trans" lang="ja">
同様に、別の GCD を計算せねばならなかった。
しかし、<tt>gcd</tt> 手続き——元の計算を新たな GCD 計算へと帰着させる——と、<tt>factorial</tt> ——別の階乗を副問題として計算することを要する——との間には、重大な違いがある。
GCD では、新たな GCD 計算に対する答えは、元の問題に対する答えである。
次の GCD を計算するためには、単に、GCD マシンの入力レジスタに新たな引数を置いて、同じコントローラ列を実行することによってマシンのデータ経路を再利用するだけである。
マシンが最終的な GCD 問題を解き終えたとき、マシンは、全体の計算を完了したところである。
</p>

<p class="orig" lang="en">
In the case of factorial (or any recursive process) the answer to the
new factorial subproblem is not the answer to the original problem.
The value obtained for (<em>n</em> - 1)! must be multiplied by <em>n</em> to get the
final answer.  If we try to imitate the GCD design, and solve
the factorial subproblem by decrementing the <tt>n</tt> register and
rerunning the factorial machine, we will no longer have available the
old value of <tt>n</tt> by which to multiply the result.  We thus need a
second factorial machine to work on the subproblem.  This second
factorial computation itself has a factorial subproblem, which
requires a third factorial machine, and so on.  Since each factorial
machine contains another factorial machine within it, the total
machine contains an infinite nest of similar machines and hence cannot
be constructed from a fixed, finite number of parts.</p>

<p class="trans" lang="ja">
階乗 (または、任意の再帰的プロセス) の場合、新たな階乗副問題に対する答えは、元の問題に対する答えではない。
最終的な答えを得るためには、
<span class="math">(<em class="en">n</em> &minus; 1)!</span> 
に対して得られた値が、<em class="en">n</em> と掛け合わせられなくてはならない。
もし、GCD の設計を模倣しよう、そして、<tt>n</tt> レジスタをデクリメントして階乗マシンを再度動作させることで階乗の副問題を解決しよう、と試みたなら、結果に掛けるべき、<tt>n</tt> の古い値を、もはや利用可能に保っておけはしないだろう。
よって、副問題について動作する第二の階乗マシンが必要である。
この第二の階乗計算自体にも階乗副問題があり、それが第三の階乗マシンを必要とし、以下同様である。
各階乗マシンが自身の内部に別の階乗マシンを含むため、全体のマシンは、類似のマシンの無限の入れ子を含み、したがって、固定の有限な個数の部品から構築することができない。
</p>

<p class="orig" lang="en">
Nevertheless, we can implement the factorial process as a register
machine if we can arrange to use the same components for each nested
instance of the machine.  Specifically, the machine that computes <em>n</em>!
should use the same components to work on the subproblem of computing
(<em>n</em> - 1)!, on the subproblem for (<em>n</em> - 2)!, and so on.  This is
plausible because, although the factorial process dictates that an
unbounded number of copies of the same machine are needed to perform a
computation, only one of these copies needs to be active at any given
time.  When the machine encounters a recursive subproblem, it can
suspend work on the main problem, reuse the same physical parts to
work on the subproblem, then continue the suspended computation.</p>

<p class="trans" lang="ja">
それにもかかわらず、もし、マシンの入れ子になった各インスタンスについて同じ構成要素を使うように手筈を整えることができれば、階乗プロセスをレジスタ・マシンとして実装できるのだ。
具体的には、<em class="en">n</em>! を計算するマシンは、同じ構成要素を使って、
<span class="math">(<em class="en">n</em> &minus; 1)!</span> 
を計算するという副問題や、
<span class="math">(<em class="en">n</em> &minus; 2)!</span> 
についての副問題などに対して、動作すべきである。
これは、もっともらしい。というのも、階乗プロセスは、計算を実行するには同じマシンの無制限の個数の複製が必要だと指示しているわけだが、どの特定の時点においても、これらの複製のうちのたった一つしか、<ruby><rb>作動中</rb><rp> (</rp><rt>アクティブ</rt><rp>) </rp></ruby>である必要はないからである。
マシンが再帰的な副問題に遭遇したら、マシンは、主問題についての作業を中断し、同じ物理的部品を再利用して副問題について動作し、その後、中断した計算を続ける、ということが可能なのだ。
</p>

<p class="orig" lang="en">
In the subproblem, the contents of the registers will be different
than they were in the main problem. (In this case the <tt>n</tt> register
is decremented.)  In order to be able to continue the suspended
computation, the machine must save the contents of any registers that
will be needed after the subproblem is solved so that these can be
restored to continue the suspended computation.  In the case of
factorial, we will save the old value of <tt>n</tt>, to be restored when
we are finished computing the factorial of the decremented <tt>n</tt>
register.<a name="call_footnote_Temp_717" href="#footnote_Temp_717"><sup><small>2</small></sup></a></p>

<p class="trans" lang="ja">
副問題では、レジスタの中身が、主問題のときのものとは異なるだろう 
(この場合だと、<tt>n</tt> レジスタがデクリメントされる)。
中断した計算を継続することができるようにするためには、マシンは、副問題が解かれた後に必要になるであろう任意のレジスタの中身を、中断した計算を継続するためにその中身を復元できるように、退避しなくてはならない。
階乗の場合には、デクリメントした <tt>n</tt> レジスタの階乗を計算し終えたときに復元されるべき、<tt>n</tt> の古い値を、退避しよう<a href="#footnote_Temp_717"><sup><small>2</small></sup></a>。
</p>

<p class="orig" lang="en">
Since there is no <em>a priori</em> limit on the depth of nested
recursive calls, we may need to save an arbitrary number of register
values.  These values must be restored in the reverse of the order in
which they were saved, since in a nest of recursions the last
subproblem to be entered is the first to be finished.  This dictates
the use of a <em>stack</em>, or ``last in, first out'' data structure, to
save register values.  We can extend the register-machine language to
include a stack by adding two kinds of instructions: Values are placed
<a name="%_idx_5574"></a><a name="%_idx_5576"></a><a name="%_idx_5578"></a><a name="%_idx_5580"></a>on the stack using a <tt>save</tt> instruction and restored from the
stack using a <tt>restore</tt> instruction.  After a sequence of values
has been <tt>save</tt>d on the stack, a sequence of <tt>restore</tt>s will
retrieve these values in reverse order.<a name="call_footnote_Temp_718" href="#footnote_Temp_718"><sup><small>3</small></sup></a></p>

<p class="trans" lang="ja">
入れ子になった再帰呼び出しの深さに対する、<em><ruby><rb>先験的</rb><rp> (</rp><rt>アプリオリ</rt><rp>) </rp></ruby></em>な制限は存在しないので、私たちは、任意の個数のレジスタ値を退避する必要があるかもしれない。
これらの値は、これらの値が退避された順序の逆順で、復元されねばならない。なぜなら、再帰の入れ子では、入れられるべき最後の副問題は、終了すべき最初のものであるからだ。
このことが、レジスタ値を退避するために、<em>スタック</em>——つまり、「後入れ先出し」のデータ構造——の使用を押し付けてくる。
二種類の命令を追加することによって、スタックを含むようにレジスタ・マシン言語を拡張できる。
値は、<tt>save</tt> 命令を用いてスタック上に置かれ、<tt>restore</tt> 命令を用いてスタックから復元される。
一連の値がスタック上に <tt>save</tt> された後、一連の <tt>restore</tt> が、これらの値を逆順で取り出すだろう<a href="#footnote_Temp_718"><sup><small>3</small></sup></a>。
</p>

<p class="orig" lang="en">
With the aid of the stack, we can reuse a single copy of the factorial
machine's data paths for each factorial subproblem.  There is a
similar design issue in reusing the controller sequence that operates
the data paths.  To reexecute the factorial computation, the
controller cannot simply loop back to the beginning, as with
an iterative process, because after solving the (<em>n</em> - 1)! subproblem
the machine must still multiply the result by <em>n</em>.  The controller
must suspend its computation of <em>n</em>!, solve the (<em>n</em> - 1)! subproblem,
then continue its computation of <em>n</em>!.  This view of the factorial
computation suggests the use of the subroutine mechanism described in
section <a href="#%_sec_5.1.3">5.1.3</a>, which has the controller use a
<a name="%_idx_5582"></a><tt>continue</tt> register to transfer to the part of the sequence that
solves a subproblem and then continue where it left off on the main
problem.  We can thus make a factorial subroutine that returns to the
entry point stored in the <tt>continue</tt> register.  Around each subroutine
call, we save and restore <tt>continue</tt> just as we do the <tt>n</tt>
register, since each ``level'' of the factorial computation will use
the same <tt>continue</tt> register.  That is, the factorial subroutine
must put a new value in <tt>continue</tt> when it calls itself for a
subproblem, but it will need the old value in order to return to the
place that called it to solve a subproblem.</p>

<p class="trans" lang="ja">
スタックの助けを借りると、それぞれの階乗副問題に対して、階乗マシンのデータ経路ひとつを使い回すことが可能だ。
データ経路を操作するコントローラ列を再利用する際における、同様の設計の問題もある。
階乗計算を再実行するには、コントローラは、反復的プロセスの場合のように単純にループして最初に戻ることはできない。なぜなら、
<span class="math">(<em class="en">n</em> &minus; 1)!</span>
の副問題を解いた後、マシンは、依然として、その結果に <em class="en">n</em> を掛けなくてはならないからだ。
コントローラは、自分の <em class="en">n</em>! の計算を中断し、
<span class="math">(<em class="en">n</em> &minus; 1)!</span>
の副問題を解き、それから、自分の <em class="en">n</em>! の計算を続行しなくてはならない。
階乗計算のこの見方は、<a href="#%_sec_5.1.3">5.1.3</a>節で説明するサブルーチンの仕組み——列のうちの副問題を解く部分へと移り、それから、主問題について中断したところを続けるために、コントローラに <tt>continue</tt> レジスタを使わせる——を使うことを、示唆する。
私たちは、このようにして、<tt>continue</tt> レジスタに記憶されたエントリ・ポイントへと戻る階乗サブルーチンを作ることができるのだ。
階乗計算の各「レベル」は同じ <tt>continue</tt> レジスタを使うだろうから、各サブルーチン呼び出しをめぐっては、<tt>n</tt> レジスタを退避・復元するのとまさしく同様に <tt>continue</tt> を退避・復元する。
つまり、階乗サブルーチンは、副問題のために自分自身を呼び出すときに、新たな値を <tt>continue</tt> に入れなくてはならないのだが、副問題を解くために自分を呼んだ場所へと戻るためには、古い値を必要とするだろう。
</p>

<p class="orig" lang="en">
Figure <a href="#%_fig_5.11">5.11</a> shows the data paths and controller for
a machine that implements the recursive <tt>factorial</tt> procedure.
The machine has a stack and three registers, called <tt>n</tt>, <tt>val</tt>, and <tt>continue</tt>.  To simplify the data-path diagram, we have
not named the register-assignment buttons, only the stack-operation
buttons (<tt>sc</tt> and <tt>sn</tt> to save registers, <tt>rc</tt> and <tt>rn</tt> to restore registers).  To operate the machine, we put in register
<tt>n</tt> the number whose factorial we wish to compute and start the
machine.  When the machine reaches <tt>fact-done</tt>, the computation is
finished and the answer will be found in the <tt>val</tt> register.  In
the controller sequence, <tt>n</tt> and <tt>continue</tt> are saved before
each recursive call and restored upon return from the call.  Returning
from a call is accomplished by branching to the location stored in
<tt>continue</tt>.  <tt>Continue</tt> is initialized when the machine starts
so that the last return will go to <tt>fact-done</tt>.  The <tt>val</tt>
register, which holds the result of the factorial computation, is not
saved before the recursive call, because the old contents of <tt>val</tt>
is not useful after the subroutine returns.  Only the new value, which
is the value produced by the subcomputation, is needed.

Although in principle the factorial computation requires an infinite
machine, the machine in figure <a href="#%_fig_5.11">5.11</a> is actually
finite except for the stack, which is potentially unbounded.  Any
particular physical implementation of a stack, however, will be of
finite size, and this will limit the depth of recursive calls that can
be handled by the machine.  This implementation of factorial
illustrates the general strategy for realizing recursive algorithms as
ordinary register machines augmented by stacks.  When a recursive
subproblem is encountered, we save on the stack the registers whose
current values will be required after the subproblem is solved, solve
the recursive subproblem, then restore the saved registers and
continue execution on the main problem.  The <tt>continue</tt> register
must always be saved.  Whether there are other registers that need to
be saved depends on the particular machine, since not all recursive
computations need the original values of registers that are modified
during solution of the subproblem (see exercise <a href="#%_thm_5.4">5.4</a>).</p>

<p class="trans" lang="ja">
図<a href="#%_fig_5.11">5.11</a>は、再帰的な <tt>factorial</tt> 手続きを実装するマシンについてのデータ経路とコントローラを示している。
このマシンには、スタックと、三つのレジスタ—— <tt>n</tt> と <tt>val</tt> と <tt>continue</tt> と呼ばれる——がある。
データ経路図を簡略化するために、レジスタ割り当てのボタンには名前をつけず、ただスタック操作ボタンにだけ名前をつけた (レジスタを退避するための <tt>sc</tt> と <tt>sn</tt>、レジスタを復元するための <tt>rc</tt> と <tt>rn</tt>)。
マシンを動作させるには、階乗を計算したい数を <tt>n</tt> というレジスタに入れ、そして、マシンを始動させる。
マシンが <tt>fact-done</tt> に到達したら、計算は完了し、<tt>val</tt> レジスタの中に答えが見出されることだろう。
コントローラ列においては、<tt>n</tt> と <tt>continue</tt> は、それぞれの再帰呼び出しの前に退避され、その呼び出しからの戻りの際に復元される。
呼び出しから戻ることは、<tt>continue</tt> に記憶されている場所へと分岐することによって、達成される。
マシンが始動するときに、<tt>continue</tt> は、直近の戻りが <tt>fact-done</tt> へ行くように初期化される。
<tt>val</tt> レジスタは、階乗計算の結果を保持するものなのだが、これは再帰呼び出しの前には退避されない。なぜなら、<tt>val</tt> の古い中身は、サブルーチンが戻った後には有用ではないからだ。
新しい値——副計算により生み出された値——のみが、必要とされる。

階乗計算が原理的には無限のマシンを必要とするとはいえ、図<a href="#%_fig_5.11">5.11</a>のマシンは、実際のところ、スタック——潜在的には無制限である——を除いて有限である。
しかし、スタックのいかなる特定の物理的実装も、有限の大きさのものとなるだろうし、このことは、そのマシンによって扱うことのできる再帰呼び出しの深さを制限するだろう。
階乗のこの実装は、スタックによって増強された通常のレジスタ・マシンとして再帰的アルゴリズムを実現するための、一般的戦略を例示している。
再帰的な副問題に遭遇すると、私たちは、副問題が解かれた後に現在の値が必要とされるであろうレジスタを、スタック上に退避し、その後、退避したレジスタを復元して主問題についての実行を続ける。
<tt>continue</tt> レジスタは常に退避されねばならない。
退避する必要のある他のレジスタがあるかどうかは、特定のマシンに依存する。なぜなら、副問題を解く間に改変されるレジスタの元の値を、すべての再帰的計算が必要とする訳ではないためである (練習問題<a href="#%_thm_5.4">5.4</a>を参照)。
</p>

<a name="%_sec_Temp_719"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_719">A double recursion</a></h4>
<h4 class="trans" lang="ja">二重再帰</h4>

<p class="orig" lang="en">
<a name="%_idx_5584"></a>Let us examine a more complex recursive process, the tree-recursive
computation of the Fibonacci numbers, which we introduced in
section <a href="11_sec1_2.html#%_sec_1.2.2">1.2.2</a>:
</p>

<p class="trans" lang="ja">
より複雑な再帰的プロセス、すなわち、フィボナッチ数の木構造再帰計算——<a href="11_sec1_2.html#%_sec_1.2.2">1.2.2</a>節で導入したもの——を吟味しよう。
</p>

<p class="lisp">(define (fib n)
  (if (&lt; n 2)
      n
      (+ (fib (- n 1)) (fib (- n 2)))))
</p>

<p class="orig" lang="en">Just as with factorial, we can implement the recursive Fibonacci
computation as a register machine with registers <tt>n</tt>, <tt>val</tt>,
and <tt>continue</tt>.  The machine is more complex than the one for
factorial, because there are two places in the controller sequence
where we need to perform recursive calls -- once to compute Fib(<em>n</em> - 1)
and once to compute Fib(<em>n</em> - 2).  To set up for each of these calls, we
save the registers whose values will be needed later, set the <tt>n</tt>
register to the number whose Fib we need to compute recursively (<em>n</em> - 1
or <em>n</em> - 2), and assign to <tt>continue</tt> the entry point in the main sequence
to which to return (<tt>afterfib-n-1</tt> or <tt>afterfib-n-2</tt>,
respectively).  We then go to <tt>fib-loop</tt>.  When we return from the
recursive call, the answer is in <tt>val</tt>.
Figure <a href="#%_fig_5.12">5.12</a> shows the controller sequence for this
machine.</p>

<p class="trans" lang="ja">
階乗とちょうど同じように、再帰的フィボナッチ計算を、<tt>n</tt> と <tt>val</tt> と <tt>continue</tt> というレジスタを有するレジスタ・マシンとして、実装できる。
そのマシンは、階乗用のものよりも複雑だ。なぜなら、コントローラ列には、再帰呼び出しを実行する必要のある場所が二箇所あるためだ—— 一度は、
<span class="math">Fib(<em class="en">n</em> &minus; 1)</span>
を計算するため、一度は、
<span class="math">Fib(<em class="en">n</em> &minus; 2)</span>
を計算するためのものである。
これらの呼び出しのそれぞれについて準備するために、後で値が必要となるであろうレジスタを退避し、<tt>n</tt> レジスタを、Fib を再帰的に計算する必要のある数 
(<span class="math"><em class="en">n</em> &minus; 1</span>
または
<span class="math"><em class="en">n</em> &minus; 2</span>) に設定し、
主たる列における、戻るべきエントリ・ポイント (それぞれ、<tt>afterfib-n-1</tt> または <tt>afterfib-n-2</tt>) を、<tt>continue</tt> に割り当てる。
それから、<tt>fib-loop</tt> へ行く。
再帰呼び出しから戻ってきたら、答えが <tt>val</tt> の中にある。
図<a href="#%_fig_5.12">5.12</a>は、このマシンについてのコントローラ列を示している。
</p>

<figure>
<a name="%_fig_5.11"></a>
<img src="ch5-Z-G-6.gif" border="0">
<p class="infig-lisp">(controller
   (assign continue (label fact-done))     <em>; set up final return address</em>
                                           <em>; (最終的な戻りアドレスを設定する)</em>
 fact-loop
   (test (op =) (reg n) (const 1))
   (branch (label base-case))
   <em>;; Set up for the recursive call by saving <tt>n</tt> and <tt>continue</tt>.</em>
   <em>;; (<tt>n</tt> と <tt>continue</tt> を退避することにより、再帰呼び出しについて準備する)</em>
   <em>;; Set up <tt>continue</tt> so that the computation will continue</em>
   <em>;; at <tt>after-fact</tt> when the subroutine returns.</em>
   <em>;; (サブルーチンが戻ってきたときに、計算が <tt>after-fact</tt> において</em>
   <em>;;  続行するように、<tt>continue</tt> を設定する)</em>
   (save continue)
   (save n)
   (assign n (op -) (reg n) (const 1))
   (assign continue (label after-fact))
   (goto (label fact-loop))
 after-fact
   (restore n)
   (restore continue)
   (assign val (op *) (reg n) (reg val))   <em>; <tt>val</tt> now contains</em> <em>n</em>(<em>n</em> - 1)!
                                           <em>; (<tt>val</tt> にはここで n(n - 1)! が入っている)</em>
   (goto (reg continue))                   <em>; return to caller</em>
                                           <em>; (呼び出し側へ戻る)</em>
 base-case
   (assign val (const 1))                  <em>; base case: </em>1! = 1
                                           <em>; (基礎となる場合: 1! = 1)</em>
   (goto (reg continue))                   <em>; return to caller</em>
                                           <em>; (呼び出し側へ戻る)</em>
 fact-done)
</p>

<figcaption class="orig" lang="en"><b>Figure 5.11:</b>  A recursive factorial machine.</figcaption>
<figcaption class="trans" lang="ja"><b>図5.11.:</b> 再帰的階乗マシン</figcaption>
<a name="%_idx_5586"></a>
</figure>

<figure>
<a name="%_fig_5.12"></a>
<p class="infig-lisp">(controller
   (assign continue (label fib-done))
 fib-loop
   (test (op &lt;) (reg n) (const 2))
   (branch (label immediate-answer))
   <em>;; set up to compute <em>F</em><em>i</em><em>b</em>(<em>n</em> - 1)</em>
   <em>;; (Fib(n - 1) を計算するために設定する)</em>
   (save continue)
   (assign continue (label afterfib-n-1))
   (save n)                           <em>; save old value of <tt>n</tt></em>
                                      <em>; (<tt>n</tt> の古い値を退避する)</em>
   (assign n (op -) (reg n) (const 1))<em>; clobber <tt>n</tt> to <em>n</em> - 1</em>
                                      <em>; (<tt>n</tt> を叩いて n - 1 にする)</em>
   (goto (label fib-loop))            <em>; perform recursive call</em>
                                      <em>; (再帰呼び出しを実行する)</em>
 afterfib-n-1                         <em>; upon return, <tt>val</tt> contains <em>F</em><em>i</em><em>b</em>(<em>n</em> - 1)</em>
                                      <em>; (戻ったとき、<tt>val</tt> には Fib(n - 1) が入っている)</em>
   (restore n)
   (restore continue)
   <em>;; set up to compute <em>F</em><em>i</em><em>b</em>(<em>n</em> - 2)</em>
   <em>;; (Fib(n - 2) を計算するために設定する)</em>
   (assign n (op -) (reg n) (const 2))
   (save continue)
   (assign continue (label afterfib-n-2))
   (save val)                         <em>; save <em>F</em><em>i</em><em>b</em>(<em>n</em> - 1)</em>
                                      <em>; (Fib(n - 1) を退避する)</em>
   (goto (label fib-loop))
 afterfib-n-2                         <em>; upon return, <tt>val</tt> contains <em>F</em><em>i</em><em>b</em>(<em>n</em> - 2)</em>
                                      <em>; (戻ったとき、<tt>val</tt> には Fib(n - 2) が入っている)</em>
   (assign n (reg val))               <em>; <tt>n</tt> now contains <em>F</em><em>i</em><em>b</em>(<em>n</em> - 2)</em>
                                      <em>; (<tt>n</tt> にはここで Fib(n - 2) が入っている)</em>
   (restore val)                      <em>; <tt>val</tt> now contains <em>F</em><em>i</em><em>b</em>(<em>n</em> - 1)</em>
                                      <em>; (<tt>val</tt> にはここで Fib(n - 1) が入っている)</em>
   (restore continue)
   (assign val                        <em>;  <em>F</em><em>i</em><em>b</em>(<em>n</em> - 1) +  <em>F</em><em>i</em><em>b</em>(<em>n</em> - 2)</em>
           (op +) (reg val) (reg n)) 
   (goto (reg continue))              <em>; return to caller, answer is in <tt>val</tt></em>
                                      <em>; (呼び出し側に戻る。答えは <tt>val</tt> にある)</em>
 immediate-answer
   (assign val (reg n))               <em>; base case:  <em>F</em><em>i</em><em>b</em>(<em>n</em>) = <em>n</em></em>
                                      <em>; (基礎となる場合: Fib(n) = n)</em>
   (goto (reg continue))
 fib-done)
</p>

<figcaption class="orig" lang="en"><b>Figure 5.12:</b>  Controller for a machine to compute Fibonacci
numbers.</figcaption>
<figcaption class="trans" lang="ja"><b>図5.12.:</b> フィボナッチ数を計算するマシンについてのコントローラ</figcaption>
<a name="%_idx_5588"></a>
</figure>


<p class="orig" lang="en">
<a name="%_thm_5.4"></a>
<b>Exercise 5.4.</b>  Specify register machines that implement each of the following
procedures.  For each machine, write a controller instruction sequence
and draw a diagram showing the data paths.</p>

<p class="trans" lang="ja">
<b>練習問題5.4.</b> 以下の手続きのそれぞれを実装するレジスタ・マシンの明細を規定せよ。
それぞれのマシンについて、コントローラ命令列を書き、データ経路を示す図を描け。
</p>

<ol class="orig alph" start="1" lang="en">
<li>Recursive exponentiation:</li>
</ol>

<ol class="trans alph" start="1" lang="ja">
<li>再帰的な指数関数</li>
</ol>

<p class="lisp"><a name="%_idx_5590"></a>(define (expt b n)
  (if (= n 0)
      1
      (* b (expt b (- n 1)))))
</p>

<ol class="orig alph" start="2" lang="en">
<li>Iterative exponentiation:</li>
</ol>

<ol class="trans alph" start="2" lang="ja">
<li>反復的な指数関数</li>
</ol>

<p class="lisp">(define (expt b n)
  (define (expt-iter counter product)
    (if (= counter 0)
        product
        (expt-iter (- counter 1) (* b product))))
  (expt-iter n 1))
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.5"></a>
<b>Exercise 5.5.</b>  Hand-simulate the factorial and Fibonacci machines, using some
nontrivial input (requiring execution of at least one recursive call).
Show the contents of the stack at each significant point in the
execution.
</p>

<p class="trans" lang="ja">
<b>練習問題5.5.</b> (少なくとも一回の再帰呼び出しの実行を必要とする) 何らかの非自明な入力を用いて、階乗マシンとフィボナッチ・マシンを手作業でシミュレートせよ。
実行中の重要なそれぞれの時点におけるスタックの中身を示せ。
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.6"></a>
<b>Exercise 5.6.</b>  Ben Bitdiddle observes that the Fibonacci machine's controller sequence
has an extra <tt>save</tt> and an extra <tt>restore</tt>, which can be
removed to make a faster machine.  Where are these instructions?
</p>

<p class="trans" lang="ja">
<b>練習問題5.6.</b> フィボナッチ・マシンのコントローラ列に、余計な <tt>save</tt> と余計な <tt>restore</tt> ——より高速なマシンを作るために取り除くことが可能である——があることに、ベン・ビットディドルは気づく。
これらの命令は、どこにあるのだろう?
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_5.1.5"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_5.1.5">5.1.5  Instruction Summary</a></h3>
<h3 class="trans" lang="ja">5.1.5 命令のまとめ</h3>


<p class="orig" lang="en"><a name="%_idx_5592"></a>
<a name="%_idx_5594"></a><a name="%_idx_5596"></a>A controller instruction in our register-machine language
has one of the following forms, where each
&lt;<em>input<sub><em>i</em></sub></em>&gt; is either <tt>(reg &lt;<em>register-name</em>&gt;)</tt>
or <tt>(const &lt;<em>constant-value</em>&gt;)</tt>.
</p>

<p class="trans" lang="ja">
私たちのレジスタ・マシン言語におけるコントローラ命令は、以下の形のうちの一つの形をしていて、ここで、
&lt;<em class="en">input<sub><em class="en">i</em></sub></em>&gt; は、
<tt>(reg &lt;<em class="en">register-name</em>&gt;)</tt> または
<tt>(const &lt;<em class="en">constant-value</em>&gt;)</tt> のいずれかである。
</p>

<p class="orig" lang="en">
These instructions were introduced in
section <a href="#%_sec_5.1.1">5.1.1</a>:
</p>

<p class="trans" lang="ja">
これらの命令は、<a href="#%_sec_5.1.1">5.1.1</a>節で導入された。
</p>

<p class="lisp"><a name="%_idx_5598"></a>(assign &lt;<em>register-name</em>&gt; (reg &lt;<em>register-name</em>&gt;))

(assign &lt;<em>register-name</em>&gt; (const &lt;<em>constant-value</em>&gt;))

<a name="%_idx_5600"></a>(assign &lt;<em>register-name</em>&gt; (op &lt;<em>operation-name</em>&gt;) &lt;<em>input<sub>1</sub></em>&gt; <tt>...</tt> &lt;<em>input<sub><em>n</em></sub></em>&gt;)

<a name="%_idx_5602"></a>(perform (op &lt;<em>operation-name</em>&gt;) &lt;<em>input<sub>1</sub></em>&gt; <tt>...</tt> &lt;<em>input<sub><em>n</em></sub></em>&gt;)

<a name="%_idx_5604"></a>(test (op &lt;<em>operation-name</em>&gt;) &lt;<em>input<sub>1</sub></em>&gt; <tt>...</tt> &lt;<em>input<sub><em>n</em></sub></em>&gt;)

<a name="%_idx_5606"></a><a name="%_idx_5608"></a>(branch (label &lt;<em>label-name</em>&gt;))

<a name="%_idx_5610"></a>(goto (label &lt;<em>label-name</em>&gt;))
</p>

<p class="orig" lang="en">
The use of registers to hold labels was introduced in
section <a href="#%_sec_5.1.3">5.1.3</a>:
</p>

<p class="trans" lang="ja">
ラベルを保持するためのレジスタの使用は、<a href="#%_sec_5.1.3">5.1.3</a>節で導入された。
</p>

<p class="lisp">(assign &lt;<em>register-name</em>&gt; (label &lt;<em>label-name</em>&gt;))

(goto (reg &lt;<em>register-name</em>&gt;))
</p>

<p class="orig" lang="en">
Instructions to use the stack were introduced in
section <a href="#%_sec_5.1.4">5.1.4</a>:
</p>

<p class="trans" lang="ja">
スタックを使うための命令は、<a href="#%_sec_5.1.4">5.1.4</a>節で導入された。
</p>

<p class="lisp"><a name="%_idx_5612"></a>(save &lt;<em>register-name</em>&gt;)

<a name="%_idx_5614"></a>(restore &lt;<em>register-name</em>&gt;)
</p>

<p class="orig" lang="en">
<a name="%_idx_5616"></a><a name="%_idx_5618"></a><a name="%_idx_5620"></a>The only kind of &lt;<em>constant-value</em>&gt; we have seen so far is a number,
but later we will use strings, symbols, and lists.
For example,
<tt>(const &quot;abc&quot;)</tt> is the string <tt>&quot;abc&quot;</tt>,
<tt>(const abc)</tt> is the symbol <tt>abc</tt>,
<tt>(const (a b c))</tt> is the list <tt>(a b c)</tt>,
and <tt>(const ())</tt> is the empty list.
</p>

<p class="trans" lang="ja">
ここまで見てきた &lt;<em class="en">constant-value</em>&gt; の唯一の種類は数であるが、今後は、文字列や、<ruby><rb>記号</rb><rp> (</rp><rt>シンボル</rt><rp>) </rp></ruby>や、リストを使うだろう。
たとえば、
<tt>(const &quot;abc&quot;)</tt> は <tt>&quot;abc&quot;</tt> という文字列であり、
<tt>(const abc)</tt> は <tt>abc</tt> という記号であり、
<tt>(const (a b c))</tt> は <tt>(a b c)</tt> というリストであり、
<tt>(const ())</tt> は空リストである。
</p>

<a name="footnotes"></a>
<hr>

<p class="orig" lang="en"><a name="footnote_Temp_715" href="#call_footnote_Temp_715"><sup><small>1</small></sup></a> This assumption
glosses over a great deal of complexity.  Usually a large portion of
the implementation of a Lisp system is dedicated to making reading
and printing work.</p>

<p class="trans" lang="ja"><a href="#call_footnote_Temp_715"><sup><small>1</small></sup></a>
この仮定は、大量の複雑性をごまかしている。
普通、Lisp システムの実装の大部分は、読み込みと印字の作業に捧げられる。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_717" href="#call_footnote_Temp_717"><sup><small>2</small></sup></a> One might argue that we don't need to save the old
<tt>n</tt>; after we decrement it and solve the subproblem, we could
simply increment it to recover the old value.  Although this strategy
works for factorial, it cannot work in general, since the old value of
a register cannot always be computed from the new one.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_717"><sup><small>2</small></sup></a>
古い <tt>n</tt> を退避する必要はない、と主張する人がいるかもしれない。
これをデクリメントして副問題を解いた後に、単純にこれをインクリメントして古い値を回復できるだろう、と。
この戦略は、階乗についてはうまく機能するのだが、一般にはうまく機能し得ない。なぜなら、レジスタの古い値は、常に新しい値から計算できるわけではないからだ。
</p>


<p class="orig" lang="en"><a name="footnote_Temp_718" href="#call_footnote_Temp_718"><sup><small>3</small></sup></a> In
section <a href="33_sec5_3.html#%_sec_5.3">5.3</a> we will see how to implement a
stack in terms of more primitive operations.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_718"><sup><small>3</small></sup></a>
より原始的な演算を用いてスタックを実装する方法を、<a href="33_sec5_3.html#%_sec_5.3">5.3</a>節で見よう。
</p>


</div>
</body>
</html>
