<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<link rel="stylesheet" href="sicp.css" type="text/css">
	<base target="_top">
	<title>SICPç§è¨³: ç¬¬1ç« ã€€æ‰‹ç¶šãã‚’ä½¿ã£ã¦æŠ½è±¡æ¦‚å¿µã‚’çµ„ã¿ç«‹ã¦ã‚‹</title>
    <link rel="canonical" href="https://piyo-ko.github.io/SICP/09_chap1.html" />
</head>

<body>

<div class="idx-bar">
<nav>
<a href="https://twitter.com/share" class="twitter-share-button" data-lang="ja">ãƒ„ã‚¤ãƒ¼ãƒˆ</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
<span class="status">æ¨æ•²æ¸ˆã¿</span>
[
<a href="00_cover.html">å…ˆé ­ã¸</a> |
<a href="08_ack.html">å‰ã¸</a> |
<a href="10_sec1_1.html">æ¬¡ã¸</a> | 
<a href="04_toc.html#%_toc_start">ç›®æ¬¡</a> |
<a href="38_index.html#%_index_start">ç´¢å¼•</a>
] [<a href="99_about.html">ã“ã®å¯¾è¨³ç‰ˆã«ã¤ã„ã¦</a> | <a href="../index.html">ãƒ›ãƒ¼ãƒ </a>]
[
Â§<a href="#%_chap_1">1</a>
ğŸ“š<a href="#%_sec_Temp_6">â€¦</a>
<a href="#footnotes">è„šæ³¨</a>
]
</nav>
</div>

<div class="main-txt">
<h1 class="orig" lang="en" id="%_chap_1"><a href="04_toc.html#%_toc_%_chap_1">Chapter 1<br>
Building Abstractions with Procedures</a></h1>
<h1 class="trans" lang="ja">ç¬¬1ç« ã€€æ‰‹ç¶šãã‚’ä½¿ã£ã¦<!--æŠ½è±¡ç‰©ã‚’æ§‹ç¯‰ã™ã‚‹-->æŠ½è±¡æ¦‚å¿µã‚’çµ„ã¿ç«‹ã¦ã‚‹
</h1>

<blockquote class="orig" lang="en">
The acts of the mind, wherein it exerts its power over simple ideas,
are chiefly these three: 1. Combining several simple ideas into one
compound one, and thus all complex ideas are made.  2. The second is
bringing two ideas, whether simple or complex, together, and setting
them by one another so as to take a view of them at once, without
uniting them into one, by which it gets all its ideas of relations.
3.  The third is separating them from all other ideas that accompany
them in their real existence: this is called abstraction, and thus all
its general ideas are made.<br>
<br>
<a name="%_idx_6"></a>John Locke, <em>An Essay Concerning Human Understanding</em>
(1690)</blockquote>

<blockquote class="trans" lang="ja">
ç²¾ç¥ã®ã¯ãŸã‚‰ãâ€”â€”ç²¾ç¥ã¯ã€å˜ç´”ãªè€ƒãˆã«å¯¾ã—ã¦åŠ›ã‚’è¡Œä½¿ã™ã‚‹â€”â€”ã¯ã€ä¸»ã«æ¬¡ã®ä¸‰ã¤ã§ã‚ã‚‹ã€‚
ç¬¬ä¸€ã«ã€ã„ãã¤ã‹ã®å˜ç´”ãª<!--è€ƒãˆ-->è¦³å¿µã‚’çµã³ã¤ã‘ã¦ã€ä¸€ã¤ã®è¤‡åˆçš„ãª<!--è€ƒãˆ-->è¦³å¿µã¨ã™ã‚‹ã“ã¨ã€‚ã“ã†ã—ã¦ã€ã™ã¹ã¦ã®è¤‡é›‘ãª<!--è€ƒãˆ-->è¦³å¿µã¯ä½œã‚‰ã‚Œã‚‹ã®ã§ã‚ã‚‹ã€‚
ç¬¬äºŒã«ã€äºŒã¤ã®<!--è€ƒãˆ-->è¦³å¿µã‚’ã€<!--ãã‚Œã‚‰ãŒ-->å˜ç´”ã§ã‚ã‚ã†ãŒè¤‡é›‘ã§ã‚ã‚ã†ãŒä¸€ç·’ã«ã¾ã¨ã‚ã¦ãŠã„ã¦ã€ãã‚Œã‚‰ã‚’ä¸€ç›®ã§è¦‹æ¸¡ã›ã‚‹ã‚ˆã†ã«ã€ãŠäº’ã„ã«åµŒã‚è¾¼ã‚€ã“ã¨â€”â€”ãŸã ã—ã€ãã‚Œã‚‰ã‚’ä¸€ã¤ã«çµ±åˆã™ã‚‹ã“ã¨ãªã—ã«ã€‚ãã†ã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€ç²¾ç¥ã¯ã€è«¸é–¢ä¿‚ã«ã¤ã„ã¦ã®ã™ã¹ã¦ã®<!--è€ƒãˆ-->è¦³å¿µã‚’å¾—ã‚‹ã®ã§ã‚ã‚‹ã€‚<!--æ„è¨³ã‹ãªã‚â€¦â€¦-->
ç¬¬ä¸‰ã«ã€ç¾å®Ÿã®å­˜åœ¨ã«ãŠã„ã¦ãã‚Œã‚‰<!--äºŒã¤-->ã®<!--è€ƒãˆ-->è¦³å¿µã«ä»˜éšã™ã‚‹ä»–ã®ã™ã¹ã¦ã®<!--è€ƒãˆ-->è¦³å¿µã‹ã‚‰ã€ãã‚Œã‚‰<!--äºŒã¤-->ã®<!--è€ƒãˆ-->è¦³å¿µã‚’åˆ†é›¢ã™ã‚‹ã“ã¨ã€‚ã“ã‚Œã¯æŠ½è±¡åŒ–ã¨å‘¼ã°ã‚Œã€ã“ã†ã—ã¦ã€ã™ã¹ã¦ã®ä¸€èˆ¬çš„ãª<!--è€ƒãˆ-->è¦³å¿µãŒã§ãã‚ãŒã‚‹ã€‚<!--itsã¯ä½•ã‚’æŒ‡ã™ã‹?--><br>
<br>
<a name="%_idx_6"></a>ã‚¸ãƒ§ãƒ³ãƒ»ãƒ­ãƒƒã‚¯ã€äººé–“çŸ¥æ€§è«–ã€ (1690)
</blockquote>

<p class="orig" lang="en">
We are about to study the idea of a <a name="%_idx_8"></a><a name="%_idx_10"></a><em>computational process</em>.
Computational processes are abstract beings that inhabit computers.
As they evolve, processes manipulate other abstract things called <a name="%_idx_12"></a><em>data</em>.  The evolution of a process is directed by a pattern of rules
called a <a name="%_idx_14"></a><em>program</em>.  People create programs to direct processes.
In effect, we conjure the spirits of the computer with our spells.</p>

<p class="trans" lang="ja">
ç§ãŸã¡ã¯<em>è¨ˆç®—ãƒ—ãƒ­ã‚»ã‚¹</em>ã¨ã„ã†è€ƒãˆã«ã¤ã„ã¦å­¦ã¼ã†ã¨ã—ã¦ã„ã‚‹ã¨ã“ã‚ã§ã‚ã‚‹ã€‚
è¨ˆç®—ãƒ—ãƒ­ã‚»ã‚¹ã¨ã¯ã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã®ä¸­ã«ã‚ã‚‹æŠ½è±¡çš„å­˜åœ¨ã§ã‚ã‚‹ã€‚
è¨ˆç®—ãƒ—ãƒ­ã‚»ã‚¹ãŒé€²ã‚€ã®ã«å¿œã˜ã¦ã€ãƒ—ãƒ­ã‚»ã‚¹ã¯ã€<em>ãƒ‡ãƒ¼ã‚¿</em>ã¨å‘¼ã°ã‚Œã‚‹åˆ¥ã®æŠ½è±¡çš„ãªç‰©ã‚’<!--æ‰±ã†-->æ“ä½œã™ã‚‹ã€‚
ãƒ—ãƒ­ã‚»ã‚¹ã®é€²å±•ã¯ã€<em>ãƒ—ãƒ­ã‚°ãƒ©ãƒ </em>ã¨å‘¼ã°ã‚Œã‚‹è«¸è¦å‰‡ã®ãƒ‘ã‚¿ãƒ³ã«ã‚ˆã‚Šã€æŒ‡å›³ã•ã‚Œã‚‹ã€‚
äººã¯ãƒ—ãƒ­ã‚»ã‚¹ã«æŒ‡å›³ã™ã‚‹ãŸã‚ã«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ä½œã‚‹ã€‚
å®Ÿéš›ã€ç§ãŸã¡ã¯ã€å‘ªæ–‡ã§ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã®ç²¾éœŠã‚’å‘¼ã³å‡ºã™ã®ã ã€‚
</p>

<p class="orig" lang="en">
A computational process is indeed much like a sorcerer's idea of a
spirit.  It cannot be seen or touched.  It is not composed of matter
at all.  However, it is very real.  It can perform intellectual work.
It can answer questions.  It can affect the world by disbursing money
at a bank or by controlling a robot arm in a factory.  The programs we
use to conjure processes are like a sorcerer's spells.  They are
carefully composed from symbolic expressions in arcane and esoteric
<a name="%_idx_16"></a><em>programming languages</em> that prescribe the tasks we want our
processes to perform.</p>

<p class="trans" lang="ja">
å®Ÿéš›ã€è¨ˆç®—ãƒ—ãƒ­ã‚»ã‚¹ã¯ã€é­”è¡“å¸«ãŒæŒã£ã¦ã„ã‚‹ã€ç²¾éœŠã¨ã„ã†è€ƒãˆã¨ã‚ˆãä¼¼ã¦ã„ã‚‹ã€‚
ãã‚Œã¯ã€è¦‹ãˆãªã„ã—ã€ã•ã‚ã‚Œãªã„ã€‚
ãã‚Œã¯ã€ã¾ã£ãŸãã€ç‰©è³ªã‹ã‚‰ä½œã‚‰ã‚Œã¦ã„ã‚‹ã®ã§ã¯ãªã„ã€‚
ã—ã‹ã—ã€ãã‚Œã¯ã€ã¨ã¦ã‚‚ç¾å®Ÿçš„ã§ã‚ã‚‹ã€‚
ãã‚Œã¯ã€çŸ¥çš„ãªä»•äº‹ã‚’é‚è¡Œã§ãã‚‹ã€‚
ãã‚Œã¯ã€è³ªå•ã«ç­”ãˆã‚‰ã‚Œã‚‹ã€‚
ãã‚Œã¯ã€éŠ€è¡Œã§ãŠé‡‘ã‚’æ”¯æ‰•ã†ã“ã¨ã«ã‚ˆã£ã¦ã€ã‚ã‚‹ã„ã¯ã€å·¥å ´ã§ãƒ­ãƒœãƒƒãƒˆã‚¢ãƒ¼ãƒ ã‚’åˆ¶å¾¡ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€ã“ã®ä¸–ç•Œã«å½±éŸ¿ã‚’ä¸ãˆã‚‰ã‚Œã‚‹ã€‚
ç§ãŸã¡ãŒãƒ—ãƒ­ã‚»ã‚¹ã‚’å‘¼ã³å‡ºã™ã®ã«ä½¿ã†ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€é­”è¡“å¸«ã®å‘ªæ–‡ã®ã‚ˆã†ãªã‚‚ã®ã§ã‚ã‚‹ã€‚
ãã‚Œã¯ã€ãƒ—ãƒ­ã‚»ã‚¹ã«å®Ÿè¡Œã•ã›ãŸã„èª²é¡Œã‚’è¦å®šã™ã‚‹ã€è¬ã‚ã„ã¦æ·±é ãª<em>ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èª</em>ã§æ›¸ã‹ã‚ŒãŸè±¡å¾´çš„è¡¨ç¾ã‹ã‚‰ã€æ³¨æ„æ·±ãåˆæˆã•ã‚Œã¦ã„ã‚‹ã€‚
</p>

<p class="orig" lang="en">
A computational process, in a correctly working computer, executes
programs precisely and accurately.  Thus, like the sorcerer's
apprentice, novice programmers must learn to understand and to
anticipate the consequences of their conjuring.  Even small errors
(usually called <a name="%_idx_18"></a><em>bugs</em> or <a name="%_idx_20"></a><em>glitches</em>) in programs can have
complex and unanticipated consequences.</p>

<p class="trans" lang="ja">
è¨ˆç®—ãƒ—ãƒ­ã‚»ã‚¹ã¯ã€æ­£ã—ãå‹•ãã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã«ãŠã„ã¦ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ç²¾å¯†ã‹ã¤æ­£ç¢ºã«å®Ÿè¡Œã™ã‚‹ã€‚
ã‚ˆã£ã¦ã€é­”è¡“å¸«ã®è¦‹ç¿’ã„ã¨åŒæ§˜ã«ã€æ–°äººãƒ—ãƒ­ã‚°ãƒ©ãƒã¯ã€è‡ªåˆ†ãŒè¡Œã†å‘¼ã³å‡ºã—ã®çµæœã‚’ç†è§£ã™ã‚‹ã¨ã¨ã‚‚ã«äºˆã‚è¦‹è¶Šã—ã¦ãŠããŸã‚ã«ã€å­¦ç¿’ã‚’è¡Œã‚ãªãã¦ã¯ãªã‚‰ãªã„ã€‚
ãƒ—ãƒ­ã‚°ãƒ©ãƒ å†…ã®å°ã•ãªé–“é•ã„ (é€šå¸¸ã€<em>ãƒã‚°</em>ã¾ãŸã¯<em>ã‚°ãƒªãƒƒãƒ</em>ã¨å‘¼ã°ã‚Œã‚‹) ã§ã•ãˆã€è¤‡é›‘ã§æ€ã„ãŒã‘ãªã„çµæœã‚’ã‚‚ãŸã‚‰ã™ã®ã ã€‚
</p>

<p class="orig" lang="en">
Fortunately, learning to program is considerably less dangerous than
learning sorcery, because the spirits we deal with are conveniently
contained in a secure way.  Real-world programming, however,
requires care, expertise, and wisdom.  A small bug in a computer-aided
design program, for example, can lead to the catastrophic collapse of
an airplane or a dam or the self-destruction of an industrial robot.</p>

<p class="trans" lang="ja">
å¹¸ã„ã«ã‚‚ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ãã“ã¨ã‚’å­¦ã¶ã“ã¨ã¯ã€é­”è¡“ã‚’å­¦ã¶ã“ã¨ã‚ˆã‚Šã‚‚ã€é¥ã‹ã«å±é™ºãŒå°‘ãªã„ã€‚ã¨ã„ã†ã®ã‚‚ã€ç§ãŸã¡ãŒæ‰±ã†ç²¾éœŠãŸã¡ã¯ã€å®‰å…¨ãªæ–¹æ³•ã§éƒ½åˆã‚ˆãå°ã˜è¾¼ã¾ã‚Œã¦ã„ã‚‹ã‹ã‚‰ã ã€‚
ã—ã‹ã—ã€å®Ÿä¸–ç•Œã®ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã«ã¯ã€ç”¨å¿ƒã¨ã€å°‚é–€çŸ¥è­˜ã¨ã€çŸ¥æµã‚’è¦ã™ã‚‹ã€‚
ãŸã¨ãˆã°ã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿æ”¯æ´è¨­è¨ˆãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ãŠã‘ã‚‹å°ã•ãªãƒã‚°ãŒã€é£›è¡Œæ©Ÿã¾ãŸã¯ãƒ€ãƒ ã®å£Šæ»…çš„å´©å£Šã€ã‚ã‚‹ã„ã¯ã€å·¥æ¥­ãƒ­ãƒœãƒƒãƒˆã®è‡ªå£Šã‚’æ‹›ãã“ã¨ãŒã‚ã‚Šå¾—ã‚‹ã€‚
</p>

<p class="orig" lang="en">
Master software engineers have the ability to organize programs so
that they can be reasonably sure that the resulting processes will
perform the tasks intended.  They can visualize the behavior of their
systems in advance.  They know how to structure programs so that
unanticipated problems do not lead to catastrophic consequences, and
when problems do arise, they can <a name="%_idx_22"></a><em>debug</em> their programs.  Well-designed
computational systems, like well-designed automobiles or nuclear
reactors, are designed in a modular manner, so that the parts can be
constructed, replaced, and debugged separately.</p>

<p class="trans" lang="ja">
<!--åäººçš„ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ãƒ»ãƒ—ãƒ­ã‚°ãƒ©ãƒã«ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ã€çµæœã¨ã—ã¦ç”Ÿã˜ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ãŒã€æ„å›³ã—ãŸèª²é¡Œã‚’ã¾ãšé–“é•ã„ãªãé‚è¡Œã™ã‚‹ã ã‚ã†ã€ã¨ç¢ºä¿¡ã§ãã‚‹ã‚ˆã†ã«ã¾ã¨ã‚ã‚ã’ã‚‹èƒ½åŠ›ãŒã‚ã‚‹ã€‚-->
ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®çµæœã¨ã—ã¦ç”Ÿã˜ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ãŒã€æ„å›³ã—ãŸèª²é¡Œã‚’é‚è¡Œã™ã‚‹ã ã‚ã†ã€ã¨ç†æ€§çš„ã«ç¢ºä¿¡ã§ãã‚‹ã‚ˆã†ã«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ã¾ã¨ã‚ã‚ã’ã‚‹èƒ½åŠ›ãŒã€åäººçš„ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢æŠ€å¸«ã«ã¯ã‚ã‚‹ã€‚
ã‹ã‚Œã‚‰ã¯ã€è‡ªåˆ†ã®ã‚·ã‚¹ãƒ†ãƒ ã®æŒ¯ã‚‹èˆã„ã‚’äºˆã‚è¦–è¦šåŒ–ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
ã‹ã‚Œã‚‰ã¯ã€æ€ã„ãŒã‘ãªã„å•é¡ŒãŒå£Šæ»…çš„ãªçµæœã‚’ã‚‚ãŸã‚‰ã•ãªã„ã‚ˆã†ã«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ§‹æˆã™ã‚‹ã«ã¯ã©ã†ã™ã‚‹ã®ã‹ã€å•é¡Œã¯ã©ã‚“ãªå ´åˆã«èµ·ãã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’çŸ¥ã£ã¦ã„ã‚‹ã—ã€ã‹ã‚Œã‚‰ã¯è‡ªåˆ†ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’<em>ãƒ‡ãƒãƒƒã‚°</em>ã§ãã‚‹ã€‚
ã†ã¾ãè¨­è¨ˆã•ã‚ŒãŸè¨ˆç®—ã‚·ã‚¹ãƒ†ãƒ ã¯ã€ã†ã¾ãè¨­è¨ˆã•ã‚ŒãŸè‡ªå‹•è»Šã‚„åŸå­ç‚‰ã¨åŒæ§˜ã«ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å¼ã«è¨­è¨ˆã•ã‚Œã¦ãŠã‚Šã€ãã®ãŸã‚ã€è«¸éƒ¨åˆ†ã‚’åˆ¥ã€…ã«æ§‹ç¯‰ãƒ»ç½®æ›ãƒ»ãƒ‡ãƒãƒƒã‚°ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
</p>


<a name="%_sec_Temp_6"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_6">Programming in Lisp</a></h4>
<h4 class="trans" lang="ja">Lispã§ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã™ã‚‹</h4>

<p class="orig" lang="en">
We need an appropriate language for describing processes, and we will
use for this purpose the programming language Lisp.  Just as our
everyday thoughts are usually expressed in our natural language (such
as English, French, or Japanese), and descriptions of quantitative
phenomena are expressed with mathematical notations, our procedural
thoughts will be expressed in Lisp.  <a name="%_idx_24"></a>Lisp was invented in the late
1950s as a formalism for reasoning about the use of certain kinds of
logical expressions, called <a name="%_idx_26"></a><em>recursion equations</em>, as a model for
computation.  The language was conceived by <a name="%_idx_28"></a>John McCarthy and is based
on his paper ``Recursive Functions of Symbolic Expressions and Their
Computation by Machine'' (McCarthy 1960).</p>

<p class="trans" lang="ja">
ç§ãŸã¡ã¯ã€ãƒ—ãƒ­ã‚»ã‚¹ã‚’è¨˜è¿°ã™ã‚‹ãŸã‚ã®é©å½“ãªè¨€èªã‚’å¿…è¦ã¨ã—ã¦ãŠã‚Šã€ã“ã®ç›®çš„ã®ãŸã‚ã«ç§ãŸã¡ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã®Lispã‚’ä½¿ãŠã†ã€‚
ç§ãŸã¡ã®æ—¥ã€…ã®è€ƒãˆãŒæ™®é€šã¯è‡ªåˆ†ã®è‡ªç„¶è¨€èª (ãŸã¨ãˆã°ã€è‹±èªã€ãƒ•ãƒ©ãƒ³ã‚¹èªã€ã‚ã‚‹ã„ã¯æ—¥æœ¬èª) ã§è¡¨ã•ã‚Œã€é‡çš„ãªç¾è±¡ãŒæ•°å­¦çš„è¡¨è¨˜æ³•ã§è¡¨ã•ã‚Œã‚‹ã®ã¨ã¡ã‚‡ã†ã©åŒã˜ã‚ˆã†ã«ã€ç§ãŸã¡ã®æ‰‹ç¶šãçš„ãªè€ƒãˆã¯ã€Lispã§è¡¨ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã ã‚ã†ã€‚
Lispã¯ã€è¨ˆç®—ã®ãƒ¢ãƒ‡ãƒ«ã¨ã—ã¦ã®ã‚ã‚‹ç¨®ã®è«–ç†å¼â€”â€”<em>å†å¸°æ–¹ç¨‹å¼</em>ã¨å‘¼ã°ã‚Œã‚‹â€”â€”ã®ä½¿ç”¨ã«ã¤ã„ã¦ã®æ¨è«–ã®ãŸã‚ã®å½¢å¼åŒ–ã¨ã—ã¦ã€1950å¹´ä»£å¾ŒåŠã«ç™ºæ˜ã•ã‚ŒãŸã€‚
ã“ã®è¨€èªã¯ã€ã‚¸ãƒ§ãƒ³ãƒ»ãƒãƒƒã‚«ãƒ¼ã‚·ãƒ¼ãŒæ€ã„ã¤ã„ãŸã‚‚ã®ã§ã‚ã‚Šã€ã€Œè¨˜å·å¼ã®å†å¸°çš„é–¢æ•°ã¨ã€æ©Ÿæ¢°ã«ã‚ˆã‚‹ãã®è¨ˆç®—ã€ã¨ã„ã†å½¼ã®è«–æ–‡ (<a href="http://www-formal.stanford.edu/jmc/recursive.html" target="_blank">McCrthy 1960</a>) ã«åŸºã¥ã„ã¦ã„ã‚‹ã€‚
</p>

<p class="orig" lang="en">
Despite its inception as a mathematical formalism, Lisp is a practical
programming language.  A Lisp <a name="%_idx_30"></a><em>interpreter</em> is a machine that
carries out processes described in the Lisp language.  The first Lisp
interpreter was implemented by <a name="%_idx_32"></a>McCarthy with the help of colleagues
and students in the Artificial Intelligence Group of the <a name="%_idx_34"></a>MIT Research
Laboratory of Electronics and in the MIT Computation
Center.<a name="call_footnote_Temp_7" href="#footnote_Temp_7"><sup><small>1</small></sup></a> <a name="%_idx_38"></a>Lisp, whose name is an acronym for LISt Processing,
was designed to provide symbol-manipulating capabilities for
attacking programming problems such as the symbolic differentiation
and integration of algebraic expressions.  It included for this
purpose new data objects known as atoms and lists, which most
strikingly set it apart from all other languages of the period.</p>

<p class="trans" lang="ja">
æ•°å­¦çš„å½¢å¼åŒ–ã¨ã—ã¦å§‹ã¾ã£ãŸã«ã‚‚ã‹ã‹ã‚ã‚‰ãšã€Lispã¯ã€å®Ÿç”¨çš„ãªãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã§ã‚ã‚‹ã€‚
Lispã®<em>ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿</em>ã¯ã€Lispè¨€èªã§è¨˜è¿°ã•ã‚ŒãŸãƒ—ãƒ­ã‚»ã‚¹ã‚’å®Ÿè¡Œã™ã‚‹ãƒã‚·ãƒ³ã§ã‚ã‚‹ã€‚
æœ€åˆã®Lispã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã¯ã€ãƒãƒƒã‚«ãƒ¼ã‚·ãƒ¼ã«ã‚ˆã£ã¦ã€MITé›»å­å·¥å­¦èª¿æŸ»ç ”ç©¶æ‰€ã®äººå·¥çŸ¥èƒ½ã‚°ãƒ«ãƒ¼ãƒ—ã¨MITè¨ˆç®—ã‚»ãƒ³ã‚¿ã®åŒåƒšã‚„å­¦ç”Ÿã®åŠ©ã‘ã‚’å€Ÿã‚Šã¦ã€å®Ÿè£…ã•ã‚ŒãŸ<a href="#footnote_Temp_7"><sup><small>1</small></sup></a>ã€‚
Lispâ€”â€”ãã®åã¯LISt Processingã®é ­å­—èªã§ã‚ã‚‹â€”â€”ã¯ã€ä»£æ•°å¼ã®<!--è¨˜å·å¾®åˆ†ã‚„è¨˜å·ç©åˆ†-->è¨˜å·çš„å¾®ç©åˆ†ãªã©ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®è«¸å•é¡Œã«å–ã‚Šçµ„ã‚€ãŸã‚ã®ã€è¨˜å·æ“ä½œã®èƒ½åŠ›ã‚’<!--ä¸ãˆã‚‹-->æä¾›ã™ã‚‹ãŸã‚ã«ã€è¨­è¨ˆã•ã‚ŒãŸã€‚
ã“ã®ç›®çš„ã®ãŸã‚ã€Lispã¯ã€ã‚¢ãƒˆãƒ ã¨ãƒªã‚¹ãƒˆã¨ã—ã¦çŸ¥ã‚‰ã‚Œã‚‹æ–°ãŸãªãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å«ã‚“ã§ã„ãŸã®ã§ã‚ã‚Šã€ãã®ã“ã¨ãŒã€æœ€ã‚‚éš›ç«‹ã£ã¦Lispã‚’ä»–ã®ã™ã¹ã¦ã®åŒæ™‚ä»£ã®è¨€èªã¨åŒºåˆ¥ã—ã¦ã„ã‚‹ã€‚
</p>

<p class="orig" lang="en">
Lisp was not the product of a concerted design effort.  Instead, it
evolved informally in an experimental manner in response to users'
needs and to pragmatic implementation considerations.  Lisp's informal
evolution has continued through the years, and the community of Lisp
users has traditionally resisted attempts to promulgate any
``official'' definition of the language.  This evolution, together
with the flexibility and elegance of the initial conception, has
enabled Lisp, which is the second oldest language in widespread use
today (only <a name="%_idx_40"></a>Fortran is older), to continually adapt to encompass the
most modern ideas about program design.  Thus, Lisp is by now a family
of dialects, which, while sharing most of the original features, may
differ from one another in significant ways.  The dialect of Lisp used
in this book is called <a name="%_idx_42"></a><a name="%_idx_44"></a>Scheme.<a name="call_footnote_Temp_8" href="#footnote_Temp_8"><sup><small>2</small></sup></a></p>

<p class="trans" lang="ja">
Lispã¯ã€ç†±å¿ƒãªè¨­è¨ˆåŠªåŠ›ã®è³œç‰©ã§ã¯ãªã„ã€‚
ãã†ã§ã¯ãªãã€Lispã¯ã€ãƒ¦ãƒ¼ã‚¶ã®è¦æ±‚ã«å¿œã˜ã¦ã€ã¾ãŸã€å®Ÿç”¨çš„ãªå®Ÿè£…ä¸Šã®å•é¡Œç‚¹ã«å¿œã˜ã¦ã€è©¦é¨“çš„ãªã‚„ã‚Šæ–¹ã§å½¢å¼ã°ã‚‰ãšã«é€²å±•ã—ãŸã€‚
Lispã®å½¢å¼ã°ã‚‰ãªã„é€²å±•ã¯ä½•å¹´ã‚‚ç¶šãã€Lispãƒ¦ãƒ¼ã‚¶ã®å…±åŒä½“ã¯ã€ã“ã®è¨€èªã®ã„ã‹ãªã‚‹ã€Œå…¬å¼ãªã€å®šç¾©ã‚’å…¬å¸ƒã™ã‚‹è©¦ã¿ã«å¯¾ã—ã¦ã‚‚ã€ä¼çµ±çš„ã«æŠµæŠ—ã—ã¦ããŸã€‚
<!--ã“ã®ã‚ˆã†ãªé€²å±•ã¯ã€æœ€åˆã®ç€æƒ³ã®æŸ”è»Ÿæ€§ã¨å„ªç¾ã•ã¨ã¨ã‚‚ã«ã€Lispâ€”â€”ç¾åœ¨ã€åºƒãä½¿ã‚ã‚Œã¦ã„ã‚‹ä¸­ã§ã¯äºŒç•ªç›®ã«å¤ã„è¨€èªã§ã‚ã‚‹ (<a name="%_idx_40"></a>Fortranã®ã¿ãŒã€ã‚ˆã‚Šå¤ã„) â€”â€”ã«ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ è¨­è¨ˆã«ã¤ã„ã¦ã®æœ€ã‚‚ç¾ä»£çš„ãªæ¦‚å¿µã‚’åŒ…å«ã™ã‚‹ã‚ˆã†ã«ç¶™ç¶šçš„ã«é©åˆã—ã¦ã„ãã®ã‚’å¯èƒ½ãŸã‚‰ã—ã‚ã¦ããŸã€‚-->
<!--ã“ã®ã‚ˆã†ãªé€²å±•ã¶ã‚Šã¨ã€æœ€åˆã®ç€æƒ³ã®æŸ”è»Ÿæ€§ãŠã‚ˆã³å„ªç¾ã•ã«ã‚ˆã£ã¦ã€Lispâ€”â€”ã„ã¾åºƒãä½¿ã‚ã‚Œã¦ã„ã‚‹ä¸­ã§ã¯äºŒç•ªç›®ã«å¤ã„è¨€èªã§ã‚ã‚‹ (Fortranã®ã¿ãŒã€ã‚ˆã‚Šå¤ã„) â€”â€”ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ è¨­è¨ˆã«ã¤ã„ã¦ã®æœ€ã‚‚ç¾ä»£çš„ãªæ¦‚å¿µã‚’åŒ…å«ã™ã‚‹ã‚ˆã†ã«çµ¶ãˆé–“ãªãé©åˆã—ã¦ã„ãã“ã¨ãŒå¯èƒ½ã¨ãªã£ãŸã€‚-->
ã“ã®ã‚ˆã†ãªé€²å±•ã¯ã€æœ€åˆã®ç€æƒ³ã®æŸ”è»Ÿæ€§ãŠã‚ˆã³æ˜æ™°ã•ã¨ã‚‚ç›¸ã¾ã£ã¦ã€Lispâ€”â€”ç¾åœ¨ã€åºƒãä½¿ã‚ã‚Œã¦ã„ã‚‹ä¸­ã§ã¯äºŒç•ªç›®ã«å¤ã„è¨€èªã§ã‚ã‚‹ (Fortranã®ã¿ãŒã€ã‚ˆã‚Šå¤ã„) â€”â€”ãŒã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ è¨­è¨ˆã«ã¤ã„ã¦ã®æœ€ã‚‚ç¾ä»£çš„ãªæ¦‚å¿µã‚’åŒ…å«ã™ã‚‹ã‚ˆã†ã«ã€çµ¶ãˆé–“ãªãé©åˆã—ã¦ã„ãã“ã¨ã‚’å¯èƒ½ã¨ã—ã¦ããŸã€‚
ã‹ãã—ã¦ã€ä»Šã‚„Lispã¯ã€è«¸æ–¹è¨€â€”â€”å…ƒã®ç‰¹å¾´ã®ã»ã¨ã‚“ã©ã‚’å…±æœ‰ã—ã¦ã„ã‚‹ã¨ã¯ã„ãˆã€äº’ã„ã«å¤§ã„ã«ç•°ãªã‚‹ã“ã¨ã‚‚ã‚ã‚‹â€”â€”ã®é›†ã¾ã‚Šã§ã‚ã‚‹ã€‚
æœ¬æ›¸ã§ä½¿ã†Lispã®æ–¹è¨€ã¯ã€Schemeã¨å‘¼ã°ã‚Œã‚‹<a href="#footnote_Temp_8"><sup><small>2</small></sup></a>ã€‚
</p>

<p class="orig" lang="en">
Because of its experimental character and its emphasis on symbol
manipulation, <a name="%_idx_96"></a><a name="%_idx_98"></a><a name="%_idx_100"></a>Lisp was at first very inefficient for numerical
computations, at least in comparison with Fortran.  Over the years,
however, Lisp compilers have been developed that translate programs
into machine code that can perform numerical computations reasonably
efficiently.  And for special applications, Lisp has been used with
great effectiveness.<a name="call_footnote_Temp_9" href="#footnote_Temp_9"><sup><small>3</small></sup></a>  Although Lisp has not yet overcome its old reputation
as hopelessly inefficient, Lisp is now used in many applications where
efficiency is not the central concern.  For example, Lisp has become
a language of choice for operating-system shell languages and for
extension languages for editors and computer-aided design systems.</p>

<p class="trans" lang="ja">
è©¦é¨“çš„ãªæ€§è³ªã‚†ãˆã«ã€ãã—ã¦ã€è¨˜å·æ“ä½œã‚’é‡è¦–ã™ã‚‹ãŒã‚†ãˆã«ã€Lispã¯ã€æœ€åˆã¯ã€æ•°å€¤è¨ˆç®—ç”¨ã«ã¯éå¸¸ã«éåŠ¹ç‡çš„ã ã£ãŸâ€”â€”å°‘ãªãã¨ã‚‚Fortranã¨æ¯”ã¹ã¦ã€‚
ã—ã‹ã—ã€æ•°å€¤è¨ˆç®—ã‚’ã‹ãªã‚ŠåŠ¹ç‡çš„ã«å®Ÿè¡Œã§ãã‚‹ãƒã‚·ãƒ³ã‚³ãƒ¼ãƒ‰ã¸ã¨ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’å¤‰æ›ã™ã‚‹Lispã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãŒã€é•·å¹´ã«ã‚ãŸã£ã¦é–‹ç™ºã•ã‚Œã¦ããŸã€‚
ã¾ãŸã€ç‰¹æ®Šãªå¿œç”¨åˆ†é‡ã§ã¯ã€Lispã¯ã€å¤šå¤§ãªã‚‹æœ‰åŠ¹æ€§ã‚’ã‚‚ã£ã¦ä½¿ã‚ã‚Œã¦ããŸ<a href="#footnote_Temp_9"><sup><small>3</small></sup></a>ã€‚
çµ¶æœ›çš„ã«éåŠ¹ç‡ã ã¨ã„ã†æ—§æ¥ã®è©•åˆ¤ã‚’ã€Lispã¯ã¾ã å…‹æœã—ã¦ã¯ã„ãªã„ã¨ã¯ã„ãˆã€ä»Šã‚„Lispã¯ã€åŠ¹ç‡æ€§ãŒä¸­å¿ƒçš„é–¢å¿ƒäº‹ã§ã¯ãªã„ã‚ˆã†ãªå¤šãã®å¿œç”¨åˆ†é‡ã§ä½¿ã‚ã‚Œã¦ã„ã‚‹ã€‚
ãŸã¨ãˆã°ã€Lispã¯ã€ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒ»ã‚·ã‚¹ãƒ†ãƒ ã®ã‚·ã‚§ãƒ«è¨€èªã ã¨ã‹ã€ã‚¨ãƒ‡ã‚£ã‚¿ã‚„ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼æ”¯æ´è¨­è¨ˆã‚·ã‚¹ãƒ†ãƒ ç”¨ã®æ‹¡å¼µè¨€èªã ã¨ã‹ã®ã€é¸æŠè‚¢ãŸã‚‹è¨€èªã¨ãªã£ãŸã€‚
<!--ã“ãªã‚Œã¦ã„ãªã„ã€‚ã€œã¨ã—ã¦é¸ã¹ã‚‹(ã€œã®ãŸã‚ã«(é¸æŠè‚¢ã¨ã—ã¦)é¸ã¹ã‚‹)è¨€èªã€ã¨ã‹è¨³ã™?-->
<!--Lispã¯ã€ãŸã¨ãˆã°ã€ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒ»ã‚·ã‚¹ãƒ†ãƒ ã®ã‚·ã‚§ãƒ«è¨€èªã®ãŸã‚ã‚„ã€ã‚¨ãƒ‡ã‚£ã‚¿ã‚„ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼æ”¯æ´è¨­è¨ˆã‚·ã‚¹ãƒ†ãƒ ç”¨ã®æ‹¡å¼µè¨€èªã®ãŸã‚ã«ã€é¸æŠè‚¢ã¨ã—ã¦é¸ã¹ã‚‹è¨€èªã¨ãªã£ãŸã€‚-->
</p>

<p class="orig" lang="en">
If Lisp is not a mainstream language, why are we using it as the
framework for our discussion of programming?  Because the language
possesses <a name="%_idx_112"></a>unique features that make it an excellent medium for
studying important programming constructs and data structures and for
relating them to the linguistic features that support them.  The most
significant of these features is the fact that Lisp descriptions of
processes, called <a name="%_idx_114"></a><a name="%_idx_116"></a><em>procedures</em>, can
themselves be represented and manipulated as Lisp data.  The
importance of this is that there are powerful program-design
techniques that rely on the ability to blur the traditional
distinction between ``passive'' data and ``active'' processes.  As we
shall discover, Lisp's flexibility in handling procedures as data
makes it one of the most convenient languages in existence for
exploring these techniques.  The ability to represent procedures as
data also makes Lisp an excellent language for writing programs that
must manipulate other programs as data, such as the interpreters and
compilers that support computer languages.  Above and beyond these
considerations, programming in Lisp is great fun.</p>

<p class="trans" lang="ja">
ã‚‚ã—LsipãŒä¸»æµè¨€èª<!--ã§ãªã‘ã‚Œã°-->ã§ã¯ãªã„ãªã‚‰ã°ã€ãªãœç§ãŸã¡<!--ãŒ-->ã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®è­°è«–ã®ãŸã‚ã®æ çµ„ã¿ã¨ã—ã¦Lispã‚’ä½¿ã£ã¦ã„ã‚‹ã¨ã„ã†ã®ã ã‚ã†?
ãªãœãªã‚‰ã€ã“ã®è¨€èªã‚’ã€é‡è¦ãªãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°æ§‹æˆ<!--ä½“-->ã¨ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã¨ã‚’å­¦ã¶ãŸã‚ã®ã€ã¾ãŸã€ãã‚Œã‚‰ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°æ§‹æˆã¨ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’ã€ãã‚Œã‚‰ã‚’æ”¯ãˆã‚‹è¨€èªçš„ç‰¹å¾´ã¨é–¢é€£ã¥ã‘ã‚‹ãŸã‚ã®ã€å„ªã‚ŒãŸæ‰‹æ®µãŸã‚‰ã—ã‚ã‚‹æ ¼åˆ¥ãªç‰¹å¾´ã‚’ã€ã“ã®è¨€èªã¯æœ‰ã—ã¦ã„ã‚‹ã‹ã‚‰ã§ã‚ã‚‹ã€‚
ã“ã‚Œã‚‰ã®ç‰¹å¾´ã®ã†ã¡æœ€ã‚‚é‡è¦ãªã‚‚ã®ã¯ã€ãƒ—ãƒ­ã‚»ã‚¹ã®Lispè¨˜è¿°â€”â€”<em>æ‰‹ç¶šã</em>ã¨å‘¼ã°ã‚Œã‚‹â€”â€”è‡ªä½“ã‚’ã€Lispãƒ‡ãƒ¼ã‚¿ã¨ã—ã¦è¡¨ç¾ã—ãŸã‚Šæ“ä½œã—ãŸã‚Šã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€ã¨ã„ã†äº‹å®Ÿã§ã‚ã‚‹ã€‚
ã“ã®ã“ã¨ã®é‡è¦æ€§ã¯ã€ã€Œå—å‹•çš„ãªã€ãƒ‡ãƒ¼ã‚¿ã¨ã€Œèƒ½å‹•çš„ãªã€ãƒ—ãƒ­ã‚»ã‚¹ã®é–“ã«ã‚ã‚‹å¾“æ¥ã®åŒºåˆ¥ã‚’ã¼ã‚„ã‹ã™èƒ½åŠ›ã«ä¾å­˜ã™ã‚‹ã‚ˆã†ãªã€å¼·åŠ›ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ è¨­è¨ˆæŠ€æ³•ãŒå­˜åœ¨ã™ã‚‹ã€ã¨ã„ã†ã“ã¨ã«ã‚ã‚‹ã€‚
ç§ãŸã¡ãŒè¦‹å‡ºã™ã“ã¨ã«ãªã‚‹ã¨ãŠã‚Šã€æ‰‹ç¶šãã‚’ãƒ‡ãƒ¼ã‚¿ã¨ã—ã¦æ‰±ã†éš›ã®Lispã®æŸ”è»Ÿæ€§ã¯ã€Lispã‚’ã€ã“ã‚Œã‚‰ã®æŠ€æ³•ã‚’æ¢æ±‚ã™ã‚‹ãŸã‚ã®æœ€ã‚‚ä¾¿åˆ©ãªç¾å­˜ã®è¨€èªã®ä¸€ã¤ãŸã‚‰ã—ã‚ã¦ã„ã‚‹ã€‚
<!--æ‰‹ç¶šãã‚’ãƒ‡ãƒ¼ã‚¿ã¨ã—ã¦è¡¨ç¾ã™ã‚‹èƒ½åŠ›ã¯ã€Lispã‚’ã€ä»–ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ãƒ‡ãƒ¼ã‚¿ã¨ã—ã¦æ“ä½œã›ã­ã°ãªã‚‰ãªã„ãƒ—ãƒ­ã‚°ãƒ©ãƒ â€”â€”ãŸã¨ãˆã°ã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿è¨€èªã‚’ä¸‹æ”¯ãˆã™ã‚‹ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã‚„ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãªã©â€”â€”ã‚’æ›¸ããŸã‚ã®ã€å„ªã‚ŒãŸè¨€èªãŸã‚‰ã—ã‚ã¦ã„ã‚‹ã€‚-->
æ‰‹ç¶šãã‚’ãƒ‡ãƒ¼ã‚¿ã¨ã—ã¦è¡¨ç¾ã™ã‚‹èƒ½åŠ›ã«ã‚ˆã‚Šã€Lispã¯ã€ä»–ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ãƒ‡ãƒ¼ã‚¿ã¨ã—ã¦æ“ä½œã›ã­ã°ãªã‚‰ãªã„ãƒ—ãƒ­ã‚°ãƒ©ãƒ â€”â€”ãŸã¨ãˆã°ã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿è¨€èªã‚’ä¸‹æ”¯ãˆã™ã‚‹ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã‚„ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãªã©â€”â€”ã‚’æ›¸ããŸã‚ã®ã€å„ªã‚ŒãŸè¨€èªã«ã‚‚ãªã£ã¦ã„ã‚‹ã€‚
ã“ã‚Œã‚‰ã®äº‹æŸ„ã«åŠ ãˆã¦ã€Lispã§ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã™ã‚‹ã“ã¨ã¯ã€ã¨ã¦ã‚‚æ¥½ã—ã„ã®ã ã€‚
</p>

<a name="footnotes"></a>
<hr>
<p class="orig" lang="en"><a name="footnote_Temp_7" href="#call_footnote_Temp_7"><sup><small>1</small></sup></a> The <em>Lisp 1 Programmer's Manual</em> appeared in
1960, and the <em>Lisp 1.5 Programmer's Manual</em> <a name="%_idx_36"></a>(McCarthy 1965)
was published in 1962.  The early history of Lisp is described in
McCarthy 1978.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_7"><sup><small>1</small></sup></a>
1960å¹´ã«å‡ºãŸ<em class="en">Lisp 1 Programmer's Manual</em>ã¨ã€<em class="en">Lisp 1.5 Programmer's Manual</em> <a name="%_idx_36"></a> (McCarthy 1965) ã¯ã€1962å¹´ã«å…¬é–‹ã•ã‚ŒãŸã€‚
Lispã®åˆæœŸã®æ­´å²ã¯ã€McCarthy 1978ã«è¿°ã¹ã‚‰ã‚Œã¦ã„ã‚‹ã€‚
</p>


<p class="orig" lang="en"><a name="footnote_Temp_8" href="#call_footnote_Temp_8"><sup><small>2</small></sup></a> The two dialects in which most
major Lisp programs of the 1970s were written are <a name="%_idx_46"></a><a name="%_idx_48"></a>MacLisp <a name="%_idx_50"></a>(Moon 1978;
<a name="%_idx_52"></a>Pitman 1983), developed at the <a name="%_idx_54"></a>MIT Project MAC, and <a name="%_idx_56"></a><a name="%_idx_58"></a>Interlisp
<a name="%_idx_60"></a>(Teitelman 1974), developed at <a name="%_idx_62"></a>Bolt Beranek and Newman Inc. and the
<a name="%_idx_64"></a>Xerox Palo Alto Research Center.  <a name="%_idx_66"></a><a name="%_idx_68"></a>Portable Standard Lisp <a name="%_idx_70"></a>(Hearn 1969;
<a name="%_idx_72"></a>Griss 1981) was a Lisp dialect designed to be easily portable
between different machines.  MacLisp spawned a number of subdialects,
such as <a name="%_idx_74"></a><a name="%_idx_76"></a>Franz Lisp, which was developed at the <a name="%_idx_78"></a>University of
California at Berkeley, and <a name="%_idx_80"></a><a name="%_idx_82"></a>Zetalisp (Moon 1981), which was based on a
special-purpose processor designed at the <a name="%_idx_84"></a>MIT Artificial Intelligence
Laboratory to run Lisp very efficiently.  The Lisp dialect used in
this book, called <a name="%_idx_86"></a>Scheme (Steele 1975), was invented in 1975 by <a name="%_idx_88"></a><a name="%_idx_90"></a>Guy
Lewis Steele Jr. and Gerald Jay Sussman of the MIT Artificial
Intelligence Laboratory and later reimplemented for instructional use
at MIT.  Scheme became an IEEE standard in 1990 (IEEE 1990).  The
<a name="%_idx_92"></a><a name="%_idx_94"></a>Common Lisp dialect (Steele 1982, Steele 1990) was developed by the
Lisp community to combine features from the earlier Lisp dialects
to make an industrial standard for Lisp.  Common Lisp became an ANSI
standard in 1994 (ANSI&nbsp;1994).</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_8"><sup><small>2</small></sup></a>
1970å¹´ä»£ã®æœ€ã‚‚é‡è¦ãªLispã®è«¸ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ãã®ã«ä½¿ã‚ã‚ŒãŸäºŒã¤ã®æ–¹è¨€ã¯ã€MacLisp (Moon 1978; Pitman 1983) â€”â€”MIT Project MACã§é–‹ç™ºã•ã‚ŒãŸâ€”â€”ã¨ã€Interlisp (Teitelman 1974) â€”â€”Bolt Beranek and Newman Inc.ã¨Xerox Palo Alto Research Centerã§é–‹ç™ºã•ã‚ŒãŸâ€”â€”ã§ã‚ã‚‹ã€‚
Portable Standard Lisp (Hearn 1969; Griss 1981) ã¯ã€ç•°ãªã‚‹ãƒã‚·ãƒ³é–“ã§ç°¡å˜ã«ç§»æ¤å¯èƒ½ã¨ãªã‚‹ã‚ˆã†ã«è¨­è¨ˆã•ã‚ŒãŸLispæ–¹è¨€ã ã£ãŸã€‚
MacLispã¯ã€Franz Lispâ€”â€”ã‚«ãƒªãƒ•ã‚©ãƒ«ãƒ‹ã‚¢å¤§å­¦ãƒãƒ¼ã‚¯ãƒªãƒ¼æ ¡ã§é–‹ç™ºã•ã‚ŒãŸâ€”â€”ã‚„ã€Zetalisp (Moon 1981) â€”â€”Lispã‚’éå¸¸ã«åŠ¹ç‡çš„ã«å®Ÿè¡Œã•ã›ã‚‹ã‚ˆã†ã«MITäººå·¥çŸ¥èƒ½ç ”ç©¶æ‰€ã«ãŠã„ã¦è¨­è¨ˆã•ã‚ŒãŸç‰¹å®šç”¨é€”ãƒ—ãƒ­ã‚»ãƒƒã‚µã«åŸºã¥ã„ã¦ã„ãŸâ€”â€”ãªã©ã®ã€å¤šãã®ä¸‹ä½æ–¹è¨€ã‚’ç”£ã¿å‡ºã—ãŸã€‚
æœ¬æ›¸ã§ä½¿ã†Lispæ–¹è¨€â€”â€”Scheme (Steele 1975) ã¨å‘¼ã°ã‚Œã‚‹â€”â€”ã¯ã€1975å¹´ã«ã€MITäººå·¥çŸ¥èƒ½ç ”ç©¶æ‰€ã®Guy Lewis Steele Jr. ã¨Gerald Jay Sussmanã«ã‚ˆã£ã¦ä½œã‚Šå‡ºã•ã‚Œã€å¾Œã«MITã«ãŠã„ã¦æ•™è‚²ç”¨é€”ã®ãŸã‚ã«å†å®Ÿè£…ã•ã‚ŒãŸã€‚
Schemeã¯ã€1990å¹´ã«IEEEè¦æ ¼ã¨ãªã£ãŸ (IEEE 1990)ã€‚
Common Lispæ–¹è¨€ (Steele 1982, Steele 1990) ã¯ã€Lispã®ç”£æ¥­çš„è¦æ ¼ã‚’ä½œã‚‹ãŸã‚ã«ã€åˆæœŸã®Lispã®è«¸æ–¹è¨€ã‹ã‚‰ã®ç‰¹å¾´ã‚’çµ±åˆã™ã‚‹ã‚ˆã†ã«ã€Lispå…±åŒä½“ã«ã‚ˆã‚Šé–‹ç™ºã•ã‚ŒãŸã€‚
Common Lispã¯1994å¹´ã«ANSIè¦æ ¼ (ANSI 1994) ã«ãªã£ãŸã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_9" href="#call_footnote_Temp_9"><sup><small>3</small></sup></a> One such special application was a
breakthrough computation of scientific importance -- an integration of
the motion of the <a name="%_idx_102"></a><a name="%_idx_104"></a>Solar System that extended previous results by
nearly two orders of magnitude, and demonstrated that the dynamics of
the Solar System is chaotic.  This computation was made possible by
new integration algorithms, a special-purpose compiler, and a
special-purpose computer all implemented with the aid of software
tools written in Lisp <a name="%_idx_106"></a>(Abelson et al. 1992; <a name="%_idx_108"></a><a name="%_idx_110"></a>Sussman and
Wisdom 1992).</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_9"><sup><small>3</small></sup></a>
ãã†ã„ã†ç‰¹æ®Šãªå¿œç”¨åˆ†é‡ã®ä¸€ã¤ã¯ã€<!--ç§‘å­¦çš„é‡è¦æ€§ã®ãƒ–ãƒ¬ã‚¤ã‚¯ã‚¹ãƒ«ãƒ¼è¨ˆç®—-->ç§‘å­¦çš„é‡è¦æ€§ã‚’æŒã£ãŸãƒ–ãƒ¬ã‚¤ã‚¯ã‚¹ãƒ«ãƒ¼çš„ãªè¨ˆç®—ã§ã‚ã‚‹â€”â€”ã™ãªã‚ã¡ã€ä»¥å‰ã®çµæœã‚’ã»ã¼äºŒæ¡ã¶ã‚“æ‹¡å¼µã—ã€å¤ªé™½ç³»ã®åŠ›å­¦ãŒæ··æ²Œã¨ã—ã¦ã„ã‚‹ã“ã¨ã‚’å®Ÿè¨¼ã—ãŸã€å¤ªé™½ç³»ã®å‹•ãã®ç©åˆ†ã§ã‚ã‚‹ã€‚
ã“ã®è¨ˆç®—ã¯ã€æ–°ãŸãªç©åˆ†ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¨ã€ç‰¹å®šç”¨é€”ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¨ã€ç‰¹å®šç”¨é€”ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã«ã‚ˆã£ã¦å¯èƒ½ã¨ãªã£ãŸã‚‚ã®ã ãŒã€ãã‚Œã‚‰ã™ã¹ã¦ã¯ã€Lispã§æ›¸ã‹ã‚ŒãŸã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ãƒ»ãƒ„ãƒ¼ãƒ«ã®åŠ©ã‘ã‚’å€Ÿã‚Šã¦å®Ÿç¾ã•ã‚ŒãŸã‚‚ã®ã§ã‚ã‚‹ (Abelson et al. 1992; Sussman and Wisdom 1992) ã€‚
</p>
</div>
</body>

</html>
