<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="sicp.css" type="text/css">
<base target="_top">
<title>SICP私訳: 5.3 記憶割り当てとガーベジ・コレクション (ごみあつめ) </title>
<link rel="canonical" href="https://piyo-ko.github.io/SICP/33_sec5_3.html" />
</head>
<body>

<div class="idx-bar">
<nav>
<a href="https://twitter.com/share" class="twitter-share-button" data-lang="ja">ツイート</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
<span class="status">推敲待ち</span>
[
<a href="00_cover.html">先頭へ</a> |
<a href="32_sec5_2.html">前へ</a> |
<a href="34_sec5_4.html">次へ</a> |
<a href="04_toc.html#%_toc_start">目次</a> |
<a href="38_index.html#%_index_start">索引</a>
] [<a href="99_about.html">この対訳版について</a> | <a href="../index.html">ホーム</a>]
[
§<a href="#%_sec_5.3">5.3</a>
§<a href="#%_sec_5.3.1">5.3.1</a>
📚<a href="#%_sec_Temp_746">&hellip;</a>
🎨<a href="#%_fig_5.14">5.14</a>
📚<a href="#%_sec_Temp_751">&hellip;</a>
📚<a href="#%_sec_Temp_754">&hellip;</a>
📝<a href="#%_thm_5.20">5.20</a>
📝<a href="#%_thm_5.21">5.21</a>
📝<a href="#%_thm_5.22">5.22</a>
§<a href="#%_sec_5.3.2">5.3.2</a>
📚<a href="#%_sec_Temp_761">&hellip;</a>
🎨<a href="#%_fig_5.15">5.15</a>
<a href="#footnotes">脚注</a>
]</nav>


</div>

<div class="main-txt">
<a name="%_sec_5.3"></a>
<h2 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_5.3">5.3  Storage Allocation and Garbage Collection</a></h2>
<h2 class="trans" lang="ja">5.3 記憶割り当てと<ruby><rb>ガーベジ</rb><rp> (</rp><rt>ごみ</rt><rp>) </rp></ruby>・<ruby><rb>コレクション</rb><rp> (</rp><rt>あつめ</rt><rp>) </rp></ruby></h2>

<p class="orig" lang="en">
<a name="%_idx_5828"></a><a name="%_idx_5830"></a>
In section <a href="34_sec5_4.html#%_sec_5.4">5.4</a>, we will show how to implement a Scheme
evaluator as a register machine.  In order to simplify the discussion,
we will assume that our register machines can be equipped with a <em>list-structured memory</em>, in which the basic operations for
manipulating list-structured data are primitive.  Postulating the
existence of such a memory is a useful abstraction when one is
focusing on the mechanisms of control in a Scheme interpreter, but
this does not reflect a realistic view of the actual primitive data
operations of contemporary computers.  To obtain a more complete
picture of how a Lisp system operates, we must investigate how list
structure can be represented in a way that is compatible with
conventional computer memories.</p>

<p class="trans" lang="ja">
<a href="34_sec5_4.html#%_sec_5.4">5.4</a>節では、どのようにして Scheme 評価器をレジスタ・マシンとして実装するのかを示そう。
その議論を簡単化するために、私たちは、<em>リスト構造化されたメモリ</em>——そこでは、リスト構造化されたデータを操作するための基本的演算が原始的である——を自分たちのレジスタ・マシンに備えつけることができるのだ、と仮定しよう。
そうしたメモリの存在を仮定することは、Scheme インタプリタにおける制御の仕組みに関心を集中させているときに有用な抽象化であるが、これは、現代のコンピュータの実際の原始的データ演算についての現実的な見方を反映しているわけではない。
Lisp システムがどのように動作するかについての、より完全な描写を手に入れるために、私たちは、従来のコンピュータ・メモリと互換性のある方法でリスト構造をどのように表せるのか、ということを研究せねばならない。
</p>

<p class="orig" lang="en">
There are two considerations in implementing list structure.  The
first is purely an issue of representation: how to represent the
``box-and-pointer'' structure of Lisp pairs, using only the storage
and addressing capabilities of typical computer memories.  The second
issue concerns the management of memory as a computation proceeds.
The operation of a Lisp system depends crucially on the ability to
continually create new data objects.  These include objects that are
explicitly created by the Lisp procedures being interpreted as well
as structures created by the interpreter itself, such as environments
and argument lists.  Although the constant creation of new data
objects would pose no problem on a computer with an infinite amount of
rapidly addressable memory, computer memories are available only in
finite sizes (more's the pity).  Lisp systems
thus provide an <a name="%_idx_5832"></a><em>automatic storage allocation</em> facility to
support the illusion of an infinite memory.  When a data object is no
longer needed, the memory allocated to it is automatically recycled
and used to construct new data objects.  There are various
techniques for providing such automatic storage allocation.  The
method we shall discuss in this section is called <em>garbage
collection</em>.</p>

<p class="trans" lang="ja">
リスト構造を実装する際に考慮すべきことが二つある。
一つ目は、純粋に表現の問題である。つまり、Lisp での対の「箱とポインタ」の構造を、典型的コンピュータ・メモリの格納能力とアドレシング能力のみを用いて、どのように表現するか、という点である。
二つ目の問題は、計算が進むにつれてのメモリの管理についてのものである。
Lisp システムの動作は、新たなデータ・オブジェクトを継続的に作成する能力に、決定定期に依存している。
これらの新たなデータ・オブジェクトには、解釈されている最中の Lisp 手続きにより明示的に作成されるオブジェクト、および、インタプリタ自体により作成される構造——環境や引数リストなど——が含まれる。
新たなデータ・オブジェクトを絶え間なく作成することは、迅速にアクセス可能な無限の量のメモリを備えたコンピュータに対しては、何の問題ももたらさないだろうが、コンピュータ・メモリは、(残念ながら) 有限の大きさでしか利用可能ではない。
よって、Lisp システムは、無限のメモリという幻影を支えるために、<em>自動的<ruby><rb>記憶</rb><rp> (</rp><rt>ストレージ</rt><rp>) </rp></ruby><ruby><rb>割り当て</rb><rp> (</rp><rt>アロケーション</rt><rp>) </rp></ruby></em>手段を提供している。
データ・オブジェクトがもう必要ではなくなると、そのデータ・オブジェクトに割り当てられているメモリが自動的に再利用され、新たなデータ・オブジェクトを構築するのに使われる。
そうした自動記憶割り当てを提供するための、様々な技法がある。
本節で私たちが議論することになる方法は、<em><ruby><rb>ガーベジ</rb><rp> (</rp><rt>ごみ</rt><rp>) </rp></ruby>・<ruby><rb>コレクション</rb><rp> (</rp><rt>あつめ</rt><rp>) </rp></ruby></em>と呼ばれる。
</p>

<a name="%_sec_5.3.1"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_5.3.1">5.3.1  Memory as Vectors</a></h3>
<h3 class="trans" lang="ja">5.3.1 ベクタとしてのメモリ</h3>

<p class="orig" lang="en">A conventional computer memory can be thought of as an array of
cubbyholes, each of which can contain a piece of information.  Each
cubbyhole has a unique name, called its <a name="%_idx_5834"></a><em>address</em> or <a name="%_idx_5836"></a><em>location</em>.  Typical memory systems provide two primitive operations:
one that fetches the data stored in a specified location and one that
assigns new data to a specified location.  Memory addresses can be
incremented to support sequential access to some set of the
cubbyholes.  More generally, many important data operations require
that memory addresses be treated as data, which can be stored in
memory locations and manipulated in machine registers.  The
representation of list structure is one application of such <a name="%_idx_5838"></a><a name="%_idx_5840"></a><em>address arithmetic</em>.</p>

<p class="trans" lang="ja">
従来のコンピュータ・メモリは、小部屋の配列だと見なせて、それらの小部屋の各々は、一つの情報を含むことができる。
各小部屋には、その小部屋の<em><ruby><rb>番地</rb><rp> (</rp><rt>アドレス</rt><rp>) </rp></ruby></em>または<em><ruby><rb>場所</rb><rp> (</rp><rt>ロケーション</rt><rp>) </rp></ruby></em>と呼ばれる、一意な名前がある。
典型的メモリシステムは、二つの原始的操作——すなわち、指定された場所に格納されているデータを取ってくるものと、指定された場所に新たなデータを割り当てるもの——を提供する。
メモリアドレスは、小部屋の何らかの集まりに対する逐次的アクセスをサポートするために、インクリメントされ得る。
より一般的には、データ——メモリ上の場所に格納することができ、マシン・レジスタにおいて操作することができるもの——としてメモリアドレスを扱うことを、多くの重要なデータ操作が要求している。
リスト構造の表現は、そうした<em>アドレス算術</em>の一つの応用である。
</p>

<p class="orig" lang="en">
To model computer memory, we use a new kind of data
structure called a <a name="%_idx_5842"></a><em>vector</em>.  Abstractly, a vector is a compound
data object whose individual elements can be accessed by means of an
integer index in an amount of time that is independent of the
index.<a name="call_footnote_Temp_744" href="#footnote_Temp_744"><sup><small>5</small></sup></a> In order to describe memory operations, we use two
primitive Scheme procedures for manipulating vectors:</p>

<p class="trans" lang="ja">
コンピュータ・メモリをモデル化するために、私たちは、<em>ベクタ</em>と呼ばれる新たな種類のデータ構造を用いる。
<!-- 抽象的には、ベクタとは、その個々の要素に、添え字には依存しない量の時間で、整数の添え字によってアクセスできるような、複合データ・オブジェクトである。 -->
抽象的には、ベクタとは、整数の添え字を用いて、その添え字には依存しない量の時間で、個々の要素にアクセスできるような、複合データ・オブジェクトである<a  href="#footnote_Temp_744"><sup><small>5</small></sup></a>。
メモリ演算を説明するために、ベクタを操作するための二つの原始的な Scheme 手続きを用いる。
</p>

<ul class="orig" lang="en">
<a name="%_idx_5844"></a><a name="%_idx_5846"></a><li><tt>(vector-ref &lt;<em>vector</em>&gt; &lt;<em>n</em>&gt;)</tt> returns the <em>n</em>th
element of the vector.</li>

<a name="%_idx_5848"></a><a name="%_idx_5850"></a><li><tt>(vector-set! &lt;<em>vector</em>&gt; &lt;<em>n</em>&gt; &lt;<em>value</em>&gt;)</tt> sets
the <em>n</em>th element of the vector to the designated value.</li>
</ul>

<ul class="trans" lang="ja">
<li><tt>(vector-ref &lt;<em class="en">vector</em>&gt; &lt;<em class="en">n</em>&gt;)</tt> は、ベクタの <em class="en">n</em> 番目の要素を返す。</li>
<li><tt>(vector-set! &lt;<em class="en">vector</em>&gt; &lt;<em class="en">n</em>&gt; &lt;<em class="en">value</em>&gt;)</tt> は、ベクタの <em class="en">n</em> 番目の要素を、指定された値に設定する。</li>
</ul>

<p class="orig" lang="en">For example, if <tt>v</tt> is a vector, then <tt>(vector-ref v 5)</tt> gets
the fifth entry in the vector <tt>v</tt> and <tt>(vector-set! v 5 7)</tt>
changes the value of the fifth entry of the vector <tt>v</tt> to 7.<a name="call_footnote_Temp_745" href="#footnote_Temp_745"><sup><small>6</small></sup></a>
For computer memory, this access can be implemented
through the use of address arithmetic to combine a <em>base address</em>
that specifies the beginning location of a vector in memory with an
<em>index</em> that specifies the offset of a particular element of the vector.</p>

<p class="trans" lang="ja">
例えば、もし <tt>v</tt> がベクタなら、
<tt>(vector-ref v 5)</tt> 
は、<tt>v</tt> というベクタの 5 番目のエントリを取得し、
<tt>(vector-set! v 5 7)</tt>
は、<tt>v</tt> というベクタの 5 番目のエントリの値を 7 に変更する<a href="#footnote_Temp_745"><sup><small>6</small></sup></a>。
メモリにおけるベクタの開始位置を指定する<em>ベース・アドレス</em>を、そのベクタの特定の要素のオフセットを指定する<em><ruby><rb>添え字</rb><rp> (</rp><rt>インデックス</rt><rp>) </rp></ruby></em>と組み合わせるアドレス算術の使用を通じて、コンピュータ・メモリ用に、こうしたアクセスを実装できる。
</p>

<a name="%_sec_Temp_746"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_746">Representing Lisp data</a></h4>
<h4 class="trans" lang="ja">Lisp データを表現する</h4>

<p class="orig" lang="en">
<a name="%_idx_5852"></a><a name="%_idx_5854"></a>
We can use vectors to implement the basic pair structures required for
a list-structured memory.  Let us imagine that computer memory is
divided into two vectors: <a name="%_idx_5856"></a><tt>the-cars</tt> and <a name="%_idx_5858"></a><tt>the-cdrs</tt>.  We will
represent list structure as follows: A pointer to a pair is an index
into the two vectors.  The <tt>car</tt> of the pair is the entry in <tt>the-cars</tt> with the designated index, and the <tt>cdr</tt> of the pair is
the entry in <tt>the-cdrs</tt> with the designated index.  We also need a
representation for objects other than pairs (such as numbers and
symbols) and a way to distinguish one kind of data from another.
There are many methods of accomplishing this, but they all reduce to
using <a name="%_idx_5860"></a><a name="%_idx_5862"></a><em>typed pointers</em>, that is, to extending the notion of
``pointer'' to include information on data type.<a name="call_footnote_Temp_747" href="#footnote_Temp_747"><sup><small>7</small></sup></a> The data type enables the system to
distinguish a pointer to a pair (which consists of the ``pair'' data
type and an index into the memory vectors) from pointers to other
kinds of data (which consist of some other data type and whatever is
being used to represent data of that type).  Two data objects are
<a name="%_idx_5868"></a>considered to be the same (<tt>eq?</tt>) if their pointers are
identical.<a name="call_footnote_Temp_748" href="#footnote_Temp_748"><sup><small>8</small></sup></a> Figure <a href="#%_fig_5.14">5.14</a>
illustrates the use of this method to represent the list <tt>((1 2) 3
4)</tt>, whose box-and-pointer diagram is also shown.  We use letter
prefixes to denote the data-type information.  Thus, a pointer to the
pair with index 5 is denoted <tt>p5</tt>, the empty list is denoted by
the pointer <tt>e0</tt>, and a pointer to the number 4 is denoted <tt>n4</tt>.  In the box-and-pointer diagram, we have indicated at the lower
left of each pair the vector index that specifies where the <tt>car</tt>
and <tt>cdr</tt> of the pair are stored.  The blank locations in <tt>the-cars</tt> and <tt>the-cdrs</tt> may contain parts of other list
structures (not of interest here).</p>

<p class="trans" lang="ja">
リスト構造化されたメモリに必要な基本的な対構造を実装するために、私たちはベクタを使える。
コンピュータ・メモリが、二つのベクタ——すなわち、<tt>the-cars</tt> と <tt>the-cdrs</tt> ——に分割されているものと想像しよう。
リスト構造を次のように表現する。
対へのポインタは、これら二つのベクタに対する添え字である。
その対の <tt>car</tt> は、<tt>the-cars</tt> の中における、指定された添え字を有するエントリであり、その対の <tt>cdr</tt> は、<tt>the-cdrs</tt> の中における、指定された添え字を有するエントリである。
私たちは、対以外のオブジェクト (数や記号など) に対する表現と、ある一つの種類のデータを別の種類のデータと区別するための方法も、必要としている。
これを達成する多くの方法があるが、それらの方法はどれも、<em>型つきのポインタ</em>を使うことへと——つまり、「ポインタ」の概念を、データ型についての情報を含むように拡張することへと——帰着する<a href="#footnote_Temp_747"><sup><small>7</small></sup></a>。
データ型により、システムが、対 (「対」のデータ型と、メモリ・ベクタに対する添え字とからなる) に対するポインタを、別の種類のデータ (他の何らかのデータ型と、その型のデータを表現するのに使われているものなら何でもすべて、からなる) に対するポインタと区別することが可能となる。
二つのデータ・オブジェクトは、もしそれらのポインタ同士が同じであれば、同一である (<tt>eq?</tt>) と見なされる<a href="#footnote_Temp_748"><sup><small>8</small></sup></a>。
図<a href="#%_fig_5.14">5.14</a>は、<tt>((1 2) 3 4)</tt> というリストを表現するためにこの方法を使用することを図示しており、このリストの、箱とポインタによる図も示されている。
データ型情報を表記するために、文字の接頭辞を使う。
よって、5 という添え字の対へのポインタは <tt>p5</tt> と示され、空リストは <tt>e0</tt> というポインタにより示され、4 という数へのポインタは <tt>n4</tt> と示される。
箱とポインタによる図においては、それぞれの対の左下に、その対の <tt>car</tt>
と <tt>cdr</tt> がどこに格納されているのかを指定する、ベクタの添え字を示した。
<tt>the-cars</tt> と <tt>the-cdrs</tt> における空白の場所は、(ここでは興味の対象外の) 他のリスト構造の一部を含んでいてもよい。
</p>

<figure>
<a name="%_fig_5.14"></a>
<img src="ch5-Z-G-7.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 5.14:</b>  Box-and-pointer and memory-vector representations 
of the list <tt>((1 2) 3 4)</tt>.</figcaption>
<figcaption class="trans" lang="ja"><b>図5.14.:</b> <tt>((1 2) 3 4)</tt> というリストの、箱とポインタでの表現と、メモリ上のベクタでの表現</figcaption>
</figure>

<p class="orig" lang="en">
A pointer to a number, such as <tt>n4</tt>,
might consist of a type indicating numeric data together with the
actual representation of the number 4.<a name="call_footnote_Temp_749" href="#footnote_Temp_749"><sup><small>9</small></sup></a>
To deal with numbers that are too large to
be represented in the fixed amount of space allocated for a single
pointer, we could use a distinct <a name="%_idx_5880"></a><em>bignum</em> data type, for which the
pointer designates a list in which the parts of the number are
stored.<a name="call_footnote_Temp_750" href="#footnote_Temp_750"><sup><small>10</small></sup></a></p>

<p class="trans" lang="ja">
<tt>n4</tt> のような、数へのポインタは、4 という数の実際の表現をともなった、数値的データを示す型からなるかもしれない<a href="#footnote_Temp_749"><sup><small>9</small></sup></a>。
一つのポインタに対して割り当てられた固定量の空間で表現するには大きすぎる数を扱うためには、別の<em>多倍長</em>データ型——これについて、ポインタは、数の諸部分が格納されているリストを指定する——を使うこともできるだろう<a href="#footnote_Temp_750"><sup><small>10</small></sup></a>。
</p>

<p class="orig" lang="en">
<a name="%_idx_5882"></a>A symbol might be represented as a typed pointer that designates a
sequence of the characters that form the symbol's printed representation.
This sequence is constructed by the Lisp reader when the character string
is initially encountered in input.  Since we want two instances of a
symbol to be recognized as the ``same'' symbol by <tt>eq?</tt> and we
<a name="%_idx_5884"></a>want <tt>eq?</tt> to be a simple test for equality of pointers, we must
ensure that if the reader sees the same character string twice, it
will use the same pointer (to the same sequence of characters) to
represent both occurrences.  To accomplish this, the reader maintains
a table, traditionally called the <a name="%_idx_5886"></a><em>obarray</em>, of all the symbols it
has ever encountered.  When the reader encounters a character string
and is about to construct a symbol, it checks the obarray to see if it
has ever before seen the same character string.  If it has not, it
uses the characters to construct a new symbol (a typed pointer to a
new character sequence) and enters this pointer in the obarray.  If the
reader has seen the string before, it returns the symbol pointer
stored in the obarray.  This process of replacing character strings by
unique pointers is called <a name="%_idx_5888"></a><a name="%_idx_5890"></a><em>interning</em> symbols.</p>

<p class="trans" lang="ja">
記号は、その記号の印字された表現を形成している文字の並びを指定する、型つきのポインタとして、表現されるかもしれない。
この並びは、入力の中でその文字列に最初に遭遇した際に、Lisp 読み取り器により構築される。
私たちは、二つの記号が「同じだ」と <tt>eq?</tt> によって認識されてほしいし、<tt>eq?</tt> がポインタ同士の等価性のための簡潔な検査であってほしい。よって、私たちは、もし読み取り器が同じ文字列を二回見たなら、読み取り器は双方の存在を表現するのに (文字の同じ並びに対する) 同じポインタを使うだろう、ということを保証せねばならない。
これを達成するために、読み取り器は、自分が今までに遭遇したことのあるすべての記号の表——伝統的には<em><ruby><rb>obarray</rb><rp> (</rp><rt>オブジェクト配列</rt><rp>) </rp></ruby></em>と呼ばれる——を維持する。
読み取り器は、文字列に遭遇して、まさに記号を構築しようとするとき、以前に同じ文字列を見たことがあるかどうかを確かめるために obarray を調べる。
読み取り器は、もしその文字列を以前に見たことがあれば、obarray 内に格納されている記号ポインタを返す。
文字列を一意なポインタで置き換えるという、この過程は、記号の<em><ruby><rb>インターン</rb><rp> (</rp><rt>とじこめ</rt><rp>) </rp></ruby></em>と呼ばれる。
</p>


<a name="%_sec_Temp_751"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_751">Implementing the primitive list operations</a></h4>
<h4 class="trans" lang="ja">原始的なリスト演算を実装する</h4>

<p class="orig" lang="en">
<a name="%_idx_5892"></a><a name="%_idx_5894"></a>Given the above representation scheme, we can replace each
``primitive'' list operation of a register machine with one or more
primitive vector operations.  We will use two registers, <tt>the-cars</tt> and <tt>the-cdrs</tt>, to identify the memory vectors, and will
assume that <tt>vector-ref</tt> and <tt>vector-set!</tt> are available as
primitive operations.  We also assume that numeric operations on
pointers (such as incrementing a pointer, using a pair pointer to
index a vector, or adding two numbers) use only the index portion of
the typed pointer.</p>

<p class="trans" lang="ja">
上記の表現方式が与えられると、私たちは、レジスタ・マシンの各「原始的」リスト演算を、一つ以上の原始的ベクタ演算に置き換えられる。
メモリ・ベクタを識別するのに、二つのレジスタ——つまり、<tt>the-cars</tt> と <tt>the-cdrs</tt> ——を使おう。そして、原始的演算として <tt>vector-ref</tt> と <tt>vector-set!</tt> が利用可能だと仮定しよう。
また、ポインタに対する数値的演算 (ポインタをインクリメントしたり、ベクタに添え字をつけるための対ポインタを使ったり、あるいは、二つの数を足したり、といったもの) が、型つきポインタの添え字部分のみを用いる、ということも仮定する。
</p>

<p class="orig" lang="en">
For example, we can make a register machine support the instructions</p>

<p class="trans" lang="ja">
たとえば、レジスタ・マシンに次の命令をサポートさせることができる——
</p>

<a name="%_idx_5896"></a><a name="%_idx_5898"></a>
<p class="lisp">(assign &lt;<em>reg<sub>1</sub></em>&gt; (op car) (reg &lt;<em>reg<sub>2</sub></em>&gt;))

(assign &lt;<em>reg<sub>1</sub></em>&gt; (op cdr) (reg &lt;<em>reg<sub>2</sub></em>&gt;))
</p>

<p class="orig" lang="en">if we implement these, respectively, as</p>

<p class="trans" lang="ja">
もし、これらをそれぞれ以下のように実装するならば。
</p>

<p class="lisp">(assign &lt;<em>reg<sub>1</sub></em>&gt; (op vector-ref) (reg the-cars) (reg &lt;<em>reg<sub>2</sub></em>&gt;))

(assign &lt;<em>reg<sub>1</sub></em>&gt; (op vector-ref) (reg the-cdrs) (reg &lt;<em>reg<sub>2</sub></em>&gt;))
</p>

<p class="orig" lang="en">The instructions</p>

<p class="trans" lang="ja">
以下の命令は、
</p>

<a name="%_idx_5900"></a><a name="%_idx_5902"></a>

<p class="lisp">(perform (op set-car!) (reg &lt;<em>reg<sub>1</sub></em>&gt;) (reg &lt;<em>reg<sub>2</sub></em>&gt;))

(perform (op set-cdr!) (reg &lt;<em>reg<sub>1</sub></em>&gt;) (reg &lt;<em>reg<sub>2</sub></em>&gt;))
</p>

<p class="orig" lang="en">are implemented as
</p>

<p class="trans" lang="ja">
次のように実装される。
</p>

<p class="lisp">(perform
 (op vector-set!) (reg the-cars) (reg &lt;<em>reg<sub>1</sub></em>&gt;) (reg &lt;<em>reg<sub>2</sub></em>&gt;))

(perform
 (op vector-set!) (reg the-cdrs) (reg &lt;<em>reg<sub>1</sub></em>&gt;) (reg &lt;<em>reg<sub>2</sub></em>&gt;))
</p>

<p class="orig" lang="en">
<a name="%_idx_5904"></a><tt>Cons</tt> is performed by allocating an unused index and storing the
arguments to <tt>cons</tt> in <tt>the-cars</tt> and <tt>the-cdrs</tt> at that
indexed vector position.  We presume that there is a special register,
<a name="%_idx_5906"></a><tt>free</tt>, that always holds a pair pointer containing the next
available index, and that we can increment the index part of that
pointer to find the next free location.<a name="call_footnote_Temp_752" href="#footnote_Temp_752"><sup><small>11</small></sup></a>
For example, the instruction</p>

<p class="trans" lang="ja">
<tt>cons</tt> は、使われていない添え字を割り当てることと、その添え字のついたベクタ位置において、<tt>the-cars</tt> と <tt>the-cdrs</tt> の中に、<tt>cons</tt> に対する引数を格納することにより、実行される。
次に利用可能な添え字を含む対ポインタを常に保持する、<tt>free</tt> という特別なレジスタが存在する、ということを仮定し、また、次の空いている場所を見つけるためにそのポインタの添え字部分をインクリメントすることができる、と仮定する<a href="#footnote_Temp_752"><sup><small>11</small></sup></a>。
たとえば、次の命令は、
</p>

<p class="lisp">(assign &lt;<em>reg<sub>1</sub></em>&gt; (op cons) (reg &lt;<em>reg<sub>2</sub></em>&gt;) (reg &lt;<em>reg<sub>3</sub></em>&gt;))
</p>

<p class="orig" lang="en">is implemented as the following sequence of vector
operations:<a name="call_footnote_Temp_753" href="#footnote_Temp_753"><sup><small>12</small></sup></a></p>

<p class="trans" lang="ja">
以下の一連のベクタ演算として実装される<a href="#footnote_Temp_753"><sup><small>12</small></sup></a>。
</p>

<p class="lisp">(perform
 (op vector-set!) (reg the-cars) (reg free) (reg &lt;<em>reg<sub>2</sub></em>&gt;))
(perform
 (op vector-set!) (reg the-cdrs) (reg free) (reg &lt;<em>reg<sub>3</sub></em>&gt;))
(assign &lt;<em>reg<sub>1</sub></em>&gt; (reg free))
(assign free (op +) (reg free) (const 1))
</p>

<p class="orig" lang="en">The <tt>eq?</tt> operation</p>

<p class="trans" lang="ja">
<tt>eq?</tt> 演算は、
</p>

<p class="lisp">(op eq?) (reg &lt;<em>reg<sub>1</sub></em>&gt;) (reg &lt;<em>reg<sub>2</sub></em>&gt;)
</p>

<p class="orig" lang="en">simply tests the equality of all fields in the registers, and
<a name="%_idx_5910"></a><a name="%_idx_5912"></a><a name="%_idx_5914"></a><a name="%_idx_5916"></a>predicates such as <tt>pair?</tt>, <tt>null?</tt>, <tt>symbol?</tt>, and <tt>number?</tt> need only check the type field.</p>

<p class="trans" lang="ja">
単に、レジスタ内のすべてのフィールドの等価性を検査するだけであり、<tt>pair?</tt> や <tt>null?</tt> や <tt>symbol?</tt> や <tt>number?</tt> などの述語は、ただ型フィールドを調べるだけでよい。
</p>

<a name="%_sec_Temp_754"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_754">Implementing stacks</a></h4>
<h4 class="trans" lang="ja">スタックを実装する</h4>

<p class="orig" lang="en">
<a name="%_idx_5918"></a>
Although our register machines use stacks, we need do nothing special
here, since stacks can be modeled in terms of lists.  The stack can be
a list of the saved values, pointed to by a special register <tt>the-stack</tt>.  Thus, <tt>(save &lt;<em>reg</em>&gt;)</tt> can be implemented as</p>

<p class="trans" lang="ja">
私たちのレジスタ・マシンはスタックを使うが、ここでは特別なことを何もしなくてよい。というのも、リストを用いてスタックをモデル化できるからだ。
スタックは、保存された値のリストであってもよく、それは、<tt>the-stack</tt> という特別なレジスタによって指されている。
よって、
<tt>(save &lt;<em class="en">reg</em>&gt;)</tt> 
を次のように実装できる。
</p>

<a name="%_idx_5920"></a>
<p class="lisp">(assign the-stack (op cons) (reg &lt;<em>reg</em>&gt;) (reg the-stack))
</p>

<p class="orig" lang="en"><a name="%_idx_5922"></a>Similarly, <tt>(restore &lt;<em>reg</em>&gt;)</tt> can be implemented as
</p>

<p class="trans" lang="ja">
同様に、
<tt>(restore &lt;<em class="en">reg</em>&gt;)</tt> 
を次のように実装できるし、
</p>

<p class="lisp">(assign &lt;<em>reg</em>&gt; (op car) (reg the-stack))
(assign the-stack (op cdr) (reg the-stack))
</p>

<p class="orig" lang="en">and <tt>(perform (op initialize-stack))</tt> can be implemented as
</p>

<p class="trans" lang="ja">
<tt>(perform (op initialize-stack))</tt> 
を次のように実装できる。
</p>

<p class="lisp">(assign the-stack (const ()))
</p>

<p class="orig" lang="en">These operations can be further expanded in terms of the vector
operations given above.  In conventional computer architectures,
however, it is usually advantageous to allocate the stack as a
separate vector.  Then pushing and popping the stack can be
accomplished by incrementing or decrementing an index into that
vector.</p>

<p class="trans" lang="ja">
上記で与えられたベクタ演算を用いて、これらの演算をさらに拡張できる。
しかし、従来のコンピュータ・アーキテクチャでは、通常は、別個のベクタとしてスタックを割り当てるのが好都合である。
そして、スタックをプッシュしたりポップしたりすることは、そのベクタに対する添え字をインクリメントしたりデクリメントしたりすることによって、達成できる。
</p>

<p class="orig" lang="en">
<a name="%_thm_5.20"></a>
<b>Exercise 5.20.</b>  Draw the box-and-pointer representation and the memory-vector
representation (as in figure <a href="#%_fig_5.14">5.14</a>) of the
list structure produced by</p>

<p class="trans" lang="ja">
<b>練習問題5.20.</b> 以下により作り出されるリスト構造の、(図<a href="#%_fig_5.14">5.14</a>でのような) 箱とポインタによる表現およびメモリ・ベクタ表現を、描け。
</p>

<p class="lisp">(define x (cons 1 2))
(define y (list x x))
</p>

<p class="orig" lang="en">with the <tt>free</tt> pointer initially <tt>p1</tt>.  What is the final
value of <tt>free</tt> ?  What pointers represent the values of <tt>x</tt> and <tt>y</tt> ?
</p>

<p class="trans" lang="ja">
なお、ここで、<tt>free</tt> ポインタは最初 <tt>p1</tt> である。
<tt>free</tt> の最終的な値は何か?
どのポインタが、<tt>x</tt> と <tt>y</tt> の値を表しているか?
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.21"></a>
<b>Exercise 5.21.</b>  <a name="%_idx_5924"></a>Implement register machines for the following procedures.
Assume that the list-structure memory operations are available as
machine primitives.</p>

<p class="trans" lang="ja">
<b>練習問題5.21.</b> 以下の手続きについてのレジスタ・マシンを実装せよ。
リスト構造のメモリ演算が、マシンのプリミティブとして利用可能であるものと仮定せよ。
</p>

<ol class="orig alph" start="1" lang="en">
<li>Recursive <tt>count-leaves</tt>:</li>
</ol>

<ol class="trans alph" start="1" lang="ja">
<li>再帰的な <tt>count-leaves</tt>:</li>
</ol>

<p class="lisp">(define (count-leaves tree)
  (cond ((null? tree) 0)
        ((not (pair? tree)) 1)
        (else (+ (count-leaves (car tree))
                 (count-leaves (cdr tree))))))
</p>

<ol class="orig alph" start="2" lang="en">
<li>Recursive <tt>count-leaves</tt> with explicit counter:</li>
</ol>

<ol class="trans alph" start="2" lang="ja">
<li>明示的なカウンタつきの再帰的な <tt>count-leaves</tt>:</li>
</ol>

<p class="lisp">(define (count-leaves tree)
  (define (count-iter tree n)
    (cond ((null? tree) n)
          ((not (pair? tree)) (+ n 1))
          (else (count-iter (cdr tree)
                            (count-iter (car tree) n)))))
  (count-iter tree 0))
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.22"></a>
<b>Exercise 5.22.</b>  <a name="%_idx_5926"></a><a name="%_idx_5928"></a>Exercise <a href="22_sec3_3.html#%_thm_3.12">3.12</a> of section <a href="22_sec3_3.html#%_sec_3.3.1">3.3.1</a>
presented an <tt>append</tt> procedure that appends two lists to form a
new list and an <tt>append!</tt> procedure that splices two lists
together.  Design a register machine to implement each of these
procedures.  Assume that the list-structure memory operations are
available as primitive operations.
</p>

<p class="trans" lang="ja">
<b>練習問題5.22.</b> <a href="22_sec3_3.html#%_sec_3.3.1">3.3.1</a>節の練習問題<a href="22_sec3_3.html#%_thm_3.12">3.12</a>は、二つのリストを足し合わせて新たなリストを形成する <tt>append</tt> 手続きと、二つのリストを一つに継ぎ合わせる <tt>append!</tt> 手続きとを提示した。
これらの手続きの各々を実装するレジスタ・マシンを設計せよ。
リスト構造のメモリ演算が、原始的演算として利用可能であるものと仮定せよ。

</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_5.3.2"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_5.3.2">5.3.2  Maintaining the Illusion of Infinite Memory</a></h3>
<h3 class="trans" lang="ja">5.3.2 無限メモリという幻影を維持する</h3>

<a name="%_idx_5930"></a>
<p class="orig" lang="en">
The representation method outlined in
section <a href="#%_sec_5.3.1">5.3.1</a> solves the problem of implementing
list structure, provided that we have an infinite amount of memory.
With a real computer we will eventually run out of free space in which
to construct new pairs.<a name="call_footnote_Temp_758" href="#footnote_Temp_758"><sup><small>13</small></sup></a>
However, most of the pairs generated in a typical
computation are used only to hold intermediate results.  After these
results are accessed, the pairs are no longer needed -- they are <em>garbage</em>.  For instance, the computation</p>

<p class="trans" lang="ja">
<a href="#%_sec_5.3.1">5.3.1</a>節で概要を説明した表現手法は、リスト構造を実装する問題を解決する——無限の量のメモリがあるとすれば、ではあるが。
現実のコンピュータでは、新たな対を構築すべき空き場所を、遂には使い果たしてしまうだろう href="#footnote_Temp_758"><sup><small>13</small></sup></a>。
しかし、典型的な計算において生成される対のほとんどは、中間的な結果を保持するためだけに使われる。
これらの結果がアクセスされた後には、それらの対はもはや不要だ——それらは<em><ruby><rb>ごみ</rb><rp> (</rp><rt>ガーベジ</rt><rp>) </rp></ruby></em>なのだ。
たとえば、以下の計算は、
</p>

<p class="lisp">(accumulate + 0 (filter odd? (enumerate-interval 0 n)))
</p>

<p class="orig" lang="en">constructs two lists: the enumeration and the result of filtering
the enumeration.  When the accumulation is complete, these lists are
no longer needed, and the allocated memory can be reclaimed.  If we
can arrange to collect all the garbage periodically, and if this turns
out to recycle memory at about the same rate at which we construct new
pairs, we will have preserved the illusion that there is an infinite
amount of memory.</p>

<p class="trans" lang="ja">
二つのリストを構築する——数え上げと、その数え上げをフィルタにかけた結果である。
蓄積が完了すると、これらのリストはもはや不要であり、割り当てられたメモリを再利用することができる。
もし、定期的にすべてのごみを収集するように手配できるなら、かつ、これが、新たな対を構築するのとほぼ同じ速度でメモリを再利用するのだと分かれば、私たちは、無限の量のメモリが存在するのだという幻影を、保ち続けていることだろう。
</p>

<p class="orig" lang="en">
In order to recycle pairs, we must have a way to determine which
allocated pairs are not needed (in the sense that their contents can
no longer influence the future of the computation).  The method we
shall examine for accomplishing this is known as <em>garbage
collection</em>.  Garbage collection is based on the observation that, at
any moment in a Lisp interpretation, the only objects that can
affect the future of the computation are those that can be reached by
some succession of <tt>car</tt> and <tt>cdr</tt> operations starting from
the pointers that are currently in the machine registers.<a name="call_footnote_Temp_759" href="#footnote_Temp_759"><sup><small>14</small></sup></a>  Any memory cell
that is not so accessible may be recycled.</p>

<p class="trans" lang="ja">
対を再利用するためには、割り当て済みのどの対が (対の中身がもはや計算の将来に影響を与えることがあり得ない、という意味で) 不要なのかを判定する方法を持たねばならない。
これを達成するために私たちが検討することになる方法は、<em><ruby><rb>ガーベジ</rb><rp> (</rp><rt>ごみ</rt><rp>) </rp></ruby>・<ruby><rb>コレクション</rb><rp> (</rp><rt>あつめ</rt><rp>) </rp></ruby></em>として知られる。
Lisp 解釈におけるどの瞬間においても、計算の将来に影響を与えることができるオブジェクトとは、ただ、マシン・レジスタに今あるポインタから始まる、ある一連の <tt>car</tt> 演算と <tt>cdr</tt> 演算により到達できるオブジェクトだけなのだ、という観察結果に、ガーベジ・コレクションは、基づいている<a href="#footnote_Temp_759"><sup><small>14</small></sup></a>。
そのようにしてアクセス可能なのではないメモリセルは、どれも再利用されうる。
</p>

<p class="orig" lang="en">
There are many ways to perform garbage collection.  The method we
shall examine here is called <a name="%_idx_5932"></a><a name="%_idx_5934"></a><em>stop-and-copy</em>.  The basic idea is
to divide memory into two halves: ``working memory'' and ``free
memory.''  When <tt>cons</tt> constructs pairs, it allocates these in
working memory.  When working memory is full, we perform garbage
collection by locating all the useful pairs in working memory and
copying these into consecutive locations in free memory.  (The useful
pairs are located by tracing all the <tt>car</tt> and <tt>cdr</tt> pointers,
starting with the machine registers.)  Since we do not copy the
garbage, there will presumably be additional free memory that we can
use to allocate new pairs.  In addition, nothing in the working memory
is needed, since all the useful pairs in it have been copied.  Thus,
if we interchange the roles of working memory and free memory, we can
continue processing; new pairs will be allocated in the new working
memory (which was the old free memory).  When this is full, we can
copy the useful pairs into the new free memory (which was the old
working memory).<a name="call_footnote_Temp_760" href="#footnote_Temp_760"><sup><small>15</small></sup></a></p>

<p class="trans" lang="ja">
ガーベジ・コレクションを実行するには多くの方法がある。
ここで私たちが吟味することになる方法は、<em>ストップ・アンド・コピー</em>と呼ばれる。
基本的な考え方は、メモリを半分ずつに——「ワーキングメモリ」と「空きメモリ」に——分けることである。
<tt>cons</tt> は、対を構築するとき、これらの対をワーキングメモリに割り当てる。
ワーキングメモリが満杯のとき、私たちは、ワーキングメモリ中のすべての有用な対の場所を突き止めて、これらの対を空きメモリ内の連続する場所に複製することによって、ガーベジ・コレクションを行う (マシン・レジスタから始めて、すべての <tt>car</tt> ポインタと <tt>cdr</tt> ポインタを追跡することによって、有用な対の場所が突き止められる)。
ごみは複製しないので、新たな対を割り当てるのに使用可能な付加的な空きメモリが、おそらくは存在するだろう。
さらに、ワーキングメモリ中の何物も、必要ではない。というのも、ワーキングメモリ中のすべての有用な対は複製済みだからである。
よって、もしワーキングメモリと空きメモリの役割を交換すれば、処理を続けられる。新たな対は、新ワーキングメモリ内に (旧空きメモリだったところに) 割り当てられるだろう。
これが満杯になったら、新空きメモリ内に (旧ワーキングメモリだったところに) 有用な対を複製できる<a href="#footnote_Temp_760"><sup><small>15</small></sup></a>。
</p>

<a name="%_sec_Temp_761"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_761">Implementation of a stop-and-copy garbage collector</a></h4>
<h4 class="trans" lang="ja">ストップ・アンド・コピー方式のガーベジ・コレクタの実装</h4>

<p class="orig" lang="en">
We now use our register-machine language to describe the stop-and-copy
algorithm in more detail.  We will assume that there is a register
called <a name="%_idx_5966"></a><tt>root</tt> that contains a pointer to a structure that
eventually points at all accessible data.  This can be arranged by
storing the contents of all the machine registers in a
pre-allocated list pointed at by <tt>root</tt> just before starting
garbage collection.<a name="call_footnote_Temp_762" href="#footnote_Temp_762"><sup><small>16</small></sup></a> We also assume that, in addition to the
current working memory, there is free memory available into which we
can copy the useful data.  The current working memory consists of
vectors whose base addresses are in <a name="%_idx_5968"></a><a name="%_idx_5970"></a>registers called <tt>the-cars</tt>
and <tt>the-cdrs</tt>, and the free memory is in registers called <a name="%_idx_5972"></a><a name="%_idx_5974"></a><tt>new-cars</tt> and <tt>new-cdrs</tt>.</p>

<p class="trans" lang="ja">
ここで、私たちのレジスタ・マシン言語を用いて、より詳しくストップ・アンド・コピー・アルゴリズムを記述する。
アクセス可能なすべてのデータを最終的には指している構造へのポインタを含む、<tt>root</tt> と呼ばれるレジスタがある、と仮定する。
これは、<tt>root</tt> により指された、予め割り当てられたリストに、ガーベジ・コレクションを始める直前に、すべてのマシン・レジスタの中身を格納することによって、手筈を整えることができる<a href="#footnote_Temp_762"><sup><small>16</small></sup></a>。
また、有用なデータを複製できるような、利用可能な空きメモリが、現在のワーキングメモリに加えて更に存在する、ということも仮定する。
現在のワーキングメモリは、<tt>the-cars</tt> および <tt>the-cdrs</tt> と呼ばれるレジスタにベース・アドレスがあるようなベクタからなり、空きメモリの方は、<tt>new-cars</tt> および <tt>new-cdrs</tt> と呼ばれるレジスタにある。
</p>

<p class="orig" lang="en">
Garbage collection is triggered when we exhaust the free cells in the
current working memory, that is, when a <tt>cons</tt> operation attempts
to increment the <tt>free</tt> pointer beyond the end of the memory
vector.  When the garbage-collection process is complete, the <tt>root</tt> pointer will point into the new memory, all objects accessible
from the <tt>root</tt> will have been moved to the new memory, and the
<tt>free</tt> pointer will indicate the next place in the new memory
where a new pair can be allocated.  In addition, the roles of working
memory and new memory will have been interchanged -- new pairs will be
constructed in the new memory, beginning at the place indicated by
<tt>free</tt>, and the (previous) working memory will be available as the
new memory for the next garbage collection.
Figure <a href="#%_fig_5.15">5.15</a> shows the arrangement of memory just
before and just after garbage collection.</p>

<p class="trans" lang="ja">
ガーベジ・コレクションは、現在のワーキングメモリ内の空きセルを使い果たしたとき——つまり、<tt>cons</tt> 演算が、メモリ・ベクタの末尾よりも先へと <tt>free</tt> ポインタをインクリメントしようと試みたとき——に、引き起こされる。
ガーベジ・コレクション・プロセスが完了すると、<tt>root</tt> ポインタは新たなメモリ内を指していることだろうし、<tt>root</tt> からアクセス可能なすべてのオブジェクトはその新たなメモリへ移動済みになっているだろうし、<tt>free</tt> ポインタはその新たなメモリ内で新たな対を割り当て可能な次の場所を示していることだろう。
さらに、ワーキングメモリと新たなメモリの役割が入れ替わっていることだろう——つまり、新たな対は、<tt>free</tt> により示される場所から始まる新たなメモリ内に構築されるだろう——し、(以前の) ワーキングメモリが次のガーベジ・コレクションでは新たなメモリとして利用可能になるだろう。
図<a href="#%_fig_5.15">5.15</a>は、ガーベジ・コレクションの直前と直後のメモリの配置を示している。
</p>

<figure>
<a name="%_fig_5.15"></a>
<img src="ch5-Z-G-8.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 5.15:</b>  Reconfiguration of memory by the garbage-collection 
process.</figcaption>
<figcaption class="trans" lang="ja"><b>図5.15:</b> ガーベジ・コレクション・プロセスによるメモリの再構成</figcaption>
</figure>

<p class="orig" lang="en">
<a name="%_idx_5976"></a><a name="%_idx_5978"></a>The state of the garbage-collection process is controlled by
maintaining two pointers: <tt>free</tt> and <tt>scan</tt>.  These are
initialized to point to the beginning of the new memory.  The
algorithm begins by relocating the pair pointed at by <tt>root</tt> to
the beginning of the new memory.  The pair is copied, the <tt>root</tt>
pointer is adjusted to point to the new location, and the <tt>free</tt>
pointer is incremented.  In addition, the old location of the pair is
marked to show that its contents have been moved.  This marking is
done as follows: In the <tt>car</tt> position, we place a special tag
that signals that this is an already-moved object.  (Such an object is
traditionally called a <a name="%_idx_5980"></a><em>broken heart</em>.)<a name="call_footnote_Temp_763" href="#footnote_Temp_763"><sup><small>17</small></sup></a>  In the <tt>cdr</tt> position we place a <a name="%_idx_5988"></a><em>forwarding
address</em> that points at the location to which the object has been
moved.</p>

<p class="trans" lang="ja">
ガーベジ・コレクション・プロセスの状態は、二つのポインタ—— <tt>free</tt> と <tt>scan</tt> ——を維持することによって、制御される。
これらは、新たなメモリの先頭を指すように、初期化される。
本アルゴリズムは、<tt>root</tt> によって指されている対を、新たなメモリ先頭へと再配置することから始まる。
その対を複製し、新たな場所を指すように <tt>root</tt> ポインタを調整し、<tt>free</tt> ポインタをインクリメントする。
さらに、その対のかつての場所には、その中身が移動済みだと示すように、印をつける。
この印づけは、次のように行われる。
<tt>car</tt> 位置には、これは既に移動されたオブジェクトなのだと知らせる、特別なタグを置く
(そうしたオブジェクトは、伝統的には<ruby><rb>失意</rb><rp> (</rp><rt>ブロークン・ハート</rt><rp>) </rp></ruby>と呼ばれる)<a name="call_footnote_Temp_763" href="#footnote_Temp_763"><sup><small>17</small></sup></a>。
<tt>cdr</tt> 位置には、そのオブジェクトが移動された先の位置を指す、<em>転送先アドレス</em>を置く。
</p>

<p class="orig" lang="en">
After relocating the root, the garbage collector enters its basic
cycle.  At each step in the algorithm, the <tt>scan</tt> pointer
(initially pointing at the relocated root) points at a pair that has
been moved to the new memory but whose <tt>car</tt> and <tt>cdr</tt>
pointers still refer to objects in the old memory.  These objects are
each relocated, and the <tt>scan</tt> pointer is incremented.  To
relocate an object (for example, the object indicated by the <tt>car</tt>
pointer of the pair we are scanning) we check to see if the object has
already been moved (as indicated by the presence of a broken-heart tag
in the <tt>car</tt> position of the object).  If the object has not
already been moved, we copy it to the place indicated by <tt>free</tt>,
update <tt>free</tt>, set up a broken heart at the object's old location,
and update the pointer to the object (in this
example, the <tt>car</tt> pointer of the pair we are scanning) to point
to the new location.  If the object has already been moved, its
forwarding address (found in the <tt>cdr</tt> position of the broken
heart) is substituted for the pointer in the pair being scanned.
Eventually, all accessible objects will have been moved and scanned,
at which point the <tt>scan</tt> pointer will overtake the <tt>free</tt>
pointer and the process will terminate.</p>

<p class="trans" lang="ja">
<ruby><rb>根</rb><rp> (</rp><rt>ルート</rt><rp>) </rp></ruby> を再配置した後、ガーベジ・コレクタは、基本的サイクルに入る。
本アルゴリズムの各ステップにおいて、<tt>scan</tt> ポインタ (最初は、再配置されたルートを指している) は、新たなメモリに移動済みだけれども自分の <tt>car</tt> ポインタと <tt>cdr</tt> ポインタはまだかつてのメモリ内のオブジェクトを参照している、という対を、指している。
これらのオブジェクトをそれぞれ再配置し、<tt>scan</tt> ポインタをインクリメントする。
あるオブジェクト (たとえば、いま走査している最中の対の <tt>car</tt> ポインタにより示されるオブジェクト) を再配置するには、そのオブジェクトが既に移動されているかどうか (そのオブジェクトの <tt>car</tt> 位置のブロークン・ハート・タグの存在によって示される) を調べる。
もしそのオブジェクトが移動済みでなければ、<tt>free</tt> により示される場所にそのオブジェクトを複製し、<tt>free</tt> を更新し、そのオブジェクトのかつての場所にブロークン・ハートを設定し、そのオブジェクトへのポインタ (この例では、いま走査している最中の対の <tt>car</tt> ポインタ) を、新たな位置を指すように更新する。
もしそのオブジェクトが移動済みなら、いま走査している最中の対のポインタを、その転送先アドレス (ブロークン・ハートの <tt>cdr</tt> 位置で見つかる) に置き換える。
最後には、アクセス可能なすべてのオブジェクトが移動済みかつ走査済みとなることだろう。そして、その時点で、<tt>scan</tt> ポインタが <tt>free</tt> ポインタを追い越しているだろうし、プロセスが終了するだろう。
</p>

<p class="orig" lang="en">
We can specify the stop-and-copy algorithm as a sequence of
instructions for a register
machine.  The basic step of relocating an object is accomplished by a
subroutine called <tt>relocate-old-result-in-new</tt>.  This
subroutine gets its argument, a pointer to the object to be relocated,
from a register named <a name="%_idx_5990"></a><tt>old</tt>.  It relocates the designated object
(incrementing <tt>free</tt> in the process),
puts a pointer to the relocated object into a register called <a name="%_idx_5992"></a><tt>new</tt>, and returns by branching to the entry point stored in the register
<tt>relocate-continue</tt>.  To begin garbage collection, we invoke this
subroutine to relocate the <tt>root</tt> pointer, after initializing <tt>free</tt> and <tt>scan</tt>.  When the relocation of <tt>root</tt> has been
accomplished, we install the new pointer as the new <tt>root</tt> and
enter the main loop of the garbage collector.</p>

<p class="trans" lang="ja">
ストップ・アンド・コピー・アルゴリズムを、レジスタ・マシン用の命令列として、規定できる。
オブジェクトを再配置する基本的ステップは、<tt>relocate-old-result-in-new</tt> と呼ばれるサブルーチンにより達成される。
このサブルーチンは、引数——すなわち、再配置すべきオブジェクトへのポインタ——を、<tt>old</tt> という名前のレジスタから得る。
このサブルーチンは、指定されたオブジェクトを再配置し (その過程で <tt>free</tt> をインクリメントする)、再配置したオブジェクトへのポインタを <tt>new</tt> という名前のレジスタに入れ、<tt>relocate-continue</tt> というレジスタに記憶されているエントリ・ポイントへと分岐することによって戻る。
ガーベジ・コレクションを始めるには、<tt>free</tt> と <tt>scan</tt> を初期化し手から、このサブルーチンを呼び出して <tt>root</tt> ポインタを再配置する。
<tt>root</tt> の再配置を成し遂げたら、新たなポインタを新たな <tt>root</tt> として組み込み、ガーベジ・コレクタのメイン・ループに入る。
</p>

<p class="lisp">begin-garbage-collection
  (assign free (const 0))
  (assign scan (const 0))
  (assign old (reg root))
  (assign relocate-continue (label reassign-root))
  (goto (label relocate-old-result-in-new))
reassign-root
  (assign root (reg new))
  (goto (label gc-loop))
</p>

<p class="orig" lang="en">
In the main loop of the garbage collector we must determine whether
there are any more objects to be scanned.  We do this by testing
whether the <tt>scan</tt> pointer is coincident with the <tt>free</tt>
pointer.  If the pointers are equal, then all accessible objects have
been relocated, and we branch to <tt>gc-flip</tt>, which cleans things up
so that we can continue the interrupted computation.  If there are
still pairs to be scanned, we call the relocate subroutine to relocate
the <tt>car</tt> of the next pair (by placing the <tt>car</tt> pointer in <tt>old</tt>).  The <tt>relocate-continue</tt> register is set up so that the
subroutine will return to update the <tt>car</tt> pointer.</p>

<p class="trans" lang="ja">
ガーベジ・コレクタのメイン・ループでは、走査すべきオブジェクトがさらにあるかどうかを判定せねばならない。
私たちはこれを、<tt>scan</tt> ポインタが <tt>free</tt> ポインタと一致するかどうかを調べることによって、行う。
もしポインタ同士が等しければ、アクセス可能なすべてのオブジェクトは再配置済みであり、<tt>gc-flip</tt> ——割り込まれた計算を続行できるように、ものを片付ける——へと分岐する。
もし走査すべき対がまだあれば、再配置サブルーチンを呼び出して、次の対の <tt>car</tt> を再配置する (<tt>car</tt> ポインタを <tt>old</tt> に置くことによって)。
<tt>relocate-continue</tt> レジスタは、サブルーチンが戻って <tt>car</tt> ポインタを更新するように、設定される。
</p>

<p class="lisp">gc-loop
  (test (op =) (reg scan) (reg free))
  (branch (label gc-flip))
  (assign old (op vector-ref) (reg new-cars) (reg scan))
  (assign relocate-continue (label update-car))
  (goto (label relocate-old-result-in-new))
</p>

<p class="orig" lang="en">
At <tt>update-car</tt>, we modify the <tt>car</tt> pointer of the pair being
scanned, then proceed to relocate the <tt>cdr</tt> of the pair.  We
return to <tt>update-cdr</tt> when that relocation has been accomplished.
After relocating and updating the <tt>cdr</tt>, we are finished scanning
that pair, so we continue with the main loop.</p>

<p class="trans" lang="ja">
<tt>update-car</tt> では、走査中の対の <tt>car</tt> ポインタを改変し、それから、その対の <tt>cdr</tt> の再配置を始める。
その再配置を成し遂げたら、<tt>update-cdr</tt> へと戻る。
<tt>cdr</tt> を再配置して更新し終わったら、その対を走査するのを終えているわけで、すると、メイン・ループを続行する。
</p>

<p class="lisp">update-car
  (perform
   (op vector-set!) (reg new-cars) (reg scan) (reg new))
  (assign old (op vector-ref) (reg new-cdrs) (reg scan))
  (assign relocate-continue (label update-cdr))
  (goto (label relocate-old-result-in-new))

update-cdr
  (perform
   (op vector-set!) (reg new-cdrs) (reg scan) (reg new))
  (assign scan (op +) (reg scan) (const 1))
  (goto (label gc-loop))
</p>

<p class="orig" lang="en">
The subroutine <tt>relocate-old-result-in-new</tt> relocates objects as
follows: If the object to be relocated (pointed at by <tt>old</tt>) is
not a pair, then we return the same pointer to the object unchanged
(in <tt>new</tt>).  (For example, we may be scanning a pair whose <tt>car</tt> is the number 4.  If we represent the <tt>car</tt> by <tt>n4</tt>, as
described in section <a href="#%_sec_5.3.1">5.3.1</a>, then we want the
``relocated'' <tt>car</tt> pointer to still be <tt>n4</tt>.)  Otherwise, we
must perform the relocation.  If the <tt>car</tt> position of the pair to
be relocated contains a broken-heart tag, then the pair has in fact
already been moved, so we retrieve the forwarding address (from the
<tt>cdr</tt> position of the broken heart) and return this in <tt>new</tt>.
If the pointer in <tt>old</tt> points at a yet-unmoved pair, then we move
the pair to the first free cell in new memory (pointed at by <tt>free</tt>) and set up the broken heart by storing a broken-heart tag and
forwarding address at the old location.
<tt>Relocate-old-result-in-new</tt> uses a register <a name="%_idx_5994"></a><tt>oldcr</tt>
to hold the <tt>car</tt> or the <tt>cdr</tt> of the object pointed at by
<tt>old</tt>.<a name="call_footnote_Temp_764" href="#footnote_Temp_764"><sup><small>18</small></sup></a></p>

<p class="trans" lang="ja">
<tt>relocate-old-result-in-new</tt> というサブルーチンは、以下のようにオブジェクトを再配置する。
もし再配置すべきオブジェクト (<tt>old</tt> により指されている) が対でなければ、そのままのオブジェクトへの同じポインタを (<tt>new</tt> の中に) 返す
(たとえば、<tt>car</tt> が 4 という数であるような対を、走査しているところなのかもしれない。<a href="#%_sec_5.3.1">5.3.1</a>節で説明したように、その <tt>car</tt> を <tt>n4</tt> により表しているならば、「再配置済みの」<tt>car</tt> ポインタには、依然として <tt>n4</tt> であってほしいわけだ)。
それ以外の場合、再配置を実行しなくてはならない。
もし、再配置すべき対の <tt>car</tt> 位置がブロークン・ハート・タグを含んでいれば、その対は実際は移動済みであり、したがって、転送先アドレスを (ブロークン・ハートの <tt>cdr</tt> 位置から) 取り出して、これを <tt>new</tt> の中に返す。
もし、<tt>old</tt> にあるポインタが、まだ移動されていない対を指していたら、新たなメモリにおける最初の空きセル (<tt>free</tt> により指されている) へとその対を移動させ、ブロークン・ハート・タグと転送先アドレスとを古い場所に格納することによってブロークン・ハートを設定する。
<tt>relocate-old-result-in-new</tt> は、<tt>old</tt> により指されているオブジェクトの <tt>car</tt> または <tt>cdr</tt> を保持するために、<tt>oldcr</tt> というレジスタを使う<a href="#footnote_Temp_764"><sup><small>18</small></sup></a>。
</p>

<p class="lisp">relocate-old-result-in-new
  (test (op pointer-to-pair?) (reg old))
  (branch (label pair))
  (assign new (reg old))
  (goto (reg relocate-continue))
pair
  (assign oldcr (op vector-ref) (reg the-cars) (reg old))
  (test (op broken-heart?) (reg oldcr))
  (branch (label already-moved))
  (assign new (reg free)) <em>; new location for pair</em>
  <em>;; Update <tt>free</tt> pointer.</em>
  (assign free (op +) (reg free) (const 1))
  <em>;; Copy the <tt>car</tt> and <tt>cdr</tt> to new memory.</em>
  (perform (op vector-set!)
           (reg new-cars) (reg new) (reg oldcr))
  (assign oldcr (op vector-ref) (reg the-cdrs) (reg old))
  (perform (op vector-set!)
           (reg new-cdrs) (reg new) (reg oldcr))
  <em>;; Construct the broken heart.</em>
  (perform (op vector-set!)
           (reg the-cars) (reg old) (const broken-heart))
  (perform
   (op vector-set!) (reg the-cdrs) (reg old) (reg new))
  (goto (reg relocate-continue))
already-moved
  (assign new (op vector-ref) (reg the-cdrs) (reg old))
  (goto (reg relocate-continue))
</p>

<p class="orig" lang="en">
At the very end of the garbage-collection process, we interchange the
role of old and new memories by interchanging pointers: interchanging
<tt>the-cars</tt> with <tt>new-cars</tt>, and <tt>the-cdrs</tt> with <tt>new-cdrs</tt>.  We will then be ready to perform another garbage
collection the next time memory runs out.</p>

<p class="trans" lang="ja">
ガーベジ・コレクション・プロセスの本当の最後において、ポインタ同士を入れ替えることにより、旧メモリと新メモリの役割を入れ替える。つまり、<tt>the-cars</tt> と <tt>new-cars</tt> を入れ替え、<tt>the-cdrs</tt> と <tt>new-cdrs</tt> を入れ替えるのだ。
すると、次にメモリが尽きたときに別のガーベジ・コレクションを実行する準備が、整うであろう。
</p>

<p class="lisp">gc-flip
  (assign temp (reg the-cdrs))
  (assign the-cdrs (reg new-cdrs))
  (assign new-cdrs (reg temp))
  (assign temp (reg the-cars))
  (assign the-cars (reg new-cars))
  (assign new-cars (reg temp))
</p>

<a name="footnotes"></a>
<hr>
<p class="orig" lang="en"><a name="footnote_Temp_744" href="#call_footnote_Temp_744"><sup><small>5</small></sup></a> We could represent memory as lists of items.
However, the access time would then not be independent of the index,
since accessing the <em>n</em>th element of a list requires <em>n</em> - 1 <tt>cdr</tt>
operations.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_744"><sup><small>5</small></sup></a>
項目のリストとしてメモリを表現することも、可能であっただろう。
しかし、そうすると、アクセス時間が、添え字とは独立にはならないだろう。なぜなら、リストの <em class="en">n</em> 番目の要素にアクセスすることは、
<span class="math"><em class="en">n</em> &minus; 1</span>
回の <tt>cdr</tt> 操作を必要とするためである。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_745" href="#call_footnote_Temp_745"><sup><small>6</small></sup></a> For completeness, we should specify a <tt>make-vector</tt>
operation that constructs vectors.  However, in the present
application we will use vectors only to model fixed divisions of the
computer memory.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_745"><sup><small>6</small></sup></a> 
完全性のためには、私たちは、ベクタを構築する <tt>make-vector</tt> 操作を規定すべきである。
しかし、目下の応用においては、コンピュータ・メモリの固定的な分割をモデル化することのためだけに、ベクタを使おう。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_747" href="#call_footnote_Temp_747"><sup><small>7</small></sup></a> This is
precisely the same <a name="%_idx_5864"></a><a name="%_idx_5866"></a>``tagged data'' idea we introduced in chapter 2 for
dealing with generic operations.  Here, however, the data types are
included at the primitive machine level rather than constructed
through the use of lists.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_747"><sup><small>7</small></sup></a> 
これは、総称的演算を扱うために2章で導入した「タグ付けされたデータ」の考え方と、まさに同じである。
しかし、ここでは、データ型は、リストの使用を通じて構築されるのではなく、むしろ、原始的なマシン・レベルに含まれている。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_748" href="#call_footnote_Temp_748"><sup><small>8</small></sup></a> Type information may be encoded in a variety of
ways, depending on the details of the machine on which the Lisp
system is to be implemented.  The execution efficiency of Lisp
programs will be strongly dependent on how cleverly this choice is
made, but it is difficult to formulate general design rules for good
choices.  The most straightforward way to implement typed pointers is
to allocate a fixed set of bits in each pointer to be a <a name="%_idx_5870"></a><em>type
field</em> that encodes the data type.  Important questions to be
addressed in designing such a representation include the following:
How many type bits are required?  How large must the vector indices
be?  How efficiently can the primitive machine instructions be used to
manipulate the type fields of pointers?  Machines that include special
hardware for the efficient handling of type fields are said to have
<a name="%_idx_5872"></a><em>tagged architectures</em>.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_748"><sup><small>8</small></sup></a>
型情報は、その上に Lisp システムを実装するべきマシンの詳細に応じて、多様な方法で符号化され得る。
Lisp プログラムの実行効率は、この選択がどれほど賢くなされたか、ということに強く依存するだろうが、良い選択のための一般的な設計規則を定式化するのは困難だ。
型つきポインタを実装するための最も分かりやすい方法は、各ポインタの中の所定のビット一揃いを、データ型を符号化する<em>型フィールド</em>となるよう、割り当てることである。
そうした表現を設計するうえで対処すべき重要な疑問点には、次のようなものがある。
型ビットはどれくらい多く必要か?
ベクトルの添え字は、どれほど大きくなくてはならないか?
原始的マシン命令を使って、どれほど効率的にポインタの型フィールドを操作できるか?
型フィールドの効率的な取り扱いのための特別なハードウェアを含むマシンは、<em>タグつきアーキテクチャ</em>を有する、と言われる。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_749" href="#call_footnote_Temp_749"><sup><small>9</small></sup></a> This decision on the
<a name="%_idx_5874"></a><a name="%_idx_5876"></a><a name="%_idx_5878"></a>representation of numbers determines whether <tt>eq?</tt>, which tests
equality of pointers, can be used to test for equality of numbers.  If
the pointer contains the number itself, then equal numbers will have
the same pointer.  But if the pointer contains the index of a location
where the number is stored, equal numbers will be guaranteed to have
equal pointers only if we are careful never to store the same number
in more than one location.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_749"><sup><small>9</small></sup></a> 
数の表現に関する決定は、数同士の等価性を検査するのに <tt>eq?</tt> ——ポインタ同士の等価性を検査する——が使えるかどうかを左右する。
もしポインタが数そのものを含んでいれば、等しい数同士は、同じポインタを有するだろう。
しかし、もしポインタが、数が格納されている場所の添え字を含んでいれば、一箇所よりも多くの場所には同じ数を決して格納しないように気をつける場合にしか、等しい数同士が等しいポインタを有するとは保証されないだろう。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_750" href="#call_footnote_Temp_750"><sup><small>10</small></sup></a> This is just like writing a number as a sequence of
digits, except that each ``digit'' is a number between 0 and the
largest number that can be stored in a single pointer.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_750"><sup><small>10</small></sup></a>
これは、桁の並びとして数を書くこととちょうど同様である——各「桁」が、0 と、一つのポインタに格納できる最大の数との間の数である、という点を除いては。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_752" href="#call_footnote_Temp_752"><sup><small>11</small></sup></a> There are other ways
of finding free storage.  For example, we could link together all the
unused pairs into a <a name="%_idx_5908"></a><em>free list</em>.  Our free locations are
consecutive (and hence can be accessed by incrementing a pointer)
because we are using a compacting garbage collector, as we will see in
section <a href="#%_sec_5.3.2">5.3.2</a>.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_752"><sup><small>11</small></sup></a>
空いている記憶装置を見つける、別の方法もある。
たとえば、使われていない対すべてを一緒につなげて、<em>空きリスト</em>とすることもできるだろう。
私たちの空き場所は連続している (したがって、ポインタをインクリメントすることでアクセスできる) のだが、これは、<a href="#%_sec_5.3.2">5.3.2</a>節で見ることになるように、<ruby><rb>圧縮型の</rb><rp> (</rp><rt>コンパクティング</rt><rp>) </rp></ruby>ガーベジ・コレクタを使っているためである。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_753" href="#call_footnote_Temp_753"><sup><small>12</small></sup></a> This is essentially the implementation of <tt>cons</tt> in terms of <tt>set-car!</tt> and <tt>set-cdr!</tt>, as described in
section <a href="22_sec3_3.html#%_sec_3.3.1">3.3.1</a>.  The operation <tt>get-new-pair</tt> used in that implementation is realized here by the <tt>free</tt> pointer.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_753"><sup><small>12</small></sup></a>
これは、本質的には、<a href="22_sec3_3.html#%_sec_3.3.1">3.3.1</a>節で説明したような、<tt>set-car!</tt> と <tt>set-cdr!</tt> を用いた <tt>cons</tt> の実装である。
その実装において用いた <tt>get-new-pair</tt> という演算は、ここでは、<tt>free</tt> ポインタにより実現される。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_758" href="#call_footnote_Temp_758"><sup><small>13</small></sup></a> This may not be true eventually,
because memories may get large enough so that it would be impossible
to run out of free memory in the lifetime of the computer.  For
example, there are about 3&times; 10<sup>13</sup>, microseconds in a year, so
if we were to <tt>cons</tt> once per microsecond we would need about
10<sup>15</sup> cells of memory to build a machine that could operate for 30
years without running out of memory.  That much memory seems absurdly
large by today's standards, but it is not physically impossible.  On
the other hand, processors are getting faster and a future computer
may have large numbers of processors operating in parallel on a single
memory, so it may be possible to use up memory much faster than we
have postulated.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_758"><sup><small>13</small></sup></a>
ゆくゆくは、これは本当ではなくなるかもしれない。なぜなら、コンピュータの寿命の間には空きメモリを使い果たすのが不可能となるように、メモリが十分大規模になるかもしれないから。
たとえば、一年には約
<span class="math">3 &times; 10<sup>13</sup></span>
マイクロ秒あり、よって、もし1マイクロ秒ごとに一度 <tt>cons</tt> するつもりだったとすると、メモリを使い果たさずに30年間動けるマシンを構築するには、メモリのセルを約 10<sup>15</sup> 個、必要とすることだろう。
そうした大量のメモリは、今日の標準によれば馬鹿げたほど大規模なように見えるが、物理的に不可能なわけではない。
一方で、プロセッサは高速化しているし、将来のコンピュータは、一つのメモリに対して並列に動作する多数のプロセッサを有しているかもしれない。そうすると、私たちが仮定したのよりもずっと速く、メモリを使い果たすこともあり得る。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_759" href="#call_footnote_Temp_759"><sup><small>14</small></sup></a> We
assume here that the stack is represented as a list as described in
section <a href="#%_sec_5.3.1">5.3.1</a>, so that items on the stack are
accessible via the pointer in the stack register.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_759"><sup><small>14</small></sup></a>
ここでは、<a href="#%_sec_5.3.1">5.3.1</a>節で説明したように、スタックがリストとして表現されているものと仮定しており、その結果、スタック上の項目は、スタック・レジスタのポインタを介してアクセス可能である。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_760" href="#call_footnote_Temp_760"><sup><small>15</small></sup></a> This idea was invented and first implemented
<a name="%_idx_5936"></a>by Minsky, as part of the implementation of <a name="%_idx_5938"></a>Lisp for the PDP-1 at the
<a name="%_idx_5940"></a>MIT Research Laboratory of Electronics.  It was further developed by
<a name="%_idx_5942"></a><a name="%_idx_5944"></a>Fenichel and Yochelson (1969) for use in the Lisp implementation for
<a name="%_idx_5946"></a>the Multics time-sharing system.  Later, <a name="%_idx_5948"></a>Baker (1978) developed a
``real-time'' version of the method, which does not require the
computation to stop during garbage collection.  Baker's idea was
extended by <a name="%_idx_5950"></a><a name="%_idx_5952"></a><a name="%_idx_5954"></a>Hewitt, Lieberman, and Moon (see Lieberman and Hewitt
1983) to take advantage of the fact that some structure is more volatile
and other structure is more permanent.  </p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_760"><sup><small>15</small></sup></a>
この考えは、ミンスキーによって、考案され、最初に——MIT 電子工学調査研究所において PDP-1 用の Lisp 処理系の一部として——実装された。
これはさらに、Multics のタイムシェアリング・システム用の Lisp 処理系で使うために、Fenichel and Yochelson (1969) によって開発された。
後に、Baker (1978) は、本手法の「リアルタイム」版を開発したが、これは、ガーベジ・コレクションの間に計算が停止するよう要求したりはしない。
ある種の構造は揮発性がより高く、他の構造は永続性がより高い、という事実を利用するよう、Baker の考えは Hewitt と Lieberman と Moon により拡張された (Lieberman and Hewitt 1983 を参照)。
</p>

<p class="orig" lang="en">
An alternative commonly used garbage-collection technique is the <a name="%_idx_5956"></a><a name="%_idx_5958"></a><em>mark-sweep</em> method.  This consists of tracing all the structure
accessible from the machine registers and marking each pair we reach.
We then scan all of memory, and any location that is unmarked is
``swept up'' as garbage and made available for reuse.  A full
<a name="%_idx_5960"></a>discussion of the mark-sweep method can be found in Allen 1978.</p>

<p class="trans" lang="ja">
よく使われる別のガーベジ・コレクション技法は、<em>マーク・スイープ</em>法である。
これは、マシン・レジスタからアクセス可能なすべての構造を追跡することと、たどり着く先のそれぞれの対に印をつけることから、成り立っている。
それから、メモリ全体を走査し、印のついていないどの場所をも、ごみとして「掃き捨て」て、再利用のために使えるようにする。
マーク・スイープ法についての詳細な議論は、Allen 1978 で見つかる。
</p>

<p class="orig" lang="en">
The Minsky-Fenichel-Yochelson algorithm is the dominant algorithm in
use for large-memory systems because it examines only the useful part
of memory.  This is in contrast to mark-sweep, in which the sweep
phase must check all of memory.  A second advantage of stop-and-copy
is that it is a <a name="%_idx_5962"></a><a name="%_idx_5964"></a><em>compacting</em> garbage collector.  That is, at the
end of the garbage-collection phase the useful data will have been
moved to consecutive memory locations, with all garbage pairs
compressed out.  This can be an extremely important performance
consideration in machines with virtual memory, in which accesses to
widely separated memory addresses may require extra paging
operations.</p>

<p class="trans" lang="ja">
Minsky-Fenichel-Yochelson アルゴリズムは、大規模メモリ型のシステムに使われている主要なアルゴリズムである。なぜなら、これは、メモリの有用な部分のみを調べるからである。
これは、マーク・スイープ——スイープ段階でメモリ全体を調べなくてはならない——とは対照的である。
ストップ・アンド・コピーの第二の利点は、これが<em>圧縮型の</em>ガーベジ・コレクタである、という点である。
すなわち、ガーベジ・コレクション段階の最後には、連続的なメモリ上の場所に有用なデータが移動されていることになるだろうし、その際、ごみの対はすべて圧縮されて押し出されている。
これは、仮想メモリ——広範囲に分離したメモリ・アドレスへのアクセスが、余計なページング操作を必要とするかもしれない——を有するマシンにおける、非常に重要な性能上の論点となる可能性がある。
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_762" href="#call_footnote_Temp_762"><sup><small>16</small></sup></a> This list of registers does not include
the registers used by the storage-allocation system -- <tt>root</tt>, <tt>the-cars</tt>, <tt>the-cdrs</tt>, and the other registers that will be
introduced in this section.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_762"><sup><small>16</small></sup></a>
このレジスタのリストは、記憶割り当てシステムにより使われるレジスタ—— <tt>root</tt> や <tt>the-cars</tt> や <tt>the-cdrs</tt> や、本節で導入されるであろう他のレジスタ——を含まない。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_763" href="#call_footnote_Temp_763"><sup><small>17</small></sup></a> The term <em><a name="%_idx_5982"></a>broken heart</em> was coined by David Cressey, who wrote a garbage
collector for <a name="%_idx_5984"></a><a name="%_idx_5986"></a>MDL, a dialect of Lisp developed at MIT during the early
1970s.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_763"><sup><small>17</small></sup></a>
<em><ruby><rb>失意</rb><rp> (</rp><rt>ブロークン・ハート</rt><rp>) </rp></ruby></em>という用語は、David Cressey ——1970年代初頭に MIT で開発された、Lisp の方言である MDL のための、ガーベジ・コレクタを書いた——により、作られた。
</p>

<p class="orig" lang="en"><a name="footnote_Temp_764" href="#call_footnote_Temp_764"><sup><small>18</small></sup></a> The garbage collector uses the low-level predicate
<tt>pointer-to-pair?</tt> instead of the list-structure <tt>pair?</tt>
operation because in a real system there might be various things
that are treated as pairs for garbage-collection purposes.
For example, in a Scheme system that conforms to the IEEE standard
a procedure object may be implemented as a special kind of ``pair''
that doesn't satisfy the <tt>pair?</tt> predicate.
For simulation purposes, <tt>pointer-to-pair?</tt> can be implemented as
<tt>pair?</tt>.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_764"><sup><small>18</small></sup></a> 
ガーベジ・コレクタは、リスト構造の <tt>pair?</tt> 演算の代わりに、<tt>pointer-to-pair?</tt> という低水準の述語を用いる。なぜなら、ガーベジ・コレクションの目的では対として扱われる様々なものが、現実のシステムには存在するかもしれないからである。
たとえば、IEEE 標準に合致する Scheme システムでは、手続きオブジェクトが、<tt>pair?</tt> 述語を満たさないような特別な種類の「対」として、実装されてもよい。
シミュレーション目的では、<tt>pointer-to-pair?</tt> を <tt>pair?</tt> として実装できる。
</p>


</div>
</body>
</html>
