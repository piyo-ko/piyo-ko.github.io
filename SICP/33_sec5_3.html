<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="sicp.css" type="text/css">
<base target="_top">
<title>SICPç§è¨³: 5.3 è¨˜æ†¶å‰²ã‚Šå½“ã¦ã¨ã‚¬ãƒ¼ãƒ™ã‚¸ãƒ»ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ (ã”ã¿ã‚ã¤ã‚) </title>
<link rel="canonical" href="https://piyo-ko.github.io/SICP/33_sec5_3.html" />
</head>
<body>

<div class="idx-bar">
<nav>
<a href="https://twitter.com/share" class="twitter-share-button" data-lang="ja">ãƒ„ã‚¤ãƒ¼ãƒˆ</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
<span class="status">æ¨æ•²å¾…ã¡</span>
[
<a href="00_cover.html">å…ˆé ­ã¸</a> |
<a href="32_sec5_2.html">å‰ã¸</a> |
<a href="34_sec5_4.html">æ¬¡ã¸</a> |
<a href="04_toc.html#%_toc_start">ç›®æ¬¡</a> |
<a href="38_index.html#%_index_start">ç´¢å¼•</a>
] [<a href="99_about.html">ã“ã®å¯¾è¨³ç‰ˆã«ã¤ã„ã¦</a> | <a href="../index.html">ãƒ›ãƒ¼ãƒ </a>]
[
Â§<a href="#%_sec_5.3">5.3</a>
Â§<a href="#%_sec_5.3.1">5.3.1</a>
ğŸ“š<a href="#%_sec_Temp_746">&hellip;</a>
ğŸ¨<a href="#%_fig_5.14">5.14</a>
ğŸ“š<a href="#%_sec_Temp_751">&hellip;</a>
ğŸ“š<a href="#%_sec_Temp_754">&hellip;</a>
ğŸ“<a href="#%_thm_5.20">5.20</a>
ğŸ“<a href="#%_thm_5.21">5.21</a>
ğŸ“<a href="#%_thm_5.22">5.22</a>
Â§<a href="#%_sec_5.3.2">5.3.2</a>
ğŸ“š<a href="#%_sec_Temp_761">&hellip;</a>
ğŸ¨<a href="#%_fig_5.15">5.15</a>
<a href="#footnotes">è„šæ³¨</a>
]</nav>


</div>

<div class="main-txt">
<a name="%_sec_5.3"></a>
<h2 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_5.3">5.3  Storage Allocation and Garbage Collection</a></h2>
<h2 class="trans" lang="ja">5.3 è¨˜æ†¶å‰²ã‚Šå½“ã¦ã¨<ruby><rb>ã‚¬ãƒ¼ãƒ™ã‚¸</rb><rp> (</rp><rt>ã”ã¿</rt><rp>) </rp></ruby>ãƒ»<ruby><rb>ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³</rb><rp> (</rp><rt>ã‚ã¤ã‚</rt><rp>) </rp></ruby></h2>

<p class="orig" lang="en">
<a name="%_idx_5828"></a><a name="%_idx_5830"></a>
In section <a href="34_sec5_4.html#%_sec_5.4">5.4</a>, we will show how to implement a Scheme
evaluator as a register machine.  In order to simplify the discussion,
we will assume that our register machines can be equipped with a <em>list-structured memory</em>, in which the basic operations for
manipulating list-structured data are primitive.  Postulating the
existence of such a memory is a useful abstraction when one is
focusing on the mechanisms of control in a Scheme interpreter, but
this does not reflect a realistic view of the actual primitive data
operations of contemporary computers.  To obtain a more complete
picture of how a Lisp system operates, we must investigate how list
structure can be represented in a way that is compatible with
conventional computer memories.</p>

<p class="trans" lang="ja">
<a href="34_sec5_4.html#%_sec_5.4">5.4</a>ç¯€ã§ã¯ã€ã©ã®ã‚ˆã†ã«ã—ã¦ Scheme è©•ä¾¡å™¨ã‚’ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ»ãƒã‚·ãƒ³ã¨ã—ã¦å®Ÿè£…ã™ã‚‹ã®ã‹ã‚’ç¤ºãã†ã€‚
ãã®è­°è«–ã‚’ç°¡å˜åŒ–ã™ã‚‹ãŸã‚ã«ã€ç§ãŸã¡ã¯ã€<em>ãƒªã‚¹ãƒˆæ§‹é€ åŒ–ã•ã‚ŒãŸãƒ¡ãƒ¢ãƒª</em>â€”â€”ãã“ã§ã¯ã€ãƒªã‚¹ãƒˆæ§‹é€ åŒ–ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‚’æ“ä½œã™ã‚‹ãŸã‚ã®åŸºæœ¬çš„æ¼”ç®—ãŒåŸå§‹çš„ã§ã‚ã‚‹â€”â€”ã‚’è‡ªåˆ†ãŸã¡ã®ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ»ãƒã‚·ãƒ³ã«å‚™ãˆã¤ã‘ã‚‹ã“ã¨ãŒã§ãã‚‹ã®ã ã€ã¨ä»®å®šã—ã‚ˆã†ã€‚
ãã†ã—ãŸãƒ¡ãƒ¢ãƒªã®å­˜åœ¨ã‚’ä»®å®šã™ã‚‹ã“ã¨ã¯ã€Scheme ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ã«ãŠã‘ã‚‹åˆ¶å¾¡ã®ä»•çµ„ã¿ã«é–¢å¿ƒã‚’é›†ä¸­ã•ã›ã¦ã„ã‚‹ã¨ãã«æœ‰ç”¨ãªæŠ½è±¡åŒ–ã§ã‚ã‚‹ãŒã€ã“ã‚Œã¯ã€ç¾ä»£ã®ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã®å®Ÿéš›ã®åŸå§‹çš„ãƒ‡ãƒ¼ã‚¿æ¼”ç®—ã«ã¤ã„ã¦ã®ç¾å®Ÿçš„ãªè¦‹æ–¹ã‚’åæ˜ ã—ã¦ã„ã‚‹ã‚ã‘ã§ã¯ãªã„ã€‚
Lisp ã‚·ã‚¹ãƒ†ãƒ ãŒã©ã®ã‚ˆã†ã«å‹•ä½œã™ã‚‹ã‹ã«ã¤ã„ã¦ã®ã€ã‚ˆã‚Šå®Œå…¨ãªæå†™ã‚’æ‰‹ã«å…¥ã‚Œã‚‹ãŸã‚ã«ã€ç§ãŸã¡ã¯ã€å¾“æ¥ã®ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ»ãƒ¡ãƒ¢ãƒªã¨äº’æ›æ€§ã®ã‚ã‚‹æ–¹æ³•ã§ãƒªã‚¹ãƒˆæ§‹é€ ã‚’ã©ã®ã‚ˆã†ã«è¡¨ã›ã‚‹ã®ã‹ã€ã¨ã„ã†ã“ã¨ã‚’ç ”ç©¶ã›ã­ã°ãªã‚‰ãªã„ã€‚
</p>

<p class="orig" lang="en">
There are two considerations in implementing list structure.  The
first is purely an issue of representation: how to represent the
``box-and-pointer'' structure of Lisp pairs, using only the storage
and addressing capabilities of typical computer memories.  The second
issue concerns the management of memory as a computation proceeds.
The operation of a Lisp system depends crucially on the ability to
continually create new data objects.  These include objects that are
explicitly created by the Lisp procedures being interpreted as well
as structures created by the interpreter itself, such as environments
and argument lists.  Although the constant creation of new data
objects would pose no problem on a computer with an infinite amount of
rapidly addressable memory, computer memories are available only in
finite sizes (more's the pity).  Lisp systems
thus provide an <a name="%_idx_5832"></a><em>automatic storage allocation</em> facility to
support the illusion of an infinite memory.  When a data object is no
longer needed, the memory allocated to it is automatically recycled
and used to construct new data objects.  There are various
techniques for providing such automatic storage allocation.  The
method we shall discuss in this section is called <em>garbage
collection</em>.</p>

<p class="trans" lang="ja">
ãƒªã‚¹ãƒˆæ§‹é€ ã‚’å®Ÿè£…ã™ã‚‹éš›ã«è€ƒæ…®ã™ã¹ãã“ã¨ãŒäºŒã¤ã‚ã‚‹ã€‚
ä¸€ã¤ç›®ã¯ã€ç´”ç²‹ã«è¡¨ç¾ã®å•é¡Œã§ã‚ã‚‹ã€‚ã¤ã¾ã‚Šã€Lisp ã§ã®å¯¾ã®ã€Œç®±ã¨ãƒã‚¤ãƒ³ã‚¿ã€ã®æ§‹é€ ã‚’ã€å…¸å‹çš„ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ»ãƒ¡ãƒ¢ãƒªã®æ ¼ç´èƒ½åŠ›ã¨ã‚¢ãƒ‰ãƒ¬ã‚·ãƒ³ã‚°èƒ½åŠ›ã®ã¿ã‚’ç”¨ã„ã¦ã€ã©ã®ã‚ˆã†ã«è¡¨ç¾ã™ã‚‹ã‹ã€ã¨ã„ã†ç‚¹ã§ã‚ã‚‹ã€‚
äºŒã¤ç›®ã®å•é¡Œã¯ã€è¨ˆç®—ãŒé€²ã‚€ã«ã¤ã‚Œã¦ã®ãƒ¡ãƒ¢ãƒªã®ç®¡ç†ã«ã¤ã„ã¦ã®ã‚‚ã®ã§ã‚ã‚‹ã€‚
Lisp ã‚·ã‚¹ãƒ†ãƒ ã®å‹•ä½œã¯ã€æ–°ãŸãªãƒ‡ãƒ¼ã‚¿ãƒ»ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç¶™ç¶šçš„ã«ä½œæˆã™ã‚‹èƒ½åŠ›ã«ã€æ±ºå®šå®šæœŸã«ä¾å­˜ã—ã¦ã„ã‚‹ã€‚
ã“ã‚Œã‚‰ã®æ–°ãŸãªãƒ‡ãƒ¼ã‚¿ãƒ»ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯ã€è§£é‡ˆã•ã‚Œã¦ã„ã‚‹æœ€ä¸­ã® Lisp æ‰‹ç¶šãã«ã‚ˆã‚Šæ˜ç¤ºçš„ã«ä½œæˆã•ã‚Œã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ãŠã‚ˆã³ã€ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿è‡ªä½“ã«ã‚ˆã‚Šä½œæˆã•ã‚Œã‚‹æ§‹é€ â€”â€”ç’°å¢ƒã‚„å¼•æ•°ãƒªã‚¹ãƒˆãªã©â€”â€”ãŒå«ã¾ã‚Œã‚‹ã€‚
æ–°ãŸãªãƒ‡ãƒ¼ã‚¿ãƒ»ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’çµ¶ãˆé–“ãªãä½œæˆã™ã‚‹ã“ã¨ã¯ã€è¿…é€Ÿã«ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ãªç„¡é™ã®é‡ã®ãƒ¡ãƒ¢ãƒªã‚’å‚™ãˆãŸã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã«å¯¾ã—ã¦ã¯ã€ä½•ã®å•é¡Œã‚‚ã‚‚ãŸã‚‰ã•ãªã„ã ã‚ã†ãŒã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ»ãƒ¡ãƒ¢ãƒªã¯ã€(æ®‹å¿µãªãŒã‚‰) æœ‰é™ã®å¤§ãã•ã§ã—ã‹åˆ©ç”¨å¯èƒ½ã§ã¯ãªã„ã€‚
ã‚ˆã£ã¦ã€Lisp ã‚·ã‚¹ãƒ†ãƒ ã¯ã€ç„¡é™ã®ãƒ¡ãƒ¢ãƒªã¨ã„ã†å¹»å½±ã‚’æ”¯ãˆã‚‹ãŸã‚ã«ã€<em>è‡ªå‹•çš„<ruby><rb>è¨˜æ†¶</rb><rp> (</rp><rt>ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸</rt><rp>) </rp></ruby><ruby><rb>å‰²ã‚Šå½“ã¦</rb><rp> (</rp><rt>ã‚¢ãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³</rt><rp>) </rp></ruby></em>æ‰‹æ®µã‚’æä¾›ã—ã¦ã„ã‚‹ã€‚
ãƒ‡ãƒ¼ã‚¿ãƒ»ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚‚ã†å¿…è¦ã§ã¯ãªããªã‚‹ã¨ã€ãã®ãƒ‡ãƒ¼ã‚¿ãƒ»ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å‰²ã‚Šå½“ã¦ã‚‰ã‚Œã¦ã„ã‚‹ãƒ¡ãƒ¢ãƒªãŒè‡ªå‹•çš„ã«å†åˆ©ç”¨ã•ã‚Œã€æ–°ãŸãªãƒ‡ãƒ¼ã‚¿ãƒ»ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ§‹ç¯‰ã™ã‚‹ã®ã«ä½¿ã‚ã‚Œã‚‹ã€‚
ãã†ã—ãŸè‡ªå‹•è¨˜æ†¶å‰²ã‚Šå½“ã¦ã‚’æä¾›ã™ã‚‹ãŸã‚ã®ã€æ§˜ã€…ãªæŠ€æ³•ãŒã‚ã‚‹ã€‚
æœ¬ç¯€ã§ç§ãŸã¡ãŒè­°è«–ã™ã‚‹ã“ã¨ã«ãªã‚‹æ–¹æ³•ã¯ã€<em><ruby><rb>ã‚¬ãƒ¼ãƒ™ã‚¸</rb><rp> (</rp><rt>ã”ã¿</rt><rp>) </rp></ruby>ãƒ»<ruby><rb>ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³</rb><rp> (</rp><rt>ã‚ã¤ã‚</rt><rp>) </rp></ruby></em>ã¨å‘¼ã°ã‚Œã‚‹ã€‚
</p>

<a name="%_sec_5.3.1"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_5.3.1">5.3.1  Memory as Vectors</a></h3>
<h3 class="trans" lang="ja">5.3.1 ãƒ™ã‚¯ã‚¿ã¨ã—ã¦ã®ãƒ¡ãƒ¢ãƒª</h3>

<p class="orig" lang="en">A conventional computer memory can be thought of as an array of
cubbyholes, each of which can contain a piece of information.  Each
cubbyhole has a unique name, called its <a name="%_idx_5834"></a><em>address</em> or <a name="%_idx_5836"></a><em>location</em>.  Typical memory systems provide two primitive operations:
one that fetches the data stored in a specified location and one that
assigns new data to a specified location.  Memory addresses can be
incremented to support sequential access to some set of the
cubbyholes.  More generally, many important data operations require
that memory addresses be treated as data, which can be stored in
memory locations and manipulated in machine registers.  The
representation of list structure is one application of such <a name="%_idx_5838"></a><a name="%_idx_5840"></a><em>address arithmetic</em>.</p>

<p class="trans" lang="ja">
å¾“æ¥ã®ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ»ãƒ¡ãƒ¢ãƒªã¯ã€å°éƒ¨å±‹ã®é…åˆ—ã ã¨è¦‹ãªã›ã¦ã€ãã‚Œã‚‰ã®å°éƒ¨å±‹ã®å„ã€…ã¯ã€ä¸€ã¤ã®æƒ…å ±ã‚’å«ã‚€ã“ã¨ãŒã§ãã‚‹ã€‚
å„å°éƒ¨å±‹ã«ã¯ã€ãã®å°éƒ¨å±‹ã®<em><ruby><rb>ç•ªåœ°</rb><rp> (</rp><rt>ã‚¢ãƒ‰ãƒ¬ã‚¹</rt><rp>) </rp></ruby></em>ã¾ãŸã¯<em><ruby><rb>å ´æ‰€</rb><rp> (</rp><rt>ãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³</rt><rp>) </rp></ruby></em>ã¨å‘¼ã°ã‚Œã‚‹ã€ä¸€æ„ãªåå‰ãŒã‚ã‚‹ã€‚
å…¸å‹çš„ãƒ¡ãƒ¢ãƒªã‚·ã‚¹ãƒ†ãƒ ã¯ã€äºŒã¤ã®åŸå§‹çš„æ“ä½œâ€”â€”ã™ãªã‚ã¡ã€æŒ‡å®šã•ã‚ŒãŸå ´æ‰€ã«æ ¼ç´ã•ã‚Œã¦ã„ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚’å–ã£ã¦ãã‚‹ã‚‚ã®ã¨ã€æŒ‡å®šã•ã‚ŒãŸå ´æ‰€ã«æ–°ãŸãªãƒ‡ãƒ¼ã‚¿ã‚’å‰²ã‚Šå½“ã¦ã‚‹ã‚‚ã®â€”â€”ã‚’æä¾›ã™ã‚‹ã€‚
ãƒ¡ãƒ¢ãƒªã‚¢ãƒ‰ãƒ¬ã‚¹ã¯ã€å°éƒ¨å±‹ã®ä½•ã‚‰ã‹ã®é›†ã¾ã‚Šã«å¯¾ã™ã‚‹é€æ¬¡çš„ã‚¢ã‚¯ã‚»ã‚¹ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ãŸã‚ã«ã€ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã•ã‚Œå¾—ã‚‹ã€‚
ã‚ˆã‚Šä¸€èˆ¬çš„ã«ã¯ã€ãƒ‡ãƒ¼ã‚¿â€”â€”ãƒ¡ãƒ¢ãƒªä¸Šã®å ´æ‰€ã«æ ¼ç´ã™ã‚‹ã“ã¨ãŒã§ãã€ãƒã‚·ãƒ³ãƒ»ãƒ¬ã‚¸ã‚¹ã‚¿ã«ãŠã„ã¦æ“ä½œã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã‚‚ã®â€”â€”ã¨ã—ã¦ãƒ¡ãƒ¢ãƒªã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æ‰±ã†ã“ã¨ã‚’ã€å¤šãã®é‡è¦ãªãƒ‡ãƒ¼ã‚¿æ“ä½œãŒè¦æ±‚ã—ã¦ã„ã‚‹ã€‚
ãƒªã‚¹ãƒˆæ§‹é€ ã®è¡¨ç¾ã¯ã€ãã†ã—ãŸ<em>ã‚¢ãƒ‰ãƒ¬ã‚¹ç®—è¡“</em>ã®ä¸€ã¤ã®å¿œç”¨ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
To model computer memory, we use a new kind of data
structure called a <a name="%_idx_5842"></a><em>vector</em>.  Abstractly, a vector is a compound
data object whose individual elements can be accessed by means of an
integer index in an amount of time that is independent of the
index.<a name="call_footnote_Temp_744" href="#footnote_Temp_744"><sup><small>5</small></sup></a> In order to describe memory operations, we use two
primitive Scheme procedures for manipulating vectors:</p>

<p class="trans" lang="ja">
ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ»ãƒ¡ãƒ¢ãƒªã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã™ã‚‹ãŸã‚ã«ã€ç§ãŸã¡ã¯ã€<em>ãƒ™ã‚¯ã‚¿</em>ã¨å‘¼ã°ã‚Œã‚‹æ–°ãŸãªç¨®é¡ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’ç”¨ã„ã‚‹ã€‚
<!-- æŠ½è±¡çš„ã«ã¯ã€ãƒ™ã‚¯ã‚¿ã¨ã¯ã€ãã®å€‹ã€…ã®è¦ç´ ã«ã€æ·»ãˆå­—ã«ã¯ä¾å­˜ã—ãªã„é‡ã®æ™‚é–“ã§ã€æ•´æ•°ã®æ·»ãˆå­—ã«ã‚ˆã£ã¦ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã‚ˆã†ãªã€è¤‡åˆãƒ‡ãƒ¼ã‚¿ãƒ»ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚‹ã€‚ -->
æŠ½è±¡çš„ã«ã¯ã€ãƒ™ã‚¯ã‚¿ã¨ã¯ã€æ•´æ•°ã®æ·»ãˆå­—ã‚’ç”¨ã„ã¦ã€ãã®æ·»ãˆå­—ã«ã¯ä¾å­˜ã—ãªã„é‡ã®æ™‚é–“ã§ã€å€‹ã€…ã®è¦ç´ ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã‚ˆã†ãªã€è¤‡åˆãƒ‡ãƒ¼ã‚¿ãƒ»ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚‹<a  href="#footnote_Temp_744"><sup><small>5</small></sup></a>ã€‚
ãƒ¡ãƒ¢ãƒªæ¼”ç®—ã‚’èª¬æ˜ã™ã‚‹ãŸã‚ã«ã€ãƒ™ã‚¯ã‚¿ã‚’æ“ä½œã™ã‚‹ãŸã‚ã®äºŒã¤ã®åŸå§‹çš„ãª Scheme æ‰‹ç¶šãã‚’ç”¨ã„ã‚‹ã€‚
</p>

<ul class="orig" lang="en">
<a name="%_idx_5844"></a><a name="%_idx_5846"></a><li><tt>(vector-ref &lt;<em>vector</em>&gt; &lt;<em>n</em>&gt;)</tt> returns the <em>n</em>th
element of the vector.</li>

<a name="%_idx_5848"></a><a name="%_idx_5850"></a><li><tt>(vector-set! &lt;<em>vector</em>&gt; &lt;<em>n</em>&gt; &lt;<em>value</em>&gt;)</tt> sets
the <em>n</em>th element of the vector to the designated value.</li>
</ul>

<ul class="trans" lang="ja">
<li><tt>(vector-ref &lt;<em class="en">vector</em>&gt; &lt;<em class="en">n</em>&gt;)</tt> ã¯ã€ãƒ™ã‚¯ã‚¿ã® <em class="en">n</em> ç•ªç›®ã®è¦ç´ ã‚’è¿”ã™ã€‚</li>
<li><tt>(vector-set! &lt;<em class="en">vector</em>&gt; &lt;<em class="en">n</em>&gt; &lt;<em class="en">value</em>&gt;)</tt> ã¯ã€ãƒ™ã‚¯ã‚¿ã® <em class="en">n</em> ç•ªç›®ã®è¦ç´ ã‚’ã€æŒ‡å®šã•ã‚ŒãŸå€¤ã«è¨­å®šã™ã‚‹ã€‚</li>
</ul>

<p class="orig" lang="en">For example, if <tt>v</tt> is a vector, then <tt>(vector-ref v 5)</tt> gets
the fifth entry in the vector <tt>v</tt> and <tt>(vector-set! v 5 7)</tt>
changes the value of the fifth entry of the vector <tt>v</tt> to 7.<a name="call_footnote_Temp_745" href="#footnote_Temp_745"><sup><small>6</small></sup></a>
For computer memory, this access can be implemented
through the use of address arithmetic to combine a <em>base address</em>
that specifies the beginning location of a vector in memory with an
<em>index</em> that specifies the offset of a particular element of the vector.</p>

<p class="trans" lang="ja">
ä¾‹ãˆã°ã€ã‚‚ã— <tt>v</tt> ãŒãƒ™ã‚¯ã‚¿ãªã‚‰ã€
<tt>(vector-ref v 5)</tt> 
ã¯ã€<tt>v</tt> ã¨ã„ã†ãƒ™ã‚¯ã‚¿ã® 5 ç•ªç›®ã®ã‚¨ãƒ³ãƒˆãƒªã‚’å–å¾—ã—ã€
<tt>(vector-set! v 5 7)</tt>
ã¯ã€<tt>v</tt> ã¨ã„ã†ãƒ™ã‚¯ã‚¿ã® 5 ç•ªç›®ã®ã‚¨ãƒ³ãƒˆãƒªã®å€¤ã‚’ 7 ã«å¤‰æ›´ã™ã‚‹<a href="#footnote_Temp_745"><sup><small>6</small></sup></a>ã€‚
ãƒ¡ãƒ¢ãƒªã«ãŠã‘ã‚‹ãƒ™ã‚¯ã‚¿ã®é–‹å§‹ä½ç½®ã‚’æŒ‡å®šã™ã‚‹<em>ãƒ™ãƒ¼ã‚¹ãƒ»ã‚¢ãƒ‰ãƒ¬ã‚¹</em>ã‚’ã€ãã®ãƒ™ã‚¯ã‚¿ã®ç‰¹å®šã®è¦ç´ ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’æŒ‡å®šã™ã‚‹<em><ruby><rb>æ·»ãˆå­—</rb><rp> (</rp><rt>ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹</rt><rp>) </rp></ruby></em>ã¨çµ„ã¿åˆã‚ã›ã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ç®—è¡“ã®ä½¿ç”¨ã‚’é€šã˜ã¦ã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ»ãƒ¡ãƒ¢ãƒªç”¨ã«ã€ã“ã†ã—ãŸã‚¢ã‚¯ã‚»ã‚¹ã‚’å®Ÿè£…ã§ãã‚‹ã€‚
</p>

<a name="%_sec_Temp_746"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_746">Representing Lisp data</a></h4>
<h4 class="trans" lang="ja">Lisp ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ç¾ã™ã‚‹</h4>

<p class="orig" lang="en">
<a name="%_idx_5852"></a><a name="%_idx_5854"></a>
We can use vectors to implement the basic pair structures required for
a list-structured memory.  Let us imagine that computer memory is
divided into two vectors: <a name="%_idx_5856"></a><tt>the-cars</tt> and <a name="%_idx_5858"></a><tt>the-cdrs</tt>.  We will
represent list structure as follows: A pointer to a pair is an index
into the two vectors.  The <tt>car</tt> of the pair is the entry in <tt>the-cars</tt> with the designated index, and the <tt>cdr</tt> of the pair is
the entry in <tt>the-cdrs</tt> with the designated index.  We also need a
representation for objects other than pairs (such as numbers and
symbols) and a way to distinguish one kind of data from another.
There are many methods of accomplishing this, but they all reduce to
using <a name="%_idx_5860"></a><a name="%_idx_5862"></a><em>typed pointers</em>, that is, to extending the notion of
``pointer'' to include information on data type.<a name="call_footnote_Temp_747" href="#footnote_Temp_747"><sup><small>7</small></sup></a> The data type enables the system to
distinguish a pointer to a pair (which consists of the ``pair'' data
type and an index into the memory vectors) from pointers to other
kinds of data (which consist of some other data type and whatever is
being used to represent data of that type).  Two data objects are
<a name="%_idx_5868"></a>considered to be the same (<tt>eq?</tt>) if their pointers are
identical.<a name="call_footnote_Temp_748" href="#footnote_Temp_748"><sup><small>8</small></sup></a> Figure <a href="#%_fig_5.14">5.14</a>
illustrates the use of this method to represent the list <tt>((1 2) 3
4)</tt>, whose box-and-pointer diagram is also shown.  We use letter
prefixes to denote the data-type information.  Thus, a pointer to the
pair with index 5 is denoted <tt>p5</tt>, the empty list is denoted by
the pointer <tt>e0</tt>, and a pointer to the number 4 is denoted <tt>n4</tt>.  In the box-and-pointer diagram, we have indicated at the lower
left of each pair the vector index that specifies where the <tt>car</tt>
and <tt>cdr</tt> of the pair are stored.  The blank locations in <tt>the-cars</tt> and <tt>the-cdrs</tt> may contain parts of other list
structures (not of interest here).</p>

<p class="trans" lang="ja">
ãƒªã‚¹ãƒˆæ§‹é€ åŒ–ã•ã‚ŒãŸãƒ¡ãƒ¢ãƒªã«å¿…è¦ãªåŸºæœ¬çš„ãªå¯¾æ§‹é€ ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã«ã€ç§ãŸã¡ã¯ãƒ™ã‚¯ã‚¿ã‚’ä½¿ãˆã‚‹ã€‚
ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ»ãƒ¡ãƒ¢ãƒªãŒã€äºŒã¤ã®ãƒ™ã‚¯ã‚¿â€”â€”ã™ãªã‚ã¡ã€<tt>the-cars</tt> ã¨ <tt>the-cdrs</tt> â€”â€”ã«åˆ†å‰²ã•ã‚Œã¦ã„ã‚‹ã‚‚ã®ã¨æƒ³åƒã—ã‚ˆã†ã€‚
ãƒªã‚¹ãƒˆæ§‹é€ ã‚’æ¬¡ã®ã‚ˆã†ã«è¡¨ç¾ã™ã‚‹ã€‚
å¯¾ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã¯ã€ã“ã‚Œã‚‰äºŒã¤ã®ãƒ™ã‚¯ã‚¿ã«å¯¾ã™ã‚‹æ·»ãˆå­—ã§ã‚ã‚‹ã€‚
ãã®å¯¾ã® <tt>car</tt> ã¯ã€<tt>the-cars</tt> ã®ä¸­ã«ãŠã‘ã‚‹ã€æŒ‡å®šã•ã‚ŒãŸæ·»ãˆå­—ã‚’æœ‰ã™ã‚‹ã‚¨ãƒ³ãƒˆãƒªã§ã‚ã‚Šã€ãã®å¯¾ã® <tt>cdr</tt> ã¯ã€<tt>the-cdrs</tt> ã®ä¸­ã«ãŠã‘ã‚‹ã€æŒ‡å®šã•ã‚ŒãŸæ·»ãˆå­—ã‚’æœ‰ã™ã‚‹ã‚¨ãƒ³ãƒˆãƒªã§ã‚ã‚‹ã€‚
ç§ãŸã¡ã¯ã€å¯¾ä»¥å¤–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (æ•°ã‚„è¨˜å·ãªã©) ã«å¯¾ã™ã‚‹è¡¨ç¾ã¨ã€ã‚ã‚‹ä¸€ã¤ã®ç¨®é¡ã®ãƒ‡ãƒ¼ã‚¿ã‚’åˆ¥ã®ç¨®é¡ã®ãƒ‡ãƒ¼ã‚¿ã¨åŒºåˆ¥ã™ã‚‹ãŸã‚ã®æ–¹æ³•ã‚‚ã€å¿…è¦ã¨ã—ã¦ã„ã‚‹ã€‚
ã“ã‚Œã‚’é”æˆã™ã‚‹å¤šãã®æ–¹æ³•ãŒã‚ã‚‹ãŒã€ãã‚Œã‚‰ã®æ–¹æ³•ã¯ã©ã‚Œã‚‚ã€<em>å‹ã¤ãã®ãƒã‚¤ãƒ³ã‚¿</em>ã‚’ä½¿ã†ã“ã¨ã¸ã¨â€”â€”ã¤ã¾ã‚Šã€ã€Œãƒã‚¤ãƒ³ã‚¿ã€ã®æ¦‚å¿µã‚’ã€ãƒ‡ãƒ¼ã‚¿å‹ã«ã¤ã„ã¦ã®æƒ…å ±ã‚’å«ã‚€ã‚ˆã†ã«æ‹¡å¼µã™ã‚‹ã“ã¨ã¸ã¨â€”â€”å¸°ç€ã™ã‚‹<a href="#footnote_Temp_747"><sup><small>7</small></sup></a>ã€‚
ãƒ‡ãƒ¼ã‚¿å‹ã«ã‚ˆã‚Šã€ã‚·ã‚¹ãƒ†ãƒ ãŒã€å¯¾ (ã€Œå¯¾ã€ã®ãƒ‡ãƒ¼ã‚¿å‹ã¨ã€ãƒ¡ãƒ¢ãƒªãƒ»ãƒ™ã‚¯ã‚¿ã«å¯¾ã™ã‚‹æ·»ãˆå­—ã¨ã‹ã‚‰ãªã‚‹) ã«å¯¾ã™ã‚‹ãƒã‚¤ãƒ³ã‚¿ã‚’ã€åˆ¥ã®ç¨®é¡ã®ãƒ‡ãƒ¼ã‚¿ (ä»–ã®ä½•ã‚‰ã‹ã®ãƒ‡ãƒ¼ã‚¿å‹ã¨ã€ãã®å‹ã®ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ç¾ã™ã‚‹ã®ã«ä½¿ã‚ã‚Œã¦ã„ã‚‹ã‚‚ã®ãªã‚‰ä½•ã§ã‚‚ã™ã¹ã¦ã€ã‹ã‚‰ãªã‚‹) ã«å¯¾ã™ã‚‹ãƒã‚¤ãƒ³ã‚¿ã¨åŒºåˆ¥ã™ã‚‹ã“ã¨ãŒå¯èƒ½ã¨ãªã‚‹ã€‚
äºŒã¤ã®ãƒ‡ãƒ¼ã‚¿ãƒ»ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ã‚‚ã—ãã‚Œã‚‰ã®ãƒã‚¤ãƒ³ã‚¿åŒå£«ãŒåŒã˜ã§ã‚ã‚Œã°ã€åŒä¸€ã§ã‚ã‚‹ (<tt>eq?</tt>) ã¨è¦‹ãªã•ã‚Œã‚‹<a href="#footnote_Temp_748"><sup><small>8</small></sup></a>ã€‚
å›³<a href="#%_fig_5.14">5.14</a>ã¯ã€<tt>((1 2) 3 4)</tt> ã¨ã„ã†ãƒªã‚¹ãƒˆã‚’è¡¨ç¾ã™ã‚‹ãŸã‚ã«ã“ã®æ–¹æ³•ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã‚’å›³ç¤ºã—ã¦ãŠã‚Šã€ã“ã®ãƒªã‚¹ãƒˆã®ã€ç®±ã¨ãƒã‚¤ãƒ³ã‚¿ã«ã‚ˆã‚‹å›³ã‚‚ç¤ºã•ã‚Œã¦ã„ã‚‹ã€‚
ãƒ‡ãƒ¼ã‚¿å‹æƒ…å ±ã‚’è¡¨è¨˜ã™ã‚‹ãŸã‚ã«ã€æ–‡å­—ã®æ¥é ­è¾ã‚’ä½¿ã†ã€‚
ã‚ˆã£ã¦ã€5 ã¨ã„ã†æ·»ãˆå­—ã®å¯¾ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã¯ <tt>p5</tt> ã¨ç¤ºã•ã‚Œã€ç©ºãƒªã‚¹ãƒˆã¯ <tt>e0</tt> ã¨ã„ã†ãƒã‚¤ãƒ³ã‚¿ã«ã‚ˆã‚Šç¤ºã•ã‚Œã€4 ã¨ã„ã†æ•°ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã¯ <tt>n4</tt> ã¨ç¤ºã•ã‚Œã‚‹ã€‚
ç®±ã¨ãƒã‚¤ãƒ³ã‚¿ã«ã‚ˆã‚‹å›³ã«ãŠã„ã¦ã¯ã€ãã‚Œãã‚Œã®å¯¾ã®å·¦ä¸‹ã«ã€ãã®å¯¾ã® <tt>car</tt>
ã¨ <tt>cdr</tt> ãŒã©ã“ã«æ ¼ç´ã•ã‚Œã¦ã„ã‚‹ã®ã‹ã‚’æŒ‡å®šã™ã‚‹ã€ãƒ™ã‚¯ã‚¿ã®æ·»ãˆå­—ã‚’ç¤ºã—ãŸã€‚
<tt>the-cars</tt> ã¨ <tt>the-cdrs</tt> ã«ãŠã‘ã‚‹ç©ºç™½ã®å ´æ‰€ã¯ã€(ã“ã“ã§ã¯èˆˆå‘³ã®å¯¾è±¡å¤–ã®) ä»–ã®ãƒªã‚¹ãƒˆæ§‹é€ ã®ä¸€éƒ¨ã‚’å«ã‚“ã§ã„ã¦ã‚‚ã‚ˆã„ã€‚
</p>

<figure>
<a name="%_fig_5.14"></a>
<img src="ch5-Z-G-7.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 5.14:</b>  Box-and-pointer and memory-vector representations 
of the list <tt>((1 2) 3 4)</tt>.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³5.14.:</b> <tt>((1 2) 3 4)</tt> ã¨ã„ã†ãƒªã‚¹ãƒˆã®ã€ç®±ã¨ãƒã‚¤ãƒ³ã‚¿ã§ã®è¡¨ç¾ã¨ã€ãƒ¡ãƒ¢ãƒªä¸Šã®ãƒ™ã‚¯ã‚¿ã§ã®è¡¨ç¾</figcaption>
</figure>

<p class="orig" lang="en">
A pointer to a number, such as <tt>n4</tt>,
might consist of a type indicating numeric data together with the
actual representation of the number 4.<a name="call_footnote_Temp_749" href="#footnote_Temp_749"><sup><small>9</small></sup></a>
To deal with numbers that are too large to
be represented in the fixed amount of space allocated for a single
pointer, we could use a distinct <a name="%_idx_5880"></a><em>bignum</em> data type, for which the
pointer designates a list in which the parts of the number are
stored.<a name="call_footnote_Temp_750" href="#footnote_Temp_750"><sup><small>10</small></sup></a></p>

<p class="trans" lang="ja">
<tt>n4</tt> ã®ã‚ˆã†ãªã€æ•°ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã¯ã€4 ã¨ã„ã†æ•°ã®å®Ÿéš›ã®è¡¨ç¾ã‚’ã¨ã‚‚ãªã£ãŸã€æ•°å€¤çš„ãƒ‡ãƒ¼ã‚¿ã‚’ç¤ºã™å‹ã‹ã‚‰ãªã‚‹ã‹ã‚‚ã—ã‚Œãªã„<a href="#footnote_Temp_749"><sup><small>9</small></sup></a>ã€‚
ä¸€ã¤ã®ãƒã‚¤ãƒ³ã‚¿ã«å¯¾ã—ã¦å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸå›ºå®šé‡ã®ç©ºé–“ã§è¡¨ç¾ã™ã‚‹ã«ã¯å¤§ãã™ãã‚‹æ•°ã‚’æ‰±ã†ãŸã‚ã«ã¯ã€åˆ¥ã®<em>å¤šå€é•·</em>ãƒ‡ãƒ¼ã‚¿å‹â€”â€”ã“ã‚Œã«ã¤ã„ã¦ã€ãƒã‚¤ãƒ³ã‚¿ã¯ã€æ•°ã®è«¸éƒ¨åˆ†ãŒæ ¼ç´ã•ã‚Œã¦ã„ã‚‹ãƒªã‚¹ãƒˆã‚’æŒ‡å®šã™ã‚‹â€”â€”ã‚’ä½¿ã†ã“ã¨ã‚‚ã§ãã‚‹ã ã‚ã†<a href="#footnote_Temp_750"><sup><small>10</small></sup></a>ã€‚
</p>

<p class="orig" lang="en">
<a name="%_idx_5882"></a>A symbol might be represented as a typed pointer that designates a
sequence of the characters that form the symbol's printed representation.
This sequence is constructed by the Lisp reader when the character string
is initially encountered in input.  Since we want two instances of a
symbol to be recognized as the ``same'' symbol by <tt>eq?</tt> and we
<a name="%_idx_5884"></a>want <tt>eq?</tt> to be a simple test for equality of pointers, we must
ensure that if the reader sees the same character string twice, it
will use the same pointer (to the same sequence of characters) to
represent both occurrences.  To accomplish this, the reader maintains
a table, traditionally called the <a name="%_idx_5886"></a><em>obarray</em>, of all the symbols it
has ever encountered.  When the reader encounters a character string
and is about to construct a symbol, it checks the obarray to see if it
has ever before seen the same character string.  If it has not, it
uses the characters to construct a new symbol (a typed pointer to a
new character sequence) and enters this pointer in the obarray.  If the
reader has seen the string before, it returns the symbol pointer
stored in the obarray.  This process of replacing character strings by
unique pointers is called <a name="%_idx_5888"></a><a name="%_idx_5890"></a><em>interning</em> symbols.</p>

<p class="trans" lang="ja">
è¨˜å·ã¯ã€ãã®è¨˜å·ã®å°å­—ã•ã‚ŒãŸè¡¨ç¾ã‚’å½¢æˆã—ã¦ã„ã‚‹æ–‡å­—ã®ä¸¦ã³ã‚’æŒ‡å®šã™ã‚‹ã€å‹ã¤ãã®ãƒã‚¤ãƒ³ã‚¿ã¨ã—ã¦ã€è¡¨ç¾ã•ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚
ã“ã®ä¸¦ã³ã¯ã€å…¥åŠ›ã®ä¸­ã§ãã®æ–‡å­—åˆ—ã«æœ€åˆã«é­é‡ã—ãŸéš›ã«ã€Lisp èª­ã¿å–ã‚Šå™¨ã«ã‚ˆã‚Šæ§‹ç¯‰ã•ã‚Œã‚‹ã€‚
ç§ãŸã¡ã¯ã€äºŒã¤ã®è¨˜å·ãŒã€ŒåŒã˜ã ã€ã¨ <tt>eq?</tt> ã«ã‚ˆã£ã¦èªè­˜ã•ã‚Œã¦ã»ã—ã„ã—ã€<tt>eq?</tt> ãŒãƒã‚¤ãƒ³ã‚¿åŒå£«ã®ç­‰ä¾¡æ€§ã®ãŸã‚ã®ç°¡æ½”ãªæ¤œæŸ»ã§ã‚ã£ã¦ã»ã—ã„ã€‚ã‚ˆã£ã¦ã€ç§ãŸã¡ã¯ã€ã‚‚ã—èª­ã¿å–ã‚Šå™¨ãŒåŒã˜æ–‡å­—åˆ—ã‚’äºŒå›è¦‹ãŸãªã‚‰ã€èª­ã¿å–ã‚Šå™¨ã¯åŒæ–¹ã®å­˜åœ¨ã‚’è¡¨ç¾ã™ã‚‹ã®ã« (æ–‡å­—ã®åŒã˜ä¸¦ã³ã«å¯¾ã™ã‚‹) åŒã˜ãƒã‚¤ãƒ³ã‚¿ã‚’ä½¿ã†ã ã‚ã†ã€ã¨ã„ã†ã“ã¨ã‚’ä¿è¨¼ã›ã­ã°ãªã‚‰ãªã„ã€‚
ã“ã‚Œã‚’é”æˆã™ã‚‹ãŸã‚ã«ã€èª­ã¿å–ã‚Šå™¨ã¯ã€è‡ªåˆ†ãŒä»Šã¾ã§ã«é­é‡ã—ãŸã“ã¨ã®ã‚ã‚‹ã™ã¹ã¦ã®è¨˜å·ã®è¡¨â€”â€”ä¼çµ±çš„ã«ã¯<em><ruby><rb>obarray</rb><rp> (</rp><rt>ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆé…åˆ—</rt><rp>) </rp></ruby></em>ã¨å‘¼ã°ã‚Œã‚‹â€”â€”ã‚’ç¶­æŒã™ã‚‹ã€‚
èª­ã¿å–ã‚Šå™¨ã¯ã€æ–‡å­—åˆ—ã«é­é‡ã—ã¦ã€ã¾ã•ã«è¨˜å·ã‚’æ§‹ç¯‰ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ãã€ä»¥å‰ã«åŒã˜æ–‡å­—åˆ—ã‚’è¦‹ãŸã“ã¨ãŒã‚ã‚‹ã‹ã©ã†ã‹ã‚’ç¢ºã‹ã‚ã‚‹ãŸã‚ã« obarray ã‚’èª¿ã¹ã‚‹ã€‚
èª­ã¿å–ã‚Šå™¨ã¯ã€ã‚‚ã—ãã®æ–‡å­—åˆ—ã‚’ä»¥å‰ã«è¦‹ãŸã“ã¨ãŒã‚ã‚Œã°ã€obarray å†…ã«æ ¼ç´ã•ã‚Œã¦ã„ã‚‹è¨˜å·ãƒã‚¤ãƒ³ã‚¿ã‚’è¿”ã™ã€‚
æ–‡å­—åˆ—ã‚’ä¸€æ„ãªãƒã‚¤ãƒ³ã‚¿ã§ç½®ãæ›ãˆã‚‹ã¨ã„ã†ã€ã“ã®éç¨‹ã¯ã€è¨˜å·ã®<em><ruby><rb>ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ³</rb><rp> (</rp><rt>ã¨ã˜ã“ã‚</rt><rp>) </rp></ruby></em>ã¨å‘¼ã°ã‚Œã‚‹ã€‚
</p>


<a name="%_sec_Temp_751"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_751">Implementing the primitive list operations</a></h4>
<h4 class="trans" lang="ja">åŸå§‹çš„ãªãƒªã‚¹ãƒˆæ¼”ç®—ã‚’å®Ÿè£…ã™ã‚‹</h4>

<p class="orig" lang="en">
<a name="%_idx_5892"></a><a name="%_idx_5894"></a>Given the above representation scheme, we can replace each
``primitive'' list operation of a register machine with one or more
primitive vector operations.  We will use two registers, <tt>the-cars</tt> and <tt>the-cdrs</tt>, to identify the memory vectors, and will
assume that <tt>vector-ref</tt> and <tt>vector-set!</tt> are available as
primitive operations.  We also assume that numeric operations on
pointers (such as incrementing a pointer, using a pair pointer to
index a vector, or adding two numbers) use only the index portion of
the typed pointer.</p>

<p class="trans" lang="ja">
ä¸Šè¨˜ã®è¡¨ç¾æ–¹å¼ãŒä¸ãˆã‚‰ã‚Œã‚‹ã¨ã€ç§ãŸã¡ã¯ã€ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ»ãƒã‚·ãƒ³ã®å„ã€ŒåŸå§‹çš„ã€ãƒªã‚¹ãƒˆæ¼”ç®—ã‚’ã€ä¸€ã¤ä»¥ä¸Šã®åŸå§‹çš„ãƒ™ã‚¯ã‚¿æ¼”ç®—ã«ç½®ãæ›ãˆã‚‰ã‚Œã‚‹ã€‚
ãƒ¡ãƒ¢ãƒªãƒ»ãƒ™ã‚¯ã‚¿ã‚’è­˜åˆ¥ã™ã‚‹ã®ã«ã€äºŒã¤ã®ãƒ¬ã‚¸ã‚¹ã‚¿â€”â€”ã¤ã¾ã‚Šã€<tt>the-cars</tt> ã¨ <tt>the-cdrs</tt> â€”â€”ã‚’ä½¿ãŠã†ã€‚ãã—ã¦ã€åŸå§‹çš„æ¼”ç®—ã¨ã—ã¦ <tt>vector-ref</tt> ã¨ <tt>vector-set!</tt> ãŒåˆ©ç”¨å¯èƒ½ã ã¨ä»®å®šã—ã‚ˆã†ã€‚
ã¾ãŸã€ãƒã‚¤ãƒ³ã‚¿ã«å¯¾ã™ã‚‹æ•°å€¤çš„æ¼”ç®— (ãƒã‚¤ãƒ³ã‚¿ã‚’ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã—ãŸã‚Šã€ãƒ™ã‚¯ã‚¿ã«æ·»ãˆå­—ã‚’ã¤ã‘ã‚‹ãŸã‚ã®å¯¾ãƒã‚¤ãƒ³ã‚¿ã‚’ä½¿ã£ãŸã‚Šã€ã‚ã‚‹ã„ã¯ã€äºŒã¤ã®æ•°ã‚’è¶³ã—ãŸã‚Šã€ã¨ã„ã£ãŸã‚‚ã®) ãŒã€å‹ã¤ããƒã‚¤ãƒ³ã‚¿ã®æ·»ãˆå­—éƒ¨åˆ†ã®ã¿ã‚’ç”¨ã„ã‚‹ã€ã¨ã„ã†ã“ã¨ã‚‚ä»®å®šã™ã‚‹ã€‚
</p>

<p class="orig" lang="en">
For example, we can make a register machine support the instructions</p>

<p class="trans" lang="ja">
ãŸã¨ãˆã°ã€ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ»ãƒã‚·ãƒ³ã«æ¬¡ã®å‘½ä»¤ã‚’ã‚µãƒãƒ¼ãƒˆã•ã›ã‚‹ã“ã¨ãŒã§ãã‚‹â€”â€”
</p>

<a name="%_idx_5896"></a><a name="%_idx_5898"></a>
<p class="lisp">(assign &lt;<em>reg<sub>1</sub></em>&gt; (op car) (reg &lt;<em>reg<sub>2</sub></em>&gt;))

(assign &lt;<em>reg<sub>1</sub></em>&gt; (op cdr) (reg &lt;<em>reg<sub>2</sub></em>&gt;))
</p>

<p class="orig" lang="en">if we implement these, respectively, as</p>

<p class="trans" lang="ja">
ã‚‚ã—ã€ã“ã‚Œã‚‰ã‚’ãã‚Œãã‚Œä»¥ä¸‹ã®ã‚ˆã†ã«å®Ÿè£…ã™ã‚‹ãªã‚‰ã°ã€‚
</p>

<p class="lisp">(assign &lt;<em>reg<sub>1</sub></em>&gt; (op vector-ref) (reg the-cars) (reg &lt;<em>reg<sub>2</sub></em>&gt;))

(assign &lt;<em>reg<sub>1</sub></em>&gt; (op vector-ref) (reg the-cdrs) (reg &lt;<em>reg<sub>2</sub></em>&gt;))
</p>

<p class="orig" lang="en">The instructions</p>

<p class="trans" lang="ja">
ä»¥ä¸‹ã®å‘½ä»¤ã¯ã€
</p>

<a name="%_idx_5900"></a><a name="%_idx_5902"></a>

<p class="lisp">(perform (op set-car!) (reg &lt;<em>reg<sub>1</sub></em>&gt;) (reg &lt;<em>reg<sub>2</sub></em>&gt;))

(perform (op set-cdr!) (reg &lt;<em>reg<sub>1</sub></em>&gt;) (reg &lt;<em>reg<sub>2</sub></em>&gt;))
</p>

<p class="orig" lang="en">are implemented as
</p>

<p class="trans" lang="ja">
æ¬¡ã®ã‚ˆã†ã«å®Ÿè£…ã•ã‚Œã‚‹ã€‚
</p>

<p class="lisp">(perform
 (op vector-set!) (reg the-cars) (reg &lt;<em>reg<sub>1</sub></em>&gt;) (reg &lt;<em>reg<sub>2</sub></em>&gt;))

(perform
 (op vector-set!) (reg the-cdrs) (reg &lt;<em>reg<sub>1</sub></em>&gt;) (reg &lt;<em>reg<sub>2</sub></em>&gt;))
</p>

<p class="orig" lang="en">
<a name="%_idx_5904"></a><tt>Cons</tt> is performed by allocating an unused index and storing the
arguments to <tt>cons</tt> in <tt>the-cars</tt> and <tt>the-cdrs</tt> at that
indexed vector position.  We presume that there is a special register,
<a name="%_idx_5906"></a><tt>free</tt>, that always holds a pair pointer containing the next
available index, and that we can increment the index part of that
pointer to find the next free location.<a name="call_footnote_Temp_752" href="#footnote_Temp_752"><sup><small>11</small></sup></a>
For example, the instruction</p>

<p class="trans" lang="ja">
<tt>cons</tt> ã¯ã€ä½¿ã‚ã‚Œã¦ã„ãªã„æ·»ãˆå­—ã‚’å‰²ã‚Šå½“ã¦ã‚‹ã“ã¨ã¨ã€ãã®æ·»ãˆå­—ã®ã¤ã„ãŸãƒ™ã‚¯ã‚¿ä½ç½®ã«ãŠã„ã¦ã€<tt>the-cars</tt> ã¨ <tt>the-cdrs</tt> ã®ä¸­ã«ã€<tt>cons</tt> ã«å¯¾ã™ã‚‹å¼•æ•°ã‚’æ ¼ç´ã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€å®Ÿè¡Œã•ã‚Œã‚‹ã€‚
æ¬¡ã«åˆ©ç”¨å¯èƒ½ãªæ·»ãˆå­—ã‚’å«ã‚€å¯¾ãƒã‚¤ãƒ³ã‚¿ã‚’å¸¸ã«ä¿æŒã™ã‚‹ã€<tt>free</tt> ã¨ã„ã†ç‰¹åˆ¥ãªãƒ¬ã‚¸ã‚¹ã‚¿ãŒå­˜åœ¨ã™ã‚‹ã€ã¨ã„ã†ã“ã¨ã‚’ä»®å®šã—ã€ã¾ãŸã€æ¬¡ã®ç©ºã„ã¦ã„ã‚‹å ´æ‰€ã‚’è¦‹ã¤ã‘ã‚‹ãŸã‚ã«ãã®ãƒã‚¤ãƒ³ã‚¿ã®æ·»ãˆå­—éƒ¨åˆ†ã‚’ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€ã¨ä»®å®šã™ã‚‹<a href="#footnote_Temp_752"><sup><small>11</small></sup></a>ã€‚
ãŸã¨ãˆã°ã€æ¬¡ã®å‘½ä»¤ã¯ã€
</p>

<p class="lisp">(assign &lt;<em>reg<sub>1</sub></em>&gt; (op cons) (reg &lt;<em>reg<sub>2</sub></em>&gt;) (reg &lt;<em>reg<sub>3</sub></em>&gt;))
</p>

<p class="orig" lang="en">is implemented as the following sequence of vector
operations:<a name="call_footnote_Temp_753" href="#footnote_Temp_753"><sup><small>12</small></sup></a></p>

<p class="trans" lang="ja">
ä»¥ä¸‹ã®ä¸€é€£ã®ãƒ™ã‚¯ã‚¿æ¼”ç®—ã¨ã—ã¦å®Ÿè£…ã•ã‚Œã‚‹<a href="#footnote_Temp_753"><sup><small>12</small></sup></a>ã€‚
</p>

<p class="lisp">(perform
 (op vector-set!) (reg the-cars) (reg free) (reg &lt;<em>reg<sub>2</sub></em>&gt;))
(perform
 (op vector-set!) (reg the-cdrs) (reg free) (reg &lt;<em>reg<sub>3</sub></em>&gt;))
(assign &lt;<em>reg<sub>1</sub></em>&gt; (reg free))
(assign free (op +) (reg free) (const 1))
</p>

<p class="orig" lang="en">The <tt>eq?</tt> operation</p>

<p class="trans" lang="ja">
<tt>eq?</tt> æ¼”ç®—ã¯ã€
</p>

<p class="lisp">(op eq?) (reg &lt;<em>reg<sub>1</sub></em>&gt;) (reg &lt;<em>reg<sub>2</sub></em>&gt;)
</p>

<p class="orig" lang="en">simply tests the equality of all fields in the registers, and
<a name="%_idx_5910"></a><a name="%_idx_5912"></a><a name="%_idx_5914"></a><a name="%_idx_5916"></a>predicates such as <tt>pair?</tt>, <tt>null?</tt>, <tt>symbol?</tt>, and <tt>number?</tt> need only check the type field.</p>

<p class="trans" lang="ja">
å˜ã«ã€ãƒ¬ã‚¸ã‚¹ã‚¿å†…ã®ã™ã¹ã¦ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ç­‰ä¾¡æ€§ã‚’æ¤œæŸ»ã™ã‚‹ã ã‘ã§ã‚ã‚Šã€<tt>pair?</tt> ã‚„ <tt>null?</tt> ã‚„ <tt>symbol?</tt> ã‚„ <tt>number?</tt> ãªã©ã®è¿°èªã¯ã€ãŸã å‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’èª¿ã¹ã‚‹ã ã‘ã§ã‚ˆã„ã€‚
</p>

<a name="%_sec_Temp_754"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_754">Implementing stacks</a></h4>
<h4 class="trans" lang="ja">ã‚¹ã‚¿ãƒƒã‚¯ã‚’å®Ÿè£…ã™ã‚‹</h4>

<p class="orig" lang="en">
<a name="%_idx_5918"></a>
Although our register machines use stacks, we need do nothing special
here, since stacks can be modeled in terms of lists.  The stack can be
a list of the saved values, pointed to by a special register <tt>the-stack</tt>.  Thus, <tt>(save &lt;<em>reg</em>&gt;)</tt> can be implemented as</p>

<p class="trans" lang="ja">
ç§ãŸã¡ã®ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ»ãƒã‚·ãƒ³ã¯ã‚¹ã‚¿ãƒƒã‚¯ã‚’ä½¿ã†ãŒã€ã“ã“ã§ã¯ç‰¹åˆ¥ãªã“ã¨ã‚’ä½•ã‚‚ã—ãªãã¦ã‚ˆã„ã€‚ã¨ã„ã†ã®ã‚‚ã€ãƒªã‚¹ãƒˆã‚’ç”¨ã„ã¦ã‚¹ã‚¿ãƒƒã‚¯ã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã§ãã‚‹ã‹ã‚‰ã ã€‚
ã‚¹ã‚¿ãƒƒã‚¯ã¯ã€ä¿å­˜ã•ã‚ŒãŸå€¤ã®ãƒªã‚¹ãƒˆã§ã‚ã£ã¦ã‚‚ã‚ˆãã€ãã‚Œã¯ã€<tt>the-stack</tt> ã¨ã„ã†ç‰¹åˆ¥ãªãƒ¬ã‚¸ã‚¹ã‚¿ã«ã‚ˆã£ã¦æŒ‡ã•ã‚Œã¦ã„ã‚‹ã€‚
ã‚ˆã£ã¦ã€
<tt>(save &lt;<em class="en">reg</em>&gt;)</tt> 
ã‚’æ¬¡ã®ã‚ˆã†ã«å®Ÿè£…ã§ãã‚‹ã€‚
</p>

<a name="%_idx_5920"></a>
<p class="lisp">(assign the-stack (op cons) (reg &lt;<em>reg</em>&gt;) (reg the-stack))
</p>

<p class="orig" lang="en"><a name="%_idx_5922"></a>Similarly, <tt>(restore &lt;<em>reg</em>&gt;)</tt> can be implemented as
</p>

<p class="trans" lang="ja">
åŒæ§˜ã«ã€
<tt>(restore &lt;<em class="en">reg</em>&gt;)</tt> 
ã‚’æ¬¡ã®ã‚ˆã†ã«å®Ÿè£…ã§ãã‚‹ã—ã€
</p>

<p class="lisp">(assign &lt;<em>reg</em>&gt; (op car) (reg the-stack))
(assign the-stack (op cdr) (reg the-stack))
</p>

<p class="orig" lang="en">and <tt>(perform (op initialize-stack))</tt> can be implemented as
</p>

<p class="trans" lang="ja">
<tt>(perform (op initialize-stack))</tt> 
ã‚’æ¬¡ã®ã‚ˆã†ã«å®Ÿè£…ã§ãã‚‹ã€‚
</p>

<p class="lisp">(assign the-stack (const ()))
</p>

<p class="orig" lang="en">These operations can be further expanded in terms of the vector
operations given above.  In conventional computer architectures,
however, it is usually advantageous to allocate the stack as a
separate vector.  Then pushing and popping the stack can be
accomplished by incrementing or decrementing an index into that
vector.</p>

<p class="trans" lang="ja">
ä¸Šè¨˜ã§ä¸ãˆã‚‰ã‚ŒãŸãƒ™ã‚¯ã‚¿æ¼”ç®—ã‚’ç”¨ã„ã¦ã€ã“ã‚Œã‚‰ã®æ¼”ç®—ã‚’ã•ã‚‰ã«æ‹¡å¼µã§ãã‚‹ã€‚
ã—ã‹ã—ã€å¾“æ¥ã®ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ»ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã§ã¯ã€é€šå¸¸ã¯ã€åˆ¥å€‹ã®ãƒ™ã‚¯ã‚¿ã¨ã—ã¦ã‚¹ã‚¿ãƒƒã‚¯ã‚’å‰²ã‚Šå½“ã¦ã‚‹ã®ãŒå¥½éƒ½åˆã§ã‚ã‚‹ã€‚
ãã—ã¦ã€ã‚¹ã‚¿ãƒƒã‚¯ã‚’ãƒ—ãƒƒã‚·ãƒ¥ã—ãŸã‚Šãƒãƒƒãƒ—ã—ãŸã‚Šã™ã‚‹ã“ã¨ã¯ã€ãã®ãƒ™ã‚¯ã‚¿ã«å¯¾ã™ã‚‹æ·»ãˆå­—ã‚’ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã—ãŸã‚Šãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã—ãŸã‚Šã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€é”æˆã§ãã‚‹ã€‚
</p>

<p class="orig" lang="en">
<a name="%_thm_5.20"></a>
<b>Exercise 5.20.</b>  Draw the box-and-pointer representation and the memory-vector
representation (as in figure <a href="#%_fig_5.14">5.14</a>) of the
list structure produced by</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ5.20.</b> ä»¥ä¸‹ã«ã‚ˆã‚Šä½œã‚Šå‡ºã•ã‚Œã‚‹ãƒªã‚¹ãƒˆæ§‹é€ ã®ã€(å›³<a href="#%_fig_5.14">5.14</a>ã§ã®ã‚ˆã†ãª) ç®±ã¨ãƒã‚¤ãƒ³ã‚¿ã«ã‚ˆã‚‹è¡¨ç¾ãŠã‚ˆã³ãƒ¡ãƒ¢ãƒªãƒ»ãƒ™ã‚¯ã‚¿è¡¨ç¾ã‚’ã€æã‘ã€‚
</p>

<p class="lisp">(define x (cons 1 2))
(define y (list x x))
</p>

<p class="orig" lang="en">with the <tt>free</tt> pointer initially <tt>p1</tt>.  What is the final
value of <tt>free</tt> ?  What pointers represent the values of <tt>x</tt> and <tt>y</tt> ?
</p>

<p class="trans" lang="ja">
ãªãŠã€ã“ã“ã§ã€<tt>free</tt> ãƒã‚¤ãƒ³ã‚¿ã¯æœ€åˆ <tt>p1</tt> ã§ã‚ã‚‹ã€‚
<tt>free</tt> ã®æœ€çµ‚çš„ãªå€¤ã¯ä½•ã‹?
ã©ã®ãƒã‚¤ãƒ³ã‚¿ãŒã€<tt>x</tt> ã¨ <tt>y</tt> ã®å€¤ã‚’è¡¨ã—ã¦ã„ã‚‹ã‹?
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.21"></a>
<b>Exercise 5.21.</b>  <a name="%_idx_5924"></a>Implement register machines for the following procedures.
Assume that the list-structure memory operations are available as
machine primitives.</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ5.21.</b> ä»¥ä¸‹ã®æ‰‹ç¶šãã«ã¤ã„ã¦ã®ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ»ãƒã‚·ãƒ³ã‚’å®Ÿè£…ã›ã‚ˆã€‚
ãƒªã‚¹ãƒˆæ§‹é€ ã®ãƒ¡ãƒ¢ãƒªæ¼”ç®—ãŒã€ãƒã‚·ãƒ³ã®ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã¨ã—ã¦åˆ©ç”¨å¯èƒ½ã§ã‚ã‚‹ã‚‚ã®ã¨ä»®å®šã›ã‚ˆã€‚
</p>

<ol class="orig alph" start="1" lang="en">
<li>Recursive <tt>count-leaves</tt>:</li>
</ol>

<ol class="trans alph" start="1" lang="ja">
<li>å†å¸°çš„ãª <tt>count-leaves</tt>:</li>
</ol>

<p class="lisp">(define (count-leaves tree)
  (cond ((null? tree) 0)
        ((not (pair? tree)) 1)
        (else (+ (count-leaves (car tree))
                 (count-leaves (cdr tree))))))
</p>

<ol class="orig alph" start="2" lang="en">
<li>Recursive <tt>count-leaves</tt> with explicit counter:</li>
</ol>

<ol class="trans alph" start="2" lang="ja">
<li>æ˜ç¤ºçš„ãªã‚«ã‚¦ãƒ³ã‚¿ã¤ãã®å†å¸°çš„ãª <tt>count-leaves</tt>:</li>
</ol>

<p class="lisp">(define (count-leaves tree)
  (define (count-iter tree n)
    (cond ((null? tree) n)
          ((not (pair? tree)) (+ n 1))
          (else (count-iter (cdr tree)
                            (count-iter (car tree) n)))))
  (count-iter tree 0))
</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<p class="orig" lang="en">
<a name="%_thm_5.22"></a>
<b>Exercise 5.22.</b>  <a name="%_idx_5926"></a><a name="%_idx_5928"></a>Exercise <a href="22_sec3_3.html#%_thm_3.12">3.12</a> of section <a href="22_sec3_3.html#%_sec_3.3.1">3.3.1</a>
presented an <tt>append</tt> procedure that appends two lists to form a
new list and an <tt>append!</tt> procedure that splices two lists
together.  Design a register machine to implement each of these
procedures.  Assume that the list-structure memory operations are
available as primitive operations.
</p>

<p class="trans" lang="ja">
<b>ç·´ç¿’å•é¡Œ5.22.</b> <a href="22_sec3_3.html#%_sec_3.3.1">3.3.1</a>ç¯€ã®ç·´ç¿’å•é¡Œ<a href="22_sec3_3.html#%_thm_3.12">3.12</a>ã¯ã€äºŒã¤ã®ãƒªã‚¹ãƒˆã‚’è¶³ã—åˆã‚ã›ã¦æ–°ãŸãªãƒªã‚¹ãƒˆã‚’å½¢æˆã™ã‚‹ <tt>append</tt> æ‰‹ç¶šãã¨ã€äºŒã¤ã®ãƒªã‚¹ãƒˆã‚’ä¸€ã¤ã«ç¶™ãåˆã‚ã›ã‚‹ <tt>append!</tt> æ‰‹ç¶šãã¨ã‚’æç¤ºã—ãŸã€‚
ã“ã‚Œã‚‰ã®æ‰‹ç¶šãã®å„ã€…ã‚’å®Ÿè£…ã™ã‚‹ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ»ãƒã‚·ãƒ³ã‚’è¨­è¨ˆã›ã‚ˆã€‚
ãƒªã‚¹ãƒˆæ§‹é€ ã®ãƒ¡ãƒ¢ãƒªæ¼”ç®—ãŒã€åŸå§‹çš„æ¼”ç®—ã¨ã—ã¦åˆ©ç”¨å¯èƒ½ã§ã‚ã‚‹ã‚‚ã®ã¨ä»®å®šã›ã‚ˆã€‚

</p>

<p class="exercise"><span class="ex_comment">
</span></p>

<a name="%_sec_5.3.2"></a>
<h3 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_5.3.2">5.3.2  Maintaining the Illusion of Infinite Memory</a></h3>
<h3 class="trans" lang="ja">5.3.2 ç„¡é™ãƒ¡ãƒ¢ãƒªã¨ã„ã†å¹»å½±ã‚’ç¶­æŒã™ã‚‹</h3>

<a name="%_idx_5930"></a>
<p class="orig" lang="en">
The representation method outlined in
section <a href="#%_sec_5.3.1">5.3.1</a> solves the problem of implementing
list structure, provided that we have an infinite amount of memory.
With a real computer we will eventually run out of free space in which
to construct new pairs.<a name="call_footnote_Temp_758" href="#footnote_Temp_758"><sup><small>13</small></sup></a>
However, most of the pairs generated in a typical
computation are used only to hold intermediate results.  After these
results are accessed, the pairs are no longer needed -- they are <em>garbage</em>.  For instance, the computation</p>

<p class="trans" lang="ja">
<a href="#%_sec_5.3.1">5.3.1</a>ç¯€ã§æ¦‚è¦ã‚’èª¬æ˜ã—ãŸè¡¨ç¾æ‰‹æ³•ã¯ã€ãƒªã‚¹ãƒˆæ§‹é€ ã‚’å®Ÿè£…ã™ã‚‹å•é¡Œã‚’è§£æ±ºã™ã‚‹â€”â€”ç„¡é™ã®é‡ã®ãƒ¡ãƒ¢ãƒªãŒã‚ã‚‹ã¨ã™ã‚Œã°ã€ã§ã¯ã‚ã‚‹ãŒã€‚
ç¾å®Ÿã®ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã§ã¯ã€æ–°ãŸãªå¯¾ã‚’æ§‹ç¯‰ã™ã¹ãç©ºãå ´æ‰€ã‚’ã€é‚ã«ã¯ä½¿ã„æœãŸã—ã¦ã—ã¾ã†ã ã‚ã† href="#footnote_Temp_758"><sup><small>13</small></sup></a>ã€‚
ã—ã‹ã—ã€å…¸å‹çš„ãªè¨ˆç®—ã«ãŠã„ã¦ç”Ÿæˆã•ã‚Œã‚‹å¯¾ã®ã»ã¨ã‚“ã©ã¯ã€ä¸­é–“çš„ãªçµæœã‚’ä¿æŒã™ã‚‹ãŸã‚ã ã‘ã«ä½¿ã‚ã‚Œã‚‹ã€‚
ã“ã‚Œã‚‰ã®çµæœãŒã‚¢ã‚¯ã‚»ã‚¹ã•ã‚ŒãŸå¾Œã«ã¯ã€ãã‚Œã‚‰ã®å¯¾ã¯ã‚‚ã¯ã‚„ä¸è¦ã â€”â€”ãã‚Œã‚‰ã¯<em><ruby><rb>ã”ã¿</rb><rp> (</rp><rt>ã‚¬ãƒ¼ãƒ™ã‚¸</rt><rp>) </rp></ruby></em>ãªã®ã ã€‚
ãŸã¨ãˆã°ã€ä»¥ä¸‹ã®è¨ˆç®—ã¯ã€
</p>

<p class="lisp">(accumulate + 0 (filter odd? (enumerate-interval 0 n)))
</p>

<p class="orig" lang="en">constructs two lists: the enumeration and the result of filtering
the enumeration.  When the accumulation is complete, these lists are
no longer needed, and the allocated memory can be reclaimed.  If we
can arrange to collect all the garbage periodically, and if this turns
out to recycle memory at about the same rate at which we construct new
pairs, we will have preserved the illusion that there is an infinite
amount of memory.</p>

<p class="trans" lang="ja">
äºŒã¤ã®ãƒªã‚¹ãƒˆã‚’æ§‹ç¯‰ã™ã‚‹â€”â€”æ•°ãˆä¸Šã’ã¨ã€ãã®æ•°ãˆä¸Šã’ã‚’ãƒ•ã‚£ãƒ«ã‚¿ã«ã‹ã‘ãŸçµæœã§ã‚ã‚‹ã€‚
è“„ç©ãŒå®Œäº†ã™ã‚‹ã¨ã€ã“ã‚Œã‚‰ã®ãƒªã‚¹ãƒˆã¯ã‚‚ã¯ã‚„ä¸è¦ã§ã‚ã‚Šã€å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸãƒ¡ãƒ¢ãƒªã‚’å†åˆ©ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
ã‚‚ã—ã€å®šæœŸçš„ã«ã™ã¹ã¦ã®ã”ã¿ã‚’åé›†ã™ã‚‹ã‚ˆã†ã«æ‰‹é…ã§ãã‚‹ãªã‚‰ã€ã‹ã¤ã€ã“ã‚ŒãŒã€æ–°ãŸãªå¯¾ã‚’æ§‹ç¯‰ã™ã‚‹ã®ã¨ã»ã¼åŒã˜é€Ÿåº¦ã§ãƒ¡ãƒ¢ãƒªã‚’å†åˆ©ç”¨ã™ã‚‹ã®ã ã¨åˆ†ã‹ã‚Œã°ã€ç§ãŸã¡ã¯ã€ç„¡é™ã®é‡ã®ãƒ¡ãƒ¢ãƒªãŒå­˜åœ¨ã™ã‚‹ã®ã ã¨ã„ã†å¹»å½±ã‚’ã€ä¿ã¡ç¶šã‘ã¦ã„ã‚‹ã“ã¨ã ã‚ã†ã€‚
</p>

<p class="orig" lang="en">
In order to recycle pairs, we must have a way to determine which
allocated pairs are not needed (in the sense that their contents can
no longer influence the future of the computation).  The method we
shall examine for accomplishing this is known as <em>garbage
collection</em>.  Garbage collection is based on the observation that, at
any moment in a Lisp interpretation, the only objects that can
affect the future of the computation are those that can be reached by
some succession of <tt>car</tt> and <tt>cdr</tt> operations starting from
the pointers that are currently in the machine registers.<a name="call_footnote_Temp_759" href="#footnote_Temp_759"><sup><small>14</small></sup></a>  Any memory cell
that is not so accessible may be recycled.</p>

<p class="trans" lang="ja">
å¯¾ã‚’å†åˆ©ç”¨ã™ã‚‹ãŸã‚ã«ã¯ã€å‰²ã‚Šå½“ã¦æ¸ˆã¿ã®ã©ã®å¯¾ãŒ (å¯¾ã®ä¸­èº«ãŒã‚‚ã¯ã‚„è¨ˆç®—ã®å°†æ¥ã«å½±éŸ¿ã‚’ä¸ãˆã‚‹ã“ã¨ãŒã‚ã‚Šå¾—ãªã„ã€ã¨ã„ã†æ„å‘³ã§) ä¸è¦ãªã®ã‹ã‚’åˆ¤å®šã™ã‚‹æ–¹æ³•ã‚’æŒãŸã­ã°ãªã‚‰ãªã„ã€‚
ã“ã‚Œã‚’é”æˆã™ã‚‹ãŸã‚ã«ç§ãŸã¡ãŒæ¤œè¨ã™ã‚‹ã“ã¨ã«ãªã‚‹æ–¹æ³•ã¯ã€<em><ruby><rb>ã‚¬ãƒ¼ãƒ™ã‚¸</rb><rp> (</rp><rt>ã”ã¿</rt><rp>) </rp></ruby>ãƒ»<ruby><rb>ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³</rb><rp> (</rp><rt>ã‚ã¤ã‚</rt><rp>) </rp></ruby></em>ã¨ã—ã¦çŸ¥ã‚‰ã‚Œã‚‹ã€‚
Lisp è§£é‡ˆã«ãŠã‘ã‚‹ã©ã®ç¬é–“ã«ãŠã„ã¦ã‚‚ã€è¨ˆç®—ã®å°†æ¥ã«å½±éŸ¿ã‚’ä¸ãˆã‚‹ã“ã¨ãŒã§ãã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã¯ã€ãŸã ã€ãƒã‚·ãƒ³ãƒ»ãƒ¬ã‚¸ã‚¹ã‚¿ã«ä»Šã‚ã‚‹ãƒã‚¤ãƒ³ã‚¿ã‹ã‚‰å§‹ã¾ã‚‹ã€ã‚ã‚‹ä¸€é€£ã® <tt>car</tt> æ¼”ç®—ã¨ <tt>cdr</tt> æ¼”ç®—ã«ã‚ˆã‚Šåˆ°é”ã§ãã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã ã‘ãªã®ã ã€ã¨ã„ã†è¦³å¯Ÿçµæœã«ã€ã‚¬ãƒ¼ãƒ™ã‚¸ãƒ»ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã¯ã€åŸºã¥ã„ã¦ã„ã‚‹<a href="#footnote_Temp_759"><sup><small>14</small></sup></a>ã€‚
ãã®ã‚ˆã†ã«ã—ã¦ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ãªã®ã§ã¯ãªã„ãƒ¡ãƒ¢ãƒªã‚»ãƒ«ã¯ã€ã©ã‚Œã‚‚å†åˆ©ç”¨ã•ã‚Œã†ã‚‹ã€‚
</p>

<p class="orig" lang="en">
There are many ways to perform garbage collection.  The method we
shall examine here is called <a name="%_idx_5932"></a><a name="%_idx_5934"></a><em>stop-and-copy</em>.  The basic idea is
to divide memory into two halves: ``working memory'' and ``free
memory.''  When <tt>cons</tt> constructs pairs, it allocates these in
working memory.  When working memory is full, we perform garbage
collection by locating all the useful pairs in working memory and
copying these into consecutive locations in free memory.  (The useful
pairs are located by tracing all the <tt>car</tt> and <tt>cdr</tt> pointers,
starting with the machine registers.)  Since we do not copy the
garbage, there will presumably be additional free memory that we can
use to allocate new pairs.  In addition, nothing in the working memory
is needed, since all the useful pairs in it have been copied.  Thus,
if we interchange the roles of working memory and free memory, we can
continue processing; new pairs will be allocated in the new working
memory (which was the old free memory).  When this is full, we can
copy the useful pairs into the new free memory (which was the old
working memory).<a name="call_footnote_Temp_760" href="#footnote_Temp_760"><sup><small>15</small></sup></a></p>

<p class="trans" lang="ja">
ã‚¬ãƒ¼ãƒ™ã‚¸ãƒ»ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œã™ã‚‹ã«ã¯å¤šãã®æ–¹æ³•ãŒã‚ã‚‹ã€‚
ã“ã“ã§ç§ãŸã¡ãŒåŸå‘³ã™ã‚‹ã“ã¨ã«ãªã‚‹æ–¹æ³•ã¯ã€<em>ã‚¹ãƒˆãƒƒãƒ—ãƒ»ã‚¢ãƒ³ãƒ‰ãƒ»ã‚³ãƒ”ãƒ¼</em>ã¨å‘¼ã°ã‚Œã‚‹ã€‚
åŸºæœ¬çš„ãªè€ƒãˆæ–¹ã¯ã€ãƒ¡ãƒ¢ãƒªã‚’åŠåˆ†ãšã¤ã«â€”â€”ã€Œãƒ¯ãƒ¼ã‚­ãƒ³ã‚°ãƒ¡ãƒ¢ãƒªã€ã¨ã€Œç©ºããƒ¡ãƒ¢ãƒªã€ã«â€”â€”åˆ†ã‘ã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚
<tt>cons</tt> ã¯ã€å¯¾ã‚’æ§‹ç¯‰ã™ã‚‹ã¨ãã€ã“ã‚Œã‚‰ã®å¯¾ã‚’ãƒ¯ãƒ¼ã‚­ãƒ³ã‚°ãƒ¡ãƒ¢ãƒªã«å‰²ã‚Šå½“ã¦ã‚‹ã€‚
ãƒ¯ãƒ¼ã‚­ãƒ³ã‚°ãƒ¡ãƒ¢ãƒªãŒæº€æ¯ã®ã¨ãã€ç§ãŸã¡ã¯ã€ãƒ¯ãƒ¼ã‚­ãƒ³ã‚°ãƒ¡ãƒ¢ãƒªä¸­ã®ã™ã¹ã¦ã®æœ‰ç”¨ãªå¯¾ã®å ´æ‰€ã‚’çªãæ­¢ã‚ã¦ã€ã“ã‚Œã‚‰ã®å¯¾ã‚’ç©ºããƒ¡ãƒ¢ãƒªå†…ã®é€£ç¶šã™ã‚‹å ´æ‰€ã«è¤‡è£½ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€ã‚¬ãƒ¼ãƒ™ã‚¸ãƒ»ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¡Œã† (ãƒã‚·ãƒ³ãƒ»ãƒ¬ã‚¸ã‚¹ã‚¿ã‹ã‚‰å§‹ã‚ã¦ã€ã™ã¹ã¦ã® <tt>car</tt> ãƒã‚¤ãƒ³ã‚¿ã¨ <tt>cdr</tt> ãƒã‚¤ãƒ³ã‚¿ã‚’è¿½è·¡ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€æœ‰ç”¨ãªå¯¾ã®å ´æ‰€ãŒçªãæ­¢ã‚ã‚‰ã‚Œã‚‹)ã€‚
ã”ã¿ã¯è¤‡è£½ã—ãªã„ã®ã§ã€æ–°ãŸãªå¯¾ã‚’å‰²ã‚Šå½“ã¦ã‚‹ã®ã«ä½¿ç”¨å¯èƒ½ãªä»˜åŠ çš„ãªç©ºããƒ¡ãƒ¢ãƒªãŒã€ãŠãã‚‰ãã¯å­˜åœ¨ã™ã‚‹ã ã‚ã†ã€‚
ã•ã‚‰ã«ã€ãƒ¯ãƒ¼ã‚­ãƒ³ã‚°ãƒ¡ãƒ¢ãƒªä¸­ã®ä½•ç‰©ã‚‚ã€å¿…è¦ã§ã¯ãªã„ã€‚ã¨ã„ã†ã®ã‚‚ã€ãƒ¯ãƒ¼ã‚­ãƒ³ã‚°ãƒ¡ãƒ¢ãƒªä¸­ã®ã™ã¹ã¦ã®æœ‰ç”¨ãªå¯¾ã¯è¤‡è£½æ¸ˆã¿ã ã‹ã‚‰ã§ã‚ã‚‹ã€‚
ã‚ˆã£ã¦ã€ã‚‚ã—ãƒ¯ãƒ¼ã‚­ãƒ³ã‚°ãƒ¡ãƒ¢ãƒªã¨ç©ºããƒ¡ãƒ¢ãƒªã®å½¹å‰²ã‚’äº¤æ›ã™ã‚Œã°ã€å‡¦ç†ã‚’ç¶šã‘ã‚‰ã‚Œã‚‹ã€‚æ–°ãŸãªå¯¾ã¯ã€æ–°ãƒ¯ãƒ¼ã‚­ãƒ³ã‚°ãƒ¡ãƒ¢ãƒªå†…ã« (æ—§ç©ºããƒ¡ãƒ¢ãƒªã ã£ãŸã¨ã“ã‚ã«) å‰²ã‚Šå½“ã¦ã‚‰ã‚Œã‚‹ã ã‚ã†ã€‚
ã“ã‚ŒãŒæº€æ¯ã«ãªã£ãŸã‚‰ã€æ–°ç©ºããƒ¡ãƒ¢ãƒªå†…ã« (æ—§ãƒ¯ãƒ¼ã‚­ãƒ³ã‚°ãƒ¡ãƒ¢ãƒªã ã£ãŸã¨ã“ã‚ã«) æœ‰ç”¨ãªå¯¾ã‚’è¤‡è£½ã§ãã‚‹<a href="#footnote_Temp_760"><sup><small>15</small></sup></a>ã€‚
</p>

<a name="%_sec_Temp_761"></a>
<h4 class="orig" lang="en"><a href="04_toc.html#%_toc_%_sec_Temp_761">Implementation of a stop-and-copy garbage collector</a></h4>
<h4 class="trans" lang="ja">ã‚¹ãƒˆãƒƒãƒ—ãƒ»ã‚¢ãƒ³ãƒ‰ãƒ»ã‚³ãƒ”ãƒ¼æ–¹å¼ã®ã‚¬ãƒ¼ãƒ™ã‚¸ãƒ»ã‚³ãƒ¬ã‚¯ã‚¿ã®å®Ÿè£…</h4>

<p class="orig" lang="en">
We now use our register-machine language to describe the stop-and-copy
algorithm in more detail.  We will assume that there is a register
called <a name="%_idx_5966"></a><tt>root</tt> that contains a pointer to a structure that
eventually points at all accessible data.  This can be arranged by
storing the contents of all the machine registers in a
pre-allocated list pointed at by <tt>root</tt> just before starting
garbage collection.<a name="call_footnote_Temp_762" href="#footnote_Temp_762"><sup><small>16</small></sup></a> We also assume that, in addition to the
current working memory, there is free memory available into which we
can copy the useful data.  The current working memory consists of
vectors whose base addresses are in <a name="%_idx_5968"></a><a name="%_idx_5970"></a>registers called <tt>the-cars</tt>
and <tt>the-cdrs</tt>, and the free memory is in registers called <a name="%_idx_5972"></a><a name="%_idx_5974"></a><tt>new-cars</tt> and <tt>new-cdrs</tt>.</p>

<p class="trans" lang="ja">
ã“ã“ã§ã€ç§ãŸã¡ã®ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ»ãƒã‚·ãƒ³è¨€èªã‚’ç”¨ã„ã¦ã€ã‚ˆã‚Šè©³ã—ãã‚¹ãƒˆãƒƒãƒ—ãƒ»ã‚¢ãƒ³ãƒ‰ãƒ»ã‚³ãƒ”ãƒ¼ãƒ»ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’è¨˜è¿°ã™ã‚‹ã€‚
ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ãªã™ã¹ã¦ã®ãƒ‡ãƒ¼ã‚¿ã‚’æœ€çµ‚çš„ã«ã¯æŒ‡ã—ã¦ã„ã‚‹æ§‹é€ ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã‚’å«ã‚€ã€<tt>root</tt> ã¨å‘¼ã°ã‚Œã‚‹ãƒ¬ã‚¸ã‚¹ã‚¿ãŒã‚ã‚‹ã€ã¨ä»®å®šã™ã‚‹ã€‚
ã“ã‚Œã¯ã€<tt>root</tt> ã«ã‚ˆã‚ŠæŒ‡ã•ã‚ŒãŸã€äºˆã‚å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸãƒªã‚¹ãƒˆã«ã€ã‚¬ãƒ¼ãƒ™ã‚¸ãƒ»ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’å§‹ã‚ã‚‹ç›´å‰ã«ã€ã™ã¹ã¦ã®ãƒã‚·ãƒ³ãƒ»ãƒ¬ã‚¸ã‚¹ã‚¿ã®ä¸­èº«ã‚’æ ¼ç´ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€æ‰‹ç­ˆã‚’æ•´ãˆã‚‹ã“ã¨ãŒã§ãã‚‹<a href="#footnote_Temp_762"><sup><small>16</small></sup></a>ã€‚
ã¾ãŸã€æœ‰ç”¨ãªãƒ‡ãƒ¼ã‚¿ã‚’è¤‡è£½ã§ãã‚‹ã‚ˆã†ãªã€åˆ©ç”¨å¯èƒ½ãªç©ºããƒ¡ãƒ¢ãƒªãŒã€ç¾åœ¨ã®ãƒ¯ãƒ¼ã‚­ãƒ³ã‚°ãƒ¡ãƒ¢ãƒªã«åŠ ãˆã¦æ›´ã«å­˜åœ¨ã™ã‚‹ã€ã¨ã„ã†ã“ã¨ã‚‚ä»®å®šã™ã‚‹ã€‚
ç¾åœ¨ã®ãƒ¯ãƒ¼ã‚­ãƒ³ã‚°ãƒ¡ãƒ¢ãƒªã¯ã€<tt>the-cars</tt> ãŠã‚ˆã³ <tt>the-cdrs</tt> ã¨å‘¼ã°ã‚Œã‚‹ãƒ¬ã‚¸ã‚¹ã‚¿ã«ãƒ™ãƒ¼ã‚¹ãƒ»ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒã‚ã‚‹ã‚ˆã†ãªãƒ™ã‚¯ã‚¿ã‹ã‚‰ãªã‚Šã€ç©ºããƒ¡ãƒ¢ãƒªã®æ–¹ã¯ã€<tt>new-cars</tt> ãŠã‚ˆã³ <tt>new-cdrs</tt> ã¨å‘¼ã°ã‚Œã‚‹ãƒ¬ã‚¸ã‚¹ã‚¿ã«ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
Garbage collection is triggered when we exhaust the free cells in the
current working memory, that is, when a <tt>cons</tt> operation attempts
to increment the <tt>free</tt> pointer beyond the end of the memory
vector.  When the garbage-collection process is complete, the <tt>root</tt> pointer will point into the new memory, all objects accessible
from the <tt>root</tt> will have been moved to the new memory, and the
<tt>free</tt> pointer will indicate the next place in the new memory
where a new pair can be allocated.  In addition, the roles of working
memory and new memory will have been interchanged -- new pairs will be
constructed in the new memory, beginning at the place indicated by
<tt>free</tt>, and the (previous) working memory will be available as the
new memory for the next garbage collection.
Figure <a href="#%_fig_5.15">5.15</a> shows the arrangement of memory just
before and just after garbage collection.</p>

<p class="trans" lang="ja">
ã‚¬ãƒ¼ãƒ™ã‚¸ãƒ»ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã¯ã€ç¾åœ¨ã®ãƒ¯ãƒ¼ã‚­ãƒ³ã‚°ãƒ¡ãƒ¢ãƒªå†…ã®ç©ºãã‚»ãƒ«ã‚’ä½¿ã„æœãŸã—ãŸã¨ãâ€”â€”ã¤ã¾ã‚Šã€<tt>cons</tt> æ¼”ç®—ãŒã€ãƒ¡ãƒ¢ãƒªãƒ»ãƒ™ã‚¯ã‚¿ã®æœ«å°¾ã‚ˆã‚Šã‚‚å…ˆã¸ã¨ <tt>free</tt> ãƒã‚¤ãƒ³ã‚¿ã‚’ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã—ã‚ˆã†ã¨è©¦ã¿ãŸã¨ãâ€”â€”ã«ã€å¼•ãèµ·ã“ã•ã‚Œã‚‹ã€‚
ã‚¬ãƒ¼ãƒ™ã‚¸ãƒ»ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ãƒ»ãƒ—ãƒ­ã‚»ã‚¹ãŒå®Œäº†ã™ã‚‹ã¨ã€<tt>root</tt> ãƒã‚¤ãƒ³ã‚¿ã¯æ–°ãŸãªãƒ¡ãƒ¢ãƒªå†…ã‚’æŒ‡ã—ã¦ã„ã‚‹ã“ã¨ã ã‚ã†ã—ã€<tt>root</tt> ã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ãªã™ã¹ã¦ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãã®æ–°ãŸãªãƒ¡ãƒ¢ãƒªã¸ç§»å‹•æ¸ˆã¿ã«ãªã£ã¦ã„ã‚‹ã ã‚ã†ã—ã€<tt>free</tt> ãƒã‚¤ãƒ³ã‚¿ã¯ãã®æ–°ãŸãªãƒ¡ãƒ¢ãƒªå†…ã§æ–°ãŸãªå¯¾ã‚’å‰²ã‚Šå½“ã¦å¯èƒ½ãªæ¬¡ã®å ´æ‰€ã‚’ç¤ºã—ã¦ã„ã‚‹ã“ã¨ã ã‚ã†ã€‚
ã•ã‚‰ã«ã€ãƒ¯ãƒ¼ã‚­ãƒ³ã‚°ãƒ¡ãƒ¢ãƒªã¨æ–°ãŸãªãƒ¡ãƒ¢ãƒªã®å½¹å‰²ãŒå…¥ã‚Œæ›¿ã‚ã£ã¦ã„ã‚‹ã“ã¨ã ã‚ã†â€”â€”ã¤ã¾ã‚Šã€æ–°ãŸãªå¯¾ã¯ã€<tt>free</tt> ã«ã‚ˆã‚Šç¤ºã•ã‚Œã‚‹å ´æ‰€ã‹ã‚‰å§‹ã¾ã‚‹æ–°ãŸãªãƒ¡ãƒ¢ãƒªå†…ã«æ§‹ç¯‰ã•ã‚Œã‚‹ã ã‚ã†â€”â€”ã—ã€(ä»¥å‰ã®) ãƒ¯ãƒ¼ã‚­ãƒ³ã‚°ãƒ¡ãƒ¢ãƒªãŒæ¬¡ã®ã‚¬ãƒ¼ãƒ™ã‚¸ãƒ»ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã§ã¯æ–°ãŸãªãƒ¡ãƒ¢ãƒªã¨ã—ã¦åˆ©ç”¨å¯èƒ½ã«ãªã‚‹ã ã‚ã†ã€‚
å›³<a href="#%_fig_5.15">5.15</a>ã¯ã€ã‚¬ãƒ¼ãƒ™ã‚¸ãƒ»ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®ç›´å‰ã¨ç›´å¾Œã®ãƒ¡ãƒ¢ãƒªã®é…ç½®ã‚’ç¤ºã—ã¦ã„ã‚‹ã€‚
</p>

<figure>
<a name="%_fig_5.15"></a>
<img src="ch5-Z-G-8.gif" border="0">
<figcaption class="orig" lang="en"><b>Figure 5.15:</b>  Reconfiguration of memory by the garbage-collection 
process.</figcaption>
<figcaption class="trans" lang="ja"><b>å›³5.15:</b> ã‚¬ãƒ¼ãƒ™ã‚¸ãƒ»ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ãƒ»ãƒ—ãƒ­ã‚»ã‚¹ã«ã‚ˆã‚‹ãƒ¡ãƒ¢ãƒªã®å†æ§‹æˆ</figcaption>
</figure>

<p class="orig" lang="en">
<a name="%_idx_5976"></a><a name="%_idx_5978"></a>The state of the garbage-collection process is controlled by
maintaining two pointers: <tt>free</tt> and <tt>scan</tt>.  These are
initialized to point to the beginning of the new memory.  The
algorithm begins by relocating the pair pointed at by <tt>root</tt> to
the beginning of the new memory.  The pair is copied, the <tt>root</tt>
pointer is adjusted to point to the new location, and the <tt>free</tt>
pointer is incremented.  In addition, the old location of the pair is
marked to show that its contents have been moved.  This marking is
done as follows: In the <tt>car</tt> position, we place a special tag
that signals that this is an already-moved object.  (Such an object is
traditionally called a <a name="%_idx_5980"></a><em>broken heart</em>.)<a name="call_footnote_Temp_763" href="#footnote_Temp_763"><sup><small>17</small></sup></a>  In the <tt>cdr</tt> position we place a <a name="%_idx_5988"></a><em>forwarding
address</em> that points at the location to which the object has been
moved.</p>

<p class="trans" lang="ja">
ã‚¬ãƒ¼ãƒ™ã‚¸ãƒ»ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ãƒ»ãƒ—ãƒ­ã‚»ã‚¹ã®çŠ¶æ…‹ã¯ã€äºŒã¤ã®ãƒã‚¤ãƒ³ã‚¿â€”â€” <tt>free</tt> ã¨ <tt>scan</tt> â€”â€”ã‚’ç¶­æŒã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€åˆ¶å¾¡ã•ã‚Œã‚‹ã€‚
ã“ã‚Œã‚‰ã¯ã€æ–°ãŸãªãƒ¡ãƒ¢ãƒªã®å…ˆé ­ã‚’æŒ‡ã™ã‚ˆã†ã«ã€åˆæœŸåŒ–ã•ã‚Œã‚‹ã€‚
æœ¬ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯ã€<tt>root</tt> ã«ã‚ˆã£ã¦æŒ‡ã•ã‚Œã¦ã„ã‚‹å¯¾ã‚’ã€æ–°ãŸãªãƒ¡ãƒ¢ãƒªå…ˆé ­ã¸ã¨å†é…ç½®ã™ã‚‹ã“ã¨ã‹ã‚‰å§‹ã¾ã‚‹ã€‚
ãã®å¯¾ã‚’è¤‡è£½ã—ã€æ–°ãŸãªå ´æ‰€ã‚’æŒ‡ã™ã‚ˆã†ã« <tt>root</tt> ãƒã‚¤ãƒ³ã‚¿ã‚’èª¿æ•´ã—ã€<tt>free</tt> ãƒã‚¤ãƒ³ã‚¿ã‚’ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã™ã‚‹ã€‚
ã•ã‚‰ã«ã€ãã®å¯¾ã®ã‹ã¤ã¦ã®å ´æ‰€ã«ã¯ã€ãã®ä¸­èº«ãŒç§»å‹•æ¸ˆã¿ã ã¨ç¤ºã™ã‚ˆã†ã«ã€å°ã‚’ã¤ã‘ã‚‹ã€‚
ã“ã®å°ã¥ã‘ã¯ã€æ¬¡ã®ã‚ˆã†ã«è¡Œã‚ã‚Œã‚‹ã€‚
<tt>car</tt> ä½ç½®ã«ã¯ã€ã“ã‚Œã¯æ—¢ã«ç§»å‹•ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãªã®ã ã¨çŸ¥ã‚‰ã›ã‚‹ã€ç‰¹åˆ¥ãªã‚¿ã‚°ã‚’ç½®ã
(ãã†ã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ä¼çµ±çš„ã«ã¯<ruby><rb>å¤±æ„</rb><rp> (</rp><rt>ãƒ–ãƒ­ãƒ¼ã‚¯ãƒ³ãƒ»ãƒãƒ¼ãƒˆ</rt><rp>) </rp></ruby>ã¨å‘¼ã°ã‚Œã‚‹)<a name="call_footnote_Temp_763" href="#footnote_Temp_763"><sup><small>17</small></sup></a>ã€‚
<tt>cdr</tt> ä½ç½®ã«ã¯ã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç§»å‹•ã•ã‚ŒãŸå…ˆã®ä½ç½®ã‚’æŒ‡ã™ã€<em>è»¢é€å…ˆã‚¢ãƒ‰ãƒ¬ã‚¹</em>ã‚’ç½®ãã€‚
</p>

<p class="orig" lang="en">
After relocating the root, the garbage collector enters its basic
cycle.  At each step in the algorithm, the <tt>scan</tt> pointer
(initially pointing at the relocated root) points at a pair that has
been moved to the new memory but whose <tt>car</tt> and <tt>cdr</tt>
pointers still refer to objects in the old memory.  These objects are
each relocated, and the <tt>scan</tt> pointer is incremented.  To
relocate an object (for example, the object indicated by the <tt>car</tt>
pointer of the pair we are scanning) we check to see if the object has
already been moved (as indicated by the presence of a broken-heart tag
in the <tt>car</tt> position of the object).  If the object has not
already been moved, we copy it to the place indicated by <tt>free</tt>,
update <tt>free</tt>, set up a broken heart at the object's old location,
and update the pointer to the object (in this
example, the <tt>car</tt> pointer of the pair we are scanning) to point
to the new location.  If the object has already been moved, its
forwarding address (found in the <tt>cdr</tt> position of the broken
heart) is substituted for the pointer in the pair being scanned.
Eventually, all accessible objects will have been moved and scanned,
at which point the <tt>scan</tt> pointer will overtake the <tt>free</tt>
pointer and the process will terminate.</p>

<p class="trans" lang="ja">
<ruby><rb>æ ¹</rb><rp> (</rp><rt>ãƒ«ãƒ¼ãƒˆ</rt><rp>) </rp></ruby> ã‚’å†é…ç½®ã—ãŸå¾Œã€ã‚¬ãƒ¼ãƒ™ã‚¸ãƒ»ã‚³ãƒ¬ã‚¯ã‚¿ã¯ã€åŸºæœ¬çš„ã‚µã‚¤ã‚¯ãƒ«ã«å…¥ã‚‹ã€‚
æœ¬ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®å„ã‚¹ãƒ†ãƒƒãƒ—ã«ãŠã„ã¦ã€<tt>scan</tt> ãƒã‚¤ãƒ³ã‚¿ (æœ€åˆã¯ã€å†é…ç½®ã•ã‚ŒãŸãƒ«ãƒ¼ãƒˆã‚’æŒ‡ã—ã¦ã„ã‚‹) ã¯ã€æ–°ãŸãªãƒ¡ãƒ¢ãƒªã«ç§»å‹•æ¸ˆã¿ã ã‘ã‚Œã©ã‚‚è‡ªåˆ†ã® <tt>car</tt> ãƒã‚¤ãƒ³ã‚¿ã¨ <tt>cdr</tt> ãƒã‚¤ãƒ³ã‚¿ã¯ã¾ã ã‹ã¤ã¦ã®ãƒ¡ãƒ¢ãƒªå†…ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‚ç…§ã—ã¦ã„ã‚‹ã€ã¨ã„ã†å¯¾ã‚’ã€æŒ‡ã—ã¦ã„ã‚‹ã€‚
ã“ã‚Œã‚‰ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ãã‚Œãã‚Œå†é…ç½®ã—ã€<tt>scan</tt> ãƒã‚¤ãƒ³ã‚¿ã‚’ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã™ã‚‹ã€‚
ã‚ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (ãŸã¨ãˆã°ã€ã„ã¾èµ°æŸ»ã—ã¦ã„ã‚‹æœ€ä¸­ã®å¯¾ã® <tt>car</tt> ãƒã‚¤ãƒ³ã‚¿ã«ã‚ˆã‚Šç¤ºã•ã‚Œã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ) ã‚’å†é…ç½®ã™ã‚‹ã«ã¯ã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒæ—¢ã«ç§»å‹•ã•ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹ (ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® <tt>car</tt> ä½ç½®ã®ãƒ–ãƒ­ãƒ¼ã‚¯ãƒ³ãƒ»ãƒãƒ¼ãƒˆãƒ»ã‚¿ã‚°ã®å­˜åœ¨ã«ã‚ˆã£ã¦ç¤ºã•ã‚Œã‚‹) ã‚’èª¿ã¹ã‚‹ã€‚
ã‚‚ã—ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç§»å‹•æ¸ˆã¿ã§ãªã‘ã‚Œã°ã€<tt>free</tt> ã«ã‚ˆã‚Šç¤ºã•ã‚Œã‚‹å ´æ‰€ã«ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¤‡è£½ã—ã€<tt>free</tt> ã‚’æ›´æ–°ã—ã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‹ã¤ã¦ã®å ´æ‰€ã«ãƒ–ãƒ­ãƒ¼ã‚¯ãƒ³ãƒ»ãƒãƒ¼ãƒˆã‚’è¨­å®šã—ã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ (ã“ã®ä¾‹ã§ã¯ã€ã„ã¾èµ°æŸ»ã—ã¦ã„ã‚‹æœ€ä¸­ã®å¯¾ã® <tt>car</tt> ãƒã‚¤ãƒ³ã‚¿) ã‚’ã€æ–°ãŸãªä½ç½®ã‚’æŒ‡ã™ã‚ˆã†ã«æ›´æ–°ã™ã‚‹ã€‚
ã‚‚ã—ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç§»å‹•æ¸ˆã¿ãªã‚‰ã€ã„ã¾èµ°æŸ»ã—ã¦ã„ã‚‹æœ€ä¸­ã®å¯¾ã®ãƒã‚¤ãƒ³ã‚¿ã‚’ã€ãã®è»¢é€å…ˆã‚¢ãƒ‰ãƒ¬ã‚¹ (ãƒ–ãƒ­ãƒ¼ã‚¯ãƒ³ãƒ»ãƒãƒ¼ãƒˆã® <tt>cdr</tt> ä½ç½®ã§è¦‹ã¤ã‹ã‚‹) ã«ç½®ãæ›ãˆã‚‹ã€‚
æœ€å¾Œã«ã¯ã€ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ãªã™ã¹ã¦ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç§»å‹•æ¸ˆã¿ã‹ã¤èµ°æŸ»æ¸ˆã¿ã¨ãªã‚‹ã“ã¨ã ã‚ã†ã€‚ãã—ã¦ã€ãã®æ™‚ç‚¹ã§ã€<tt>scan</tt> ãƒã‚¤ãƒ³ã‚¿ãŒ <tt>free</tt> ãƒã‚¤ãƒ³ã‚¿ã‚’è¿½ã„è¶Šã—ã¦ã„ã‚‹ã ã‚ã†ã—ã€ãƒ—ãƒ­ã‚»ã‚¹ãŒçµ‚äº†ã™ã‚‹ã ã‚ã†ã€‚
</p>

<p class="orig" lang="en">
We can specify the stop-and-copy algorithm as a sequence of
instructions for a register
machine.  The basic step of relocating an object is accomplished by a
subroutine called <tt>relocate-old-result-in-new</tt>.  This
subroutine gets its argument, a pointer to the object to be relocated,
from a register named <a name="%_idx_5990"></a><tt>old</tt>.  It relocates the designated object
(incrementing <tt>free</tt> in the process),
puts a pointer to the relocated object into a register called <a name="%_idx_5992"></a><tt>new</tt>, and returns by branching to the entry point stored in the register
<tt>relocate-continue</tt>.  To begin garbage collection, we invoke this
subroutine to relocate the <tt>root</tt> pointer, after initializing <tt>free</tt> and <tt>scan</tt>.  When the relocation of <tt>root</tt> has been
accomplished, we install the new pointer as the new <tt>root</tt> and
enter the main loop of the garbage collector.</p>

<p class="trans" lang="ja">
ã‚¹ãƒˆãƒƒãƒ—ãƒ»ã‚¢ãƒ³ãƒ‰ãƒ»ã‚³ãƒ”ãƒ¼ãƒ»ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’ã€ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ»ãƒã‚·ãƒ³ç”¨ã®å‘½ä»¤åˆ—ã¨ã—ã¦ã€è¦å®šã§ãã‚‹ã€‚
ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å†é…ç½®ã™ã‚‹åŸºæœ¬çš„ã‚¹ãƒ†ãƒƒãƒ—ã¯ã€<tt>relocate-old-result-in-new</tt> ã¨å‘¼ã°ã‚Œã‚‹ã‚µãƒ–ãƒ«ãƒ¼ãƒãƒ³ã«ã‚ˆã‚Šé”æˆã•ã‚Œã‚‹ã€‚
ã“ã®ã‚µãƒ–ãƒ«ãƒ¼ãƒãƒ³ã¯ã€å¼•æ•°â€”â€”ã™ãªã‚ã¡ã€å†é…ç½®ã™ã¹ãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿â€”â€”ã‚’ã€<tt>old</tt> ã¨ã„ã†åå‰ã®ãƒ¬ã‚¸ã‚¹ã‚¿ã‹ã‚‰å¾—ã‚‹ã€‚
ã“ã®ã‚µãƒ–ãƒ«ãƒ¼ãƒãƒ³ã¯ã€æŒ‡å®šã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å†é…ç½®ã— (ãã®éç¨‹ã§ <tt>free</tt> ã‚’ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã™ã‚‹)ã€å†é…ç½®ã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã‚’ <tt>new</tt> ã¨ã„ã†åå‰ã®ãƒ¬ã‚¸ã‚¹ã‚¿ã«å…¥ã‚Œã€<tt>relocate-continue</tt> ã¨ã„ã†ãƒ¬ã‚¸ã‚¹ã‚¿ã«è¨˜æ†¶ã•ã‚Œã¦ã„ã‚‹ã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒã‚¤ãƒ³ãƒˆã¸ã¨åˆ†å²ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦æˆ»ã‚‹ã€‚
ã‚¬ãƒ¼ãƒ™ã‚¸ãƒ»ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’å§‹ã‚ã‚‹ã«ã¯ã€<tt>free</tt> ã¨ <tt>scan</tt> ã‚’åˆæœŸåŒ–ã—æ‰‹ã‹ã‚‰ã€ã“ã®ã‚µãƒ–ãƒ«ãƒ¼ãƒãƒ³ã‚’å‘¼ã³å‡ºã—ã¦ <tt>root</tt> ãƒã‚¤ãƒ³ã‚¿ã‚’å†é…ç½®ã™ã‚‹ã€‚
<tt>root</tt> ã®å†é…ç½®ã‚’æˆã—é‚ã’ãŸã‚‰ã€æ–°ãŸãªãƒã‚¤ãƒ³ã‚¿ã‚’æ–°ãŸãª <tt>root</tt> ã¨ã—ã¦çµ„ã¿è¾¼ã¿ã€ã‚¬ãƒ¼ãƒ™ã‚¸ãƒ»ã‚³ãƒ¬ã‚¯ã‚¿ã®ãƒ¡ã‚¤ãƒ³ãƒ»ãƒ«ãƒ¼ãƒ—ã«å…¥ã‚‹ã€‚
</p>

<p class="lisp">begin-garbage-collection
  (assign free (const 0))
  (assign scan (const 0))
  (assign old (reg root))
  (assign relocate-continue (label reassign-root))
  (goto (label relocate-old-result-in-new))
reassign-root
  (assign root (reg new))
  (goto (label gc-loop))
</p>

<p class="orig" lang="en">
In the main loop of the garbage collector we must determine whether
there are any more objects to be scanned.  We do this by testing
whether the <tt>scan</tt> pointer is coincident with the <tt>free</tt>
pointer.  If the pointers are equal, then all accessible objects have
been relocated, and we branch to <tt>gc-flip</tt>, which cleans things up
so that we can continue the interrupted computation.  If there are
still pairs to be scanned, we call the relocate subroutine to relocate
the <tt>car</tt> of the next pair (by placing the <tt>car</tt> pointer in <tt>old</tt>).  The <tt>relocate-continue</tt> register is set up so that the
subroutine will return to update the <tt>car</tt> pointer.</p>

<p class="trans" lang="ja">
ã‚¬ãƒ¼ãƒ™ã‚¸ãƒ»ã‚³ãƒ¬ã‚¯ã‚¿ã®ãƒ¡ã‚¤ãƒ³ãƒ»ãƒ«ãƒ¼ãƒ—ã§ã¯ã€èµ°æŸ»ã™ã¹ãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã•ã‚‰ã«ã‚ã‚‹ã‹ã©ã†ã‹ã‚’åˆ¤å®šã›ã­ã°ãªã‚‰ãªã„ã€‚
ç§ãŸã¡ã¯ã“ã‚Œã‚’ã€<tt>scan</tt> ãƒã‚¤ãƒ³ã‚¿ãŒ <tt>free</tt> ãƒã‚¤ãƒ³ã‚¿ã¨ä¸€è‡´ã™ã‚‹ã‹ã©ã†ã‹ã‚’èª¿ã¹ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€è¡Œã†ã€‚
ã‚‚ã—ãƒã‚¤ãƒ³ã‚¿åŒå£«ãŒç­‰ã—ã‘ã‚Œã°ã€ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ãªã™ã¹ã¦ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å†é…ç½®æ¸ˆã¿ã§ã‚ã‚Šã€<tt>gc-flip</tt> â€”â€”å‰²ã‚Šè¾¼ã¾ã‚ŒãŸè¨ˆç®—ã‚’ç¶šè¡Œã§ãã‚‹ã‚ˆã†ã«ã€ã‚‚ã®ã‚’ç‰‡ä»˜ã‘ã‚‹â€”â€”ã¸ã¨åˆ†å²ã™ã‚‹ã€‚
ã‚‚ã—èµ°æŸ»ã™ã¹ãå¯¾ãŒã¾ã ã‚ã‚Œã°ã€å†é…ç½®ã‚µãƒ–ãƒ«ãƒ¼ãƒãƒ³ã‚’å‘¼ã³å‡ºã—ã¦ã€æ¬¡ã®å¯¾ã® <tt>car</tt> ã‚’å†é…ç½®ã™ã‚‹ (<tt>car</tt> ãƒã‚¤ãƒ³ã‚¿ã‚’ <tt>old</tt> ã«ç½®ãã“ã¨ã«ã‚ˆã£ã¦)ã€‚
<tt>relocate-continue</tt> ãƒ¬ã‚¸ã‚¹ã‚¿ã¯ã€ã‚µãƒ–ãƒ«ãƒ¼ãƒãƒ³ãŒæˆ»ã£ã¦ <tt>car</tt> ãƒã‚¤ãƒ³ã‚¿ã‚’æ›´æ–°ã™ã‚‹ã‚ˆã†ã«ã€è¨­å®šã•ã‚Œã‚‹ã€‚
</p>

<p class="lisp">gc-loop
  (test (op =) (reg scan) (reg free))
  (branch (label gc-flip))
  (assign old (op vector-ref) (reg new-cars) (reg scan))
  (assign relocate-continue (label update-car))
  (goto (label relocate-old-result-in-new))
</p>

<p class="orig" lang="en">
At <tt>update-car</tt>, we modify the <tt>car</tt> pointer of the pair being
scanned, then proceed to relocate the <tt>cdr</tt> of the pair.  We
return to <tt>update-cdr</tt> when that relocation has been accomplished.
After relocating and updating the <tt>cdr</tt>, we are finished scanning
that pair, so we continue with the main loop.</p>

<p class="trans" lang="ja">
<tt>update-car</tt> ã§ã¯ã€èµ°æŸ»ä¸­ã®å¯¾ã® <tt>car</tt> ãƒã‚¤ãƒ³ã‚¿ã‚’æ”¹å¤‰ã—ã€ãã‚Œã‹ã‚‰ã€ãã®å¯¾ã® <tt>cdr</tt> ã®å†é…ç½®ã‚’å§‹ã‚ã‚‹ã€‚
ãã®å†é…ç½®ã‚’æˆã—é‚ã’ãŸã‚‰ã€<tt>update-cdr</tt> ã¸ã¨æˆ»ã‚‹ã€‚
<tt>cdr</tt> ã‚’å†é…ç½®ã—ã¦æ›´æ–°ã—çµ‚ã‚ã£ãŸã‚‰ã€ãã®å¯¾ã‚’èµ°æŸ»ã™ã‚‹ã®ã‚’çµ‚ãˆã¦ã„ã‚‹ã‚ã‘ã§ã€ã™ã‚‹ã¨ã€ãƒ¡ã‚¤ãƒ³ãƒ»ãƒ«ãƒ¼ãƒ—ã‚’ç¶šè¡Œã™ã‚‹ã€‚
</p>

<p class="lisp">update-car
  (perform
   (op vector-set!) (reg new-cars) (reg scan) (reg new))
  (assign old (op vector-ref) (reg new-cdrs) (reg scan))
  (assign relocate-continue (label update-cdr))
  (goto (label relocate-old-result-in-new))

update-cdr
  (perform
   (op vector-set!) (reg new-cdrs) (reg scan) (reg new))
  (assign scan (op +) (reg scan) (const 1))
  (goto (label gc-loop))
</p>

<p class="orig" lang="en">
The subroutine <tt>relocate-old-result-in-new</tt> relocates objects as
follows: If the object to be relocated (pointed at by <tt>old</tt>) is
not a pair, then we return the same pointer to the object unchanged
(in <tt>new</tt>).  (For example, we may be scanning a pair whose <tt>car</tt> is the number 4.  If we represent the <tt>car</tt> by <tt>n4</tt>, as
described in section <a href="#%_sec_5.3.1">5.3.1</a>, then we want the
``relocated'' <tt>car</tt> pointer to still be <tt>n4</tt>.)  Otherwise, we
must perform the relocation.  If the <tt>car</tt> position of the pair to
be relocated contains a broken-heart tag, then the pair has in fact
already been moved, so we retrieve the forwarding address (from the
<tt>cdr</tt> position of the broken heart) and return this in <tt>new</tt>.
If the pointer in <tt>old</tt> points at a yet-unmoved pair, then we move
the pair to the first free cell in new memory (pointed at by <tt>free</tt>) and set up the broken heart by storing a broken-heart tag and
forwarding address at the old location.
<tt>Relocate-old-result-in-new</tt> uses a register <a name="%_idx_5994"></a><tt>oldcr</tt>
to hold the <tt>car</tt> or the <tt>cdr</tt> of the object pointed at by
<tt>old</tt>.<a name="call_footnote_Temp_764" href="#footnote_Temp_764"><sup><small>18</small></sup></a></p>

<p class="trans" lang="ja">
<tt>relocate-old-result-in-new</tt> ã¨ã„ã†ã‚µãƒ–ãƒ«ãƒ¼ãƒãƒ³ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å†é…ç½®ã™ã‚‹ã€‚
ã‚‚ã—å†é…ç½®ã™ã¹ãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (<tt>old</tt> ã«ã‚ˆã‚ŠæŒ‡ã•ã‚Œã¦ã„ã‚‹) ãŒå¯¾ã§ãªã‘ã‚Œã°ã€ãã®ã¾ã¾ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®åŒã˜ãƒã‚¤ãƒ³ã‚¿ã‚’ (<tt>new</tt> ã®ä¸­ã«) è¿”ã™
(ãŸã¨ãˆã°ã€<tt>car</tt> ãŒ 4 ã¨ã„ã†æ•°ã§ã‚ã‚‹ã‚ˆã†ãªå¯¾ã‚’ã€èµ°æŸ»ã—ã¦ã„ã‚‹ã¨ã“ã‚ãªã®ã‹ã‚‚ã—ã‚Œãªã„ã€‚<a href="#%_sec_5.3.1">5.3.1</a>ç¯€ã§èª¬æ˜ã—ãŸã‚ˆã†ã«ã€ãã® <tt>car</tt> ã‚’ <tt>n4</tt> ã«ã‚ˆã‚Šè¡¨ã—ã¦ã„ã‚‹ãªã‚‰ã°ã€ã€Œå†é…ç½®æ¸ˆã¿ã®ã€<tt>car</tt> ãƒã‚¤ãƒ³ã‚¿ã«ã¯ã€ä¾ç„¶ã¨ã—ã¦ <tt>n4</tt> ã§ã‚ã£ã¦ã»ã—ã„ã‚ã‘ã )ã€‚
ãã‚Œä»¥å¤–ã®å ´åˆã€å†é…ç½®ã‚’å®Ÿè¡Œã—ãªãã¦ã¯ãªã‚‰ãªã„ã€‚
ã‚‚ã—ã€å†é…ç½®ã™ã¹ãå¯¾ã® <tt>car</tt> ä½ç½®ãŒãƒ–ãƒ­ãƒ¼ã‚¯ãƒ³ãƒ»ãƒãƒ¼ãƒˆãƒ»ã‚¿ã‚°ã‚’å«ã‚“ã§ã„ã‚Œã°ã€ãã®å¯¾ã¯å®Ÿéš›ã¯ç§»å‹•æ¸ˆã¿ã§ã‚ã‚Šã€ã—ãŸãŒã£ã¦ã€è»¢é€å…ˆã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ (ãƒ–ãƒ­ãƒ¼ã‚¯ãƒ³ãƒ»ãƒãƒ¼ãƒˆã® <tt>cdr</tt> ä½ç½®ã‹ã‚‰) å–ã‚Šå‡ºã—ã¦ã€ã“ã‚Œã‚’ <tt>new</tt> ã®ä¸­ã«è¿”ã™ã€‚
ã‚‚ã—ã€<tt>old</tt> ã«ã‚ã‚‹ãƒã‚¤ãƒ³ã‚¿ãŒã€ã¾ã ç§»å‹•ã•ã‚Œã¦ã„ãªã„å¯¾ã‚’æŒ‡ã—ã¦ã„ãŸã‚‰ã€æ–°ãŸãªãƒ¡ãƒ¢ãƒªã«ãŠã‘ã‚‹æœ€åˆã®ç©ºãã‚»ãƒ« (<tt>free</tt> ã«ã‚ˆã‚ŠæŒ‡ã•ã‚Œã¦ã„ã‚‹) ã¸ã¨ãã®å¯¾ã‚’ç§»å‹•ã•ã›ã€ãƒ–ãƒ­ãƒ¼ã‚¯ãƒ³ãƒ»ãƒãƒ¼ãƒˆãƒ»ã‚¿ã‚°ã¨è»¢é€å…ˆã‚¢ãƒ‰ãƒ¬ã‚¹ã¨ã‚’å¤ã„å ´æ‰€ã«æ ¼ç´ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ãƒ–ãƒ­ãƒ¼ã‚¯ãƒ³ãƒ»ãƒãƒ¼ãƒˆã‚’è¨­å®šã™ã‚‹ã€‚
<tt>relocate-old-result-in-new</tt> ã¯ã€<tt>old</tt> ã«ã‚ˆã‚ŠæŒ‡ã•ã‚Œã¦ã„ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® <tt>car</tt> ã¾ãŸã¯ <tt>cdr</tt> ã‚’ä¿æŒã™ã‚‹ãŸã‚ã«ã€<tt>oldcr</tt> ã¨ã„ã†ãƒ¬ã‚¸ã‚¹ã‚¿ã‚’ä½¿ã†<a href="#footnote_Temp_764"><sup><small>18</small></sup></a>ã€‚
</p>

<p class="lisp">relocate-old-result-in-new
  (test (op pointer-to-pair?) (reg old))
  (branch (label pair))
  (assign new (reg old))
  (goto (reg relocate-continue))
pair
  (assign oldcr (op vector-ref) (reg the-cars) (reg old))
  (test (op broken-heart?) (reg oldcr))
  (branch (label already-moved))
  (assign new (reg free)) <em>; new location for pair</em>
  <em>;; Update <tt>free</tt> pointer.</em>
  (assign free (op +) (reg free) (const 1))
  <em>;; Copy the <tt>car</tt> and <tt>cdr</tt> to new memory.</em>
  (perform (op vector-set!)
           (reg new-cars) (reg new) (reg oldcr))
  (assign oldcr (op vector-ref) (reg the-cdrs) (reg old))
  (perform (op vector-set!)
           (reg new-cdrs) (reg new) (reg oldcr))
  <em>;; Construct the broken heart.</em>
  (perform (op vector-set!)
           (reg the-cars) (reg old) (const broken-heart))
  (perform
   (op vector-set!) (reg the-cdrs) (reg old) (reg new))
  (goto (reg relocate-continue))
already-moved
  (assign new (op vector-ref) (reg the-cdrs) (reg old))
  (goto (reg relocate-continue))
</p>

<p class="orig" lang="en">
At the very end of the garbage-collection process, we interchange the
role of old and new memories by interchanging pointers: interchanging
<tt>the-cars</tt> with <tt>new-cars</tt>, and <tt>the-cdrs</tt> with <tt>new-cdrs</tt>.  We will then be ready to perform another garbage
collection the next time memory runs out.</p>

<p class="trans" lang="ja">
ã‚¬ãƒ¼ãƒ™ã‚¸ãƒ»ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ãƒ»ãƒ—ãƒ­ã‚»ã‚¹ã®æœ¬å½“ã®æœ€å¾Œã«ãŠã„ã¦ã€ãƒã‚¤ãƒ³ã‚¿åŒå£«ã‚’å…¥ã‚Œæ›¿ãˆã‚‹ã“ã¨ã«ã‚ˆã‚Šã€æ—§ãƒ¡ãƒ¢ãƒªã¨æ–°ãƒ¡ãƒ¢ãƒªã®å½¹å‰²ã‚’å…¥ã‚Œæ›¿ãˆã‚‹ã€‚ã¤ã¾ã‚Šã€<tt>the-cars</tt> ã¨ <tt>new-cars</tt> ã‚’å…¥ã‚Œæ›¿ãˆã€<tt>the-cdrs</tt> ã¨ <tt>new-cdrs</tt> ã‚’å…¥ã‚Œæ›¿ãˆã‚‹ã®ã ã€‚
ã™ã‚‹ã¨ã€æ¬¡ã«ãƒ¡ãƒ¢ãƒªãŒå°½ããŸã¨ãã«åˆ¥ã®ã‚¬ãƒ¼ãƒ™ã‚¸ãƒ»ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œã™ã‚‹æº–å‚™ãŒã€æ•´ã†ã§ã‚ã‚ã†ã€‚
</p>

<p class="lisp">gc-flip
  (assign temp (reg the-cdrs))
  (assign the-cdrs (reg new-cdrs))
  (assign new-cdrs (reg temp))
  (assign temp (reg the-cars))
  (assign the-cars (reg new-cars))
  (assign new-cars (reg temp))
</p>

<a name="footnotes"></a>
<hr>
<p class="orig" lang="en"><a name="footnote_Temp_744" href="#call_footnote_Temp_744"><sup><small>5</small></sup></a> We could represent memory as lists of items.
However, the access time would then not be independent of the index,
since accessing the <em>n</em>th element of a list requires <em>n</em> - 1 <tt>cdr</tt>
operations.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_744"><sup><small>5</small></sup></a>
é …ç›®ã®ãƒªã‚¹ãƒˆã¨ã—ã¦ãƒ¡ãƒ¢ãƒªã‚’è¡¨ç¾ã™ã‚‹ã“ã¨ã‚‚ã€å¯èƒ½ã§ã‚ã£ãŸã ã‚ã†ã€‚
ã—ã‹ã—ã€ãã†ã™ã‚‹ã¨ã€ã‚¢ã‚¯ã‚»ã‚¹æ™‚é–“ãŒã€æ·»ãˆå­—ã¨ã¯ç‹¬ç«‹ã«ã¯ãªã‚‰ãªã„ã ã‚ã†ã€‚ãªãœãªã‚‰ã€ãƒªã‚¹ãƒˆã® <em class="en">n</em> ç•ªç›®ã®è¦ç´ ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã“ã¨ã¯ã€
<span class="math"><em class="en">n</em> &minus; 1</span>
å›ã® <tt>cdr</tt> æ“ä½œã‚’å¿…è¦ã¨ã™ã‚‹ãŸã‚ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_745" href="#call_footnote_Temp_745"><sup><small>6</small></sup></a> For completeness, we should specify a <tt>make-vector</tt>
operation that constructs vectors.  However, in the present
application we will use vectors only to model fixed divisions of the
computer memory.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_745"><sup><small>6</small></sup></a> 
å®Œå…¨æ€§ã®ãŸã‚ã«ã¯ã€ç§ãŸã¡ã¯ã€ãƒ™ã‚¯ã‚¿ã‚’æ§‹ç¯‰ã™ã‚‹ <tt>make-vector</tt> æ“ä½œã‚’è¦å®šã™ã¹ãã§ã‚ã‚‹ã€‚
ã—ã‹ã—ã€ç›®ä¸‹ã®å¿œç”¨ã«ãŠã„ã¦ã¯ã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ»ãƒ¡ãƒ¢ãƒªã®å›ºå®šçš„ãªåˆ†å‰²ã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã™ã‚‹ã“ã¨ã®ãŸã‚ã ã‘ã«ã€ãƒ™ã‚¯ã‚¿ã‚’ä½¿ãŠã†ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_747" href="#call_footnote_Temp_747"><sup><small>7</small></sup></a> This is
precisely the same <a name="%_idx_5864"></a><a name="%_idx_5866"></a>``tagged data'' idea we introduced in chapter 2 for
dealing with generic operations.  Here, however, the data types are
included at the primitive machine level rather than constructed
through the use of lists.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_747"><sup><small>7</small></sup></a> 
ã“ã‚Œã¯ã€ç·ç§°çš„æ¼”ç®—ã‚’æ‰±ã†ãŸã‚ã«2ç« ã§å°å…¥ã—ãŸã€Œã‚¿ã‚°ä»˜ã‘ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã€ã®è€ƒãˆæ–¹ã¨ã€ã¾ã•ã«åŒã˜ã§ã‚ã‚‹ã€‚
ã—ã‹ã—ã€ã“ã“ã§ã¯ã€ãƒ‡ãƒ¼ã‚¿å‹ã¯ã€ãƒªã‚¹ãƒˆã®ä½¿ç”¨ã‚’é€šã˜ã¦æ§‹ç¯‰ã•ã‚Œã‚‹ã®ã§ã¯ãªãã€ã‚€ã—ã‚ã€åŸå§‹çš„ãªãƒã‚·ãƒ³ãƒ»ãƒ¬ãƒ™ãƒ«ã«å«ã¾ã‚Œã¦ã„ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_748" href="#call_footnote_Temp_748"><sup><small>8</small></sup></a> Type information may be encoded in a variety of
ways, depending on the details of the machine on which the Lisp
system is to be implemented.  The execution efficiency of Lisp
programs will be strongly dependent on how cleverly this choice is
made, but it is difficult to formulate general design rules for good
choices.  The most straightforward way to implement typed pointers is
to allocate a fixed set of bits in each pointer to be a <a name="%_idx_5870"></a><em>type
field</em> that encodes the data type.  Important questions to be
addressed in designing such a representation include the following:
How many type bits are required?  How large must the vector indices
be?  How efficiently can the primitive machine instructions be used to
manipulate the type fields of pointers?  Machines that include special
hardware for the efficient handling of type fields are said to have
<a name="%_idx_5872"></a><em>tagged architectures</em>.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_748"><sup><small>8</small></sup></a>
å‹æƒ…å ±ã¯ã€ãã®ä¸Šã« Lisp ã‚·ã‚¹ãƒ†ãƒ ã‚’å®Ÿè£…ã™ã‚‹ã¹ããƒã‚·ãƒ³ã®è©³ç´°ã«å¿œã˜ã¦ã€å¤šæ§˜ãªæ–¹æ³•ã§ç¬¦å·åŒ–ã•ã‚Œå¾—ã‚‹ã€‚
Lisp ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®å®Ÿè¡ŒåŠ¹ç‡ã¯ã€ã“ã®é¸æŠãŒã©ã‚Œã»ã©è³¢ããªã•ã‚ŒãŸã‹ã€ã¨ã„ã†ã“ã¨ã«å¼·ãä¾å­˜ã™ã‚‹ã ã‚ã†ãŒã€è‰¯ã„é¸æŠã®ãŸã‚ã®ä¸€èˆ¬çš„ãªè¨­è¨ˆè¦å‰‡ã‚’å®šå¼åŒ–ã™ã‚‹ã®ã¯å›°é›£ã ã€‚
å‹ã¤ããƒã‚¤ãƒ³ã‚¿ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã®æœ€ã‚‚åˆ†ã‹ã‚Šã‚„ã™ã„æ–¹æ³•ã¯ã€å„ãƒã‚¤ãƒ³ã‚¿ã®ä¸­ã®æ‰€å®šã®ãƒ“ãƒƒãƒˆä¸€æƒã„ã‚’ã€ãƒ‡ãƒ¼ã‚¿å‹ã‚’ç¬¦å·åŒ–ã™ã‚‹<em>å‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰</em>ã¨ãªã‚‹ã‚ˆã†ã€å‰²ã‚Šå½“ã¦ã‚‹ã“ã¨ã§ã‚ã‚‹ã€‚
ãã†ã—ãŸè¡¨ç¾ã‚’è¨­è¨ˆã™ã‚‹ã†ãˆã§å¯¾å‡¦ã™ã¹ãé‡è¦ãªç–‘å•ç‚¹ã«ã¯ã€æ¬¡ã®ã‚ˆã†ãªã‚‚ã®ãŒã‚ã‚‹ã€‚
å‹ãƒ“ãƒƒãƒˆã¯ã©ã‚Œãã‚‰ã„å¤šãå¿…è¦ã‹?
ãƒ™ã‚¯ãƒˆãƒ«ã®æ·»ãˆå­—ã¯ã€ã©ã‚Œã»ã©å¤§ãããªãã¦ã¯ãªã‚‰ãªã„ã‹?
åŸå§‹çš„ãƒã‚·ãƒ³å‘½ä»¤ã‚’ä½¿ã£ã¦ã€ã©ã‚Œã»ã©åŠ¹ç‡çš„ã«ãƒã‚¤ãƒ³ã‚¿ã®å‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æ“ä½œã§ãã‚‹ã‹?
å‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®åŠ¹ç‡çš„ãªå–ã‚Šæ‰±ã„ã®ãŸã‚ã®ç‰¹åˆ¥ãªãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ã‚’å«ã‚€ãƒã‚·ãƒ³ã¯ã€<em>ã‚¿ã‚°ã¤ãã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£</em>ã‚’æœ‰ã™ã‚‹ã€ã¨è¨€ã‚ã‚Œã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_749" href="#call_footnote_Temp_749"><sup><small>9</small></sup></a> This decision on the
<a name="%_idx_5874"></a><a name="%_idx_5876"></a><a name="%_idx_5878"></a>representation of numbers determines whether <tt>eq?</tt>, which tests
equality of pointers, can be used to test for equality of numbers.  If
the pointer contains the number itself, then equal numbers will have
the same pointer.  But if the pointer contains the index of a location
where the number is stored, equal numbers will be guaranteed to have
equal pointers only if we are careful never to store the same number
in more than one location.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_749"><sup><small>9</small></sup></a> 
æ•°ã®è¡¨ç¾ã«é–¢ã™ã‚‹æ±ºå®šã¯ã€æ•°åŒå£«ã®ç­‰ä¾¡æ€§ã‚’æ¤œæŸ»ã™ã‚‹ã®ã« <tt>eq?</tt> â€”â€”ãƒã‚¤ãƒ³ã‚¿åŒå£«ã®ç­‰ä¾¡æ€§ã‚’æ¤œæŸ»ã™ã‚‹â€”â€”ãŒä½¿ãˆã‚‹ã‹ã©ã†ã‹ã‚’å·¦å³ã™ã‚‹ã€‚
ã‚‚ã—ãƒã‚¤ãƒ³ã‚¿ãŒæ•°ãã®ã‚‚ã®ã‚’å«ã‚“ã§ã„ã‚Œã°ã€ç­‰ã—ã„æ•°åŒå£«ã¯ã€åŒã˜ãƒã‚¤ãƒ³ã‚¿ã‚’æœ‰ã™ã‚‹ã ã‚ã†ã€‚
ã—ã‹ã—ã€ã‚‚ã—ãƒã‚¤ãƒ³ã‚¿ãŒã€æ•°ãŒæ ¼ç´ã•ã‚Œã¦ã„ã‚‹å ´æ‰€ã®æ·»ãˆå­—ã‚’å«ã‚“ã§ã„ã‚Œã°ã€ä¸€ç®‡æ‰€ã‚ˆã‚Šã‚‚å¤šãã®å ´æ‰€ã«ã¯åŒã˜æ•°ã‚’æ±ºã—ã¦æ ¼ç´ã—ãªã„ã‚ˆã†ã«æ°—ã‚’ã¤ã‘ã‚‹å ´åˆã«ã—ã‹ã€ç­‰ã—ã„æ•°åŒå£«ãŒç­‰ã—ã„ãƒã‚¤ãƒ³ã‚¿ã‚’æœ‰ã™ã‚‹ã¨ã¯ä¿è¨¼ã•ã‚Œãªã„ã ã‚ã†ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_750" href="#call_footnote_Temp_750"><sup><small>10</small></sup></a> This is just like writing a number as a sequence of
digits, except that each ``digit'' is a number between 0 and the
largest number that can be stored in a single pointer.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_750"><sup><small>10</small></sup></a>
ã“ã‚Œã¯ã€æ¡ã®ä¸¦ã³ã¨ã—ã¦æ•°ã‚’æ›¸ãã“ã¨ã¨ã¡ã‚‡ã†ã©åŒæ§˜ã§ã‚ã‚‹â€”â€”å„ã€Œæ¡ã€ãŒã€0 ã¨ã€ä¸€ã¤ã®ãƒã‚¤ãƒ³ã‚¿ã«æ ¼ç´ã§ãã‚‹æœ€å¤§ã®æ•°ã¨ã®é–“ã®æ•°ã§ã‚ã‚‹ã€ã¨ã„ã†ç‚¹ã‚’é™¤ã„ã¦ã¯ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_752" href="#call_footnote_Temp_752"><sup><small>11</small></sup></a> There are other ways
of finding free storage.  For example, we could link together all the
unused pairs into a <a name="%_idx_5908"></a><em>free list</em>.  Our free locations are
consecutive (and hence can be accessed by incrementing a pointer)
because we are using a compacting garbage collector, as we will see in
section <a href="#%_sec_5.3.2">5.3.2</a>.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_752"><sup><small>11</small></sup></a>
ç©ºã„ã¦ã„ã‚‹è¨˜æ†¶è£…ç½®ã‚’è¦‹ã¤ã‘ã‚‹ã€åˆ¥ã®æ–¹æ³•ã‚‚ã‚ã‚‹ã€‚
ãŸã¨ãˆã°ã€ä½¿ã‚ã‚Œã¦ã„ãªã„å¯¾ã™ã¹ã¦ã‚’ä¸€ç·’ã«ã¤ãªã’ã¦ã€<em>ç©ºããƒªã‚¹ãƒˆ</em>ã¨ã™ã‚‹ã“ã¨ã‚‚ã§ãã‚‹ã ã‚ã†ã€‚
ç§ãŸã¡ã®ç©ºãå ´æ‰€ã¯é€£ç¶šã—ã¦ã„ã‚‹ (ã—ãŸãŒã£ã¦ã€ãƒã‚¤ãƒ³ã‚¿ã‚’ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã™ã‚‹ã“ã¨ã§ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹) ã®ã ãŒã€ã“ã‚Œã¯ã€<a href="#%_sec_5.3.2">5.3.2</a>ç¯€ã§è¦‹ã‚‹ã“ã¨ã«ãªã‚‹ã‚ˆã†ã«ã€<ruby><rb>åœ§ç¸®å‹ã®</rb><rp> (</rp><rt>ã‚³ãƒ³ãƒ‘ã‚¯ãƒ†ã‚£ãƒ³ã‚°</rt><rp>) </rp></ruby>ã‚¬ãƒ¼ãƒ™ã‚¸ãƒ»ã‚³ãƒ¬ã‚¯ã‚¿ã‚’ä½¿ã£ã¦ã„ã‚‹ãŸã‚ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_753" href="#call_footnote_Temp_753"><sup><small>12</small></sup></a> This is essentially the implementation of <tt>cons</tt> in terms of <tt>set-car!</tt> and <tt>set-cdr!</tt>, as described in
section <a href="22_sec3_3.html#%_sec_3.3.1">3.3.1</a>.  The operation <tt>get-new-pair</tt> used in that implementation is realized here by the <tt>free</tt> pointer.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_753"><sup><small>12</small></sup></a>
ã“ã‚Œã¯ã€æœ¬è³ªçš„ã«ã¯ã€<a href="22_sec3_3.html#%_sec_3.3.1">3.3.1</a>ç¯€ã§èª¬æ˜ã—ãŸã‚ˆã†ãªã€<tt>set-car!</tt> ã¨ <tt>set-cdr!</tt> ã‚’ç”¨ã„ãŸ <tt>cons</tt> ã®å®Ÿè£…ã§ã‚ã‚‹ã€‚
ãã®å®Ÿè£…ã«ãŠã„ã¦ç”¨ã„ãŸ <tt>get-new-pair</tt> ã¨ã„ã†æ¼”ç®—ã¯ã€ã“ã“ã§ã¯ã€<tt>free</tt> ãƒã‚¤ãƒ³ã‚¿ã«ã‚ˆã‚Šå®Ÿç¾ã•ã‚Œã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_758" href="#call_footnote_Temp_758"><sup><small>13</small></sup></a> This may not be true eventually,
because memories may get large enough so that it would be impossible
to run out of free memory in the lifetime of the computer.  For
example, there are about 3&times; 10<sup>13</sup>, microseconds in a year, so
if we were to <tt>cons</tt> once per microsecond we would need about
10<sup>15</sup> cells of memory to build a machine that could operate for 30
years without running out of memory.  That much memory seems absurdly
large by today's standards, but it is not physically impossible.  On
the other hand, processors are getting faster and a future computer
may have large numbers of processors operating in parallel on a single
memory, so it may be possible to use up memory much faster than we
have postulated.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_758"><sup><small>13</small></sup></a>
ã‚†ãã‚†ãã¯ã€ã“ã‚Œã¯æœ¬å½“ã§ã¯ãªããªã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚ãªãœãªã‚‰ã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã®å¯¿å‘½ã®é–“ã«ã¯ç©ºããƒ¡ãƒ¢ãƒªã‚’ä½¿ã„æœãŸã™ã®ãŒä¸å¯èƒ½ã¨ãªã‚‹ã‚ˆã†ã«ã€ãƒ¡ãƒ¢ãƒªãŒååˆ†å¤§è¦æ¨¡ã«ãªã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã‹ã‚‰ã€‚
ãŸã¨ãˆã°ã€ä¸€å¹´ã«ã¯ç´„
<span class="math">3 &times; 10<sup>13</sup></span>
ãƒã‚¤ã‚¯ãƒ­ç§’ã‚ã‚Šã€ã‚ˆã£ã¦ã€ã‚‚ã—1ãƒã‚¤ã‚¯ãƒ­ç§’ã”ã¨ã«ä¸€åº¦ <tt>cons</tt> ã™ã‚‹ã¤ã‚‚ã‚Šã ã£ãŸã¨ã™ã‚‹ã¨ã€ãƒ¡ãƒ¢ãƒªã‚’ä½¿ã„æœãŸã•ãšã«30å¹´é–“å‹•ã‘ã‚‹ãƒã‚·ãƒ³ã‚’æ§‹ç¯‰ã™ã‚‹ã«ã¯ã€ãƒ¡ãƒ¢ãƒªã®ã‚»ãƒ«ã‚’ç´„ 10<sup>15</sup> å€‹ã€å¿…è¦ã¨ã™ã‚‹ã“ã¨ã ã‚ã†ã€‚
ãã†ã—ãŸå¤§é‡ã®ãƒ¡ãƒ¢ãƒªã¯ã€ä»Šæ—¥ã®æ¨™æº–ã«ã‚ˆã‚Œã°é¦¬é¹¿ã’ãŸã»ã©å¤§è¦æ¨¡ãªã‚ˆã†ã«è¦‹ãˆã‚‹ãŒã€ç‰©ç†çš„ã«ä¸å¯èƒ½ãªã‚ã‘ã§ã¯ãªã„ã€‚
ä¸€æ–¹ã§ã€ãƒ—ãƒ­ã‚»ãƒƒã‚µã¯é«˜é€ŸåŒ–ã—ã¦ã„ã‚‹ã—ã€å°†æ¥ã®ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã¯ã€ä¸€ã¤ã®ãƒ¡ãƒ¢ãƒªã«å¯¾ã—ã¦ä¸¦åˆ—ã«å‹•ä½œã™ã‚‹å¤šæ•°ã®ãƒ—ãƒ­ã‚»ãƒƒã‚µã‚’æœ‰ã—ã¦ã„ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚ãã†ã™ã‚‹ã¨ã€ç§ãŸã¡ãŒä»®å®šã—ãŸã®ã‚ˆã‚Šã‚‚ãšã£ã¨é€Ÿãã€ãƒ¡ãƒ¢ãƒªã‚’ä½¿ã„æœãŸã™ã“ã¨ã‚‚ã‚ã‚Šå¾—ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_759" href="#call_footnote_Temp_759"><sup><small>14</small></sup></a> We
assume here that the stack is represented as a list as described in
section <a href="#%_sec_5.3.1">5.3.1</a>, so that items on the stack are
accessible via the pointer in the stack register.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_759"><sup><small>14</small></sup></a>
ã“ã“ã§ã¯ã€<a href="#%_sec_5.3.1">5.3.1</a>ç¯€ã§èª¬æ˜ã—ãŸã‚ˆã†ã«ã€ã‚¹ã‚¿ãƒƒã‚¯ãŒãƒªã‚¹ãƒˆã¨ã—ã¦è¡¨ç¾ã•ã‚Œã¦ã„ã‚‹ã‚‚ã®ã¨ä»®å®šã—ã¦ãŠã‚Šã€ãã®çµæœã€ã‚¹ã‚¿ãƒƒã‚¯ä¸Šã®é …ç›®ã¯ã€ã‚¹ã‚¿ãƒƒã‚¯ãƒ»ãƒ¬ã‚¸ã‚¹ã‚¿ã®ãƒã‚¤ãƒ³ã‚¿ã‚’ä»‹ã—ã¦ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ã§ã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_760" href="#call_footnote_Temp_760"><sup><small>15</small></sup></a> This idea was invented and first implemented
<a name="%_idx_5936"></a>by Minsky, as part of the implementation of <a name="%_idx_5938"></a>Lisp for the PDP-1 at the
<a name="%_idx_5940"></a>MIT Research Laboratory of Electronics.  It was further developed by
<a name="%_idx_5942"></a><a name="%_idx_5944"></a>Fenichel and Yochelson (1969) for use in the Lisp implementation for
<a name="%_idx_5946"></a>the Multics time-sharing system.  Later, <a name="%_idx_5948"></a>Baker (1978) developed a
``real-time'' version of the method, which does not require the
computation to stop during garbage collection.  Baker's idea was
extended by <a name="%_idx_5950"></a><a name="%_idx_5952"></a><a name="%_idx_5954"></a>Hewitt, Lieberman, and Moon (see Lieberman and Hewitt
1983) to take advantage of the fact that some structure is more volatile
and other structure is more permanent.  </p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_760"><sup><small>15</small></sup></a>
ã“ã®è€ƒãˆã¯ã€ãƒŸãƒ³ã‚¹ã‚­ãƒ¼ã«ã‚ˆã£ã¦ã€è€ƒæ¡ˆã•ã‚Œã€æœ€åˆã«â€”â€”MIT é›»å­å·¥å­¦èª¿æŸ»ç ”ç©¶æ‰€ã«ãŠã„ã¦ PDP-1 ç”¨ã® Lisp å‡¦ç†ç³»ã®ä¸€éƒ¨ã¨ã—ã¦â€”â€”å®Ÿè£…ã•ã‚ŒãŸã€‚
ã“ã‚Œã¯ã•ã‚‰ã«ã€Multics ã®ã‚¿ã‚¤ãƒ ã‚·ã‚§ã‚¢ãƒªãƒ³ã‚°ãƒ»ã‚·ã‚¹ãƒ†ãƒ ç”¨ã® Lisp å‡¦ç†ç³»ã§ä½¿ã†ãŸã‚ã«ã€Fenichel and Yochelson (1969) ã«ã‚ˆã£ã¦é–‹ç™ºã•ã‚ŒãŸã€‚
å¾Œã«ã€Baker (1978) ã¯ã€æœ¬æ‰‹æ³•ã®ã€Œãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã€ç‰ˆã‚’é–‹ç™ºã—ãŸãŒã€ã“ã‚Œã¯ã€ã‚¬ãƒ¼ãƒ™ã‚¸ãƒ»ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®é–“ã«è¨ˆç®—ãŒåœæ­¢ã™ã‚‹ã‚ˆã†è¦æ±‚ã—ãŸã‚Šã¯ã—ãªã„ã€‚
ã‚ã‚‹ç¨®ã®æ§‹é€ ã¯æ®ç™ºæ€§ãŒã‚ˆã‚Šé«˜ãã€ä»–ã®æ§‹é€ ã¯æ°¸ç¶šæ€§ãŒã‚ˆã‚Šé«˜ã„ã€ã¨ã„ã†äº‹å®Ÿã‚’åˆ©ç”¨ã™ã‚‹ã‚ˆã†ã€Baker ã®è€ƒãˆã¯ Hewitt ã¨ Lieberman ã¨ Moon ã«ã‚ˆã‚Šæ‹¡å¼µã•ã‚ŒãŸ (Lieberman and Hewitt 1983 ã‚’å‚ç…§)ã€‚
</p>

<p class="orig" lang="en">
An alternative commonly used garbage-collection technique is the <a name="%_idx_5956"></a><a name="%_idx_5958"></a><em>mark-sweep</em> method.  This consists of tracing all the structure
accessible from the machine registers and marking each pair we reach.
We then scan all of memory, and any location that is unmarked is
``swept up'' as garbage and made available for reuse.  A full
<a name="%_idx_5960"></a>discussion of the mark-sweep method can be found in Allen 1978.</p>

<p class="trans" lang="ja">
ã‚ˆãä½¿ã‚ã‚Œã‚‹åˆ¥ã®ã‚¬ãƒ¼ãƒ™ã‚¸ãƒ»ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³æŠ€æ³•ã¯ã€<em>ãƒãƒ¼ã‚¯ãƒ»ã‚¹ã‚¤ãƒ¼ãƒ—</em>æ³•ã§ã‚ã‚‹ã€‚
ã“ã‚Œã¯ã€ãƒã‚·ãƒ³ãƒ»ãƒ¬ã‚¸ã‚¹ã‚¿ã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ãªã™ã¹ã¦ã®æ§‹é€ ã‚’è¿½è·¡ã™ã‚‹ã“ã¨ã¨ã€ãŸã©ã‚Šç€ãå…ˆã®ãã‚Œãã‚Œã®å¯¾ã«å°ã‚’ã¤ã‘ã‚‹ã“ã¨ã‹ã‚‰ã€æˆã‚Šç«‹ã£ã¦ã„ã‚‹ã€‚
ãã‚Œã‹ã‚‰ã€ãƒ¡ãƒ¢ãƒªå…¨ä½“ã‚’èµ°æŸ»ã—ã€å°ã®ã¤ã„ã¦ã„ãªã„ã©ã®å ´æ‰€ã‚’ã‚‚ã€ã”ã¿ã¨ã—ã¦ã€Œæƒãæ¨ã¦ã€ã¦ã€å†åˆ©ç”¨ã®ãŸã‚ã«ä½¿ãˆã‚‹ã‚ˆã†ã«ã™ã‚‹ã€‚
ãƒãƒ¼ã‚¯ãƒ»ã‚¹ã‚¤ãƒ¼ãƒ—æ³•ã«ã¤ã„ã¦ã®è©³ç´°ãªè­°è«–ã¯ã€Allen 1978 ã§è¦‹ã¤ã‹ã‚‹ã€‚
</p>

<p class="orig" lang="en">
The Minsky-Fenichel-Yochelson algorithm is the dominant algorithm in
use for large-memory systems because it examines only the useful part
of memory.  This is in contrast to mark-sweep, in which the sweep
phase must check all of memory.  A second advantage of stop-and-copy
is that it is a <a name="%_idx_5962"></a><a name="%_idx_5964"></a><em>compacting</em> garbage collector.  That is, at the
end of the garbage-collection phase the useful data will have been
moved to consecutive memory locations, with all garbage pairs
compressed out.  This can be an extremely important performance
consideration in machines with virtual memory, in which accesses to
widely separated memory addresses may require extra paging
operations.</p>

<p class="trans" lang="ja">
Minsky-Fenichel-Yochelson ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯ã€å¤§è¦æ¨¡ãƒ¡ãƒ¢ãƒªå‹ã®ã‚·ã‚¹ãƒ†ãƒ ã«ä½¿ã‚ã‚Œã¦ã„ã‚‹ä¸»è¦ãªã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã§ã‚ã‚‹ã€‚ãªãœãªã‚‰ã€ã“ã‚Œã¯ã€ãƒ¡ãƒ¢ãƒªã®æœ‰ç”¨ãªéƒ¨åˆ†ã®ã¿ã‚’èª¿ã¹ã‚‹ã‹ã‚‰ã§ã‚ã‚‹ã€‚
ã“ã‚Œã¯ã€ãƒãƒ¼ã‚¯ãƒ»ã‚¹ã‚¤ãƒ¼ãƒ—â€”â€”ã‚¹ã‚¤ãƒ¼ãƒ—æ®µéšã§ãƒ¡ãƒ¢ãƒªå…¨ä½“ã‚’èª¿ã¹ãªãã¦ã¯ãªã‚‰ãªã„â€”â€”ã¨ã¯å¯¾ç…§çš„ã§ã‚ã‚‹ã€‚
ã‚¹ãƒˆãƒƒãƒ—ãƒ»ã‚¢ãƒ³ãƒ‰ãƒ»ã‚³ãƒ”ãƒ¼ã®ç¬¬äºŒã®åˆ©ç‚¹ã¯ã€ã“ã‚ŒãŒ<em>åœ§ç¸®å‹ã®</em>ã‚¬ãƒ¼ãƒ™ã‚¸ãƒ»ã‚³ãƒ¬ã‚¯ã‚¿ã§ã‚ã‚‹ã€ã¨ã„ã†ç‚¹ã§ã‚ã‚‹ã€‚
ã™ãªã‚ã¡ã€ã‚¬ãƒ¼ãƒ™ã‚¸ãƒ»ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³æ®µéšã®æœ€å¾Œã«ã¯ã€é€£ç¶šçš„ãªãƒ¡ãƒ¢ãƒªä¸Šã®å ´æ‰€ã«æœ‰ç”¨ãªãƒ‡ãƒ¼ã‚¿ãŒç§»å‹•ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã«ãªã‚‹ã ã‚ã†ã—ã€ãã®éš›ã€ã”ã¿ã®å¯¾ã¯ã™ã¹ã¦åœ§ç¸®ã•ã‚Œã¦æŠ¼ã—å‡ºã•ã‚Œã¦ã„ã‚‹ã€‚
ã“ã‚Œã¯ã€ä»®æƒ³ãƒ¡ãƒ¢ãƒªâ€”â€”åºƒç¯„å›²ã«åˆ†é›¢ã—ãŸãƒ¡ãƒ¢ãƒªãƒ»ã‚¢ãƒ‰ãƒ¬ã‚¹ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒã€ä½™è¨ˆãªãƒšãƒ¼ã‚¸ãƒ³ã‚°æ“ä½œã‚’å¿…è¦ã¨ã™ã‚‹ã‹ã‚‚ã—ã‚Œãªã„â€”â€”ã‚’æœ‰ã™ã‚‹ãƒã‚·ãƒ³ã«ãŠã‘ã‚‹ã€éå¸¸ã«é‡è¦ãªæ€§èƒ½ä¸Šã®è«–ç‚¹ã¨ãªã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã€‚
</p>

<p class="orig" lang="en">
<a name="footnote_Temp_762" href="#call_footnote_Temp_762"><sup><small>16</small></sup></a> This list of registers does not include
the registers used by the storage-allocation system -- <tt>root</tt>, <tt>the-cars</tt>, <tt>the-cdrs</tt>, and the other registers that will be
introduced in this section.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_762"><sup><small>16</small></sup></a>
ã“ã®ãƒ¬ã‚¸ã‚¹ã‚¿ã®ãƒªã‚¹ãƒˆã¯ã€è¨˜æ†¶å‰²ã‚Šå½“ã¦ã‚·ã‚¹ãƒ†ãƒ ã«ã‚ˆã‚Šä½¿ã‚ã‚Œã‚‹ãƒ¬ã‚¸ã‚¹ã‚¿â€”â€” <tt>root</tt> ã‚„ <tt>the-cars</tt> ã‚„ <tt>the-cdrs</tt> ã‚„ã€æœ¬ç¯€ã§å°å…¥ã•ã‚Œã‚‹ã§ã‚ã‚ã†ä»–ã®ãƒ¬ã‚¸ã‚¹ã‚¿â€”â€”ã‚’å«ã¾ãªã„ã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_763" href="#call_footnote_Temp_763"><sup><small>17</small></sup></a> The term <em><a name="%_idx_5982"></a>broken heart</em> was coined by David Cressey, who wrote a garbage
collector for <a name="%_idx_5984"></a><a name="%_idx_5986"></a>MDL, a dialect of Lisp developed at MIT during the early
1970s.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_763"><sup><small>17</small></sup></a>
<em><ruby><rb>å¤±æ„</rb><rp> (</rp><rt>ãƒ–ãƒ­ãƒ¼ã‚¯ãƒ³ãƒ»ãƒãƒ¼ãƒˆ</rt><rp>) </rp></ruby></em>ã¨ã„ã†ç”¨èªã¯ã€David Cressey â€”â€”1970å¹´ä»£åˆé ­ã« MIT ã§é–‹ç™ºã•ã‚ŒãŸã€Lisp ã®æ–¹è¨€ã§ã‚ã‚‹ MDL ã®ãŸã‚ã®ã€ã‚¬ãƒ¼ãƒ™ã‚¸ãƒ»ã‚³ãƒ¬ã‚¯ã‚¿ã‚’æ›¸ã„ãŸâ€”â€”ã«ã‚ˆã‚Šã€ä½œã‚‰ã‚ŒãŸã€‚
</p>

<p class="orig" lang="en"><a name="footnote_Temp_764" href="#call_footnote_Temp_764"><sup><small>18</small></sup></a> The garbage collector uses the low-level predicate
<tt>pointer-to-pair?</tt> instead of the list-structure <tt>pair?</tt>
operation because in a real system there might be various things
that are treated as pairs for garbage-collection purposes.
For example, in a Scheme system that conforms to the IEEE standard
a procedure object may be implemented as a special kind of ``pair''
that doesn't satisfy the <tt>pair?</tt> predicate.
For simulation purposes, <tt>pointer-to-pair?</tt> can be implemented as
<tt>pair?</tt>.</p>

<p class="trans" lang="ja">
<a href="#call_footnote_Temp_764"><sup><small>18</small></sup></a> 
ã‚¬ãƒ¼ãƒ™ã‚¸ãƒ»ã‚³ãƒ¬ã‚¯ã‚¿ã¯ã€ãƒªã‚¹ãƒˆæ§‹é€ ã® <tt>pair?</tt> æ¼”ç®—ã®ä»£ã‚ã‚Šã«ã€<tt>pointer-to-pair?</tt> ã¨ã„ã†ä½æ°´æº–ã®è¿°èªã‚’ç”¨ã„ã‚‹ã€‚ãªãœãªã‚‰ã€ã‚¬ãƒ¼ãƒ™ã‚¸ãƒ»ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®ç›®çš„ã§ã¯å¯¾ã¨ã—ã¦æ‰±ã‚ã‚Œã‚‹æ§˜ã€…ãªã‚‚ã®ãŒã€ç¾å®Ÿã®ã‚·ã‚¹ãƒ†ãƒ ã«ã¯å­˜åœ¨ã™ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã‹ã‚‰ã§ã‚ã‚‹ã€‚
ãŸã¨ãˆã°ã€IEEE æ¨™æº–ã«åˆè‡´ã™ã‚‹ Scheme ã‚·ã‚¹ãƒ†ãƒ ã§ã¯ã€æ‰‹ç¶šãã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã€<tt>pair?</tt> è¿°èªã‚’æº€ãŸã•ãªã„ã‚ˆã†ãªç‰¹åˆ¥ãªç¨®é¡ã®ã€Œå¯¾ã€ã¨ã—ã¦ã€å®Ÿè£…ã•ã‚Œã¦ã‚‚ã‚ˆã„ã€‚
ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ç›®çš„ã§ã¯ã€<tt>pointer-to-pair?</tt> ã‚’ <tt>pair?</tt> ã¨ã—ã¦å®Ÿè£…ã§ãã‚‹ã€‚
</p>


</div>
</body>
</html>
